#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ Notes - C++ Tooling
#+DESCRIPTION: c c++ cpp tooling utilities instrumentation 


* Tooling 
** Online Tools 
*** Online Online Compilers                                        :compiler:

    + https://coliru.stacked-crooked.com/
      + The only online compiler which supports C++17 and the experimental
        C++20. 

    + http://rextester.com/
      + The main selling point of this online tool is that it allows to
        save code snippets and run them again. 
      + Online C++ compiler, provides GCC, CLANG and Visual Studio
        Compiler, also known as MSVC (VC++ - Visual C++).
      + Supports Boost libraries.

    + https://repl.it/languages/cpp11
      + Oline compiler (GCC / C++11 only) with REPL support.

    + https://wandbox.org/ (Best)
      + Supports C++11, C++14, C++17 and C++20a (draft).
      + Supports Boost libraries.
      + Supported Languages other C++:
        + Non-managed languages: C, Rust, D, Go C#, CMake,  Nim, Haskell, Nim
        + Managed languages: C#, Java,  R, Scala, Swift, PHP, Ruby, SQL
          and so on.
*** Online Compiler Explorers                                      :compiler:

    + https://godbolt.org/ [BEST]
      * Compiler explorer - allows to explore the assembly generated by a
        wide variety of compilers, including, GNU GCC, Clang, MSVC and
        so on.

    + https://cppinsights.io
      + "C++ Insights is a clang-based tool which does a source to
        source transformation. Its goal is to make things visible which
        normally, and intentionally, happen behind the scenes. It's
        about the magic the compiler does for us to make things
        work. Or looking through the classes of a compiler. You can
        see, for example the transformation of a lamda, range-based
        for-loop or auto. Of course, you can transform any other C++
        snippet. "

    + https://demangler.com/
      * Symbol demangler for MSVC, GCC and Clang.

    + http://quick-bench.com
      + Tool for micro benchamrks  

    + http://metashell.org/index.html
      + Tool for visualizing template expansion 
*** Misc Online Tools 

  *Regex Testers* 

  + https://myregextester.com/index.php

  + [[https://regexr.com/][RegExr: Learn, Build, & Test RegEx]]

  + https://regex101.com/

  *UML Ascii/Text Drawing Tools*
    * [[http://asciiflow.com/][ASCIIFlow Infinity]] (Pick-and place)
      * Allows to draw Ascii UML box diagrams by dragging and dropping
        like in MS-Paint.

    * http://stable.ascii-flow.appspot.com/ (Pick-and place)

    * https://textik.com/ (Pick-and place)

    * https://www.planttext.com/ (Latex-like)

    * https://textart.io/sequence  (Latex-like)
      * UML Sequence Diagram drawing tool. The user writes the commands
        and the tool draws the diagram. It adopts an approach similar
        to Tex/Latex.

  * *MISC*
    + [[https://www.google.ca/search?q=float%20point%20online][float point online - Google Search]]
    + [[https://www.h-schmidt.net/FloatConverter/IEEE754.html][IEEE-754 Floating Point Converter]]
    + [[http://weitz.de/ieee/][IEEE 754 Calculator]]
** General

 * Documentation Builder, aka Generator 
   + Doxygen => http://www.doxygen.org/
   
 * IDEs and Quasi-IDEs

   + *Visual Studio Community Edition* (Windows Only)

   + *CLion* / JetBrains 

   + GNome Builder => Not an IDE, but at least the code completion
     "just works" without any configuration. 
     + https://wiki.gnome.org/Apps/Builder/Features
     + https://www.collabora.com/news-and-blog/blog/2018/08/03/cross-compilation-made-easy-for-gnome-builder/

 * Building Systems
   + CMake
     + https://cmake.org/documentation/
   + Meson
     + https://github.com/mesonbuild/meson/wiki
   + SCons
     + https://scons.org/
   + Make (GNU Make, BSD Make or Windows MAKE - NMake)
     + https://en.wikipedia.org/wiki/Makefile
   + Ninja
     + https://ninja-build.org/

 * Package Managers:
   + https://conan.io/
   + [[https://docs.microsoft.com/en-us/cpp/vcpkg?view=vs-2017][vcpkg-- A C++ package manager for Windows, Linux and MacOS | Microsoft Docs]]
   + [[http://www.buckaroo.pm/][Buckaroo - C/C++ Package Manager]]
   + [[https://gist.github.com/Overdrivr/d14e4c7e79234f1fb7b3a5a14f8b6ad9][Why C/C++ package managers fail for now ?]]

 * Source Code Naviagator => Helpers for understanding code. 
   + Source Trail => https://www.sourcetrail.com/
   + CPPDepend

 * *Debuggers* - Essential tools for development, debugging,
   introspecing processes, reversing engineering and security
   research.
   + GDB  - GNU Debugger 
   + LLDB - LLVM/Clang Debugger
   + WinDG -> Windows Debugger 
   + IDA

** Static code analysers                                     :quality:qa:bug:

Tools for performing static analysis in the code and catching bugs
easily go unnoticed.

 * *Cppcheck*
   + "Cppcheck is a static analysis tool for C/C++ code. It provides
     unique code analysis to detect bugs and focuses on detecting
     undefined behaviour and dangerous coding constructs. The goal is
     to detect only real errors in the code (i.e. have very few false
     positives)."
   + Web Site: http://cppcheck.sourceforge.net/

 * *Clang Analyser*
   + "The Clang Static Analyzer is a source code analysis tool that
     finds bugs in C, C++, and Objective-C programs. Currently it can
     be run either as a standalone tool or within Xcode. The
     standalone tool is invoked from the command line, and is intended
     to be run in tandem with a build of a codebase. The analyzer is
     100% open source and is part of the Clang project. Like the rest
     of Clang, the analyzer is implemented as a C++ library that can
     be used by other tools and applications."
   + Web Site: https://clang-analyzer.llvm.org

 * *Splint - Annotation-Assisted Lightweight Static Checking*
   + "Splint is a tool for statically checking C programs for _security_
     _vulnerabilities_ and coding mistakes. With minimal effort, Splint
     can be used as a better lint. If additional effort is invested
     adding annotations to programs, Splint can perform stronger
     checking than can be done by any standard lint."
   + Web Site: https://splint.org

 * *OCLint*
   + "OCLint is a static code analysis tool for improving quality and
     reducing defects by inspecting C, C++ and Objective-C code and
     looking for potential problems like: Possible bugs - empty
     if/else/try/catch/finally statements; Unused code - unused local
     variables and parameters; Complicated code - high cyclomatic
     complexity, NPath complexity and high NCSS; Redundant code -
     redundant if statement and useless parentheses; Code smells -
     long method and long parameter list; Bad practices - inverted
     logic and parameter reassignment" 

** Sanitizers 

 + [[https://github.com/google/sanitizers][google/sanitizers]]
   + "This project is the home for Sanitizers: AddressSanitizer,
     MemorySanitizer, ThreadSanitizer, LeakSanitizer, and more The
     actual code resides in the LLVM repository. Here we keep extended
     documentation, bugs and some helper code."

   + [[https://github.com/google/sanitizers/wiki/AddressSanitizer][AddressSanitizer]] - AddressSanitizer (aka ASan) is a memory error detector for C/C++.

   + [[https://github.com/google/sanitizers/wiki/MemorySanitizer][MemorySanitizer]]

   + [[https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html][HWASAN]]

   + [[https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html][UBSAN]] - Undefined Behavior Sanitizer

** Memory Leak Debuggers                                     :quality:qa:bug:

 + [[http://www.valgrind.org/][Valgrind]]
   + Most well known memory leak debugger for *Nix
     systems. Unfortunately, it doesn't work on Windows.
   + [[https://en.wikipedia.org/wiki/Valgrind][Valgrind - Wikipedia]]
   + [[http://doc.qt.io/qtcreator/creator-valgrind-overview.html][Using Valgrind Code Analysis Tools | Qt Creator Manual]]

 + [[http://drmemory.org/][Dr. Memory Memory Debugger for Windows and Linux]]
   + "Dr. Memory is a memory monitoring tool capable of identifying
     memory-related programming errors such as accesses of
     uninitialized memory, accesses to unaddressable memory (including
     outside of allocated heap units and heap underflow and overflow),
     accesses to freed memory, double frees, memory leaks, and (on
     Windows) handle leaks, GDI API usage errors, and accesses to
     un-reserved thread local storage slots." 

See also: 
 + [[https://stackoverflow.com/questions/413477/is-there-a-good-valgrind-substitute-for-windows][c - Is there a good Valgrind substitute for Windows? - Stack Overflow]]

** Profiling Tools - Performance Measurement Tools    :qa:quality:speed:perf:

  * *perf* - Performance Monitoring and Analysis tool for Linux
    * https://developers.redhat.com/blog/2019/04/23/how-to-use-the-linux-perf-tool-to-count-software-events/
    * https://www.tecmint.com/perf-performance-monitoring-and-analysis-tool-for-linux/
    * http://lacasa.uah.edu/portal/Upload/tutorials/perf.tool/PerfTool.pdf
    * https://qqibrow.github.io/CPU-Cache-Effects-and-Linux-Perf/
    * https://www.slideshare.net/brendangregg/kernel-recipes-2017-using-linux-perf-at-netflix

  * *Very Sleepy* - Profile for Microsft Windows OS 
    * http://www.codersnotes.com/sleepy/

  * [[http://valgrind.org/docs/manual/cg-manual.html][cachegrind / valgrind]] - (CPU Caches L1, L2, L3)
    + cache-branch prediction profiler - "Cachegrind simulates how your
      program interacts with a machine's cache hierarchy and
      (optionally) branch predictor. It simulates a machine with
      independent first-level instruction and data caches (I1 and D1),
      backed by a unified second-level cache (L2). This exactly matches
      the configuration of many modern machines."
    + See also:
      + [[https://accu.org/index.php/journals/1886][Valgrind Part 4: Cachegrind and Callgrind]]

  * [[http://valgrind.org/docs/manual/cl-manual.html][callgrind / valgrind]] (Call graph)
    + "Callgrind is a profiling tool that records the call history
      among functions in a program's run as a call-graph. By default,
      the collected data consists of the number of instructions
      executed, their relationship to source lines, the caller/callee
      relationship between functions, and the numbers of such
      calls. Optionally, cache simulation and/or branch prediction
      (similar to Cachegrind) can produce further information about
      the runtime behavior of an application." 

  * [[http://valgrind.org/docs/manual/hg-manual.html][helgrind / valgrind]] (Threads and concurrency)
    * "Helgrind is a Valgrind tool for detecting synchronisation
      errors in C, C++ and Fortran programs that use the POSIX
      pthreads threading primitives. The main abstractions in POSIX
      pthreads are: a set of threads sharing a common address space,
      thread creation, thread joining, thread exit, mutexes (locks),
      condition variables (inter-thread event notifications),
      reader-writer locks, spinlocks, semaphores and
      barriers. Helgrind can detect three classes of errors, which are
      discussed in detail in the next three sections: Misuses of the
      POSIX pthreads API; Potential deadlocks arising from lock
      ordering problems and Data races -- accessing memory without
      adequate locking or synchronisation."

  * [[https://github.com/gperftools/gperftools][gperftools]] - Google's Performance Tools
    * https://gperftools.github.io/gperftools/cpuprofile.html
    * https://github.com/gperftools/gperftools/wiki
    * https://wiki.geany.org/howtos/profiling/gperftools

** Clang/LLVM tools 

 + [[https://lldb.llvm.org/][LLDB Debugger]]
   + "LLDB is a next generation, high-performance debugger. It is
     built as a set of reusable components which highly leverage
     existing libraries in the larger LLVM Project, such as the Clang
     expression parser and LLVM disassembler. LLDB is the default
     debugger in Xcode on macOS and supports debugging C, Objective-C
     and C++ on the desktop and iOS devices and simulator."

 + [[https://clang.llvm.org/extra/clang-tidy/][clang-tidy]] - Automating the formatting of C or C++ code according
   to some style. 
   + "clang-tidy is a clang-based C++ 'linter' tool. Its purpose is to
     provide an extensible framework for diagnosing and fixing typical
     programming errors, like style violations, interface misuse, or
     bugs that can be deduced via static analysis. clang-tidy is
     modular and provides a convenient interface for writing new
     checks."
   + See:
     + https://www.kdab.com/clang-tidy-part-1-modernize-source-code-using-c11c14/
     + https://codeyarns.com/2019/01/28/how-to-use-clang-tidy/

 + [[https://devblogs.microsoft.com/cppblog/exploring-clang-tooling-part-2-examining-the-clang-ast-with-clang-query/][clang-query]]
   + Tool for exploring the Clang AST - Abstract Syntax Tree from a
     C++ code base.
   + See:
     * https://clang.llvm.org/docs/LibASTMatchers.html
     * https://steveire.wordpress.com/2018/11/11/future-developments-in-clang-query/
     * https://eli.thegreenplace.net/2014/07/29/ast-matchers-and-clang-refactoring-tools
     * https://clang.llvm.org/docs/LibASTMatchersReference.html

 + [[https://clang.llvm.org/docs/RefactoringEngine.html][clang-refactor]] - Clang Refactoring engine
   + "This document describes the design of Clang’s refactoring engine
     and provides a couple of examples that show how various
     primitives in the refactoring API can be used to implement
     different refactoring actions. The LibTooling library provides
     several other APIs that are used when developing a refactoring
     action. Refactoring engine can be used to implement local
     refactorings that are initiated using a selection in an editor or
     an IDE. You can combine AST matchers and the refactoring engine
     to implement refactorings that don’t lend themselves well to
     source selection and/or have to query ASTs for some particular
     nodes."

 + [[https://clang.llvm.org/extra/clang-rename.html][clang-rename]]
   + "clang-rename is a C++ refactoring tool. Its purpose is to
     perform efficient renaming actions in large-scale projects such
     as renaming classes, functions, variables, arguments, namespaces
     etc. The tool is in a very early development stage, so you might
     encounter bugs and crashes. Submitting reports with information
     about how to reproduce the issue to the LLVM bugtracker will
     definitely help the project. If you have any ideas or
     suggestions, you might want to put a feature request there."

** Windows Development

 + *SysInternals* - A collection of debugging tools which allows to
   introspect processes and get informations such as loaded DLLs,
   files opened by a process, network activity and so on.
   + https://docs.microsoft.com/en-us/sysinternals/
   + http://www.sysinternals.com/
   + https://docs.microsoft.com/en-us/sysinternals/downloads/process-utilities

 + *Sysinternals* / dumpbin
   + Show informations Windows native executables and shared
     libraries, specifically about PE32 object code. For instance, it
     can show symbols exported by a DLL, DLLs used by an executable
     and functions imported by the executable from DLLs.

 + *Sysinternals* / procmon
   + Process mionitor

 + *Sysinternals* / procexp
   + Process explorer

 + *Sysinternals* / Winobj
   + WinObj accesses and display information on the NT Object
     Manager's name space

 + *Dependency Walker* - Tool which scans executable dependencies such
   as imported DLLs.
   + http://www.dependencywalker.com/ 

** Documentation Generator 

 + [[http://www.doxygen.nl/][Doxygen]] 
   + Doxygen builds documentatiuon in many formats including text and
     html by extracting documentation code from comments.
   + Example of documentation generated with Doxygen:
     + https://docs.wxwidgets.org/stable/
     + http://assimp.sourceforge.net/lib_html/index.html
     + [[http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/dir_db160b4728e6067cf5f9cc14ec42c79d.html][libEvent]]

** Compiler Metadata Generators

 + [[https://pygccxml.readthedocs.io/en/develop/upgrade_issues.html][GCC-XML 0.7 → 0.9 upgrade issues (Legacy) — pygccxml 1.9.1 documentation]]    

** Assembly for x86 and x64 

  + https://godbolt.org/
    + Compiler explorer - allows to explore the assembly generated by a
      wide variety of compilers, including, GNU GCC, Clang, MSVC and so
      on.

  + [[https://github.com/zerosum0x0/WinREPL][WinREPL]] - Assembly REPL - interactive shell like Python or IPython
    for Windows.
    + Precompile binaries: https://github.com/zerosum0x0/WinREPL/releases/

  + [[https://github.com/yrp604/rappel][Rappel]] - A linux-based assembly REPL for x86, amd64, armv7, and armv8.
    + [[https://news.ycombinator.com/item?id=11214868][Rappel: A REPL for x86, amd64, and armv7 | Hacker News]]

  + [[https://www.radare.org/r/][radare]] Framework - A suite of reversing enegineering tools.
    + Features:
      * Disassemble (and assemble for) many different architectures
      * Debug with local native and remote debuggers (gdb, rap, webui, r2pipe, winedbg, windbg)
      * Run on Linux, *BSD, Windows, OSX, Android, iOS, Solaris and Haiku
      * Perform forensics on filesystems and data carving
      * Be scripted in Python, Javascript, Go and more
      * Support collaborative analysis using the embedded webserver
      * Visualize data structures of several file types
      * Patch programs to uncover new features or fix vulnerabilities
      * Use powerful analysis capabilities to speed up reversing
      * Aid in software exploitation

  + [[http://www.unicorn-engine.org/][Unicorn]] - CPU emulator Framework
    + https://github.com/unicorn-engine/unicorn  

** Unix and Linux Development 

The following tools are not only useful for debugging, diagnosing and
assisting development, they are also useful for reverse engineering. 

Note: 
 + object files: executables and shared libraries (*.so files),
   generally with ELF format.

| Tool / Command            | Description                                                  |
|---------------------------+--------------------------------------------------------------|
| file                      | identify file type by its header bytes                       |
| nm                        | list symbols exported by executables                         |
| c++filt                   | demangles C++ symbols                                        |
| objdump                   | show detailed information about object files                 |
| readlef                   | show information about ELF object files.                     |
| strings                   | show human readable characters in the executable             |
| strip                     | discard symbols                                              |
| ptrace and strace         | trace system calls                                           |
| gdb                       | GNU Debugger                                                 |
| lsof                      | Check which files a process is using                         |
| Directory /etc/proc/<pid> | Allows to check which files and resources a process is using |
|                           |                                                              |
|---------------------------+--------------------------------------------------------------|

** Emacs as a C++ IDE 

Misc: 

 + [[https://nilsdeppe.com/posts/emacs-c++-ide2][Using Emacs as a C++ IDE - Take 2]]
 + [[http://martinsosic.com/development/emacs/2017/12/09/emacs-cpp-ide.html][Emacs as a C++ IDE]]
 + [[https://oremacs.com/2017/03/28/emacs-cpp-ide/][Using Emacs as a C++ IDE · (or emacs]]
 + [[https://tuhdo.github.io/c-ide.html][C/C++ Development Environment for Emacs]]
 + [[https://www.reddit.com/r/emacs/comments/7wzstc/emacs_as_a_c_ide_martin_sosics_blog/][Emacs as a C++ IDE - Martin Sosic's blog : emacs]]

Using Emacs a GDB Front-end (aka user interface): 

 + [[https://www.cs.bu.edu/teaching/tool/emacs/programming/][Using Emacs for Programming]]   
