#+INCLUDE: theme/style.org
#+TITLE: CPP / C++ Review
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

 - [[wiki:index][Index]]

* Understanding C++ 
** C++ Benefits and Costs 

Some C++ compelling features which sets it apart from most
programming languages are: 

 + Compilation to native code.
 + High Performance and zero-cost abstractions.
 + Hardware portability and compiler availability for many processor
   and hardware architechtures. C++ has the widest range of processor
   support, so it can run on mainstream x86, desktop processors;
   mobile phone ARM-based CPUs; GPUs; embedded processors and
   microcontrollers.
 + Direct access to the operating system C-API and system calls.
 + Interoperability with C libraries.
 + Direct Access to Memory which is important on embedded systems for
   accessing memory-mapped IO devices.

 Disadvantages: 

 + Language complexity

 + Lack of a comprehensive standard library. 

 + Compiler's cryptic error messages. 

 + Lack of agreed package manager.

 + ABI - Application Binary Interface Issues - due the
   non-standardized ABI, it is almost impossible to link object-code
   (aka compiled code) compiled with different compilers. This is why,
   unlike Java and C#,  there is almost no pre-compiled libraries for
   C++ what makes the binary reuse hard.

** C++ New Features and Standards

 + *C++11*
   + C++11 Working Draft  http://wg21.link/n3242
   + See:
     + [[https://isocpp.org/wiki/faq/cpp11-language#auto][C++11 Language Extensions — General Features, C++ FAQ]]
     + http://www.windowscpp.com/CPP11FAQ.htm
   + Features which supports Functional Programming 
     + auto keyworkd for type deduction (aka type inference)
       + Which relieves the developer from writing all types and
         simplifies the code.
     + Lambda functions and std::function
       - Introduces the functional programming paradigm in C++ allowing
         users to write higher-order functions and reusable algorithms.
     + Tuples
       + allows returning multiple values 
     + Move Semantics:
       - Transfer resource ownership from temporary objects. This
         feature removes the runtime overhead of temporary objects and
         also allows to return containers such as vectors, string and
         etc from functions without runtime overhed or deep copy.
   + Library Support 
     + Smart Pointers => ~unique_ptr~ and ~shared_ptr~
       - Provides memory and resource management making the programs
         less prone to memory or resource leaks. Those pointers
         implments the RAII (Resource Acquisition is Initialization)
         idiom which takes advantage of C++ deterministic destructor for
         releasing resources no longer needed.
     + Regex
     + Cross-platform concurrency features.
       + Example: threads, monitors and locks which works on all
         supported platforms and operating systems.
   + Misc
     + nullpr - type-safe null pointer 
     + Ranged-based loop
   + Compile-time metaprogramming features 
     + Variadic Templates
     + Contexpr
       - Allows compile-time computations such as computing
         random numbers, encrypting string at runtime or generating
         look-up tables.
     + Static assert
     + String literals
     + User-defined literals 
 + *C++14*
   + C++14 Working Draft - http://wg21.link/n4296
   + See: [[https://isocpp.org/wiki/faq/cpp14-language][C++14 Language Extensions, C++ FAQ]]
   + _Binary Literals_: int x = 0b1001001 -> This feature is useful for
     embedded systems and dealing with bitmasks and hardware
     registers.
   + _Digit Separators_ - allows to write the number pi = 3.1415927 as pi = 3.141'592'7
   + _Generalized return type deduction_.
   + decltype(auto)
   + Genric Lambda - Now it is possible to use the keyword auto for
     deducing or infering the type of lambda arguments.
   + Variable Templates
   + _Extended Constexpr_ - contexpr functions can have loops, mutating
     variables and don't need to be recursive as it was before,
     consequently constexpr is able to peform more complex
     compile-time computations. 
   + [ [ deprecated ] ] attribute -> enables annotating an entity as
     deprecated and prints a compilation warn if a deprecated entity
     is used.
 + *C++17*
   + C++17 Working Draft - http://wg21.link/n4659
   + See:
     + http://www.cppstd17.com/
     + https://isocpp.org/wiki/faq/cpp17-language
     + [[https://www.infoworld.com/article/3044727/application-development/qa-bjarne-stroustrup-previews-c-17.html][Q&A: Bjarne Stroustrup previews C++ 17 | InfoWorld]]
   + std::any
   + std::variant
   + std::optional
   + key, value decomposition
   + Parallel algorithms
   + structured bindings
   + nested namespaces
   + File system libraries 
   + ... and much more ...!!
 + *C++20* - Coming soon.

Compiler Support: 

 + [[https://en.cppreference.com/w/cpp/compiler_support][C++ compiler support - cppreference.com]]
 + [[https://www.gnu.org/software/gcc/projects/cxx-status.html][C++ Standards Support in GCC - GNU Project - Free Software Foundation (FSF)]]
 + [[https://software.intel.com/en-us/articles/c17-features-supported-by-intel-c-compiler][C++17 Features Supported by Intel® C++ Compiler | Intel® Software]]
 + [[https://docs.microsoft.com/en-us/cpp/visual-cpp-language-conformance?view=vs-2017][Visual C++ Language Conformance | Microsoft Docs]]
** C++ Comparison with C, Java and C#

General overview: Unlike most object oriented languages such as Java
and C#, C++ doesn't have a class hierarchy, single inheritance,
garbage collection and a comprehensive standard library. However in
some situations, C++ benefits such as direct access to the operating
system, memory, system calls and low level; interoperability with C
libraries; and above all, high performance computing may offset the
language complexity costs.

This table shows a comparison between C++ and mainstreams object
oriented programming languages like Java and C#.


| Feature                                | C++                                   | Java               | C# - .NET |
|----------------------------------------+---------------------------------------+--------------------+-----------|
| Native Code                            | Yes                                   | No                 | No        |
| JIT - Just-In-Time Compilation         | No  - No needed, since C++ is native. | Yes                | Yes       |
| Virtual Machine                        | No                                    | Yes                | Yes       |
| Garbage Collection                     | No                                    | Yes                | Yes       |
| Memory Management                      | semi-automatic                        | auto               | auto      |
|                                        |                                       |                    |           |
| *Object Oriented Features*               |                                       |                    |           |
| OOP - Object Oriented                  | Yes                                   | Yes                | Yes       |
| Class Hierarchy                        | No                                    | Yes                | Yes       |
| Reflection                             | No                                    | Yes                | Yes       |
| Single Inheritance                     | No                                    | Yes                | Yes       |
| Multiple Inheritance                   | Yes                                   | No                 | No        |
| Properties                             | No                                    | No                 | Yes       |
| Inner classes, aka nested classes      | Yes                                   | Yes                | Yes       |
| Anonymous classes                      | No                                    | Yes                | No        |
| Operator Overloading                   | Yes                                   | Not                | Yes       |
| Marshalling                            |                                       |                    |           |
| Conditional Compilation - preprocessor | Yes                                   | No                 | Yes       |
| Lambda functions                       | Yes  - since C++11                    | Yes - since Java 8 | Yes       |
| Generics                               | Yes                                   | Yes                | Yes       |
| *Template metaprogramming              | Yes                                   | No                 | No        |
| Dependency, package manager            | No                                    | Yes                | Yes       |
|                                        |                                       |                    |           |
| *Standard Library Features*              |                                       |                    |           |
| Broad Cross Platform Support           | No - Provided by boost library.       | Yes                | No        |
| GUI toolkit in standard library        | No                                    | Yes                | Yes       |
| Collection Library                     | Yes - STL.                            | Yes                | Yes       |
| Sockets                                | No - Provided Boost library.          | No                 | No        |
| Threads                                | No - It is OS dependent.              | Yes                | Yes       |
| File System                            | C++ 11 -> No, C++17 -> Yes.           | Yes                | Yes       |
|                                        |                                       |                    |           |
|                                        |                                       |                    |           |

*Main Differences between C++ and other languages*

 + Value Semantics => Classes are trated as primitive types by default.
 + Objects can be allocated on the stack and on the heap.
 + Deterministic Destructor - the destructor method is always called
   when the object goes out of escope. 
 + Minimal standard library
 + Template Metaprogramming - which allows type-safe code generation
   with zero rutime overhead.
 + Pointers => Most languages doesn't provide access to pointers and
   calling C-libraries directly. 

*C++ Terminology* 

C++ has a different terminology from mainstream programming languages
which is shown in the following table.

| C++                    | Other OOP Languages                             | Comment                                                                                   |
|                        | i.e: Java, Python, ...                          |                                                                                           |
|------------------------+-------------------------------------------------+-------------------------------------------------------------------------------------------|
| Class                  | Class                                           | C++ class' fields and methods are private by default.                                     |
| Struct                 | Class                                           | A C++ is the same as a Class, but fields and methods are public by default.               |
| Class or Struct        | Abstract Class                                  | A C++ abstract class have at least one _virtual function_.                                  |
| Class or Struct        | Interface                                       | A C++ interface is a class signature with only pure virtual functions (abstract methods.) |
|                        |                                                 |                                                                                           |
| Member Function        | Instance methods                                |                                                                                           |
| Static Member Function | Static method                                   |                                                                                           |
| Virtual Functions      | -                                               | Only methods annoted with virtual  can overriden by subclasses                            |
| Non Virtual Functions  | -                                               | Methods without _virtual_ annotation cannot be overriden by subclasses.                     |
| Pure Virtual Function  | Abstract method (method without implementation) |                                                                                           |
| STL Containers         | Collection library - Lists, Maps, Tuples ...    | C++ name its collections as containters                                                   |
|                        |                                                 |                                                                                           |


*Java X C++ Collections Comparison*


| Java                 | C++                |
|----------------------+--------------------|
| java.util.ArrayList  | std::vector        |
| java.util.LinkedList | std::list          |
| java.util.Stack      | std::stack         |
| java.util.Queue      | std::queue         |
| java.util.Deque      | std::deque         |
| java.util.TreeSet    | std::set           |
| java.util.HashSet    | std::unordered_set |
| java.util.TreeMap    | std::map           |
| java.util.HashMap    | std::unordered_map |
|                      |                    |
  
                     
See: 
  + [[wiki-asset-sys:C++ - CPP Programming;CppFor Java Programmers - Hans Dulimatra.pdf][CppFor Java Programmers - Hans Dulimatra.pdf]]
  + [[https://en.wikiversity.org/wiki/Java_Collections_Overview][Java Collections Overview - Wikiversity]]

** Comparison C X C++(CPP)

|                         | C                                                 | C++                                                            |
|-------------------------+---------------------------------------------------+----------------------------------------------------------------|
| Creator                 | Dennis Ritchie                                    | Bjarne Stroustrup                                              |
| Paradigms               | Procedural / Imperative                           | Imperative, Object Orientated, Meta programming and Functional |
| Standard and Stable ABI | Yes                                               | No                                                             |
| Garbage Collector       | No                                                | No                                                             |
| Memory Management       | Manual                                            | Manual and Automatic                                           |
| Exceptions              | No                                                | Yes                                                            |
| Namespaces              | No                                                | Yes                                                            |
| Some use cases          | Low level system programming and embedded systems | High Performance Computing, Games, ...                         |
| Extensions              | .c (C-source code) and .h (header file)           | .cpp (c++ source code) and .hpp (c++ header file).             |
|                         |                                                   |                                                                |
|                         |                                                   |                                                                |

*File Extensions*

   + Source Files
     + *.cpp - C++ source files.
     + *.hpp - C++ header files.
     + *.o   - Object Code

   + Windows
     - *.exe - PE32 - Windows Executable
     - *.dll - Windows Shared Library

   + Unix (Linux, BSD ...)
     - (No extension or *.bin) - ELF - Unix Executable
     - *.so - Unix Shared Library

*Primitive Data Types*

| Type           | stdint.h type | Size (Bytes) | Size (Bits) | Range       | Description                                          |
|----------------+---------------+--------------+-------------+-------------+------------------------------------------------------|
| bool           |               |            1 |           8 |             | Boolean 0 (false) or 1 (true)                        |
| char           |               |            1 |           8 |             | Ascii character                                      |
| unsigned char  | uint8_t       |            1 |           8 | 0 to 255    | 1 byte integer                                       |
| signed char    | int8_t        |            1 |           8 | -128 to 127 |                                                      |
|                |               |              |             |             |                                                      |
| short          | int16_t       |            2 |          16 |             | 16 bits signed integer                               |
| unsigned short | uint16_t      |            2 |          16 |             |                                                      |
|                |               |              |             |             |                                                      |
| int            | int32_t       |            4 |          32 |             | 32 bits signed integer                               |
| unsigned int   | uint32_t      |            4 |          32 |             | 32 bits unsigned integer                             |
|                |               |              |             |             |                                                      |
|                |               |              |             |             |                                                      |
| float          |               |            4 |          32 |             | 32 bits IEEE 754 single-precision float point number |
| double         |               |            8 |          64 |             | 64 bits IEEE 754 double-precision float point Number |
| long double    |               |           10 |          80 |             | Extended precision non-IEEE float point number       |
|                |               |              |             |             |                                                      |


 - Note: The type char can be understood as an 8-bits integer. 
** Value Semantics X Reference Semantics 

 According to the - [[https://isocpp.org/wiki/faq/value-vs-ref-semantics][ISO C++]], value and reference semantics are defined
 as: 

 #+BEGIN_QUOTE
   With reference semantics, assignment is a pointer-copy (i.e., a
   reference). Value (or “copy”) semantics mean assignment copies the
   value, not just the pointer. C++ gives you the choice: use the
   assignment operator to copy the value (copy/value semantics), or use
   a pointer-copy to copy a pointer (reference semantics). C++ allows
   you to override the assignment operator to do anything your heart
   desires, however the default (and most common) choice is to copy the
   value.
 #+END_QUOTE

  *Definitions:*

 _Reference Semantics_: Behavior where composite types are passed by
 reference when assigned; passed as function or method parameters or
 returned from functions. This is the default behavior of most object
 oriented programming languages, except C++.
 
 In Java, C#, Scala, Python and etc. Objects have reference semantics
 by default. This example in Scala programming language shows how
 _reference semantics_ works in most languages.

 #+BEGIN_SRC scala 
   class Foo(name: String){
     private var _name = name
     def setName(name: String) =
       _name = name
     def getName() =
       name
     override def toString() =
       s"Foo { name = $name }"
   }

   scala> var x = 10
   x: Int = 10

   // Primitive types have value semantics: assignment of variables of
   // primitive types, creates a copy, so both variables can be modified
   // without changing each other.
   scala> var y = x
   y: Int = 10

   // By modifying x, the value of y remains the same.
   scala> x = 25
   x: Int = 25

   scala> y
   res5: Int = 10

   scala> 

   //===> Composite and complexity types have reference semantics by default 
   // in languages other than C++.

   scala> val foo = new Foo("bar")
   foo: Foo = Foo { name = bar }

   // Assignment doesn't create a copy like assignment 
   // of primitive type, actually the assignment creates 
   // a reference to the object foo. As result, modifying 
   // one of the objects, modifies the other.
   scala> val bar = foo
   bar: Foo = Foo { name = bar }

   // Modifying bar modifes foo. 
   scala> bar.setName("something")

   scala> bar
   res3: Foo = Foo { name = something }

   scala> foo
   res4: Foo = Foo { name = something }

   // Passing as function parameter doesn't create a copy like in C++, 
   // it passes the object by reference, so if the parameter is modified inside
   // the function, the original object will be modified too. 
    def setFooPrint(param: Foo){
      param.setName("dummy name")
      println(foo)
    }

    scala> setFooPrint(foo)
    Foo { name = dummy name }

    scala> foo
    res8: Foo = Foo { name = dummy name }

    // Returning an object from a function doesn't create a copy as would happen 
    // with primitive types.
    def modifyReturn(param: Foo, newName: String) = {
      param.setName(newName)
      param
    }
    scala> val foob = modifyReturn(foo, "Scala + C++ + JNI == HPC")
    foob: Foo = Foo { name = Scala + C++ + JNI == HPC }

    scala> foo
    res9: Foo = Foo { name = Scala + C++ + JNI == HPC }
 #+END_SRC

 _Value Semantics_: Behavior where composite types such as instances of
 classes are treated as primitive type such as booleans, integers or
 float point numbers. In the value semantics, a copy is created when
 variables are assigned; passed as parameters to functions or methods
 and returned from functions. So modifying one of the variables doesn't
 change the other. 

Unlike other languages, C++ uses value semantics by default, it means
that in operations such as assignment; returning objects from
functions and passing objects as parameters create a full copy of the
object, instead of creating a reference to the object as would happen
in most object oriented programming languages such as Java, C#,
Python, Ruby and etc. C++ also supports reference semantics, however
it is not the default behavior and unlike in the majority of
programming languages, requires explicit annotation to pass objects by
reference or create a reference to the object.

  *Value Semantics in C++*

  Example: demonstration of value semantics in C++ tested in the CERN's
  C++ ROOT REPL:

  - Note: this code can be copied and pasted in the CERN's ROOT REPL.
 
 #+BEGIN_SRC cpp 
   #include <iostream>
   #include <string>

   class Foo{
   private:
     std::string _name;
   public:
     // Constructor 
     Foo(std::string name):_name(name){}
     // Copy constructor
     //--------------------------
     // Note: If it is not defined, the compiler, defines 
     // a default copy constructor. It was created to demonstrate
     // when the copy constructor is invoked.
     Foo(const Foo& rhs){
       _name = rhs._name;    
       std::cout << " [INFO] Copy constructor invoked." << std::endl;    
     }
     // Copy assignment-operator
     //--------------------------
     // Note: It is similar to the copy constructor and
     // default assignment copy-assignment-operator is created
     // by the compiler if the user doesn't define it.
     Foo operator= (const Foo& rhs){    
       std::cout << " [INFO] Copy-assignment operator invoked." << std::endl;
       return Foo(rhs._name);
     }
     void setName(std::string name){
       _name = name;
     }
     std::string getName() const {
       return _name;
     }
     void show(){
       std::cout << "Foo { name = " << _name << " } " << std::endl;
     }
     void show2() const {
       std::cout << "Foo { name = " << _name << " } " << std::endl;
     }
   };

 #+END_SRC

 Assignment creates a copy, unlike in most OOP languages like Java, C#,
 Python and so on. 

 #+BEGIN_SRC cpp 
   >> Foo foo("foo");
   >> foo.show()
   Foo { name = foo } 

   // Assingment creates a copy, unlike in most OO languages
   >> Foo bar = foo; 
    [INFO] Copy constructor invoked.

   // Modifying one of the objects, doens't change the other. 
   >> bar.show()
   Foo { name = foo } 

   >> bar.setName("I am object bar")

   >> bar.show()
   Foo { name = I am object bar } 

   >> foo.show()
   Foo { name = foo } 
   >> 

   // foo and bar objects aren't the same as they have 
   // different memory locations. 
   >> &foo == &bar
   (bool) false
   >>
 #+END_SRC

 Primitive and composite types are passed by value in C++, unlike in
 most OOP languages. So, it means that a copy of the object is created.

 #+BEGIN_SRC cpp
   void setFooPrint(Foo param, std::string name){
     param.setName(name);
     param.show();
     std::cout << " name = " << param.getName() << std::endl;
   }

   // Modifying the function paramenter, doesn't modify the passed object.
   >> setFooPrint(foo, "dummy name")
    [INFO] Copy constructor invoked.
   Foo { name = dummy name } 
    name = dummy name

   >> foo.show()
   Foo { name = foo } 
   >> 
 #+END_SRC

 Returning an object from function, creates a copy of the object
 instead of returning a reference to it like in Java, Scala, Python and
 most languages.

 #+BEGIN_SRC cpp 
   Foo modifyReturn(Foo param, std::string newName) {
     param.setName(newName);
     return param;
   }

   >> auto ret = modifyReturn(foo, "New name")
    [INFO] Copy constructor invoked.
    [INFO] Copy constructor invoked.
   (Foo &) @0x7f54f0288050

   >> &ret == &foo
   (bool) false

   >> ret.show()
   Foo { name = New name } 

   >> foo.show()
   Foo { name = foo } 
   >> 

 #+END_SRC

 Value semantics and STL 

  - Objects can be stored in STL containers by value, reference or by
    pointers. 

 #+BEGIN_SRC cpp 
   #include <deque> // Double ended queue collection 

   >> std::deque<Foo> xs;

   // Temporary objects are created on the stack, 
   // copied to the deque data structure and then 
   // put on the collection. 
   // 
   >> xs.push_back(Foo("hello"));
    [INFO] Copy constructor invoked.
   >> xs.push_back(Foo("world"));
    [INFO] Copy constructor invoked.
   >> xs.push_back(Foo("value"));
    [INFO] Copy constructor invoked.
   >> xs.push_back(Foo("semantics"));
    [INFO] Copy constructor invoked.
   >> 

   >> xs
   (std::deque<Foo> &) { @0x1393820, @0x1393840, @0x1393860, @0x1393880 }
   >> 

   >> xs.size()
   (unsigned long) 4
   >> 

   >> xs.at(0).show()
   Foo { name = hello } 
   >> xs.at(0).show2()
   Foo { name = hello } 
   >> 
   >> xs.at(2).show()
   Foo { name = value } 
   >> 

   // Error: invoke const reference method which is not annotated with 'const'
   >> for(const auto& x: xs) { x.show(); }
   ROOT_prompt_56:1:26: error: member function 'show' not viable: 
   'this' argument has type 'const Foo', but function is not marked const
   for(const auto& x: xs) { x.show(); }

   // Works as show2() is annotated with 'const'
   >> for(const auto& x: xs) { x.show2(); }
   Foo { name = hello } 
   Foo { name = world } 
   Foo { name = value } 
   Foo { name = semantics } 
   >> 

   // Wateful for-loop 
   >> for(auto x: xs) { x.show(); }
    [INFO] Copy constructor invoked.
   Foo { name = hello } 
    [INFO] Copy constructor invoked.
   Foo { name = world } 
    [INFO] Copy constructor invoked.
   Foo { name = value } 
    [INFO] Copy constructor invoked.
   Foo { name = semantics } 
   >> 

   // By using emplace_back - a copy is not created.
   >> auto xs2 = deque<Foo>()
   (std::deque<Foo, std::allocator<Foo> > &) {}
   >> 
   >> xs2.emplace_back("hello")
   >> xs2.emplace_back("world")
   >> xs2.emplace_back("value")
   >> xs2.emplace_back("semantics")
   >> xs2
   (std::deque<Foo, std::allocator<Foo> > &) { @0x411ff30, @0x411ff50, @0x411ff70, @0x411ff90 }
   >> 

   >> for(const auto& x: xs2) { x.show2(); }
   Foo { name = hello } 
   Foo { name = world } 
   Foo { name = value } 
   Foo { name = semantics } 
   >> 
 #+END_SRC

  *Reference Semantics in C++*

 Unlike in most programming languages where reference semantics for
 complex types such as object is the default behavior, in C++ reference
 semantics requires explicit annotation with reference operator (&) or
 passing objects by pointer. 

 The default behavior of passing by value cause significant memory and
 performance overhead. In order to avoid unnecessary copies, it is
 preferable to pass objects by reference with operator (&) or by const
 reference when the object is not supposed to be modified by the
 function the objects are passed to.

  - Create a reference in assignment operation instead of a copy.

 #+BEGIN_SRC cpp 
   >> foo.show()
   Foo { name = foo } 

   >> Foo& ref1 = foo;

   >> ref1.setName("I am foo reference")
   >> foo.show()
   Foo { name = I am foo reference } 
   >> 

   // The reference has the same memory location of foo.
   >> &foo == &ref1
   (bool) true
   >> 
 #+END_SRC

  - Passing a parameter by reference instead of passing it by
    value. Note: that the copy constructor is not invoked when passing
    by reference.

 #+BEGIN_SRC cpp 
   void setFooPrintRef(Foo& param, const std::string& name){
     param.setName(name);
     param.show();
     std::cout << " name = " << param.getName() << std::endl;
   }

   >> setFooPrintRef(foo, "dummy name")
   Foo { name = dummy name } 
    name = dummy name

   >> foo.show()
   Foo { name = dummy name } 
   >> 
 #+END_SRC

  - Returning objects from functions as references. 

 #+BEGIN_SRC cpp 
   Foo& modifyReturnRef(Foo& param, std::string newName) {
     param.setName(newName);
     return param;
   }

   >> foo.setName("unnamed")

   >> fooRefx.setName("I am foo reference")
   >> foo.show()
   Foo { name = I am foo reference } 

   >> &foo == &fooRefx
   (bool) true
   >> 

   >> auto& fooRefAuto = modifyReturnRef(foo, "C++ type inference auto!")
   (Foo &) @0x7f54f0288010

   >> foo.show()
   Foo { name = C++ type inference auto! } 

   >> fooRefAuto.show()
   Foo { name = C++ type inference auto! } 

   >> fooRefAuto.setName("C++17")

   >> foo.show()
   Foo { name = C++17 } 
   >> 

   >> &foo == &fooRefAuto
   (bool) true
   >> 
 #+END_SRC

  - Const references cannot be modified as any attempt to change it
    will result in a compile-time error. 

 #+BEGIN_SRC cpp 
   >> Foo foo("foo");

   >> foo.show()
   Foo { name = foo } 

   >> foo.getName()
   (std::string) "foo"

   >> const Foo& fooRefConst = modifyReturnRef(foo, "C++ constant ref.")
   (const Foo &) @0x7fbf2003c010

   >> foo.show()
   Foo { name = C++ constant ref. } 

   >> foo.getName()
   (std::string) "C++ constant ref."
   >> 

   >> fooRefConst.show2()
   Foo { name = C++ constant ref. } 
   >> 

   // Any attempt to call a method not annotated with const will result 
   // in a compile-time error. 
   >> fooRefConst.show()
   ROOT_prompt_52:1:1: error: member function 'show' not viable: 'this' 
   argument has type 'const Foo', but function is not marked const
   fooRefConst.show()
   ^~~~~~~~~~~
   ROOT_prompt_30:1:6: note: 'show' declared here
   void show(){ 
 #+END_SRC

  *Summary* 

  + Value Semantics X Reference Semantics
    + _Value Semantics_ -> Objects are assigned, passed to functions and
      return from functions as primitive types without being modified
      as what is modified is a copy of the object. This is default
      behavior of C++.

      + Object A = B; => (C++ Only) Creates object A as a copy of the object B.

      + Object A = B.copy() (C#, Java, Python ...) Creates object A as
        copy of object B. As value-semantics is not the default
        behavior in thoses languages, it is necessary to invoke some
        deep copy method explicity.

    + _Reference Semantics_ -> Objects are passed by reference or
      pointer; assigned by pointer and so on. Objects passed to
      functions using reference semantics can modified. This is the
      default behavior of Java, Python, C# and other programming
      languages.

      + Object A = B; (C#, Java, Python ...) => The object A is
        reference to object B. Any modification to A or B will modify
        both as the refer to the same memory location.

      + Object& A = B; (C++ only) => Creating a reference in C++
        requires an explicit annotation with operator (&) as it is
        non-default behavior.

  + Most programming languages, except C++, uses value-semantics for
    primitive types and reference semantics for complex or composite
    types such as objects due to performance reasons.

  + C++ Uses _values-semantics_ by default for all types, unlike most
    programming languages, when any primitive type or composite type such
    as class when assigned, passed to functions or returned from 
    functions, copy is created and the original object is not
    changed.

  + _C++ supports both value and reference semantics_ which is not
    default for objects linke in Java, Python and other languages. The
    reference semantics requires explicit annotation.

  + In order to avoid unncessary copies what would bring memory
    peformance overhead, it is preferable to use reference semantics,
    in other words, pass large objects by reference or const reference
    to functions or methods. 

  + Move semantics optmizes return-by value avoiding copy. The copy
    overhead can avoided when returning an object from functions by
    defining a _move constructor_ (see C++11's move semantics) which
    transfer resource ownership from the object defined locally within
    the function body to the returned object.

  *Further Reading:*

  + ISO C++ - Reference and Value Semantics -
    <https://isocpp.org/wiki/faq/value-vs-ref-semantics>
    + Note: Provides a good and clear definition about what really is
      value and reference semantics. 

  + Andrezj's C++ blog - Value Semantics -
    <https://akrzemi1.wordpress.com/2012/02/03/value-semantics/> 

  + Value Semantics - Code of the danmed -
    <http://codeofthedamned.com/index.php/value-semantics>

  + What do ‘value semantics’ and ‘pointer semantics’ mean? -
    <https://stackoverflow.com/questions/166033/what-do-value-semantics-and-pointer-semantics-mean>

  + MSDN - Value Types (Modern C++) -
    <https://msdn.microsoft.com/en-us/library/hh438479.aspx>
    + Note:

  + My Precious Compile Time Bool (long introduction to Move
    Semantics) - <https://medium.com/@gaussnoise/my-precious-compile-time-bool-long-introduction-to-move-semantics-c9ee73c370c7>

  + 

** C++11 - Uniform Initialization

The C++11 uniform initialization feature allows classes, STL
containers (collections) and primitives values to be initialized in a
uniform way similar to vectors and C-arrays. 

 - Uniform initialization of primitive types: 

#+BEGIN_SRC cpp 
  int    x {};   // x = 0
  double fd {};  // fd = 0.0
  float  ff {};  // ff = 0.0f
  bool   flag{}; // flag = false = 0 
#+END_SRC

 - Uniform initialization of C-arrays 

#+BEGIN_SRC cpp 
  int xs[] {10, 20, 30};  //  int xs[] =  {10, 20, 30};
  double ys[3] {1.0};     //  double ys[] = {1.0};
#+END_SRC

 - Uniform initialization of pointers 

#+BEGIN_SRC cpp 
  double* fdptr{} ; // fdptr = nullptr 
#+END_SRC

 - Uniform initialization of STL containers: 

#+BEGIN_SRC cpp 
  std::string s {};                // s = ""
  std::string s {"Hello world"};   // s = "Hello World"

  // Vectors 
  std::vector<double> xs {};                      
  std::vector<double> ys {2.0, 3.0, 4.0, 5.0};
  std::vector<string> zs {"apple", "orange", "grape", "banana"};
  // Lists
  std::list<double>   xs {};
  std::list<double>   ys{2.0, 3.0, 4.0, 5.0};   
  // Sets 
  std::set<double>    xs{};
  std::set<double>    ys {3.0, 4.0, 3.0, 10.0};
  // Unordered set 
  std::unordered_set<int>    xs{};
  std::unordered_set<string> zs {"apple", "orange", "grape", "banana"};

  // Maps, aka hash map, aka dictionary, aka hash table 
  std::map<std::string,double> prices {{"orange", 10.0}, {"grapes", 25.12}, {"apple", 4.12}};
#+END_SRC

 - Initialization of C-structus POD - Plain Old Data 

#+BEGIN_SRC cpp 
  struct Point3D{
      double x;
      double y;
      double z;
  };

  // Before C++11
  //---------------------------
  Point3D pa;
  pa.x = 10.0;
  pa.y = 20.0;
  pa.z = 35.0;

  // After C++11
  //---------------------------
  Point3D pb {10.0, 20.0, 35.0};
  Point3D pc = {10.0, 20.0, 35.0};

  // C++ Vector - way 1
  std::vector<Point3D> {{ 20.0, 15.0, 5.0}, { 10.0, 25.0, 12.4}, {-14.0, 0.32, 51.43}};

  // C++ Vector - way 2 
  std::vector<Point3D> {
        Point3D{ 20.0, 15.0, 5.0}
       ,Point3D{ 10.0, 25.0, 12.4}
       ,Point3D{-14.0, 0.32, 51.43}
  };

  // C++ Map Containers 
  std::map<std::string, Point3D> locations = {
       {"City 1",    { 20.0, 15.0, 5.0}}
      ,{"Somewhere", { 10.0, 25.0, 12.4}}
      ,{"Nowhere",   {-14.0, 0.32, 51.43}}     
  };

  // or in more pleasant notation 
  // C++ Map Containers 
  auto locations2 = std::map<std::string, Point3D> {
       {"City 1",    { 20.0, 15.0, 5.0}}
      ,{"Somewhere", { 10.0, 25.0, 12.4}}
      ,{"Nowhere",   {-14.0, 0.32, 51.43}}     
  };

  //--- Functions -------//

  Point3D makeOriginPoint(){
      // return Point3D{0.0, 0.0, 0.0};
      return {0.0, 0.0, 0.0};
  }

#+END_SRC

Classes: 

#+BEGIN_SRC cpp 
  class A{
  public: 
      A(double x, double y, double z, std::string name):
          m_x(x),
          m_y(y),
          m_z(z),
          m_name(name) {      
      }
      auto getX() -> double{ return m_x;}
      auto getY() -> double {return m_y;}
      auto getZ() -> double {return m_z;} 
  private:
      double m_x;
      double m_y;
      double m_z; 
  };

  void display(const A& a){
      std::cout << "A (" << a.getX() << " " << a.getY() << a.getZ() << ")" << "\n";
  }

  int main(){
      A instance1 {10.0, 20.0, 15.0, "unknown binary blob"};  
      display(instance1);
      display({10.0, 20.0, 15.0, "unknown binary blob"});
      return 0;
  }

#+END_SRC

References: 

 + [[http://scottmeyers.blogspot.com/2015/09/thoughts-on-vagaries-of-c-initialization.html][The View from Aristeia: Thoughts on the Vagaries of C++ Initialization]]
 + [[https://www.codeguru.com/cpp/cpp/article.php/c19081/C-2011-Uniform-Initialization.htm][C++ 2011: Uniform Initialization]]
 + [[https://mbevin.wordpress.com/2012/11/16/uniform-initialization/][Lesson #3: Uniform Initialization | Mike's C++11 Blog]]
 + [[https://softwareengineering.stackexchange.com/questions/133688/is-c11-uniform-initialization-a-replacement-for-the-old-style-syntax][c++ - Is C++11 Uniform Initialization a replacement for the old style syntax? - Software Engineering Stack Exchange]]
 + 
 + 

** Iterato based loops and for-range based loops 
*** Iterator based loop 

Loop over a vector: 

#+BEGIN_SRC cpp 
  std::vector<std::string> xs {"Hello", "world", "C++", "HPC", "awesome"};

  for(std::vector<std::string>::iterator it = xs.begin(); it != xs.end(); ++it){
          std::cout << "word = '" << *it << "' size = " << it->size() << "\n";
  }

  /** Output: 
     word = 'Hello' size = 5
     word = 'world' size = 5
     word = 'C++' size = 3
     word = 'HPC' size = 3
     word = 'awesome' size = 7
     >> 
   ,*/

  // === OR =====//

  for(auto it = xs.begin(); it != xs.end(); ++it){
          std::cout << "word = '" << *it << "' size = " << it->size() << "\n";
  }

  /** Output: 
          word = 'Hello' size = 5
          word = 'world' size = 5
          word = 'C++' size = 3
          word = 'HPC' size = 3
          word = 'awesome' size = 7
   ,*/
#+END_SRC

Loop over a deque: 

#+BEGIN_SRC cpp 
  auto ds = std::deque<std::string> {"Physics", "C++", "STL", "Math", "Algebra", "Electronics"};

  for(std::deque<std::string>::iterator it = ds.begin(); it != ds.end(); ++it){
          std::cout << "word = '" << *it << "' size = " << it->size() << "\n";
  }

  // Or: 
  for(auto it = ds.begin(); it != ds.end(); ++it){
          std::cout << "word = '" << *it << "' size = " << it->size() << "\n";
  }

  /** Output: 
     word = 'Physics' size = 7
     word = 'C++' size = 3
     word = 'STL' size = 3
     word = 'Math' size = 4
     word = 'Algebra' size = 7
     word = 'Electronics' size = 11
   ,*/

#+END_SRC

Loop over a list: 

#+BEGIN_SRC cpp 
  // Struct is a class with everything public 
  struct Waypoint{
          std::string name;
          double      lat;
          double      lon;
          // This constructor is necessary for storing this object
          // in STL collections/containers 
          Waypoint(){}
          Waypoint(const std::string& name, double lat, double lon):
                  name(name), lat(lat), lon(lon){}
  };

  >> auto wp = Waypoint("Paris", 48.23, 22.12)
  >> wp.name
  (std::string &) "Paris"
  >> wp.lat
  (double) 48.230000
  >> wp.lon
  (double) 22.120000
  >> 
  >> 

  auto waypoints = std::list<Waypoint>{};
  waypoints.emplace_back("Paris", 48.8566, 2.3522);
  waypoints.emplace_back("Tokyo", 35.6895, 139.6917);
  waypoints.emplace_back("Beijing", 39.9042, 116.4074);
  waypoints.emplace_back("Cape Town", -33.9249, 18.4241);
  waypoints.emplace_back("Buenos Aires", -34.6037, -58.3816);

  std::cout << std::fixed << std::setprecision(2);

  for(auto it = waypoints.begin(); it != waypoints.end(); ++it){
          std::cout << std::setw(15) << std::left  << it->name
                            << std::setw(15) << std::right << it->lat
                            << std::setw(15) << it->lon
                            << "\n";
  }
#+END_SRC

Output: 

#+BEGIN_SRC text 
  Paris                    48.86           2.35
  Tokyo                    35.69         139.69
  Beijing                  39.90         116.41
  Cape Town               -33.92          18.42
  Buenos Aires            -34.60         -58.38
#+END_SRC

Loop over a map:

#+BEGIN_SRC cpp 
  auto values = std::map<std::string, double>{
        {"x",  2.1023}
       ,{"y",  sqrt(2)}
       ,{"e",  exp(1)}
       ,{"pi", 3.1415}
       ,{"3/4", 3.0 / 4.0}
  };

  std::cout << std::fixed << std::setprecision(2);

  for(std::map<std::string, double>::iterator it = values.begin(); it != values.end(); it++){
          std::cout << std::setw(5) << std::left  << it->first
                            << std::setw(5) << std::right << it->second
                            << "\n";
  }

  // OR:
  for(auto it = values.begin(); it != values.end(); it++){
          std::cout << std::setw(5) << std::left  << it->first
                            << std::setw(5) << std::right << it->second
                            << "\n";
  }

  /** Output: 
     3/4   0.75
     e     2.72
     pi    3.14
     x     2.10
     y     1.41
   ,*/
#+END_SRC

*** For-ranged based loops 

C++11 and new standards allow to iterate over any STL container or
class with methods (member functions) .begin() or .end() using a
simpler syntax than the old iterator loop syntax.

 *Loop over a vector:*

#+BEGIN_SRC cpp 
  std::vector<std::string> xs {"Hello", "world", "C++", "HPC", "awesome"};

  // Use: const auto&  to avoid uncessary copies, use auto& if there is modification of x.
  // The const keyword will generate a compiler error if there is 
  // any attempt to modify the value of x. 
  for(const auto& x: xs){
          std::cout << "word = '" << x << "' size = " << x.size() << "\n";
  }

  /** Output: 
     word = 'Hello' size = 5
     word = 'world' size = 5
     word = 'C++' size = 3
     word = 'HPC' size = 3
     word = 'awesome' size = 7
   ,*---------------*/

#+END_SRC

 *Loop over a list:*

#+BEGIN_SRC cpp 
  // Struct is a class with everything public 
  struct Waypoint{
          std::string name;
          double      lat;
          double      lon;
          // This constructor is necessary for storing this object
          // in STL collections/containers 
          Waypoint(){}
          Waypoint(const std::string& name, double lat, double lon):
                  name(name), lat(lat), lon(lon){}
  };

  auto waypoints = std::list<Waypoint>{
         {"Paris", 48.8566, 2.3522}
        ,{"Tokyo", 35.6895, 139.6917}
        ,{"Beijing", 39.9042, 116.4074}
        ,{"Cape Town", -33.9249, 18.4241}
        ,{"Buenos Aires", -34.6037, -58.3816}};


  std::cout << std::fixed << std::setprecision(2);

  for(const auto& wp: waypoints){
          std::cout << std::setw(15) << std::left  << wp.name
                            << std::setw(15) << std::right << wp.lat
                            << std::setw(15) << wp.lon 
                            << "\n";
  }

#+END_SRC

Ouput: 

#+BEGIN_SRC text 
  Paris                    48.86           2.35
  Tokyo                    35.69         139.69
  Beijing                  39.90         116.41
  Cape Town               -33.92          18.42
  Buenos Aires            -34.60         -58.38
#+END_SRC

 *Loop over a map*

#+BEGIN_SRC cpp 
  auto values = std::map<std::string, double>{
        {"x",  2.1023}
       ,{"y",  sqrt(2)}
       ,{"e",  exp(1)}
       ,{"pi", 3.1415}
       ,{"3/4", 3.0 / 4.0}
  };

  std::cout << std::fixed << std::setprecision(3);

  for(const auto& p: values){
          std::cout << std::setw(5) << std::left  << p.first
                                    << std::setw(5) << std::right << p.second
                                    << "\n";
  }

  /** Output: 
     3/4  0.750
     e    2.718
     pi   3.142
     x    2.102
     y    1.414
   ,*==============*/
#+END_SRC

** C++11 - Scoped Enum

Scoped enumerations are a more type-safe alternative to the old
C-enums as it has several problems realated to namespace conflicts and
implicit conversions that can introduce bugs hard to catch and reason
about. 

Syntax: 

 - Simple scoped enum class 

#+BEGIN_SRC cpp 
  enum class Color {
     white,
     black,
     yellow,
     red,
     blue,
  };

  >> Color::white
  (Color) (Color::white) : (int) 0
  >> Color::blue
  (Color) (Color::blue) : (int) 4
  >> Color::yellow
  (Color) (Color::yellow) : (int) 2
  >> Color::red
  (Color) (Color::red) : (int) 3
  >> 

  >> static_cast<int>(Color::blue)
  (int) 4
  >> static_cast<int>(Color::white)
  (int) 0
  >> static_cast<int>(Color::yellow)
  (int) 2
  >> 
#+END_SRC

 - Scoped enum with hexadecimal error codes.
 
#+BEGIN_SRC cpp 
  enum class ErrorCode: std::uint32_t {
     tankNotFilled = 0xff,
     missingSupply = 0x2f,
     lowBattery    = 0x2a,
     unknown       = 0x24                                         
  };
#+END_SRC

 - Scoped enums with chars 

#+BEGIN_SRC cpp 
  enum class ErrorCodeLetter: char {
          tankNotFilled = 'x',
          missingSupply = 'y',
          lowBattery    = 'a',
          unknown       = 'k'                                         
  };

  >> ErrorCodeLetter::tankNotFilled
  (ErrorCodeLetter) (ErrorCodeLetter::tankNotFilled) : (char) 120
  >> ErrorCodeLetter::missingSupply
  (ErrorCodeLetter) (ErrorCodeLetter::missingSupply) : (char) 121
  >> ErrorCodeLetter::unknown
  (ErrorCodeLetter) (ErrorCodeLetter::unknown) : (char) 107
  >> static_cast<char>(ErrorCodeLetter::unknown)
  (char) 'k'
  >> static_cast<char>(ErrorCodeLetter::missingSupply)
  (char) 'y'
  >> 
#+END_SRC


 *More Exhaustive Example:*

#+BEGIN_SRC cpp 
  enum class MachineStatus: std::uint32_t {
     running = 0xf5,
     iddle   = 0x2a,
     waiting = 0x35,
     failure = 0x24                                         
  };
#+END_SRC

Example: CERN's root shell. 

#+BEGIN_SRC cpp 
   >> MachineStatus::running
   (MachineStatus) (MachineStatus::running) : (unsigned int) 245
   >> MachineStatus::iddle
   (MachineStatus) (MachineStatus::iddle) : (unsigned int) 42
   >> MachineStatus::waiting
   (MachineStatus) (MachineStatus::waiting) : (unsigned int) 53
   >> MachineStatus::failure
   (MachineStatus) (MachineStatus::failure) : (unsigned int) 36
   >> 

   >> auto status = MachineStatus::running
   (MachineStatus) (MachineStatus::running) : (unsigned int) 245

   >> std::cout << "Machine status = " << std::hex << "0x" << static_cast<std::uint32_t>(status) << std::endl;
   Machine status = 0xf5
   >> 
   >> 

   >> status = MachineStatus::iddle 
   (MachineStatus) (MachineStatus::iddle) : (unsigned int) 42
   >> std::cout << "Machine status = " << std::hex << "0x" << static_cast<std::uint32_t>(status) << std::endl;
   Machine status = 0x2a
   >> 

   >> if(status == MachineStatus::iddle) { std::cout << "Machine is iddle" << std::endl; }
   Machine is iddle
   >> 

   >> status = MachineStatus::running
   (MachineStatus) (MachineStatus::running) : (unsigned int) 245
   >> if(status == MachineStatus::running) { std::cout << "Machine is running" << std::endl; }
   Machine is running
   >> 

   >> static_cast<std::uint32_t>(MachineStatus::running)
   (unsigned int) 245
   >> static_cast<std::uint32_t>(MachineStatus::iddle)
   (unsigned int) 42
   >> static_cast<std::uint32_t>(MachineStatus::iddle) == 0x2a
   (bool) true
   >> 
   >> static_cast<MachineStatus>(0x2a) 
   (MachineStatus) (MachineStatus::iddle) : (unsigned int) 42
   >> 
   >> static_cast<MachineStatus>(0x2a) == MachineStatus::iddle
   (bool) true
   >> 
#+END_SRC

** Functor Function-Object and higher order functions 

Functor is any object which behaves like a function and callable like
a function. Unlike C++ ordinary functions, functors can have internal
state and change its internal data as well.

Functors are implementing in C++ by overloading the function
application operator. 

The code in the file: [[file:src/cpp-functor.cpp][file:src/cpp-functor.cpp]] shows an
exhaustive example about how to implement, use functors and implement
client code using dynamic polymorphism (aka subtyping or inheritance),
static polymorphism (aka template metaprogramming) and C++11's
function type _std::function_.

Example: 
 + File:            [[file:src/cpp-functor.cpp][file:src/cpp-functor.cpp]] 
 + Online Compiler: http://rextester.com/VGE78113

 + Math functor interface class representing a general math function. 

#+BEGIN_SRC cpp  
  class IMathFunctor {
  public:
          // Pure virtual function
          // => const -> Means that the function cannot change the object internal state.
          // => (= 0) -> Means abstract member function or abstract method.
          virtual double operator()(double x)	const = 0;
          virtual ~IMathFunctor() = default;
  };
#+END_SRC

 - Linear Function "C++ functor." - function-object 

#+BEGIN_SRC cpp 
  /** Linear Function "C++ functor." - function-object 
   ,*   LinFun(x) = A * x + B
   ,*/
  class LinFun: public IMathFunctor {
  private:
          // Linear coefficient or line slope 
          double _a; 
          double _b;
  public:
          LinFun(double a, double b): _a(a), _b(b){}
          auto getA()				-> double   { return _a;}
          auto setA(double a)			-> void	    { _a = a; }
          auto getB()				-> double   { return _b;}
          auto setB(double b)			-> void	    { _b = b; }

          // Function-call operator => Makes this object callable
          //------------------------------
          // double operator()(double x)	-> double	{ return _a * x + _b;}	
          double operator()(double x)	const { return _a * x + _b;}	
  };
#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
  // Function linear object - modelling a linear function 3 * x + 4.0 
  LinFun fun1(3.0, 4.0);
  std::cout << "a = " << fun1.getA() << " ; b = " << fun1.getB() << nl;
  std::cout << "fun1(3.0) = " << fun1(3.0) << nl;  
  std::cout << "fun1(4.0) = " << fun1(4.0) << nl;
#+END_SRC

Output: 

#+BEGIN_SRC text 
  a = 3 ; b = 4
  fun1(3.0) = 13
  fun1(4.0) = 16
  fun1(5.0) = 19
#+END_SRC


Higher order functions (functions that calls or return functions) can
be implemented using dynamic polymorphis or inheritance; static
polymorphism, also known as template metaprogramming and using the
type std::function from C++11.


 - *Higher order function using dynamic polymorphism*
   (inheritance). This function only accepts implementations of
   IMathFunctor and cannot worth with an arbitrary function-object,
   ordinary functions or C++11 lambda function. Another drawback is
   the runtime overhead of virtual function-calls.

Example:

#+BEGIN_SRC cpp 
  void tabulateDynamic(const IMathFunctor& fun, double start, double stop, double step){
          std::cout << std::fixed << std::setprecision(3);
          for(double x = start; x <= stop ; x += step)
                  std::cout << std::setw(10) << x << std::setw(10) << fun(x) << "\n";
  }
#+END_SRC

Usage:

#+BEGIN_SRC cpp 
    tabulatDynamic(fun1, 0.0, 5.0, 1.0);
#+END_SRC

Sample Output: 

#+BEGIN_SRC text 
  -----> Tabulating fun1
      0.000     4.000
      1.000     7.000
      2.000    10.000
      3.000    13.000
      4.000    16.000
      5.000    19.000
#+END_SRC

 - *Higher order function using static polymorphism* - The advantage
   of this function is that it can work with any callable object like
   functors (function-objects), ordinary functions and C++11 lambda
   functions. Another benefit is the lower runtime overhead than the
   implementation using dynamic polymorphism. For this case, the
   runtime cost of dynamic polymorphism is not significant, however it
   can become noticeable on large scale computation or high
   performance computations.

 - Example:

#+BEGIN_SRC cpp 
  template<class Function>
  void tabulateStatic(const Function& fun, double start, double stop, double step){
          std::cout << std::fixed << std::setprecision(3);
          for(double x = start; x <= stop ; x += step)
                  std::cout << std::setw(10) << x << std::setw(10) << fun(x) << "\n";
  }
#+END_SRC

Usage:

#+BEGIN_SRC cpp 
    std::cout << " -----> Tabulating fun1" << nl;
    tabulateStatic(fun1, 0.0, 5.0, 1.0);
    std::cout << " -----> Tabulating fun2" << nl;
    tabulateStatic(fun2, 0.0, 5.0, 1.0);
#+END_SRC


 - *Higher order function using the C++11 type std::function* - The type
   std::function provides type erasure and can work with any functor,
   ordinary function and C++11 lambda functions, in addition it also
   allows all those types of functions to be stored in STL containers.

Example: 

#+BEGIN_SRC cpp 
  void tabulateLambdaList(
           const std::vector<std::function<double (double)>> funlist
          ,double start
          ,double stop
          ,double step
          ){
          std::cout << std::fixed << std::setprecision(3);
          for(double x = start; x <= stop ; x += step){
                  std::cout << std::setw(10) << x;
                  // const auto& is used for avoid uncessary copies 
                  for(const auto& fun: funlist)
                          std::cout << std::setw(10) << fun(x);
                  std::cout << "\n";
          }
  }
#+END_SRC

Usage:

#+BEGIN_SRC cpp 
   tabulateLambdaList({fun1, fun2, exp, ordinaryFunction}, 0.0, 5.0, 1.0)
#+END_SRC

Output:

#+BEGIN_SRC text 
         x         fun1     fun2      exp      ordinaryFunction
       0.000     4.000     4.000     1.000     0.000
       1.000     7.000     9.000     2.718     3.000
       2.000    10.000    18.000     7.389     6.000
       3.000    13.000    31.000    20.086     9.000
       4.000    16.000    48.000    54.598    12.000
       5.000    19.000    69.000   148.413    15.000
#+END_SRC

Compilation of [[file:src/cpp-functor.cpp][file:src/cpp-functor.cpp]] 

#+BEGIN_SRC sh 
  $ clang++ cpp-functor.cpp -o cpp-functor.bin -g -std=c++11 -Wall -Wextra &&
#+END_SRC

Complete program output of [[file:src/cpp-functor.cpp][file:src/cpp-functor.cpp]] 

#+BEGIN_SRC sh 
  ./cpp-functor.bin

  a = 3 ; b = 4
  fun1(3.0) = 13
  fun1(4.0) = 16
  fun1(5.0) = 19
  =======================
  a = 2 ; b = 3 ; c = 4
  fun2(3.0) = 31
  fun2(4.0) = 48
  fun2(5.0) = 69
  ======= [1] Client Code using dynamic polymorphism  ================
   -----> Tabulating fun1
       0.000     4.000
       1.000     7.000
       2.000    10.000
       3.000    13.000
       4.000    16.000
       5.000    19.000
   -----> Tabulating fun2
       0.000     4.000
       1.000     9.000
       2.000    18.000
       3.000    31.000
       4.000    48.000
       5.000    69.000
  ======= [2] Client Code using dynamic polymorphism  ================
       0.000     4.000     4.000
       1.000     7.000     9.000
       2.000    10.000    18.000
       3.000    13.000    31.000
       4.000    16.000    48.000
       5.000    19.000    69.000
  ======= Client Code using static polymorphism (template)  ================
   -----> Tabulating fun1
       0.000     4.000
       1.000     7.000
       2.000    10.000
       3.000    13.000
       4.000    16.000
       5.000    19.000
   -----> Tabulating fun2
       0.000     4.000
       1.000     9.000
       2.000    18.000
       3.000    31.000
       4.000    48.000
       5.000    69.000
   -----> Tabulating lambda function f(x) = x * x
       0.000     0.000
       1.000     1.000
       2.000     4.000
       3.000     9.000
       4.000    16.000
       5.000    25.000
   -----> Tabulating ordinary function f(x) = 3 * x
       0.000     0.000
       1.000     3.000
       2.000     6.000
       3.000     9.000
       4.000    12.000
       5.000    15.000
   -----> Tabulating ordinary function f(x) = exp(x)
       0.000     1.000
       1.000     2.718
       2.000     7.389
       3.000    20.086
       4.000    54.598
       5.000   148.413
  ======= Client Code using C++11 lambda std::function  ================
       0.000     4.000     4.000     1.000     0.000
       1.000     7.000     9.000     2.718     3.000
       2.000    10.000    18.000     7.389     6.000
       3.000    13.000    31.000    20.086     9.000
       4.000    16.000    48.000    54.598    12.000
       5.000    19.000    69.000   148.413    15.000
#+END_SRC

** Lambda Functions
   :PROPERTIES:
   :ID:       02be1a97-c100-44ce-ad76-63835818d406
   :END:
*** Overview 

Lambda expressions, also known as lambda functions or lambda
abstractions, are ubiquitous in functional programming languages such
as Haskell, OCaml, Scala and Scheme. They were by introduced in a
theoretical way by Alonzo Church in the lambda calculus. Lisp was
first programming language to use lambda functions and now this
function programming feature has made its way into mainstream and has
arrived to C# (Cshap), Java 8 and C++11.

In C++, Lambda functions are not ordinary functions, actually, they
are special function-objects or "C++ functors". Lambda abstractions
can be passed as arguments to any function; returned from functions;
can have state and also they can be defined locally at the call-site
simplifying all the boilerplate code necessary to pass a function to
callbacks, event handlers and higher order functions.

Summary:

  * Lambda functions were introduced in C++11. Before C++11 lambdas
    were available as Boost.Lambda. 

  * Lambda functions can be:
    + returned from functions.
    + be passed as function parameters.
    + Can be stored in data structures.
    + Hold state and capture variables (closure).
    + Non-capturing lambdas can be converted to function pointers what
      is useful with old C-APIs.

  * Lambda turns C++11 is a *game changer* and turns C++ into an
    quasi-functional programming language.

  * Practical Use Cases:
    + Callbacks
    + Higher order functions
    + Simplify design patterns
    + Asynchronous code
    + Create functions at runtime. 

*Main parts* 
 
 - Capture list between square brackets ~[ ]~
 - Argument list between parenthesis ~()~
 - Function body between curly braces ~{}~

Syntax: 

#+BEGIN_SRC text 
  [capture](parameters) -> return-type {body}
#+END_SRC

Some lambda functions: 

#+BEGIN_SRC cpp 
 auto fn = [](int n){ return n * 10; }

 // Test in CERN's ROOT REPL
 >> auto fn = [](int n){ return n * 10; }
 ((lambda) &) @0x7f5e578f2010
 >> 

 >> auto fn = [](int n){ return n * 10; }
 ((lambda) &) @0x7f5e578f2010
 >> 
#+END_SRC


*Parts of a C++'s lambda expression:*  - ([[https://msdn.microsoft.com/en-us/library/dd293608.aspx][Microsoft Inc. Lambda C++]])

 1. Capture clause - Specifies captured variables (closure).
    - ~[ ]~ - Empty capture clause means that no variable from escope
      is captured.
    - ~[x, y]~- The variables x and y are captured by value and the
      the lambda body will get a copy of x and y. They cannot be
      modified in the body of the lambda expression. 
    - ~[&x , y]~ - The variable x is captured by reference and y by
      value, therefore x can be modified in the body of the lambda
      expression and y cannot.
    - ~[&]~ - Capture all variables used in the lambda's body by
      reference.
    - ~[=]~- Captures all variables used in the body by value
      (copy). The variables cannot be modifed as they are passed by
      value.
    - ~[=, &blob]~- The variable blob is captured by reference and all
      other variables are captured by value (copy).
    - ~[this]~ - Captures the "this" pointer of the enclosing class.

 2. Parameter list (Optional)- Parameters, aka arguments, of the lambda expression.
 3. Mutable specification (optional)
 4. exception-specification (optional)
 5. trailing return type (optional)
 6. lambda-body - The body can access variables such as:
    - Lambda parameters passed between parenthesis:  ~(int x)~
    - Captured variables from the enclosing scope.
    - Global variables.
    - Class data members if the lambda expression is defined inside a
      class. 

#+BEGIN_SRC text 
  --
              (1)  (2)    (3)       (4)         (5)
                 |    |         |            |           |
                ...  ....  .....+....  ...+....     ......
                [ ]  ( )  mutable  throw()  -> int
                {                                                   
                  // (6)                                              
                  // Lambda body 
                  int n = x + y;
                  x = y;
                  y  = n;
                  return n;
                }
#+END_SRC

*** Basic Example 

*Proof-of-concept code* 

 + File: [[file:src/lambdaFun.cpp][file:src/lambdaFun.cpp]]
 + Online Compiler: http://rextester.com/SCQP30593

Code Highlights:

 - Lambda function - lambda1 

#+BEGIN_SRC cpp 
  // Example (1)
  auto lambda1 = [](const std::string& str){
     std::cout << "Lambda1: : I got the value = " << str << "\n";
  };

  // Alternative 1:
  //------------------------------
  std::function<void (const std::string&)> lambda1A = [](const std::string& str) {
    std::cout << "Lambda1: : I got the value = " << str << endl;
  };

  // Alternative 2:
  //------------------------------
  std::function<auto (const std::string&) -> void> lambda1B = [](const std::string& str) {
    std::cout << "Lambda1: : I got the value = " << str << endl;
  };

  // Alternative 3:
  //------------------------------
  // Type synonym 
  using FnAction = std::function<void (const std::string&)>;
  // Alternative type synonym: 
  using FnAction = std::function<auto (const std::string&) -> void>;

  FnAction lambda1C = [](const std::string& str) {
    std::cout << "Lambda1: : I got the value = " << str << endl;
  };

  >> lambda1("hello world")
  Lambda1: : I got the value = hello world

  >> lambda1("hola mundo")
  Lambda1: : I got the value = hola mundo

  >> lambda1A("testing C++")
  Lambda1: : I got the value = testing C++

  >> lambda1B("Running lambda1B")
  Lambda1: : I got the value = Running lambda1B

  >> lambda1C("I am lambda1C function")
  Lambda1: : I got the value = I am lambda1C function
  >> 	
#+END_SRC


 - Higher order function which returns a lambda function which takes
   two ints as parameters returning an int. This function captures the
   parameter m by value, it means that the parameter is copied in the
   function body. 

#+BEGIN_SRC cpp 
  // As it is in the code.
  //-----------------------------------------	
  std::function<int (int, int)> makeFunction1(int m){
      return [m](int x, int y){ return m * (x + y); };
  }

  >> auto fn = makeFunction1(4)
  (std::function<int (int, int)> &) @0x7fb73017f010
  >> fn(3, 5)
  (int) 32
  >> fn(4, 3)
  (int) 28
  >> 

  // Alternative 1:
  //-----------------------------------------
  auto makeFunction1A(int m) -> std::function<int (int, int)>{
      return [m](int x, int y){ return m * (x + y); };
  }

  >> fna(3, 5)
  (int) 32
  >> fna(4, 3)
  (int) 28
  >> auto fna6 = makeFunction1A(6)
  (std::function<int (int, int)> &) @0x7f696d823030
  >> fna6(3, 5)
  (int) 48
  >> fna6(4, 3)
  (int) 42
  >> 

  // Alternative 2:
  //-----------------------------------------
  auto makeFunction1B(int m) -> std::function<auto (int, int) -> int>{
      return [m](int x, int y){ return m * (x + y); };
  }

  // Alternative 3:
  //-----------------------------------------
  // C++11 Type synonym
  using BinaryIntFunctionA = std::function<int (int, int)>;
  using BinaryIntFunctionB = std::function<auto (int, int) -> int>;
  // Prior to C++11 type synonym
  typedef std::function<auto (int, int) -> int> BinaryIntFunction;

  auto makeFunction1C(int m) -> BinaryIntFunctionB {
      return [m](int x, int y){ return m * (x + y); };
  }

  >> auto fnc = makeFunction1C(8)
  (std::function<int (int, int)> &) @0x7f696d823050
  >> fnc(3, 5)
  (int) 64
  >> fnc(6, 7)
  (int) 104
  >> 8 * (6 + 7)
  (int) 104
  >> 
#+END_SRC


Complete program output ([[file:src/lambdaFun.cpp][file:src/lambdaFun.cpp]]) : 

#+BEGIN_SRC sh
  g++ lamdaFun.cpp -o bin/lamdaFun.bin && bin/lamdaFun.bin

  -----------------------------------------------------------------------------------------
  >> Example(1) - Testing function lambda1
  Lambda1: : I got the value = Hello
  Lambda1: : I got the value = World

  -----------------------------------------------------------------------------------------
  >> Example(2) Testing function lambda2
  Lambda 2 :: I got the value  = Japan
  Lambda 2 :: I got the value  = Korea

  -----------------------------------------------------------------------------------------
  >> Example(3) Testing function lambda3
     - Lambda function can be defined and executed at the call-site
  Lambda 3 :: I got the value = C++11 is awesome!

  -----------------------------------------------------------------------------------------
  >> Example(4) Testing function sumLambda
     - Lambda functions  can return values as any function.
  sumLambda(10.0, 25.34) = 35.34
  sumLambda(-10.23, 4.56) = -5.67

  -----------------------------------------------------------------------------------------
  >> Example(5) Testing function lamdaCapture
     - Lambda functions  can capture its environment (closures) and have state as "function objects"
    x  = 5  c = 3
  lamdaCapture(2, 5)  = 32
    x  = 5  c = 4
    lamdaCapture(1, 2) =  16
    x  = 5  c = 5

  -----------------------------------------------------------------------------------------
  >> Example(6) Testing function sumLambda
     - Lambda functions  can play well with STL algorithms
  Print all vector elements - Version 1
    v[0] = 1
    v[1] = 2
    v[2] = 3
    v[3] = 4
    v[4] = 5
    v[5] = 6
    v[6] = 7
    v[7] = 8
  Print all vector element Version 2  - local state with 'static' keyword
    v[0] = 1
    v[1] = 2
    v[2] = 3
    v[3] = 4
    v[4] = 5
    v[5] = 6
    v[6] = 7
    v[7] = 8

  -----------------------------------------------------------------------------------------
  >> Example(7) 
     Playing with STL transform algorithm.
    Vector transformed =  
  v  [0] = 4
  v  [1] = 7
  v  [2] = 10
  v  [3] = 13
  v  [4] = 16
  v  [5] = 19
  v  [6] = 22
  v  [7] = 25

  -----------------------------------------------------------------------------------------
  >> Example(8) 
     Lambda functions can be returned from functions and be generated at run-time.
    mulSumBy2(2, 4) = 12
    mulSumBy2(3, 1) = 8
    mulSumBy5(2, 4) = 30
    mulSumBy5(9, 2) = 55

  -----------------------------------------------------------------------------------------
  >> Example(9) 
     Lambda functions can be returned from functions and have state.
    Running dummy function
      (*) m = 2, n = 0, x = 1, y = 3, z = 8
    Running dummy function
      (*) m = 2, n = 1, x = 2, y = 5, z = 15
    Running dummy function
      (*) m = 3, n = 0, x = 1, y = 3, z = 12
    Running dummy function
      (*) m = 3, n = 1, x = 2, y = 5, z = 22

  -----------------------------------------------------------------------------------------
  >> Example(10) 
     Lambda functions can return lambda functions!!
    addTo5(4) = 9
    addTo5(3) = 8
    addTo10(4) = 14
    addTo10(3) = 13

  -----------------------------------------------------------------------------------------
  >> Example(11) 
     Lambda functions can be passed as function arguments!
  foldVector(dataset2, 0, add) = 28
  foldVector(dataset2, 1, mul) = 5040

  -----------------------------------------------------------------------------------------
  >> Example(12) - Observer pattern
  (observer 1) Temperature changed to 30.5 C
  (observer 2) Sensor temperature changed to 30.5 C
  (observer 1) Temperature changed to 20.5 C
  (observer 2) Sensor temperature changed to 20.5 C

#+END_SRC

*References*

 - *Lambda Expressions in C++* -
   <https://msdn.microsoft.com/en-us/library/dd293608.aspx>

 - *Lambda expressions (since C++11)* -
   <http://en.cppreference.com/w/cpp/language/lambda> 

 - *C++ Core Guidelines: Function Objects and Lambdas* -
   <http://www.modernescpp.com/index.php/c-core-guidelines-function-objects-and-lambas> 

 - *C++11/C++14 lambda functions - 2017* -
   <http://www.bogotobogo.com/cplusplus/C11/C11_lambda_functions_expressions.php>

 - *Lambda Functions in C++11 - the Definitive Guide* -
   <https://www.cprogramming.com/c++11/c++11-lambda-closures.html> 

 - *Fun with Lambdas: C++14 Style (part 1)* -
   <https://www.slideshare.net/SumantTambe/fun-with-lambdas-c14-style> 

 - *ICS 45C Fall 2016 - Notes and Examples: Functions and Lambdas* -
   <http://www.ics.uci.edu/~thornton/ics45c/Notes/FunctionsAndLambdas/>

 - *Creating Recursive Lambdas ... and returning them too!* -
   <http://cpptruths.blogspot.com.br/2013/10/creating-recursive-lambdas-and.html> 

*** std::bind 
**** Overview

The operator std::bind can simplify help simplifying turning ordinary
functions, instance methods (member functions) and static methods
(static member functions) into ordinary functions.

Example 1: Turn a function of signature: 
  + Input Signature:
    + double functionABC(double a, double c, double c)
  + Target signature: 
    + function<double (double)> 

For the function functionABC

#+BEGIN_SRC cpp 
  double functionABC(double a, double c, double c);
#+END_SRC

The expression:

#+BEGIN_SRC cpp 
 // Type of fnFunOfA is std::function<double (double)>
 auto fnFunOfA = std::bind(functionABC, _1, 10.0, 20.0)
 // It is the same as 
 auto fnFunOfA = [](double x){ return functionABC(x, 10.0, 20.0); };
 // It also equivalent to 
 std::function<double (double)> fnFunOfA = [](double x){ return functionABC(x, 10.0, 20.0); };
#+END_SRC

So, it follows that: 

#+BEGIN_SRC cpp 
  auto fnFunOfB = std::bind(functionABC, 25.0 , _1, 20.0);
  // It is equivalent to 
  auto fnFunOfB = [](double x){ return (functionABC, 25.0 , _1, 20.0); };
#+END_SRC

By using more lambda placeholders it is also possible to generate
multi variable functions: 

#+BEGIN_SRC cpp 
  #include <functional> 
  using namespace std::placeholders; // Import placeholders, _1, _2, _3 ...  

  //----------------------------------//
  auto fnFunOfAB = std::bind(functionABC, _1 , _2, 20.0);
  // Equivalent to 
  auto fnFunOfAB = [](double x, double y){ return functionABC( x , y, 20.0);};

  //----------------------------------//
  auto fnFunOfAC = std::bind(functionABC, _1 , 10.0, _2);
  // Equivalent to 
  auto fnFunOfAC = [](double x, double y){ return functionABC( x , 10.0, y);};

  //----------------------------------//
  auto fnFunOfABC = std::bind(functionABC, _1 , 10.0, _2);
  // Equivalent to 
  auto fnFunOfABC = [](double x, double y, double z){ return functionABC( x , y, z);};
#+END_SRC


 *Binding non-static methods (member function)*

For the following class:

#+BEGIN_SRC cpp 
 struct FunctionObject{
      double x;
      double y;
      FunctionObject(double x, double y): x(x), y(y) {};      
      double operator ()(double a){   
         return a * a;
      }   
      double operator ()(double a, double b, double c){
          return a * x + b * y + c / (x + y);
      }
      double method1(double a){
          return this->x * a  + this->y / a;
      }
      double method2(double a, double b, double c){
          return  c * (a / x + b / y);
      }       
  };
#+END_SRC

It is possible to create lambda functions from those class methods
(member functions):

#+BEGIN_SRC cpp 
  FunctionObject obj;

  //-------------------------
  auto method1LambdaA = std::bind(&FunctionObject::method1, fobj, _1);
  // Equivalent to: 
  auto method1LambdaA = [&obj](double a){return obj.method1(x); };

  //-------------------------
  auto method2LambdaAsFnOfAC = std::bind(&FunctionObject::method2, &fobj, _1, 10.0, _2);
  // Equivalent to: 
  auto method2LambdaAsFnOfAC = [&obj](double a, double c){ return obj.method2(a, 10.0, c); }

  //-------------------------
  auto functionOfObj = std::bind(&FunctionObject::method1, _1, 10.0);
  // Equivalent to: 
  auto functionOfobj = [](FunctionObject a){ return obj.method1(obj, 10.0);};
#+END_SRC

**** std::bind Example 
     :PROPERTIES:
     :ID:       219c4de9-3e9e-446f-bdd5-1ae6e7d45b5b
     :END:

File: 
 +  [[file:src/lambda-bind.cpp][file:src/lambda-bind.cpp]]

Running: 

#+BEGIN_SRC sh 
  $ g++ lambda-bind.cpp -o lambda-bind.bin -g -std=c++11 -Wall -Wextra -ldl 
  $ ./lambda-bind.bin

  ======== Test 1 ========
  lambda-bind.cpp:58: ; sum10(2.0) = 12
  lambda-bind.cpp:59: ; sum10(4.5) = 14.5
  lambda-bind.cpp:60: ; sum10(25.0) = 35
  ======== Test 2 ========
  lambda-bind.cpp:66: ; vectorLenAsFunctionOfX(4.0) = 27.2213
  lambda-bind.cpp:67: ; std::bind(vectorLength, _1, 10.0, 25.0)(4.0) = 27.2213
  lambda-bind.cpp:68: ; vectorLenAsFunctionOfX(10.0) = 28.7228
  lambda-bind.cpp:69: ; std::bind(vectorLength, _1, 10.0, 25.0)(10.0) = 28.7228
  Tabulating - vectorLenAsFunctionOfX
       1.000    26.944
       2.000    27.000
       3.000    27.092
       4.000    27.221
       5.000    27.386
  ======== Test 3 ========
  lambda-bind.cpp:77: ; vectorLenAsFunctionOfY(14.0) = 30.348
  lambda-bind.cpp:78: ; vectorLenAsFunctionOfY(20.0) = 33.541
  Tabulating - vectorLenAsFunctionOfY
       1.000    26.944
       2.000    27.000
       3.000    27.092
       4.000    27.221
       5.000    27.386
  ======== Test 4 ========
  lambda-bind.cpp:92: ; vectorLenAsFunctionOfYZ(3.0, 6.0) = 12.0416
  lambda-bind.cpp:93: ; vectorLenAsFunctionOfYZ(15.0, 26.0) = 31.6386
  ======== Test 5 ========
  lambda-bind.cpp:97: ; fobj(4.0) = 16
  lambda-bind.cpp:98: ; fobj(5.0) = 25
  lambda-bind.cpp:99: ; fobj(10.0) = 100
  lambda-bind.cpp:101: ; fobj(4.0, 10.0, 5.0) = 104.357
  lambda-bind.cpp:102: ; fobj(6.0, 8.0, 9.0) = 100.643
  Running: tabulate(0.0, 5.0, 1.0, fobj)
       0.000     0.000
       1.000     1.000
       2.000     4.000
       3.000     9.000
       4.000    16.000
       5.000    25.000
  Turning class member function into lambda function 
   Note: it is not possible (0.0, 5.0, 1.0, fobj.method1)
  lambda-bind.cpp:111: ; fobj.method1(10.0) = 60.8
  lambda-bind.cpp:112: ; method1LambdaA(10.0) = 60.8
  lambda-bind.cpp:113: ; fobj.method1(20.0) = 120.4
  lambda-bind.cpp:114: ; method1LambdaA(20.0) = 120.4
  lambda-bind.cpp:115: ; fobj.method1(30.0) = 180.267
  lambda-bind.cpp:116: ; method1LambdaA(30.0) = 180.267
  Tabulating method1LambdaA
       0.000       inf
       1.000    14.000
       2.000    16.000
       3.000    20.667
       4.000    26.000
       5.000    31.600
  Tabulating method1LambdaA using direct lambda
       0.000       inf
       1.000    14.000
       2.000    16.000
       3.000    20.667
       4.000    26.000
       5.000    31.600
  ======== Test 6 ========
  lambda-bind.cpp:129: ; method2LambdaAsFnOfA(5.0) = 41.6667
  lambda-bind.cpp:130: ; method2LambdaAsFnOfA(6.0) = 45
  lambda-bind.cpp:131: ; method2LambdaAsFnOfA(10.0) = 58.3333
  lambda-bind.cpp:136: ; fobj.method2(3.0, 10.0, 4.0) = 7
  lambda-bind.cpp:137: ; method2LambdaAsFnOfAC(3.0, 4.0) = 7
  lambda-bind.cpp:138: ; fobj.method2(15.0, 10.0, 14.0) = 52.5
  lambda-bind.cpp:139: ; method2LambdaAsFnOfAC(15.0, 14.0) = 52.5


#+END_SRC
** OOP Polymorphism 
*** Overview 

 Dynamic or subtyping polymorphis is basically, the ability
 of the client code to deal with any any instance of derived classes in
 the same way it deals with an instance of the base class. 

 In C++, it is only possible to use OOP subtyping polymorphism with
 pointers or references. As a result, it is not possible to store
 instances of base class in STL containers by value, or to create
 polymorphic functions which return instance of derived classes by
 value or take instance derived classes as argument passed by value.

 To summarize: 

  + Object Oriented Polymorphism, is aso called:
    + Dynamic polymorphism
    + Runtime polymorphism 
  + In C++ it is only possible to use polymorphism with references or
    pointers.
  + A polymorphic function which returns any instance of the derived
    class casted as an instance of the base class can only return them
    *by pointer to objects allocated on the heap* (dynamic memory) with
    *new* operator. Functions like this are called factory functions and
    in this case, it is better to wrap the pointer in smart pointer,
    ~unique_ptr~ or ~shared_ptr~.
*** Dynamic Polymorphism example 

 File: polymorphism.cpp 

 #+BEGIN_SRC cpp 
   #include <iostream>
   #include <string>
   #include <memory>   // C++11 Smart pointers (unique_ptr and shared_ptr)
   #include <map>      // Hash table, hash map or dictionary
   #include <vector>
   #include <deque>

   #include <cassert> // assertions tests 

   // Interface class 
   class GenericDBDriver{
   public:
     GenericDBDriver() = default;
     virtual auto driverName()  const -> std::string {
       return "generic";   
     }
     virtual auto getID() const -> std::string {
       return "unknown";
     }
     virtual auto connect(std::string url) -> void {
       std::cout << "Connecting to generic driver url = " << url << std::endl;
     }
     virtual auto isConnected()  const -> bool {
       return false;
     }
     // Default destructor
     virtual ~GenericDBDriver() {
       std::cout << "Disconnecting from generic driver - id = " << "unknown"<< std::endl;
     }
   };

   class DriverSQLiteDriver: public GenericDBDriver{
   private:
     bool m_connected = false;
     std::string m_id = "unknown";
   public:
     DriverSQLiteDriver() = default;
     DriverSQLiteDriver(const std::string& name): m_id(name){}
    
     // Const keyword in this case indicates that the member function (method)
     // doesn't change the current object.
     auto driverName() const -> std::string override{
       return "sqlite";
     }
     auto getID() const -> std::string override {
       return m_id;
     }  
     // This keyword override -> indicates visually that the method
     // is being overriden and also provides some safety features which
     // helps to improve type-safety and compile-time correctness.
     // For instance, if member function (aka method) being overriden
     // is not annotated as virtual in the base class, this C++11 keyword
     // will generate a compile-time error. It also will generate a compile-time
     // error if the member function being overriden doesn't exist in the base class.  
     auto connect(std::string url) -> void override {
       std::cout << "Connecting to " << url << std::endl;
       m_connected = true;
     }
     auto isConnected() const -> bool override {
       return m_connected;
     }
     ~DriverSQLiteDriver(){
       std::cout << "Disconnecting from PosgresDB - m_id = " << m_id << std::endl;
     }
   };


   class DriverPostgresSQL: public GenericDBDriver{
   private:
     bool m_connected = false;
     std::string m_id = "unknown";  
   public:
     // DriverPostgresSQL () = default;
     DriverPostgresSQL(const std::string& name): m_id(name){}
 
     auto driverName() const -> std::string override{
       return "PostGresSQL";
     }
     virtual auto getID() const -> std::string override {
       return m_id;
     }   
     auto connect(std::string url) -> void override {
       std::cout << "Connecting to " << url << std::endl;
       m_connected = true;
     }
     auto isConnected() const -> bool override {
       return m_connected;
     }
     ~DriverPostgresSQL(){
       std::cout << "Disconnecting from PostGresSQL - id = " << m_id << std::endl;
     }  
   };


   class DriverSQLServer : public GenericDBDriver{
   private:
     bool m_connected = false;
     std::string m_id = "unknown";  
   public:
     DriverSQLServer() = default;
     DriverSQLServer(const std::string& name): m_id(name){}
      
     auto driverName() const -> std::string override{
       return "SQLServer";
     }
     auto getID() const -> std::string override {
       return m_id;
     }    
     auto connect(std::string url) -> void override {
       std::cout << "Connecting to " << url << std::endl;
       m_connected = true;
     }
     auto isConnected() const -> bool override {
       return m_connected;
     }
     ~DriverSQLServer(){
       std::cout << "Disconnecting from SQLServer - id = " << m_id << std::endl;
     }  
   };


   // Non-polymorphi function -> Parameters passed by value cannot be polymorphic
   // void showDriverStatus(const GenericDBDriver driver){ ... }

   // Polymorphic function using references 
   void showDriverStatus1(const GenericDBDriver& driver){
     std::cout << std::boolalpha;
     std::cout << " [INFO] Driver = " << driver.driverName()
               << " id = " << driver.getID()
               << " ; status = " << driver.isConnected() <<  std::endl;
   }

   // Polymorphic function using pointers 
   void showDriverStatus2(const GenericDBDriver* driver){
     std::cout << std::boolalpha;
     std::cout << " [INFO] Driver = " << driver->driverName()
               << " id = " << driver->getID()
               << " ; status = " << driver->isConnected() <<  std::endl;
   }


   // Factory method
   enum class DriverType{
    generic,
    sqlite,
    postgres,
    sqlserver                        
   };

   auto dbDriverFactory(const DriverType& dbtype, const std::string& id = "unknown")
     -> std::shared_ptr<GenericDBDriver>{
     if(dbtype == DriverType::generic)
       return std::make_shared<GenericDBDriver>();   
     if(dbtype == DriverType::sqlite)
       return std::make_shared<DriverSQLiteDriver>(id);   
     if(dbtype == DriverType::postgres)
       return std::make_shared<DriverPostgresSQL>(id);   
     if(dbtype == DriverType::sqlserver)
       return std::make_shared<DriverSQLServer>(id);    
     // Failure -> DO NOT return old C++98 NULL as it is not typesafe 
     return nullptr;
   }


   class DriverFactory{
   private:
  
   public:

     DriverFactory() = delete;
     DriverFactory(const DriverFactory& lhs) = delete;

     static auto getInstance() 
   };

   int main(){

     {
       std::cout << "\n====== Test 1 ===========" << std::endl;
       // Uniform initialization 
       GenericDBDriver   d0;
       DriverSQLServer   d1{"d1"};
       DriverPostgresSQL d2 = {"d2"};
       DriverSQLServer   d3 = {"d3"};

       showDriverStatus1(d0);
       showDriverStatus1(d1);
       d1.connect("file:///home/user/datbase.sqlite");
       showDriverStatus1(d1);
       showDriverStatus1(d2);
       showDriverStatus1(d3);

       std::cout << "====== End of test 1 ===========" << std::endl;
     }

     {
       std::cout << "\n====== Test 2 ===========" << std::endl;
       // Uniform initialization 
       GenericDBDriver   d0;
       DriverSQLServer   d1{"d1"};
       DriverPostgresSQL d2 = {"d2"};
       DriverSQLServer   d3 = {"d3"};

       showDriverStatus2(&d0);
       showDriverStatus2(&d1);
       d1.connect("file:///home/user/datbase.sqlite");
       showDriverStatus2(&d1);
       showDriverStatus2(&d2);
       showDriverStatus2(&d3);

       std::cout << "====== End of test 2 ===========" << std::endl;
     }

     { // Failure ! -> It only calls the methods of GenericDBDriver
       // It is not possible to polymorphism (subtyping polymorphism) in C++
       // without pointers or references.
       std::cout << "\n====== Test 3 ===========" << std::endl;
       std::deque<GenericDBDriver> xs;

       xs.push_back(GenericDBDriver{});
       xs.push_back(DriverSQLServer {"d1"});
       xs.push_back(DriverPostgresSQL{"d2"});
       xs.push_back(DriverSQLServer{"d3"});

       for(const auto& x: xs){
         std::cout << " - driver = " << x.driverName() << " ; id = " << x.getID() << std::endl;
       }

       assert(xs.at(0).driverName() == "generic");
       assert(xs.at(1).driverName() == "generic");
       assert(xs.at(2).driverName() == "generic");
       assert(xs.at(3).driverName() == "generic");
    
       std::cout << "\n====== End of test 3 ===========" << std::endl;
     }


     { std::cout << "\n====== Test 4 ===========" << std::endl;
       std::deque<GenericDBDriver*> xs;

       auto d0 = GenericDBDriver{};
       auto d1 = DriverSQLiteDriver {"d1"};
       auto d2 = DriverPostgresSQL{"d2"};
       auto d3 = DriverSQLServer{"d3"};
       xs.push_back(&d0);
       xs.push_back(&d1);
       xs.push_back(&d2);
       xs.push_back(&d3);

       for(const auto& x: xs){
         std::cout << " - driver = " << x->driverName() << " ; id = " << x->getID() << std::endl;;
       }
       assert(xs.at(0)->driverName() == "generic");
       assert(xs.at(1)->driverName() == "sqlite");
       assert(xs.at(2)->driverName() == "PostGresSQL");
       assert(xs.at(3)->driverName() == "SQLServer");
    
       std::cout << "====== End of test 4 ===========" << std::endl;
     }  

     { std::cout << "\n====== Test 5 ===========" << std::endl;
       std::deque<std::shared_ptr<GenericDBDriver>> xs;
       xs.push_back(dbDriverFactory(DriverType::generic));
       xs.push_back(dbDriverFactory(DriverType::sqlite,    "d1"));
       xs.push_back(dbDriverFactory(DriverType::postgres,  "d2"));
       xs.push_back(dbDriverFactory(DriverType::sqlserver, "d3"));
       for(const auto& x: xs){
         std::cout << " - driver = " << x->driverName() << " ; id = " << x->getID() << std::endl;;
       }
       assert(xs.at(0)->driverName() == "generic");
       assert(xs.at(1)->driverName() == "sqlite");
       assert(xs.at(2)->driverName() == "PostGresSQL");
       assert(xs.at(3)->driverName() == "SQLServer");
    
       std::cout << "====== End of test 5 ===========" << std::endl;
     }  
     return EXIT_SUCCESS;
   }
 #+END_SRC

 Running: 

 #+BEGIN_SRC sh
   $ clang++ polymorphism.cpp -std=c++1z -Wall -Wextra && ./a.out

   ====== Test 1 ===========
    [INFO] Driver = generic id = unknown ; status = false
    [INFO] Driver = SQLServer id = d1 ; status = false
   Connecting to file:///home/user/datbase.sqlite
    [INFO] Driver = SQLServer id = d1 ; status = true
    [INFO] Driver = PostGresSQL id = d2 ; status = false
    [INFO] Driver = SQLServer id = d3 ; status = false
   ====== End of test 1 ===========
   Disconnecting from SQLServer - id = d3
   Disconnecting from generic driver - id = unknown
   Disconnecting from PostGresSQL - id = d2
   Disconnecting from generic driver - id = unknown
   Disconnecting from SQLServer - id = d1
   Disconnecting from generic driver - id = unknown
   Disconnecting from generic driver - id = unknown

   ====== Test 2 ===========
    [INFO] Driver = generic id = unknown ; status = false
    [INFO] Driver = SQLServer id = d1 ; status = false
   Connecting to file:///home/user/datbase.sqlite
    [INFO] Driver = SQLServer id = d1 ; status = true
    [INFO] Driver = PostGresSQL id = d2 ; status = false
    [INFO] Driver = SQLServer id = d3 ; status = false
   ====== End of test 2 ===========
   Disconnecting from SQLServer - id = d3
   Disconnecting from generic driver - id = unknown
   Disconnecting from PostGresSQL - id = d2
   Disconnecting from generic driver - id = unknown
   Disconnecting from SQLServer - id = d1
   Disconnecting from generic driver - id = unknown
   Disconnecting from generic driver - id = unknown

   ====== Test 3 ===========
   Disconnecting from generic driver - id = unknown
   Disconnecting from SQLServer - id = d1
   Disconnecting from generic driver - id = unknown
   Disconnecting from PostGresSQL - id = d2
   Disconnecting from generic driver - id = unknown
   Disconnecting from SQLServer - id = d3
   Disconnecting from generic driver - id = unknown
    - driver = generic ; id = unknown
    - driver = generic ; id = unknown
    - driver = generic ; id = unknown
    - driver = generic ; id = unknown

   ====== End of test 3 ===========
   Disconnecting from generic driver - id = unknown
   Disconnecting from generic driver - id = unknown
   Disconnecting from generic driver - id = unknown
   Disconnecting from generic driver - id = unknown

   ====== Test 4 ===========
    - driver = generic ; id = unknown
    - driver = sqlite ; id = d1
    - driver = PostGresSQL ; id = d2
    - driver = SQLServer ; id = d3
   ====== End of test 4 ===========
   Disconnecting from SQLServer - id = d3
   Disconnecting from generic driver - id = unknown
   Disconnecting from PostGresSQL - id = d2
   Disconnecting from generic driver - id = unknown
   Disconnecting from PosgresDB - m_id = d1
   Disconnecting from generic driver - id = unknown
   Disconnecting from generic driver - id = unknown

   ====== Test 5 ===========
    - driver = generic ; id = unknown
    - driver = sqlite ; id = d1
    - driver = PostGresSQL ; id = d2
    - driver = SQLServer ; id = d3
   ====== End of test 5 ===========
   Disconnecting from generic driver - id = unknown
   Disconnecting from PosgresDB - m_id = d1
   Disconnecting from generic driver - id = unknown
   Disconnecting from PostGresSQL - id = d2
   Disconnecting from generic driver - id = unknown
   Disconnecting from SQLServer - id = d3
   Disconnecting from generic driver - id = unknown

 #+END_SRC


*** STL containers and polymorphism 

C++'s STL (Standard Template Library) containers/collections such as
vector, deque, map, stack and so on can only store pointers to
instances of different derived classes from a given base
class. However the STL containers cannot store references to those
instances. The STL std::reference_wrapper solves this problem. 

Documentation: 
  + http://www.cplusplus.com/reference/functional/reference_wrapper/operator_func/

Demonstration in CERN's ROOT C++ REPL: 

 - Create test classes.

#+BEGIN_SRC cpp 
  // Base class 
  class IRoot{
  public:
    virtual auto getName() const -> std::string {
      return "root";
    }
  };

  //===== Derived Classes ====== //
 
  class A: public IRoot{
  public:
    auto getName() const -> std::string {
      return "Class A";
    }
  };

  class B: public IRoot{
  public:
    auto getName() const -> std::string {
      return "Class B";
    }
  };
#+END_SRC

 - Play with sample objects:

#+BEGIN_SRC cpp 
  // Create test objects 
  auto r = IRoot();
  auto a = A();
  auto b = B();

  // Test objects 
  >> r.getName()
  (std::string) "root"
  >> a.getName()
  (std::string) "Class A"
  >> b.getName()
  (std::string) "Class B"
  >>
#+END_SRC

 - Store those objects in a collection by pointer:

#+BEGIN_SRC cpp 
  >> auto xsp = std::deque<IRoot*>()
  (std::deque<IRoot *, std::allocator<IRoot *> > &) {}
  >> xsp.push_back(&r)
  >> xsp.push_back(&a)
  >> xsp.push_back(&b)
  >> xsp
  (std::deque<IRoot *, std::allocator<IRoot *> > &) { @0x2f01990, @0x2f01998, @0x2f019a0 }
  >>
  >>

  >> for(auto x: xsp) { std::cout << "name = " << x->getName() << std::endl; }
  name = root
  name = Class A
  name = Class B
  >>

#+END_SRC

 - Try to store those object r, a and b in a container/collection by
   reference.

#+BEGIN_SRC cpp 
  /** Many of errors: new_allocator.h:63:18: error: 'pointer' declared
   ,* as a pointer to a reference of type 'IRoot &' typedef _Tp* pointer;
   ,*/
  auto xs = std::deque<IRoot&>() 
#+END_SRC

 - Try to store those object r, a and b in a container/collection by
   reference using _std::reference_wrapper_.

#+BEGIN_SRC cpp 
  >> auto xsr = std::deque<std::reference_wrapper<IRoot>> {}
  (std::deque<std::reference_wrapper<IRoot>, std::allocator<std::reference_wrapper<IRoot> > > &) {}
  >>

  xsr.push_back(a)
  xsr.push_back(r)
  xsr.push_back(b)

  >> xsr
  (std::deque<std::reference_wrapper<IRoot>, std::allocator<std::reference_wrapper<IRoot> > > &)
  { @0x31013c0, @0x31013c8, @0x31013d0 }
  >>

  >> xsr.at(0).get().getName()
  (std::string) "Class A"
  >> xsr.at(1).get().getName()
  (std::string) "root"
  >> xsr.at(2).get().getName()
  (std::string) "Class B"
  >> 
  >>

  >> for(auto x: xsr) { std::cout << "name = " << x.get().getName() << std::endl; }
  name = Class A
  name = root
  name = Class B
  >> 

  >> for(const auto& x: xsr) { std::cout << "name = " << x.get().getName() << std::endl; }
  name = Class A
  name = root
  name = Class B
  >> 
#+END_SRC

References: 

 + https://oopscenities.net/2012/08/09/reference_wrapper/

 + How to correctly use std::reference_wrappers -
   <https://stackoverflow.com/questions/18127469/how-to-correctly-use-stdreference-wrappers>
** Pointer to Member Function 
   :PROPERTIES:
   :ID:       07dc0b5f-0486-4c18-b356-226ec48d4834
   :END:

In addition to ordinary pointers and function pointers, C++ has member
function pointers which can point to a particular class method and be
used for performing indirect method calls. 

Despite member function pointer are much less used than other types of
pointers, they are still useful in lots of use cases such as: 

 + Implementing callbacks => Example: QT Slots and Signals.
 + Creating warappers     => Example: Boost.Python 
 + Reflection 

Pointer Member Function variable declaration : 

  + It declares a pointer-to-member function of the class
    _CLASS_NAME_. The pointer variable  is named pVariable and has the
    type signature:  _(ARG0, ARG1, ... ARGN) => RETURN_TYPE_

#+BEGIN_SRC cpp 
   RETURN_TYPE (CLASS_NAME::* pVariable) (ARG0, ARG1, ..., ARGN-1);
   RETURN_TYPE (CLASS_NAME::* pVariable) (ARG0, ARG1, ..., ARGN-1) = nullptr;
   RETURN_TYPE (CLASS_NAME::* pVariable) (ARG0, ARG1, ..., ARGN-1) = &CLASS_NAME::member_functionA;
   RETURN_TYPE (CLASS_NAME::* pVariable) (ARG0, ARG1, ..., ARGN-1) = &CLASS_NAME::member_functionB;
#+END_SRC

  + Example: Pointer to any member function taking zero arguments and
    returning a string.

#+BEGIN_SRC cpp 
   std::string (Dummy::* pMemfn) () = nullptr;
#+END_SRC

  + Invoking a pointer to member function. It is necessary an instance
    of the class in order to invoke the member function pointed by the
    pointer.

#+BEGIN_SRC cpp 
   CLASS_TYPE obj;
   pVariable = &CLASS_TYPE::member_function1;
   (obj.*pVariable)(arg0, arg1, arg2, ... argn);
#+END_SRC


  + Type synonym with Typdef 

#+BEGIN_SRC cpp 
   typedef RETURN_TYPE (CLASS_NAME::* pMemberFunction) (ARG0, ARG1, ..., ARGN-1);
   pMemberFunction pvar = &CLASS_NAME::member_functionA;
   CLASS_NAME obj;
   (obj.*pvar)(arg0, arg1, .... argn-1);
#+END_SRC

  + Type synonym with C++11 "using" keyword

#+BEGIN_SRC cpp 
   using pMemberFunction = RETURN_TYPE (CLASS_NAME::*) (ARG0, ARG1, ..., ARGN-1);
   pMemberFunction pvar = &CLASS_NAME::member_functionA;
   CLASS_NAME obj;
   (obj.*pvar)(arg0, arg1, .... argn-1);
#+END_SRC

 *Further Reading:*
 
 + [[https://accu.org/index.php/journals/495][ACCU - An Application of Pointers to Members]]
 + [[http://soggywizards.com/tips/code/c%2B%2B/member-pointers.html][Pointers to C++ Member Functions]]
 + [[https://yosefk.com/c%2B%2Bfqa/function.html][C++ FQA Lite: Pointers to member functions]]
 + [[https://arne-mertz.de/2017/01/decltype-declval/][Modern C++ Features - decltype and std::declval - Simplify C++!]]
 + [[https://isocpp.org/wiki/faq/pointers-to-members][Pointers to Member Functions, C++ FAQ]]
 + [[https://wiki.qt.io/New_Signal_Slot_Syntax][New Signal Slot Syntax - Qt Wiki]]
 + [[https://www.codeguru.com/cpp/cpp/article.php/c17401/C-Tutorial-PointertoMember-Function.htm][C++ Tutorial: Pointer-to-Member Function]]
 + [[https://embeddedartistry.com/blog/2017/1/26/c11-improving-your-callback-game][Improving Your Callback Game — Embedded Artistry]]
 

 *Example*

File: 
  - [[file:src/member-function-pointer.cpp][file:src/member-function-pointer.cpp]]
  - Online compiler: http://rextester.com/WYFC32509

#+BEGIN_SRC cpp :tangle src/member-function-pointer.cpp
  #include <iostream>
  #include <string>
  #include <iomanip>
  #include <deque>
  #include <map>
  #include <cassert>

  class Dummy {
  private:
          std::string _name = "unnamed";
  public:
          Dummy(){}
          Dummy(const std::string& name): _name(name){}
          ~Dummy() = default;
          std::string getName() {
                  return "I am a dummy class named <" + _name + ">";
          }
          std::string getLocation() {
                  return "Unknown location";
          }
          std::string operator()(){
                  return "I am a function-object called: <" + _name + ">";
          }
          auto compute(double x, double y) -> double {
                  return 4 * x + 5 * y;
          }	
  };

  class DummyB{
  public:
          DummyB(){}
          ~DummyB() = default;
          std::string getName() {
                  return "My name is DummyB";
          }
          std::string getLocation() {
                  return "Location of dummyB location";
          }
          std::string operator()(){
                  return "I am the class DummyB";
          }
  };

  // Create type synonym to any member function of Dummy class
  // which takes no parameter and returns a string.
  typedef std::string (Dummy::* pDummyMemFnStr)();

  void invokeMemberFun(Dummy& obj, pDummyMemFnStr pMemfn){
          std::cout << " [1] Method invocation returned value: " << (obj.*pMemfn)() << "\n";
  }

  // Create type synonum with the new "using" C++11 syntax
  using pDummyMemFnStrCPP11 = std::string (Dummy::*)();

  auto invokeMemberFun2(Dummy& obj, pDummyMemFnStrCPP11 pMemfn) -> void {
          std::cout << " [2] Method invocation returned value: " << (obj.*pMemfn)() << "\n";
  }

  template<class T>
  auto invokeMemberFun3(T& obj, std::string (T::* pMemfn)()) -> void{
          std::cout << " [3] Method invocation returned value: " << (obj.*pMemfn)() << "\n";
  }

  template<class T, class R, class ... Args>
  auto invokeMemfn(R (T::* pMemfn) (Args ... args), T& obj, Args ... arglist) -> R{
          return (obj.*pMemfn)(arglist ...);
  }

  int main(){
          const auto nl = std::string("\n");
          const auto nl2 = std::string("\n\n");
          const std::string line = "--------------------------------------------------\n";
	
          std::cout << nl << "=== Experiment 1 ===============" << nl2;
          std::cout << line;
          // Pointer to member function to any member functions
          // (aka method) which takes no argument and returns a string
          // of signature: () => std::string
          //.....................................................
          std::string (Dummy::* pMemfn) () = nullptr;
          // std::string (Dummy::* pMemfn) ();
          if(pMemfn == nullptr)
                  std::cerr << " [INFO] Pointer not initilialized yet." << nl;

          Dummy d("DUMMY");
	
          // Set the function pointer to member function getName().
          pMemfn = &Dummy::getName;
          // Invoke pointer to member function (aka pointer to method)
          std::cout << "Name     = " << (d.*pMemfn)() << nl2;
          assert((d.*pMemfn)() == "I am a dummy class named <DUMMY>");

          if(pMemfn != nullptr)
                  std::cerr << " [INFO] Pointer initilialized OK." << nl;
	
          // Set pointer to Dummy::getLocation
          pMemfn = &Dummy::getLocation;
          std::cout << "Location = " << (d.*pMemfn)() << nl;
          // assert((d.*pMemfn)() == "I am a dummy class named <DUMMY>");	
	
	
          std::cout << nl << "=== Experiment 2 - Using typedef ===============" << nl;
          std::cout << line;
          pDummyMemFnStr pMemfn2 = nullptr;
          pMemfn2 = &Dummy::getName;
          std::cout << "d.getName() == " << (d.*pMemfn2)() << nl;
          assert((d.*pMemfn2)() == "I am a dummy class named <DUMMY>");	

          std::cout << nl << "=== Experiment 3 - Invoking member function with free function =" << nl;
          std::cout << line;
          // execute d.getName() 
          invokeMemberFun(d, &Dummy::getName);
          // execute d.getLocation() 
          invokeMemberFun(d, &Dummy::getLocation);
          // execute d() 
          invokeMemberFun(d, &Dummy::operator());
	
          std::cout << nl << "=== Experiment 4 - Invoking member function with free function C++11" << nl;
          std::cout << line;
          invokeMemberFun2(d, &Dummy::getName);
          invokeMemberFun2(d, &Dummy::getLocation);
          invokeMemberFun2(d, &Dummy::operator());

          std::cout << nl << "=== Experiment 5 - Pointer to member functions in STL deque collection" << nl;
          auto plist = std::deque<pDummyMemFnStrCPP11>();
          plist.push_back(&Dummy::getName);
          plist.push_back(&Dummy::getLocation);
          plist.push_back(&Dummy::operator());
          for(const auto& p: plist)
                  std::cout << " (+) Calll returned = " << (d.*p)() << nl;

          std::cout << nl << "=== Experiment 6 - Pointer to member functions in map collection" << nl;
          auto dict = std::map<std::string, pDummyMemFnStrCPP11>();
          dict["getName"]     = &Dummy::getName;
          dict["getLocation"] = &Dummy::getLocation;
          dict["callme"]      = &Dummy::operator();
          for(const auto& kv: dict)
                  std::cout << std::right << std::setw(20)  << "invoke(object, "
                                    << std::setw(15) << kv.first << ")"
                                    << " = " << (d.*(kv.second))() << nl;

          std::cout << nl << "=== Experiment 7 - Template " << nl;
          DummyB b;
          invokeMemberFun3(d, &Dummy::getName);
          invokeMemberFun3(b, &DummyB::getName);
          invokeMemberFun3(d, &Dummy::getLocation);
          invokeMemberFun3(b, &DummyB::getLocation);

          std::cout << nl << "=== Experiment 8 - Template " << nl;
          std::cout << line;
          std::cout << "d.getName()         = " << invokeMemfn(&Dummy::getName, d) << nl;
          std::cout << "d.compute(3.0, 4.0) = " << invokeMemfn(&Dummy::compute, d, 3.0, 4.0) << nl;
	
          return 0;
  }

#+END_SRC

Running: 

#+BEGIN_SRC sh 
   $ clang++ member-function-pointer.cpp -o member-function-pointer.bin -std=c++1z -Wall -Wextra  && ./member-function-pointer.bin

   === Experiment 1 ===============

   --------------------------------------------------
    [INFO] Pointer not initilialized yet.
   Name     = I am a dummy class named <DUMMY>

    [INFO] Pointer initilialized OK.
   Location = Unknown location

   === Experiment 2 - Using typedef ===============
   --------------------------------------------------
   d.getName() == I am a dummy class named <DUMMY>

   === Experiment 3 - Invoking member function with free function =
   --------------------------------------------------
    [1] Method invocation returned value: I am a dummy class named <DUMMY>
    [1] Method invocation returned value: Unknown location
    [1] Method invocation returned value: I am a function-object called: <DUMMY>

   === Experiment 4 - Invoking member function with free function C++11
   --------------------------------------------------
    [2] Method invocation returned value: I am a dummy class named <DUMMY>
    [2] Method invocation returned value: Unknown location
    [2] Method invocation returned value: I am a function-object called: <DUMMY>

   === Experiment 5 - Pointer to member functions in STL deque collection
    (+) Calll returned = I am a dummy class named <DUMMY>
    (+) Calll returned = Unknown location
    (+) Calll returned = I am a function-object called: <DUMMY>

   === Experiment 6 - Pointer to member functions in map collection
        invoke(object,          callme) = I am a function-object called: <DUMMY>
        invoke(object,     getLocation) = Unknown location
        invoke(object,         getName) = I am a dummy class named <DUMMY>

   === Experiment 7 - Template 
    [3] Method invocation returned value: I am a dummy class named <DUMMY>
    [3] Method invocation returned value: My name is DummyB
    [3] Method invocation returned value: Unknown location
    [3] Method invocation returned value: Location of dummyB location

   === Experiment 8 - Template 
   --------------------------------------------------
   d.getName()         = I am a dummy class named <DUMMY>
   d.compute(3.0, 4.0) = 32

#+END_SRC
** Template Metaprogramming or Generic Programming 
*** Overview 

 *C++ Metaprogramming Features:*

 + _Templates_
   + Use case:
     + Template metaprogramming or generic programming
     + Generic classes and containers
     + Generic algorithms
     + Compile-time optmization
     + Write high performance code by eliminating virtual member
       function calls.
   + Limitation: Unfortunately, the C++ templates cannot manipulate
     the AST and generate code in the way that LISP-like languages
     do. 

 + C++11 _Constexpr_
   + Use cases:
     + Compile-time computations such as look up tables, math
       constants, CRC32, hash, string encryption and obfuscation at
       compile-time and so on.

 + _Inline functions_
   + Use cases:
     + Removing function-calls. The function code is inserted at the
       call-site by the compiler allowing a more efficient and
       perfomant code.

 + _Pre-processor macros_
   + Use-cases:
     + Debugging, print line number, file, current function, function
       signature and so on. 
     + Conditional compilation
     + Conditional compilation for cross platform compatibility
     + Boilerplate code generation which cannot be done with templates
       or anything else.
     + Generation of reflection data. 

 *Generic Programming / Template Metaprogramming Design Patterns:*

 + _Generic Functions, algorithms and containers_
   + Some known use cases:
     + C++ STL introduced by Alexander Stepanov.
     + Boost Libraries
 + _CRTP => Curious Recurring Template Pattern_
   + Eliminates virtual function-calls overhead by emulating
     inheritance or dynamic polymorphism with static polymorphism or
     template metaprogramming.
 + _Type Erasure_ 
   + Despite the high performance and the ability to operate ony type
     regardless of the class hierarchy, the main shortcoming of
     generic programming is that, it is not possible to store
     unrelated types in the same containers or access them by the same
     pointer. The type erasure technique address those downsides by
     combining generic programmign and generic programming.
   + Known uses:
     + std::function (C++11)
     + std::any (C++17), Boost.any, std::variant (C++17) and Boost.variant
 + _EP => Expression Template_ => Technique used by many scientific
   library for encoding DSL - Domain Specific Languages with
   templates.
   + Some known uses of this design pattern are:
     + Linear Algebra: librareis Blitz++, Eigen and Armadillo
     + Automatic Differentiation.
 + _Meta Functions_ => "Functions" emualted with structs and static
   methods or members that can manipulate types or query information
   about types using template specialisation.
 + _Policy Based Design_
 + _SFINAE_

 *Libraries and Frameworks for metaprogramming:*

 + [[https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html][Boost.Hana]]  
 + [[https://www.boost.org/doc/libs/1_68_0/libs/fusion/doc/html/fusion/preface.html][Boost.Fusion]] 
 + [[https://www.boost.org/doc/libs/1_68_0/libs/mpl/doc/index.html][Boost.MPL]] 

 *Tool for testing templates online* 

 + [[http://metashell.org/index.html][Home - Metashell]] - "The goal of this project is to provide an
   interactive template metaprogramming shell." 


 *Template Metaprogramming Reference* 

 - Andrei Alexandrescu's *Loki Library* (http://loki-lib.sourceforge.net/)
   + type list
   + functor
   + singleton
   + object factory
   + visitor
   + multi methods
   + pimpl - pointer to implementation.

*** Template type-safe duck-typing or structural typing 

 In dynamically programming languages like Python, Ruby and etc, a
 function or method can accept any object implementing the methods
 referred in the function body regardless of the object base or
 interface. For instance, in the code below the function describeArea
 will work with any class implementing the methods .area() and .name()
 not matter the object's base class. 

 This ability to work with any object which has that requested types,
 in this case .area() and .name() is called _duck-typying_. Other
 languages with duck-typing ability are Smalltalk, Groovy, C#, Scala
 and Objective-C. The advantage of duck-typing is that function or
 methods can work with classes without an inheritance hierarchy or a
 common base class.

 #+BEGIN_SRC python 
   def describeArea(shape):
       print("Shape is      = " + shape.name())
       print("Shape area is = " + str(shape.area()))

   class Square:
       def __init__(self, side):
           self.side = side 
       def area(self):
           return self.side * self.side
       def name(self):
           return "square"

   class Circle:
       def __init__(self, radius):
           self.radius = radius
       def area(self):
           return self.radius * self.radius  * 3.1415
       def name(self):
           return "circle"    
 #+END_SRC

 Running: 

 #+BEGIN_SRC python 
   >>> s = Square(10)
   >>> c = Circle(3)
   >>>

   >>> describeArea(s)
   Shape is      = square
   Shape area is = 100
   >>> 
   >>> describeArea(c)
   Shape is      = circle
   Shape area is = 28.273500000000002
   >>> 
   >>> 
 #+END_SRC


  *C++ "Duck-typing" or type-safe structural typing*

 C++ templates feature supports a more type-safe duck-typing as the
 feature allows to write functions or methods which works with any
 object implementing the methods requested in the template code
 regardless of passed types have a common class hierarchy or a base
 class. However, unlike Python or Scala's duck typing, C++'s template
 doesn't have performance penalty due to dynamic polymorphism or
 reflection as it generates code at compile-time for each parameter
 type. 

 The C++'s template duck-typing is also called static polymorphism as a
 contrast to dynamic polymorphism which requires that all objects
 passed to a function or method implement the same base class.

 Example: The function describeArea works with any object implementing
 the methods area() and name(), however unlike Python and other
 dynamically typed languages, if an object that doesn't implement none
 of those mentioned methods is passed as argument, a compile error will
 be generated rather than a runtime error. 

 The advantage of C++ template is that it eliminates the runtime
 overhead of dynamic polymorphism or virtual function calls, therefore
 makes the code more performant and loosely coupled as it can work with
 any class without any inheritance hierarchy.  

 #+BEGIN_SRC cpp 
   #include <iostream>

   // Works with any type T which implements .name() or .area()
   template <class T>
   void describeArea(const T& obj){
           std::cout << "Shape is = " << obj.name() << std::endl;
           std::cout << "Area is  = " << obj.area() << std::endl;
           std::cout << "---------" << std::endl;
   }

   class Circle{
   private:
           double m_radius;
   public:
           Circle(double radius): m_radius(radius) {};
           double area() const {
                   return 3.1415 * m_radius * m_radius;
           }
           const char* name() const {
                   return "circle";
           }	
   };

   class Square{
   private:
           double m_side;
   public:
           Square(double side): m_side(side) {};
           double area() const {
                   return m_side * m_side;
           }
           const char* name() const {
                   return "square";
           }
   };

   int main(){
           Square s(4.0);
           Circle c(3.0);
           describeArea(s);
           describeArea(c);
           return 0;
   }

 #+END_SRC

 Running: 

  - The template generates multiple versions of the function
    describeArea specific for each type, for instance, it generates,
    describeArea(const Circle&) and describeArea(const Square&). The
    static polymorphism is a high performance alternative to the use of
    dynamic polymorphism, inheritance, and virtual methods since the
    methods that will be called are resolved at compile-time.

 #+BEGIN_SRC sh 
   $ clang++ -std=c++11 templateDuckTyping.cpp -o out.bin && ./out.bin
   Shape is = square
   Area is  = 16
   ---------
   Shape is = circle
   Area is  = 28.2735
   ---------
 #+END_SRC

 Summary: 

  + C++ Templates works in similar fashion to dynamically typed
    languages' duck typing.

  + Templates can make the code more loosely coupled as they works with
    any class or type implementing the requested methods.

  + Templates have zero cost and follows the C++ motto, "don't pay for
    what you don't use" they only generate code when requested or
    instantiated.

  + Templates are widely used in the STL (Standard Template Library)
    and the Boost Library.
*** Templates and C++ iterators 

Templates can be used for writing more generic and resuable code which
operates like functions or STL algorithms on  any type of iterator or
container. 

This example shows how to implement generic code which operates on any
type of container or iterator in modern C++.

 + File: [[file:src/template-iterator-container.cpp][file:src/template-iterator-container.cpp]]

Code highlights:

#+BEGIN_SRC cpp 
  namespace IterUtils{
          template<class Iterator>
          double sumContainer(const Iterator& begin, const Iterator& end){
                  double sum = 0.0;
                  for(Iterator it = begin; it != end; ++it)
                          sum += *it;
                  return sum;
          }

          // Sum elements of any type <Container> with methods .begin() and .end()
          // returnign iterators.
          template<class U, class Container>
          auto sumContainer2(const Container& container) -> U{
                  U sum{}; // Uniform initialization
                  for(auto it = container.begin(); it != container.end(); ++it)
                          sum += *it;
                  return sum;
          }

          template<class Iterator>
          auto printContainer(
                  const Iterator& begin,
                  const Iterator& end,
                  const std::string& sep = ", " ) -> void
          {
                  for(Iterator it = begin; it != end; ++it)
                          std::cout <<  *it << sep;
          }

          template<class Container>
          auto printContainer2(
                    const Container& cont
                   ,const std::string& sep = ", "
                  ) -> void
          {
                  // C++11 For-range based loop
                  for(const auto& x: cont)
                          std::cout <<  x << sep;
          }

          // Higher order function
          // The parameter actions accepts any type which can be called like
          // a function returning void.
          //
          // Note: It doesn't matter as it is possible to use both class T or typename T.
          template<typename Container, typename Function>
          auto for_each (const Container cont, Function action) -> void
          {
                  for(const auto& x: cont) action(x);
          }

  }; // ----- End of namespace IterUtils ----- //
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
  $ clang++ template-iterator-container.cpp -o template-iterator-container.bin -g -std=c++11 -Wall -Wextra 
  $ ./template-iterator-container.bin

  =========== Experiment 1 - sumContainer
  template-iterator-container.cpp:95: ; iu::sumContainer(&carray[0], &carray[0] + arrsize) = 16
  template-iterator-container.cpp:96: ; iu::sumContainer(vec1.begin(), vec1.end()) = 16
  template-iterator-container.cpp:97: ; iu::sumContainer(list1.begin(), list1.end()) = 16
  template-iterator-container.cpp:98: ; iu::sumContainer(deque1.begin(), deque1.end()) = 16

  =========== Experiment 2 - sumContainer2 
  template-iterator-container.cpp:101: ; iu::sumContainer2<double>(vec1) = 16
  template-iterator-container.cpp:102: ; iu::sumContainer2<int>(vec1) = 15
  template-iterator-container.cpp:103: ; iu::sumContainer2<double>(list1) = 16
  template-iterator-container.cpp:104: ; iu::sumContainer2<int>(list2) = 114

  =========== Experiment 3 - printContainer 

  Contents of carray  = 1, 2, 4.5, 2.5, 6, 
  Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
  Contents of vec2  = c++, templates, awesome, binary, 
  Contents of list1 = 1, 2, 4.5, 2.5, 6, 

  =========== Experiment 4 - printContainer2 

  Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
  Contents of vec2  = c++, templates, awesome, binary, 
  Contents of list1 = 1, 2, 4.5, 2.5, 6, 

  =========== Experiment 5 - for_each higher order function 

  Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
  Contents of vec2  = c++, templates, awesome, binary, c++, templates, awesome, binary, 
  Contents of m1  = 
    earth-gravity     9.810
            euler     2.718
               pi     3.142
                x     2.345

#+END_SRC

*** Basic Template Specialization 
    :PROPERTIES:
    :ID:       80f3766a-39eb-47ef-a3f5-5a49ef183db0
    :END:

Code example showing template specialization. As the code shows, the
template specilization can be used for type introspection, type
identification and implement reflection.

 + File: [[file:src/template-specialization1.cpp][file:src/template-specialization1.cpp]]
 + Online compiler: http://rextester.com/BKG53705

#+BEGIN_SRC cpp :tangle src/template-specialization1.cpp
  #include <iostream>
  #include <iomanip>    // Stream manipulator std::fixed, std::setw ... 
  #include <vector>
  #include <cmath>      // sin, cos, tan, exp ... M_PI, M_E ...
  #include <functional> // std::function 

  // ============= Example 1 ===============================//

  // Check whether type is float point 
  template<class T>
  auto isFPNumber() -> bool {
          return false;
  }
  // Template specialization of isFPNumber for type float
  template<> auto isFPNumber<float>() -> bool {
          return true;
  }
  // Template specialization of isFPNumber for type double 
  template<> auto isFPNumber<double>() -> bool {
          return true;
  }

  // ============= Example 2 - Template specialization for runtime type identification ====//
  // Note: this technique can be used for implemeting custom C++ reflection 

  // Return name of a given type 
  template<class Type>
  auto TypeName() -> const char* { return "unknown"; }

  #define REGISTER_TYPE(type)  template<> \
          auto TypeName<type>() -> const char* { return #type; } 

  // Specialization for int type 
  template<>
  auto TypeName<int>() -> const char* { return "int"; }

  // Automate boilerplate code using macros.
  REGISTER_TYPE(bool);
  REGISTER_TYPE(std::string);
  REGISTER_TYPE(const char*);
  REGISTER_TYPE(float);
  REGISTER_TYPE(double);
  REGISTER_TYPE(long);
  REGISTER_TYPE(unsigned);
  REGISTER_TYPE(char);
  REGISTER_TYPE(long long);

  // ============= Example 3 - Template with int argument specialization ===//
  template<int>
  const char* getNumberName(){
          return "I down't known";
  }
  template<> const char* getNumberName<0>(){ return "zero"; }
  template<> const char* getNumberName<1>(){ return "one"; }
  template<> const char* getNumberName<2>(){ return "two"; }
  template<> const char* getNumberName<3>(){ return "three"; }

  // ============= Example 4 - Template with bool argument specialization ====//
  template<bool>
  struct boolTemplate;

  template<> struct boolTemplate<false>{
          static auto getName() -> const char* { return "false"; }
  };
  template<> struct boolTemplate<true>{
          static auto getName() -> const char* { return "true"; }
  };

  // ============= Example 5 - Check whether types are equal ====//
  // Partial template specialization 

  template<class A, class B>
  struct type_equal{
          static bool get(){ return false; }
          enum { value = 0 };
  };

  // Partial specialisation
  template<class A>
  struct type_equal<A, A>{
          static bool get(){ return true; }
          enum { value = 1};
  };

  int main(){
          const char nl = '\n';
          std::cout << std::boolalpha;

          std::cout << nl << "EXPERIMENT 1 - Check whether type is float pointer" << nl;
          std::cout << "--------------------------------------------" << nl;	
          std::cout << "is float point type<int>    ? = " << isFPNumber<int>() << nl;
          std::cout << "is float point type<char>   ? = " << isFPNumber<char>() << nl;
          std::cout << "is float point type<float>  ? = " << isFPNumber<float>() << nl;
          std::cout << "is float point type<double> ? = " << isFPNumber<float>() << nl;

          std::cout << nl << "EXPERIMENT 2 - Type introspection" << nl;
          std::cout << "--------------------------------------------" << nl;	
          std::cout << "type = " << TypeName<int>() << nl;
          std::cout << "type = " << TypeName<char>() << nl;
          std::cout << "type = " << TypeName<float>() << nl;
          std::cout << "type = " << TypeName<const char*>() << nl;
          std::cout << "type = " << TypeName<std::string>() << nl;	
	
          std::cout << nl << "EXPERIMENT 3 - Templates with integers as arguments" << nl;
          std::cout << "--------------------------------------------" << nl;
          std::cout << "getNumberName<0>() = " << getNumberName<0>() << nl;
          std::cout << "getNumberName<1>() = " << getNumberName<1>() << nl;
          std::cout << "getNumberName<2>() = " << getNumberName<2>() << nl;
          std::cout << "getNumberName<10>() = " << getNumberName<10>() << nl;
          std::cout << "getNumberName<14>() = " << getNumberName<14>() << nl;

          std::cout << nl << "EXPERIMENT 4 - Templates with bool as arguments" << nl;
          std::cout << "--------------------------------------------" << nl;	
          std::cout << "boolTemplate<false>::getName>()  = " << boolTemplate<false>::getName() << nl;
          std::cout << "boolTemplate<true>::getName>()   = " << boolTemplate<true>::getName() << nl;

          std::cout << nl << "Check whether types are equal" << nl;
          std::cout << "type_equal<int, char>::get()       = "  << type_equal<int, char>::get() << nl;	
          std::cout << "type_equal<char, double>::get()    = "  << type_equal<char, double>::get() << nl;
          std::cout << "type_equal<double, double>::get()  = "  << type_equal<double, double>::get() << nl;
          std::cout << "type_equal<int, int>::get()        = "  << type_equal<int, int>::get() << nl;

          if(type_equal<int, double>::value)
                  std::cout << "[1] Types are equal\n";
          else
                  std::cout << "[1] Types are not equal\n";

          if(type_equal<double, double>::value)
                  std::cout << "[2] Types are equal\n";
          else
                  std::cout << "[2] Types are not equal\n";
	
	
          return 0;
  }

#+END_SRC

Program output: 

#+BEGIN_SRC sh 
  $ clang++ template-specialization1.cpp -o template-specialization1.bin -g -std=c++11 -Wall -Wextra 
  $ ./template-specialization1.bin

  EXPERIMENT 1 - Check whether type is float pointer
  --------------------------------------------
  is float point type<int>    ? = false
  is float point type<char>   ? = false
  is float point type<float>  ? = true
  is float point type<double> ? = true

  EXPERIMENT 2 - Type introspection
  --------------------------------------------
  type = int
  type = char
  type = float
  type = const char*
  type = std::string

  EXPERIMENT 3 - Templates with integers as arguments
  --------------------------------------------
  getNumberName<0>() = zero
  getNumberName<1>() = one
  getNumberName<2>() = two
  getNumberName<10>() = I down't known
  getNumberName<14>() = I down't known

  EXPERIMENT 4 - Templates with bool as arguments
  --------------------------------------------
  boolTemplate<false>::getName>()  = false
  boolTemplate<true>::getName>()   = true

  Check whether types are equal
  type_equal<int, char>::get()       = false
  type_equal<char, double>::get()    = false
  type_equal<double, double>::get()  = true
  type_equal<int, int>::get()        = true
  [1] Types are not equal
  [2] Types are equal
#+END_SRC
*** Implementing Higher Order Functions with templates 
    :PROPERTIES:
    :ID:       20156a12-aa32-407d-8cc0-5c4b85ba9021
    :END:


 + File: [[file:src/template-hof1.cpp][file:src/template-hof1.cpp]]
 + Online Compiler: https://rextester.com/ZAT8950

#+BEGIN_SRC cpp :tangle src/template-hof1.cpp 
  /**   File:     template-hof1.cpp 
    ,*  Brief:    Shows how to implement template higher order functions which operates on containers.
    ,*  Features: Template metaprogramming, C++11, functional programming and STL.
    ,****************************************************************************/
  #include <iostream>
  #include <cmath>
  #include <list>
  #include <deque>
  #include <vector>
  #include <functional> 
  #include <iomanip>

  /** Apply a function to every element of a container */
  template<class ELEM, class ALLOC, template<class, class> class CONTAINER>
  void forRange1(CONTAINER<ELEM, ALLOC>& cont, std::function<void (ELEM&)> fn){
          for(auto i =  std::begin(cont); i != std::end(cont); i++)
                  fn(*i);
  }

  /** Apply a function to every element of a container */
  template<class CONTAINER>
  void forRange2(CONTAINER& cont, std::function<void (decltype(cont.front()))> fn){
          for(auto i =  std::begin(cont); i != std::end(cont); i++)
                  fn(*i);
  }

  /** Template for folding over a container in a similar way to the higher order function fold. 
   ,* Note: 
   ,* + CONTAINER parameter accepts any argument which has .begin() and .end() methods 
   ,*   returning iterators. 
   ,* + STEPFN type parameters accepts any function-object, function pointer or lambda 
   ,*   whith the following signature: (ACC, X) => ACC where ACC is the accumulator type 
   ,*   and X is the type of the container element. 
   ,*/
  template<class CONTAINER, class ACC, class STEPFN>
  auto foldRange(CONTAINER& cont, const ACC& init, STEPFN fn) -> ACC {
          ACC acc{init};
          for(auto i =  std::begin(cont); i != std::end(cont); i++)
                  acc = fn(*i, acc);
          return acc;
  }

  int main(){
          std::ios_base::sync_with_stdio(false);

          std::vector<int> vec{1, 2, 400, 100};
          std::list<int>   lst{1, 2, 400, 100};

          // Requires template argument 
          std::cout << "===== EXPERIMENT 1 =================\n";
                  std::cout << "forRange1 - Vector" << "\n";
          forRange1<int>(vec, [](int x){ std::cout << std::setw(5) << x << " "; });
          std::cout << "\n";
          std::cout << "forRange1 - List" << "\n";
          forRange1<int>(lst, [](int x){ std::cout << std::setw(5) << x << " "; });
          std::cout << "\n";

          // Doesn't require the template argument as the compiler can infer its type.
          std::cout << "===== EXPERIMENT 2 =================\n";
          std::cout << "forRange1 - Vector" << "\n";
          forRange2(vec, [](int x){ std::cout << std::setw(5) << x << " "; });
          std::cout << "\n";
          std::cout << "forRange1 - list" << "\n";
          forRange2(lst, [](int x){ std::cout << std::setw(5) << x << " "; });
          std::cout << "\n";

          std::cout << "===== EXPERIMENT 3 =================\n";
          int result1 = foldRange(vec, 0, [](int x, int acc){
                                                  return x + acc;
                                            });	
          std::cout << "sum(vec1) = " << result1 << "\n" ;
          int result2 = foldRange(lst, 0, std::plus<int>());	
          std::cout << "sum(lst) = " << result2 << "\n" ;

          std::cout << "product(lst) = " << foldRange(lst, 1, std::multiplies<int>()) << "\n" ;
          return 0;
  }

#+END_SRC

Output: 

#+BEGIN_SRC sh 
  clang++ template-hof1.cpp -o template-hof1.bin -g -std=c++11 -Wall -Wextra && ./template-hof1.bin
  ===== EXPERIMENT 1 =================
  forRange1 - Vector
      1     2   400   100 
  forRange1 - List
      1     2   400   100 
  ===== EXPERIMENT 2 =================
  forRange1 - Vector
      1     2   400   100 
  forRange1 - list
      1     2   400   100 
  ===== EXPERIMENT 3 =================
  sum(vec1) = 503
  sum(lst) = 503
  product(lst) = 80000
#+END_SRC
*** Metafunctions or type traits 
**** Overview 

Metafunction (aka type traits) is a template metaprogramming technique
for type introspection, type manipulation and type computation. This
idiom uses templates, template specialization, structs (classes with
everything public) and constexpr in C++11.

This section contains examples about template metafunctions. For more
information about this subject and further reading, see: 
 + [[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Metafunction][More C++ Idioms/Metafunction - Wikibooks, open books for an open world]]
 + [[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Generator][More C++ Idioms/Type Generator - Wikibooks, open books for an open world]]
 + [[https://akrzemi1.wordpress.com/2012/03/19/meta-functions-in-c11/][Meta-functions in C++11 | Andrzej's C++ blog]]
 + [[https://accu.org/index.php/journals/442][ACCU - An introduction to C++ Traits]]


A meta function has the forms: 

 + Meta function which returns type.

#+BEGIN_SRC cpp 
  // Doesn't matter using typename T1, typename T2
  // or using class T1, class T2 ..
  template<class T1, class T2 ...>
  struct meta_function {
          // Before C++11
          // Meta function which returns type 
          using type = ... ;
  };

  template<typename T1, typename T2 ...>
  struct meta_function {
          // Before C++11
          // Meta function which returns type 
          using type = ... ;
  };

  // Before C++11 
  template<class T1, class T2 ...>
  struct meta_function {
          typedef ... ... type;
  };

  // Usage: 
  using type_synonym =  meta_function<T1, T2, ...>::type ;
  // Or in before C++11
  typedef  meta_function<T1, T2, ...>::type type_synonym;
#+END_SRC

 + Meta function which returns value.

#+BEGIN_SRC cpp 
  // At least C++11
  template<class T1, class T2 ...>
  struct meta_function {
          // Requires at aleast C++11
          // Meta function which returns type 
          static constexpr TYPE value = ... 
  };

  // Before C++11
  template<class T1, class T2 ...>
  struct meta_function {
          // Requires at aleast C++11
          // Meta function which returns type 
          static const TYPE value = ... 
  };

  // Usage:
  TYPE result = meta_function<T1, T2, ..>::value;
#+END_SRC

Further References: 

 + [[https://en.cppreference.com/w/cpp/header/type_traits][Standard library header <type_traits> - cppreference.com]]
 + [[https://www.youtube.com/watch?v=eVtLOHoDbTo][Type Traits - CopperSpice video]]

**** Example 

 *Example*

Example in:
 * file:            [[file:src/template-metafunction.cpp][file:src/template-metafunction.cpp]]
 * Online compiler: http://rextester.com/TAT89158
 * The code in the example demonstrates how to query types using
   template specialization, catalog type information and display the
   user as well. 

Highlights: 

 - The *metafunction isPointer* checks whether a given type is a
   pointer.

#+BEGIN_SRC cpp
  template<class T>
  struct isPointer{
          static constexpr bool value = false;
          constexpr bool operator()() const { return false; }
  };

  template<class T>
  struct isPointer<T*>{
          static constexpr bool value = true;
          constexpr bool operator()() const { return true; }
  };
#+END_SRC

Sample usage:

#+BEGIN_SRC cpp 
  std::cout << "isPointer<short*>::value  = " << isPointer<short*>::value << "\n";
  std::cout << "isPointer<short>::value   = " << isPointer<short>::value << "\n";
  std::cout << "isPointer<double>::value  = " << isPointer<double>::value << "\n";
  std::cout << "isPointer<double*>::value = " << isPointer<double*>::value << "\n";
#+END_SRC

Output: 

#+BEGIN_SRC text 
  isPointer<short*>::value  = true
  isPointer<short>::value   = false
  isPointer<double>::value  = false
  isPointer<double*>::value = true
#+END_SRC

  - The *meta function removePointer* turns any pointer type into a
    non-pointer type removing the star operator.

#+BEGIN_SRC cpp 
  // Partial specilization
  template<class T> struct removePointer{
          typedef T type;
  };
  template<class T> struct removePointer<T*>{
          typedef T type;
  };
#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
  disp(Typeinfo<removePointer<double>::type>::name);
  disp(Typeinfo<removePointer<double*>::type>::name);
  disp(Typeinfo<removePointer<const char*>::type>::name);
#+END_SRC

Output: 

#+BEGIN_SRC text 
  template-metafunction.cpp:175: ; Typeinfo<removePointer<double>::type>::name = double
  template-metafunction.cpp:176: ; Typeinfo<removePointer<double*>::type>::name = double
  template-metafunction.cpp:177: ; Typeinfo<removePointer<const char*>::type>::name = const char
#+END_SRC

 -  *The metafunction Typeinfo* computes basic information about types at
   compile-time. As this "metafunction" relies on template
   specialization, it requires defining template specialization for
   all supported types what can be cumbersome. In order to avoid the
   specialization boilerplate code, the macro ~REGISTER_TYPE_INFO~ is
   used to register the supported types. 

#+BEGIN_SRC cpp 
  template<typename T>
  struct Typeinfo{
          static constexpr const char* name	 = "unknown";
          static constexpr size_t      size	 = sizeof(T);
          static constexpr bool        isNumber	 = false;
          static constexpr bool        isPointer = ::isPointer<T>::value;
          static constexpr bool        isConst	 = ::isConst<T>::value;		
  };

  // Macro for type registration 
  #define REGISTER_TYPE_INFO(type, isNumberFlag) \
          template<> struct Typeinfo<type>{ \
                  static constexpr const char* name		= #type; \
                  static constexpr size_t      size		= sizeof(type); \
                  static constexpr bool        isNumber	= isNumberFlag;	\
                  static constexpr bool        isPointer	= ::isPointer<type>::value; \
                  static constexpr bool        isConst	= ::isConst<type>::value;	\
          }

   // Type registration 
   REGISTER_TYPE_INFO(bool, false);
   REGISTER_TYPE_INFO(char, false);
#+END_SRC

Usage example: 

#+BEGIN_SRC cpp 
  std::cout << "Type info for " << Typeinfo<int>>::name 
            << " size = " << Typeinfo<int>::size 
            << " isPointer = " << Typeinfo<int>::isPointer 
            << "\n";
#+END_SRC


 *Complete Program output:* ([[file:src/template-metafunction.cpp][file:src/template-metafunction.cpp]])

#+BEGIN_SRC text 
   $ clang++ template-metafunction.cpp -o template-metafunction.bin -g -std=c++11 -Wall -Wextra  
   ./template-metafunction.bin

   isPointerOLD<short*>::value  = 1
   isPointerOLD<short>::value   = 0
   isPointerOLD<double>::value  = 0
   isPointerOLD<double*>::value = 1
   isPointer<short*>::value  = true
   isPointer<short>::value   = false
   isPointer<double>::value  = false
   isPointer<double*>::value = true
   isPointer<short*>()()  = true
   isPointer<short>()()   = false
   isPointer<double>()()  = false
   isPointer<double*>()() = true
   Type Info: name =            bool ; bytes =    1 ; isNumber = false ; isPointer = false ; isConst = false
   Type Info: name =            char ; bytes =    1 ; isNumber = false ; isPointer = false ; isConst = false
   Type Info: name =     std::string ; bytes =   32 ; isNumber = false ; isPointer = false ; isConst = false
   Type Info: name =             int ; bytes =    4 ; isNumber =  true ; isPointer = false ; isConst = false
   Type Info: name =           short ; bytes =    2 ; isNumber =  true ; isPointer = false ; isConst = false
   Type Info: name =           float ; bytes =    4 ; isNumber =  true ; isPointer = false ; isConst = false
   Type Info: name =          double ; bytes =    8 ; isNumber =  true ; isPointer = false ; isConst = false
   Type Info: name =     const char* ; bytes =    8 ; isNumber =  true ; isPointer =  true ; isConst =  true
   Type Info: name =          float* ; bytes =    8 ; isNumber = false ; isPointer =  true ; isConst = false
   Type Info: name =         double* ; bytes =    8 ; isNumber = false ; isPointer =  true ; isConst = false
   Type Info: name =   const double& ; bytes =    8 ; isNumber = false ; isPointer = false ; isConst =  true
   template-metafunction.cpp:175: ; Typeinfo<removePointer<double>::type>::name = double
   template-metafunction.cpp:176: ; Typeinfo<removePointer<double*>::type>::name = double
   template-metafunction.cpp:177: ; Typeinfo<removePointer<const char*>::type>::name = const char
#+END_SRC
*** Variadic Templates 

This code shows examples about variadic templates in C++11 and
newer standards.

File: [[file:src/template-variadic.cpp][file:src/template-variadic.cpp]]

Code Highlights:


 - Print a sequence of heterogenous arguments.

#+BEGIN_SRC cpp 
  template<typename T>
  void printTypes(const T& x){	
          std::cout << std::left << std::setw(15) << x
                                    << std::setw(10) << std::right << " size = "
                                    << std::setw(2) << sizeof(x) << "\n";
          std::clog << " [TRACE] Base case => x = " << x << "\n";
  }
  // Variadic template arguments 
  template<typename T, typename ... Types>
  void printTypes(const T& x, const Types ... args){
          std::cout << std::left << std::setw(15) << x
                                    << std::setw(10) << std::right << " size = "
                                    << std::setw(2) << sizeof(x) << "\n";
          printTypes(args ...);
  }
#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
   printTypes("hello world", 10, 'x', 20.23f, true, NAN);
#+END_SRC

Ouput: 

#+BEGIN_SRC text 
  hello world       size = 12
  10                size =  4
  x                 size =  1
  20.23             size =  4
  1                 size =  1
  nan               size =  4
#+END_SRC


 - Create a function that applies a member function to a given object.

#+BEGIN_SRC cpp 
  template<class T, class R, class ... Args>
  auto makeCommand(
          // Pointer to member function 
          R (T::* pMemfn) (Args ... args),
          // Member function arguments 
          Args ... arglist) -> std::function<R (T& obj)> {
          return [=](T& obj){ return (obj.*pMemfn)(arglist ...); };
  }
#+END_SRC

Usage:

#+BEGIN_SRC cpp
   CNCMachine mach1("7Z9FA");
   CNCMachine mach2("MY9FT");
   auto setSpeed10 = makeCommand(&CNCMachine::setSpeed, 10);
   auto shutdown   = makeCommand(&CNCMachine::shutdown);
   setSpeed10(mach1);
   setSpeed10(mach2);
   shutdown(mach2);
#+END_SRC

 - Dynamic load an [U] nix-shared library or shared object.

#+BEGIN_SRC cpp 
  /** Type synonym for shared library handler 
   ,*  Requires: #include <dlfcn.h> and -ldl linker flag */
  using LibHandle = std::unique_ptr<void, std::function<void (void*)>>;

  auto loadDLL(const std::string& libPath) -> LibHandle {
          // Return unique_ptr for RAAI -> Resource Acquisition is Initialization
          // releasing closing handle when the unique_ptr goes out of scope. 
          return LibHandle(
                  dlopen(libPath.c_str(), RTLD_LAZY),
                  [](void* h){
                          std::cout << " [INFO] Shared library handle released OK." << "\n";
                          dlclose(h);
                  });		
  }

  /** Load symbol from shared library 
    ,*  Requires: #include <dlfcn.h> and -ldl linker flag */
  template<typename Function>
  auto loadSymbol(const LibHandle& handle, const std::string& symbol) -> Function* {
          void* voidptr = dlsym(handle.get(), symbol.c_str());
          if(voidptr == nullptr)
                  return nullptr;
          return reinterpret_cast<Function*>(voidptr);
  }
#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
   // GNU Scientific Library - Linear Algebra CBLAS 
   auto handle1 = loadDLL("/usr/lib64/libgslcblas.so");
   using cblas_daxpy_type = void (int, double, const double*, int, double*, int);
   auto cblas_daxpy = loadSymbol<cblas_daxpy_type>(handle1, "cblas_daxpy");
   // Or 
   auto cblas_daxpy = loadSymbol<void (int, double, const double*, int, double*, int)>(handle1, "cblas_daxpy");

   auto xs = std::vector<double>{ 3.0, 5.0, 6.0, 10.0, 8.0};
   auto ys = std::vector<double>{ 2.0, 2.0, 2.0,  2.0, 2.0};
   printContainer("xs", xs);
   printContainer("ys", ys);
   // Compute xs * 4.0 + ys
   cblas_daxpy(xs.size(), 4.0, &xs[0], 1, &ys[0], 1);
   printContainer("ys", ys);
#+END_SRC

Output: 

#+BEGIN_SRC text 
  [INFO]  Loaded clblas_daxpy OK!
 xs = 3, 5, 6, 10, 8, 
 ys = 2, 2, 2, 2, 2, 
 ys = 14, 22, 26, 42, 34, 
  [INFO] Shared library handle released OK.
#+END_SRC


Complete Output: 

#+BEGIN_SRC txt 
   $ g++ template-variadic.cpp -o template-variadic.bin -g -std=c++11 -Wall -Wextra -ldl 
   $ ./template-variadic.bin

   EXPERIMENT 1 = Function of many argument for printing all of them
   ---------------------------------------
   hello world       size = 12
   10                size =  4
   x                 size =  1
   20.23             size =  4
   1                 size =  1
   nan               size =  4
    [TRACE] Base case => x = nan

   EXPERIMENT 2 = Indirect method invocation
   --------------------------------------
   [MACHINE] id = 7Z9FA Set machine speed to level 10
   [MACHINE] id = MY9FT Set machine speed to level 10
   [MACHINE] id = 7Z9FA  Equipment to position set to  x = 10 ; y = -20
   [MACHINE] id = MY9FT  Equipment to position set to  x = 10 ; y = -20
   [MACHINE] id = 7Z9FA Shutdown equipment
   [MACHINE] id = MY9FT Shutdown equipment

   EXPERIMENT 3 = Dynamic Loading from shared library (libgslcblas.so) 
   --------------------------------------
    [INFO]  Loaded clblas_daxpy OK!
   xs = 3, 5, 6, 10, 8, 
   ys = 2, 2, 2, 2, 2, 
   ys = 14, 22, 26, 42, 34, 
    [INFO] Shared library handle released OK.
#+END_SRC

References:  
 + [[https://stackoverflow.com/questions/27604128/c-stdfunction-like-template-syntax][c++11 - C++ std::function-like template syntax - Stack Overflow]]
 + [[https://www.nag.com/numeric/FL/nagdoc_fl24/html/F06/f06ecf.html][F06ECF (DAXPY) : NAG Library, Mark 24]]
 + [[https://dwheeler.com/program-library/Program-Library-HOWTO/x172.html][Dynamically Loaded (DL) Libraries]]
 + [[https://www.gnu.org/software/gsl/doc/html/cblas.html][GSL CBLAS Library — GSL 2.5 documentation]]

*** References and Bookmarks 

General 

 + [[https://en.cppreference.com/w/cpp/language/templates][Templates - cppreference.com]]

 + [[https://en.cppreference.com/w/cpp/header/type_traits][Standard library header <type_traits> - cppreference.com]]

 + [[https://en.cppreference.com/w/cpp/language/class_template][Class template - cppreference.com]]


Templates and Iterators: 
 + [[https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/][std::iterator is deprecated: Why, What It Was, and What to Use Instead - Fluent C++]]

Dependent Type Names: 
 + [[http://www.enseignement.polytechnique.fr/informatique/INF478/docs/Cpp/en/cpp/language/dependent_name.html][Dependent names - cppreference.com]]

Variadic Templates:
 + [[http://www.cplusplus.com/articles/EhvU7k9E/][C++11 - New features - Variadic template - C++ Articles]]
 + [[http://kevinushey.github.io/blog/2016/01/27/introduction-to-c++-variadic-templates/][Introduction to C++ Variadic Templates · R and C++]]
 + [[https://docs.microsoft.com/en-gb/cpp/cpp/ellipses-and-variadic-templates?view=vs-2017][Ellipses and Variadic Templates | Microsoft Docs]]
 + [[https://stackoverflow.com/questions/27604128/c-stdfunction-like-template-syntax][c++11 - C++ std::function-like template syntax - Stack Overflow]]

Papers and technical documents about Generic Programming and Template Metaprogramming 

 + Alexander Stepanov and David R. Musser - *Generic Programming* -
   <http://stepanovpapers.com/genprog.pdf> 

 + Alexander Stepanov and Meng Lee. *The Standard Template Library*
   + <http://stepanovpapers.com/STL/DOC.PDF>

 + Alexandre Duret-Lutz et al. *Design Patterns for Generic Programming in C++*
   + <https://www.lrde.epita.fr/dload/papers/coots01.html>

 + Alexandre Duret-Lutz et al. *Design Patterns for Generic Programming in C++*
   + <https://www.usenix.org/legacy/events/coots01/full_papers/duret/duret_html/index.html>

 + James C. Dehnert and Alexander Stepanov. *Fundamentals of Generic Programming*
   + <http://stepanovpapers.com/DeSt98.pdf>

 + Jeremy Gibbons. *Patterns in Datatype-Generic Programming*
   + <http://www.cs.ox.ac.uk/jeremy.gibbons/publications/patterns.pdf>

 + Giuseppe Lipari. *Design Patterns in C++ Template metaprogramming*
   + <http://retis.sssup.it/~lipari/courses/oosd2010-2/07.metaprogramming-handout.pdf>

 + Gabriel Dos Reis and Jaakko Jarvi. *What is Generic Programming?*
   + <https://pdfs.semanticscholar.org/e730/3991015a041e50c7bdabbe4cb4678531e35b.pdf>

 + *Functional Programming with C++ Template Metaprograms*
   + <https://pdfs.semanticscholar.org/c7f3/a67b78dabd5aa6c4599a127583c07bb8c032.pdf>

 + *Implementing Monads for C++ Template Metaprograms*
   + <http://plcportal.inf.elte.hu/en/publications/TechnicalReports/monad-tr.pdf>

 + Angelika Langer. *C++ Expression Templates - An Introduction to the*
   *Principles of Expression Templates*
   + <http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm>

 + *Advanced C++ Template Techniques: An Introduction to Meta-Programming for Scientific Computing*
   + <https://conradsanderson.id.au/misc/sanderson_templates_lecture_uqcomp7305.pdf>

 + [[http://people.cs.uchicago.edu/~jacobm/pubs/templates.html][What's Wrong with C++ Templates?]]
** C++17 New Features 
*** Cpp17 std::invoke 
    :PROPERTIES:
    :ID:       5754cb0e-f4d3-434c-85e0-5ea55655a22f
    :END:

Function which provides an uniform interface for invoking anything
callable such as class member functions (ordinary methods), static
member functions (static methods), functios and etc.

See: https://en.cppreference.com/w/cpp/utility/functional/invoke

 + File: [[file:src/cpp17/cpp17-invoke.cpp][file:src/cpp17/cpp17-invoke.cpp]]
 + Online Compiler: http://rextester.com/IPY88297


#+BEGIN_SRC cpp :tangle src/cpp17/cpp17-invoke.cpp
  #include <iostream>
  #include <string>
  #include <ostream>

  // std::invoke is provide by header functional
  #include <functional> 

  struct Dummy{
          double evalme(double x)	{
                  std::cerr << __FILE__ << ":" << __LINE__ << " I was evaluated ; 2x = " << 2 *x << '\n';
                  return 2 * x;
          }
          double operator()(double x){
                  std::cerr << __FILE__ << ":" << __LINE__ << " Call function-operator << 4 * x = " << 4 * x << '\n';
                  return 4 * x;
          }
  };

  double computeDouble(double x){
          std::cerr << __FILE__ << ":" << __LINE__ << " Computed double of 2x = " << 2 * x << '\n';
          return 2 * x;
  }

  int main(){
          std::invoke(computeDouble, 3.0);
          Dummy dummy;
          std::invoke(dummy, 3.0);
          std::invoke(Dummy(), 2.0);
          // Call method: .evalme indirectly 
          std::invoke(&Dummy::evalme, dummy, 3.0);
          return 0;
  }

#+END_SRC

Compile and run: 

#+BEGIN_SRC sh 
  g++ cpp17-invoke.cpp -o out.bin -std=c++1z -Wall -Wextra && ./out.bin
  cpp17-invoke.cpp:20 Computed double of 2x = 6
  cpp17-invoke.cpp:14 Call function-operator << 4 * x = 12
  cpp17-invoke.cpp:14 Call function-operator << 4 * x = 8
  cpp17-invoke.cpp:9 I was evaluated ; 2x = 6
#+END_SRC

*** Cpp17 std::any 
    :PROPERTIES:
    :ID:       9397a9a0-e641-4cb6-89b7-24a82fe12d99
    :END:

This example shows how to use the C++17 std::any container which comes
froom boost::any.

See: https://en.cppreference.com/w/cpp/utility/any

File:  [[file:src/cpp17/cpp17-any.cpp][file:src/cpp17/cpp17-any.cpp]] 

#+BEGIN_SRC cpp :tangle src/cpp17/cpp17-any.cpp
  #include <iostream>
  #include <string>
  #include <iomanip>
  #include <ostream>

  #include <any>

  struct Point{
      double x;
      double y;
      Point(double x, double y): x(x), y(y) {}

      // Copy constructor
      Point(const Point& p){
          std::cerr << " -->> Copy constructor" << '\n';
          x = p.x;
          y = p.y;
      }   
  };

  std::ostream& operator<<(std::ostream& os, const Point& p){
      os << "Point(" << p.x << ", " << p.y << ") ";
      return os;
  }

  template<typename T>
  auto printInfo(std::any x) -> void{
      std::cout << " x.type = " << x.type().name()
                << " ; value(x) = "
                << std::any_cast<T>(x)
                << '\n';  
  }

  int main(){
      // Print boolean as 'true', 'false', instead of 0 or 1
      std::cout << std::boolalpha;
      std::any x = 1;
      printInfo<int>(x);
      x = 10.233;
      printInfo<double>(x);
      x = 'k';
      printInfo<char>(x);
      x = "hello world";
      printInfo<const char*>(x);
      x = std::string("hello world");
      printInfo<std::string>(x);  
      x = Point(100.0, 20.0);
      printInfo<Point>(x);
      std::cout << "Has value: x.has_value() = " << x.has_value() << '\n';
      x.reset();                                                         
      std::cout << "Has value: x.has_value() = " << x.has_value() << '\n';                                                               
      std::cout << "Try casting " << std::endl;
      x = "testing type casting";
      try{
          std::any_cast<int>(x);
      } catch (const std::bad_any_cast& ex) {
          std::cerr << " >>> Exception: what = " << ex.what() << '\n'; 
      }
      std::cerr << " >>> End the program gracefully" << '\n'; 
      return 0;
  }

#+END_SRC

Compiling with gcc: 

#+BEGIN_SRC sh 
  $ g++ --version
  g++ (GCC) 7.3.1 20180130 (Red Hat 7.3.1-2)
  .. ... ... ... 

  $ g++ cpp17-any.cpp -o out.bin -std=c++1z -Wall -Wextra && ./out.bin
   x.type = i ; value(x) = 1
   x.type = d ; value(x) = 10.233
   x.type = c ; value(x) = k
   x.type = PKc ; value(x) = hello world
   x.type = NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE ; value(x) = hello world
   -->> Copy constructor
   -->> Copy constructor
   x.type = 5Point ; value(x) =  -->> Copy constructor
  Point(100, 20) 
  Has value: x.has_value() = true
  Has value: x.has_value() = false
  Try casting 
   >>> Exception: what = bad any_cast
   >>> End the program gracefully
#+END_SRC

Compile with MSVC / VC++ on Windows: 

#+BEGIN_SRC sh 
  $ cl.exe cpp17-any.cpp /EHsc /Zi /nologo /std:c++17 /Fe:out.exe && out.exe
  cpp17-any.cpp
   x.type = int ; value(x) = 1
   x.type = double ; value(x) = 10.233
   x.type = char ; value(x) = k
   x.type = char const * __ptr64 ; value(x) = hello world
   x.type = class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > ; value(x) = hello world
   -->> Copy constructor
   -->> Copy constructor
   -->> Copy constructor
   x.type = struct Point ; value(x) = Point(100, 20) 
  Has value: x.has_value() = true
  Has value: x.has_value() = false
  Try casting 
   >>> Exception: what = Bad any_cast
   >>> End the program gracefully
#+END_SRC
*** Cpp17 std::variant 
    :PROPERTIES:
    :ID:       8232d77f-99a5-4434-96f2-c5c3cfd6d956
    :END:

C++17 new std::variant which comes from Boost.Variant provides a
type-safe discriminated union or sum type which is similar to pattern
matching from functional programming languages like Haskell, OCaml and
Scala. In addition to those benefits, the std::variant is an
out-of-the-box generic visitor design pattern and a type-safe
replacement for old C-unions.

Potential Applications: 
 + Implement visitor OOP pattern.
 + Simulate or emulate pattern matching from functional languages.
 + Manipulate abstract syntax trees.

Useful concepts references: 
 + [[https://en.wikipedia.org/wiki/Tagged_union][Tagged union - Wikipedia]]
 + [[https://en.wikipedia.org/wiki/Algebraic_data_type][Algebraic data type - Wikipedia]]

Documentation: 
 + https://en.cppreference.com/w/cpp/utility/variant
 + [[https://www.boost.org/doc/libs/1_64_0/doc/html/variant.html][Chapter 45. Boost.Variant - 1.64.0]]

Code example: 

 - File: [[file:src/cpp17/variant.cpp][file:src/cpp17/variant.cpp]] 

#+BEGIN_SRC cpp :tangle src/cpp17/variant.cpp
  #include <iostream>
  #include <variant> // C++17
  #include <string>
  #include <ostream>
  #include <deque>
  #include <vector>
  #include <iomanip>

  template <class T>
  auto display(const std::string& name, const T& t) -> void;

  // Pattern matching using constexpr => May be the more performant way 
  template<class T>
  auto identifyAndPrint(const T& v) -> void;

  struct VisitorOperation{
          auto operator()(int num) -> void {
                  std::cout << "type = int     => value = " << num << "\n";
          }
          auto operator()(double num) -> void {
                  std::cout << "type = double  => value = " << num << "\n";
          }
          auto operator()(const std::string& s){
                  std::cout << "type = string  => value = " << s << "\n";
          }
  };

  int main(){
          // using <1>, <2>, ... <n> => Only available at C++17
          using std::cout, std::endl, std::cerr;
          auto nl = "\n";
          std::cout << std::boolalpha;
          cout << "========== Test 1 ==================" << nl;	
	
          // std::variant<int, double, std::string> somevar;
          auto x = std::variant<int, double, std::string>();
          x = 100;
          std::cout << "variant has int    = " << std::holds_alternative<int>(x) << nl;
          std::cout << "variant has double = " << std::holds_alternative<double>(x) << nl;
          std::cout << "variant has string = " << std::holds_alternative<std::string>(x) << nl;
          display("x", x);
          std::cout << "-------------------" << nl;
          x = 204.45;
          std::cout << "variant has double = " << std::holds_alternative<double>(x) << nl;	
          display("x", x);
          std::cout << "-------------------" << nl;
          x = "std::variant is awesome!";
          std::cout << "variant has string = " << std::holds_alternative<std::string>(x) << nl;
          display("x", x);

          cout << "========== Test 2 ==================" << nl;
          try{ 
                  // Try to get int 
                  int m = std::get<int>(x);
                  std::cout << "m = " << m << "\n";
          } catch(const std::bad_variant_access& ex){
                  std::cerr << "Error: Failed to extract int." << nl;
          }
          try{ 
                  // Try to get string 
                  auto s = std::get<std::string>(x);
                  std::cout << "s = " << s << nl;
          } catch(const std::bad_variant_access& ex){
                  std::cerr << "Error: Failed to extract string." << nl;
          }

          cout << "========== Test 3 ==================" << nl;
          x = -100;
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);
          x = 20.52;
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);

          x = "<hello world std::variant>";
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);

          cout << "========== Test 4 ==================" << nl;
          // auto + uniform initialization 
          auto xs = std::deque<std::variant<int, double, std::string>>{10.0, 20, 5, "hello", 10, "world"};
          for(const auto& e: xs){
                  identifyAndPrint(e);
          }
          cout << "========== Test 5 ==================" << nl;
          for(const auto& e: xs){
                  std::visit(VisitorOperation(), e);
          }	
          return 0;
  }

  // It works in a similar fashion to functional languages with
  // pattern matching such as Haskell, Scala, OCaml and so on.
  // std::variant is also a type-safe alternative to old C-unions.
  template <class T>
  auto display(const std::string& name, const T& t) -> void {
          auto nl = "\n";
          // Boost.Variant uses boost::get<TYPE>(&t), now changed to std::get_if
          if(auto n = std::get_if<int>(&t)){
                  std::cout << " = " << *n << nl;
                  return; // Early return 
          }
          if(auto d = std::get_if<double>(&t)){
                  std::cout << name << " = " << *d << nl;
                  return;
          }	
          if(auto s = std::get_if<std::string>(&t)){
                  std::cout << name << " = " << *s << nl;
                  return;
          }
          std::cout << "<UNKNOWN>" << std::endl;
  }

  template<class T>
  auto identifyAndPrint(const T& v) -> void{
          std::visit([](auto&& a){
              using C = std::decay_t<decltype(a)>;
              if constexpr(std::is_same_v<C, int>){
                              std::cout << "Type is int => value = " << a << "\n";
                              return;
              }
              if constexpr(std::is_same_v<C, double>){
                              std::cout << "Type is double => value = " << a << "\n";
                              return;
              }
              if constexpr(std::is_same_v<C, std::string>){
                              std::cout << "Type is string => value = " << a << "\n";
                              return;
              }
              std::cout << "Type is unknown" << "\n";
                             }, v);
  } // End of func. identifyAndPrint() ---//

#+END_SRC

Compile with GCC:

#+BEGIN_SRC sh 
 $ g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin 
#+END_SRC

Compile with Clang:

#+BEGIN_SRC sh 
 $ g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin 
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin

  ========== Test 1 ==================
  variant has int    = true
  variant has double = false
  variant has string = false
   = 100
  -------------------
  variant has double = true
  x = 204.45
  -------------------
  variant has string = true
  x = std::variant is awesome!
  ========== Test 2 ==================
  Error: Failed to extract int.
  s = std::variant is awesome!
  ========== Test 3 ==================
  x = -100
  x = 20.52
  x = <hello world std::variant>
  ========== Test 4 ==================
  Type is double => value = 10
  Type is int => value = 20
  Type is int => value = 5
  Type is string => value = hello
  Type is int => value = 10
  Type is string => value = world
  ========== Test 5 ==================
  type = double  => value = 10
  type = int     => value = 20
  type = int     => value = 5
  type = string  => value = hello
  type = int     => value = 10
  type = string  => value = world


#+END_SRC
** Books 

 + Bruce Eckel. *Thinking in C++*. 1995
   + Notes: Despite being an old book, it has a step-by-step coverage
     of C++ main concepts and some design patterns.

 + Andrei Alexandrescu. *Modern C++ Design: Generic Programming and*
   *Design Patterns Applied 1st Edition*. 2001 
   + Notes: Provides a comprehensive and broad coverage of C++
     generic/template metaprogramming.
   + Link: [[https://www.amazon.com/Modern-Design-Generic-Programming-Patterns/dp/0201704315][Amazon]]

 + Scott Meyers. *Effective C++ Third Edition, 55 Specific Ways to Improve Your*
   *Programs and Designs* 

 + Andrew Koenig and Barbara E. Moo. *Accelerated C++: Practical Programming by Example*

 + Bjarne Stroustrup. *Tour of C++ second edition*

