#+TITLE: CPP / C++ Review
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 
#+AUTHOR: Caio Rodrigues 

* Understanding C++ 
** C++ Benefits and Costs 

Some C++ compelling features which sets it apart from most
programming languages are: 

 + Compilation to native code.
 + High Performance and zero-cost abstractions.
 + Hardware portability and compiler availability for many processor
   and hardware architechtures. C++ has the widest range of processor
   support, so it can run on mainstream x86, desktop processors;
   mobile phone ARM-based CPUs; GPUs; embedded processors and
   microcontrollers.
 + Direct access to the operating system C-API and system calls.
 + Interoperability with C libraries.
 + Direct Access to Memory which is important on embedded systems for
   accessing memory-mapped IO devices.

 Disadvantages: 

 + Language complexity

 + Lack of a comprehensive standard library. 

 + Compiler's cryptic error messages. 

 + Lack of agreed package manager.

 + ABI - Application Binary Interface Issues - due the
   non-standardized ABI, it is almost impossible to link object-code
   (aka compiled code) compiled with different compilers. This is why,
   unlike Java and C#,  there is almost no pre-compiled libraries for
   C++ what makes the binary reuse hard.

** C++ Comparison with C, Java and C#

General overview: Unlike most object oriented languages such as Java
and C#, C++ doesn't have a class hierarchy, single inheritance,
garbage collection and a comprehensive standard library. However in
some situations, C++ benefits such as direct access to the operating
system, memory, system calls and low level; interoperability with C
libraries; and above all, high performance computing may offset the
language complexity costs.

This table shows a comparison between C++ and mainstreams object
oriented programming languages like Java and C#.


| Feature                                | C++                                   | Java               | C# - .NET |
|----------------------------------------+---------------------------------------+--------------------+-----------|
| Native Code                            | Yes                                   | No                 | No        |
| JIT - Just-In-Time Compilation         | No  - No needed, since C++ is native. | Yes                | Yes       |
| Virtual Machine                        | No                                    | Yes                | Yes       |
| Garbage Collection                     | No                                    | Yes                | Yes       |
| Memory Management                      | semi-automatic                        | auto               | auto      |
|                                        |                                       |                    |           |
| *Object Oriented Features*               |                                       |                    |           |
| OOP - Object Oriented                  | Yes                                   | Yes                | Yes       |
| Class Hierarchy                        | No                                    | Yes                | Yes       |
| Reflection                             | No                                    | Yes                | Yes       |
| Single Inheritance                     | No                                    | Yes                | Yes       |
| Multiple Inheritance                   | Yes                                   | No                 | No        |
| Properties                             | No                                    | No                 | Yes       |
| Inner classes, aka nested classes      | Yes                                   | Yes                | Yes       |
| Anonymous classes                      | No                                    | Yes                | No        |
| Operator Overloading                   | Yes                                   | Not                | Yes       |
| Marshalling                            |                                       |                    |           |
| Conditional Compilation - preprocessor | Yes                                   | No                 | Yes       |
| Lambda functions                       | Yes  - since C++11                    | Yes - since Java 8 | Yes       |
| Generics                               | Yes                                   | Yes                | Yes       |
| *Template metaprogramming              | Yes                                   | No                 | No        |
| Dependency, package manager            | No                                    | Yes                | Yes       |
|                                        |                                       |                    |           |
| *Standard Library Features*              |                                       |                    |           |
| Broad Cross Platform Support           | No - Provided by boost library.       | Yes                | No        |
| GUI toolkit in standard library        | No                                    | Yes                | Yes       |
| Collection Library                     | Yes - STL.                            | Yes                | Yes       |
| Sockets                                | No - Provided Boost library.          | No                 | No        |
| Threads                                | No - It is OS dependent.              | Yes                | Yes       |
| File System                            | C++ 11 -> No, C++17 -> Yes.           | Yes                | Yes       |
|                                        |                                       |                    |           |
|                                        |                                       |                    |           |

*C++ Terminology* 

C++ has a different terminology from mainstream programming languages
which is shown in the following table.

| C++                    | Other OOP Languages                             | Comment                                                                                   |
|                        | i.e: Java, Python, ...                          |                                                                                           |
|------------------------+-------------------------------------------------+-------------------------------------------------------------------------------------------|
| Class                  | Class                                           | C++ class' fields and methods are private by default.                                     |
| Struct                 | Class                                           | A C++ is the same as a Class, but fields and methods are public by default.               |
| Class or Struct        | Abstract Class                                  | A C++ abstract class have at least one _virtual function_.                                  |
| Class or Struct        | Interface                                       | A C++ interface is a class signature with only pure virtual functions (abstract methods.) |
|                        |                                                 |                                                                                           |
| Member Function        | Instance methods                                |                                                                                           |
| Static Member Function | Static method                                   |                                                                                           |
| Virtual Functions      | -                                               | Only methods annoted with virtual  can overriden by subclasses                            |
| Non Virtual Functions  | -                                               | Methods without _virtual_ annotation cannot be overriden by subclasses.                     |
| Pure Virtual Function  | Abstract method (method without implementation) |                                                                                           |
| STL Containers         | Collection library - Lists, Maps, Tuples ...    | C++ name its collections as containters                                                   |
|                        |                                                 |                                                                                           |


*Java X C++ Collections Comparison*


| Java                 | C++                |
|----------------------+--------------------|
| java.util.ArrayList  | std::vector        |
| java.util.LinkedList | std::list          |
| java.util.Stack      | std::stack         |
| java.util.Queue      | std::queue         |
| java.util.Deque      | std::deque         |
| java.util.TreeSet    | std::set           |
| java.util.HashSet    | std::unordered_set |
| java.util.TreeMap    | std::map           |
| java.util.HashMap    | std::unordered_map |
|                      |                    |
  
                     
See: 
  + [[wiki-asset-sys:C++ - CPP Programming;CppFor Java Programmers - Hans Dulimatra.pdf][CppFor Java Programmers - Hans Dulimatra.pdf]]
  + [[https://en.wikiversity.org/wiki/Java_Collections_Overview][Java Collections Overview - Wikiversity]]

** Comparison C X C++(CPP)

|                         | C                                                 | C++                                                            |
|-------------------------+---------------------------------------------------+----------------------------------------------------------------|
| Creator                 | Dennis Ritchie                                    | Bjarne Stroustrup                                              |
| Paradigms               | Procedural / Imperative                           | Imperative, Object Orientated, Meta programming and Functional |
| Standard and Stable ABI | Yes                                               | No                                                             |
| Garbage Collector       | No                                                | No                                                             |
| Memory Management       | Manual                                            | Manual and Automatic                                           |
| Exceptions              | No                                                | Yes                                                            |
| Namespaces              | No                                                | Yes                                                            |
| Some use cases          | Low level system programming and embedded systems | High Performance Computing, Games, ...                         |
| Extensions              | .c (C-source code) and .h (header file)           | .cpp (c++ source code) and .hpp (c++ header file).             |
|                         |                                                   |                                                                |
|                         |                                                   |                                                                |

*File Extensions*

   + Source Files
     + *.cpp - C++ source files.
     + *.hpp - C++ header files.
     + *.o   - Object Code

   + Windows
     - *.exe - PE32 - Windows Executable
     - *.dll - Windows Shared Library

   + Unix (Linux, BSD ...)
     - (No extension or *.bin) - ELF - Unix Executable
     - *.so - Unix Shared Library

*Primitive Data Types*

| Type           | stdint.h type | Size (Bytes) | Size (Bits) | Range       | Description                                          |
|----------------+---------------+--------------+-------------+-------------+------------------------------------------------------|
| bool           |               |            1 |           8 |             | Boolean 0 (false) or 1 (true)                        |
| char           |               |            1 |           8 |             | Ascii character                                      |
| unsigned char  | uint8_t       |            1 |           8 | 0 to 255    | 1 byte integer                                       |
| signed char    | int8_t        |            1 |           8 | -128 to 127 |                                                      |
|                |               |              |             |             |                                                      |
| short          | int16_t       |            2 |          16 |             | 16 bits signed integer                               |
| unsigned short | uint16_t      |            2 |          16 |             |                                                      |
|                |               |              |             |             |                                                      |
| int            | int32_t       |            4 |          32 |             | 32 bits signed integer                               |
| unsigned int   | uint32_t      |            4 |          32 |             | 32 bits unsigned integer                             |
|                |               |              |             |             |                                                      |
|                |               |              |             |             |                                                      |
| float          |               |            4 |          32 |             | 32 bits IEEE 754 single-precision float point number |
| double         |               |            8 |          64 |             | 64 bits IEEE 754 double-precision float point Number |
| long double    |               |           10 |          80 |             | Extended precision non-IEEE float point number       |
|                |               |              |             |             |                                                      |


 - Note: The type char can be understood as an 8-bits integer. 
** Value Semantics X Reference Semantics 

 According to the - [[https://isocpp.org/wiki/faq/value-vs-ref-semantics][ISO C++]], value and reference semantics are defined
 as: 

 #+BEGIN_QUOTE
   With reference semantics, assignment is a pointer-copy (i.e., a
   reference). Value (or “copy”) semantics mean assignment copies the
   value, not just the pointer. C++ gives you the choice: use the
   assignment operator to copy the value (copy/value semantics), or use
   a pointer-copy to copy a pointer (reference semantics). C++ allows
   you to override the assignment operator to do anything your heart
   desires, however the default (and most common) choice is to copy the
   value.
 #+END_QUOTE

  *Definitions:*

 _Reference Semantics_: Behavior where composite types are passed by
 reference when assigned; passed as function or method parameters or
 returned from functions. This is the default behavior of most object
 oriented programming languages, except C++.
 
 In Java, C#, Scala, Python and etc. Objects have reference semantics
 by default. This example in Scala programming language shows how
 _reference semantics_ works in most languages.

 #+BEGIN_SRC scala 
   class Foo(name: String){
     private var _name = name
     def setName(name: String) =
       _name = name
     def getName() =
       name
     override def toString() =
       s"Foo { name = $name }"
   }

   scala> var x = 10
   x: Int = 10

   // Primitive types have value semantics: assignment of variables of
   // primitive types, creates a copy, so both variables can be modified
   // without changing each other.
   scala> var y = x
   y: Int = 10

   // By modifying x, the value of y remains the same.
   scala> x = 25
   x: Int = 25

   scala> y
   res5: Int = 10

   scala> 

   //===> Composite and complexity types have reference semantics by default 
   // in languages other than C++.

   scala> val foo = new Foo("bar")
   foo: Foo = Foo { name = bar }

   // Assignment doesn't create a copy like assignment 
   // of primitive type, actually the assignment creates 
   // a reference to the object foo. As result, modifying 
   // one of the objects, modifies the other.
   scala> val bar = foo
   bar: Foo = Foo { name = bar }

   // Modifying bar modifes foo. 
   scala> bar.setName("something")

   scala> bar
   res3: Foo = Foo { name = something }

   scala> foo
   res4: Foo = Foo { name = something }

   // Passing as function parameter doesn't create a copy like in C++, 
   // it passes the object by reference, so if the parameter is modified inside
   // the function, the original object will be modified too. 
    def setFooPrint(param: Foo){
      param.setName("dummy name")
      println(foo)
    }

    scala> setFooPrint(foo)
    Foo { name = dummy name }

    scala> foo
    res8: Foo = Foo { name = dummy name }

    // Returning an object from a function doesn't create a copy as would happen 
    // with primitive types.
    def modifyReturn(param: Foo, newName: String) = {
      param.setName(newName)
      param
    }
    scala> val foob = modifyReturn(foo, "Scala + C++ + JNI == HPC")
    foob: Foo = Foo { name = Scala + C++ + JNI == HPC }

    scala> foo
    res9: Foo = Foo { name = Scala + C++ + JNI == HPC }
 #+END_SRC

 _Value Semantics_: Behavior where composite types such as instances of
 classes are treated as primitive type such as booleans, integers or
 float point numbers. In the value semantics, a copy is created when
 variables are assigned; passed as parameters to functions or methods
 and returned from functions. So modifying one of the variables doesn't
 change the other. 

Unlike other languages, C++ uses value semantics by default, it means
that in operations such as assignment; returning objects from
functions and passing objects as parameters create a full copy of the
object, instead of creating a reference to the object as would happen
in most object oriented programming languages such as Java, C#,
Python, Ruby and etc. C++ also supports reference semantics, however
it is not the default behavior and unlike in the majority of
programming languages, requires explicit annotation to pass objects by
reference or create a reference to the object.

  *Value Semantics in C++*

  Example: demonstration of value semantics in C++ tested in the CERN's
  C++ ROOT REPL:

  - Note: this code can be copied and pasted in the CERN's ROOT REPL.
 
 #+BEGIN_SRC cpp 
   #include <iostream>
   #include <string>

   class Foo{
   private:
     std::string _name;
   public:
     // Constructor 
     Foo(std::string name):_name(name){}
     // Copy constructor
     //--------------------------
     // Note: If it is not defined, the compiler, defines 
     // a default copy constructor. It was created to demonstrate
     // when the copy constructor is invoked.
     Foo(const Foo& rhs){
       _name = rhs._name;    
       std::cout << " [INFO] Copy constructor invoked." << std::endl;    
     }
     // Copy assignment-operator
     //--------------------------
     // Note: It is similar to the copy constructor and
     // default assignment copy-assignment-operator is created
     // by the compiler if the user doesn't define it.
     Foo operator= (const Foo& rhs){    
       std::cout << " [INFO] Copy-assignment operator invoked." << std::endl;
       return Foo(rhs._name);
     }
     void setName(std::string name){
       _name = name;
     }
     std::string getName() const {
       return _name;
     }
     void show(){
       std::cout << "Foo { name = " << _name << " } " << std::endl;
     }
     void show2() const {
       std::cout << "Foo { name = " << _name << " } " << std::endl;
     }
   };

 #+END_SRC

 Assignment creates a copy, unlike in most OOP languages like Java, C#,
 Python and so on. 

 #+BEGIN_SRC cpp 
   >> Foo foo("foo");
   >> foo.show()
   Foo { name = foo } 

   // Assingment creates a copy, unlike in most OO languages
   >> Foo bar = foo; 
    [INFO] Copy constructor invoked.

   // Modifying one of the objects, doens't change the other. 
   >> bar.show()
   Foo { name = foo } 

   >> bar.setName("I am object bar")

   >> bar.show()
   Foo { name = I am object bar } 

   >> foo.show()
   Foo { name = foo } 
   >> 

   // foo and bar objects aren't the same as they have 
   // different memory locations. 
   >> &foo == &bar
   (bool) false
   >>
 #+END_SRC

 Primitive and composite types are passed by value in C++, unlike in
 most OOP languages. So, it means that a copy of the object is created.

 #+BEGIN_SRC cpp
   void setFooPrint(Foo param, std::string name){
     param.setName(name);
     param.show();
     std::cout << " name = " << param.getName() << std::endl;
   }

   // Modifying the function paramenter, doesn't modify the passed object.
   >> setFooPrint(foo, "dummy name")
    [INFO] Copy constructor invoked.
   Foo { name = dummy name } 
    name = dummy name

   >> foo.show()
   Foo { name = foo } 
   >> 
 #+END_SRC

 Returning an object from function, creates a copy of the object
 instead of returning a reference to it like in Java, Scala, Python and
 most languages.

 #+BEGIN_SRC cpp 
   Foo modifyReturn(Foo param, std::string newName) {
     param.setName(newName);
     return param;
   }

   >> auto ret = modifyReturn(foo, "New name")
    [INFO] Copy constructor invoked.
    [INFO] Copy constructor invoked.
   (Foo &) @0x7f54f0288050

   >> &ret == &foo
   (bool) false

   >> ret.show()
   Foo { name = New name } 

   >> foo.show()
   Foo { name = foo } 
   >> 

 #+END_SRC

 Value semantics and STL 

  - Objects can be stored in STL containers by value, reference or by
    pointers. 

 #+BEGIN_SRC cpp 
   #include <deque> // Double ended queue collection 

   >> std::deque<Foo> xs;

   // Temporary objects are created on the stack, 
   // copied to the deque data structure and then 
   // put on the collection. 
   // 
   >> xs.push_back(Foo("hello"));
    [INFO] Copy constructor invoked.
   >> xs.push_back(Foo("world"));
    [INFO] Copy constructor invoked.
   >> xs.push_back(Foo("value"));
    [INFO] Copy constructor invoked.
   >> xs.push_back(Foo("semantics"));
    [INFO] Copy constructor invoked.
   >> 

   >> xs
   (std::deque<Foo> &) { @0x1393820, @0x1393840, @0x1393860, @0x1393880 }
   >> 

   >> xs.size()
   (unsigned long) 4
   >> 

   >> xs.at(0).show()
   Foo { name = hello } 
   >> xs.at(0).show2()
   Foo { name = hello } 
   >> 
   >> xs.at(2).show()
   Foo { name = value } 
   >> 

   // Error: invoke const reference method which is not annotated with 'const'
   >> for(const auto& x: xs) { x.show(); }
   ROOT_prompt_56:1:26: error: member function 'show' not viable: 
   'this' argument has type 'const Foo', but function is not marked const
   for(const auto& x: xs) { x.show(); }

   // Works as show2() is annotated with 'const'
   >> for(const auto& x: xs) { x.show2(); }
   Foo { name = hello } 
   Foo { name = world } 
   Foo { name = value } 
   Foo { name = semantics } 
   >> 

   // Wateful for-loop 
   >> for(auto x: xs) { x.show(); }
    [INFO] Copy constructor invoked.
   Foo { name = hello } 
    [INFO] Copy constructor invoked.
   Foo { name = world } 
    [INFO] Copy constructor invoked.
   Foo { name = value } 
    [INFO] Copy constructor invoked.
   Foo { name = semantics } 
   >> 

   // By using emplace_back - a copy is not created.
   >> auto xs2 = deque<Foo>()
   (std::deque<Foo, std::allocator<Foo> > &) {}
   >> 
   >> xs2.emplace_back("hello")
   >> xs2.emplace_back("world")
   >> xs2.emplace_back("value")
   >> xs2.emplace_back("semantics")
   >> xs2
   (std::deque<Foo, std::allocator<Foo> > &) { @0x411ff30, @0x411ff50, @0x411ff70, @0x411ff90 }
   >> 

   >> for(const auto& x: xs2) { x.show2(); }
   Foo { name = hello } 
   Foo { name = world } 
   Foo { name = value } 
   Foo { name = semantics } 
   >> 
 #+END_SRC

  *Reference Semantics in C++*

 Unlike in most programming languages where reference semantics for
 complex types such as object is the default behavior, in C++ reference
 semantics requires explicit annotation with reference operator (&) or
 passing objects by pointer. 

 The default behavior of passing by value cause significant memory and
 performance overhead. In order to avoid unnecessary copies, it is
 preferable to pass objects by reference with operator (&) or by const
 reference when the object is not supposed to be modified by the
 function the objects are passed to.

  - Create a reference in assignment operation instead of a copy.

 #+BEGIN_SRC cpp 
   >> foo.show()
   Foo { name = foo } 

   >> Foo& ref1 = foo;

   >> ref1.setName("I am foo reference")
   >> foo.show()
   Foo { name = I am foo reference } 
   >> 

   // The reference has the same memory location of foo.
   >> &foo == &ref1
   (bool) true
   >> 
 #+END_SRC

  - Passing a parameter by reference instead of passing it by
    value. Note: that the copy constructor is not invoked when passing
    by reference.

 #+BEGIN_SRC cpp 
   void setFooPrintRef(Foo& param, const std::string& name){
     param.setName(name);
     param.show();
     std::cout << " name = " << param.getName() << std::endl;
   }

   >> setFooPrintRef(foo, "dummy name")
   Foo { name = dummy name } 
    name = dummy name

   >> foo.show()
   Foo { name = dummy name } 
   >> 
 #+END_SRC

  - Returning objects from functions as references. 

 #+BEGIN_SRC cpp 
   Foo& modifyReturnRef(Foo& param, std::string newName) {
     param.setName(newName);
     return param;
   }

   >> foo.setName("unnamed")

   >> fooRefx.setName("I am foo reference")
   >> foo.show()
   Foo { name = I am foo reference } 

   >> &foo == &fooRefx
   (bool) true
   >> 

   >> auto& fooRefAuto = modifyReturnRef(foo, "C++ type inference auto!")
   (Foo &) @0x7f54f0288010

   >> foo.show()
   Foo { name = C++ type inference auto! } 

   >> fooRefAuto.show()
   Foo { name = C++ type inference auto! } 

   >> fooRefAuto.setName("C++17")

   >> foo.show()
   Foo { name = C++17 } 
   >> 

   >> &foo == &fooRefAuto
   (bool) true
   >> 
 #+END_SRC

  - Const references cannot be modified as any attempt to change it
    will result in a compile-time error. 

 #+BEGIN_SRC cpp 
   >> Foo foo("foo");

   >> foo.show()
   Foo { name = foo } 

   >> foo.getName()
   (std::string) "foo"

   >> const Foo& fooRefConst = modifyReturnRef(foo, "C++ constant ref.")
   (const Foo &) @0x7fbf2003c010

   >> foo.show()
   Foo { name = C++ constant ref. } 

   >> foo.getName()
   (std::string) "C++ constant ref."
   >> 

   >> fooRefConst.show2()
   Foo { name = C++ constant ref. } 
   >> 

   // Any attempt to call a method not annotated with const will result 
   // in a compile-time error. 
   >> fooRefConst.show()
   ROOT_prompt_52:1:1: error: member function 'show' not viable: 'this' 
   argument has type 'const Foo', but function is not marked const
   fooRefConst.show()
   ^~~~~~~~~~~
   ROOT_prompt_30:1:6: note: 'show' declared here
   void show(){ 
 #+END_SRC

  *Summary* 

  + Value Semantics X Reference Semantics
    + _Value Semantics_ -> Objects are assigned, passed to functions and
      return from functions as primitive types without being modified
      as what is modified is a copy of the object. This is default
      behavior of C++.

      + Object A = B; => (C++ Only) Creates object A as a copy of the object B.

      + Object A = B.copy() (C#, Java, Python ...) Creates object A as
        copy of object B. As value-semantics is not the default
        behavior in thoses languages, it is necessary to invoke some
        deep copy method explicity.

    + _Reference Semantics_ -> Objects are passed by reference or
      pointer; assigned by pointer and so on. Objects passed to
      functions using reference semantics can modified. This is the
      default behavior of Java, Python, C# and other programming
      languages.

      + Object A = B; (C#, Java, Python ...) => The object A is
        reference to object B. Any modification to A or B will modify
        both as the refer to the same memory location.

      + Object& A = B; (C++ only) => Creating a reference in C++
        requires an explicit annotation with operator (&) as it is
        non-default behavior.

  + Most programming languages, except C++, uses value-semantics for
    primitive types and reference semantics for complex or composite
    types such as objects due to performance reasons.

  + C++ Uses _values-semantics_ by default for all types, unlike most
    programming languages, when any primitive type or composite type such
    as class when assigned, passed to functions or returned from 
    functions, copy is created and the original object is not
    changed.

  + _C++ supports both value and reference semantics_ which is not
    default for objects linke in Java, Python and other languages. The
    reference semantics requires explicit annotation.

  + In order to avoid unncessary copies what would bring memory
    peformance overhead, it is preferable to use reference semantics,
    in other words, pass large objects by reference or const reference
    to functions or methods. 

  + Move semantics optmizes return-by value avoiding copy. The copy
    overhead can avoided when returning an object from functions by
    defining a _move constructor_ (see C++11's move semantics) which
    transfer resource ownership from the object defined locally within
    the function body to the returned object.

  *Further Reading:*

  + ISO C++ - Reference and Value Semantics -
    <https://isocpp.org/wiki/faq/value-vs-ref-semantics>
    + Note: Provides a good and clear definition about what really is
      value and reference semantics. 

  + Andrezj's C++ blog - Value Semantics -
    <https://akrzemi1.wordpress.com/2012/02/03/value-semantics/> 

  + Value Semantics - Code of the danmed -
    <http://codeofthedamned.com/index.php/value-semantics>

  + What do ‘value semantics’ and ‘pointer semantics’ mean? -
    <https://stackoverflow.com/questions/166033/what-do-value-semantics-and-pointer-semantics-mean>

  + MSDN - Value Types (Modern C++) -
    <https://msdn.microsoft.com/en-us/library/hh438479.aspx>
    + Note:

  + My Precious Compile Time Bool (long introduction to Move
    Semantics) - <https://medium.com/@gaussnoise/my-precious-compile-time-bool-long-introduction-to-move-semantics-c9ee73c370c7>

  + 

** Template type-safe duck-typing or structural typing 

In dynamically programming languages like Python, Ruby and etc, a
function or method can accept any object implementing the methods
referred in the function body regardless of the object base or
interface. For instance, in the code below the function describeArea
will work with any class implementing the methods .area() and .name()
not matter the object's base class. 

This ability to work with any object which has that requested types,
in this case .area() and .name() is called _duck-typying_. Other
languages with duck-typing ability are Smalltalk, Groovy, C#, Scala
and Objective-C. The advantage of duck-typing is that function or
methods can work with classes without an inheritance hierarchy or a
common base class.

#+BEGIN_SRC python 
  def describeArea(shape):
      print("Shape is      = " + shape.name())
      print("Shape area is = " + str(shape.area()))

  class Square:
      def __init__(self, side):
          self.side = side 
      def area(self):
          return self.side * self.side
      def name(self):
          return "square"

  class Circle:
      def __init__(self, radius):
          self.radius = radius
      def area(self):
          return self.radius * self.radius  * 3.1415
      def name(self):
          return "circle"    
#+END_SRC

Running: 

#+BEGIN_SRC python 
  >>> s = Square(10)
  >>> c = Circle(3)
  >>>

  >>> describeArea(s)
  Shape is      = square
  Shape area is = 100
  >>> 
  >>> describeArea(c)
  Shape is      = circle
  Shape area is = 28.273500000000002
  >>> 
  >>> 
#+END_SRC


 *C++ "Duck-typing" or type-safe structural typing*

C++ templates feature supports a more type-safe duck-typing as the
feature allows to write functions or methods which works with any
object implementing the methods requested in the template code
regardless of passed types have a common class hierarchy or a base
class. However, unlike Python or Scala's duck typing, C++'s template
doesn't have performance penalty due to dynamic polymorphism or
reflection as it generates code at compile-time for each parameter
type. 

The C++'s template duck-typing is also called static polymorphism as a
contrast to dynamic polymorphism which requires that all objects
passed to a function or method implement the same base class.

Example: The function describeArea works with any object implementing
the methods area() and name(), however unlike Python and other
dynamically typed languages, if an object that doesn't implement none
of those mentioned methods is passed as argument, a compile error will
be generated rather than a runtime error. 

The advantage of C++ template is that it eliminates the runtime
overhead of dynamic polymorphism or virtual function calls, therefore
makes the code more performant and loosely coupled as it can work with
any class without any inheritance hierarchy.  

#+BEGIN_SRC cpp 
  #include <iostream>

  // Works with any type T which implements .name() or .area()
  template <class T>
  void describeArea(const T& obj){
          std::cout << "Shape is = " << obj.name() << std::endl;
          std::cout << "Area is  = " << obj.area() << std::endl;
          std::cout << "---------" << std::endl;
  }

  class Circle{
  private:
          double m_radius;
  public:
          Circle(double radius): m_radius(radius) {};
          double area() const {
                  return 3.1415 * m_radius * m_radius;
          }
          const char* name() const {
                  return "circle";
          }	
  };

  class Square{
  private:
          double m_side;
  public:
          Square(double side): m_side(side) {};
          double area() const {
                  return m_side * m_side;
          }
          const char* name() const {
                  return "square";
          }
  };

  int main(){
          Square s(4.0);
          Circle c(3.0);
          describeArea(s);
          describeArea(c);
          return 0;
  }

#+END_SRC

Running: 

 - The template generates multiple versions of the function
   describeArea specific for each type, for instance, it generates,
   describeArea(const Circle&) and describeArea(const Square&). The
   static polymorphism is a high performance alternative to the use of
   dynamic polymorphism, inheritance, and virtual methods since the
   methods that will be called are resolved at compile-time.

#+BEGIN_SRC sh 
  $ clang++ -std=c++11 templateDuckTyping.cpp -o out.bin && ./out.bin
  Shape is = square
  Area is  = 16
  ---------
  Shape is = circle
  Area is  = 28.2735
  ---------
#+END_SRC

Summary: 

 + C++ Templates works in similar fashion to dynamically typed
   languages' duck typing.

 + Templates can make the code more loosely coupled as they works with
   any class or type implementing the requested methods.

 + Templates have zero cost and follows the C++ motto, "don't pay for
   what you don't use" they only generate code when requested or
   instantiated.

 + Templates are widely used in the STL (Standard Template Library)
   and the Boost Library.

** C++11 - Scoped Enum

Scoped enumerations are a more type-safe alternative to the old
C-enums as it has several problems realated to namespace conflicts and
implicit conversions that can introduce bugs hard to catch and reason
about. 

Syntax: 

 - Simple scoped enum class 

#+BEGIN_SRC cpp 
  enum class Color {
     white,
     black,
     yellow,
     red,
     blue,
  };

  >> Color::white
  (Color) (Color::white) : (int) 0
  >> Color::blue
  (Color) (Color::blue) : (int) 4
  >> Color::yellow
  (Color) (Color::yellow) : (int) 2
  >> Color::red
  (Color) (Color::red) : (int) 3
  >> 

  >> static_cast<int>(Color::blue)
  (int) 4
  >> static_cast<int>(Color::white)
  (int) 0
  >> static_cast<int>(Color::yellow)
  (int) 2
  >> 
#+END_SRC

 - Scoped enum with hexadecimal error codes.
 
#+BEGIN_SRC cpp 
  enum class ErrorCode: std::uint32_t {
     tankNotFilled = 0xff,
     missingSupply = 0x2f,
     lowBattery    = 0x2a,
     unknown       = 0x24                                         
  };
#+END_SRC

 - Scoped enums with chars 

#+BEGIN_SRC cpp 
  enum class ErrorCodeLetter: char {
          tankNotFilled = 'x',
          missingSupply = 'y',
          lowBattery    = 'a',
          unknown       = 'k'                                         
  };

  >> ErrorCodeLetter::tankNotFilled
  (ErrorCodeLetter) (ErrorCodeLetter::tankNotFilled) : (char) 120
  >> ErrorCodeLetter::missingSupply
  (ErrorCodeLetter) (ErrorCodeLetter::missingSupply) : (char) 121
  >> ErrorCodeLetter::unknown
  (ErrorCodeLetter) (ErrorCodeLetter::unknown) : (char) 107
  >> static_cast<char>(ErrorCodeLetter::unknown)
  (char) 'k'
  >> static_cast<char>(ErrorCodeLetter::missingSupply)
  (char) 'y'
  >> 
#+END_SRC


 *More Exhaustive Example:*

#+BEGIN_SRC cpp 
  enum class MachineStatus: std::uint32_t {
     running = 0xf5,
     iddle   = 0x2a,
     waiting = 0x35,
     failure = 0x24                                         
  };
#+END_SRC

Example: CERN's root shell. 

#+BEGIN_SRC cpp 
   >> MachineStatus::running
   (MachineStatus) (MachineStatus::running) : (unsigned int) 245
   >> MachineStatus::iddle
   (MachineStatus) (MachineStatus::iddle) : (unsigned int) 42
   >> MachineStatus::waiting
   (MachineStatus) (MachineStatus::waiting) : (unsigned int) 53
   >> MachineStatus::failure
   (MachineStatus) (MachineStatus::failure) : (unsigned int) 36
   >> 

   >> auto status = MachineStatus::running
   (MachineStatus) (MachineStatus::running) : (unsigned int) 245

   >> std::cout << "Machine status = " << std::hex << "0x" << static_cast<std::uint32_t>(status) << std::endl;
   Machine status = 0xf5
   >> 
   >> 

   >> status = MachineStatus::iddle 
   (MachineStatus) (MachineStatus::iddle) : (unsigned int) 42
   >> std::cout << "Machine status = " << std::hex << "0x" << static_cast<std::uint32_t>(status) << std::endl;
   Machine status = 0x2a
   >> 

   >> if(status == MachineStatus::iddle) { std::cout << "Machine is iddle" << std::endl; }
   Machine is iddle
   >> 

   >> status = MachineStatus::running
   (MachineStatus) (MachineStatus::running) : (unsigned int) 245
   >> if(status == MachineStatus::running) { std::cout << "Machine is running" << std::endl; }
   Machine is running
   >> 

   >> static_cast<std::uint32_t>(MachineStatus::running)
   (unsigned int) 245
   >> static_cast<std::uint32_t>(MachineStatus::iddle)
   (unsigned int) 42
   >> static_cast<std::uint32_t>(MachineStatus::iddle) == 0x2a
   (bool) true
   >> 
   >> static_cast<MachineStatus>(0x2a) 
   (MachineStatus) (MachineStatus::iddle) : (unsigned int) 42
   >> 
   >> static_cast<MachineStatus>(0x2a) == MachineStatus::iddle
   (bool) true
   >> 
#+END_SRC

** C++11 - Uniform Initialization

The C++11 uniform initialization feature allows classes, STL
containers (collections) and primitives values to be initialized in a
uniform way similar to vectors and C-arrays. 

 - Uniform initialization of primitive types: 

#+BEGIN_SRC cpp 
  int    x {};   // x = 0
  double fd {};  // fd = 0.0
  float  ff {};  // ff = 0.0f
  bool   flag{}; // flag = false = 0 
#+END_SRC

 - Uniform initialization of C-arrays 

#+BEGIN_SRC cpp 
  int xs[] {10, 20, 30};  //  int xs[] =  {10, 20, 30};
  double ys[3] {1.0};     //  double ys[] = {1.0};
#+END_SRC

 - Uniform initialization of pointers 

#+BEGIN_SRC cpp 
  double* fdptr{} ; // fdptr = nullptr 
#+END_SRC

 - Uniform initialization of STL containers: 

#+BEGIN_SRC cpp 
  std::string s {};                // s = ""
  std::string s {"Hello world"};   // s = "Hello World"

  // Vectors 
  std::vector<double> xs {};                      
  std::vector<double> ys {2.0, 3.0, 4.0, 5.0};
  std::vector<string> zs {"apple", "orange", "grape", "banana"};
  // Lists
  std::list<double>   xs {};
  std::list<double>   ys{2.0, 3.0, 4.0, 5.0};   
  // Sets 
  std::set<double>    xs{};
  std::set<double>    ys {3.0, 4.0, 3.0, 10.0};
  // Unordered set 
  std::unordered_set<int>    xs{};
  std::unordered_set<string> zs {"apple", "orange", "grape", "banana"};

  // Maps, aka hash map, aka dictionary, aka hash table 
  std::map<std::string,double> prices {{"orange", 10.0}, {"grapes", 25.12}, {"apple", 4.12}};
#+END_SRC

 - Initialization of C-structus POD - Plain Old Data 

#+BEGIN_SRC cpp 
  struct Point3D{
      double x;
      double y;
      double z;
  };

  // Before C++11
  //---------------------------
  Point3D pa;
  pa.x = 10.0;
  pa.y = 20.0;
  pa.z = 35.0;

  // After C++11
  //---------------------------
  Point3D pb {10.0, 20.0, 35.0};
  Point3D pc = {10.0, 20.0, 35.0};

  // C++ Vector - way 1
  std::vector<Point3D> {{ 20.0, 15.0, 5.0}, { 10.0, 25.0, 12.4}, {-14.0, 0.32, 51.43}};

  // C++ Vector - way 2 
  std::vector<Point3D> {
        Point3D{ 20.0, 15.0, 5.0}
       ,Point3D{ 10.0, 25.0, 12.4}
       ,Point3D{-14.0, 0.32, 51.43}
  };

  // C++ Map Containers 
  std::map<std::string, Point3D> locations = {
       {"City 1",    { 20.0, 15.0, 5.0}}
      ,{"Somewhere", { 10.0, 25.0, 12.4}}
      ,{"Nowhere",   {-14.0, 0.32, 51.43}}     
  };

  // or in more pleasant notation 
  // C++ Map Containers 
  auto locations2 = std::map<std::string, Point3D> {
       {"City 1",    { 20.0, 15.0, 5.0}}
      ,{"Somewhere", { 10.0, 25.0, 12.4}}
      ,{"Nowhere",   {-14.0, 0.32, 51.43}}     
  };

  //--- Functions -------//

  Point3D makeOriginPoint(){
      // return Point3D{0.0, 0.0, 0.0};
      return {0.0, 0.0, 0.0};
  }

#+END_SRC

Classes: 

#+BEGIN_SRC cpp 
  class A{
  public: 
      A(double x, double y, double z, std::string name):
          m_x(x),
          m_y(y),
          m_z(z),
          m_name(name) {      
      }
      auto getX() -> double{ return m_x;}
      auto getY() -> double {return m_y;}
      auto getZ() -> double {return m_z;} 
  private:
      double m_x;
      double m_y;
      double m_z; 
  };

  void display(const A& a){
      std::cout << "A (" << a.getX() << " " << a.getY() << a.getZ() << ")" << "\n";
  }

  int main(){
      A instance1 {10.0, 20.0, 15.0, "unknown binary blob"};  
      display(instance1);
      display({10.0, 20.0, 15.0, "unknown binary blob"});
      return 0;
  }

#+END_SRC

References: 

 + [[http://scottmeyers.blogspot.com/2015/09/thoughts-on-vagaries-of-c-initialization.html][The View from Aristeia: Thoughts on the Vagaries of C++ Initialization]]
 + [[https://www.codeguru.com/cpp/cpp/article.php/c19081/C-2011-Uniform-Initialization.htm][C++ 2011: Uniform Initialization]]
 + [[https://mbevin.wordpress.com/2012/11/16/uniform-initialization/][Lesson #3: Uniform Initialization | Mike's C++11 Blog]]
 + [[https://softwareengineering.stackexchange.com/questions/133688/is-c11-uniform-initialization-a-replacement-for-the-old-style-syntax][c++ - Is C++11 Uniform Initialization a replacement for the old style syntax? - Software Engineering Stack Exchange]]
 + 
 + 

** C++17 New Features 
*** Cpp17 std::invoke 
    :PROPERTIES:
    :ID:       5754cb0e-f4d3-434c-85e0-5ea55655a22f
    :END:

Function which provides an uniform interface for invoking anything
callable such as class member functions (ordinary methods), static
member functions (static methods), functios and etc.

See: https://en.cppreference.com/w/cpp/utility/functional/invoke

File: [[file:src/cpp17/cpp17-invoke.cpp][file:src/cpp17/cpp17-invoke.cpp]] 

#+BEGIN_SRC cpp :tangle src/cpp17/cpp17-invoke.cpp
  #include <iostream>
  #include <string>
  #include <ostream>

  // std::invoke is provide by header functional
  #include <functional> 

  struct Dummy{
          double evalme(double x)	{
                  std::cerr << __FILE__ << ":" << __LINE__ << " I was evaluated ; 2x = " << 2 *x << '\n';
                  return 2 * x;
          }
          double operator()(double x){
                  std::cerr << __FILE__ << ":" << __LINE__ << " Call function-operator << 4 * x = " << 4 * x << '\n';
                  return 4 * x;
          }
  };

  double computeDouble(double x){
          std::cerr << __FILE__ << ":" << __LINE__ << " Computed double of 2x = " << 2 * x << '\n';
          return 2 * x;
  }

  int main(){
          std::invoke(computeDouble, 3.0);
          Dummy dummy;
          std::invoke(dummy, 3.0);
          std::invoke(Dummy(), 2.0);
          // Call method: .evalme indirectly 
          std::invoke(&Dummy::evalme, dummy, 3.0);
          return 0;
  }

#+END_SRC

Compile and run: 

#+BEGIN_SRC sh 
  g++ cpp17-invoke.cpp -o out.bin -std=c++1z -Wall -Wextra && ./out.bin
  cpp17-invoke.cpp:20 Computed double of 2x = 6
  cpp17-invoke.cpp:14 Call function-operator << 4 * x = 12
  cpp17-invoke.cpp:14 Call function-operator << 4 * x = 8
  cpp17-invoke.cpp:9 I was evaluated ; 2x = 6
#+END_SRC

*** Cpp17 std::any 
    :PROPERTIES:
    :ID:       9397a9a0-e641-4cb6-89b7-24a82fe12d99
    :END:

This example shows how to use the C++17 std::any container which comes
froom boost::any.

See: https://en.cppreference.com/w/cpp/utility/any

File:  [[file:src/cpp17/cpp17-any.cpp][file:src/cpp17/cpp17-any.cpp]] 

#+BEGIN_SRC cpp :tangle src/cpp17/cpp17-any.cpp
  #include <iostream>
  #include <string>
  #include <iomanip>
  #include <ostream>

  #include <any>

  struct Point{
      double x;
      double y;
      Point(double x, double y): x(x), y(y) {}

      // Copy constructor
      Point(const Point& p){
          std::cerr << " -->> Copy constructor" << '\n';
          x = p.x;
          y = p.y;
      }   
  };

  std::ostream& operator<<(std::ostream& os, const Point& p){
      os << "Point(" << p.x << ", " << p.y << ") ";
      return os;
  }

  template<typename T>
  auto printInfo(std::any x) -> void{
      std::cout << " x.type = " << x.type().name()
                << " ; value(x) = "
                << std::any_cast<T>(x)
                << '\n';  
  }

  int main(){
      // Print boolean as 'true', 'false', instead of 0 or 1
      std::cout << std::boolalpha;
      std::any x = 1;
      printInfo<int>(x);
      x = 10.233;
      printInfo<double>(x);
      x = 'k';
      printInfo<char>(x);
      x = "hello world";
      printInfo<const char*>(x);
      x = std::string("hello world");
      printInfo<std::string>(x);  
      x = Point(100.0, 20.0);
      printInfo<Point>(x);
      std::cout << "Has value: x.has_value() = " << x.has_value() << '\n';
      x.reset();                                                         
      std::cout << "Has value: x.has_value() = " << x.has_value() << '\n';                                                               
      std::cout << "Try casting " << std::endl;
      x = "testing type casting";
      try{
          std::any_cast<int>(x);
      } catch (const std::bad_any_cast& ex) {
          std::cerr << " >>> Exception: what = " << ex.what() << '\n'; 
      }
      std::cerr << " >>> End the program gracefully" << '\n'; 
      return 0;
  }

#+END_SRC

Compiling with gcc: 

#+BEGIN_SRC sh 
  $ g++ --version
  g++ (GCC) 7.3.1 20180130 (Red Hat 7.3.1-2)
  .. ... ... ... 

  $ g++ cpp17-any.cpp -o out.bin -std=c++1z -Wall -Wextra && ./out.bin
   x.type = i ; value(x) = 1
   x.type = d ; value(x) = 10.233
   x.type = c ; value(x) = k
   x.type = PKc ; value(x) = hello world
   x.type = NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE ; value(x) = hello world
   -->> Copy constructor
   -->> Copy constructor
   x.type = 5Point ; value(x) =  -->> Copy constructor
  Point(100, 20) 
  Has value: x.has_value() = true
  Has value: x.has_value() = false
  Try casting 
   >>> Exception: what = bad any_cast
   >>> End the program gracefully
#+END_SRC

Compile with MSVC / VC++ on Windows: 

#+BEGIN_SRC sh 
  $ cl.exe cpp17-any.cpp /EHsc /Zi /nologo /std:c++17 /Fe:out.exe && out.exe
  cpp17-any.cpp
   x.type = int ; value(x) = 1
   x.type = double ; value(x) = 10.233
   x.type = char ; value(x) = k
   x.type = char const * __ptr64 ; value(x) = hello world
   x.type = class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > ; value(x) = hello world
   -->> Copy constructor
   -->> Copy constructor
   -->> Copy constructor
   x.type = struct Point ; value(x) = Point(100, 20) 
  Has value: x.has_value() = true
  Has value: x.has_value() = false
  Try casting 
   >>> Exception: what = Bad any_cast
   >>> End the program gracefully
#+END_SRC
*** Cpp17 std::variant 
    :PROPERTIES:
    :ID:       8232d77f-99a5-4434-96f2-c5c3cfd6d956
    :END:

C++17 new std::variant which comes from Boost.Variant provides a
type-safe discriminated union or sum type which is similar to pattern
matching from functional programming languages like Haskell, OCaml and
Scala. In addition to those benefits, the std::variant is an
out-of-the-box generic visitor design pattern and a type-safe
replacement for old C-unions.

Potential Applications: 
 + Implement visitor OOP pattern.
 + Simulate or emulate pattern matching from functional languages.
 + Manipulate abstract syntax trees.

Useful concepts references: 
 + [[https://en.wikipedia.org/wiki/Tagged_union][Tagged union - Wikipedia]]
 + [[https://en.wikipedia.org/wiki/Algebraic_data_type][Algebraic data type - Wikipedia]]

Documentation: 
 + https://en.cppreference.com/w/cpp/utility/variant
 + [[https://www.boost.org/doc/libs/1_64_0/doc/html/variant.html][Chapter 45. Boost.Variant - 1.64.0]]

Code example: 

 - File: [[file:src/cpp17/variant.cpp][file:src/cpp17/variant.cpp]] 

#+BEGIN_SRC cpp :tangle src/cpp17/variant.cpp
  #include <iostream>
  #include <variant> // C++17
  #include <string>
  #include <ostream>
  #include <deque>
  #include <vector>
  #include <iomanip>

  template <class T>
  auto display(const std::string& name, const T& t) -> void;

  // Pattern matching using constexpr => May be the more performant way 
  template<class T>
  auto identifyAndPrint(const T& v) -> void;

  struct VisitorOperation{
          auto operator()(int num) -> void {
                  std::cout << "type = int     => value = " << num << "\n";
          }
          auto operator()(double num) -> void {
                  std::cout << "type = double  => value = " << num << "\n";
          }
          auto operator()(const std::string& s){
                  std::cout << "type = string  => value = " << s << "\n";
          }
  };

  int main(){
          // using <1>, <2>, ... <n> => Only available at C++17
          using std::cout, std::endl, std::cerr;
          auto nl = "\n";
          std::cout << std::boolalpha;
          cout << "========== Test 1 ==================" << nl;	
	
          // std::variant<int, double, std::string> somevar;
          auto x = std::variant<int, double, std::string>();
          x = 100;
          std::cout << "variant has int    = " << std::holds_alternative<int>(x) << nl;
          std::cout << "variant has double = " << std::holds_alternative<double>(x) << nl;
          std::cout << "variant has string = " << std::holds_alternative<std::string>(x) << nl;
          display("x", x);
          std::cout << "-------------------" << nl;
          x = 204.45;
          std::cout << "variant has double = " << std::holds_alternative<double>(x) << nl;	
          display("x", x);
          std::cout << "-------------------" << nl;
          x = "std::variant is awesome!";
          std::cout << "variant has string = " << std::holds_alternative<std::string>(x) << nl;
          display("x", x);

          cout << "========== Test 2 ==================" << nl;
          try{ 
                  // Try to get int 
                  int m = std::get<int>(x);
                  std::cout << "m = " << m << "\n";
          } catch(const std::bad_variant_access& ex){
                  std::cerr << "Error: Failed to extract int." << nl;
          }
          try{ 
                  // Try to get string 
                  auto s = std::get<std::string>(x);
                  std::cout << "s = " << s << nl;
          } catch(const std::bad_variant_access& ex){
                  std::cerr << "Error: Failed to extract string." << nl;
          }

          cout << "========== Test 3 ==================" << nl;
          x = -100;
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);
          x = 20.52;
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);

          x = "<hello world std::variant>";
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);

          cout << "========== Test 4 ==================" << nl;
          // auto + uniform initialization 
          auto xs = std::deque<std::variant<int, double, std::string>>{10.0, 20, 5, "hello", 10, "world"};
          for(const auto& e: xs){
                  identifyAndPrint(e);
          }
          cout << "========== Test 5 ==================" << nl;
          for(const auto& e: xs){
                  std::visit(VisitorOperation(), e);
          }	
          return 0;
  }

  // It works in a similar fashion to functional languages with
  // pattern matching such as Haskell, Scala, OCaml and so on.
  // std::variant is also a type-safe alternative to old C-unions.
  template <class T>
  auto display(const std::string& name, const T& t) -> void {
          auto nl = "\n";
          // Boost.Variant uses boost::get<TYPE>(&t), now changed to std::get_if
          if(auto n = std::get_if<int>(&t)){
                  std::cout << " = " << *n << nl;
                  return; // Early return 
          }
          if(auto d = std::get_if<double>(&t)){
                  std::cout << name << " = " << *d << nl;
                  return;
          }	
          if(auto s = std::get_if<std::string>(&t)){
                  std::cout << name << " = " << *s << nl;
                  return;
          }
          std::cout << "<UNKNOWN>" << std::endl;
  }

  template<class T>
  auto identifyAndPrint(const T& v) -> void{
          std::visit([](auto&& a){
              using C = std::decay_t<decltype(a)>;
              if constexpr(std::is_same_v<C, int>){
                              std::cout << "Type is int => value = " << a << "\n";
                              return;
              }
              if constexpr(std::is_same_v<C, double>){
                              std::cout << "Type is double => value = " << a << "\n";
                              return;
              }
              if constexpr(std::is_same_v<C, std::string>){
                              std::cout << "Type is string => value = " << a << "\n";
                              return;
              }
              std::cout << "Type is unknown" << "\n";
                             }, v);
  } // End of func. identifyAndPrint() ---//

#+END_SRC

Compile with GCC:

#+BEGIN_SRC sh 
 $ g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin 
#+END_SRC

Compile with Clang:

#+BEGIN_SRC sh 
 $ g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin 
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin

  ========== Test 1 ==================
  variant has int    = true
  variant has double = false
  variant has string = false
   = 100
  -------------------
  variant has double = true
  x = 204.45
  -------------------
  variant has string = true
  x = std::variant is awesome!
  ========== Test 2 ==================
  Error: Failed to extract int.
  s = std::variant is awesome!
  ========== Test 3 ==================
  x = -100
  x = 20.52
  x = <hello world std::variant>
  ========== Test 4 ==================
  Type is double => value = 10
  Type is int => value = 20
  Type is int => value = 5
  Type is string => value = hello
  Type is int => value = 10
  Type is string => value = world
  ========== Test 5 ==================
  type = double  => value = 10
  type = int     => value = 20
  type = int     => value = 5
  type = string  => value = hello
  type = int     => value = 10
  type = string  => value = world


#+END_SRC

