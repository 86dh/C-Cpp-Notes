<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-01-14 Mon 01:47 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CPP / C++ Review</title>
<meta name="generator" content="Org mode" />
<meta name="description" content="cpp c++ code examples, demonstrations, design pattern and integration."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<link href="theme/org-nav-theme.css" rel="stylesheet">
<script src="theme/org-nav-theme.js"></script>
<link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CPP / C++ Review</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf47884e">1. Template Metaprogramming or Generic Programming</a>
<ul>
<li><a href="#orgdce0676">1.1. Overview</a></li>
<li><a href="#org5cefb24">1.2. Template type-safe duck-typing or structural typing</a></li>
<li><a href="#org11ebbc3">1.3. Class Template</a>
<ul>
<li><a href="#org9ef7d8b">1.3.1. Example: Generic stack class</a></li>
<li><a href="#orga19c478">1.3.2. Example: Tuple of three elements</a></li>
</ul>
</li>
<li><a href="#org4b19d14">1.4. Non-class template parameters</a>
<ul>
<li><a href="#orga48e852">1.4.1. Overview</a></li>
<li><a href="#org7093ef1">1.4.2. Integer as template parameter</a></li>
<li><a href="#org2540907">1.4.3. Function pointer as template parameter</a></li>
<li><a href="#orgb070df6">1.4.4. Class templates as template parameters</a></li>
</ul>
</li>
<li><a href="#org89586b2">1.5. Templates and STL Containers</a>
<ul>
<li><a href="#org437b09b">1.5.1. Overview</a></li>
<li><a href="#org6723973">1.5.2. Example 1 - iterating over containers</a></li>
<li><a href="#org8faeeef">1.5.3. Example 2 - print any sequential container (typename)</a></li>
<li><a href="#orge6f666c">1.5.4. Example 3 - print map container</a></li>
<li><a href="#org8bf0be2">1.5.5. Example 4 - print any associative container</a></li>
</ul>
</li>
<li><a href="#orga14c3f4">1.6. Templates with Ranges</a></li>
<li><a href="#orga8631a4">1.7. Basic Template Specialization</a></li>
<li><a href="#org4c54f6a">1.8. Template Type Alias - 'using'</a></li>
<li><a href="#org7e9ab13">1.9. Templates with default arguments</a></li>
<li><a href="#orge023348">1.10. Implementing Higher Order Functions with templates</a></li>
<li><a href="#orgae456df">1.11. Metafunctions or type traits</a>
<ul>
<li><a href="#orgf023608">1.11.1. Overview</a></li>
<li><a href="#org342ce32">1.11.2. Example</a></li>
</ul>
</li>
<li><a href="#org717ffc8">1.12. Predefined type traits in &lt;type_traits&gt;</a></li>
<li><a href="#org669399d">1.13. Variadic Templates</a></li>
<li><a href="#org94fa1c0">1.14. Variadic Templates - sizeof&#x2026; operator</a></li>
<li><a href="#orgbf5445d">1.15. Variadic Templates arguments expansion</a></li>
<li><a href="#orgba0c477">1.16. SFINAE - Substution Is Not a Failure</a>
<ul>
<li><a href="#org7d06540">1.16.1. Fundamentals</a></li>
<li><a href="#orgb305d7e">1.16.2. Metafunction or type trait std::enable_if</a></li>
<li><a href="#orgfd2b369">1.16.3. Metafunction or type trait std::enalbe_if_t</a></li>
</ul>
</li>
<li><a href="#org5f5fbd7">1.17. References and Bookmarks</a>
<ul>
<li><a href="#org10d1b9c">1.17.1. General</a></li>
<li><a href="#orgd2fa3fe">1.17.2. Videos</a></li>
<li><a href="#orgae9a2ec">1.17.3. Papers and technical documents</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<ul class="org-ul">
<li><a href='index.html'>Index</a></li>
</ul>

<div id="outline-container-orgf47884e" class="outline-2">
<h2 id="orgf47884e"><span class="section-number-2">1</span> Template Metaprogramming or Generic Programming</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgdce0676" class="outline-3">
<h3 id="orgdce0676"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<b>C++ Metaprogramming Features:</b>
</p>

<ul class="org-ul">
<li><span class="underline">Templates</span>
<ul class="org-ul">
<li>Use case:
<ul class="org-ul">
<li>Template metaprogramming or generic programming</li>
<li>Generic classes and containers</li>
<li>Generic algorithms</li>
<li>Compile-time optmization</li>
<li>Write high performance code by eliminating virtual member
function calls.</li>
</ul></li>
<li>Limitation: Unfortunately, the C++ templates cannot manipulate
the AST and generate code in the way that LISP-like languages
do.</li>
</ul></li>

<li>C++11 <span class="underline">Constexpr</span>
<ul class="org-ul">
<li>Use cases:
<ul class="org-ul">
<li>Compile-time computations such as look up tables, math
constants, CRC32, hash, string encryption and obfuscation at
compile-time and so on.</li>
</ul></li>
</ul></li>

<li><span class="underline">Inline functions</span>
<ul class="org-ul">
<li>Use cases:
<ul class="org-ul">
<li>Removing function-calls. The function code is inserted at the
call-site by the compiler allowing a more efficient and
perfomant code.</li>
</ul></li>
</ul></li>

<li><span class="underline">Pre-processor macros</span>
<ul class="org-ul">
<li>Use-cases:
<ul class="org-ul">
<li>Debugging, print line number, file, current function, function
signature and so on.</li>
<li>Conditional compilation</li>
<li>Conditional compilation for cross platform compatibility</li>
<li>Boilerplate code generation which cannot be done with templates
or anything else.</li>
<li>Generation of reflection data.</li>
</ul></li>
</ul></li>
</ul>

<p>
<b>Generic Programming / Template Metaprogramming Design Patterns:</b>
</p>

<ul class="org-ul">
<li><span class="underline">Generic Functions, algorithms and containers</span>
<ul class="org-ul">
<li>Some known use cases:
<ul class="org-ul">
<li>C++ STL introduced by Alexander Stepanov.</li>
<li>Boost Libraries</li>
</ul></li>
</ul></li>
<li><span class="underline">CRTP =&gt; Curious Recurring Template Pattern</span>
<ul class="org-ul">
<li>Eliminates virtual function-calls overhead by emulating
inheritance or dynamic polymorphism with static polymorphism or
template metaprogramming.</li>
</ul></li>
<li><span class="underline">Type Erasure</span> 
<ul class="org-ul">
<li>Despite the high performance and the ability to operate ony type
regardless of the class hierarchy, the main shortcoming of
generic programming is that, it is not possible to store
unrelated types in the same containers or access them by the same
pointer. The type erasure technique address those downsides by
combining generic programmign and generic programming.</li>
<li>Known uses:
<ul class="org-ul">
<li>std::function (C++11)</li>
<li>std::any (C++17), Boost.any, std::variant (C++17) and Boost.variant</li>
</ul></li>
</ul></li>
<li><span class="underline">EP =&gt; Expression Template</span> =&gt; Technique used by many scientific
library for encoding DSL - Domain Specific Languages with
templates.
<ul class="org-ul">
<li>Some known uses of this design pattern are:
<ul class="org-ul">
<li>Linear Algebra: librareis Blitz++, Eigen and Armadillo</li>
<li>Automatic Differentiation.</li>
</ul></li>
</ul></li>
<li><span class="underline">Meta Functions</span> =&gt; "Functions" emualted with structs and static
methods or members that can manipulate types or query information
about types using template specialisation.</li>
<li><span class="underline">Policy Based Design</span></li>
<li><span class="underline">SFINAE</span></li>
</ul>

<p>
<b>Libraries and Frameworks for metaprogramming:</b>
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html">Boost.Hana</a></li>
<li><a href="https://www.boost.org/doc/libs/1_68_0/libs/fusion/doc/html/fusion/preface.html">Boost.Fusion</a></li>
<li><a href="https://www.boost.org/doc/libs/1_68_0/libs/mpl/doc/index.html">Boost.MPL</a></li>
</ul>

<p>
<b>Tool for testing templates online</b> 
</p>

<ul class="org-ul">
<li><a href="http://metashell.org/index.html">Home - Metashell</a> - "The goal of this project is to provide an
interactive template metaprogramming shell."</li>

<li><a href="https://godbolt.org/">https://godbolt.org/</a> - Compiler explorer, allows taking a closer
look at the object code (assembly and symbols) generated by
templates.</li>
</ul>

<p>
<b>Advanced Templates</b> 
</p>

<ul class="org-ul">
<li>template-template or nested templates</li>
<li>Universal references, std::forward</li>
<li>std::index_sequence</li>
<li>std::make_index_sequence</li>
<li>std::enable_if</li>
<li>dependent type with (typename) keyword</li>
<li>decltype</li>
<li>declval</li>
<li>variadic templates with tuples and variadic functions</li>
<li>Policy-based design pattern</li>
<li>SFINAE</li>
<li>CRTP</li>
</ul>

<p>
<b>Template Metaprogramming Reference</b> 
</p>

<ul class="org-ul">
<li>Andrei Alexandrescu's <b>Loki Library</b> (<a href="http://loki-lib.sourceforge.net/">http://loki-lib.sourceforge.net/</a>)
<ul class="org-ul">
<li>type list</li>
<li>functor</li>
<li>singleton</li>
<li>object factory</li>
<li>visitor</li>
<li>multi methods</li>
<li>pimpl - pointer to implementation.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org5cefb24" class="outline-3">
<h3 id="org5cefb24"><span class="section-number-3">1.2</span> Template type-safe duck-typing or structural typing</h3>
<div class="outline-text-3" id="text-1-2">
<p>
In dynamically programming languages like Python, Ruby and etc, a
function or method can accept any object implementing the methods
referred in the function body regardless of the object base or
interface. For instance, in the code below the function describeArea
will work with any class implementing the methods .area() and .name()
not matter the object's base class. 
</p>

<p>
This ability to work with any object which has that requested types,
in this case .area() and .name() is called <span class="underline">duck-typying</span>. Other
languages with duck-typing ability are Smalltalk, Groovy, C#, Scala
and Objective-C. The advantage of duck-typing is that function or
methods can work with classes without an inheritance hierarchy or a
common base class.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">describeArea</span>(shape):
    <span class="org-keyword">print</span>(<span class="org-string">"Shape is      = "</span> + shape.name())
    <span class="org-keyword">print</span>(<span class="org-string">"Shape area is = "</span> + <span class="org-builtin">str</span>(shape.area()))

<span class="org-keyword">class</span> <span class="org-type">Square</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, side):
        <span class="org-keyword">self</span>.side = side 
    <span class="org-keyword">def</span> <span class="org-function-name">area</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.side * <span class="org-keyword">self</span>.side
    <span class="org-keyword">def</span> <span class="org-function-name">name</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-string">"square"</span>

<span class="org-keyword">class</span> <span class="org-type">Circle</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, radius):
        <span class="org-keyword">self</span>.radius = radius
    <span class="org-keyword">def</span> <span class="org-function-name">area</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.radius * <span class="org-keyword">self</span>.radius  * 3.1415
    <span class="org-keyword">def</span> <span class="org-function-name">name</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-string">"circle"</span>    
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-variable-name">s</span> = Square(10)
&gt;&gt;&gt; <span class="org-variable-name">c</span> = Circle(3)
&gt;&gt;&gt;

&gt;&gt;&gt; describeArea(s)
Shape <span class="org-keyword">is</span>      = square
Shape area <span class="org-keyword">is</span> = 100
&gt;&gt;&gt; 
&gt;&gt;&gt; describeArea(c)
Shape <span class="org-keyword">is</span>      = circle
Shape area <span class="org-keyword">is</span> = 28.273500000000002
&gt;&gt;&gt; 
&gt;&gt;&gt; 
</pre>
</div>


<p>
<b>C++ "Duck-typing" or type-safe structural typing</b>
</p>

<p>
C++ templates feature supports a more type-safe duck-typing as the
feature allows to write functions or methods which works with any
object implementing the methods requested in the template code
regardless of passed types have a common class hierarchy or a base
class. However, unlike Python or Scala's duck typing, C++'s template
doesn't have performance penalty due to dynamic polymorphism or
reflection as it generates code at compile-time for each parameter
type. 
</p>

<p>
The C++'s template duck-typing is also called static polymorphism as a
contrast to dynamic polymorphism which requires that all objects
passed to a function or method implement the same base class.
</p>

<p>
Example: The function describeArea works with any object implementing
the methods area() and name(), however unlike Python and other
dynamically typed languages, if an object that doesn't implement none
of those mentioned methods is passed as argument, a compile error will
be generated rather than a runtime error. 
</p>

<p>
The advantage of C++ template is that it eliminates the runtime
overhead of dynamic polymorphism or virtual function calls, therefore
it makes the code more performant and loosely coupled as it can work
with any class without any inheritance hierarchy.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Works with any type T which implements .name() or .area()</span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">describeArea</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Shape is = "</span> &lt;&lt; obj.name<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Area is  = "</span> &lt;&lt; obj.area<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"---------"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">class</span> <span class="org-type">Circle</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-type">double</span> <span class="org-variable-name">m_radius</span>;
<span class="org-function-name">public</span>:
    <span class="org-function-name">Circle</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">radius</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">m_radius</span><span class="org-rainbow-delimiters-depth-2">(</span>radius<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-type">double</span> <span class="org-function-name">area</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> 3.1415 * m_radius * m_radius;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">name</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-string">"circle"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>   
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">Square</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
   <span class="org-type">double</span> <span class="org-variable-name">m_side</span>;
<span class="org-function-name">public</span>:
   <span class="org-function-name">Square</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">side</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">m_side</span><span class="org-rainbow-delimiters-depth-2">(</span>side<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
   <span class="org-type">double</span> <span class="org-function-name">area</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> m_side * m_side;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">name</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> <span class="org-string">"square"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-type">Square</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">(</span>4.0<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">Circle</span> <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-2">(</span>3.0<span class="org-rainbow-delimiters-depth-2">)</span>;
    describeArea<span class="org-rainbow-delimiters-depth-2">(</span>s<span class="org-rainbow-delimiters-depth-2">)</span>;
    describeArea<span class="org-rainbow-delimiters-depth-2">(</span>c<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Running: 
</p>

<ul class="org-ul">
<li>The template generates multiple versions of the function
describeArea specific for each type, for instance, it generates,
describeArea(const Circle&amp;) and describeArea(const Square&amp;). The
static polymorphism is a high performance alternative to the use of
dynamic polymorphism, inheritance, and virtual methods since the
methods that will be called are resolved at compile-time.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ -std=c++11 templateDuckTyping.cpp -o <span class="org-keyword">out.bin</span> &amp;&amp; ./out.bin
Shape is = square
Area is  = 16
---------
Shape is = circle
Area is  = 28.2735
---------
</pre>
</div>

<p>
Generated functions: 
</p>

<ul class="org-ul">
<li>Once the template is instantiated, it will generate the following
overloaded functions:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Overloaded describeArea for Circle class </span>
<span class="org-type">void</span> <span class="org-function-name">describeArea</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Circle</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Shape is = "</span> &lt;&lt; obj.name<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Area is  = "</span> &lt;&lt; obj.area<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"---------"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Overloaded describeArea for Square class  </span>
<span class="org-type">void</span> <span class="org-function-name">describeArea</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Square</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Shape is = "</span> &lt;&lt; obj.name<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Area is  = "</span> &lt;&lt; obj.area<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"---------"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Summary: 
</p>

<ul class="org-ul">
<li>C++ Templates works in similar fashion to dynamically typed
languages' duck typing. The difference is that templates have zero
runtime overhead.</li>

<li>Templates can make the code more loosely coupled as they works with
any class or type implementing the requested methods.</li>

<li>Templates have zero cost and follows the C++ motto, "don't pay for
what you don't use" they are only generate code when requested or
instantiated.</li>

<li>Templates are widely used in the STL (Standard Template Library)
and the Boost Library.</li>

<li>Disadvantages:
<ul class="org-ul">
<li>Generally, templates must be in header files what increases the
compile-time.</li>
<li>Templates can increase the executable size, since they generate
object-code for overloaded functions or classes generated at
compile time. It may not be a problem for desktop applications,
but it can be a drawback for embedded systems.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org11ebbc3" class="outline-3">
<h3 id="org11ebbc3"><span class="section-number-3">1.3</span> Class Template</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org9ef7d8b" class="outline-4">
<h4 id="org9ef7d8b"><span class="section-number-4">1.3.1</span> Example: Generic stack class</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Note: 
</p>

<ul class="org-ul">
<li>A class template is not a class, it is factory of classes and has
zero cost until it is used or instantiated. For instance,
Stack&lt;int&gt; and Stack&lt;std::string&gt; are different classes and cannot
be stored in containers or accessed with the same pointer.</li>

<li>When Stack&lt;int&gt; or Stack&lt;double&gt; appears in the code, the compiler
generates an unique object code for each of those template
instantiation. The C++ generics doesn't have type erasure like
java where all objects can be casted to an instance of Object.</li>

<li>All the template code must be always in the header files.</li>
</ul>

<p>
Class Template Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
        <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">_stack</span>;
<span class="org-function-name">public</span>:
    <span class="org-keyword">struct</span> <span class="org-type">stack_empty_error</span>: <span class="org-keyword">public</span> <span class="org-constant">std</span>::<span class="org-type">exception</span><span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">what</span><span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-keyword">const</span> <span class="org-keyword">throw</span><span class="org-rainbow-delimiters-depth-3">(){</span>
           <span class="org-keyword">return</span> <span class="org-string">" ==&gt; Error: stack empty."</span> ;
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-type">void</span> <span class="org-function-name">push</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-2">){</span>
        _stack.push_back<span class="org-rainbow-delimiters-depth-3">(</span>t<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">T</span> <span class="org-function-name">pop</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>_stack.empty<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
            <span class="org-keyword">throw</span> stack_empty_error<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">x</span> = _stack.back<span class="org-rainbow-delimiters-depth-3">()</span>;
        _stack.pop_back<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">return</span> x;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">T</span> <span class="org-function-name">peek</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>_stack.empty<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>
            <span class="org-keyword">throw</span> stack_empty_error<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">return</span> _stack.back<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">size_t</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">(){</span>  <span class="org-keyword">return</span> _stack.size<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>   <span class="org-function-name">empty</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> _stack.empty<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span>   <span class="org-function-name">clear</span><span class="org-rainbow-delimiters-depth-2">(){</span> _stack.clear<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" stack: "</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: _stack<span class="org-rainbow-delimiters-depth-3">)</span>
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span> &lt;&lt; x ;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<p>
Usage example: 
</p>

<ul class="org-ul">
<li>Instantiate class template with int parameter.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> s1;
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>20<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>-30<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>15<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; 
&gt;&gt; s1.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; 
&gt;&gt; s1.empty<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>

&gt;&gt; s1.print<span class="org-rainbow-delimiters-depth-1">()</span>
 stack:  10 20 -30 15

&gt;&gt; s1.peek<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15

&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> -30
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 20
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
&gt;&gt; s1.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Error</span> <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: <span class="org-constant">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::stack_empty_error caught:  ==&gt; Error: stack empty.
&gt;&gt; 

&gt;&gt; s1.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; s1.empty<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
&gt;&gt;
</pre>
</div>

<ul class="org-ul">
<li>Instantiate class template with std::string parameter.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> sd;
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"c++"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"templates"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; sd.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"test"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; 
&gt;&gt; sd.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; sd.empty<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; sd.peek<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"test"</span>
&gt;&gt; 
&gt;&gt; sd.print<span class="org-rainbow-delimiters-depth-1">()</span>
 stack:  hello c++ templates test
&gt;&gt; 
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"test"</span>
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"templates"</span>
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"c++"</span>
&gt;&gt; sd.pop<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"hello"</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Generic client code for the class stack:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Non-destructive print -&gt; Creates a copy invoking copy constructor </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printStack</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>t.empty<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-constant">std</span>::cout &lt;&lt; t.pop<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">" "</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout.flush<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">fillStack</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-variable-name">t</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">data</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">d</span>: data<span class="org-rainbow-delimiters-depth-2">)</span>
         t.push<span class="org-rainbow-delimiters-depth-2">(</span>d<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Running client code.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> stack_double1;
&gt;&gt; fillStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_double1, <span class="org-rainbow-delimiters-depth-2">{</span>2.0, 5.0, 6.0, 9.0<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; 
&gt;&gt; stack_double1.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; stack_double1.peek<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 9.0000000
&gt;&gt; 

&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_double1<span class="org-rainbow-delimiters-depth-1">)</span>
9 6 5 2 
&gt;&gt; 
&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_double1<span class="org-rainbow-delimiters-depth-1">)</span>
9 6 5 2 

&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> stack_string;
&gt;&gt; fillStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_string, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"hello"</span>, <span class="org-string">"hpc"</span>, <span class="org-string">"C++"</span>, <span class="org-string">"RULEZ"</span>, <span class="org-string">"peformance"</span>, <span class="org-string">"matters"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">(</span>stack_string<span class="org-rainbow-delimiters-depth-1">)</span>
matters peformance <span class="org-type">RULEZ</span> <span class="org-variable-name">C</span>++ hpc hello

&gt;&gt; printStack<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-type">stack_string</span><span class="org-rainbow-delimiters-depth-1">)</span>
matters peformance <span class="org-type">RULEZ</span> <span class="org-function-name">C</span>++ hpc hello 
&gt;&gt; 

&gt;&gt; stack_string.clear<span class="org-rainbow-delimiters-depth-1">()</span>
&gt;&gt; printStack3<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span>stack_string<span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-orga19c478" class="outline-4">
<h4 id="orga19c478"><span class="section-number-4">1.3.2</span> Example: Tuple of three elements</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Code: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Empty constructor - necessary to store by value the tuple</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">in STL containers.</span>
     <span class="org-function-name">tuple3</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
     <span class="org-function-name">tuple3</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">A</span>&amp; <span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">B</span>&amp; <span class="org-variable-name">b</span>, <span class="org-keyword">const</span> <span class="org-type">C</span>&amp; <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-2">)</span>
        : a<span class="org-rainbow-delimiters-depth-2">(</span>a<span class="org-rainbow-delimiters-depth-2">)</span>, b<span class="org-rainbow-delimiters-depth-2">(</span>b<span class="org-rainbow-delimiters-depth-2">)</span>, c<span class="org-rainbow-delimiters-depth-2">(</span>c<span class="org-rainbow-delimiters-depth-2">){</span>     
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-type">A</span> <span class="org-variable-name">a</span>;
     <span class="org-type">B</span> <span class="org-variable-name">b</span>;
     <span class="org-type">C</span> <span class="org-variable-name">c</span>;   
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getA</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;  <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> t.a;    
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;  <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">B</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> t.b;    
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getC</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;  <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> t.c;    
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printTuple1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"tuple3{"</span>
               &lt;&lt; <span class="org-string">" a = "</span> &lt;&lt; t.a
               &lt;&lt; <span class="org-string">" b = "</span> &lt;&lt; t.b
               &lt;&lt; <span class="org-string">" c = "</span> &lt;&lt; t.c
               &lt;&lt; <span class="org-string">" } "</span>
               &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span>, <span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">printTuple2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span>, <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"tuple3{"</span>
               &lt;&lt; <span class="org-string">" a = "</span> &lt;&lt; t.a
               &lt;&lt; <span class="org-string">" b = "</span> &lt;&lt; t.b
               &lt;&lt; <span class="org-string">" c = "</span> &lt;&lt; t.c
               &lt;&lt; <span class="org-string">" } "</span>
               &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> h<span class="org-rainbow-delimiters-depth-1">(</span>100.23, <span class="org-string">'x'</span>, <span class="org-string">"world"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span>tuple3&lt;<span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string&gt; &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f3ea8607010
&gt;&gt; 
&gt;&gt; h.a
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.23000
&gt;&gt; h.b
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'x'</span>
&gt;&gt; h.c
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"world"</span>
&gt;&gt; 

&gt;&gt; getA<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.23000
&gt;&gt; getB<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'x'</span>
&gt;&gt; getC<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"world"</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Types parameter are deduced by the compiler.</span>
&gt;&gt; printTuple1<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100.23 b = x c = world <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; printTuple2<span class="org-rainbow-delimiters-depth-1">(</span>h<span class="org-rainbow-delimiters-depth-1">)</span>
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100.23 b = x c = world <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

&gt;&gt; printTuple1<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-type">h</span><span class="org-rainbow-delimiters-depth-1">)</span>
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -100 b = x c = world <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt;

<span class="org-keyword">auto</span> tdata = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">tuple3</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>100, <span class="org-string">'x'</span>, <span class="org-string">"C++"</span><span class="org-rainbow-delimiters-depth-2">}</span>,
        <span class="org-rainbow-delimiters-depth-2">{</span>200, <span class="org-string">'z'</span>, <span class="org-string">"Forth"</span><span class="org-rainbow-delimiters-depth-2">}</span>,
        <span class="org-rainbow-delimiters-depth-2">{</span>-900, <span class="org-string">'k'</span>, <span class="org-string">"Lisp"</span><span class="org-rainbow-delimiters-depth-2">}</span>,
        <span class="org-rainbow-delimiters-depth-2">{</span>66, <span class="org-string">'p'</span>, <span class="org-string">"route"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: tlist<span class="org-rainbow-delimiters-depth-1">)</span> printTuple1<span class="org-rainbow-delimiters-depth-1">(</span>t<span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: tdata<span class="org-rainbow-delimiters-depth-1">)</span> printTuple1<span class="org-rainbow-delimiters-depth-1">(</span>t<span class="org-rainbow-delimiters-depth-1">)</span>;
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100 b = x c = C++ <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 200 b = z c = Forth <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -900 b = k c = Lisp <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 66 b = p c = route <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Compiler fails to deduce arguments </span>
&gt;&gt; <span class="org-constant">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, printTuple1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_32</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>for_each<span class="org-warning">'</span>
<span class="org-function-name">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, printTuple1<span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~

&gt;&gt; <span class="org-constant">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, printTuple1&lt;<span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string&gt;<span class="org-rainbow-delimiters-depth-1">)</span>;
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100 b = x c = C++ <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 200 b = z c = Forth <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -900 b = k c = Lisp <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 66 b = p c = route <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt;

&gt;&gt; <span class="org-constant">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>tdata.begin<span class="org-rainbow-delimiters-depth-2">()</span>, tdata.end<span class="org-rainbow-delimiters-depth-2">()</span>, &amp;<span class="org-type">printTuple1</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span>;
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 100 b = x c = C++ <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 200 b = z c = Forth <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = -900 b = k c = Lisp <span class="org-rainbow-delimiters-depth-1">}</span> 
tuple3<span class="org-rainbow-delimiters-depth-1">{</span> a = 66 b = p c = route <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4b19d14" class="outline-3">
<h3 id="org4b19d14"><span class="section-number-3">1.4</span> Non-class template parameters</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-orga48e852" class="outline-4">
<h4 id="orga48e852"><span class="section-number-4">1.4.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
It is possible to use the following kinds of template parameters.
</p>

<ul class="org-ul">
<li>class or typename</li>
<li>Integers</li>
<li>Function pointer</li>
<li>Member function pointer</li>
</ul>
</div>
</div>

<div id="outline-container-org7093ef1" class="outline-4">
<h4 id="org7093ef1"><span class="section-number-4">1.4.2</span> Integer as template parameter</h4>
<div class="outline-text-4" id="text-1-4-2">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">n =&gt; Numeric template argument with default value 3 </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span> = 3, <span class="org-keyword">typename</span> <span class="org-type">Action</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">repeat</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Action</span> <span class="org-variable-name">fn</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = n; i &gt; 0; i--<span class="org-rainbow-delimiters-depth-2">)</span>
       fn<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
This templated function, repeat&lt;n&gt;, generates a different functions
for every different value of n. For instance, it will generate the
functions repeat&lt;1&gt; for n = 1, repeat&lt;3&gt; for n = 3, repeat&lt;10&gt; for n =
10 and so on. It can be tested at <a href="https://godbolt.org/">https://godbolt.org/</a>. 
</p>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; repeat<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">[]{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Repeat n times"</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Repeat <span class="org-type">n</span> <span class="org-variable-name">times</span>

&gt;&gt; repeat<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[]{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Repeat n times"</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> <span class="org-variable-name">times</span>

&gt;&gt; repeat<span class="org-rainbow-delimiters-depth-1">&lt;&gt;(</span><span class="org-rainbow-delimiters-depth-2">[]{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Repeat n times"</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> <span class="org-variable-name">times</span>

&gt;&gt; repeat<span class="org-rainbow-delimiters-depth-1">&lt;</span>5<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">[]{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Repeat n times"</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> times
Repeat <span class="org-type">n</span> <span class="org-variable-name">times</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org2540907" class="outline-4">
<h4 id="org2540907"><span class="section-number-4">1.4.3</span> Function pointer as template parameter</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
Syntax 1: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-function-name">mfunction</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">tabulateFunPTR</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; i
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; mfunction<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Syntax 2: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-function-name">mfunction</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">tabulateFunPTRB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; i
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; mfunction<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Syntax 3: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">It is also possible the following syntax with auto keyword.</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">auto</span> <span class="org-function-name">mfunction</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">tabulateFunPTRC</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; i
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; mfunction<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-text">&gt;&gt; tabulateFunPTR&lt;exp&gt;(4)
    0     1.000
    1     2.718
    2     7.389
    3    20.086

&gt;&gt; tabulateFunPTR&lt;sqrt&gt;(9)
    0     0.000
    1     1.000
    2     1.414
    3     1.732
    4     2.000
    5     2.236
    6     2.449
    7     2.646
    8     2.828

&gt;&gt; tabulateFunPTRB&lt;cbrt&gt;(4)
    0     0.000
    1     1.000
    2     1.260
    3     1.442

&gt;&gt; tabulateFunPTRC&lt;std::exp&gt;(5)
    0     1.000
    1     2.718
    2     7.389
    3    20.086
    4    54.598
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb070df6" class="outline-4">
<h4 id="orgb070df6"><span class="section-number-4">1.4.4</span> Class templates as template parameters</h4>
<div class="outline-text-4" id="text-1-4-4">
<p>
AKA: template template. 
</p>

<p>
<b>Example 1:</b> 
</p>

<p>
Every STL container has two type parameters, the element type and the
allocator type which has the element type as parameter. In the
following code, the type parameter named Container is used for
changing the STL container used by the stack class.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">list</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Type of stack element </span>
     <span class="org-keyword">typename</span> <span class="org-type">Element</span>,
     <span class="org-comment-delimiter">// </span><span class="org-comment">Every STL container has two type parameters Container&lt;Element, Allocator&gt;</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">The allocator has the type parameter Allocator&lt;Element&gt;</span>
     <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span>, <span class="org-keyword">typename</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">Container</span> = <span class="org-constant">std</span>::deque
     <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Element</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Element</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">_stack</span>;
<span class="org-function-name">public</span>:
    <span class="org-type">void</span> <span class="org-function-name">push</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Element</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-2">){</span>
         _stack.push_back<span class="org-rainbow-delimiters-depth-3">(</span>t<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">Element</span> <span class="org-function-name">pop</span><span class="org-rainbow-delimiters-depth-2">(){</span>
         <span class="org-keyword">auto</span> <span class="org-variable-name">x</span> = _stack.back<span class="org-rainbow-delimiters-depth-3">()</span>;
         _stack.pop_back<span class="org-rainbow-delimiters-depth-3">()</span>;
         <span class="org-keyword">return</span> x;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">size_t</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">(){</span>  <span class="org-keyword">return</span> _stack.size<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">bool</span>   <span class="org-function-name">empty</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> _stack.empty<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span>   <span class="org-function-name">clear</span><span class="org-rainbow-delimiters-depth-2">(){</span> _stack.clear<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(){</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" stack: "</span>;
         <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: _stack<span class="org-rainbow-delimiters-depth-3">)</span>
                 <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span> &lt;&lt; x ;
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> s1;
&gt;&gt; s1.push<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>, s1.push<span class="org-rainbow-delimiters-depth-1">(</span>15<span class="org-rainbow-delimiters-depth-1">)</span>, s1.push<span class="org-rainbow-delimiters-depth-1">(</span>25<span class="org-rainbow-delimiters-depth-1">)</span>; s1.print<span class="org-rainbow-delimiters-depth-1">()</span>
 stack:  10 15 25
&gt;&gt; 

&gt;&gt; <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-1">&gt;</span> s2;
&gt;&gt; s2.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"C++"</span><span class="org-rainbow-delimiters-depth-1">)</span>, s2.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"IOT"</span><span class="org-rainbow-delimiters-depth-1">)</span>, s2.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Network"</span><span class="org-rainbow-delimiters-depth-1">)</span>, s2.print<span class="org-rainbow-delimiters-depth-1">()</span>;
 <span class="org-constant">stack</span>:  C++ IOT Network
&gt;&gt; 

&gt;&gt; <span class="org-keyword">auto</span> sn = <span class="org-type">Stack</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::list<span class="org-rainbow-delimiters-depth-1">&gt;{}</span>;
&gt;&gt; sn.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-1">)</span>, sn.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'y'</span><span class="org-rainbow-delimiters-depth-1">)</span>, sn.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'w'</span><span class="org-rainbow-delimiters-depth-1">)</span>, sn.push<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'k'</span><span class="org-rainbow-delimiters-depth-1">)</span>, sn.print<span class="org-rainbow-delimiters-depth-1">()</span>;
 <span class="org-constant">stack</span>:  x y <span class="org-type">w</span> <span class="org-variable-name">k</span>
&gt;&gt; 
</pre>
</div>

<p>
<b>Example 2:</b> Generic higher-order function which can peform a
fold-operation on any STL sequence container.
</p>

<ul class="org-ul">
<li>Version A - Using for-range based loop.</li>
</ul>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>
     <span class="org-keyword">typename</span> <span class="org-type">Acc</span>,
     <span class="org-keyword">typename</span> <span class="org-type">Element</span>,  
     <span class="org-keyword">typename</span> <span class="org-type">Func</span>,
     <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">Allocator</span>,
     <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span>, <span class="org-keyword">typename</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">Container</span>
     <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">Acc</span> <span class="org-function-name">foldContainerA</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Acc</span> <span class="org-variable-name">init</span>, <span class="org-keyword">const</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Element</span>, <span class="org-type">Allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Element</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-type">Func</span> <span class="org-variable-name">func</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-type">Acc</span> <span class="org-variable-name">acc</span> <span class="org-rainbow-delimiters-depth-2">{</span>init<span class="org-rainbow-delimiters-depth-2">}</span>;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: cont<span class="org-rainbow-delimiters-depth-2">)</span> acc = func<span class="org-rainbow-delimiters-depth-2">(</span>acc, x<span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span> acc;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<ul class="org-ul">
<li>Version B - Using iterator based loop</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>
    <span class="org-keyword">typename</span> <span class="org-type">Acc</span>,
    <span class="org-keyword">typename</span> <span class="org-type">Element</span>,   
    <span class="org-keyword">typename</span> <span class="org-type">Func</span>,
    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">Allocator</span>,
    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span>, <span class="org-keyword">typename</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">Container</span>
    <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">Acc</span> <span class="org-function-name">foldContainerB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Acc</span> <span class="org-variable-name">init</span>, <span class="org-keyword">const</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Element</span>, <span class="org-type">Allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Element</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-type">Func</span> <span class="org-variable-name">func</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">Acc</span> <span class="org-variable-name">acc</span> <span class="org-rainbow-delimiters-depth-2">{</span>init<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Dependent name </span>
    <span class="org-keyword">using</span> <span class="org-type">Iterator</span> = <span class="org-keyword">typename</span> <span class="org-constant">Container</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Element</span>, <span class="org-type">Allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Element</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::const_iterator;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Or: typedef typename Container&lt;Element, Allocator&lt;Element&gt;&gt;::const_iterator Iterator;</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Iterator</span> <span class="org-variable-name">it</span> = cont.begin<span class="org-rainbow-delimiters-depth-3">()</span>; it &lt; cont.end<span class="org-rainbow-delimiters-depth-3">()</span>; it++<span class="org-rainbow-delimiters-depth-2">)</span>
            acc = func<span class="org-rainbow-delimiters-depth-2">(</span>acc, *it<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> acc;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> xsa<span class="org-rainbow-delimiters-depth-1">{</span>1, 2, 3, 4, 5, 6<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; foldContainerA<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsa, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">acc</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 10 * acc + x;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 123456
&gt;&gt; 

&gt;&gt; foldContainerB<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsa, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">acc</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 10 * acc + x;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 123456

<span class="org-comment-delimiter">// </span><span class="org-comment">1 + 2 + 3 + 4 + 5 + 6</span>
&gt;&gt; foldContainerA<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsa, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">acc</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> acc + x;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 21

&gt;&gt; foldContainerB<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsa, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">acc</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span>  acc + x;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 21

&gt;&gt; foldContainerA<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsa, <span class="org-constant">std</span>::plus<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 21
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> xsb<span class="org-rainbow-delimiters-depth-1">{</span>1, 2, 3, 4, 5<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; foldContainerA<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>0, xsb, <span class="org-constant">std</span>::plus<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15

&gt;&gt; foldContainerA<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>1, xsb, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 120
&gt;&gt; 

&gt;&gt; foldContainerB<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>1, xsb, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 120


</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org89586b2" class="outline-3">
<h3 id="org89586b2"><span class="section-number-3">1.5</span> Templates and STL Containers</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org437b09b" class="outline-4">
<h4 id="org437b09b"><span class="section-number-4">1.5.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
Templates can be used for writing more generic and resuable code which
operates like functions or STL algorithms on  any type of iterator or
container. 
</p>
</div>
</div>
<div id="outline-container-org6723973" class="outline-4">
<h4 id="org6723973"><span class="section-number-4">1.5.2</span> Example 1 - iterating over containers</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
This example shows how to implement generic code which operates on any
type of container or iterator in modern C++.
</p>

<ul class="org-ul">
<li>File: <a href="src/template-iterator-container.cpp">file:src/template-iterator-container.cpp</a></li>
</ul>

<p>
Code highlights:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">namespace</span> <span class="org-constant">IterUtils</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Iterator</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-type">double</span> <span class="org-function-name">sumContainer</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">begin</span>, <span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-2">){</span>
            <span class="org-type">double</span> <span class="org-variable-name">sum</span> = 0.0;
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Iterator</span> <span class="org-variable-name">it</span> = begin; it != end; ++it<span class="org-rainbow-delimiters-depth-3">)</span>
                sum += *it;
            <span class="org-keyword">return</span> sum;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Sum elements of any type &lt;Container&gt; with methods .begin() and .end()</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">returnign iterators.</span>
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">U</span>, <span class="org-keyword">class</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">sumContainer2</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Container</span>&amp; <span class="org-variable-name">container</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">U</span><span class="org-rainbow-delimiters-depth-2">{</span>
            <span class="org-type">U</span> <span class="org-variable-name">sum</span><span class="org-rainbow-delimiters-depth-3">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Uniform initialization</span>
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = container.begin<span class="org-rainbow-delimiters-depth-4">()</span>; it != container.end<span class="org-rainbow-delimiters-depth-4">()</span>; ++it<span class="org-rainbow-delimiters-depth-3">)</span>
               sum += *it;
            <span class="org-keyword">return</span> sum;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Iterator</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">printContainer</span><span class="org-rainbow-delimiters-depth-2">(</span>
                <span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">begin</span>,
                <span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp; <span class="org-variable-name">end</span>,
                <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">sep</span> = <span class="org-string">", "</span> <span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Iterator</span> <span class="org-variable-name">it</span> = begin; it != end; ++it<span class="org-rainbow-delimiters-depth-3">)</span>
                        <span class="org-constant">std</span>::cout &lt;&lt;  *it &lt;&lt; sep;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">printContainer2</span><span class="org-rainbow-delimiters-depth-2">(</span>
                  <span class="org-keyword">const</span> <span class="org-type">Container</span>&amp; <span class="org-variable-name">cont</span>
                 ,<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">sep</span> = <span class="org-string">", "</span>
                <span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
           <span class="org-comment-delimiter">// </span><span class="org-comment">C++11 For-range based loop</span>
           <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: cont<span class="org-rainbow-delimiters-depth-3">)</span>
                   <span class="org-constant">std</span>::cout &lt;&lt;  x &lt;&lt; sep;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Higher order function</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">The parameter actions accepts any type which can be called like</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">a function returning void.</span>
        <span class="org-comment-delimiter">//</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Note: It doesn't matter as it is possible to use both class T or typename T.</span>
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Container</span>, <span class="org-keyword">typename</span> <span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">for_each</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Container</span> <span class="org-variable-name">cont</span>, <span class="org-type">Function</span> <span class="org-variable-name">action</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: cont<span class="org-rainbow-delimiters-depth-3">)</span> action<span class="org-rainbow-delimiters-depth-3">(</span>x<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">----- End of namespace IterUtils ----- //</span>
</pre>
</div>

<p>
Program output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ template-iterator-container.cpp -o <span class="org-keyword">template-iterator-container.bin</span> -g -std=c++11 -Wall -Wextra 
$ ./template-iterator-container.bin

=========== Experiment 1 - sumContainer
<span class="org-function-name">template-iterator-container.cpp</span>:95: ; iu::sumContainer(&amp;carray[0], &amp;carray[0] + arrsize) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:96: ; iu::sumContainer(vec1.begin(), vec1.end()) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:97: ; iu::sumContainer(list1.begin(), list1.end()) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:98: ; iu::sumContainer(deque1.begin(), deque1.end()) = 16

=========== Experiment 2 - sumContainer2 
<span class="org-function-name">template-iterator-container.cpp</span>:101: ; iu::sumContainer2&lt;double&gt;(vec1) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:102: ; iu::sumContainer2&lt;int&gt;(vec1) = 15
<span class="org-function-name">template-iterator-container.cpp</span>:103: ; iu::sumContainer2&lt;double&gt;(list1) = 16
<span class="org-function-name">template-iterator-container.cpp</span>:104: ; iu::sumContainer2&lt;int&gt;(list2) = 114

=========== Experiment 3 - printContainer 

Contents of carray  = 1, 2, 4.5, 2.5, 6, 
Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
Contents of vec2  = c++, templates, awesome, binary, 
Contents of list1 = 1, 2, 4.5, 2.5, 6, 

=========== Experiment 4 - printContainer2 

Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
Contents of vec2  = c++, templates, awesome, binary, 
Contents of list1 = 1, 2, 4.5, 2.5, 6, 

=========== Experiment 5 - for_each higher order <span class="org-keyword">function</span> 

Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
Contents of vec2  = c++, templates, awesome, binary, c++, templates, awesome, binary, 
Contents of m1  = 
  earth-gravity     9.810
          euler     2.718
             pi     3.142
              x     2.345

</pre>
</div>
</div>
</div>
<div id="outline-container-org8faeeef" class="outline-4">
<h4 id="org8faeeef"><span class="section-number-4">1.5.3</span> Example 2 - print any sequential container (typename)</h4>
<div class="outline-text-4" id="text-1-5-3">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printContents</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Container</span>&amp; <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Dependent type declaration </span>
     <span class="org-keyword">typename</span> <span class="org-constant">Container</span>::<span class="org-type">iterator</span> <span class="org-variable-name">i</span>;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span>i = c.begin<span class="org-rainbow-delimiters-depth-3">()</span>; i != c.end<span class="org-rainbow-delimiters-depth-3">()</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
             <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span> &lt;&lt; *i &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> xs<span class="org-rainbow-delimiters-depth-1">{</span>10.23, -24.23, 25.2, 100.34<span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">list</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> ds<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"hello world"</span>, <span class="org-string">"C++"</span>, <span class="org-string">"HPC"</span>, <span class="org-string">"processor"</span><span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; 
&gt;&gt; printContents<span class="org-rainbow-delimiters-depth-1">(</span>xs<span class="org-rainbow-delimiters-depth-1">)</span>
 10.23
 -24.23
 25.2
 100.34

&gt;&gt; printContents<span class="org-rainbow-delimiters-depth-1">(</span>ds<span class="org-rainbow-delimiters-depth-1">)</span>
 hello <span class="org-type">world</span>
 <span class="org-variable-name">C</span>++
 HPC
 processor
</pre>
</div>
</div>
</div>
<div id="outline-container-orge6f666c" class="outline-4">
<h4 id="orge6f666c"><span class="section-number-4">1.5.4</span> Example 3 - print map container</h4>
<div class="outline-text-4" id="text-1-5-4">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">KEY</span>, <span class="org-keyword">typename</span> <span class="org-type">VALUE</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printMap</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">KEY</span>, <span class="org-type">VALUE</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">mp</span>, <span class="org-type">int</span> <span class="org-variable-name">w1</span> = 10, <span class="org-type">int</span> <span class="org-variable-name">w2</span> = 10<span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">typename</span> <span class="org-constant">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">KEY</span>, <span class="org-type">VALUE</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">iterator</span> <span class="org-variable-name">it</span>;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span>it = mp.begin<span class="org-rainbow-delimiters-depth-3">()</span>; it != mp.end<span class="org-rainbow-delimiters-depth-3">()</span>; it++<span class="org-rainbow-delimiters-depth-2">)</span>
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w1<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; it-&gt;first
                    &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; it-&gt;second 
                    &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Or, using for-range based loop: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">KEY</span>, <span class="org-keyword">typename</span> <span class="org-type">VALUE</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printMap2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">KEY</span>, <span class="org-type">VALUE</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">mp</span>, <span class="org-type">int</span> <span class="org-variable-name">w1</span> = 10, <span class="org-type">int</span> <span class="org-variable-name">w2</span> = 10<span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">p</span>: mp<span class="org-rainbow-delimiters-depth-2">)</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w1<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; p.first
                   &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; p.second 
                   &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> m1 <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"x"</span>, 200<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"y"</span>, 1000<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"z"</span>, 3400<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; printMap<span class="org-rainbow-delimiters-depth-1">(</span>m1<span class="org-rainbow-delimiters-depth-1">)</span>
         x       200
         y      1000
         z      3400

&gt;&gt; printMap2<span class="org-rainbow-delimiters-depth-1">(</span>m1<span class="org-rainbow-delimiters-depth-1">)</span>
         x       200
         y      1000
         z      3400

&gt;&gt; <span class="org-keyword">auto</span> m2 = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-rainbow-delimiters-depth-2">{</span>100, <span class="org-string">"Argentina"</span><span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span>900, <span class="org-string">"Colombia"</span><span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span>80, <span class="org-string">"Brazil"</span><span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span>600, <span class="org-string">"Chile"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; printMap<span class="org-rainbow-delimiters-depth-1">(</span>m2<span class="org-rainbow-delimiters-depth-1">)</span>
        80    Brazil
       100 Argentina
       600     Chile
       900  Colombia
</pre>
</div>
</div>
</div>
<div id="outline-container-org8bf0be2" class="outline-4">
<h4 id="org8bf0be2"><span class="section-number-4">1.5.5</span> Example 4 - print any associative container</h4>
<div class="outline-text-4" id="text-1-5-5">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Container</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printAssoc</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Container</span>&amp; <span class="org-variable-name">mp</span>, <span class="org-type">int</span> <span class="org-variable-name">w1</span> = 10, <span class="org-type">int</span> <span class="org-variable-name">w2</span> = 10<span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">it</span> : mp<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w1<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; it.first
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>w2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; it.second 
                  &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">m1a</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"x"</span>, 200<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"y"</span>, 1000<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"z"</span>, 3400<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">m2a</span> = <span class="org-constant">std</span>::<span class="org-type">unordered_map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"x"</span>, 200<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"y"</span>, 1000<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"z"</span>, 3400<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;

 &gt;&gt; printAssoc<span class="org-rainbow-delimiters-depth-1">(</span>m1a<span class="org-rainbow-delimiters-depth-1">)</span>
          x       200
          y      1000
          z      3400

 &gt;&gt; printAssoc<span class="org-rainbow-delimiters-depth-1">(</span>m2a<span class="org-rainbow-delimiters-depth-1">)</span>
          z      3400
          y      1000
          x       200
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga14c3f4" class="outline-3">
<h3 id="orga14c3f4"><span class="section-number-3">1.6</span> Templates with Ranges</h3>
<div class="outline-text-3" id="text-1-6">
<p>
<b>Example 1:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Range</span>, <span class="org-keyword">class</span> <span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">forEachRange</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Range</span>&amp; <span class="org-variable-name">range</span>, <span class="org-type">Function</span> <span class="org-variable-name">func</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: range<span class="org-rainbow-delimiters-depth-2">)</span> func<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">xs</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>1, 2, 3, 4, 5, 6, 7<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; forEachRange<span class="org-rainbow-delimiters-depth-1">(</span>xs, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" x = "</span> &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 x = 1
 x = 2
 x = 3
 x = 4
 x = 5
 x = 6
 x = 7

 &gt;&gt; <span class="org-keyword">auto</span> list = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;{</span> <span class="org-string">"c++"</span>, <span class="org-string">"asm"</span>, <span class="org-string">"rust"</span>, <span class="org-string">"DLang"</span><span class="org-rainbow-delimiters-depth-1">}</span>;

 &gt;&gt; forEachRange<span class="org-rainbow-delimiters-depth-1">(</span>::list, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> 
                              <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; "</span> &lt;&lt; x &lt;&lt; st =&gt; c++; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
  =&gt; <span class="org-keyword">asm</span>
  =&gt; rust
  =&gt; DLang
</pre>
</div>

<p>
<b>Example 2:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Range</span>, <span class="org-keyword">class</span> <span class="org-type">Acc</span>, <span class="org-keyword">class</span> <span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">Acc</span> <span class="org-function-name">foldRange</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Range</span>&amp; <span class="org-variable-name">range</span>, <span class="org-keyword">const</span> <span class="org-type">Acc</span>&amp; <span class="org-variable-name">init</span>, <span class="org-type">Function</span> <span class="org-variable-name">func</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">acc</span> = init;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: range<span class="org-rainbow-delimiters-depth-2">)</span> acc = func<span class="org-rainbow-delimiters-depth-2">(</span>acc, x<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> acc;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">//</span><span class="org-comment">---------- std::vector --------------//</span>

&gt;&gt; <span class="org-keyword">auto</span> xs = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>1, 2, 3, 4, 5, 6, 7<span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; 1 + 2 + 3 + 4 + 5 + 6 + 7
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 28
&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>xs, 0, <span class="org-constant">std</span>::plus<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 28

&gt;&gt; 1 * 2 * 3 * 4 * 5 * 6 * 7
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 5040
&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>xs, 1, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 5040

&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>xs, 0, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">acc</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 10 * acc + x; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 1234567
&gt;&gt; 

<span class="org-comment-delimiter">//</span><span class="org-comment">---------- std::deque -------------------//</span>

&gt;&gt; <span class="org-keyword">auto</span> ys = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>1, 2, 3, 4, 5, 6, 7<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>ys, 0, <span class="org-constant">std</span>::plus<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 28

&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>ys, 1, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 5040
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">------------- std::set -----------------//</span>

&gt;&gt; <span class="org-keyword">auto</span> zs = <span class="org-constant">std</span>::<span class="org-type">set</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>1, 2, 3, 4, 5, 6, 7<span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; 
&gt;&gt; foldRange<span class="org-rainbow-delimiters-depth-1">(</span>zs, 1, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 5040
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-orga8631a4" class="outline-3">
<h3 id="orga8631a4"><a id="ID-80f3766a-39eb-47ef-a3f5-5a49ef183db0"></a><span class="section-number-3">1.7</span> Basic Template Specialization</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Code example showing template specialization. As the code shows, the
template specilization can be used for type introspection, type
identification and implement reflection.
</p>

<ul class="org-ul">
<li>File: <a href="src/template-specialization1.cpp">file:src/template-specialization1.cpp</a></li>
<li>Online compiler: <a href="http://rextester.com/BKG53705">http://rextester.com/BKG53705</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>    <span class="org-comment-delimiter">// </span><span class="org-comment">Stream manipulator std::fixed, std::setw ... </span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>      <span class="org-comment-delimiter">// </span><span class="org-comment">sin, cos, tan, exp ... M_PI, M_E ...</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">std::function </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 1 ===============================//</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Check whether type is float point </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">isFPNumber</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-constant">false</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Template specialization of isFPNumber for type float</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">auto</span> <span class="org-function-name">isFPNumber</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-constant">true</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Template specialization of isFPNumber for type double </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">auto</span> <span class="org-function-name">isFPNumber</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-constant">true</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 2 - Template specialization for runtime type identification ====//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: this technique can be used for implemeting custom C++ reflection </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Return name of a given type </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Type</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">TypeName</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> <span class="org-string">"unknown"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-preprocessor">#define</span> <span class="org-function-name">REGISTER_TYPE</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">type</span><span class="org-rainbow-delimiters-depth-1">)</span>  <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> \
        <span class="org-keyword">auto</span> <span class="org-variable-name">TypeName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>type<span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> #type; <span class="org-rainbow-delimiters-depth-1">}</span> 

<span class="org-comment-delimiter">// </span><span class="org-comment">Specialization for int type </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">TypeName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> <span class="org-string">"int"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Automate boilerplate code using macros.</span>
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span>;
REGISTER_TYPE<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">long</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 3 - Template with int argument specialization ===//</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-keyword">return</span> <span class="org-string">"I down't known"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"zero"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"one"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>2<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"two"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getNumberName</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>3<span class="org-rainbow-delimiters-depth-1">&gt;(){</span> <span class="org-keyword">return</span> <span class="org-string">"three"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 4 - Template with bool argument specialization ====//</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">boolTemplate</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">boolTemplate</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">"false"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">boolTemplate</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-string">"true"</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">============= Example 5 - Check whether types are equal ====//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Partial template specialization </span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span>, <span class="org-keyword">class</span> <span class="org-type">B</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">type_equal</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">enum</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-variable-name">value</span> = 0 <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Partial specialisation</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">type_equal</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">A</span>, <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
        <span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">enum</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-variable-name">value</span> = 1<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
      <span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">nl</span> = <span class="org-string">'\n'</span>;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;

      <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 1 - Check whether type is float pointer"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;    
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;int&gt;    ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;char&gt;   ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;float&gt;  ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"is float point type&lt;double&gt; ? = "</span> &lt;&lt; isFPNumber<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;

      <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 2 - Type introspection"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;    
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; TypeName<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;  

      <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 3 - Templates with integers as arguments"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;0&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>0<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;1&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>1<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;2&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>2<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;10&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>10<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getNumberName&lt;14&gt;() = "</span> &lt;&lt; getNumberName<span class="org-rainbow-delimiters-depth-2">&lt;</span>14<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; nl;

      <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"EXPERIMENT 4 - Templates with bool as arguments"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"--------------------------------------------"</span> &lt;&lt; nl;    
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"boolTemplate&lt;false&gt;::getName&gt;()  = "</span> &lt;&lt; <span class="org-constant">boolTemplate</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"boolTemplate&lt;true&gt;::getName&gt;()   = "</span> &lt;&lt; <span class="org-constant">boolTemplate</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;

      <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"Check whether types are equal"</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;int, char&gt;::get()       = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;  
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;char, double&gt;::get()    = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;double, double&gt;::get()  = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type_equal&lt;int, int&gt;::get()        = "</span>  &lt;&lt; <span class="org-constant">type_equal</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; nl;

      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type_equal&lt;<span class="org-type">int</span>, <span class="org-type">double</span>&gt;::value<span class="org-rainbow-delimiters-depth-2">)</span>
           <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[1] Types are equal\n"</span>;
      <span class="org-keyword">else</span>
           <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[1] Types are not equal\n"</span>;

      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type_equal&lt;<span class="org-type">double</span>, <span class="org-type">double</span>&gt;::value<span class="org-rainbow-delimiters-depth-2">)</span>
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[2] Types are equal\n"</span>;
      <span class="org-keyword">else</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[2] Types are not equal\n"</span>;
        <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Program output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ template-specialization1.cpp -o <span class="org-keyword">template-specialization1.bin</span> -g -std=c++11 -Wall -Wextra 
$ ./template-specialization1.bin

EXPERIMENT 1 - Check whether type is float pointer
--------------------------------------------
is float point type&lt;int&gt;    ? = false
is float point type&lt;char&gt;   ? = false
is float point type&lt;float&gt;  ? = true
is float point type&lt;double&gt; ? = true

EXPERIMENT 2 - Type introspection
--------------------------------------------
<span class="org-builtin">type</span> = int
<span class="org-builtin">type</span> = char
<span class="org-builtin">type</span> = float
<span class="org-builtin">type</span> = const char*
<span class="org-builtin">type</span> = std::string

EXPERIMENT 3 - Templates with integers as arguments
--------------------------------------------
getNumberName&lt;0&gt;() = zero
getNumberName&lt;1&gt;() = one
getNumberName&lt;2&gt;() = two
getNumberName&lt;10&gt;() = I down<span class="org-string">'t known</span>
<span class="org-string">getNumberName&lt;14&gt;() = I down'</span>t known

EXPERIMENT 4 - Templates with bool as arguments
--------------------------------------------
boolTemplate&lt;false&gt;::getName&gt;()  = false
boolTemplate&lt;true&gt;::getName&gt;()   = true

Check whether types are equal
type_equal&lt;int, char&gt;::get()       = false
type_equal&lt;char, double&gt;::get()    = false
type_equal&lt;double, double&gt;::get()  = true
type_equal&lt;int, int&gt;::get()        = true
[1] Types are not equal
[2] Types are equal
</pre>
</div>
</div>
</div>
<div id="outline-container-org4c54f6a" class="outline-3">
<h3 id="org4c54f6a"><span class="section-number-3">1.8</span> Template Type Alias - 'using'</h3>
<div class="outline-text-3" id="text-1-8">
<p>
In addition to be useful for creating type alias, the keyword "using"
can also be used for defining template type alias or parametrized type
alias. 
</p>

<p>
Example: 
</p>

<p>
Type synonym: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">using</span> <span class="org-type">Action</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>T <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">doTimes</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">Action</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">action</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" i = 0; x = "</span> &lt;&lt; action<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; doTimes<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>3, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 3.0 * i + 4.5; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 i = 0; x = 4.5
 i = 0; x = 7.5
 i = 0; x = 10.5
&gt;&gt; 

&gt;&gt; doTimes<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>6, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 65 + i; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 i = 0; x = A
 i = 0; x = B
 i = 0; x = C
 i = 0; x = D
 i = 0; x = E
 i = 0; x = F
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org7e9ab13" class="outline-3">
<h3 id="org7e9ab13"><span class="section-number-3">1.9</span> Templates with default arguments</h3>
<div class="outline-text-3" id="text-1-9">
<p>
Example: Array allocated on the stack memory.
</p>

<ul class="org-ul">
<li>File: default-template-args.C</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">ostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-comment-delimiter">// </span><span class="org-comment">Array allocated on stack with size 10.</span>
<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Element</span>, <span class="org-type">size_t</span> <span class="org-variable-name">Size</span> = 10<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">Array</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
        <span class="org-type">Element</span> <span class="org-variable-name">m_data</span> <span class="org-rainbow-delimiters-depth-2">[</span>Size<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="org-function-name">public</span>:
   <span class="org-keyword">auto</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-type">size_t</span> <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> Size;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">auto</span> <span class="org-function-name">fill</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Element</span>&amp; <span class="org-variable-name">t</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; Size; i++<span class="org-rainbow-delimiters-depth-3">)</span>
           m_data<span class="org-rainbow-delimiters-depth-3">[</span>i<span class="org-rainbow-delimiters-depth-3">]</span> = t;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">auto</span> <span class="org-keyword">operator</span> <span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">[]</span></span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">index</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; Element&amp; <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> m_data<span class="org-rainbow-delimiters-depth-3">[</span>index<span class="org-rainbow-delimiters-depth-3">]</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">auto</span> <span class="org-function-name">begin</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">auto</span> <span class="org-function-name">end</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>m_data<span class="org-rainbow-delimiters-depth-3">)</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">auto</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span> = <span class="org-constant">std</span>::cout<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">{</span>
       os &lt;&lt; name &lt;&lt; <span class="org-string">" = "</span>;
       <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: *<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>
          os &lt;&lt; x &lt;&lt; <span class="org-string">" "</span> &lt;&lt; <span class="org-constant">std</span>::flush;
       os &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">void</span> <span class="org-function-name">default_template_args</span><span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-type">Array</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">s1</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"s1.size() = "</span> &lt;&lt; s1.size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
     s1.fill<span class="org-rainbow-delimiters-depth-2">(</span>3.0<span class="org-rainbow-delimiters-depth-2">)</span>;
     s1<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> = 8.23;
     s1<span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-rainbow-delimiters-depth-2">]</span> = -10.2;
     s1<span class="org-rainbow-delimiters-depth-2">[</span>3<span class="org-rainbow-delimiters-depth-2">]</span> = 0.0;
     s1.print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"s1"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

     <span class="org-type">Array</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, 4<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">s2</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"s2.size() = "</span> &lt;&lt; s2.size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
     s2.fill<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"C++"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     s2.print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"s2"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     s2<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"PlusPlus"</span>;
     s2<span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"CPP"</span>;
     s2<span class="org-rainbow-delimiters-depth-2">[</span>2<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"ASM"</span>;
     s2.print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"s2"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running on CLING REPL:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .X <span class="org-keyword">default</span>-<span class="org-keyword">template</span>-args.C 
s1.size<span class="org-rainbow-delimiters-depth-1">()</span> = 10
s1 = 8.23 -10.2 3 0 3 3 3 3 3 3 
s2.size<span class="org-rainbow-delimiters-depth-1">()</span> = 4
s2 = C++ C++ C++ C++ 
s2 = PlusPlus CPP ASM C++ 
</pre>
</div>
</div>
</div>
<div id="outline-container-orge023348" class="outline-3">
<h3 id="orge023348"><a id="ID-20156a12-aa32-407d-8cc0-5c4b85ba9021"></a><span class="section-number-3">1.10</span> Implementing Higher Order Functions with templates</h3>
<div class="outline-text-3" id="text-1-10">
<ul class="org-ul">
<li>File: <a href="src/template-hof1.cpp">file:src/template-hof1.cpp</a></li>
<li>Online Compiler: <a href="https://rextester.com/ZAT8950">https://rextester.com/ZAT8950</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/**   </span><span class="org-comment">File:     template-hof1.cpp </span>
<span class="org-comment">  *  Brief:    Shows how to implement template higher order functions which operates on containers.</span>
<span class="org-comment">  *  Features: Template metaprogramming, C++11, functional programming and STL.</span>
<span class="org-comment">  ****************************************************************************/</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">list</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Apply a function to every element of a container */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">ELEM</span>, <span class="org-keyword">class</span> <span class="org-type">ALLOC</span>, <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span>, <span class="org-keyword">class</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">CONTAINER</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">forRange1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">CONTAINER</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">ELEM</span>, <span class="org-type">ALLOC</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">ELEM</span>&amp;<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">fn</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">i</span> =  <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i != <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
       fn<span class="org-rainbow-delimiters-depth-2">(</span>*i<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Apply a function to every element of a container */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">CONTAINER</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">forRange2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">CONTAINER</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-4">(</span>cont.front<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">fn</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">i</span> =  <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i != <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
       fn<span class="org-rainbow-delimiters-depth-2">(</span>*i<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Template for folding over a container in a similar way to the higher order function fold. </span>
<span class="org-comment"> * Note: </span>
<span class="org-comment"> * + CONTAINER parameter accepts any argument which has .begin() and .end() methods </span>
<span class="org-comment"> *   returning iterators. </span>
<span class="org-comment"> * + STEPFN type parameters accepts any function-object, function pointer or lambda </span>
<span class="org-comment"> *   whith the following signature: (ACC, X) =&gt; ACC where ACC is the accumulator type </span>
<span class="org-comment"> *   and X is the type of the container element. </span>
<span class="org-comment"> */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">CONTAINER</span>, <span class="org-keyword">class</span> <span class="org-type">ACC</span>, <span class="org-keyword">class</span> <span class="org-type">STEPFN</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">foldRange</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">CONTAINER</span>&amp; <span class="org-variable-name">cont</span>, <span class="org-keyword">const</span> <span class="org-type">ACC</span>&amp; <span class="org-variable-name">init</span>, <span class="org-type">STEPFN</span> <span class="org-variable-name">fn</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">ACC</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-type">ACC</span> <span class="org-variable-name">acc</span><span class="org-rainbow-delimiters-depth-2">{</span>init<span class="org-rainbow-delimiters-depth-2">}</span>;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">i</span> =  <span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i != <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-3">(</span>cont<span class="org-rainbow-delimiters-depth-3">)</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
        acc = fn<span class="org-rainbow-delimiters-depth-2">(</span>*i, acc<span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span> acc;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-constant">std</span>::<span class="org-constant">ios_base</span>::sync_with_stdio<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">vec</span><span class="org-rainbow-delimiters-depth-2">{</span>1, 2, 400, 100<span class="org-rainbow-delimiters-depth-2">}</span>;
        <span class="org-constant">std</span>::<span class="org-type">list</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>   <span class="org-variable-name">lst</span><span class="org-rainbow-delimiters-depth-2">{</span>1, 2, 400, 100<span class="org-rainbow-delimiters-depth-2">}</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Requires template argument </span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"===== EXPERIMENT 1 =================\n"</span>;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - Vector"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange1<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>vec, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - List"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange1<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>lst, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Doesn't require the template argument as the compiler can infer its type.</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"===== EXPERIMENT 2 =================\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - Vector"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange2<span class="org-rainbow-delimiters-depth-2">(</span>vec, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"forRange1 - list"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        forRange2<span class="org-rainbow-delimiters-depth-2">(</span>lst, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-4">(</span>5<span class="org-rainbow-delimiters-depth-4">)</span> &lt;&lt; x &lt;&lt; <span class="org-string">" "</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"===== EXPERIMENT 3 =================\n"</span>;
        <span class="org-type">int</span> <span class="org-variable-name">result1</span> = foldRange<span class="org-rainbow-delimiters-depth-2">(</span>vec, 0, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">acc</span><span class="org-rainbow-delimiters-depth-3">){</span>
                                                <span class="org-keyword">return</span> x + acc;
                                          <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;   
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"sum(vec1) = "</span> &lt;&lt; result1 &lt;&lt; <span class="org-string">"\n"</span> ;
        <span class="org-type">int</span> <span class="org-variable-name">result2</span> = foldRange<span class="org-rainbow-delimiters-depth-2">(</span>lst, 0, <span class="org-constant">std</span>::plus<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span><span class="org-rainbow-delimiters-depth-2">)</span>;  
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"sum(lst) = "</span> &lt;&lt; result2 &lt;&lt; <span class="org-string">"\n"</span> ;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"product(lst) = "</span> &lt;&lt; foldRange<span class="org-rainbow-delimiters-depth-2">(</span>lst, 1, <span class="org-constant">std</span>::multiplies<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span> ;
        <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">clang++ template-hof1.cpp -o <span class="org-keyword">template-hof1.bin</span> -g -std=c++11 -Wall -Wextra &amp;&amp; ./template-hof1.bin
===== EXPERIMENT 1 =================
forRange1 - Vector
    1     2   400   100 
forRange1 - List
    1     2   400   100 
===== EXPERIMENT 2 =================
forRange1 - Vector
    1     2   400   100 
forRange1 - list
    1     2   400   100 
===== EXPERIMENT 3 =================
<span class="org-function-name">sum</span>(vec1) = 503
<span class="org-function-name">sum</span>(lst) = 503
<span class="org-function-name">product</span>(lst) = 80000
</pre>
</div>
</div>
</div>
<div id="outline-container-orgae456df" class="outline-3">
<h3 id="orgae456df"><span class="section-number-3">1.11</span> Metafunctions or type traits</h3>
<div class="outline-text-3" id="text-1-11">
</div>
<div id="outline-container-orgf023608" class="outline-4">
<h4 id="orgf023608"><span class="section-number-4">1.11.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-11-1">
<p>
Metafunction (aka type traits) is a template metaprogramming technique
for type introspection, type manipulation and type computation. This
idiom uses templates, template specialization, structs (classes with
everything public) and constexpr in C++11.
</p>

<p>
This section contains examples about template metafunctions. For more
information about this subject and further reading, see: 
</p>
<ul class="org-ul">
<li><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Metafunction">More C++ Idioms/Metafunction - Wikibooks, open books for an open world</a></li>
<li><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Type_Generator">More C++ Idioms/Type Generator - Wikibooks, open books for an open world</a></li>
<li><a href="https://akrzemi1.wordpress.com/2012/03/19/meta-functions-in-c11/">Meta-functions in C++11 | Andrzej's C++ blog</a></li>
<li><a href="https://accu.org/index.php/journals/442">ACCU - An introduction to C++ Traits</a></li>
</ul>


<p>
A meta function has the forms: 
</p>

<ul class="org-ul">
<li>Meta function which returns type.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Doesn't matter using typename T1, typename T2</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">or using class T1, class T2 ..</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
    <span class="org-keyword">using</span> <span class="org-type">type</span> = ... ;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T1</span>, <span class="org-keyword">typename</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
    <span class="org-keyword">using</span> <span class="org-type">type</span> = ... ;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11 </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">typedef</span> ... ... <span class="org-type">type</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Usage: </span>
<span class="org-keyword">using</span> <span class="org-type">type_synonym</span> =  <span class="org-constant">meta_function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T1</span>, <span class="org-type">T2</span>, ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>::type ;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or in before C++11</span>
<span class="org-keyword">typedef</span>  <span class="org-constant">meta_function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T1</span>, <span class="org-type">T2</span>, ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span> <span class="org-type">type_synonym</span>;
</pre>
</div>

<ul class="org-ul">
<li>Meta function which returns value.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">At least C++11</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Requires at aleast C++11</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">TYPE</span> <span class="org-variable-name">value</span> = ... 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T1</span>, <span class="org-keyword">class</span> <span class="org-type">T2</span> ...<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">meta_function</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Requires at aleast C++11</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Meta function which returns type </span>
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">TYPE</span> <span class="org-variable-name">value</span> = ... 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Usage:</span>
<span class="org-type">TYPE</span> <span class="org-variable-name">result</span> = <span class="org-constant">meta_function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T1</span>, <span class="org-type">T2</span>, ..<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value;
</pre>
</div>

<p>
Further References: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/header/type_traits">Standard library header &lt;type_traits&gt; - cppreference.com</a></li>
<li><a href="https://www.youtube.com/watch?v=eVtLOHoDbTo">Type Traits - CopperSpice video</a></li>
</ul>
</div>
</div>

<div id="outline-container-org342ce32" class="outline-4">
<h4 id="org342ce32"><span class="section-number-4">1.11.2</span> Example</h4>
<div class="outline-text-4" id="text-1-11-2">
<p>
<b>Example</b>
</p>

<p>
Example in:
</p>
<ul class="org-ul">
<li>file:            <a href="src/template-metafunction.cpp">file:src/template-metafunction.cpp</a></li>
<li>Online compiler: <a href="http://rextester.com/TAT89158">http://rextester.com/TAT89158</a></li>
<li>The code in the example demonstrates how to query types using
template specialization, catalog type information and display the
user as well.</li>
</ul>

<p>
Highlights: 
</p>

<ul class="org-ul">
<li>The <b>metafunction isPointer</b> checks whether a given type is a
pointer.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">isPointer</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">value</span> = <span class="org-constant">false</span>;
    <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span>*<span class="org-rainbow-delimiters-depth-1">&gt;{</span>
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">value</span> = <span class="org-constant">true</span>;
    <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Sample usage:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;short*&gt;::value  = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">short</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;short&gt;::value   = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">short</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;double&gt;::value  = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"isPointer&lt;double*&gt;::value = "</span> &lt;&lt; <span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">isPointer&lt;short*&gt;::value  = true
isPointer&lt;short&gt;::value   = false
isPointer&lt;double&gt;::value  = false
isPointer&lt;double*&gt;::value = true
</pre>
</div>

<ul class="org-ul">
<li>The <b>meta function removePointer</b> turns any pointer type into a
non-pointer type removing the star operator.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Partial specilization</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">removePointer</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">typedef</span> <span class="org-type">T</span> <span class="org-type">type</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">removePointer</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span>*<span class="org-rainbow-delimiters-depth-1">&gt;{</span>
    <span class="org-keyword">typedef</span> <span class="org-type">T</span> <span class="org-type">type</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">disp<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">removePointer</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::name<span class="org-rainbow-delimiters-depth-1">)</span>;
disp<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">removePointer</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-3">&gt;</span>::type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::name<span class="org-rainbow-delimiters-depth-1">)</span>;
disp<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">removePointer</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-3">&gt;</span>::type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::name<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">template-metafunction.cpp:175: ; Typeinfo&lt;removePointer&lt;double&gt;::type&gt;::name = double
template-metafunction.cpp:176: ; Typeinfo&lt;removePointer&lt;double*&gt;::type&gt;::name = double
template-metafunction.cpp:177: ; Typeinfo&lt;removePointer&lt;const char*&gt;::type&gt;::name = const char
</pre>
</div>

<ul class="org-ul">
<li><b>The metafunction Typeinfo</b> computes basic information about types at
compile-time. As this "metafunction" relies on template
specialization, it requires defining template specialization for
all supported types what can be cumbersome. In order to avoid the
specialization boilerplate code, the macro <code>REGISTER_TYPE_INFO</code> is
used to register the supported types.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>   = <span class="org-string">"unknown"</span>;
     <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">size_t</span>      <span class="org-variable-name">size</span>   = <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isNumber</span>   = <span class="org-constant">false</span>;
     <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isPointer</span> = ::<span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value;
     <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isConst</span>    = ::<span class="org-constant">isConst</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value;     
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Macro for type registration </span>
<span class="org-preprocessor">#define</span> <span class="org-function-name">REGISTER_TYPE_INFO</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">type</span>, <span class="org-variable-name">isNumberFlag</span><span class="org-rainbow-delimiters-depth-1">)</span> \
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>type<span class="org-rainbow-delimiters-depth-1">&gt;{</span> \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>       = #type; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">size_t</span>      <span class="org-variable-name">size</span>       = <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>type<span class="org-rainbow-delimiters-depth-2">)</span>; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isNumber</span>   = isNumberFlag; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isPointer</span>  = ::<span class="org-constant">isPointer</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::value; \
                <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">bool</span>        <span class="org-variable-name">isConst</span>    = ::<span class="org-constant">isConst</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>type<span class="org-rainbow-delimiters-depth-2">&gt;</span>::value;   \
        <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-comment-delimiter">// </span><span class="org-comment">Type registration </span>
 REGISTER_TYPE_INFO<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span>, <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 REGISTER_TYPE_INFO<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span>, <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Usage example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"Type info for "</span> &lt;&lt; <span class="org-type">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>&gt;::name 
          &lt;&lt; <span class="org-string">" size = "</span> &lt;&lt; <span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::size 
          &lt;&lt; <span class="org-string">" isPointer = "</span> &lt;&lt; <span class="org-constant">Typeinfo</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::isPointer 
          &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>


<p>
<b>Complete Program output:</b> (<a href="src/template-metafunction.cpp">file:src/template-metafunction.cpp</a>)
</p>

<div class="org-src-container">
<pre class="src src-text">$ clang++ template-metafunction.cpp -o template-metafunction.bin -g -std=c++11 -Wall -Wextra  
./template-metafunction.bin

isPointerOLD&lt;short*&gt;::value  = 1
isPointerOLD&lt;short&gt;::value   = 0
isPointerOLD&lt;double&gt;::value  = 0
isPointerOLD&lt;double*&gt;::value = 1
isPointer&lt;short*&gt;::value  = true
isPointer&lt;short&gt;::value   = false
isPointer&lt;double&gt;::value  = false
isPointer&lt;double*&gt;::value = true
isPointer&lt;short*&gt;()()  = true
isPointer&lt;short&gt;()()   = false
isPointer&lt;double&gt;()()  = false
isPointer&lt;double*&gt;()() = true
Type Info: name =            bool ; bytes =    1 ; isNumber = false ; isPointer = false ; isConst = false
Type Info: name =            char ; bytes =    1 ; isNumber = false ; isPointer = false ; isConst = false
Type Info: name =     std::string ; bytes =   32 ; isNumber = false ; isPointer = false ; isConst = false
Type Info: name =             int ; bytes =    4 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =           short ; bytes =    2 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =           float ; bytes =    4 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =          double ; bytes =    8 ; isNumber =  true ; isPointer = false ; isConst = false
Type Info: name =     const char* ; bytes =    8 ; isNumber =  true ; isPointer =  true ; isConst =  true
Type Info: name =          float* ; bytes =    8 ; isNumber = false ; isPointer =  true ; isConst = false
Type Info: name =         double* ; bytes =    8 ; isNumber = false ; isPointer =  true ; isConst = false
Type Info: name =   const double&amp; ; bytes =    8 ; isNumber = false ; isPointer = false ; isConst =  true
template-metafunction.cpp:175: ; Typeinfo&lt;removePointer&lt;double&gt;::type&gt;::name = double
template-metafunction.cpp:176: ; Typeinfo&lt;removePointer&lt;double*&gt;::type&gt;::name = double
template-metafunction.cpp:177: ; Typeinfo&lt;removePointer&lt;const char*&gt;::type&gt;::name = const char
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org717ffc8" class="outline-3">
<h3 id="org717ffc8"><span class="section-number-3">1.12</span> Predefined type traits in &lt;type_traits&gt;</h3>
<div class="outline-text-3" id="text-1-12">
<p>
The C++11 header <code>&lt;type_traits&gt;</code> (before <code>boost.type_traits</code>) provide many
useful type traits, also known as metafunction, for querying and
transforming types at compile-time. In addition to those operations,
the type traits available in this header can also be used for
optimizing templates by specializing them for specific types.
</p>

<p>
Documentation: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/header/type_traits">Standard library header &lt;type_traits&gt; - cppreference.com</a></li>
<li><a href="https://www.boost.org/doc/libs/1_68_0/libs/type_traits/doc/html/index.html">Chapter 1. Boost.TypeTraits - 1.68.0</a></li>
</ul>

<p>
Examples: 
</p>

<ul class="org-ul">
<li>To use the C++11's type traits, it is necessary to include the
header <code>&lt;type_traits&gt;</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
</pre>
</div>

<ul class="org-ul">
<li>Type trait <code>std::is_void</code>
<ul class="org-ul">
<li>Checks whether type is void.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> inspectType<span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-constant">is_void</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Type is void"</span> &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-keyword">else</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Type is not void"</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; 
&gt;&gt; inspectType<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Type <span class="org-type">is</span> <span class="org-type">void</span>
&gt;&gt; inspectType<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-type">Type</span> <span class="org-variable-name">is</span> <span class="org-keyword">not</span> <span class="org-type">void</span>
&gt;&gt; inspectType<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-type">Type</span> <span class="org-variable-name">is</span> <span class="org-keyword">not</span> <span class="org-type">void</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is float point: <code>std::is_floating_point</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">long</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is interger: <code>std::is_integral</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">unsigned</span> <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is const</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_const</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
</pre>
</div>

<ul class="org-ul">
<li>Check whether type is a reference (&amp;)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">const</span> <span class="org-type">int</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_reference</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>

<p>
<b>Type relationship</b>
</p>

<ul class="org-ul">
<li>Check whether type are equal.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Returns true if types are the same </span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_same</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">float</span>, <span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Checks whether types are derived.
<ul class="org-ul">
<li><code>std::is_base_of&lt;A, B&gt;::value</code> returns true if A is a base type (superclass) of
B or B is derived class of A.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">class</span> <span class="org-type">B</span>: <span class="org-keyword">public</span> <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">class</span> <span class="org-type">Z</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">A</span>, <span class="org-type">B</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">B</span>, <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">B</span>, <span class="org-type">Z</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-constant">is_base_of</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Z</span>, <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::value
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 

</pre>
</div>
</div>
</div>
<div id="outline-container-org669399d" class="outline-3">
<h3 id="org669399d"><span class="section-number-3">1.13</span> Variadic Templates</h3>
<div class="outline-text-3" id="text-1-13">
<p>
This code shows examples about variadic templates in C++11 and
newer standards.
</p>

<p>
File: <a href="src/template-variadic.cpp">file:src/template-variadic.cpp</a>
</p>

<p>
Code Highlights:
</p>


<ul class="org-ul">
<li>Print a sequence of heterogenous arguments.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printTypes</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span>    
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::left &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; x
               &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-string">" size = "</span>
               &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::clog &lt;&lt; <span class="org-string">" [TRACE] Base case =&gt; x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Variadic template arguments </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">printTypes</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-variable-name">x</span>, <span class="org-keyword">const</span> <span class="org-type">Types</span> ... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::left &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; x
               &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-string">" size = "</span>
               &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
     printTypes<span class="org-rainbow-delimiters-depth-2">(</span>args ...<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">printTypes<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello world"</span>, 10, <span class="org-string">'x'</span>, 20.23f, <span class="org-constant">true</span>, NAN<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Ouput: 
</p>

<div class="org-src-container">
<pre class="src src-text">hello world       size = 12
10                size =  4
x                 size =  1
20.23             size =  4
1                 size =  1
nan               size =  4
</pre>
</div>


<ul class="org-ul">
<li>Create a function that applies a member function to a given object.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span>, <span class="org-keyword">class</span> <span class="org-type">R</span>, <span class="org-keyword">class</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">makeCommand</span><span class="org-rainbow-delimiters-depth-1">(</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Pointer to member function </span>
     <span class="org-type">R</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">T</span>::* <span class="org-function-name">pMemfn</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Args</span> ... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>,
     <span class="org-comment-delimiter">// </span><span class="org-comment">Member function arguments </span>
     <span class="org-type">Args</span> ... <span class="org-variable-name">arglist</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>R <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>=<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">T</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">(</span>obj.*pMemfn<span class="org-rainbow-delimiters-depth-3">)(</span>arglist ...<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">CNCMachine</span> <span class="org-variable-name">mach1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"7Z9FA"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">CNCMachine</span> <span class="org-variable-name">mach2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"MY9FT"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">setSpeed10</span> = makeCommand<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">CNCMachine</span>::setSpeed, 10<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">shutdown</span>   = makeCommand<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">CNCMachine</span>::shutdown<span class="org-rainbow-delimiters-depth-1">)</span>;
setSpeed10<span class="org-rainbow-delimiters-depth-1">(</span>mach1<span class="org-rainbow-delimiters-depth-1">)</span>;
setSpeed10<span class="org-rainbow-delimiters-depth-1">(</span>mach2<span class="org-rainbow-delimiters-depth-1">)</span>;
shutdown<span class="org-rainbow-delimiters-depth-1">(</span>mach2<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>Dynamic load an [U] nix-shared library or shared object.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Type synonym for shared library handler </span>
<span class="org-comment"> *  Requires: #include &lt;dlfcn.h&gt; and -ldl linker flag */</span>
<span class="org-keyword">using</span> <span class="org-type">LibHandle</span> = <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>, <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-keyword">auto</span> <span class="org-function-name">loadDLL</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">libPath</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">LibHandle</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Return unique_ptr for RAAI -&gt; Resource Acquisition is Initialization</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">releasing closing handle when the unique_ptr goes out of scope. </span>
     <span class="org-keyword">return</span> LibHandle<span class="org-rainbow-delimiters-depth-2">(</span>
             dlopen<span class="org-rainbow-delimiters-depth-3">(</span>libPath.c_str<span class="org-rainbow-delimiters-depth-4">()</span>, RTLD_LAZY<span class="org-rainbow-delimiters-depth-3">)</span>,
             <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">void</span>* <span class="org-variable-name">h</span><span class="org-rainbow-delimiters-depth-3">){</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Shared library handle released OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
                dlclose<span class="org-rainbow-delimiters-depth-4">(</span>h<span class="org-rainbow-delimiters-depth-4">)</span>;
             <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;        
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Load symbol from shared library </span>
<span class="org-comment">  *  Requires: #include &lt;dlfcn.h&gt; and -ldl linker flag */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">loadSymbol</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">LibHandle</span>&amp; <span class="org-variable-name">handle</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">symbol</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">Function</span>* <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-type">void</span>* <span class="org-variable-name">voidptr</span> = dlsym<span class="org-rainbow-delimiters-depth-2">(</span>handle.get<span class="org-rainbow-delimiters-depth-3">()</span>, symbol.c_str<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>voidptr == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
     <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Function</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>voidptr<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">GNU Scientific Library - Linear Algebra CBLAS </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">handle1</span> = loadDLL<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"/usr/lib64/libgslcblas.so"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">using</span> <span class="org-type">cblas_daxpy_type</span> = <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-keyword">const</span> <span class="org-type">double</span>*, <span class="org-type">int</span>, <span class="org-type">double</span>*, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">cblas_daxpy</span> = loadSymbol<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">cblas_daxpy_type</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>handle1, <span class="org-string">"cblas_daxpy"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">cblas_daxpy</span> = loadSymbol<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-keyword">const</span> <span class="org-type">double</span>*, <span class="org-type">int</span>, <span class="org-type">double</span>*, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>handle1, <span class="org-string">"cblas_daxpy"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">xs</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span> 3.0, 5.0, 6.0, 10.0, 8.0<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">ys</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span> 2.0, 2.0, 2.0,  2.0, 2.0<span class="org-rainbow-delimiters-depth-1">}</span>;
printContainer<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"xs"</span>, xs<span class="org-rainbow-delimiters-depth-1">)</span>;
printContainer<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ys"</span>, ys<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Compute xs * 4.0 + ys</span>
cblas_daxpy<span class="org-rainbow-delimiters-depth-1">(</span>xs.size<span class="org-rainbow-delimiters-depth-2">()</span>, 4.0, &amp;xs<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span>, 1, &amp;ys<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span>, 1<span class="org-rainbow-delimiters-depth-1">)</span>;
printContainer<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ys"</span>, ys<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text"> [INFO]  Loaded clblas_daxpy OK!
xs = 3, 5, 6, 10, 8, 
ys = 2, 2, 2, 2, 2, 
ys = 14, 22, 26, 42, 34, 
 [INFO] Shared library handle released OK.
</pre>
</div>


<p>
Complete Output: 
</p>

<div class="org-src-container">
<pre class="src src-txt">$ g++ template-variadic.cpp -o template-variadic.bin -g -std=c++11 -Wall -Wextra -ldl 
$ ./template-variadic.bin

EXPERIMENT 1 = Function of many argument for printing all of them
---------------------------------------
hello world       size = 12
10                size =  4
x                 size =  1
20.23             size =  4
1                 size =  1
nan               size =  4
 [TRACE] Base case =&gt; x = nan

EXPERIMENT 2 = Indirect method invocation
--------------------------------------
[MACHINE] id = 7Z9FA Set machine speed to level 10
[MACHINE] id = MY9FT Set machine speed to level 10
[MACHINE] id = 7Z9FA  Equipment to position set to  x = 10 ; y = -20
[MACHINE] id = MY9FT  Equipment to position set to  x = 10 ; y = -20
[MACHINE] id = 7Z9FA Shutdown equipment
[MACHINE] id = MY9FT Shutdown equipment

EXPERIMENT 3 = Dynamic Loading from shared library (libgslcblas.so) 
--------------------------------------
 [INFO]  Loaded clblas_daxpy OK!
xs = 3, 5, 6, 10, 8, 
ys = 2, 2, 2, 2, 2, 
ys = 14, 22, 26, 42, 34, 
 [INFO] Shared library handle released OK.
</pre>
</div>

<p>
References:  
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/27604128/c-stdfunction-like-template-syntax">c++11 - C++ std::function-like template syntax - Stack Overflow</a></li>
<li><a href="https://www.nag.com/numeric/FL/nagdoc_fl24/html/F06/f06ecf.html">F06ECF (DAXPY) : NAG Library, Mark 24</a></li>
<li><a href="https://dwheeler.com/program-library/Program-Library-HOWTO/x172.html">Dynamically Loaded (DL) Libraries</a></li>
<li><a href="https://www.gnu.org/software/gsl/doc/html/cblas.html">GSL CBLAS Library — GSL 2.5 documentation</a></li>
</ul>
</div>
</div>

<div id="outline-container-org94fa1c0" class="outline-3">
<h3 id="org94fa1c0"><span class="section-number-3">1.14</span> Variadic Templates - sizeof&#x2026; operator</h3>
<div class="outline-text-3" id="text-1-14">
<p>
The operator sizeof&#x2026;(args) is used for counting the number of template
arguments.
</p>

<ul class="org-ul">
<li>Class or function with type parameters.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> ... <span class="org-type">ARGUMENTS</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">Return</span> <span class="org-function-name">FUNCTION</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">ARGUMENTS</span> ... <span class="org-variable-name">arguments</span><span class="org-rainbow-delimiters-depth-1">){</span>
  ..... 
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> ... <span class="org-type">ARGUMENTS</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">AStruct</span><span class="org-rainbow-delimiters-depth-1">{</span>
  ..... 
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Operator: sizeof&#x2026;(ARGUMENTS)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">size_t</span> <span class="org-variable-name">NumberOfTypeArguments</span> = <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-1">(</span>ARGUMENTS<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>


<ul class="org-ul">
<li>Count number of type parameters</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">countArgs1</span><span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Number of args is equal to = "</span> &lt;&lt; <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-2">(</span>Args<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; countArgs1<span class="org-rainbow-delimiters-depth-1">()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countArgs1<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 3

&gt;&gt; countArgs1<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">char</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 4
</pre>
</div>

<ul class="org-ul">
<li>Count number of template numeric arguments</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span> ... <span class="org-variable-name">Number</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">countNumberArguments</span><span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Number of args is equal to = "</span> &lt;&lt; <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-2">(</span>Number<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 1

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;</span>1, 3<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 2

&gt;&gt; countNumberArguments<span class="org-rainbow-delimiters-depth-1">&lt;</span>1, 3, 5, 6, 7, 10<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
Number of args is <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 6
</pre>
</div>

<ul class="org-ul">
<li>Count number of function arguments</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Or:</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> ... <span class="org-type">Params</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">countParameters</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Params</span> ... <span class="org-variable-name">params</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Number of parameters equal to = "</span> &lt;&lt; <span class="org-keyword">sizeof</span>...<span class="org-rainbow-delimiters-depth-2">(</span>params<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">()</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 0

&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 1

&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-1">)</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 1

&gt;&gt; countParameters<span class="org-rainbow-delimiters-depth-1">(</span>12, <span class="org-string">'x'</span>, <span class="org-string">"hello world"</span>, 3.34<span class="org-rainbow-delimiters-depth-1">)</span>
Number of parameters <span class="org-type">equal</span> <span class="org-variable-name">to</span> = 4
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbf5445d" class="outline-3">
<h3 id="orgbf5445d"><span class="section-number-3">1.15</span> Variadic Templates arguments expansion</h3>
<div class="outline-text-3" id="text-1-15">
<ul class="org-ul">
<li><b>Example 0</b>:</li>
</ul>

<p>
Expand numeric template arguments into a std::vector.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span> ... <span class="org-variable-name">Numbers</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getNumberParameters</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span> Numbers ... <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .L script-parampack.C
&gt;&gt; 
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
&gt;&gt; 
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 0 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; getNumberParameters<span class="org-rainbow-delimiters-depth-1">&lt;</span>0, 10, 56, 100, 5, 3<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 0, 10, 56, 100, 5, 3 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li><b>Example 1:</b></li>
</ul>

<p>
Get deque container containing the size in bytes of every type from
the parameter pack (arguments of a variadic template).
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Return a deque containing the size in bytes of each type from the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">parameter pack (types arguments).</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getSizeList</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">{ ... } Intializer list - used for </span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">C++11 default intialization feature. </span>
     <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>Types<span class="org-rainbow-delimiters-depth-3">)</span> ... <span class="org-rainbow-delimiters-depth-2">}</span>;   
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 1 <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 8 <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; getSizeList<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span>, <span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">long</span> <span class="org-type">double</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 1, 4, 8, 16, 32 <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li><b>Example 2:</b></li>
</ul>

<p>
Example: modify example 1 for requiring at least one type parameter.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Type0</span>, <span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">getSizeList2</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>Type0<span class="org-rainbow-delimiters-depth-3">)</span>, <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>Types<span class="org-rainbow-delimiters-depth-3">)</span> ... <span class="org-rainbow-delimiters-depth-2">}</span>;    
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
<span class="org-function-name">ROOT_prompt_2</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>getSizeList2<span class="org-warning">'</span>
getSizeList2<span class="org-rainbow-delimiters-depth-1">&lt;&gt;()</span>
^~~~~~~~~~~~~~
<span class="org-function-name">/home/archbox/root-scripts/script-parampack.C</span>:41:6: note: candidate <span class="org-keyword">template</span> ignored: couldn<span class="org-warning">'</span>t infer <span class="org-keyword">template</span> argument <span class="org-warning">'</span>Type0<span class="org-warning">'</span>
<span class="org-keyword">auto</span> getSizeList2<span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   ^
&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>
<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 1 <span class="org-rainbow-delimiters-depth-2">}</span>

&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>
<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 8 <span class="org-rainbow-delimiters-depth-2">}</span>

&gt;&gt; getSizeList2<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-type">int</span>, <span class="org-type">char</span>, <span class="org-type">long</span> <span class="org-type">double</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;()</span>
<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 8, 4, 1, 16, 32 <span class="org-rainbow-delimiters-depth-2">}</span>
&gt;&gt; 
</pre>
</div>

<p>
<b>Example 3:</b> 
</p>

<p>
Print RTTI (Runtime Type Information) about types parameters.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">TypeInfo</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-function-name">TypeInfo</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">hash_code</span>, <span class="org-type">size_t</span> <span class="org-variable-name">size</span><span class="org-rainbow-delimiters-depth-2">)</span>
     : name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>,
       hash_code<span class="org-rainbow-delimiters-depth-2">(</span>hash_code<span class="org-rainbow-delimiters-depth-2">)</span>,
       size<span class="org-rainbow-delimiters-depth-2">(</span>size<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>       
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span>   <span class="org-variable-name">name</span>;
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">hash_code</span>;
    <span class="org-type">size_t</span>        <span class="org-variable-name">size</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">printTypesInfoFromRTTI</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-type">void</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">tlist</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">TypeInfo</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span>
            TypeInfo<span class="org-rainbow-delimiters-depth-3">{</span>
               <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-4">(</span>Types<span class="org-rainbow-delimiters-depth-4">)</span>.name<span class="org-rainbow-delimiters-depth-4">()</span>,
               <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-4">(</span>Types<span class="org-rainbow-delimiters-depth-4">)</span>.hash_code<span class="org-rainbow-delimiters-depth-4">()</span>,
               <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-4">(</span>Types<span class="org-rainbow-delimiters-depth-4">)</span>
                    <span class="org-rainbow-delimiters-depth-3">}</span> ... <span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span>  &lt;&lt; <span class="org-string">"Name"</span>
              &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span>  &lt;&lt; <span class="org-string">"Size"</span>
              &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"Hash"</span>
              &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>;   
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: tlist<span class="org-rainbow-delimiters-depth-2">){</span>
        ss.str<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        ss.clear<span class="org-rainbow-delimiters-depth-3">()</span>;
        ss &lt;&lt; <span class="org-string">"0x"</span> &lt;&lt; <span class="org-constant">std</span>::hex &lt;&lt; x.hash_code;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::right
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>5<span class="org-rainbow-delimiters-depth-3">)</span>  &lt;&lt; x.name
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>5<span class="org-rainbow-delimiters-depth-3">)</span>  &lt;&lt; x.size
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>15<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; ss.str<span class="org-rainbow-delimiters-depth-3">()</span>
                  &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">//</span><span class="org-comment">--- End of printTypesInfoFromRTTI() ----- //</span>
</pre>
</div>

<p>
Running (ROOT/Cling REPL): 
</p>

<div class="org-src-container">
<pre class="src src-sh">&gt;&gt; printTypesInfoFromRTTI&lt;&gt;()
 Name Size           Hash
&gt;&gt; 
&gt;&gt; printTypesInfoFromRTTI&lt;char&gt;()
 Name Size           Hash
    c    1     0x2479fc8d
&gt;&gt; 
&gt;&gt; printTypesInfoFromRTTI&lt;char, int, double, long double&gt;()
 Name Size           Hash
    c    1     0x2479fc8d
    i    4     0xb675de06
    d    8     0x44573475
    e   16     0xbbbbed2c
</pre>
</div>
</div>
</div>

<div id="outline-container-orgba0c477" class="outline-3">
<h3 id="orgba0c477"><span class="section-number-3">1.16</span> SFINAE - Substution Is Not a Failure</h3>
<div class="outline-text-3" id="text-1-16">
</div>
<div id="outline-container-org7d06540" class="outline-4">
<h4 id="org7d06540"><span class="section-number-4">1.16.1</span> Fundamentals</h4>
<div class="outline-text-4" id="text-1-16-1">
<p>
SFINAE stands for <span class="underline">Substition Failure Is Not An Error</span>. It was
introduced by David Vandervood in book "C++ Templates: The Complete
Guide". The SFINAE technique is peformed by adding new overload
functions (function with same name and different type signatures) for
preveting compilation error during the template parameter type
substitution. When a substition failure happens, the compiler looks
for a the next function overload, if the substition fails again and
there are no more candidates, the compiler will generate an error.
</p>

<p>
<b>Example: 1</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">struct</span> <span class="org-type">AStruct</span><span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">using</span> <span class="org-type">ASubtype</span> = <span class="org-type">int</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">AStructB</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:   
   <span class="org-keyword">using</span> <span class="org-type">ASubtype</span> = <span class="org-keyword">const</span> <span class="org-type">char</span>*;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">void</span> <span class="org-function-name">AfunctionTemplate</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type contains ASubtype = TRUE "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Value = "</span> &lt;&lt; value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Template substution worked. OK. </span>
&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">&lt;</span>AStruct<span class="org-rainbow-delimiters-depth-1">&gt;(</span>200<span class="org-rainbow-delimiters-depth-1">)</span>
 Type <span class="org-type">contains</span> <span class="org-variable-name">ASubtype</span> = TRUE 
 Value = 200

<span class="org-comment-delimiter">// </span><span class="org-comment">Template substution worked. OK. </span>
 &gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">&lt;</span>AStructB<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-string">"PARAMETER"</span><span class="org-rainbow-delimiters-depth-1">)</span>
  Type <span class="org-type">contains</span> <span class="org-variable-name">ASubtype</span> = TRUE 
  Value = PARAMETER

<span class="org-comment-delimiter">// </span><span class="org-comment">Template substution error. Failed. </span>
&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span>600<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_13</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>AfunctionTemplate<span class="org-warning">'</span>
AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span>600<span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~~~~~~~~~
<span class="org-function-name">ROOT_prompt_3</span>:1:27: note: candidate <span class="org-keyword">template</span> ignored: couldn<span class="org-warning">'</span>t infer <span class="org-keyword">template</span> argument <span class="org-string">'T'</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">void</span> AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Template substution error. Failed. </span>
&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-function-name">ROOT_prompt_14</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>AfunctionTemplate<span class="org-warning">'</span>
AfunctionTemplate<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-2">)</span>
^~~~~~~~~~~~~~~~~
<span class="org-function-name">ROOT_prompt_3</span>:1:27: note: candidate <span class="org-keyword">template</span> ignored: couldn<span class="org-warning">'</span>t infer <span class="org-keyword">template</span> argument <span class="org-string">'T'</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-type">void</span> AfunctionTemplate<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
</pre>
</div>

<p>
By defining a two new overload functions which can match the type
arguments, the substition failure of the first overload function with
the type parameters int and const char* will no longer be an error as
the compiler will select the next two overoads. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Note: This overload function is not a function template, just a free function</span>
<span class="org-type">void</span> <span class="org-function-name">AfunctionTemplate</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Overload 2 =&gt; [INT] Type contains ASubtype = FALSE "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Value = "</span> &lt;&lt; value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Note: This overload function is not a function template, just a free function</span>
<span class="org-type">void</span> <span class="org-function-name">AfunctionTemplate</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Overload 3 =&gt; [CONST CHAR*] Type contains ASubtype = FALSE "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Value = "</span> &lt;&lt; value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span>400<span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 2 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INT</span><span class="org-rainbow-delimiters-depth-1">]</span> Type contains ASubtype = FALSE 
 Value = 400
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Implicit conversion </span>
&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 2 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INT</span><span class="org-rainbow-delimiters-depth-1">]</span> Type contains ASubtype = FALSE 
 Value = 120
&gt;&gt; 

&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Hello world SFINAE"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 3 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">CONST</span> CHAR*<span class="org-rainbow-delimiters-depth-1">]</span> Type contains ASubtype = FALSE 
 Value = Hello world SFINAE
</pre>
</div>

<p>
If there is no overload candidate matching the type argument, then the
type substition failure will become an error:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"A std::string object"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-function-name">ROOT_prompt_31</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>AfunctionTemplate<span class="org-warning">'</span>
AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"A std::string object"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~~~~~~~~~
<span class="org-function-name">ROOT_prompt_16</span>:1:6: note: candidate function <span class="org-keyword">not</span> viable: no known conversion from <span class="org-warning">'</span><span class="org-constant">std</span>::string<span class="org-warning">'</span> <span class="org-rainbow-delimiters-depth-1">(</span>aka
      <span class="org-warning">'</span><span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">)</span> to <span class="org-warning">'</span><span class="org-type">int</span><span class="org-warning">'</span> <span class="org-keyword">for</span> 1st argument
<span class="org-type">void</span> AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     ^
<span class="org-function-name">ROOT_prompt_20</span>:1:6: note: candidate function <span class="org-keyword">not</span> viable: no known conversion from <span class="org-warning">'</span><span class="org-constant">std</span>::string<span class="org-warning">'</span> <span class="org-rainbow-delimiters-depth-2">(</span>aka
      <span class="org-warning">'</span><span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-2">)</span> to <span class="org-warning">'</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-warning">'</span> <span class="org-keyword">for</span> 1st argument
<span class="org-type">void</span> AfunctionTemplate<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
     ^
<span class="org-function-name">ROOT_prompt_8</span>:1:27: note: candidate <span class="org-keyword">template</span> ignored: couldn<span class="org-warning">'</span>t infer <span class="org-keyword">template</span> argument <span class="org-string">'T'</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-type">void</span> AfunctionTemplate<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
                          ^
</pre>
</div>

<p>
The substition failure error can again be eliminated by defiing a new
overload:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">void</span> <span class="org-function-name">AfunctionTemplate</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Overload 4 =&gt; [Match Any Type] contains ASubtype = FALSE "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Deduce type T as std::string </span>
&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"A std::string object"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 4 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">Match</span> Any Type<span class="org-rainbow-delimiters-depth-1">]</span> contains ASubtype = FALSE 
&gt;&gt; 

&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"A std::string object"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 4 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">Match</span> Any Type<span class="org-rainbow-delimiters-depth-1">]</span> contains ASubtype = FALSE 

&gt;&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-string">"A std::string object"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 4 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">Match</span> Any Type<span class="org-rainbow-delimiters-depth-1">]</span> contains ASubtype = FALSE 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Deduce type std::vector&lt;double&gt;</span>
&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;{</span>200.34, -100.6, 6.1546<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 4 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">Match</span> Any Type<span class="org-rainbow-delimiters-depth-1">]</span> contains ASubtype = FALSE 

<span class="org-comment-delimiter">// </span><span class="org-comment">Deduce type std::vector&lt;double&gt;</span>
&gt; AfunctionTemplate<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">{</span>200.34, -100.6, 6.1546<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 Overload 4 =&gt; <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">Match</span> Any Type<span class="org-rainbow-delimiters-depth-1">]</span> contains ASubtype = FALSE 
</pre>
</div>

<p>
<b>Case 2</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">AStruct</span><span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">using</span> <span class="org-type">ASubtype</span> = <span class="org-type">int</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">AStructB</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:   
   <span class="org-keyword">using</span> <span class="org-type">ASubtype</span> = <span class="org-keyword">const</span> <span class="org-type">char</span>*;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Clever trick found at: http://cppedinburgh.uk/slides/201508-concepts-bottom-up-view.pdf</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">bool</span> <span class="org-function-name">FunctionTest</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>   
</pre>
</div>

<p>
Before defining the second overload function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; AStruct a;
&gt;&gt; AStructB b;

&gt;&gt; FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>a<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>b<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>

&gt;&gt; FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_14</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>FunctionTest<span class="org-warning">'</span>
FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~~~~
<span class="org-function-name">ROOT_prompt_9</span>:1:60: note: candidate <span class="org-keyword">template</span> ignored: substitution failure <span class="org-rainbow-delimiters-depth-1">[</span>with T = <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">]</span>: type <span class="org-warning">'</span><span class="org-type">int</span><span class="org-warning">'</span>
      cannot be used prior to <span class="org-warning">'</span>::<span class="org-warning">'</span> because it has no members
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-constant">T</span>::<span class="org-type">ASubtype</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">bool</span> FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>...
</pre>
</div>

<p>
After defining the second overload function:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">bool</span> <span class="org-function-name">FunctionTest</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [2] Value = "</span> &lt;&lt; value &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>  
<span class="org-type">bool</span> <span class="org-function-name">FunctionTest</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [3] Value = "</span> &lt;&lt; value &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>  

&gt;&gt; FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> Value = 100
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>

&gt;&gt; FunctionTest<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"C++20"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> Value = C++20
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb305d7e" class="outline-4">
<h4 id="orgb305d7e"><span class="section-number-4">1.16.2</span> Metafunction or type trait std::enable_if</h4>
<div class="outline-text-4" id="text-1-16-2">
<p>
The metafunction (aka type trait) std::enable_if is used for
conditionally selectig a given overload function template from an
overload set when the boolean argument is true or removing the
function from the overload resolution when the boolean argument is
false (SFINAE).
</p>

<ul class="org-ul">
<li>Header: <a href="https://en.cppreference.com/w/cpp/header/type_traits">&lt;type_traits&gt;</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/enable_if">Documentation</a></li>
</ul>

<p>
<b>Use cases:</b>
</p>

<ul class="org-ul">
<li>Select a given overload function when a condition is true.</li>

<li>Constrain template arguments by only allowing the templated
function or class be used with types matching a predicate
metafunction. When the predicate evaluates to false, a compile-time
error happens.</li>
</ul>

<p>
<b>Definition</b>
</p>

<p>
The metafunction or type trait std::enable_if could be defined as:
</p>

<ul class="org-ul">
<li>Base template:</li>
</ul>

<p>
When the flag is false, the subtype <span class="underline">type</span> is not defined and the
expression <span class="underline">enable_if&lt;false, T&gt;::type</span> is not valid, then compiler looks
for the next overload function matching the template type arguments.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">bool</span> <span class="org-variable-name">Flag</span>, <span class="org-keyword">class</span> <span class="org-type">T</span> = <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">enable_if</span><span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Paratial specialization:</li>
</ul>

<p>
When the flag is true, the expression <span class="underline">enable_if&lt;true, T&gt;::type</span> is
defined and returns the type T.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span> = <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">{</span> 
   <span class="org-keyword">using</span> <span class="org-type">type</span> = T;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Example: The following code has a templated function classifyType with
two overaloads, the first overload only works with integral types
(int, char, long, &#x2026;) and the second with float types (float, double
and long double). If the function is used with non integral or float
points type argument, a compilation error happens.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">First Overload classifyType</span>
<span class="org-comment-delimiter">/** </span><span class="org-comment">Note: when the predicate std::is_integral&lt;T&gt;::value is true, </span>
<span class="org-comment">  * the expression: typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::type</span>
<span class="org-comment">  * evaluates to void. When the predicate is false  this overload </span>
<span class="org-comment">  * (implementation) is discarded. (SFINAE)</span>
<span class="org-comment">  */</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>
<span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = integral ; "</span> &lt;&lt; <span class="org-string">" 3 * value = "</span> &lt;&lt; 3 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Second Overload of classifyType</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>
<span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = floating point ; "</span> &lt;&lt; <span class="org-string">" 25% x value = "</span> &lt;&lt; 0.25 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>20<span class="org-rainbow-delimiters-depth-2">)</span>;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>100L<span class="org-rainbow-delimiters-depth-2">)</span>;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-type">double</span> <span class="org-variable-name">z</span> = 9.34;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>z<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-type">float</span> <span class="org-variable-name">x</span> = 3.1415; 
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output:
</p>

<div class="org-src-container">
<pre class="src src-text">Type = integral ;  3 * value = 60
Type = integral ;  3 * value = 300
Type = integral ;  3 * value = 360
Type = floating point ;  25% x value = 2.335
Type = floating point ;  25% x value = 0.785375
</pre>
</div>


<p>
The templated functions could also be written as: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-keyword">auto</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> 
   -&gt; <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = integral ; "</span> &lt;&lt; <span class="org-string">" 3 * value = "</span> &lt;&lt; 3 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-keyword">auto</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> 
  -&gt; <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::<span class="org-type">type</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = floating point ; "</span> &lt;&lt; <span class="org-string">" 25% x value = "</span> &lt;&lt; 0.25 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The code could also be written in a another way as: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">First Overload of classifyType </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; Only works with char, int, long, unsigned, ... </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    
<span class="org-type">void</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span>, 
                  <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">type</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = integral ; "</span> &lt;&lt; <span class="org-string">" 3 * value = "</span> &lt;&lt; 3 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Second Overload of classifyType </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; Only works with float, double or long double </span>
 <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    
 <span class="org-type">void</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span>, 
                   <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">type</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> 
 <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = floating point ; "</span> &lt;&lt; <span class="org-string">" 25% x value = "</span> &lt;&lt; 0.25 * value &lt;&lt; <span class="org-constant">std</span>::endl;
 <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The metafunction std::enable_if can be removed from the function
signature by writing the code as: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">First Overload classifyType</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">type</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-type">void</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = integral ; "</span> &lt;&lt; <span class="org-string">" 3 * value = "</span> &lt;&lt; 3 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Second Overload of classifyType</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span> <span class="org-constant">std</span>::<span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value, <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">type</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    
<span class="org-type">void</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = floating point ; "</span> &lt;&lt; <span class="org-string">" 25% x value = "</span> &lt;&lt; 0.25 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfd2b369" class="outline-4">
<h4 id="orgfd2b369"><span class="section-number-4">1.16.3</span> Metafunction or type trait std::enalbe_if_t</h4>
<div class="outline-text-4" id="text-1-16-3">
<p>
The metafunction <span class="underline">std::enable_if_t</span> simplifies the usage of
std::enable_if as it can be used as a dummy template argument instead
of being used as return type. 
</p>

<p>
Definition:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-type">bool</span> <span class="org-variable-name">B</span>, <span class="org-keyword">class</span> <span class="org-type">T</span> = <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">using</span> <span class="org-type">enable_if_t</span> = <span class="org-keyword">typename</span> <span class="org-constant">enable_if</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>B,<span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>::type;
</pre>
</div>

<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-constant">std</span>::<span class="org-type">enable_if_t</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_integral</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value<span class="org-rainbow-delimiters-depth-2">&gt;</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    
<span class="org-keyword">auto</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">void</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = integral ; "</span> &lt;&lt; <span class="org-string">" 3 * value = "</span> &lt;&lt; 3 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Second Overload of classifyType</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-constant">std</span>::<span class="org-type">enable_if_t</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-constant">is_floating_point</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>::value<span class="org-rainbow-delimiters-depth-2">&gt;</span>* = <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    
<span class="org-keyword">auto</span> <span class="org-function-name">classifyType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">void</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Type = floating point ; "</span> &lt;&lt; <span class="org-string">" 25% x value = "</span> &lt;&lt; 0.25 * value &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>20<span class="org-rainbow-delimiters-depth-2">)</span>;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>100L<span class="org-rainbow-delimiters-depth-2">)</span>;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-type">double</span> <span class="org-variable-name">z</span> = 9.34;
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>z<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-type">float</span> <span class="org-variable-name">x</span> = 3.1415; 
  classifyType<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output:
</p>

<div class="org-src-container">
<pre class="src src-cpp">Type = integral ;  3 * value = 60
Type = integral ;  3 * value = 300
Type = integral ;  3 * value = 360
Type = floating point ;  25% x value = 2.335
Type = floating point ;  25% x value = 0.785375
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5f5fbd7" class="outline-3">
<h3 id="org5f5fbd7"><span class="section-number-3">1.17</span> References and Bookmarks</h3>
<div class="outline-text-3" id="text-1-17">
</div>
<div id="outline-container-org10d1b9c" class="outline-4">
<h4 id="org10d1b9c"><span class="section-number-4">1.17.1</span> General</h4>
<div class="outline-text-4" id="text-1-17-1">
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/templates">Templates - cppreference.com</a></li>

<li><a href="https://en.cppreference.com/w/cpp/header/type_traits">Standard library header &lt;type_traits&gt; - cppreference.com</a></li>

<li><a href="https://en.cppreference.com/w/cpp/language/class_template">Class template - cppreference.com</a></li>
</ul>


<p>
Templates and Iterators: 
</p>
<ul class="org-ul">
<li><a href="https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/">std::iterator is deprecated: Why, What It Was, and What to Use Instead - Fluent C++</a></li>
</ul>

<p>
Dependent Type Names: 
</p>
<ul class="org-ul">
<li><a href="http://www.enseignement.polytechnique.fr/informatique/INF478/docs/Cpp/en/cpp/language/dependent_name.html">Dependent names - cppreference.com</a></li>
</ul>

<p>
Variadic Templates:
</p>
<ul class="org-ul">
<li><a href="http://www.cplusplus.com/articles/EhvU7k9E/">C++11 - New features - Variadic template - C++ Articles</a></li>
<li><a href="http://kevinushey.github.io/blog/2016/01/27/introduction-to-c++-variadic-templates/">Introduction to C++ Variadic Templates · R and C++</a></li>
<li><a href="https://docs.microsoft.com/en-gb/cpp/cpp/ellipses-and-variadic-templates?view=vs-2017">Ellipses and Variadic Templates | Microsoft Docs</a></li>
<li><a href="https://stackoverflow.com/questions/27604128/c-stdfunction-like-template-syntax">c++11 - C++ std::function-like template syntax - Stack Overflow</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgd2fa3fe" class="outline-4">
<h4 id="orgd2fa3fe"><span class="section-number-4">1.17.2</span> Videos</h4>
<div class="outline-text-4" id="text-1-17-2">
<ul class="org-ul">
<li>CppCon 2015: Peter Sommerlad "Variadic Templates in C++11 / C++14 -
An Introduction" - <a href="https://www.youtube.com/watch?v=R1G3P5SRXCw">https://www.youtube.com/watch?v=R1G3P5SRXCw</a></li>

<li>CppCon 2016: Michał Dominiak "Variadic expansion in examples" -
<a href="https://www.youtube.com/watch?v=Os5YLB5D2BU">https://www.youtube.com/watch?v=Os5YLB5D2BU</a></li>

<li>Presented by Andrei Alexandrescu - Channel 9 - <b>Variadic Templates are Funadic</b> -
<a href="https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Variadic-Templates-are-Funadic">https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Variadic-Templates-are-Funadic</a></li>

<li>Presented by Andrei Alexandrescu - Channel 9 - <b>The Way of the</b>
<b>Exploding Tuple</b> -
<a href="https://channel9.msdn.com/Events/GoingNative/2013/The-Way-of-the-Exploding-Tuple">https://channel9.msdn.com/Events/GoingNative/2013/The-Way-of-the-Exploding-Tuple</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgae9a2ec" class="outline-4">
<h4 id="orgae9a2ec"><span class="section-number-4">1.17.3</span> Papers and technical documents</h4>
<div class="outline-text-4" id="text-1-17-3">
<p>
Papers and technical documents about Generic Programming and Template Metaprogramming 
</p>

<ul class="org-ul">
<li>Alexander Stepanov and David R. Musser - <b>Generic Programming</b> -
<a href="http://stepanovpapers.com/genprog.pdf">http://stepanovpapers.com/genprog.pdf</a></li>

<li>Alexander Stepanov and Meng Lee. <b>The Standard Template Library</b>
<ul class="org-ul">
<li><a href="http://stepanovpapers.com/STL/DOC.PDF">http://stepanovpapers.com/STL/DOC.PDF</a></li>
</ul></li>

<li>Alexandre Duret-Lutz et al. <b>Design Patterns for Generic Programming in C++</b>
<ul class="org-ul">
<li><a href="https://www.lrde.epita.fr/dload/papers/coots01.html">https://www.lrde.epita.fr/dload/papers/coots01.html</a></li>
</ul></li>

<li>Alexandre Duret-Lutz et al. <b>Design Patterns for Generic Programming in C++</b>
<ul class="org-ul">
<li><a href="https://www.usenix.org/legacy/events/coots01/full_papers/duret/duret_html/index.html">https://www.usenix.org/legacy/events/coots01/full_papers/duret/duret_html/index.html</a></li>
</ul></li>

<li>James C. Dehnert and Alexander Stepanov. <b>Fundamentals of Generic Programming</b>
<ul class="org-ul">
<li><a href="http://stepanovpapers.com/DeSt98.pdf">http://stepanovpapers.com/DeSt98.pdf</a></li>
</ul></li>

<li>Jeremy Gibbons. <b>Patterns in Datatype-Generic Programming</b>
<ul class="org-ul">
<li><a href="http://www.cs.ox.ac.uk/jeremy.gibbons/publications/patterns.pdf">http://www.cs.ox.ac.uk/jeremy.gibbons/publications/patterns.pdf</a></li>
</ul></li>

<li>Giuseppe Lipari. <b>Design Patterns in C++ Template metaprogramming</b>
<ul class="org-ul">
<li><a href="http://retis.sssup.it/~lipari/courses/oosd2010-2/07.metaprogramming-handout.pdf">http://retis.sssup.it/~lipari/courses/oosd2010-2/07.metaprogramming-handout.pdf</a></li>
</ul></li>

<li>Gabriel Dos Reis and Jaakko Jarvi. <b>What is Generic Programming?</b>
<ul class="org-ul">
<li><a href="https://pdfs.semanticscholar.org/e730/3991015a041e50c7bdabbe4cb4678531e35b.pdf">https://pdfs.semanticscholar.org/e730/3991015a041e50c7bdabbe4cb4678531e35b.pdf</a></li>
</ul></li>

<li><b>Functional Programming with C++ Template Metaprograms</b>
<ul class="org-ul">
<li><a href="https://pdfs.semanticscholar.org/c7f3/a67b78dabd5aa6c4599a127583c07bb8c032.pdf">https://pdfs.semanticscholar.org/c7f3/a67b78dabd5aa6c4599a127583c07bb8c032.pdf</a></li>
</ul></li>

<li><b>Implementing Monads for C++ Template Metaprograms</b>
<ul class="org-ul">
<li><a href="http://plcportal.inf.elte.hu/en/publications/TechnicalReports/monad-tr.pdf">http://plcportal.inf.elte.hu/en/publications/TechnicalReports/monad-tr.pdf</a></li>
</ul></li>

<li>Angelika Langer. <b>C++ Expression Templates - An Introduction to the</b>
<b>Principles of Expression Templates</b>
<ul class="org-ul">
<li><a href="http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm">http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm</a></li>
</ul></li>

<li><b>Advanced C++ Template Techniques: An Introduction to Meta-Programming for Scientific Computing</b>
<ul class="org-ul">
<li><a href="https://conradsanderson.id.au/misc/sanderson_templates_lecture_uqcomp7305.pdf">https://conradsanderson.id.au/misc/sanderson_templates_lecture_uqcomp7305.pdf</a></li>
</ul></li>

<li><b>Static and Metaprogramming Patterns and Static Frameworks A Catalog. An Application</b>
<ul class="org-ul">
<li><a href="https://hillside.net/plop/2006/Papers/ACM_Version/Static_and_Metaprogramming_Patterns_and_Static_Frameworks.pdf">https://hillside.net/plop/2006/Papers/ACM_Version/Static_and_Metaprogramming_Patterns_and_Static_Frameworks.pdf</a></li>
</ul></li>

<li><a href="http://people.cs.uchicago.edu/~jacobm/pubs/templates.html">What's Wrong with C++ Templates?</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-01-14 Mon 01:47</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
