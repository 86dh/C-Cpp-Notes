#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ Notes - Design Patterns 
#+DESCRIPTION: cpp/c++ c++ design patterns gneric programming object oriented metaprogramming
#+STARTUP: content 

* Design Patterns 
** Named constructor - static factory method

The named constructor or static factory design pattern uses static
methods instead of constructors for instantiating objects. This
approach has many advantages over constructor instantiation. Named
constructors are more readable than ordinary constructors and unlike
constructors, many named constructors static methods sharing the same
type signature can coexist. Another benefit is that this technique
allows objects to be instantiated in many different ways from several
different data representation.

Side note: It should not be confused with factory design pattern or
abstract factory design pattern.

Example:

#+BEGIN_SRC cpp   :results output pp :exports both 
  #include <iostream>
  #include <ostream>
  #include <cstdint>

  // #include <stdint>   // WARNING - It may not be available

  // Unsigned byte from 0 to 255 or 0x00 to 0xFF
  // ---> typedef uint8_t ubyte;
  using ubyte = uint8_t ; 

  class Color{
  private:
      ubyte m_r;
      ubyte m_g;
      ubyte m_b;
  public:
      Color(ubyte red, ubyte green, ubyte blue):
          m_r(red), m_g(green), m_b(blue) {}
      ubyte red(){
          return m_r;
      }
      ubyte blue(){
          return m_b;
      }
      ubyte green(){
          return m_g;
      }
      // Named constructor or static factory method which builds the object
      // From the RGB tuple data representation 
      static Color fromRGB(ubyte red, ubyte green, ubyte blue){
          return Color(red, green, blue);
      }
      // Named constructor which builds Color object 
      // from hexadecimal data representation 
      static Color fromHex(int color){
          int r = color & 0xFF;
          int g = (color >> 8 ) & 0xFF;
          int b = (color >> 16) & 0xFF;
          return Color(r, g, b);
      }
      // Named constructor which builds a specific color.
      static Color colorRED(){
          return fromRGB(255, 0, 0);
      }
      static Color colorBLUE(){
          return fromRGB(0, 255, 0);
      }
      static Color colorGREEN(){
          return fromRGB(0, 0, 255);
      }
      friend std::ostream& operator <<(std::ostream& os, const Color& c){
          os << "Color(r = "
             << static_cast<int>(c.m_r)
             << ", g = " << static_cast<int>(c.m_g)
             << ", b = " << static_cast<int>(c.m_b) << ")";
          return os;
      }      
  };

  int main(){
      std::cout << "Red    = " << Color::colorRED()   << "\n";
      std::cout << "Blue   = " << Color::colorBLUE()  << "\n";
      std::cout << "Green  = " << Color::colorGREEN() << "\n";
      std::cout << "Color1 = " << Color::fromRGB(20, 90, 200) << "\n";
      std::cout << "Color2 = " << Color::fromHex(0xFF8AB5) << "\n";
      std::cout.flush();
      return 0;
  }
#+END_SRC

#+RESULTS:
: Red    = Color(r = 255, g = 0, b = 0)
: Blue   = Color(r = 0, g = 255, b = 0)
: Green  = Color(r = 0, g = 0, b = 255)
: Color1 = Color(r = 20, g = 90, b = 200)
: Color2 = Color(r = 181, g = 138, b = 255)
** Builder Design Pattern (Joshua Blosh)

The purpose of the builder design pattern proposed by Joshua Bloch is
to simplify the instantiation of objects with many constructor
parameters or many optional parameters. Note: it should not be
confused with the GOF (Gang of Four) builder pattern.

Example: 

 - File: builder.cpp 

#+BEGIN_SRC cpp 
  // Joshua Bloch's Builder Pattern for simplifying the instantiation
  // of objects with many constructor parameters. It is not the
  // GOF (Gang of Four) builder pattern. 
  #include <iostream>
  #include <string>

  // Function meta object 
  class UserData{
  public:
          using ulong = unsigned long;
  private:
          ulong          _userID = 0;
          std::string    _name;
          std::string    _lastName;
          std::string    _email;
          UserData() = default;
  public:
          // Explicit is better than implicit 
          ~UserData() = default;
	
          auto show() -> void
          {
              std::cout << "\nUser{"
                        << "\n" << "  id        = " << _userID
                        << "\n" << "  name      = " << _name
                        << "\n" << "  last name = " << _lastName
                        << "\n" << "  email     = " << _email
                        << "\n" << "}"
                        << "\n";
          }
	
          // Allow builder class access UserData's private data
          friend class UserBuilder;
  }; //--- EoF class UserData --- //

  class UserBuilder{
  private:
          //class UserData;
          UserData _data{};
  public:
          UserBuilder(){
                  // _data = UserData();
          }		
          auto setID(ulong userID ) -> UserBuilder& {
             _data._userID = userID;
             return *this;
          }
          auto setName(const std::string& name) -> UserBuilder& {
              _data._name = name;
              return *this;
          }
          auto setLastName(const std::string& name) -> UserBuilder& {
              _data._lastName = name;
              return *this;
          }
          auto setEmail(const std::string& email) -> UserBuilder& {
             _data._email = email;
             return *this;
          }
          auto build() -> UserData {
             return this->_data;
          }
  }; //--- EoF class UserData::builder --- //

  int main(){
      auto user0 =
              UserBuilder()
              .setID(2065)
              .setName("John")
              .setLastName("Von Neumman")
              .setEmail("nx098774a@sknmap.co")
              .build();
      auto user1 =
              UserBuilder()
              .setID(1065)
              .setName("Enrico")
              .setLastName("Fermi")
              .setEmail("dummyEmail@service1.co.uk")
              .build();
      auto user2 =
              UserBuilder()
              .setID(2001)
              .setName("Stanislaw")
              .setLastName("Ulam")
              .setEmail("wsx752@couk.com.sk")
              .build();
      user0.show();
      user1.show();		
      user2.show();
      return EXIT_SUCCESS;
  }
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   $ g++ builder.cpp -o builder.bin -g -std=c++1z -Wall -Wextra && ./builder.bin
   User{
     id        = 2065
     name      = John
     last name = Von Neumman
     email     = nx098774a@sknmap.co
   }

   User{
     id        = 1065
     name      = Enrico
     last name = Fermi
     email     = dummyEmail@service1.co.uk
   }

   User{
     id        = 2001
     name      = Stanislaw
     last name = Ulam
     email     = wsx752@couk.com.sk
   }
#+END_SRC
** Type Erasure 
*** Overview  

Type erasure is a set of techniques for providing an uniform interface
for many different types by hiding the type information from the
client code. In C++ type erasure can be implemented with a combination
of object oriented programming and generic programming, in other
words, inheritance and templates. The fundamental building blocks of
this pattern are a base class, called _concept_, which provides the
uniform interface to the wrapped types and a derived templatized
class, called _model_, inherting the concept class which adapts the
wrapped type to the concept class. The inheritance allows any template
instantation of the model to be treated as it was the base class, thus
this approach hides the type information which can be later recovered
by downcasting the base class to the derived class.

 - Definition by Dave Abrahams and Aleksey Curtovoy in, *C++ Template*
   *Metaprogramming.*

#+BEGIN_QUOTE
  In its fullest expression, type erasure is the process of turning a
  wide variety of types with a common interface into one type with that
  same interface
#+END_QUOTE

Parts: 

 + *Concept class*
   - base class - definines the interface being enforced. 
 + *Model class*
   - templatized class inherting the concept class adpating the
     wrapped type to the concept class and holding an instance of the
     wrapped type. 
 + *Type Erasure class* (outter class)
   - Both the concept and model classes are private inner classes of
     the type erasure class.
   - The type erasure class takes an instance of the model class in the
     constructor.
   - This class stores a pointer variable to the concept class, but
     storing a pointer to the model class (dynamic polymorphism).
 + *Wrapped Type* or Objects 
   + Types wrapped by the model class wich will be erased. 

Use-cases: 

 + Create a common interface for many different types. 
 + Store wrapped types without a common base class in STL containers.
 + Store templatized classes in STL containers.
 + Implement dynamic or runtime polymorphism with value semantics.
 + Take advantage of the commonality of many unrelated classes without
   a common base class without modifying their source code. 

Known uses in C++ standard library: 

 + std::function (C++11, formber Boost.Function)

 + std::any (C++17, former Boost.Any)
   + A container which can store anything and the type of the stored
     object is not known at runtime. 

 + std::variant (C++17, former Boost.Variant)
   + Provides an interface for sum types or disjoint union or _visitor_ OO
     design pattern which is useful for manipulating abstract syntax
     tree, creating interpreters, tree data structures and fixed class
     hierarchies. 

 + void* - Void pointer in many C-APIs. 


References and further reading:
 + Nevin Liber, *Type Erasure*  <http://files.meetup.com/1455470/Type%20Erasure.pdf>
 + [[https://stackoverflow.com/questions/46041683/type-erasure-retrieving-value-type-check-at-compile-time][c++ - Type erasure: Retrieving value - type check at compile time - Stack Overflow]]
 + [[http://talesofcpp.fusionfenix.com/post-16/episode-nine-erasing-the-concrete][Episode Nine: Erasing the Concrete]]
 + [[https://codereview.stackexchange.com/questions/41879/concept-based-polymorphism][c++ - Concept based polymorphism - Code Review Stack Exchange]]
 + [[https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%2520Generic%2520Programming%2520with%2520Virtual%2520Concepts.pdf][Dynamic Programming with Virtual Concepts]]
 + [[https://www.reddit.com/r/cpp/comments/5epngi/type_erased_concepts/][Type erased concepts : cpp]]
 + [[http://www.cplusplus.com/articles/oz18T05o/][C++ type erasure - C++ Articles]]
 + [[https://blog.tartanllama.xyz/type-erasure-unified-call/][Type erasure with unified call syntax]]
 + [[http://www.sgh1.net/posts/cpp-type-erasure.md][My Internet Weblog - Type Erasure in C++]]
 + [[https://accu.org/index.php/journals/2424][ACCU - Polymorphism in C++ – A Type Compatibility View]]

*** Example 1 - Simple type erasure.

_Problem:_ Handle the classes A, B and C which don't have a common base
class using dynamic (aka runtime) polymorphism taking advantage of
their commonality, the method .getName(). Note: the source code of A,
B and C aren't allowed to be modified

 - Complete source code:
   + File: [[file:src/design-patterns/type-erasure1.cpp][file:src/design-patterns/type-erasure1.cpp]]

#+BEGIN_SRC cpp 
  class A{
  public:
      std::string getName() const {
          return "class A";
      }
      void sayA(){
          std::cout << "I am the class A" << "\n";
      }
  };

  class B{
  public:
      std::string getName() const  {
          return "class B";
      }
      void sayB(){
          std::cout << "I am the class B" << "\n";
      }	
  };

  class C{
  public:
      std::string getName() const  {
          return "class C";
      }
      void sayC() const {
          std::cout << "I am the class C" << "\n";
      }
  };
#+END_SRC

Solution: Type erasure design pattern. 

#+BEGIN_SRC cpp 
  class TypeErasure{
  private:
      //  --- Forward declarations ----
      class Concept;
      template<class T> class Model;

      // --- Member Variables ----- // 
      std::shared_ptr<Concept> _concept_ptr;
      // Optional: 
      // RTTI (runtime type information) for recovering wrapped type
      // by downcasting 
      const std::type_info& _tinfo;
  public:
      template<typename T> 
      TypeErasure(const T& obj)
      : _concept_ptr(std::make_shared<Model<T>>(obj))
      ,_tinfo(typeid(T)) 
      {		
      }

      auto getName() const -> std::string {
              return _concept_ptr->getName();
      }

      // Recover reference to wrapped type 
      template<typename T>
      auto recover() -> T {		
          if(typeid(T) != _tinfo)
                  throw std::runtime_error("Error: cannot cast to this type");
          // Note: static_cast downcasting to wrong type has undefined behavior,
          // use with care!
          return static_cast<Model<T>*>(_concept_ptr.get())->_obj;
      }

      template<typename T>
      auto hasType() -> bool {
              return _tinfo == typeid(T);
      }
  private:
     // Concept class defines the interface to be enforced
     // In general, it is an interface class, a class with only pure virtual
     // methods (abstract methods), in other words methods without implementation.
     class Concept{
     public:
             virtual auto getName() const -> std::string = 0;
             virtual ~Concept() = default;
     };

     // Adapt the wrapped type (T) to the concept
     template<typename T>
     class Model: public Concept {
     public:
             // Instance of the wrapped type 
             T _obj;
             // Initialize _opj by copying the parameter 
             Model(const T& obj): _obj(obj){}
             auto getName() const -> std::string {
                     return _obj.getName();
             }
     };
  };

#+END_SRC

Testing in Cling REPL: 

#+BEGIN_SRC cpp 
  >> .L type-erasure1.cpp 
  >> 
  >> A()
  (A) @0x1fc2970
  >> A().getName()
  (std::string) "class A"
  >> B().getName()
  (std::string) "class B"
  >> 
  >> B().sayB()
  I am the class B
  >> 

  auto tlist = std::deque<TypeErasure>();
  tlist.emplace_back(A())
  tlist.emplace_back(B())
  tlist.emplace_back(C())
 
  >> for(const auto& t: tlist) { std::cout << "Class type = " << t.getName() << "\n"; }
  Class type = class A
  Class type = class B
  Class type = class C
  >> 

  >> tlist.at(0).recover<A>()
  (A) @0x20cc590
  >> tlist.at(0).recover<A>().sayA()
  I am the class A
  >> tlist.at(0).recover<A>().getName()
  (std::string) "class A"
  >> 

  >> tlist.at(1).recover<B>().getName()
  (std::string) "class B"
  >> 

  >> tlist.at(1).recover<C>()
  Error in <TRint::HandleTermInput()>: std::runtime_error caught: Error: cannot cast to this type
  >> 
#+END_SRC

Main function: 

#+BEGIN_SRC cpp 
   auto tlist = std::deque<TypeErasure>();
   tlist.emplace_back(A());
   tlist.emplace_back(B());
   tlist.emplace_back(C());

   std::cout << "\n" << "EXPERIMENT 1 ============" << "\n";	
   for(const auto& t: tlist) {
           std::cout << "Class type = " << t.getName() << "\n";
   }

    // Note: It is a copy!
    A objA = tlist.at(0).recover<A>();
    objA.sayA();

    std::cout << "\n" << "EXPERIMENT 2 ============" << "\n";

    // Simulate downcasting failure 
    try {
            B objB = tlist.at(0).recover<B>();
            objB.sayB();
    } catch(const std::runtime_error& ex){
            std::cout << " [FAILURE]" << ex.what() << "\n";
    }

    B objB = tlist.at(1).recover<B>();
    objB.sayB();

    auto objC = tlist.at(2).recover<C>();
    objC.sayC();
#+END_SRC

Compiling and running: (File: [[file:src/design-patterns/type-erasure1.cpp][file:src/design-patterns/type-erasure1.cpp]])

#+BEGIN_SRC cpp 
  $ clang++ type-erasure1.cpp -o type-erasure1.bin -g -std=c++1z -Wall -Wextra 
  $ ./type-erasure1.bin

  EXPERIMENT 1 ============
  Class type = class A
  Class type = class B
  Class type = class C
  I am the class A

  EXPERIMENT 2 ============
   [FAILURE]Error: cannot cast to this type
  I am the class B
  I am the class C
#+END_SRC


