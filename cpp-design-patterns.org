#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ Notes - Design Patterns 
#+DESCRIPTION: cpp/c++ c++ design patterns gneric programming object oriented metaprogramming
#+STARTUP: content 

* Design Patterns 
** Named constructor - static factory method

The named constructor or static factory design pattern uses static
methods instead of constructors for instantiating objects. This
approach has many advantages over constructor instantiation. Named
constructors are more readable than ordinary constructors and unlike
constructors, many named constructors static methods sharing the same
type signature can coexist. Another benefit is that this technique
allows objects to be instantiated in many different ways from several
different data representation.

Side note: It should not be confused with factory design pattern or
abstract factory design pattern.

Example:

#+BEGIN_SRC cpp   :results output pp :exports both 
  #include <iostream>
  #include <ostream>
  #include <cstdint>

  // #include <stdint>   // WARNING - It may not be available

  // Unsigned byte from 0 to 255 or 0x00 to 0xFF
  // ---> typedef uint8_t ubyte;
  using ubyte = uint8_t ; 

  class Color{
  private:
      ubyte m_r;
      ubyte m_g;
      ubyte m_b;
  public:
      Color(ubyte red, ubyte green, ubyte blue):
          m_r(red), m_g(green), m_b(blue) {}
      ubyte red(){
          return m_r;
      }
      ubyte blue(){
          return m_b;
      }
      ubyte green(){
          return m_g;
      }
      // Named constructor or static factory method which builds the object
      // From the RGB tuple data representation 
      static Color fromRGB(ubyte red, ubyte green, ubyte blue){
          return Color(red, green, blue);
      }
      // Named constructor which builds Color object 
      // from hexadecimal data representation 
      static Color fromHex(int color){
          int r = color & 0xFF;
          int g = (color >> 8 ) & 0xFF;
          int b = (color >> 16) & 0xFF;
          return Color(r, g, b);
      }
      // Named constructor which builds a specific color.
      static Color colorRED(){
          return fromRGB(255, 0, 0);
      }
      static Color colorBLUE(){
          return fromRGB(0, 255, 0);
      }
      static Color colorGREEN(){
          return fromRGB(0, 0, 255);
      }
      friend std::ostream& operator <<(std::ostream& os, const Color& c){
          os << "Color(r = "
             << static_cast<int>(c.m_r)
             << ", g = " << static_cast<int>(c.m_g)
             << ", b = " << static_cast<int>(c.m_b) << ")";
          return os;
      }      
  };

  int main(){
      std::cout << "Red    = " << Color::colorRED()   << "\n";
      std::cout << "Blue   = " << Color::colorBLUE()  << "\n";
      std::cout << "Green  = " << Color::colorGREEN() << "\n";
      std::cout << "Color1 = " << Color::fromRGB(20, 90, 200) << "\n";
      std::cout << "Color2 = " << Color::fromHex(0xFF8AB5) << "\n";
      std::cout.flush();
      return 0;
  }
#+END_SRC

#+RESULTS:
: Red    = Color(r = 255, g = 0, b = 0)
: Blue   = Color(r = 0, g = 255, b = 0)
: Green  = Color(r = 0, g = 0, b = 255)
: Color1 = Color(r = 20, g = 90, b = 200)
: Color2 = Color(r = 181, g = 138, b = 255)
** Singleton 

Singleton is a creational design pattern where there is only a single
instance of a class and client code is forbidden from creating new
instances.

Note: Despite that there are lots of objections against this design
pattern, it is still worth knowing how it works.

+ File: [[file:src/design-patterns/singleton1.cpp][file:src/design-patterns/singleton1.cpp]]

#+BEGIN_SRC cpp
   class FileRepository
   {
   private:
       std::deque<std::string> _files;	
       // Forbid client code instating a new instance. 
       FileRepository(){}	
       // Forbid client code from creating a copy or using the
       // copy constructor.
       FileRepository(const FileRepository&){}
   public:
       // Return a reference to not allow client code 
       // to delete object. 
       static auto getInstance() -> FileRepository& {
           // Initialized once - lazy initialization 
           static auto _instance = std::unique_ptr<FileRepository>(new FileRepository);
           return *_instance.get();
       }
       void addFile(std::string fname){
           _files.push_back(fname);
       }
       void clearFiles(){
               _files.clear();
       }
       // C++11 member function declaration looks better. 
       auto showFiles() -> void {
           for(const auto& file: _files){
               std::cout << " File = " << file << "\n";
           }
       }
   };
#+END_SRC

Test in CERN ROOT/Clign REPL:

#+BEGIN_SRC cpp 
   // Load C++ code as it was a script.
   >> .L singleton1.cpp

   // Try to instantiate singleton object without reference. 
   //------------------------------------------------------
   >> FileRepository repo = FileRepository::getInstance()
   ROOT_prompt_2:1:23: error: calling a private constructor of class 'FileRepository'
   FileRepository repo = FileRepository::getInstance()
                         ^
   singleton1.cpp:21:5: note: declared private here
       FileRepository(const FileRepository&){}
       ^
   >> FileRepository& repo = FileRepository::getInstance()
   (FileRepository &) @0x2fc9640
   >> 

   >> FileRepository& repo = FileRepository::getInstance()
   (FileRepository &) @0x2fc9640
   >> 

   >> repo.showFiles()
   >> 
   >> repo.addFile("quarterly-sales-report.dat")
   >> repo.addFile("interest-payments.txt")
   >> repo.addFile("taxes-report.xls")
   >> repo.showFiles()
    File = quarterly-sales-report.dat
    File = interest-payments.txt
    File = taxes-report.xls
   >> 
   >> 

   // Try to copy object. 
   >> FileRepository r = repo;
   ROOT_prompt_9:1:20: error: calling a private constructor of class 'FileRepository'
   FileRepository r = repo;
                      ^
   singleton1.cpp:21:5: note: declared private here
       FileRepository(const FileRepository&){}
       ^
   >> 

   // Try to create a new object 
   >> FileRepository& repo2 = FileRepository::getInstance()
   (FileRepository &) @0x2fc9640
   >> repo2.showFiles()
    File = quarterly-sales-report.dat
    File = interest-payments.txt
    File = taxes-report.xls
   >> 

   // Check whether repo and repo2 are the same object (reference equality)
   // -> They are equal under reference equality criteria if they have the same address.
   >> &repo == &repo2
   (bool) true
   >> 
#+END_SRC

Main function: 

#+BEGIN_SRC cpp
  FileRepository& repo1 = FileRepository::getInstance();
  repo1.addFile("CashFlowStatement.txt");
  repo1.addFile("Balance-Sheet.dat");
  repo1.addFile("Sales-Report.csv");

  FileRepository& repo2 = FileRepository::getInstance();

  std::cout << std::boolalpha << "Same object? (&repo == &repo1 ?) = "
            << (&repo1 == &repo2)
            << "\n";
  std::cout << "Repository files" << std::endl;
  repo2.showFiles();

  std::cout << "Add more files" << std::endl;
  repo2.addFile("fileX1.pdf");
  repo2.addFile("fileX2.pdf");
  repo2.addFile("fileX3.pdf");
  repo2.showFiles();
#+END_SRC

Compiling and running ([[file:src/design-patterns/singleton1.cpp][file:src/design-patterns/singleton1.cpp]]): 

#+BEGIN_SRC txt 
  $ clang++ singleton1.cpp -o singleton1.bin -g -std=c++1z -Wall -Wextra 
  $ ./singleton1.bin

  Same object? (&repo == &repo1 ?) = true
  Repository files
   File = CashFlowStatement.txt
   File = Balance-Sheet.dat
   File = Sales-Report.csv
  Add more files
   File = CashFlowStatement.txt
   File = Balance-Sheet.dat
   File = Sales-Report.csv
   File = fileX1.pdf
   File = fileX2.pdf
   File = fileX3.pdf
#+END_SRC

** Interface Class 
*** Overview  

Unlike C# and Java, C++ doesn't have any keyword for implementing
interface, however it can be implemented by creating a class with only
pure virtual functions, in other words, only abstract methods or
methods without implementation. 

The interface class has a runtime overhead due to the virtual methods
that are resolved at runtime. An alternative solution when the virtual
methods calls performance overhead is not acceptable, is to use
generic programming or templates which doesn't have runtime cost since
the methods to be called are resolved at compile-time.

Note: 
 + The annotation *virtual* - means that the method (member function)
   can be overriden by the derived class. Methods in the base class
   not annotated as virtual cannot be overriden in the derived
   classes. Unlike Java, C++ methods are not virtual by default. 

 + The annotation (=0) - means a pure virtual member function, aka
   pure virtual function which is an _abstract method_, method without
   implementation. 

 *Example*: Interface Class Declaration: 

#+BEGIN_SRC cpp 
  class IStack{
  public:
      virtual ~IStack() = default;
      virtual int    size()         const = 0;
      virtual void   push(double x)       = 0;
      virtual double pop()                = 0;
      virtual double peek()         const = 0;
  };
#+END_SRC

Or: 

#+BEGIN_SRC cpp 
  struct IStack{
      virtual ~IStack() = default;
      virtual int    size()         const = 0;
      virtual void   push(double x)       = 0;
      virtual double pop()                = 0;
      virtual double peek()         const = 0;
  };
#+END_SRC

Or using C++ auto keyword for functions: 

#+BEGIN_SRC cpp 
  struct IStack{
      virtual ~IStack() = default;
      virtual auto size() const   -> int    = 0;
      virtual auto push(double x) -> void   = 0;
      virtual auto pop()          -> double = 0;
      virtual auto peek() const   -> double = 0;
  };
#+END_SRC
*** Example 

 *Complete Code Example*
 - File:  [[file:src/design-patterns/interface-class.cpp][file:src/design-patterns/interface-class.cpp]]

Interface class declaration:

#+BEGIN_SRC cpp 
  // Interface Stack. (Should be placed in the header file.) 
  class IStack{
  public:
          virtual ~IStack() = default;
          virtual int    size()         const = 0;
          virtual void   push(double x)       = 0;
          virtual double pop()                = 0;
          virtual double peek()         const = 0;
  };
#+END_SRC

Example: Interface implementations. 

 - Implementation of interface IStack using vector as internal
   representation.

#+BEGIN_SRC cpp 
  class StackVector: public IStack{
  public:
          StackVector(){}
          StackVector(const std::initializer_list<double>& xs){
                  _stack.insert(_stack.begin(), xs.begin(), xs.end());
          }
          int size() const {
                  return _stack.size();
          }	
          void push(double x){
                  _stack.push_back(x);
          }   
          double pop(){
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");
                  double top = _stack.back();
                  _stack.pop_back();
                  return top;
          }
          double peek() const {
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");		
                  return _stack.back();
          }
  private:
          std::vector<double> _stack{};
  };
#+END_SRC

 - Implementation using deque as internal representation:

#+BEGIN_SRC cpp 
  class StackDeque: public IStack{
  public:
          StackDeque(){}
          StackDeque(const std::initializer_list<double>& xs){
                  _stack.insert(_stack.begin(), xs.begin(), xs.end());
          }	
          int size() const {
                  return _stack.size();
          }	
          void push(double x){
                  _stack.push_back(x);
          }   
          double pop(){
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");
                  double top = _stack.back();
                  _stack.pop_back();
                  return top;
          }
          double peek() const {
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");		
                  return _stack.back();
          }
  private:
          std::deque<double> _stack{};
  };
#+END_SRC

 - Sample client code: 

#+BEGIN_SRC cpp 

  auto stack_sum(IStack& s) -> double{
          //std::cerr << " ==> stack_sum for references" << std::endl;
          double sum = 0.0;
          if(s.size() == 0)
                  return sum;
          while(s.size() != 0)
                  sum += s.pop();
          return sum;
  }

  auto stack_sum(IStack* s) -> double{
          // std::cerr << " ==> stack_sum for pointers" << std::endl;
          double sum = 0.0;
          if(s->size() == 0)
                  return sum;
          while(s->size() != 0)
                  sum += s->pop();
          return sum;
  }
#+END_SRC

Function main: 

#+BEGIN_SRC cpp 
   StackVector sv = {1.0, 2.0, 3.0, 5.0, 6.0};
   StackDeque  sd = {1.0, 2.0, 3.0, 5.0, 6.0};
   // The same client code works with any implementation of the interface. 
   std::cout << "stack_sum(sv) = " << stack_sum(sv) << std::endl;
   std::cout << "stack_sum(sd) = " << stack_sum(sd) << std::endl;

   IStack* spointer = nullptr;
   StackVector sv2 = {1.0, 2.0, 3.0, 5.0, 6.0};
   StackDeque  sd2 = {1.0, 2.0, 3.0, 5.0, 6.0};
   spointer = &sv2;
   std::cout << "stack_sum(spointer) = " << stack_sum(spointer) << std::endl;
   spointer = &sd2;
   std::cout << "stack_sum(spointer) = " << stack_sum(spointer) << std::endl;

   auto sptr = std::unique_ptr<IStack, std::function<void (IStack*)>>{
           nullptr,
           // Custom deleter 
           [](IStack* p){
                   std::cerr << " ==== Stack deleted OK" << std::endl ;
                   delete p;
           }
   };
   sptr.reset(new StackVector());
   sptr->push(10);
   sptr->push(25.0);
   sptr->push(20.0);
   std::cout << "stack_sum(sptr) = " << stack_sum(*sptr) << std::endl;
   sptr.reset(new StackDeque());
   sptr->push(10);
   sptr->push(25.0);
   sptr->push(20.0);
   std::cout << "stack_sum(sptr) = " << stack_sum(*sptr) << std::endl;
#+END_SRC

Compiling Running: 

#+BEGIN_SRC txt 
   $ clang++ interface-class.cpp -o interface-class.bin -g -std=c++1z -Wall -Wextra 
   $ ./interface-class.bin
   stack_sum(sv) = 17
   stack_sum(sd) = 17
   stack_sum(spointer) = 17
   stack_sum(spointer) = 17
   stack_sum(sptr) = 55
    ==== Stack deleted OK
   stack_sum(sptr) = 55
    ==== Stack deleted OK
#+END_SRC

References and further reading: 
 + [[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Interface_Class][More C++ Idioms/Interface Class - Wikibooks, open books for an open world]]
 + [[https://accu.org/index.php/journals/269][ACCU - Separating Interface and Implementation in C++]]
 + [[https://www.boost.org/doc/libs/1_63_0/libs/smart_ptr/sp_techniques.html][Smart Pointer Programming Techniques - 1.63.0]]
** Builder Design Pattern (Joshua Blosh)

The purpose of the builder design pattern proposed by Joshua Bloch is
to simplify the instantiation of objects with many constructor
parameters or many optional parameters. Note: it should not be
confused with the GOF (Gang of Four) builder pattern.

Example: 

 - File: builder.cpp 

#+BEGIN_SRC cpp 
  // Joshua Bloch's Builder Pattern for simplifying the instantiation
  // of objects with many constructor parameters. It is not the
  // GOF (Gang of Four) builder pattern. 
  #include <iostream>
  #include <string>

  // Function meta object 
  class UserData{
  public:
          using ulong = unsigned long;
  private:
          ulong          _userID = 0;
          std::string    _name;
          std::string    _lastName;
          std::string    _email;
          UserData() = default;
  public:
          // Explicit is better than implicit 
          ~UserData() = default;
	
          auto show() -> void
          {
              std::cout << "\nUser{"
                        << "\n" << "  id        = " << _userID
                        << "\n" << "  name      = " << _name
                        << "\n" << "  last name = " << _lastName
                        << "\n" << "  email     = " << _email
                        << "\n" << "}"
                        << "\n";
          }
	
          // Allow builder class access UserData's private data
          friend class UserBuilder;
  }; //--- EoF class UserData --- //

  class UserBuilder{
  private:
          //class UserData;
          UserData _data{};
  public:
          UserBuilder(){
                  // _data = UserData();
          }		
          auto setID(ulong userID ) -> UserBuilder& {
             _data._userID = userID;
             return *this;
          }
          auto setName(const std::string& name) -> UserBuilder& {
              _data._name = name;
              return *this;
          }
          auto setLastName(const std::string& name) -> UserBuilder& {
              _data._lastName = name;
              return *this;
          }
          auto setEmail(const std::string& email) -> UserBuilder& {
             _data._email = email;
             return *this;
          }
          auto build() -> UserData {
             return this->_data;
          }
  }; //--- EoF class UserData::builder --- //

  int main(){
      auto user0 =
              UserBuilder()
              .setID(2065)
              .setName("John")
              .setLastName("Von Neumman")
              .setEmail("nx098774a@sknmap.co")
              .build();
      auto user1 =
              UserBuilder()
              .setID(1065)
              .setName("Enrico")
              .setLastName("Fermi")
              .setEmail("dummyEmail@service1.co.uk")
              .build();
      auto user2 =
              UserBuilder()
              .setID(2001)
              .setName("Stanislaw")
              .setLastName("Ulam")
              .setEmail("wsx752@couk.com.sk")
              .build();
      user0.show();
      user1.show();		
      user2.show();
      return EXIT_SUCCESS;
  }
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   $ g++ builder.cpp -o builder.bin -g -std=c++1z -Wall -Wextra && ./builder.bin
   User{
     id        = 2065
     name      = John
     last name = Von Neumman
     email     = nx098774a@sknmap.co
   }

   User{
     id        = 1065
     name      = Enrico
     last name = Fermi
     email     = dummyEmail@service1.co.uk
   }

   User{
     id        = 2001
     name      = Stanislaw
     last name = Ulam
     email     = wsx752@couk.com.sk
   }
#+END_SRC
** Method Chaining - Fluent API

#+BEGIN_SRC cpp 
  class CharacterSuperMutant{
  private:
      double m_x;
      double m_y;
      double m_z;
  public:
      CharacterSuperMutant& setX(double x){
          m_x = x;
          return *this;
      }
      CharacterSuperMutant& setPosition(double x, double y, double z);
      auto setColor(COLOR color){
          ... ....
          return *this;
      }
      // C++ 11 
      auto setForce(double force) -> CharacterSuperMutant& {
          ... ... 
          return *this;
      }   
  };

  CharacterSuperMutant& CharacterSuperMutant::setPosition(double x, double y, double z){
          m_x = x; m_y = y; m_z  = z;
          return *this;
  }

#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
  CharacterSuperMutant mutant1;
  mutant1.setForce(1000).setColor(BLUE).setPosition(x).show();

  // Instead of:
  mutant1.setForce(1000)
  mutant1.setColor(BLUE)
  mutant1.setPosition(x)
#+END_SRC

** GOF - Template Pattern 

It is stated by GOF as: "Defines the skeleton of an algorithm in a
method, deferring some steps to subclasses. Template Method lets
subclasses redefine certain steps of an algorithm without changing the
algorithms structure."

 + Intent: Create an algorithm template that allows redefine some
   steps without changing its structure.

The parent abstract class has four different types of methods:
 + _Concrete methods_: Methods implemented in the abstract class.

 + _Abstract methods_: Methods without implementation that must be
   implemented by subclasses.

 + _Hook methods_: Methods with default implementation that can be
   overriden by subclasses.

 + _Template methods_: Method that calls concrete methods, abstract
   methods or hook methods.

Participants: 
 + _Base Class_: Defines an algorithm which calls primitive methods (aka
   hook methods) that will be defined by the derived classes.
 + _Derived Class_: Implements primitive methods (virtual methods or
   methods that can be overriden) defined in the _base class_.

Features: 
 + The base class defines an algorithm stub, however some steps are
   required to be implemented by the derived class.
 + This pattern provides an _inverse control structure_, the algorithm
   defined in the base class which calls the primitive methods which
   are algorithm steps declared in the base class.
 + This pattern can be the base of an framework. 

Example: 

#+BEGIN_SRC cpp 
  class IntervalSummation{
  public:
   // Algorithm or entry point which calls the derived class method.
   // This is the template method 
   double summation(int lower, int upper) const{
           double sum = 0;
           for(int i = lower; i <= upper; i++)
                   sum += this->stepFn(i);
           return sum; 
   }
  protected:
      // Hook method or to be defined by the derived class
      virtual double stepFn(double x) const = 0 ;
  };

  class SumOfSquares: public IntervalSummation{
  private:
      double stepFn(double x) const { return x * x; }
  };

  class SumOfCubes: public IntervalSummation{
  private:
      double stepFn(double x) const { return x * x * x; }
  };

  void clientCode(const IntervalSummation& obj){
      std::cout << "Summation at [0, 15] = " << obj.summation(0, 15) << std::endl;
  }

#+END_SRC

Running in CERN's ROOT REPL:

#+BEGIN_SRC sh 
  >> sq.summation(0, 10)
  (double) 385.00000

  >> sc.summation(0, 10)
  (double) 3025.0000

  >> clientCode(sq)
  Summation at [0, 15] = 1240

  >> clientCode(sc)
  Summation at [0, 15] = 14400
  >> 
#+END_SRC

References: 

 + Template Method, Factory Method, and Composite. -
   <http://condor.depaul.edu/cjones1/depaul/se455/notes/lecture07.pdf>
 + Template Method - <http://cs.unb.ca/~wdu/cs4015/ch5k.pdf>
 + Encapsulating Algorithms with the Template Method Design Pattern -
   <https://redlich.net/pdf/publications/jupitermedia/template.pdf>
 + Template Method Design Pattern in Java -
   <https://www.journaldev.com/1763/template-method-design-pattern-in-java>

** Null-Object Pattern 

An object, called nulll object, which doesn't do anything and has
empty methods implementing a required interface by the client code is
used to convey the absense of an ordinary object instead of null or
null pointer.

Example: in a database system, instead of returning null, null
reference or null pointer for an not found employee object, an empty
object, called null object, with an empty mehtods is returned. It has
the advantage of avoiding null exception that can crash unexpectdely a
program. Another problem of null or null pointers is that null bugs
cannot be caught at compile-time and are also known to be hard to
debug and trace.

Alternatives: 
 + Throw an exception when there is the absense of an object. For
   instance, std::runtime_error("Error: record not found.").
 + Use optional type (Haskell's maybe) or C++17 Optional.
 + Return a pointer that is set to null for denoting the absence of an
   object. This pattern is widely used by many C and C++
   codes. However it is prone for the infamous null pointer exception
   problems. 

#+BEGIN_QUOTE
  A Null Object provides a surrogate for another object that shares
  the same interface but does nothing. Thus, the Null Object
  encapsulates the implementation decisions of how to do nothing and
  hides those details from its collaborators.
    -- Bobby Woolf in [PLoP3]
#+END_QUOTE

Code Example:

#+BEGIN_SRC cpp
  // Interface 
  class ICompany{
          virtual unsigned    getID() const       = 0;	
          virtual std::string getName() const     = 0;
          virtual void        showCompany() const = 0;
          virtual ~ICompany() = default;
  };

  class Company: public ICompany{
  public:
          Company(unsigned id, const std::string& name):
                  _name(name),
                  _id(id){
          }
          unsigned getID()      const { return _id; }
          std::string getName() const { return _name; }
          void showCompany() const {
                  std::cout << "Company is = " << _name << "\n";
          }	
          ~Company() = default;
  private:
          std::string _name;
          unsigned    _id;	
  };

  // Null object 
  // Returns this null object instead of returning a null pointer
  // when a givne company is not found in the database system.
  class NullCompany: public ICompany{
  public:
          unsigned getID()      const { return 0; }
          std::string getName() const { return ""; }
          void showCompany()    const {}		
  };
#+END_SRC

** PIMPL - Pointer to Implementation (C++ Only)

The PIMPL - Pointer to Implementation idiom, also known as compiler
firewall, is a widely used technique  in C++ for completly hiding class
private members in the public header file. This technique uses an
opaque pointer to an internal non declared class in the current header
file encapsulating all fields of the outer class.

Also known as: 
 + PIMPL - Pointer to Implementation
 + Compiler firewall idiom
 + Cheshire Cat

Motivation and Benefits: 

 + Reduce compilation time as the number of #include headers in the
   class header is not changed.

 + Makes the class data member in the public header really private.

 + Changing of private members of the class which are encapsulated in
   the opaque pointer class does not require recompilation of client
   code. This feature is very important for library development as it
   avoid client code recompilation as the public headers are not
   changed.

 + Less likely to breaking binary compatibility - ABI Application
   Binary Interface.

 + Note: Changing class member variables or member functions (methods)
   breaks the ABI and requires the recompilation of client code. The
   pimpl maintains the binary compatibility by not changing class'
   private members.

 + TL;DR
   + PIMPL: Allow changes to implementation without the
     need to recompile client code.

Drawbacks: 

 + More complexity and work for API implementators.
 + Not convenient when there are protected members which needs to be
   accessed by subclasses. 
 + Runtime performance overhead due to the pointer indirection. 

Example: All private members of class CashFlow are conained in the
opaque type Impl which is not defined in the header file.

 - file: _CashFlow.h_  -> Class public interface.

#+BEGIN_SRC cpp 
  #ifndef _CashFlow_H_
  #define _CashFlow_H_

  // C++ 11's smart pointers
  #include <memory>

  class CashFlow{
  private:
      // Forward declaration of incomplete type.
      struct Impl;
      // This opaque type encapsulate the outer class' private member 
      // Pointer to implementation (PIMPL)
      std::unique_ptr<Impl> m_pimpl;
  public:
      // Default ctor 
      CashFlow();
      void show();
      void add(double x);
      int  size();
      // Net Present Value - NPV of cash flow for a given rate of return 
      double npv(double rate); 
      // Compute IRR - Internal rate of return 
      double irr(); 
  };

  #endif // --- EOF ---- // 
#+END_SRC

 - file: _CashFlow.cpp_  -> Class implementation.

#+BEGIN_SRC cpp 
  // C++ 11's smart pointers
  #include <memory>
  #include "CashFlow.h"

  // Struct is just class with all members
  // public by default 
  struct CashFlow::Impl{
      // cash flow vector 
      std::vector<double> m_clf;
      // Default ctor 
      Impl(){}
      // Default dtor 
      ~Impl() = default;  
  };

  // Default ctor 
  CashFlow::~CashFlow = default;
  // Ctor 
  CashFlow::CashFlow(): m_pimpl(new Impl()) {}

  void CashFlow::add(double x){
      m_pimpl->m_clf.push_back(x);
  }

  double CashFlow::get(int i){
      return m_pimpl->m_clf[i];
  }
     ... ... ... .... 
#+END_SRC  

References and further: 

 + *Pimpl Idiom* - <>
 
 + *Best Friends: C++11 Move Semantics and Pimpl* -
   <https://www.embeddeduse.com/2016/05/30/best-friends-cpp11-move-semantics-and-pimpl/>

 + *Improving C++ Encapsulation with the Pimpl Idiom* -
   <https://visualstudiomagazine.com/articles/2012/11/29/the-pimpl-idiom-in-c-plus-plus.aspx> 

 + *Why every C++ developer should know about the pimpl idiom pattern* -
   <https://tonka2013.wordpress.com/2013/08/31/why-every-c-developer-should-know-about-the-pimpl-idiom-pattern/> 

 + *Passing Containing Parent to pimpl idiom implementation class* -
   http://www.sharprobotica.com/2010/04/passing-containing-parent-to-pimpl-idiom-implementation-class/

 + *Dive in to C++ and survive* -
   <https://www.embedded.com/print/4008235> 
 
 + *Modern and Lucid C++ Advanced for Professional Programmers* -
   <https://wiki.ifs.hsr.ch/CppAdvanced/files/lecture_12_advanced_library_design.pdf> 

** Type Erasure (C++ Only)
*** Overview  

Type erasure is a set of techniques for providing an uniform interface
for many different types by hiding the type information from the
client code. In C++ type erasure can be implemented with a combination
of object oriented programming and generic programming, in other
words, inheritance and templates. The fundamental building blocks of
this pattern are a base class, called _concept_, which provides the
uniform interface to the wrapped types and a derived templatized
class, called _model_, inherting the concept class which adapts the
wrapped type to the concept class. The inheritance allows any template
instantation of the model to be treated as it was the base class, thus
this approach hides the type information which can be later recovered
by downcasting the base class to the derived class.

 - Definition by Dave Abrahams and Aleksey Curtovoy in, *C++ Template*
   *Metaprogramming.*

#+BEGIN_QUOTE
  In its fullest expression, type erasure is the process of turning a
  wide variety of types with a common interface into one type with that
  same interface
#+END_QUOTE

Parts: 

 + *Concept class*
   - base class - definines the interface being enforced. 
 + *Model class*
   - templatized class inherting the concept class adpating the
     wrapped type to the concept class and holding an instance of the
     wrapped type. 
 + *Type Erasure class* (outter class)
   - Both the concept and model classes are private inner classes of
     the type erasure class.
   - The type erasure class takes an instance of the model class in the
     constructor.
   - This class stores a pointer variable to the concept class, but
     storing a pointer to the model class (dynamic polymorphism).
 + *Wrapped Type* or Objects 
   + Types wrapped by the model class wich will be erased. 

Use-cases: 

 + Create a common interface for many different types. 
 + Store wrapped types without a common base class in STL containers.
 + Store templatized classes in STL containers.
 + Implement dynamic or runtime polymorphism with value semantics.
 + Take advantage of the commonality of many unrelated classes without
   a common base class without modifying their source code. 

Known uses in C++ standard library: 

 + std::function (C++11, formber Boost.Function)

 + std::any (C++17, former Boost.Any)
   + A container which can store anything and the type of the stored
     object is not known at runtime. 

 + std::variant (C++17, former Boost.Variant)
   + Provides an interface for sum types or disjoint union or _visitor_ OO
     design pattern which is useful for manipulating abstract syntax
     tree, creating interpreters, tree data structures and fixed class
     hierarchies. 

 + void* - Void pointer in many C-APIs. 


References and further reading:
 + Nevin Liber, *Type Erasure*  <http://files.meetup.com/1455470/Type%20Erasure.pdf>
 + [[https://stackoverflow.com/questions/46041683/type-erasure-retrieving-value-type-check-at-compile-time][c++ - Type erasure: Retrieving value - type check at compile time - Stack Overflow]]
 + [[http://talesofcpp.fusionfenix.com/post-16/episode-nine-erasing-the-concrete][Episode Nine: Erasing the Concrete]]
 + [[https://codereview.stackexchange.com/questions/41879/concept-based-polymorphism][c++ - Concept based polymorphism - Code Review Stack Exchange]]
 + [[https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%2520Generic%2520Programming%2520with%2520Virtual%2520Concepts.pdf][Dynamic Programming with Virtual Concepts]]
 + [[https://www.reddit.com/r/cpp/comments/5epngi/type_erased_concepts/][Type erased concepts : cpp]]
 + [[http://www.cplusplus.com/articles/oz18T05o/][C++ type erasure - C++ Articles]]
 + [[https://blog.tartanllama.xyz/type-erasure-unified-call/][Type erasure with unified call syntax]]
 + [[http://www.sgh1.net/posts/cpp-type-erasure.md][My Internet Weblog - Type Erasure in C++]]
 + [[https://accu.org/index.php/journals/2424][ACCU - Polymorphism in C++ – A Type Compatibility View]]

*** Example 1 - Simple type erasure.

_Problem:_ Handle the classes A, B and C which don't have a common base
class using dynamic (aka runtime) polymorphism taking advantage of
their commonality, the method .getName(). Note: the source code of A,
B and C aren't allowed to be modified

 - Complete source code:
   + File: [[file:src/design-patterns/type-erasure1.cpp][file:src/design-patterns/type-erasure1.cpp]]

#+BEGIN_SRC cpp 
  class A{
  public:
      std::string getName() const {
          return "class A";
      }
      void sayA(){
          std::cout << "I am the class A" << "\n";
      }
  };

  class B{
  public:
      std::string getName() const  {
          return "class B";
      }
      void sayB(){
          std::cout << "I am the class B" << "\n";
      }	
  };

  class C{
  public:
      std::string getName() const  {
          return "class C";
      }
      void sayC() const {
          std::cout << "I am the class C" << "\n";
      }
  };
#+END_SRC

Solution: Type erasure design pattern. 

#+BEGIN_SRC cpp 
  class TypeErasure{
  private:
      //  --- Forward declarations ----
      class Concept;
      template<class T> class Model;

      // --- Member Variables ----- // 
      std::shared_ptr<Concept> _concept_ptr;
      // Optional: 
      // RTTI (runtime type information) for recovering wrapped type
      // by downcasting 
      const std::type_info& _tinfo;
  public:
      template<typename T> 
      TypeErasure(const T& obj)
      : _concept_ptr(std::make_shared<Model<T>>(obj))
      ,_tinfo(typeid(T)) 
      {		
      }

      auto getName() const -> std::string {
              return _concept_ptr->getName();
      }

      // Recover reference to wrapped type 
      template<typename T>
      auto recover() -> T {		
          if(typeid(T) != _tinfo)
                  throw std::runtime_error("Error: cannot cast to this type");
          // Note: static_cast downcasting to wrong type has undefined behavior,
          // use with care!
          return static_cast<Model<T>*>(_concept_ptr.get())->_obj;
      }

      template<typename T>
      auto hasType() -> bool {
              return _tinfo == typeid(T);
      }
  private:
     // Concept class defines the interface to be enforced
     // In general, it is an interface class, a class with only pure virtual
     // methods (abstract methods), in other words methods without implementation.
     class Concept{
     public:
             virtual auto getName() const -> std::string = 0;
             virtual ~Concept() = default;
     };

     // Adapt the wrapped type (T) to the concept
     template<typename T>
     class Model: public Concept {
     public:
             // Instance of the wrapped type 
             T _obj;
             // Initialize _opj by copying the parameter 
             Model(const T& obj): _obj(obj){}
             auto getName() const -> std::string {
                     return _obj.getName();
             }
     };
  };

#+END_SRC

Testing in Cling REPL: 

#+BEGIN_SRC cpp 
  >> .L type-erasure1.cpp 
  >> 
  >> A()
  (A) @0x1fc2970
  >> A().getName()
  (std::string) "class A"
  >> B().getName()
  (std::string) "class B"
  >> 
  >> B().sayB()
  I am the class B
  >> 

  auto tlist = std::deque<TypeErasure>();
  tlist.emplace_back(A())
  tlist.emplace_back(B())
  tlist.emplace_back(C())
 
  >> for(const auto& t: tlist) { std::cout << "Class type = " << t.getName() << "\n"; }
  Class type = class A
  Class type = class B
  Class type = class C
  >> 

  >> tlist.at(0).recover<A>()
  (A) @0x20cc590
  >> tlist.at(0).recover<A>().sayA()
  I am the class A
  >> tlist.at(0).recover<A>().getName()
  (std::string) "class A"
  >> 

  >> tlist.at(1).recover<B>().getName()
  (std::string) "class B"
  >> 

  >> tlist.at(1).recover<C>()
  Error in <TRint::HandleTermInput()>: std::runtime_error caught: Error: cannot cast to this type
  >> 
#+END_SRC

Main function: 

#+BEGIN_SRC cpp 
   auto tlist = std::deque<TypeErasure>();
   tlist.emplace_back(A());
   tlist.emplace_back(B());
   tlist.emplace_back(C());

   std::cout << "\n" << "EXPERIMENT 1 ============" << "\n";	
   for(const auto& t: tlist) {
           std::cout << "Class type = " << t.getName() << "\n";
   }

    // Note: It is a copy!
    A objA = tlist.at(0).recover<A>();
    objA.sayA();

    std::cout << "\n" << "EXPERIMENT 2 ============" << "\n";

    // Simulate downcasting failure 
    try {
            B objB = tlist.at(0).recover<B>();
            objB.sayB();
    } catch(const std::runtime_error& ex){
            std::cout << " [FAILURE]" << ex.what() << "\n";
    }

    B objB = tlist.at(1).recover<B>();
    objB.sayB();

    auto objC = tlist.at(2).recover<C>();
    objC.sayC();
#+END_SRC

Compiling and running: (File: [[file:src/design-patterns/type-erasure1.cpp][file:src/design-patterns/type-erasure1.cpp]])

#+BEGIN_SRC cpp 
  $ clang++ type-erasure1.cpp -o type-erasure1.bin -g -std=c++1z -Wall -Wextra 
  $ ./type-erasure1.bin

  EXPERIMENT 1 ============
  Class type = class A
  Class type = class B
  Class type = class C
  I am the class A

  EXPERIMENT 2 ============
   [FAILURE]Error: cannot cast to this type
  I am the class B
  I am the class C
#+END_SRC
** CRTP - Curious Recurring Template Pattern (C++ Only)
*** Overview 

It is a variation of GOF template design pattern where an algorithm
defined by the base class is customized or specified by the derived 
class. However, unlike the GOF one, this version uses C++ template
metaprogramming for emulating dynamic polymorphism or inheritance
at compile time. So it makes the code faster by eliminating virtual
function-calls.

Features: 
 + Coined by James Coplien - 1995
 + Static polymorphism technique based on template metaprogramming for
   speeding up the code eliminating virtual functions.

Use cases:
 + Reduce virtual function call overhead - by simulating dynamic
   polymorphism through static polymorphism. 
 + Implement state machines.
 + Implement high performance numerical libraries.
 + Code injection.

Libraries using this pattern:
 + Boost.Iterator
 + Boost.Python
 + Boost.Serialization 

Also known as: 
 + Code injection
 + Barton‐Nackman Trick
 + Mixin - Name used outside C++ community 

*** Example 

 *Approach 1 - GOF - OOP template pattern* 

 - Code 1: GOF Template method design pattern using virtual functions.

 #+BEGIN_SRC cpp 
   class IntervalSummation{
   public:
           // Algorithm or entry point which calls the derived class method.
           // This is the template method 
           double summation(int lower, int upper) const{
                   double sum = 0;
                   for(int i = lower; i <= upper; i++)
                           sum += this->stepFn(i);
                   return sum; 
           }
   protected:
           // Hook method or to be defined by the derived class
           virtual double stepFn(double x) const = 0 ;
   };

   class SumOfSquares: public IntervalSummation{
   private:
           double stepFn(double x) const { return x * x; }
   };

   class SumOfCubes: public IntervalSummation{
   private:
           double stepFn(double x) const { return x * x * x; }
   };

   void clientCode(const IntervalSummation& obj){
           std::cout << "Summation at [0, 15] = " << obj.summation(0, 15) << std::endl;
   }
#+END_SRC

  *Approach 2 - CRTP generic programming pattern* 

 - Code 2: Code rewritten using CRTP for eliminating virtual function
   calls. The advantage is that this code can run faster than the
   previous one, however the cost is the higher complexity, loss of
   readability and runtime polymorphism. For instance, now is not
   possible to store multiple implementations of IntervalSummation in
   a data structure or refer to them with the same pointer.

File: crtp.cpp 

#+BEGIN_SRC cpp
  #include <iostream>

  template<class Implementation>
  class IntervalSummation{
  public:
     double summation(int lower, int upper) const {
        double sum = 0;
        for(int i = lower; i <= upper; i++)
           sum += static_cast<Implementation const * const>(this)->stepFn(i);
        return sum; 
     }
  };

  class SumOfSquares: public IntervalSummation<SumOfSquares>{
  public:
       double stepFn(double x) const { return x * x; }
  };

  class SumOfCubes: public IntervalSummation<SumOfCubes>{
  public:
      double stepFn(double x) const { return x * x * x; }
  };

  template<class T>
  void clientCode(const IntervalSummation<T>& obj){
      std::cout << "Summation at [0, 15] = " << obj.summation(0, 15) << std::endl;
  }

  int main(){
     SumOfSquares sq;
     SumOfCubes   sc;
     std::cout << "Sum of squares in [0, 10] = " << sq.summation(0, 10) << std::endl;
     std::cout << "Sum of cubes   in [0, 10] = " << sc.summation(0, 10)   << std::endl;
     clientCode(sq);
     clientCode(sc);
     return 0;
  }
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ clang++ crtp.cpp -o crtp.bin -std=c++1z -Wall -Wextra  && ./crtp.bin
  Sum of squares in [0, 10] = 385
  Sum of cubes   in [0, 10] = 3025
  Summation at [0, 15] = 1240
  Summation at [0, 15] = 14400
#+END_SRC

References: 

 + [[https://www.codeproject.com/Tips/537606/Cplusplus-Prefer-Curiously-Recurring-Template-Patt][C++: Prefer Curiously Recurring Template Pattern (CRTP) to Template Pattern - CodeProject]]
 + [[https://mklimenko.github.io/english/2018/07/02/platform-dependent-crtp/][CRTP-based platform-dependent optimizations | GNSS C++ solutions]]
 + http://stevedewhurst.com/once_weakly/once-weakly20170328/once-weakly20170328.pdf
 + [[http://enki-tech.blogspot.com/2012/08/c11-generic-singleton.html][Enki :: Technical Blog: C++11: A generic Singleton]]
 + IDENTIFYING PROGRAMMING IDIOMS IN C++ GENERIC LIBRARIES -
   <https://etd.ohiolink.edu/rws_etd/document/get/kent1259116053/inline>
 + [[http://www.masaers.com/2014/01/22/CRTP-operator-hijacking.html][Using CRTP to easily hijack operators in c++11 | masaers’ blog]]
 + https://github.com/nojhan/crtp_functor_ttp
 + [[https://web.archive.org/web/20060211034709/http://devnet.developerpipeline.com/documents/s=9843/cuj0601diggins/][Developer::Pipelines | Building More Flexible Types with Mixins]]
 + [[https://accu.org/index.php/journals/296][ACCU :: Better Encapsulation for the Curiously Recurring Template Pattern]]
 + [[http://www.di.unipi.it/~nids/docs/templates_vs_inheritance.html][Replacing Virtual Methods with Templates]]
 + http://gsd.web.elte.hu/lectures/bolyai/2018/mixin_crtp/mixin_crtp.pdf
 + https://faithandbrave.hateblo.jp/entry/20071206/1196934096
 + [[https://nativecoding.wordpress.com/2015/06/05/virtual-methods-vs-crtp-benchmark-2/][Virtual Methods vs CRTP Benchmark – Native Coding]]
 + https://nativecoding.wordpress.com/2015/01/11/important-c-idioms/
 + http://barngoggles.com/visitor-with-crtp/

Best Links: 

 + https://nativecoding.wordpress.com/2015/01/11/important-c-idioms/
 + https://marcoarena.wordpress.com/2012/04/29/use-crtp-for-polymorphic-chaining/
 + http://thothonegan.tumblr.com/post/157363120503/crtp-curiously-recurring-template-pattern

Videos: 

 + Curiously Recurring Template Pattern (CRTP) -
   <https://www.youtube.com/watch?v=C3Pi5GlIfjs>

 + 

 + 
** Cross platform code with conditional compilation (C++ Only)

Note: It is not a design pattern, but a useful for techinque for
designing cross platform code in C++.

Macros are useful for writing cross-platform code by hiding and
isolating platform-specific details, such as specific hardware
registers address, compiler extensions, APIs and system calls. This
example shows how to use conditional compilation to write code which
can be compiled on an Unix-like operating system, such as Linux or OSX
and Windows.

Example: 

#+BEGIN_SRC cpp 
  // Scoped enum is used to identify the operating system the code 
  // was copiled against.
  enum class SystemType{
      WindowsNT,
      Linux,
      MacOSX,
      FreeBSD,
      Unknown
  };

  /**  Returns the current operating system that the 
    ,*  library was compiled against.
  ,*/
  auto getSystemType() -> SystemType {
       #ifdef __apple__
          return SystemType::MacOSX;
       #elif defined __linux__
          return SystemType::Linux;
       #elif defined _WIN32 || defined _WIN64
         return SystemType::WindowsNT;
       #else
         return SystemType::Unknown;
       #endif
  }

  auto getOperatingSystem() -> std::string {
       SystemType type = getSystemType();
       if (type == SystemType::Linux)
               return "Linux";
       else if(type == SystemType::MacOSX)
               return "MacOSX";
       else if(type == SystemType::WindowsNT)
               return "Windows NT";
       else if(type == SystemType::FreeBSD)
               return "FreeBSD";
       else
               return "Unknown operating system";
  }

  auto isWindows() -> bool {
      return getSystemType() == SystemType::WindowsNT;
  }

  // Check whether is U-N-I-X like 
  auto isNixLike() -> bool {
       auto t = getSystemType();
       return t == SystemType::Linux
               || t == SystemType::FreeBSD
               || t == SystemType::MacOSX;
  }

  /** Cross platform code for creating directory */
  void makeDirectory(std::string path){
       #if defined __linux__ || defined __apple__
      /** ==== U-NIX Specific code ==== */
          mkdir(path.c_str(), 0777);
       #elif _WIN32
      /** ==== Windows Specific Code ==== */
          CreateDirectoryA(path.c_str(), NULL);
       #endif
  }

  /** Get home directory, ~/ or $HOME on Unix or %USERPROFILE% 
   ,* environment variable on Windows 
   ,*/
  std::string getHomeDir(){
      if (getSystemType() == SystemType::WindowsNT)
         return getEnv("USERPROFILE");
       else
        return getEnv("HOME");
  }
#+END_SRC

