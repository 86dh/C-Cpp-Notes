#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ Notes - Design Patterns 
#+DESCRIPTION: cpp/c++ c++ design patterns gneric programming object oriented metaprogramming
#+STARTUP: content 

- [[wiki:index][Index]]

* Design Patterns 
** Named constructor - static factory method

The named constructor or static factory design pattern uses static
methods instead of constructors for instantiating objects. This
approach has many advantages over constructor instantiation. Named
constructors are more readable than ordinary constructors and unlike
constructors, many named constructors static methods sharing the same
type signature can coexist. Another benefit is that this technique
allows objects to be instantiated in many different ways from several
different data representation.

Side note: It should not be confused with factory design pattern or
abstract factory design pattern.

Example:

#+BEGIN_SRC cpp   :results output pp :exports both 
  #include <iostream>
  #include <ostream>
  #include <cstdint>

  // #include <stdint>   // WARNING - It may not be available

  // Unsigned byte from 0 to 255 or 0x00 to 0xFF
  // ---> typedef uint8_t ubyte;
  using ubyte = uint8_t ; 

  class Color{
  private:
      ubyte m_r;
      ubyte m_g;
      ubyte m_b;
  public:
      Color(ubyte red, ubyte green, ubyte blue):
          m_r(red), m_g(green), m_b(blue) {}
      ubyte red(){
          return m_r;
      }
      ubyte blue(){
          return m_b;
      }
      ubyte green(){
          return m_g;
      }
      // Named constructor or static factory method which builds the object
      // From the RGB tuple data representation 
      static Color fromRGB(ubyte red, ubyte green, ubyte blue){
          return Color(red, green, blue);
      }
      // Named constructor which builds Color object 
      // from hexadecimal data representation 
      static Color fromHex(int color){
          int r = color & 0xFF;
          int g = (color >> 8 ) & 0xFF;
          int b = (color >> 16) & 0xFF;
          return Color(r, g, b);
      }
      // Named constructor which builds a specific color.
      static Color colorRED(){
          return fromRGB(255, 0, 0);
      }
      static Color colorBLUE(){
          return fromRGB(0, 255, 0);
      }
      static Color colorGREEN(){
          return fromRGB(0, 0, 255);
      }
      friend std::ostream& operator <<(std::ostream& os, const Color& c){
          os << "Color(r = "
             << static_cast<int>(c.m_r)
             << ", g = " << static_cast<int>(c.m_g)
             << ", b = " << static_cast<int>(c.m_b) << ")";
          return os;
      }      
  };

  int main(){
      std::cout << "Red    = " << Color::colorRED()   << "\n";
      std::cout << "Blue   = " << Color::colorBLUE()  << "\n";
      std::cout << "Green  = " << Color::colorGREEN() << "\n";
      std::cout << "Color1 = " << Color::fromRGB(20, 90, 200) << "\n";
      std::cout << "Color2 = " << Color::fromHex(0xFF8AB5) << "\n";
      std::cout.flush();
      return 0;
  }
#+END_SRC

#+RESULTS:
: Red    = Color(r = 255, g = 0, b = 0)
: Blue   = Color(r = 0, g = 255, b = 0)
: Green  = Color(r = 0, g = 0, b = 255)
: Color1 = Color(r = 20, g = 90, b = 200)
: Color2 = Color(r = 181, g = 138, b = 255)
** Singleton 

Singleton is a creational design pattern where there is only a single
instance of a class and client code is forbidden from creating new
instances.

Note: Despite that there are lots of objections against this design
pattern, it is still worth knowing how it works.

+ File: [[file:src/design-patterns/singleton1.cpp][file:src/design-patterns/singleton1.cpp]]

#+BEGIN_SRC cpp
   class FileRepository
   {
   private:
       std::deque<std::string> _files;	
       // Forbid client code instating a new instance. 
       FileRepository(){}	
       // Forbid client code from creating a copy or using the
       // copy constructor.
       FileRepository(const FileRepository&){}
   public:
       // Return a reference to not allow client code 
       // to delete object. 
       static auto getInstance() -> FileRepository& {
           // Initialized once - lazy initialization 
           static auto _instance = std::unique_ptr<FileRepository>(new FileRepository);
           return *_instance.get();
       }
       void addFile(std::string fname){
           _files.push_back(fname);
       }
       void clearFiles(){
               _files.clear();
       }
       // C++11 member function declaration looks better. 
       auto showFiles() -> void {
           for(const auto& file: _files){
               std::cout << " File = " << file << "\n";
           }
       }
   };
#+END_SRC

Test in CERN ROOT/Clign REPL:

#+BEGIN_SRC cpp 
   // Load C++ code as it was a script.
   >> .L singleton1.cpp

   // Try to instantiate singleton object without reference. 
   //------------------------------------------------------
   >> FileRepository repo = FileRepository::getInstance()
   ROOT_prompt_2:1:23: error: calling a private constructor of class 'FileRepository'
   FileRepository repo = FileRepository::getInstance()
                         ^
   singleton1.cpp:21:5: note: declared private here
       FileRepository(const FileRepository&){}
       ^
   >> FileRepository& repo = FileRepository::getInstance()
   (FileRepository &) @0x2fc9640
   >> 

   >> FileRepository& repo = FileRepository::getInstance()
   (FileRepository &) @0x2fc9640
   >> 

   >> repo.showFiles()
   >> 
   >> repo.addFile("quarterly-sales-report.dat")
   >> repo.addFile("interest-payments.txt")
   >> repo.addFile("taxes-report.xls")
   >> repo.showFiles()
    File = quarterly-sales-report.dat
    File = interest-payments.txt
    File = taxes-report.xls
   >> 
   >> 

   // Try to copy object. 
   >> FileRepository r = repo;
   ROOT_prompt_9:1:20: error: calling a private constructor of class 'FileRepository'
   FileRepository r = repo;
                      ^
   singleton1.cpp:21:5: note: declared private here
       FileRepository(const FileRepository&){}
       ^
   >> 

   // Try to create a new object 
   >> FileRepository& repo2 = FileRepository::getInstance()
   (FileRepository &) @0x2fc9640
   >> repo2.showFiles()
    File = quarterly-sales-report.dat
    File = interest-payments.txt
    File = taxes-report.xls
   >> 

   // Check whether repo and repo2 are the same object (reference equality)
   // -> They are equal under reference equality criteria if they have the same address.
   >> &repo == &repo2
   (bool) true
   >> 
#+END_SRC

Main function: 

#+BEGIN_SRC cpp
  FileRepository& repo1 = FileRepository::getInstance();
  repo1.addFile("CashFlowStatement.txt");
  repo1.addFile("Balance-Sheet.dat");
  repo1.addFile("Sales-Report.csv");

  FileRepository& repo2 = FileRepository::getInstance();

  std::cout << std::boolalpha << "Same object? (&repo == &repo1 ?) = "
            << (&repo1 == &repo2)
            << "\n";
  std::cout << "Repository files" << std::endl;
  repo2.showFiles();

  std::cout << "Add more files" << std::endl;
  repo2.addFile("fileX1.pdf");
  repo2.addFile("fileX2.pdf");
  repo2.addFile("fileX3.pdf");
  repo2.showFiles();
#+END_SRC

Compiling and running ([[file:src/design-patterns/singleton1.cpp][file:src/design-patterns/singleton1.cpp]]): 

#+BEGIN_SRC txt 
  $ clang++ singleton1.cpp -o singleton1.bin -g -std=c++1z -Wall -Wextra 
  $ ./singleton1.bin

  Same object? (&repo == &repo1 ?) = true
  Repository files
   File = CashFlowStatement.txt
   File = Balance-Sheet.dat
   File = Sales-Report.csv
  Add more files
   File = CashFlowStatement.txt
   File = Balance-Sheet.dat
   File = Sales-Report.csv
   File = fileX1.pdf
   File = fileX2.pdf
   File = fileX3.pdf
#+END_SRC

** Interface Class 
*** Overview  

Unlike C# and Java, C++ doesn't have any keyword for implementing
interface, however it can be implemented by creating a class with only
pure virtual functions, in other words, only abstract methods or
methods without implementation. 

The interface class has a runtime overhead due to the virtual methods
that are resolved at runtime. An alternative solution when the virtual
methods calls performance overhead is not acceptable, is to use
generic programming or templates which doesn't have runtime cost since
the methods to be called are resolved at compile-time.

Note: 
 + The annotation *virtual* - means that the method (member function)
   can be overriden by the derived class. Methods in the base class
   not annotated as virtual cannot be overriden in the derived
   classes. Unlike Java, C++ methods are not virtual by default. 

 + The annotation (=0) - means a pure virtual member function, aka
   pure virtual function which is an _abstract method_, method without
   implementation. 

 *Example*: Interface Class Declaration: 

#+BEGIN_SRC cpp 
  class IStack{
  public:
      virtual ~IStack() = default;
      virtual int    size()         const = 0;
      virtual void   push(double x)       = 0;
      virtual double pop()                = 0;
      virtual double peek()         const = 0;
  };
#+END_SRC

Or: 

#+BEGIN_SRC cpp 
  struct IStack{
      virtual ~IStack() = default;
      virtual int    size()         const = 0;
      virtual void   push(double x)       = 0;
      virtual double pop()                = 0;
      virtual double peek()         const = 0;
  };
#+END_SRC

Or using C++ auto keyword for functions: 

#+BEGIN_SRC cpp 
  struct IStack{
      virtual ~IStack() = default;
      virtual auto size() const   -> int    = 0;
      virtual auto push(double x) -> void   = 0;
      virtual auto pop()          -> double = 0;
      virtual auto peek() const   -> double = 0;
  };
#+END_SRC
*** Example 

 *Complete Code Example*
 - File:  [[file:src/design-patterns/interface-class.cpp][file:src/design-patterns/interface-class.cpp]]

Interface class declaration:

#+BEGIN_SRC cpp 
  // Interface Stack. (Should be placed in the header file.) 
  class IStack{
  public:
          virtual ~IStack() = default;
          virtual int    size()         const = 0;
          virtual void   push(double x)       = 0;
          virtual double pop()                = 0;
          virtual double peek()         const = 0;
  };
#+END_SRC

Example: Interface implementations. 

 - Implementation of interface IStack using vector as internal
   representation.

#+BEGIN_SRC cpp 
  class StackVector: public IStack{
  public:
          StackVector(){}
          StackVector(const std::initializer_list<double>& xs){
                  _stack.insert(_stack.begin(), xs.begin(), xs.end());
          }
          int size() const {
                  return _stack.size();
          }	
          void push(double x){
                  _stack.push_back(x);
          }   
          double pop(){
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");
                  double top = _stack.back();
                  _stack.pop_back();
                  return top;
          }
          double peek() const {
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");		
                  return _stack.back();
          }
  private:
          std::vector<double> _stack{};
  };
#+END_SRC

 - Implementation using deque as internal representation:

#+BEGIN_SRC cpp 
  class StackDeque: public IStack{
  public:
          StackDeque(){}
          StackDeque(const std::initializer_list<double>& xs){
                  _stack.insert(_stack.begin(), xs.begin(), xs.end());
          }	
          int size() const {
                  return _stack.size();
          }	
          void push(double x){
                  _stack.push_back(x);
          }   
          double pop(){
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");
                  double top = _stack.back();
                  _stack.pop_back();
                  return top;
          }
          double peek() const {
                  if(this->size() == 0)
                          throw std::runtime_error("Error: stack is empty");		
                  return _stack.back();
          }
  private:
          std::deque<double> _stack{};
  };
#+END_SRC

 - Sample client code: 

#+BEGIN_SRC cpp 

  auto stack_sum(IStack& s) -> double{
          //std::cerr << " ==> stack_sum for references" << std::endl;
          double sum = 0.0;
          if(s.size() == 0)
                  return sum;
          while(s.size() != 0)
                  sum += s.pop();
          return sum;
  }

  auto stack_sum(IStack* s) -> double{
          // std::cerr << " ==> stack_sum for pointers" << std::endl;
          double sum = 0.0;
          if(s->size() == 0)
                  return sum;
          while(s->size() != 0)
                  sum += s->pop();
          return sum;
  }
#+END_SRC

Function main: 

#+BEGIN_SRC cpp 
   StackVector sv = {1.0, 2.0, 3.0, 5.0, 6.0};
   StackDeque  sd = {1.0, 2.0, 3.0, 5.0, 6.0};
   // The same client code works with any implementation of the interface. 
   std::cout << "stack_sum(sv) = " << stack_sum(sv) << std::endl;
   std::cout << "stack_sum(sd) = " << stack_sum(sd) << std::endl;

   IStack* spointer = nullptr;
   StackVector sv2 = {1.0, 2.0, 3.0, 5.0, 6.0};
   StackDeque  sd2 = {1.0, 2.0, 3.0, 5.0, 6.0};
   spointer = &sv2;
   std::cout << "stack_sum(spointer) = " << stack_sum(spointer) << std::endl;
   spointer = &sd2;
   std::cout << "stack_sum(spointer) = " << stack_sum(spointer) << std::endl;

   auto sptr = std::unique_ptr<IStack, std::function<void (IStack*)>>{
           nullptr,
           // Custom deleter 
           [](IStack* p){
                   std::cerr << " ==== Stack deleted OK" << std::endl ;
                   delete p;
           }
   };
   sptr.reset(new StackVector());
   sptr->push(10);
   sptr->push(25.0);
   sptr->push(20.0);
   std::cout << "stack_sum(sptr) = " << stack_sum(*sptr) << std::endl;
   sptr.reset(new StackDeque());
   sptr->push(10);
   sptr->push(25.0);
   sptr->push(20.0);
   std::cout << "stack_sum(sptr) = " << stack_sum(*sptr) << std::endl;
#+END_SRC

Compiling Running: 

#+BEGIN_SRC txt 
   $ clang++ interface-class.cpp -o interface-class.bin -g -std=c++1z -Wall -Wextra 
   $ ./interface-class.bin
   stack_sum(sv) = 17
   stack_sum(sd) = 17
   stack_sum(spointer) = 17
   stack_sum(spointer) = 17
   stack_sum(sptr) = 55
    ==== Stack deleted OK
   stack_sum(sptr) = 55
    ==== Stack deleted OK
#+END_SRC

References and further reading: 
 + [[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Interface_Class][More C++ Idioms/Interface Class - Wikibooks, open books for an open world]]
 + [[https://accu.org/index.php/journals/269][ACCU - Separating Interface and Implementation in C++]]
 + [[https://www.boost.org/doc/libs/1_63_0/libs/smart_ptr/sp_techniques.html][Smart Pointer Programming Techniques - 1.63.0]]
** Builder Design Pattern (Joshua Blosh)

The purpose of the builder design pattern proposed by Joshua Bloch is
to simplify the instantiation of objects with many constructor
parameters or many optional parameters. Note: it should not be
confused with the GOF (Gang of Four) builder pattern.

Example: 

 - File: builder.cpp 

#+BEGIN_SRC cpp 
  // Joshua Bloch's Builder Pattern for simplifying the instantiation
  // of objects with many constructor parameters. It is not the
  // GOF (Gang of Four) builder pattern. 
  #include <iostream>
  #include <string>

  // Function meta object 
  class UserData{
  public:
          using ulong = unsigned long;
  private:
          ulong          _userID = 0;
          std::string    _name;
          std::string    _lastName;
          std::string    _email;
          UserData() = default;
  public:
          // Explicit is better than implicit 
          ~UserData() = default;
	
          auto show() -> void
          {
              std::cout << "\nUser{"
                        << "\n" << "  id        = " << _userID
                        << "\n" << "  name      = " << _name
                        << "\n" << "  last name = " << _lastName
                        << "\n" << "  email     = " << _email
                        << "\n" << "}"
                        << "\n";
          }
	
          // Allow builder class access UserData's private data
          friend class UserBuilder;
  }; //--- EoF class UserData --- //

  class UserBuilder{
  private:
          //class UserData;
          UserData _data{};
  public:
          UserBuilder(){
                  // _data = UserData();
          }		
          auto setID(ulong userID ) -> UserBuilder& {
             _data._userID = userID;
             return *this;
          }
          auto setName(const std::string& name) -> UserBuilder& {
              _data._name = name;
              return *this;
          }
          auto setLastName(const std::string& name) -> UserBuilder& {
              _data._lastName = name;
              return *this;
          }
          auto setEmail(const std::string& email) -> UserBuilder& {
             _data._email = email;
             return *this;
          }
          auto build() -> UserData {
             return this->_data;
          }
  }; //--- EoF class UserData::builder --- //

  int main(){
      auto user0 =
              UserBuilder()
              .setID(2065)
              .setName("John")
              .setLastName("Von Neumman")
              .setEmail("nx098774a@sknmap.co")
              .build();
      auto user1 =
              UserBuilder()
              .setID(1065)
              .setName("Enrico")
              .setLastName("Fermi")
              .setEmail("dummyEmail@service1.co.uk")
              .build();
      auto user2 =
              UserBuilder()
              .setID(2001)
              .setName("Stanislaw")
              .setLastName("Ulam")
              .setEmail("wsx752@couk.com.sk")
              .build();
      user0.show();
      user1.show();		
      user2.show();
      return EXIT_SUCCESS;
  }
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   $ g++ builder.cpp -o builder.bin -g -std=c++1z -Wall -Wextra && ./builder.bin
   User{
     id        = 2065
     name      = John
     last name = Von Neumman
     email     = nx098774a@sknmap.co
   }

   User{
     id        = 1065
     name      = Enrico
     last name = Fermi
     email     = dummyEmail@service1.co.uk
   }

   User{
     id        = 2001
     name      = Stanislaw
     last name = Ulam
     email     = wsx752@couk.com.sk
   }
#+END_SRC
** Strategy Design Pattern 
*** Overview  

Intent: A behavioral design pattern from GOF which allows the client
code to select and change an algorithm encapsulated as an object at
runtime.

Note: this design pattern is similar to a callback and can be
simplified with functional programming. 

 *Parts:*

 + _Context_:
   + Object that has a reference to an strategy objects and sets the
     strategy at runtime.
   + Resposibilities:
     + Set strategy
     + Change strategy
     + Invoke strategy

 + _IStrategy_: (Algorithm interface)
   + Strategt interface define the algorithm operations.

 + _Concrete strategy_.
   + Strategies objects or implementation of IStrategy class.
*** Example 

Code: 
 + File: [[file:src/design-patterns/strategy-pattern1.cpp][file:src/design-patterns/strategy-pattern1.cpp]]
 + Online Compiler: https://rextester.com/WQO93455

Strategy interface: 

#+BEGIN_SRC cpp 
  // Strategy interface 
  struct IStrategy{
    virtual ~IStrategy(){}
    // Essential: Algorithm encapsulated by strategy object 
    virtual auto compute(double x, double y) const -> double = 0;  
    // Optional: Provides strategy metadata 
    virtual auto name() const -> const std::string = 0;
    // Clone this object (Note: This is a virtual constructor)
    virtual auto clone() const -> IStrategy* = 0;
  };
#+END_SRC

Context Class: 
 - Selects and switch the strategy (aka algorithm).

#+BEGIN_SRC cpp 
  class Context{
  private: 
    std::unique_ptr<IStrategy> _strategy;
  public:
    Context()
      : _strategy{nullptr} { }
    Context(IStrategy* s)
      : _strategy{s} { }
    Context(const IStrategy& s)
      : _strategy{s.clone()} { }
    auto setStrategy(IStrategy* s){
      _strategy.reset(s);
    }
    auto setStrategy(const IStrategy& s){
      _strategy.reset(s.clone());
    }  
    auto compute(double x, double y) -> void {
      if(_strategy == nullptr)
        std::runtime_error("Error: strategy not set");
      double result = _strategy->compute(x, y);
      std::cout << " strategy = " << _strategy->name() << " "
                << "( x = " << x << " ; "
                << "y = " << y << " )"
                << "\n" ;
      std::cout << "Result = " << result << "\n";
    }
  };
#+END_SRC

Concrete strategies: 

 - add => algorithm which adds two numbers.

#+BEGIN_SRC cpp 
  class AddStrategy: public IStrategy {
  public:
    auto name() const -> const std::string{
      return "add";
    }
    auto compute(double x, double y) const -> double {
      return x + y;
    }
    auto clone() const -> IStrategy* {
      std::cerr << " [TRACE] AddStrategy => I was cloned" << "\n";
      return new AddStrategy(*this);
    }
  };
#+END_SRC

 + Multiplication 

#+BEGIN_SRC cpp 
  struct MulStrategy: public IStrategy {
  public:
    auto name() const -> const std::string{
      return "mul";
    }  
    double compute(double x, double y) const {
      return x + y;
    }
    auto clone() const -> IStrategy* {
      std::cerr << " [TRACE] MulStrategy => I was cloned" << "\n";
      return new MulStrategy(*this);
    }  
  };
#+END_SRC

 + Linear Combination: 

#+BEGIN_SRC cpp 
  struct LinearCombStrategy: public IStrategy {
    double a, b, c;
    LinearCombStrategy(double a, double b, double c)
      : a(a), b(b), c(c)
    {
    }
    auto name() const -> const std::string{
      return "Linear combination a * x + b * y + c";
    }    
    auto compute(double x, double y) const -> double{
      return a * x + b * y + c;
    }
    auto clone() const -> IStrategy* {
      std::cerr << " [TRACE] LinearCombStrategy => I was cloned" << "\n";
      return new LinearCombStrategy(*this);
    }  
  };
#+END_SRC

Main function: 

#+BEGIN_SRC cpp 
  Context ctx;
  std::cout << "==== Strategy = add ====" << "\n";
  ctx.setStrategy(new AddStrategy);
  ctx.compute(3.0, 4.0);

  std::cout << "==== Strategy = mul ====" << "\n";
  ctx.setStrategy(new MulStrategy);
  ctx.compute(3.0, 4.0);

  std::cout << "==== Strategy = Linear combination ====" << "\n";
  ctx.setStrategy(new LinearCombStrategy(5, 3, 4));
  ctx.compute(3.0, 4.0);

  std::cout << "==== Strategy = Linear combination [2] ====" << "\n";
  auto comb1 = LinearCombStrategy(6.0, 5.0, 10.0);
  // Copy stack-allocated object comb1 using the virtual constructor
  ctx.setStrategy(comb1);
  ctx.compute(5.0, 3.0);  

  std::cout << "==== Strategy = Linear combination [2] ====" << "\n";  
  // Copy stack-allocated temporary object comb1 using the virtual constructor
  // clone
  ctx.setStrategy(LinearCombStrategy{6.0, 5.0, 10.0});
  ctx.compute(2.0, 6.0);  
#+END_SRC

Output: 

#+BEGIN_SRC txt 
  $ clang++ strategy-pattern1.cpp -o strategy-pattern1.bin -g -std=c++1z -Wall -Wextra 
  $ ./strategy-pattern1.bin
  ==== Strategy = add ====
   strategy = add ( x = 3 ; y = 4 )
  Result = 7
  ==== Strategy = mul ====
   strategy = mul ( x = 3 ; y = 4 )
  Result = 7
  ==== Strategy = Linear combination ====
   strategy = Linear combination a * x + b * y + c ( x = 3 ; y = 4 )
  Result = 31
  ==== Strategy = Linear combination [2] ====
   [TRACE] LinearCombStrategy => I was cloned
   strategy = Linear combination a * x + b * y + c ( x = 5 ; y = 3 )
  Result = 55
  ==== Strategy = Linear combination [2] ====
   [TRACE] LinearCombStrategy => I was cloned
   strategy = Linear combination a * x + b * y + c ( x = 2 ; y = 6 )
  Result = 52

#+END_SRC

** Method Chaining - Fluent API

#+BEGIN_SRC cpp 
  class CharacterSuperMutant{
  private:
      double m_x;
      double m_y;
      double m_z;
  public:
      CharacterSuperMutant& setX(double x){
          m_x = x;
          return *this;
      }
      CharacterSuperMutant& setPosition(double x, double y, double z);
      auto setColor(COLOR color){
          ... ....
          return *this;
      }
      // C++ 11 
      auto setForce(double force) -> CharacterSuperMutant& {
          ... ... 
          return *this;
      }   
     
      // Method / member function declaration, the implemention is in a different file.
      CharacterSuperMutant& CharacterSuperMutant::setPosition(double x, double y, double z);

      // C++11 
      auto CharacterSuperMutant::setStamina(double x, double y, double z) -> CharacterSuperMutant&;
  };

  // Example: Method implemented separated from class declaration in .cpp file.
  CharacterSuperMutant& CharacterSuperMutant::setPosition(double x, double y, double z){
      m_x = x; m_y = y; m_z  = z;
      return *this;
  }

  // C++11 auto syntax 
  auto CharacterSuperMutant::setStamina(double x, double y, double z) -> CharacterSuperMutant& {
      // ... ... ... 
      return *this;
  }

#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
  CharacterSuperMutant mutant1;
  mutant1.setForce(1000).setColor(BLUE).setPosition(x).show();

  // Instead of:
  mutant1.setForce(1000)
  mutant1.setColor(BLUE)
  mutant1.setPosition(x)
#+END_SRC

** GOF - Template Pattern 

It is stated by GOF as: "Defines the skeleton of an algorithm in a
method, deferring some steps to subclasses. Template Method lets
subclasses redefine certain steps of an algorithm without changing the
algorithms structure."

 + Intent: Create an algorithm template that allows redefine some
   steps without changing its structure.

The parent abstract class has four different types of methods:
 + _Concrete methods_: Methods implemented in the abstract class.

 + _Abstract methods_: Methods without implementation that must be
   implemented by subclasses.

 + _Hook methods_: Methods with default implementation that can be
   overriden by subclasses.

 + _Template methods_: Method that calls concrete methods, abstract
   methods or hook methods.

Participants: 
 + _Base Class_: Defines an algorithm which calls primitive methods (aka
   hook methods) that will be defined by the derived classes.
 + _Derived Class_: Implements primitive methods (virtual methods or
   methods that can be overriden) defined in the _base class_.

Features: 
 + The base class defines an algorithm stub, however some steps are
   required to be implemented by the derived class.
 + This pattern provides an _inverse control structure_, the algorithm
   defined in the base class which calls the primitive methods which
   are algorithm steps declared in the base class.
 + This pattern can be the base of an framework. 

Example: 

#+BEGIN_SRC cpp 
  class IntervalSummation{
  public:
   // Algorithm or entry point which calls the derived class method.
   // This is the template method 
   double summation(int lower, int upper) const{
           double sum = 0;
           for(int i = lower; i <= upper; i++)
                   sum += this->stepFn(i);
           return sum; 
   }
  protected:
      // Hook method or to be defined by the derived class
      virtual double stepFn(double x) const = 0 ;
  };

  class SumOfSquares: public IntervalSummation{
  private:
      double stepFn(double x) const { return x * x; }
  };

  class SumOfCubes: public IntervalSummation{
  private:
      double stepFn(double x) const { return x * x * x; }
  };

  void clientCode(const IntervalSummation& obj){
      std::cout << "Summation at [0, 15] = " << obj.summation(0, 15) << std::endl;
  }

#+END_SRC

Running in CERN's ROOT REPL:

#+BEGIN_SRC sh 
  >> sq.summation(0, 10)
  (double) 385.00000

  >> sc.summation(0, 10)
  (double) 3025.0000

  >> clientCode(sq)
  Summation at [0, 15] = 1240

  >> clientCode(sc)
  Summation at [0, 15] = 14400
  >> 
#+END_SRC

References: 

 + Template Method, Factory Method, and Composite. -
   <http://condor.depaul.edu/cjones1/depaul/se455/notes/lecture07.pdf>
 + Template Method - <http://cs.unb.ca/~wdu/cs4015/ch5k.pdf>
 + Encapsulating Algorithms with the Template Method Design Pattern -
   <https://redlich.net/pdf/publications/jupitermedia/template.pdf>
 + Template Method Design Pattern in Java -
   <https://www.journaldev.com/1763/template-method-design-pattern-in-java>

** Null-Object Pattern 

An object, called nulll object, which doesn't do anything and has
empty methods implementing a required interface by the client code is
used to convey the absense of an ordinary object instead of null or
null pointer.

Example: in a database system, instead of returning null, null
reference or null pointer for an not found employee object, an empty
object, called null object, with an empty mehtods is returned. It has
the advantage of avoiding null exception that can crash unexpectdely a
program. Another problem of null or null pointers is that null bugs
cannot be caught at compile-time and are also known to be hard to
debug and trace.

Alternatives: 
 + Throw an exception when there is the absense of an object. For
   instance, std::runtime_error("Error: record not found.").
 + Use optional type (Haskell's maybe) or C++17 Optional.
 + Return a pointer that is set to null for denoting the absence of an
   object. This pattern is widely used by many C and C++
   codes. However it is prone for the infamous null pointer exception
   problems. 

#+BEGIN_QUOTE
  A Null Object provides a surrogate for another object that shares
  the same interface but does nothing. Thus, the Null Object
  encapsulates the implementation decisions of how to do nothing and
  hides those details from its collaborators.
    -- Bobby Woolf in [PLoP3]
#+END_QUOTE

Code Example:

#+BEGIN_SRC cpp
  // Interface 
  class ICompany{
          virtual unsigned    getID() const       = 0;	
          virtual std::string getName() const     = 0;
          virtual void        showCompany() const = 0;
          virtual ~ICompany() = default;
  };

  class Company: public ICompany{
  public:
          Company(unsigned id, const std::string& name):
                  _name(name),
                  _id(id){
          }
          unsigned getID()      const { return _id; }
          std::string getName() const { return _name; }
          void showCompany() const {
                  std::cout << "Company is = " << _name << "\n";
          }	
          ~Company() = default;
  private:
          std::string _name;
          unsigned    _id;	
  };

  // Null object 
  // Returns this null object instead of returning a null pointer
  // when a givne company is not found in the database system.
  class NullCompany: public ICompany{
  public:
          unsigned getID()      const { return 0; }
          std::string getName() const { return ""; }
          void showCompany()    const {}		
  };
#+END_SRC

** PIMPL - Pointer to Implementation (C++ Only)

The PIMPL - Pointer to Implementation idiom, also known as compiler
firewall, is a widely used technique  in C++ for completly hiding class
private members in the public header file. This technique uses an
opaque pointer to an internal non declared class in the current header
file encapsulating all fields of the outer class.

Also known as: 
 + PIMPL - Pointer to Implementation
 + Compiler firewall idiom
 + Cheshire Cat

Motivation and Benefits: 

 + Reduce compilation time as the number of #include headers in the
   class header is not changed.

 + Makes the class data member in the public header really private.

 + Changing of private members of the class which are encapsulated in
   the opaque pointer class does not require recompilation of client
   code. This feature is very important for library development as it
   avoid client code recompilation as the public headers are not
   changed.

 + Less likely to breaking binary compatibility - ABI Application
   Binary Interface.

 + Note: Changing class member variables or member functions (methods)
   breaks the ABI and requires the recompilation of client code. The
   pimpl maintains the binary compatibility by not changing class'
   private members.

 + TL;DR
   + PIMPL: Allow changes to implementation without the
     need to recompile client code.

Drawbacks: 

 + More complexity and work for API implementators.
 + Not convenient when there are protected members which needs to be
   accessed by subclasses. 
 + Runtime performance overhead due to the pointer indirection. 

Example: All private members of class CashFlow are conained in the
opaque type Impl which is not defined in the header file.

 - file: _CashFlow.h_  -> Class public interface.

#+BEGIN_SRC cpp 
  #ifndef _CashFlow_H_
  #define _CashFlow_H_

  // C++ 11's smart pointers
  #include <memory>

  class CashFlow{
  private:
      // Forward declaration of incomplete type.
      struct Impl;
      // This opaque type encapsulate the outer class' private member 
      // Pointer to implementation (PIMPL)
      std::unique_ptr<Impl> m_pimpl;
  public:
      // Default ctor 
      CashFlow();
      void show();
      void add(double x);
      int  size();
      // Net Present Value - NPV of cash flow for a given rate of return 
      double npv(double rate); 
      // Compute IRR - Internal rate of return 
      double irr(); 
  };

  #endif // --- EOF ---- // 
#+END_SRC

 - file: _CashFlow.cpp_  -> Class implementation.

#+BEGIN_SRC cpp 
  // C++ 11's smart pointers
  #include <memory>
  #include "CashFlow.h"

  // Struct is just class with all members
  // public by default 
  struct CashFlow::Impl{
      // cash flow vector 
      std::vector<double> m_clf;
      // Default ctor 
      Impl(){}
      // Default dtor 
      ~Impl() = default;  
  };

  // Default ctor 
  CashFlow::~CashFlow = default;
  // Ctor 
  CashFlow::CashFlow(): m_pimpl(new Impl()) {}

  void CashFlow::add(double x){
      m_pimpl->m_clf.push_back(x);
  }

  double CashFlow::get(int i){
      return m_pimpl->m_clf[i];
  }
     ... ... ... .... 
#+END_SRC  

References and further: 

 + *Pimpl Idiom* - <>
 
 + *Best Friends: C++11 Move Semantics and Pimpl* -
   <https://www.embeddeduse.com/2016/05/30/best-friends-cpp11-move-semantics-and-pimpl/>

 + *Improving C++ Encapsulation with the Pimpl Idiom* -
   <https://visualstudiomagazine.com/articles/2012/11/29/the-pimpl-idiom-in-c-plus-plus.aspx> 

 + *Why every C++ developer should know about the pimpl idiom pattern* -
   <https://tonka2013.wordpress.com/2013/08/31/why-every-c-developer-should-know-about-the-pimpl-idiom-pattern/> 

 + *Passing Containing Parent to pimpl idiom implementation class* -
   http://www.sharprobotica.com/2010/04/passing-containing-parent-to-pimpl-idiom-implementation-class/

 + *Dive in to C++ and survive* -
   <https://www.embedded.com/print/4008235> 
 
 + *Modern and Lucid C++ Advanced for Professional Programmers* -
   <https://wiki.ifs.hsr.ch/CppAdvanced/files/lecture_12_advanced_library_design.pdf> 

** Type Erasure (C++ Only)
*** Overview  

Type erasure is a set of techniques for providing an uniform interface
for many different types by hiding the type information from the
client code. In C++ type erasure can be implemented with a combination
of object oriented programming and generic programming, in other
words, inheritance and templates. The fundamental building blocks of
this pattern are a base class, called _concept_, which provides the
uniform interface to the wrapped types and a derived templatized
class, called _model_, inherting the concept class which adapts the
wrapped type to the concept class. The inheritance allows any template
instantation of the model to be treated as it was the base class, thus
this approach hides the type information which can be later recovered
by downcasting the base class to the derived class.

 - Definition by Dave Abrahams and Aleksey Curtovoy in, *C++ Template*
   *Metaprogramming.*

#+BEGIN_QUOTE
  In its fullest expression, type erasure is the process of turning a
  wide variety of types with a common interface into one type with that
  same interface
#+END_QUOTE

Parts: 

 + *Concept class*
   - base class - definines the interface being enforced. 
 + *Model class*
   - templatized class inherting the concept class adpating the
     wrapped type to the concept class and holding an instance of the
     wrapped type. 
 + *Type Erasure class* (outter class)
   - Both the concept and model classes are private inner classes of
     the type erasure class.
   - The type erasure class takes an instance of the model class in the
     constructor.
   - This class stores a pointer variable to the concept class, but
     storing a pointer to the model class (dynamic polymorphism).
 + *Wrapped Type* or Objects 
   + Types wrapped by the model class wich will be erased. 

Use-cases: 

 + Create a common interface for many different types. 
 + Store wrapped types without a common base class in STL containers.
 + Store templatized classes in STL containers.
 + Implement dynamic or runtime polymorphism with value semantics.
 + Take advantage of the commonality of many unrelated classes without
   a common base class without modifying their source code. 

Known uses in C++ standard library: 

 + std::function (C++11, formber Boost.Function)

 + std::any (C++17, former Boost.Any)
   + A container which can store anything and the type of the stored
     object is not known at runtime. 

 + std::variant (C++17, former Boost.Variant)
   + Provides an interface for sum types or disjoint union or _visitor_ OO
     design pattern which is useful for manipulating abstract syntax
     tree, creating interpreters, tree data structures and fixed class
     hierarchies. 

 + void* - Void pointer in many C-APIs. 


References and further reading:
 + Nevin Liber, *Type Erasure*  <http://files.meetup.com/1455470/Type%20Erasure.pdf>
 + [[https://stackoverflow.com/questions/46041683/type-erasure-retrieving-value-type-check-at-compile-time][c++ - Type erasure: Retrieving value - type check at compile time - Stack Overflow]]
 + [[http://talesofcpp.fusionfenix.com/post-16/episode-nine-erasing-the-concrete][Episode Nine: Erasing the Concrete]]
 + [[https://codereview.stackexchange.com/questions/41879/concept-based-polymorphism][c++ - Concept based polymorphism - Code Review Stack Exchange]]
 + [[https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%2520Generic%2520Programming%2520with%2520Virtual%2520Concepts.pdf][Dynamic Programming with Virtual Concepts]]
 + [[https://www.reddit.com/r/cpp/comments/5epngi/type_erased_concepts/][Type erased concepts : cpp]]
 + [[http://www.cplusplus.com/articles/oz18T05o/][C++ type erasure - C++ Articles]]
 + [[https://blog.tartanllama.xyz/type-erasure-unified-call/][Type erasure with unified call syntax]]
 + [[http://www.sgh1.net/posts/cpp-type-erasure.md][My Internet Weblog - Type Erasure in C++]]
 + [[https://accu.org/index.php/journals/2424][ACCU - Polymorphism in C++ – A Type Compatibility View]]

*** Example 1 - Simple type erasure.

_Problem:_ Handle the classes A, B and C which don't have a common base
class using dynamic (aka runtime) polymorphism taking advantage of
their commonality, the method .getName(). Note: the source code of A,
B and C aren't allowed to be modified

 - Complete source code:
   + File: [[file:src/design-patterns/type-erasure1.cpp][file:src/design-patterns/type-erasure1.cpp]]

#+BEGIN_SRC cpp 
  class A{
  public:
      std::string getName() const {
          return "class A";
      }
      void sayA(){
          std::cout << "I am the class A" << "\n";
      }
  };

  class B{
  public:
      std::string getName() const  {
          return "class B";
      }
      void sayB(){
          std::cout << "I am the class B" << "\n";
      }	
  };

  class C{
  public:
      std::string getName() const  {
          return "class C";
      }
      void sayC() const {
          std::cout << "I am the class C" << "\n";
      }
  };
#+END_SRC

Solution: Type erasure design pattern. 

#+BEGIN_SRC cpp 
  class TypeErasure{
  private:
      //  --- Forward declarations ----
      class Concept;
      template<class T> class Model;

      // --- Member Variables ----- // 
      std::shared_ptr<Concept> _concept_ptr;
      // Optional: 
      // RTTI (runtime type information) for recovering wrapped type
      // by downcasting 
      const std::type_info& _tinfo;
  public:
      template<typename T> 
      TypeErasure(const T& obj)
      : _concept_ptr(std::make_shared<Model<T>>(obj))
      ,_tinfo(typeid(T)) 
      {		
      }

      auto getName() const -> std::string {
              return _concept_ptr->getName();
      }

      // Recover reference to wrapped type 
      template<typename T>
      auto recover() -> T {		
          if(typeid(T) != _tinfo)
                  throw std::runtime_error("Error: cannot cast to this type");
          // Note: static_cast downcasting to wrong type has undefined behavior,
          // use with care!
          return static_cast<Model<T>*>(_concept_ptr.get())->_obj;
      }

      template<typename T>
      auto hasType() -> bool {
              return _tinfo == typeid(T);
      }
  private:
     // Concept class defines the interface to be enforced
     // In general, it is an interface class, a class with only pure virtual
     // methods (abstract methods), in other words methods without implementation.
     class Concept{
     public:
             virtual auto getName() const -> std::string = 0;
             virtual ~Concept() = default;
     };

     // Adapt the wrapped type (T) to the concept
     template<typename T>
     class Model: public Concept {
     public:
             // Instance of the wrapped type 
             T _obj;
             // Initialize _opj by copying the parameter 
             Model(const T& obj): _obj(obj){}
             auto getName() const -> std::string {
                     return _obj.getName();
             }
     };
  };

#+END_SRC

Testing in Cling REPL: 

#+BEGIN_SRC cpp 
  >> .L type-erasure1.cpp 
  >> 
  >> A()
  (A) @0x1fc2970
  >> A().getName()
  (std::string) "class A"
  >> B().getName()
  (std::string) "class B"
  >> 
  >> B().sayB()
  I am the class B
  >> 

  auto tlist = std::deque<TypeErasure>();
  tlist.emplace_back(A())
  tlist.emplace_back(B())
  tlist.emplace_back(C())
 
  >> for(const auto& t: tlist) { std::cout << "Class type = " << t.getName() << "\n"; }
  Class type = class A
  Class type = class B
  Class type = class C
  >> 

  >> tlist.at(0).recover<A>()
  (A) @0x20cc590
  >> tlist.at(0).recover<A>().sayA()
  I am the class A
  >> tlist.at(0).recover<A>().getName()
  (std::string) "class A"
  >> 

  >> tlist.at(1).recover<B>().getName()
  (std::string) "class B"
  >> 

  >> tlist.at(1).recover<C>()
  Error in <TRint::HandleTermInput()>: std::runtime_error caught: Error: cannot cast to this type
  >> 
#+END_SRC

Main function: 

#+BEGIN_SRC cpp 
   auto tlist = std::deque<TypeErasure>();
   tlist.emplace_back(A());
   tlist.emplace_back(B());
   tlist.emplace_back(C());

   std::cout << "\n" << "EXPERIMENT 1 ============" << "\n";	
   for(const auto& t: tlist) {
           std::cout << "Class type = " << t.getName() << "\n";
   }

    // Note: It is a copy!
    A objA = tlist.at(0).recover<A>();
    objA.sayA();

    std::cout << "\n" << "EXPERIMENT 2 ============" << "\n";

    // Simulate downcasting failure 
    try {
            B objB = tlist.at(0).recover<B>();
            objB.sayB();
    } catch(const std::runtime_error& ex){
            std::cout << " [FAILURE]" << ex.what() << "\n";
    }

    B objB = tlist.at(1).recover<B>();
    objB.sayB();

    auto objC = tlist.at(2).recover<C>();
    objC.sayC();
#+END_SRC

Compiling and running: (File: [[file:src/design-patterns/type-erasure1.cpp][file:src/design-patterns/type-erasure1.cpp]])

#+BEGIN_SRC cpp 
  $ clang++ type-erasure1.cpp -o type-erasure1.bin -g -std=c++1z -Wall -Wextra 
  $ ./type-erasure1.bin

  EXPERIMENT 1 ============
  Class type = class A
  Class type = class B
  Class type = class C
  I am the class A

  EXPERIMENT 2 ============
   [FAILURE]Error: cannot cast to this type
  I am the class B
  I am the class C
#+END_SRC
** CRTP - Curious Recurring Template Pattern (C++ Only)
*** Overview 

It is a variation of GOF template design pattern where an algorithm
defined by the base class is customized or specified by the derived 
class. However, unlike the GOF one, this version uses C++ template
metaprogramming for emulating dynamic polymorphism or inheritance
at compile time. So it makes the code faster by eliminating virtual
function-calls.

Features: 
 + Coined by James Coplien - 1995
 + Static polymorphism technique based on template metaprogramming for
   speeding up the code eliminating virtual functions.

Use cases:
 + Reduce virtual function call overhead - by simulating dynamic
   polymorphism through static polymorphism. 
 + Implement state machines.
 + Implement high performance numerical libraries.
 + Code injection.

Libraries using this pattern:
 + Boost.Iterator
 + Boost.Python
 + Boost.Serialization 

Also known as: 
 + Code injection
 + Barton‐Nackman Trick
 + Mixin - Name used outside C++ community 

*** Example 

 *Approach 1 - GOF - OOP template pattern* 

 - Code 1: GOF Template method design pattern using virtual functions.

 #+BEGIN_SRC cpp 
   class IntervalSummation{
   public:
           // Algorithm or entry point which calls the derived class method.
           // This is the template method 
           double summation(int lower, int upper) const{
                   double sum = 0;
                   for(int i = lower; i <= upper; i++)
                           sum += this->stepFn(i);
                   return sum; 
           }
   protected:
           // Hook method or to be defined by the derived class
           virtual double stepFn(double x) const = 0 ;
   };

   class SumOfSquares: public IntervalSummation{
   private:
           double stepFn(double x) const { return x * x; }
   };

   class SumOfCubes: public IntervalSummation{
   private:
           double stepFn(double x) const { return x * x * x; }
   };

   void clientCode(const IntervalSummation& obj){
           std::cout << "Summation at [0, 15] = " << obj.summation(0, 15) << std::endl;
   }
#+END_SRC

  *Approach 2 - CRTP generic programming pattern* 

 + Code 2: Code rewritten using CRTP for eliminating virtual function
   calls. The advantage is that this code can run faster than the
   previous one, however the cost is the higher complexity, loss of
   readability and runtime polymorphism. For instance, now is not
   possible to store multiple implementations of IntervalSummation in
   a data structure or refer to them with the same pointer.

 + File: [[file:src/design-patterns/crtp1.cpp][file:src/design-patterns/crtp1.cpp]]
 + Online Compiler: https://rextester.com/ZLZH2040

#+BEGIN_SRC cpp 
  template<class Implementation>
  class IntervalSummation{
  public:
          // Get reference to implementation 
          Implementation& self(){
                  return *static_cast<Implementation*>(this);
          }
          // Overload method 
          const Implementation& self() const {
                  return *static_cast<Implementation const * const>(this);
          } 	
          double summation(int lower, int upper) const {
          double sum = 0;
          for(int i = lower; i <= upper; i++)
                sum += self().stepFn(i);
          return sum; 
          }
  };

  class SumOfSquares: public IntervalSummation<SumOfSquares>{
  public:
          double stepFn(double x) const { return x * x; }
  };

  class SumOfCubes: public IntervalSummation<SumOfCubes>{
  public:
          double stepFn(double x) const { return x * x * x; }
  };

  template<class T>
  void clientCode(const IntervalSummation<T>& obj){
          std::cout << "Summation at [0, 15] = " << obj.summation(0, 15) << std::endl;
  }

#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ clang++ crtp.cpp -o crtp.bin -std=c++1z -Wall -Wextra  && ./crtp.bin
  Sum of squares in [0, 10] = 385
  Sum of cubes   in [0, 10] = 3025
  Summation at [0, 15] = 1240
  Summation at [0, 15] = 14400
#+END_SRC

References: 

 + [[https://www.codeproject.com/Tips/537606/Cplusplus-Prefer-Curiously-Recurring-Template-Patt][C++: Prefer Curiously Recurring Template Pattern (CRTP) to Template Pattern - CodeProject]]
 + [[https://mklimenko.github.io/english/2018/07/02/platform-dependent-crtp/][CRTP-based platform-dependent optimizations | GNSS C++ solutions]]
 + http://stevedewhurst.com/once_weakly/once-weakly20170328/once-weakly20170328.pdf
 + [[http://enki-tech.blogspot.com/2012/08/c11-generic-singleton.html][Enki :: Technical Blog: C++11: A generic Singleton]]
 + IDENTIFYING PROGRAMMING IDIOMS IN C++ GENERIC LIBRARIES -
   <https://etd.ohiolink.edu/rws_etd/document/get/kent1259116053/inline>
 + [[http://www.masaers.com/2014/01/22/CRTP-operator-hijacking.html][Using CRTP to easily hijack operators in c++11 | masaers’ blog]]
 + https://github.com/nojhan/crtp_functor_ttp
 + [[https://web.archive.org/web/20060211034709/http://devnet.developerpipeline.com/documents/s=9843/cuj0601diggins/][Developer::Pipelines | Building More Flexible Types with Mixins]]
 + [[https://accu.org/index.php/journals/296][ACCU :: Better Encapsulation for the Curiously Recurring Template Pattern]]
 + [[http://www.di.unipi.it/~nids/docs/templates_vs_inheritance.html][Replacing Virtual Methods with Templates]]
 + http://gsd.web.elte.hu/lectures/bolyai/2018/mixin_crtp/mixin_crtp.pdf
 + https://faithandbrave.hateblo.jp/entry/20071206/1196934096
 + [[https://nativecoding.wordpress.com/2015/06/05/virtual-methods-vs-crtp-benchmark-2/][Virtual Methods vs CRTP Benchmark – Native Coding]]
 + https://nativecoding.wordpress.com/2015/01/11/important-c-idioms/
 + http://barngoggles.com/visitor-with-crtp/

Best Links: 

 + https://nativecoding.wordpress.com/2015/01/11/important-c-idioms/
 + https://marcoarena.wordpress.com/2012/04/29/use-crtp-for-polymorphic-chaining/
 + http://thothonegan.tumblr.com/post/157363120503/crtp-curiously-recurring-template-pattern

Videos: 

 + Curiously Recurring Template Pattern (CRTP) -
   <https://www.youtube.com/watch?v=C3Pi5GlIfjs>

 + 

 + 
** RAII - Resource Aquisition Is Initialization (C++ Only)

Comes from book: _C++ Programming with Design Patterns Revealed_ 

RAII is a design pattern which takes advantage of C++'s deterministic
destructor feature for deallocating resources such as pointers to
objects allocated on the heap memory, database handlers, socket
handlers and etc. The RAAI technique uses an object allocated on the
stack which acquires the resource as a constructor argument and
performs the resource cleanup in the destructor method which is called
when when the wrapper object goes out scope or an exception happens.

 + Note: This pattern is specific for C++, for Java and Scala use _try_
   _finally_ statements. Python has the _with_ statement and C# has the
   _using_ statement. In addition, this pattern needs the
   *deterministic destructor* feature which is unique to C++.

Note: It is no longer necessary to design any class for RAII since
C++11 has smart pointers which already implements this
pattern. However, it is important to understand how this idiom works
and the problem that it solves.
 + In C++ >= C++ 11, it is better to use ~unique_ptr~ for handling
   resources as shown at [[https://msdn.microsoft.com/en-us/library/hh438480.aspx][Objects Own Resources (RAII)]] 

RAII is described as the process of: 
 + Acquiring a resouce and wrapping it as an object's state.
 + Using the resource 
 + Releasing the resource in the object's destructor member function
   which is executed when the object goes out of escope.

What i solves: 
 + Avoid memory leaks.
 + Avoid resource leaks. 

Known uses: 
 + C++11 _shared_ptr_ (Smart pointer)
 + C++11 _unique_ptr_ (Smart pointer)

 *Example 1:* Naive code - If an exception happens, the resource will not
be released and the code will be vulnerable against memory leak or
resource leak.  

#+BEGIN_SRC cpp 
  Handler* handle  = getDatabaseHandler(); 
  // Throw exception => Resource leak 
  performInvalidOperation(handle);  
  ...
  // Forget to release resource!
  deleteResource(handle); 
#+END_SRC

Or: 

#+BEGIN_SRC cpp 
   Object* heapObject = new Object(param0, param1, ....);
   peformOperation(heapObject); 
   heapObject->method1; 

   // Throw exception!! ==> Memory Leak!

   // If the user forget this statement, 
   // a memory leak will happen. 
   delete heapObject; 
#+END_SRC
 
 *Solution - RAAI Pattern*

 - An object is used to control the lifetime of a resource ensuring
   that is released when the object goes out of scope or an exception
   happens. The resource is aquired by the constructor and realeased
   by the destructor.

#+BEGIN_SRC cpp 
  template<class Resource>
  class RaaiHandler {
  public:  
     // Consructor: Acquire resource on the constructor 
     RaaiHandler(Resource* rawHandle_) : (rawHandle_) {};

     // Destructor: Releases resource 
     // The destructor is always called when the object goes out of scope 
     // or an exception happens.
     ~RaiiHandler() {
        delete _handler; 
      }      
  private:
     RaiiHandler* _handler;
  };

  // Object created without new keyword is allocated in the stack, not in the heap.
  RaiiHandler hnd(createNewResource());
  // .. . Peform operation 
  Operation(hnd);
  // Once the escope is gone, the resource is released.
#+END_SRC

 *References*

 + [[https://www.codeproject.com/Articles/580077/ResourceplusAcquisitionplusisplusInitializationplu][Resource Acquisition is Initialization (RAII) - CodeProject]]
 + [[https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii][c++ - What is meant by Resource Acquisition is Initialization (RAII)? - Stack Overflow]]
 + [[https://www.codeproject.com/Articles/122129/RAII-Resource-Acquisition-Is-Initialization-C-Help][RAII (Resource Acquisition Is Initialization) C# Helper Classes - CodeProject]]
 + [[http://jrdodds.blogs.com/blog/2004/08/raii_in_c.html/][RAII in C++ (constructive nonconformist)]]

** Cross platform code with conditional compilation (C++ Only)

Note: It is not a design pattern, but a useful for techinque for
designing cross platform code in C++.

Macros are useful for writing cross-platform code by hiding and
isolating platform-specific details, such as specific hardware
registers address, compiler extensions, APIs and system calls. This
example shows how to use conditional compilation to write code which
can be compiled on an Unix-like operating system, such as Linux or OSX
and Windows.

Example: 

#+BEGIN_SRC cpp 
  // Scoped enum is used to identify the operating system the code 
  // was copiled against.
  enum class SystemType{
      WindowsNT,
      Linux,
      MacOSX,
      FreeBSD,
      Unknown
  };

  /**  Returns the current operating system that the 
    ,*  library was compiled against.
  ,*/
  auto getSystemType() -> SystemType {
       #ifdef __apple__
          return SystemType::MacOSX;
       #elif defined __linux__
          return SystemType::Linux;
       #elif defined _WIN32 || defined _WIN64
         return SystemType::WindowsNT;
       #else
         return SystemType::Unknown;
       #endif
  }

  auto getOperatingSystem() -> std::string {
       SystemType type = getSystemType();
       if (type == SystemType::Linux)
               return "Linux";
       else if(type == SystemType::MacOSX)
               return "MacOSX";
       else if(type == SystemType::WindowsNT)
               return "Windows NT";
       else if(type == SystemType::FreeBSD)
               return "FreeBSD";
       else
               return "Unknown operating system";
  }

  auto isWindows() -> bool {
      return getSystemType() == SystemType::WindowsNT;
  }

  // Check whether is U-N-I-X like 
  auto isNixLike() -> bool {
       auto t = getSystemType();
       return t == SystemType::Linux
               || t == SystemType::FreeBSD
               || t == SystemType::MacOSX;
  }

  /** Cross platform code for creating directory */
  void makeDirectory(std::string path){
       #if defined __linux__ || defined __apple__
      /** ==== U-NIX Specific code ==== */
          mkdir(path.c_str(), 0777);
       #elif _WIN32
      /** ==== Windows Specific Code ==== */
          CreateDirectoryA(path.c_str(), NULL);
       #endif
  }

  /** Get home directory, ~/ or $HOME on Unix or %USERPROFILE% 
   ,* environment variable on Windows 
   ,*/
  std::string getHomeDir(){
      if (getSystemType() == SystemType::WindowsNT)
         return getEnv("USERPROFILE");
       else
        return getEnv("HOME");
  }
#+END_SRC

** Multiple booleans encoded as bitmask

Note: It is not a design pattern, but a technique for encoding
multiple booleans or flags inside a single value, passing multiple
booleans as function parameters or returning multiple booleans as a
single value.

Example: 

 - File:  [[file:src/design-patterns/boolean-bitmask.C][file:src/design-patterns/boolean-bitmask.C]]  (CLING script)

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <vector>
  #include <ostream> // Operator: (<<)
  #include <string>

  enum class Permissions: unsigned {
      executable = 0x01,  // decimal = 1 or (1 << 0)
      writeable  = 0x02,  // decimal = 2 or (1 << 1)
      readable   = 0x04   // decimal = 4 or (1 << 2)
  };

  Permissions operator | (Permissions lhs, Permissions rhs){
      return static_cast<Permissions>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs));
  }
  bool operator & (Permissions lhs, Permissions rhs){
      return static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs);
  }
  // Make permissions enum printable. 
  std::ostream& operator<<(std::ostream& os, const Permissions& p){
      os << std::boolalpha; // Make bool printable as 'true' or 'false' instead of 0 or 1
      os << "readable = "   << (p & Permissions::readable)   << "; "
         << "writeable = "  << (p & Permissions::writeable)  << "; "
         << "executable = " << (p & Permissions::executable);
      return os;
  }
#+END_SRC

Running: 

#+BEGIN_SRC cpp 
  // Load script 
  >> .L boolean-bitmask.C 

  >> std::cout << Permissions::readable << std::endl;
  readable = true; writeable = false; executable = false

  >> std::cout << Permissions::readable << "\n";
  readable = true; writeable = false; executable = false

  >> std::cout << Permissions::writeable << "\n";
  readable = false; writeable = true; executable = false

  >> std::cout << Permissions::executable << "\n";
  readable = false; writeable = false; executable = true

  >> auto p1 = Permissions::executable | Permissions::readable ;
  >> std::cout << "p1 => " << p1 << "\n";
  p1 => readable = true; writeable = false; executable = true
  >> 

  >> auto p2 = Permissions::executable | Permissions::readable | Permissions::writeable ;
  >> std::cout << "p2 => " << p2 << "\n";
  p2 => readable = true; writeable = true; executable = true
  >> 

  >> if(p1 & Permissions::readable) { std::cout << "File is readable" << "\n"; }
  File is readable
  >> 

#+END_SRC

Shows all flags or all bits that are set: 

#+BEGIN_SRC cpp 
  void showPermissions(Permissions p){
          std::cout << "Is readable?     : " << (p & Permissions::readable)   << '\n';
          std::cout << "Is writeable?    : " << (p & Permissions::writeable)  << '\n';
          std::cout << "Is executable?   : " << (p & Permissions::executable) << '\n';
  }

  >> showPermissions(p1)
  Is readable?     : true
  Is writeable?    : false
  Is executable?   : true
  >> 
  >> showPermissions(p2)
  Is readable?     : true
  Is writeable?    : true
  Is executable?   : true
  >> 
#+END_SRC

Design 1: Function uses multiple bools creating a file with some
permissions. 

#+BEGIN_SRC cpp 
  using FilePerms = std::tuple<bool, bool, bool>;

  // Design 1:
  FilePerms createFileDD1(
       std::string name,
       bool readable,
       bool writeable,
       bool executable ){
       std::cout << std::boolalpha
                 << "Create file = " << name << "\n"
                 << " with the following permissions" << "\n"
                 << "  + readable   = " << readable   << "\n"
                 << "  + writeable  = " << writeable  << "\n"
                 << "  + executable = " << executable << "\n"
                 << "\n";
       return FilePerms {readable, writeable, executable};	
  }

  >> auto pd1 = createFileDD1("dataset.txt", true, false, false)
  Create file = dataset.txt
   with the following permissions
    + readable   = true
    + writeable  = false
    + executable = false

  >> pd1
  (std::tuple<bool, bool, bool> &) { true, false, false }
  >> 

  >> std::cout << "R = " << std::get<0>(pd1) << "\n";
  R = true
  >> std::cout << "W = " << std::get<1>(pd1) << "\n";
  W = false
  >> std::cout << "X = " << std::get<2>(pd1) << "\n";
  X = false
  >> 
#+END_SRC

Design 2: Use bitmask flags instead of bools. The advantage is more
readability and less functions parameters. 

#+BEGIN_SRC cpp 
  // Design 1:
  Permissions createFileDD2(std::string name, Permissions p){
       std::cout << std::boolalpha
                 << "Create file = " << name << "\n"
                 << " with the following permissions" << "\n"
                 << "  + readable   = " << (p & Permissions::readable)   << "\n"
                 << "  + writeable  = " << (p & Permissions::writeable)  << "\n"
                 << "  + executable = " << (p & Permissions::executable) << "\n"
                 << "\n";
       return p;
  }

  >> auto pd2 = createFileDD2("Sales-report.xls", Permissions::readable | Permissions::writeable)
  Create file = Sales-report.xls
   with the following permissions
    + readable   = true
    + writeable  = true
    + executable = false

  (Permissions)  : (unsigned int) 6
  >> 

  >> createFileDD2("parser.exe", Permissions::readable | Permissions::writeable | Create file = parser.exe
   with the following permissions
    + readable   = true
    + writeable  = true
    + executable = true

  (Permissions)  : (unsigned int) 7
  >> 

  >> std::cout << "R = " << (pd2 & Permissions::readable) << "\n";
  R = true
  >> std::cout << "W = " << (pd2 & Permissions::writeable) << "\n";
  W = true
  >> std::cout << "X = " << (pd2 & Permissions::executable) << "\n";
  X = false
#+END_SRC
