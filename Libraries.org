#+INCLUDE: theme/style.org
#+TITLE: CPP / C++ - Libraries Bookmarks 
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

* Libraries 
** Boost Libraries 
*** Math 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/index.html][Math Toolkit 2.8.0 - 1.69.0]]
  + Brief: The math toolkit provides the following facilities:
    + Floating Point Utilities
    + Specific Width Floating Point Types
    + *Statistical Distributions* (Gaussian, Poisson, Bernouli...)
    + Mathematical Special Function
    + Root Finding and Function
    + Minimisations, Polynomials and Rational Functions
    + Interpolation
    + Numerical Integration and Differentiation
    + Quaternions and Octonions.   
  + [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/special.html][Chapter 6. Special Functions - 1.69.0]]
  + [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/dist.html][Chapter 5. Statistical Distributions and Functions - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/numeric/ublas/][uBLAS]] (Linear algebra facilities, linear systems, vector matrices
  and so on.)
  + Brief: "uBLAS provides matrix and vector classes as well as basic
    linear algebra routines. Several dense, packed and sparse storage
    schemes are supported."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/numeric/odeint/doc/html/boost_numeric_odeint/getting_started/overview.html][Boost Odeint]]
  + Library for ordinary differential equations - initial value
    problems.

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/date_time.html][Date Time]]
  + Brief: "A set of date-time libraries based on generic programming concepts."
  + Descr: "The motivation for this library comes from working with
    and helping build several date-time libraries on several
    projects. Date-time libraries provide fundamental infrastructure
    for most development projects. However, most of them have
    limitations in their ability to calculate, format, convert, or
    perform some other functionality. For example, most libraries do
    not correctly handle leap seconds, provide concepts such as
    infinity, or provide the ability to use high resolution or
    network time sources. These libraries also tend to be rigid in
    their representation of dates and times. Thus customized policies
    for a project or subproject are not possible."

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/chrono.html][Chapter 7. Boost.Chrono 2.0.8 - 1.69.0]] (Time interval computation,
  already in C++11, but it is a good documentation for the STL
  library.) 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/accumulators.html][Accumulators]]
  + Summary: Incremental statistics.
  + Descr: "Boost.Accumulators is both a library for incremental statistical
    computation as well as an extensible framework for incremental
    calculation in general. The library deals primarily with the
    concept of an accumulator, which is a primitive computational
    entity that accepts data one sample at a time and maintains some
    internal state. These accumulators may offload some of their
    computations on other accumulators, on which they
    depend. Accumulators are grouped within an accumulator
    set. Boost.Accumulators resolves the inter-dependencies between
    accumulators in a set and ensures that accumulators are processed
    in the proper order."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/multiprecision/doc/html/boost_multiprecision/intro.html][Boost Multiprecisions]]
  + Brief: "The Multiprecision Library provides integer, rational,
    floating-point, and complex types in C++ that have more range and
    precision than C++'s ordinary built-in types. The big number
    types in Multiprecision can be used with a wide selection of
    basic mathematical operations, elementary transcendental
    functions as well as the functions in Boost.Math. The
    Multiprecision types can also interoperate with the built-in
    types in C++ using clearly defined conversion rules. This allows
    Boost.Multiprecision to be used for all kinds of mathematical
    calculations involving integer, rational and floating-point types
    requiring extended range and precision."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/units/][Units]]
  + Brief: "Zero-overhead dimensional analysis and unit/quantity
    manipulation and conversion."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/multi_array/doc/user.html][The Boost Multidimensional Array Library (Boost.MultiArray) - 1.69.0]]
  + Brief: Multidimensional arrays, aka tensors. 

*** Parallel Computing 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/mpi.html][Chapter 26. Boost.MPI - 1.69.0]]
  + Brief: "Boost.MPI is a library for message passing in high-performance
    parallel applications. A Boost.MPI program is one or more
    processes that can communicate either via sending and receiving
    individual messages (point-to-point communication) or by
    coordinating as a group (collective communication). Unlike
    communication in threaded environments or using a shared-memory
    library, Boost.MPI processes can be spread across many different
    machines, possibly with different operating systems and
    underlying architectures."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/compute/doc/html/index.html][Chapter 1. Boost.Compute - 1.69.0]]
  + Brief: "The Boost Compute library provides a C++ interface to
    multi-core CPU and GPGPU computing platforms based on OpenCL." 
 
*** String Utilities 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_lexical_cast.html][Chapter 21. Boost.Lexical_Cast 1.0 - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/format/][The Boost Format library - 1.69.0]]
  + The format library provides a class for formatting arguments
    according to a format-string, as does printf, but with two major
    differences : format sends the arguments to an internal stream,
    and so is entirely type-safe and naturally supports all
    user-defined types. The ellipsis (...) can not be used correctly
    in the strongly typed context of format, and thus the function
    call with arbitrary arguments is replaced by successive calls to
    an argument feeding operator%

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/string_algo.html][String algo]]
  + Brief: "The String Algorithm Library provides a generic
    implementation of string-related algorithms which are missing in
    STL. It is an extension to the algorithms library of STL and it
    includes trimming, case conversion, predicates and find/replace
    functions. All of them come in different variants so it is easier
    to choose the best fit for a particular need." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/spirit/][Boost Spirit]]
  + Brief: Framework for building parsers.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/tokenizer/][Tokenizer]]
  + Brief: "Break of a string or other character sequence into a
    series of tokens."

*** Template Metaprogramming facilities 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/utility/operators.htm][Boost Operators]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/range/][Range]] [BEST]
  + Descr: "A new infrastructure for generic algorithms that builds
    on top of the new iterator concepts."
  + Note: Maybe the future replacement for C++ classical iterators.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/hof/doc/html/doc/src/index.html][Boost.HigherOrderFunctions]] (aka Boost.Hof)
  + Brief: Provides many higher order functions. 
  + Descr: HigherOrderFunctions is a header-only C++11/C++14 library that
    provides utilities for functions and function objects, which can
    solve many problems with much simpler constructs than whats
    traditionally been done with metaprogramming.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/mp11/doc/html/mp11.html][Boost.Mp11: A C++11 metaprogramming library - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/fusion/doc/html/fusion/preface.html][Boost Fusion]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/hana/doc/html/index.html][Boost.Hana]]
  + Brief: "Hana is a header-only library for C++ metaprogramming
    suited for computations on both types and values."
  + Descr: "The functionality it provides is a superset of what is
    provided by the well established Boost.MPL and Boost.Fusion
    libraries. By leveraging C++11/14 implementation techniques and
    idioms, Hana boasts faster compilation times and runtime
    performance on par or better than previous metaprogramming
    libraries, while noticeably increasing the level of
    expressiveness in the process. Hana is easy to extend in a ad-hoc
    manner and it provides out-of-the-box inter-operation with
    Boost.Fusion, Boost.MPL and the standard library." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/concept_check/][Concept check]]
  + Descr: "Tools for generic programming."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/proto/][Proto]]
  + Brief: "Expression template library and compiler construction
    toolkit for domain-specific embedded languages."

*** Design Patterns and Object Oriented Design Patterns 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_typeerasure.html][Chapter 40. Boost.TypeErasure - 1.69.0]]
  + Brief: "The Boost.TypeErasure library provides runtime
    polymorphism in C++ that is more flexible than that provided by
    the core language. The Boost.TypeErasure library combines the
    superior abstraction capabilities of templates, with the runtime
    flexibility of virtual functions."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/ptr_container/doc/ptr_container.html][Boost Pointer Container Library - 1.69.0]]
  + Brief: "Boost.Pointer Container provides containers for holding
    heap-allocated objects in an exception-safe manner and with
    minimal overhead. The aim of the library is in particular to make
    OO programming easier in C++ by establishing a standard set of
    classes, methods and designs for dealing with OO specific
    problems." 

+ [[https://www.boost.org/doc/libs/release/libs/flyweight/][Boost Flyweight]]
  + Brief: Descr: "Design pattern to manage large quantities of
    highly redundant objects."

  + Descr: "Flyweights are small-sized handle classes granting
    constant access to shared common data, thus allowing for the
    management of large amounts of entities within reasonable memory
    limits. Boost.Flyweight makes it easy to use this common
    programming idiom by providing the class template flyweight<T>,
    which acts as a drop-in replacement for const T."

  + Additional notes:
    + "Learning to use Boost.Flyweight can be accomplished in a matter
      of minutes. When special needs arise, however, an extensive
      customization interface is provided which allows the user to
      control and extend the following aspects:"
    + Type tagging for separation of domains using the same basic flyweight types.
    + Specification and parameterization of the so-called flyweight factory.
    + Control of the factory instantiation procedure.
    + Specification of the internal synchronization mechanisms.
    + Flyweight tracking, allowing for the disposal of stored values
      when no longer referenced by any flyweight object.

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/property_tree.html][Chapter 32. Boost.PropertyTree - 1.69.0]]
  + "The Property Tree library provides a data structure that stores
    an arbitrarily deeply nested tree of values, indexed at each
    level by some key. Each node of the tree stores its own value,
    plus an ordered list of its subnodes and their keys. The tree
    allows easy access to any of its nodes by means of a path, which
    is a concatenation of multiple keys." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/functional/factory/doc/html/index.html][Boost.Functional/Factory]]
  + Brief: "The template boost::factory lets you encapsulate a new
    expression as a function object, boost::value_factory
    encapsulates a constructor invocation without new."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/property_map/doc/property_map.html][Property Map Library - 1.69.0]]

*** Command Line Options 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/program_options.html][Chapter 31. Boost.Program_options - 1.69.0]]

*** Debugging, Logging and Assertions 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/log/doc/html/index.html][Chapter 1. Boost.Log v2 - 1.69.0]]
  + Descr: "The application stores all essential information about its
    execution to a log, and when something goes wrong this
    information can be used to analyze the program behavior and make
    the necessary corrections. There are other very useful
    applications of logging, such as gathering statistical
    information and highlighting events (i.e. indicating that some
    situation has occurred or that the application is experiencing
    some problems). These tasks have proved to be vital for many
    real-world industrial applications. This library aims to make
    logging significantly easier for the application developer. It
    provides a wide range of out-of-the-box tools along with public
    interfaces for extending the library. The main goals of the
    library are:"
    + Simplicity. A small example code snippet should be enough to
      get the feel of the library and be ready to use its basic
      features.
    + Extensibility. A user should be able to extend functionality of
      the library for collecting and storing information into logs.
    + Performance. The library should have as little performance
      impact on the user's application as possible.

*** Network - Sockets - TCP/IP

+ [[https://www.boost.org/doc/libs/1_69_0/libs/asio/][Boost Asio]]
  + Descr: "Portable networking and other low-level I/O, including sockets,
    timers, hostname resolution, socket iostreams, serial ports, file
    descriptors and Windows HANDLEs."

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/crc.html][Boost CRC]] - CRC (Cyclick Redundancy Checking)
  + Descr: " CRCs (cyclic redundancy codes) is one common technique
    to confirming data integrity after transmission. The Boost.CRC
    library provides access to two styles of CRC computation, one as
    a function template, the other as a function template and two
    computation object class templates, where the two class templates
    differ in speed."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/statechart/][Statechart]]
  + Brief: "Boost.Statechart - Arbitrarily complex finite state
    machines can be implemented in easily readable and maintainable
    C++ code."
  + Note: Many network protocols, embedded systems applications and
    business processes are well described by state machines such as
     [[https://en.wikipedia.org/wiki/Mealy_machine][Mealy state machine]] or [[https://en.wikipedia.org/wiki/Moore_machine][Moore State machine]].

+ [[https://www.boost.org/doc/libs/1_69_0/libs/uuid/][UUID]] - A universally unique identifier.

*** Shared Libraries and Plugins - DLL, DSO, SO

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_dll.html][Boost DLL]]
  + Brief: "This library was designed to simplify plugin development using C++ in a portable cross-platform manner."
  + Descr: "Adding a specific features to an existing software
    applications at runtime could be useful in many cases. Such
    extensions, or plugins, are usually implemented using Dynamic
    Library Modules (DLL,SO/DSO) loaded at runtime."
  + Library provides a portable across platforms way to:
    + load libraries
    + import any native functions and variables
    + make alias names for C++ mangled functions and symbols
    + query libraries for sections and exported symbols
    + self loading and self querying
    + getting program and module location by exported symbol

*** Subprocess and inter process communication - IPC 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/interprocess.html][Boost.Interprocess]]
  + Brief: "Boost.Interprocess simplifies the use of common
    interprocess communication and synchronization mechanisms and
    offers a wide range of them:"
    + Shared memory.
    + Memory-mapped files.
    + Semaphores, mutexes, condition variables and upgradable mutex
      types to place them in shared memory and memory mapped files.
    + Named versions of those synchronization objects, similar to UNIX/Windows sem_open/CreateSemaphore API.
    + File locking.
    + Relative pointers.
    + Message queues.
  + Additional:
    + Boost.Interprocess also offers higher-level interprocess
      mechanisms to allocate dynamically portions of a shared memory
      or a memory mapped file (in general, to allocate portions of a
      fixed size memory segment). Using these mechanisms,
      Boost.Interprocess offers useful tools to construct C++
      objects, including STL-like containers, in shared memory and
      memory mapped files:

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/process.html#boost_process.introduction][Boost.Process]]
  + Brief: "Boost.Process is a library to manage system processes. It
    can be used to:"
    + create child processes
    + setup streams for child processes
    + communicate with child processes through streams (synchronously
      or asynchronously)
    + wait for processes to exit (synchronously or asynchronously)
    + terminate processes

*** Low level and byte manipulation 

  + [[https://www.boost.org/doc/libs/1_69_0/libs/endian/doc/index.html][Endian Library - 1.69.0]]

** General Purpose Libraries                                        :general:
 
+ [[http://www.boost.org/][Boost libraries]] - Peer reviewed libraries that can be regarded as
  STL extensions. Many of them eventually get into the C++ standard,
  for instance, C++17 std::file_system comes from Boost.FileSystem,
  std::variant from C++17 comes from Boost.Variant.

+ [[http://stxxl.org/][STLXX]] - Standard Template Library for Extra Large Data Sets
  + "The core of STXXL is an implementation of the C++ standard
    template library STL for external memory (out-of-core)
    computations, i. e., STXXL implements containers and algorithms
    that can process huge volumes of data that only fit on
    disks. While the closeness to the STL supports ease of use and
    compatibility with existing applications, another design priority
    is high performance."

+ [[http://www.stlsoft.org/][STLSOFT]] - "Robust, Lightweight, Cross-platform, Template
  Software. STLSoft is a collection of STL and standard library
  extensions, and facades over operating-system and 3rd-party APIs."

+ [[https://abseil.io/][Abseil]] (Google) - "Allows using new C++ standard features from
  C++14 and C++17 with compilers that does not support those standards".

+ [[http://pocoproject.org/][Poco Framework]]

+ [[https://github.com/bloomberg/bde][Bloomberg BDE]] - Basic Development Environment - a set of
  foundational C++ libraries used at Bloomberg.

+ [[https://github.com/facebook/folly][Folly]] - "Folly (acronymed loosely after Facebook Open Source
  Library) is a library of C++14 components designed with
  practicality and efficiency in mind. Folly contains a variety of
  core library components used extensively at Facebook. In
  particular, it's often a dependency of Facebook's other open source
  C++ efforts and place where those projects can share code."

+ [[https://fcppt.org/][FCppt]] - Freundlich's C++ toolkit - "Freundlich's C++ Toolkit
  (fcppt) is a collection of libraries that aim to improve general
  C++ code through better typing and functional programming."

+ [[http://duneroadrunner.github.io/SaferCPlusPlus/][SaferCPlusPlus]] - "SaferCPlusPlus” is essentially a collection of
  safe data types intended to facilitate memory and data race safe
  C++ programming. This library is intended to work with and be
  complimentary to the Core Guidelines lifetime checker over its
  various stages of development and availability. (Including
  situations where the lifetime checker is not available at all.)"

** General Utility Libraries 
 
 + [[https://github.com/mandreyel/mio][mandreyel/mio]] - "An easy to use header-only cross-platform C++11
   memory mapping library with an MIT license. mio has been created
   with the goal to be easily includable (i.e. no dependencies) in any
   C++ project that needs memory mapped file IO without the need to
   pull in Boost."

 + [[https://github.com/mobius3/asap][mobius3/asap]] - "A C++ header-only library for creating, displaying,
   iterating and manipulating dates." 

 + [[https://github.com/tplgy/cppcodec][CppCodec]] - "Header-only C++11 library to encode/decode base64,
   base64url, base32, base32hex and hex (a.k.a. base16) as specified in
   RFC 4648, plus Crockford's base32. MIT licensed with consistent,
   flexible API. Supports raw pointers, std::string and (templated)
   character vectors without unnecessary allocations. Cross-platform
   with measured decent performance and without compiler warnings."

 + [[https://github.com/ReactiveX/RxCpp][RxCpp]] - "The Reactive Extensions for C++ (RxCpp) is a library of
   algorithms for values-distributed-in-time. The Range-v3 library
   does the same for values-distributed-in-space."

 + [[https://plflib.org/colony.htm][PFL::Colony]] - "plf::colony is the highest-performance C++
   template-based data container for high-modification scenarios with
   unordered data. All elements within a colony have a stable memory
   location, meaning that pointers/iterators to non-erased elements
   are valid regardless of insertions/erasures to the
   container. Specifically the container provides better performance
   than other std:: library containers when: Insertion order is
   unimportant;  Insertions and erasures to the container are
   occurring frequently in realtime ie. in performance-critical code;
   and/or Insertions and erasures to the container may not invalidate
   pointers/iterators to non-erased elements."

** Template Metaprogramming Helpers 

+ [[https://www.boost.org/doc/libs/1_63_0/libs/mpl/doc/index.html][Boost MPL]] - "The Boost.MPL library is a general-purpose, high-level
  C++ template metaprogramming framework of compile-time algorithms,
  sequences and metafunctions. It provides a conceptual foundation
  and an extensive set of powerful and coherent tools that make doing
  explict metaprogramming in C++ as easy and enjoyable as possible
  within the current language."

+ [[https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html][Boost Hana]] - "Hana is a header-only library for C++
  metaprogramming suited for computations on both types and
  values. The functionality it provides is a superset of what is
  provided by the well established Boost.MPL and Boost.Fusion
  libraries. By leveraging C++11/14 implementation techniques and
  idioms, Hana boasts faster compilation times and runtime
  performance on par or better than previous metaprogramming
  libraries, while noticeably increasing the level of expressiveness
  in the process. Hana is easy to extend in a ad-hoc manner and it
  provides out-of-the-box inter-operation with Boost.Fusion,
  Boost.MPL and the standard library." 

+ [[https://github.com/edouarda/brigand][Brigand]] - Brigand Meta-programming library (Lightweight alternative
  to Boost MPL) - "Brigand is a light-weight, fully functional,
  instant-compile time C++ 11 meta-programming library. Everything
  you were doing with Boost.MPL can be done with Brigand. And if
  that's not the case, open an issue!""

+ [[http://loki-lib.sourceforge.net/][Loki]] - Template library developed by Andrei Alexandrescu
  illustrating several generic programming design patterns.

+ [[https://github.com/Microsoft/GSL][GSL - Guidelines SUpport Library]] - "The Guidelines Support Library
  (GSL) contains functions and types that are suggested for use by
  the C++ Core Guidelines maintained by the Standard C++
  Foundation. This repo contains Microsoft's implementation of GSL." 

** Unit Testing Frameworks 

+ *Googletest* - Google Testing and Mocking Framework [MOST USED]
  + https://github.com/google/googletest


+ *Catch2* - A modern, C++-native, header-only, test framework for
  unit-tests, TDD and BDD - using C++11, C++14, C++17 and later (or
  C++03 on the Catch1.x branch)
  + https://github.com/catchorg/Catch2

+ *Doctest* - "doctest is a new C++ testing framework but is by far the
  fastest both in compile times (by orders of magnitude) and runtime
  compared to other feature-rich alternatives. It brings the ability
  of compiled languages such as D / Rust / Nim to have tests written
  directly in the production code by providing a fast, transparent
  and flexible test runner with a clean interface." 
  + https://github.com/onqtam/doctest

+ *CppUTest* - "CppUTest unit testing and mocking framework for C/C++ -
  CppUTest is a C /C++ based unit xUnit test framework for unit
  testing and for test-driving your code. It is written in C++ but is
  used in C and C++ projects and frequently used in *embedded systems*
  but it works for any C/C++ project."
  + http://cpputest.github.com
  + https://github.com/cpputest/cpputest

Other Libraries:

 + [[http://www.boost.org/doc/libs/1_38_0/libs/test/doc/html/index.html][Boost.Test]]

 + [[http://unittest-cpp.sourceforge.net/][UnitTest++]]

Mock: 

 + [[https://app.assembla.com/wiki/show/hippomocks][Hippo Mocks]]

 + [[http://turtle.sourceforge.net/][Boost Turtle]] -  A C++ mock object library for Boost.

 + [[https://github.com/google/googlemock][GoogleMock]] (Deprecated -> Absorbed into Google Test)

** Concurrency, Parallelism and Async 

*Threading and Parallel Computing*

  + *POSIX Threads*  - Threading C-API defined by POSIX IEEE standard
    which is implemented by many Unix-like operating systems such as
    Linux, MacOSX, iOS, Android, BSD, QNX and so on. Note: This API is
    already encapsulated and wrapped by C++11 standard library. 
    + [[https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html][POSIX thread (pthread) libraries]]
    + [[https://computing.llnl.gov/tutorials/pthreads/][POSIX Threads Programming]]
    + [[http://www.cs.fsu.edu/~baker/realtime/restricted/notes/pthreads.html][POSIX Threads API]]

  + *Intel TBB - Threading Building Blocks* - "This application is a
    widely used C++ library for shared-memory parallel programming and
    heterogeneous computing (intra-node distributed memory
    programming). The library provides a wide range of features for
    parallel programming, including generic parallel algorithms,
    concurrent containers, a scalable memory allocator, work-stealing
    task scheduler, and low-level synchronization primitives. Threading
    Building Blocks (TBB) is a library only solution for task-based
    parallelism and does not require any special compiler support. It
    ports to multiple architectures including Intel® architectures,
    ARM*, and Power Architecture*."
    + Site: https://software.intel.com/en-us/intel-tbb
    + Repo: https://github.com/intel/tbb

  + *Intel Parallel-STL* - "Parallel STL is an implementation of the C++
    standard library algorithms with support for execution policies, as
    specified in ISO/IEC 14882:2017 standard, commonly called
    C++17. The implementation also supports the unsequenced execution
    policy specified in Parallelism TS version 2 and proposed for the
    next version of the C++ standard in the C++ working group paper
    P1001R1. Parallel STL offers a portable implementation of threaded
    and vectorized execution of standard C++ algorithms, optimized and
    validated for Intel(R) 64 processors. For sequential execution, it
    relies on an available implementation of the C++ standard
    library. The source code in this repository corresponds to the
    releases of Parallel STL with Intel(R) C++ Compiler or with
    Threading Building Blocks."
    + Site: https://software.intel.com/en-us/articles/get-started-with-parallel-stl
    + Site: https://github.com/intel/parallelstl

  + *ICNC - Intel Concurrency Collection* - " CnC makes it easy to write
    C++ programs which take full advantage of the available
    parallelism. Whether run on multicore systems, Xeon Phi™ or
    clusters CnC will seamlessly exploit the performance potential of
    your hardware. Through its portabilty and composability (with
    itself and other tools) it provides future-proof scalability.
    Intel® Concurrent Collections for C++ is a C++ template library
    for letting C++ programmers implement CnC applications which run
    in parallel on shared and distributed memory." 
    + Site: https://icnc.github.io/
    + Repo: https://github.com/icnc/icnc

  + *HPX - High Performance ParalleX* - "HPX is a C++ Standard Library
    for Concurrency and Parallelism. It implements all of the
    corresponding facilities as defined by the C++
    Standard. Additionally, in HPX we implement functionalities
    proposed as part of the ongoing C++ standardization process. We
    also extend the C++ Standard APIs to the distributed case. The
    goal of HPX is to create a high quality, freely available, open
    source implementation of a new programming model for conventional
    systems, such as classic Linux based Beowulf clusters or
    multi-socket highly parallel SMP nodes. At the same time, we want
    to have a very modular and well designed runtime system
    architecture which would allow us to port our implementation onto
    new computer system architectures. We want to use real-world
    applications to drive the development of the runtime system,
    coining out required functionalities and converging onto a stable
    API which will provide a smooth migration path for developers. The
    API exposed by HPX is not only modeled after the interfaces
    defined by the C++11/14/17/20 ISO standard, it also adheres to the
    programming guidelines used by the Boost collection of C++
    libraries. We aim to improve the scalability of today's
    applications and to expose new levels of parallelism which are
    necessary to take advantage of the exascale systems of the
    future."
    + Site: http://stellar-group.org/libraries/hpx/
    + Repo: https://github.com/STEllAR-GROUP/hpx

*Coroutines*

  + *Boost Coroutines 2* - "Boost.Coroutine2 provides templates for
    generalized subroutines which allow suspending and resuming
    execution at certain locations. It preserves the local state of
    execution and allows re-entering subroutines more than once (useful
    if state must be kept across function calls). Coroutines can be
    viewed as a language-level construct providing a special kind of
    control flow. In contrast to threads, which are pre-emptive,
    coroutine switches are cooperative (programmer controls when a
    switch will happen). The kernel is not involved in the coroutine
    switches."
    + https://www.boost.org/doc/libs/1_70_0/libs/coroutine2/doc/html/index.html

  + *Cppcoro* [EXPERIMENTAL] - "This library is an experimental library
    that is exploring the space of high-performance, scalable
    asynchronous programming abstractions that can be built on top of
    the C++ coroutines proposal. It has been open-sourced in the hope
    that others will find it useful and that the C++ community can
    provide feedback on it and ways to improve it. It requires a
    compiler that supports the coroutines TS." 
    + https://github.com/lewissbaker/cppcoro

*Fibers, Actor Model, CSP Communication Sequential Process*

  + *Boost Fibers* [USER SPACE THREADS] - "Provides a framework for
    micro-/userland-threads (fibers) scheduled cooperatively. The API
    contains classes and functions to manage and synchronize fibers
    similar to boost.thread. A fiber is able to store the current
    execution state, including all registers and CPU flags, the
    instruction pointer, and the stack pointer and later restore this
    state. The idea is to have multiple execution paths running on a
    single thread using a sort of cooperative scheduling (threads are
    preemptively scheduled) - the running fiber decides explicitly when
    it yields to allow another fiber to run (context switching). A
    context switch between threads costs usually thousands of CPU
    cycles on x86 compared to a fiber switch with less than 100
    cycles. A fiber can only run on a single thread at any point in
    time. Boost.fiber requires C++11!"
    + Site: https://www.boost.org/doc/libs/1_67_0/libs/fiber/doc/html/index.html
    + Repo: https://github.com/boostorg/fiber

  + *IOFiber* - "IOFiber is a fiber library built on top of Boost.Context
    and Boost.Asio - This library is not a competitor to
    Boost.Fiber. This library aims to have tight integration with
    Boost.Asio execution engine."
    + https://vinipsmaker.github.io/iofiber/
    + Repo: https://github.com/blinktrade/iofiber

  + *FiberTaskingLib* - "This is a library for enabling task-based
    multi-threading. It allows execution of task graphs with arbitrary
    dependencies. Dependencies are represented as atomic counters. Under
    the covers, the task graph is executed using fibers, which in turn,
    are run on a pool of worker threads (one thread per CPU core). This
    allows the scheduler to wait on dependencies without task chaining
    or context switches. This library was created as a proof of concept
    of the ideas presented by Christian Gyrling in his 2015 GDC Talk
    'Parallelizing the Naughty Dog Engine Using Fibers'" 
    + https://github.com/RichieSams/FiberTaskingLib

  + *CAF* - C++ Actor Framework - "CAF is an open source C++11 actor
    model implementation featuring lightweight & fast actor
    implementations, pattern matching for messages, network transparent
    messaging, and more."
    + Site: https://actor-framework.org/
    + Repo: https://github.com/actor-framework/actor-framework
    + Doxygen: http://www.actor-framework.org/doc/

  + *SObjectizer* - "SObjectizer is one of a few cross-platform and
    OpenSource 'actor frameworks' or C++. But SObjectizer supports not
    only Actor Model, but also Publish-Subscribe Model and CSP-like
    channels. The goal of SObjectizer is significant simplification of
    development of concurrent and multithreaded applications in C++."
    + Repo: https://bitbucket.org/sobjectizerteam/sobjectizer/

  + *QP/C++* - "QP/C++™ (Quantum Platform in C++) is a lightweight
    Real-Time Embedded Framework (RTEF) for building modern, responsive
    and modular real-time embedded applications as systems of
    asynchronous event-driven active objects (actors). QP/C++" is a
    member of a larger family of real-time embedded frameworks (RTEFs)
    consisting of QP/C++, QP/C, and QP-nano frameworks, which are all
    strictly quality controlled, thoroughly documented, and available
    under dual licensing model."
    + Site: https://www.state-machine.com/qpcpp/
    + Repo: https://github.com/QuantumLeaps/qpcpp
    + License: GPL for open source, commerical for closed source.

  + *ProXC* [C Library] - "CSP-inspired concurrency library for modern
    C - This is a library for C which enables Communicating Sequential
    Processes (CSP) like structuring of your code. Programming
    languages such as Occam and XC utilizes and builds around this very
    paradigm, but sadly is hardware locked. Many good CSP libraries for
    general purpose programming languages has been made, including both
    for Java (JCSP) and C++ (C++CSP2), but not for C. There does exists
    plenty of libraries for C which implements many features from CSP,
    such as coroutines, channels, etc., but not all in a single
    library. ProXC aims to do this, and with no macro magic!"
    + Site: https://github.com/edvardsp/libproxc  

  *Asynchronous I/O Input and Output* 

  + [[https://github.com/libuv/libuv][libuv]] - "libuv is a multi-platform support library with a focus on
    asynchronous I/O. It was primarily developed for use by Node.js,
    but it's also used by Luvit, Julia, pyuv, and others."
    + Site: https://github.com/libuv/libuv
    + Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
    + Asynchronous TCP and UDP sockets
    + Asynchronous DNS resolution
    + Asynchronous file and file system operations
    + File system events
    + ANSI escape code controlled TTY
    + IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
    + Child processes
    + Thread pool
    + Signal handling
    + High resolution clock
    + Threading and synchronization primitives

** C Libraries                                                         :clib:
*** General 

  + *libv* - "libv implements common data structures such as linked
    lists, dynamic arrays, binary trees, AVL-trees, maps, hashes,
    stacks, queues and others."
    + Summary: Library that provides common data structures missing in
      C standard library. 
    + Repository/Site: http://libv.sourceforge.net/

  + *tbox* - "TBOX is a glib-like cross-platform C library that is simple
    to use yet powerful in nature. The project focuses on making C
    development easier and provides many modules (.e.g stream,
    coroutine, regex, container, algorithm ...), so that any developer
    can quickly pick it up and enjoy the productivity boost when
    developing in C language." 
    + Site:       https://tboox.org
    + Repository: https://github.com/tboox/tbox

  + *Eina* (Enlightment Project) - "The Eina library is a library which
    implements an API for data types in an efficient way. It also
    provides some useful tools like opening shared libraries, error
    management, type conversion, time accounting and memory pools. This
    library is cross-platform and can be compiled and used on Linux,
    BSD, and Windows."
    + Site: https://www.enlightenment.org/_legacy_embed/eina_main.html

  + *APR - Apache Portable Runtime* - Supporting library for providing
    cross-platform portability to the Apache Web Server. The library
    provides a common API to many different operating systems. It
    provides facilities for: Atomic operations; Dynamic Shared Object
    loading; File I/O; Locks (mutexes, condition variables, etc); Memory
    management (high performance allocators); Memory-mapped files;
    Multicast Sockets; Network I/O; Shared memory; Thread and Process
    management and also may data structures such as tables, hashes,
    priority queues, etc.
    + Web Site: https://apr.apache.org/
    + Mirror Repository: https://github.com/apache/apr
    + Documentation: https://apr.apache.org/docs/apr/1.7/modules.html

  + *SDS - Simple Dynamic Strings library for C* - "SDS is a string
    library for C designed to augment the limited libc string handling
    functionalities by adding heap allocated strings that are: Simpler
    to use; Binary safe; Computationally more efficient; But
    yet... Compatible with normal C string functions."
    + Note: It comes from Redis database.
    + https://github.com/antirez/sds  

  + *ConcurrencyKit* - "Concurrency primitives, safe memory reclamation
    mechanisms and non-blocking (including lock-free) data structures
    designed to aid in the research, design and implementation of high
    performance concurrent systems developed in C99+"
    + http://concurrencykit.org/
    + https://github.com/concurrencykit/ck

  + *CException* - "CException is simple exception handling in C. It is
    significantly faster than full-blown C++ exception handling but
    loses some flexibility. It is portable to any platform supporting
    setjmp/longjmp."
    + https://github.com/ThrowTheSwitch/CException
    + http://www.throwtheswitch.org/cexception

*** Unit Testing Libraries 

  + *MinUnit* - "Minunit is a minimal unit testing framework for C/C++
    self-contained in a single header file. It provides a way to define
    and configure test suites and a few handy assertion types. It
    reports the summary of the number of tests run, number of assertions
    and time elapsed." 
    + https://github.com/siu/minunit

  + *Check* - "Check is a unit testing framework for C. It features a
    simple interface for defining unit tests, putting little in the way
    of the developer. Tests are run in a separate address space, so
    Check can catch both assertion failures and code errors that cause
    segmentation faults or other signals. The output from unit tests can
    be used within source code editors and IDEs." 
    + https://github.com/libcheck/check

  + *LibTap* - "tap is an easy to read and easy to write way of creating
    tests for your software. This library creates functions that can
    be used to generate it for your C programs. It is implemented
    using macros that include file and line info automatically, and
    makes it so that the format message of each test is optional. It
    is mostly based on the Test::More Perl module." 
    + https://github.com/zorgnax/libtap
*** User-space hardware access 

 + [[https://libusb.info/][LibUSB]] (Access USB - Universal Serial Bus) - "A cross-platform user
   library to access USB devices - libusb is a C library that provides
   generic access to USB devices. It is intended to be used by
   developers to facilitate the production of applications that
   communicate with USB hardware. It is portable: Using a single
   cross-platform API, it provides access to USB devices on Linux, OS
   X, Windows, Android, OpenBSD, etc. It is user-mode: No special
   privilege or elevation is required for the application to
   communicate with a device. It is version-agnostic: All versions of
   the USB protocol, from 1.0 to 3.1 (latest), are supported."
   + Repository: https://github.com/libusb/libusb

 + [[https://github.com/OpenSC/OpenSC][OpenSC]] (Access Smart Cards) - "OpenSC provides a set of libraries
   and utilities to work with smart cards. Its main focus is on cards
   that support cryptographic operations, and facilitate their use in
   security applications such as authentication, mail encryption and
   digital signatures. OpenSC implements the standard APIs to smart
   cards, e.g. PKCS#11 API, Windows’ Smart Card Minidriver and macOS
   Tokend."

 + [[http://nfc-tools.org/index.php/Main_Page][LibNFC]] (NFC - Near Field Communication) - "libnfc is a library
   which allows userspace application access to NFC devices."
   + Respository: https://github.com/nfc-tools/libnfc

** Memory Allocators 

 + *Horad* - "The Hoard memory allocator is a fast, scalable, and
   memory-efficient memory allocator that works on a range of
   platforms, including Linux, Mac OS X, and Windows. Hoard is a
   drop-in replacement for malloc that can dramatically improve
   application performance, especially for multithreaded programs
   running on multiprocessors and multicore CPUs. No source code
   changes necessary: just link it in or set one environment variable
   (see Building Hoard, below)." 
   + https://github.com/emeryberger/hoard
   + Open source projects using Hoard include the Asterisk Open Source
     Telephony Project, Bayonne GNU telephony server, the Cilk
     parallel programming language, the GNU Common C++ system, the
     OpenFOAM computational fluid dynamics toolkit, and the SafeSquid
     web proxy. 

 + *Jemalloc* - "jemalloc is a general purpose malloc(3) implementation
   that emphasizes fragmentation avoidance and scalable concurrency
   support. jemalloc first came into use as the FreeBSD libc allocator
   in 2005, and since then it has found its way into numerous
   applications that rely on its predictable behavior. In 2010
   jemalloc development efforts broadened to include developer support
   features such as heap profiling and extensive monitoring/tuning
   hooks. Modern jemalloc releases continue to be integrated back into
   FreeBSD, and therefore versatility remains critical. Ongoing
   development efforts trend toward making jemalloc among the best
   allocators for a broad range of demanding applications, and
   eliminating/mitigating weaknesses that have practical repercussions
   for real world applications."
   + site: http://jemalloc.net/
   + repo: https://github.com/jemalloc/jemalloc

 + *Dmalloc* - "The debug memory allocation or dmalloc library has been
   designed as a drop in replacement for the system's malloc, realloc,
   calloc, free and other memory management routines while providing
   powerful debugging facilities configurable at runtime. These
   facilities include such things as memory-leak tracking, fence-post
   write detection, file/line number reporting, and general logging of
   statistics. The library is reasonably portable having been run
   successfully on at least the following operating systems: AIX,
   BSD/OS, DG/UX, Free/Net/OpenBSD, GNU/Hurd, HPUX, Irix, Linux,
   MS-DOG, NeXT, OSF, SCO, Solaris, SunOS, Ultrix, Unixware, Windoze,
   and even Unicos on a Cray T3E. It also provides support for the
   debugging of threaded programs."
   + site: http://dmalloc.com/
   + repo: https://github.com/j256/dmalloc

 + *Minimmaloc* - "mimalloc (pronounced "me-malloc") is a general
   purpose allocator with excellent performance
   characteristics. Initially developed by Daan Leijen for the
   run-time systems of the Koka and Lean languages." 
   + repo: https://github.com/microsoft/mimalloc

 + *snmalloc* - "Message passing based allocator"
   + repo: https://github.com/microsoft/snmalloc

** Language Binding and tools                                       :binding:
*** Python 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/python/doc/html/tutorial/index.html][Boost.Python]]
  + Brief: "The Boost Python Library is a framework for interfacing
    Python and C++. It allows you to quickly and seamlessly expose
    C++ classes functions and objects to Python, and vice-versa,
    using no special tools -- just your C++ compiler. It is designed
    to wrap C++ interfaces non-intrusively, so that you should not
    have to change the C++ code at all in order to wrap it, making
    Boost.Python ideal for exposing 3rd-party libraries to
    Python. The library's use of advanced metaprogramming techniques
    simplifies its syntax for users, so that wrapping code takes on
    the look of a kind of declarative interface definition language
    (IDL)." 

+ [[https://pybind11.readthedocs.io/en/stable/][pybind11]] [BEST]
  + Brief: Allows to create Python modules in native code, aka
    libraries, with C++ >= C++11.

*** Ruby 

 + [[https://github.com/jasonroelofs/rice][Rice]] - "Rice is a C++ interface to Ruby's C API. It provides a
   type-safe and exception-safe interface in order to make embedding
   Ruby and writing Ruby extensions with C++ easier. It is similar to
   Boost.Python in many ways, but also attempts to provide an
   object-oriented interface to all of the Ruby C API."
   + Doxygen: http://jasonroelofs.github.io/rice/

*** Java 

 + [[https://github.com/bytedeco/javacpp][JavaCPP]] - "JavaCPP provides efficient access to native C++ inside
   Java, not unlike the way some C/C++ compilers interact with
   assembly language. No need to invent new languages such as with
   SWIG, SIP, C++/CLI, Cython, or RPython. Instead, similar to what
   cppyy strives to do for Python, it exploits the syntactic and
   semantic similarities between Java and C++. Under the hood, it uses
   JNI, so it works with all implementations of Java SE, in addition
   to Android, Avian, and RoboVM (instructions)." 

*** C# Csharp .NET 

 + [[https://github.com/mono/CppSharp][CppSharp]] - "CppSharp is a tool and set of libraries which allows
   programmers to use C/C++ libraries with high-level programming
   languages (such as C#). It is a tool that takes C/C++ header and
   library files and generates the necessary glue to surface the
   native API as a managed API. Such an API can be used to consume an
   existing native library in your high-level code or add scripting
   support to a native codebase. The supported target languages at
   present are C# and C++/CLI. It can also be used as a library to
   parse native code into a syntax tree with a rich declaration and
   type information model." 
*** Javascript NodeJS 
 
 + [[https://github.com/charto/nbind][nbind]] -  "nbind is a set of headers that make your C++11 library
   accessible from JavaScript. With a single #include statement, your
   C++ compiler generates the necessary bindings without any
   additional tools. Your library is then usable as a Node.js addon
   or, if compiled to asm.js with Emscripten, directly in web pages
   without any plugins. nbind works with the autogypi dependency
   management tool, which sets up node-gyp to compile your library
   without needing any configuration (other than listing your source
   code file names). nbind is MIT licensed and based on templates and
   macros inspired by embind." 

*** PHP 

 + [[https://github.com/CopernicaMarketingSoftware/PHP-CPP][PHP-CPP]] - "The PHP-CPP library is a C++ library for developing PHP
   extensions. It offers a collection of well documented and
   easy-to-use classes that can be used and extended to build native
   extensions for PHP. The full documentation can be found on
   http://www.php-cpp.com." 
 
*** Bindings generators 

 + [[https://github.com/google/clif][google/cliff]] - "C++ Language Interface Foundation (CLIF) - CLIF
   provides a common foundation for creating C++ wrapper generators
   for various languages." 

** FFI - Foreign Function Interface                                 :binding:

  + [[https://sourceware.org/libffi/][libffi]] - "A Portable Foreign Function Interface Library. The libffi
    library provides a portable, high level programming interface to
    various calling conventions. This allows a programmer to call any
    function specified by a call interface description at run time. FFI
    stands for Foreign Function Interface. A foreign function interface
    is the popular name for the interface that allows code written in
    one language to call code written in another language. The libffi
    library really only provides the lowest, machine dependent layer of
    a fully featured foreign function interface. A layer must exist
    above libffi that handles type conversions for values passed between
    the two languages. "
    + Repo: https://github.com/libffi/libffi

  + [[https://www.gnu.org/software/libffcall/][libffcall - GNU Project - Free Software Foundation]]
    + "GNU libffcall is a library which can be used to build foreign
      function call interfaces in embedded interpreters."

  + [[http://www.dyncall.org/index][dyncall.org - calling C functions dynamically]]
    + "The dyncall library encapsulates architecture-, OS- and
      compiler-specific function call semantics in a virtual bind
      argument parameters from left to right and then call interface
      allowing programmers to call C functions in a completely dynamic
      manner. In other words, instead of calling a function directly,
      the dyncall library provides a mechanism to push the function
      parameters manually and to issue the call afterwards." 
** Embedded Scripting Languages                                     :binding:

Listing of programming languages designed to be embedded in C or C++
applications and available as libraries. 

 + *Lua* - Dynamically typed scripting language with minimal
   syntax and footprint widely used in Games and as extension or
   scripting language in many applications.
   + C++ Binding libraries:
     + [[https://github.com/ThePhD/sol2][ThePhD/sol2]]
     + [[https://github.com/satoren/kaguya][satoren/kaguya]]
     + [[https://github.com/radiotail/eluna][radiotail/eluna]]

 + *TCL - Tool Command Language* - Old, but is still used by many EDA -
   Electronic Design Automation tools and routers.

 + [[http://www.squirrel-lang.org/][Squirrel]] -  "Squirrel is a high level imperative, object-oriented
   programming language, designed to be a light-weight scripting
   language that fits in the size, memory bandwidth, and real-time
   requirements of applications like video games."  
  
 + [[https://www.angelcode.com/angelscript/][AngelScript]] - "The AngelCode Scripting Library, or AngelScript as
   it is also known, is an extremely flexible cross-platform scripting
   library designed to allow applications to extend their
   functionality through external scripts. It has been designed from
   the beginning to be an easy to use component, both for the
   application programmer and the script writer."
   + Features: statically typed and syntax similar to C++, code in C++
     which makes the integration easeir.
   + Repo mirror: https://github.com/IngwiePhoenix/AngelScript

 + [[http://chaiscript.com/][ChaiScript]] - "ChaiScript is one of the only embedded scripting
   language designed from the ground up to directly target C++ and
   take advantage of modern C++ development techniques, working with
   the developer how they would expect it to work. Being a native C++
   application, it has some advantages over existing embedded
   scripting languages: It uses a header-only approach, which makes it
   easy to integrate with existing projects; It maintains type safety
   between your C++ application and the user scripts; It supports a
   variety of C++ techniques including callbacks, overloaded
   functions, class methods, and stl containers."
   + Repo: https://github.com/ChaiScript/ChaiScript
   + Problem: Long compile-time due to the library be header-only and
     the usage of C++ regex library. 

 + [[https://duktape.org/][Duktape]] - "Duktape is an embeddable Javascript engine, with a focus
   on portability and compact footprint. Duktape is easy to integrate
   into a C/C++ project: add duktape.c, duktape.h, and duk_config.h to
   your build, and use the Duktape API to call ECMAScript functions
   from C code and vice versa."
   + Repo: https://github.com/svaarala/duktape

 + [[http://www.espruino.com/][Espruino]] - "Espruino is a JavaScript interpreter for
   microcontrollers. It is designed for devices with as little as
   128kB Flash and 8kB RAM."
   + Repo: https://github.com/espruino/Espruino

 + [[https://github.com/jerryscript-project/jerryscript][Jerryscript]] - "JerryScript is a lightweight JavaScript engine for
   resource-constrained devices such as microcontrollers. It can run
   on devices with less than 64 KB of RAM and less than 200 KB of
   flash memory. Key characteristics of JerryScript: Full ECMAScript
   5.1 standard compliance; 160K binary size when compiled for ARM
   Thumb-2; Heavily optimized for low memory consumption; Written in
   C99 for maximum portability; Snapshot support for precompiling
   JavaScript source code to byte code Mature C API, easy to embed in
   applications"
   + Repo: https://github.com/jerryscript-project/jerryscript

 + [[http://www.gmscript.com/][gmscript]] - "GameMonkey is a embedded scripting language that is
   intended for use in game and tool applications. GameMonkey is
   however suitable for use in any project requiring simple scripting
   support. GameMonkey borrows concepts from Lua (www.lua.org), but
   uses syntax similar to C, making it more accessible to game
   programmers. GameMonkey also natively supports multithreading and
   the concept of states."
   + Repo: https://github.com/publicrepo/gmscript

 + [[https://marcobambini.github.io/gravity/#/][Gravity]] - "Gravity is a powerful, dynamically typed, lightweight,
   embeddable programming language written in C without any external
   dependencies (except for stdlib). It is a class-based concurrent
   scripting language with a modern Swift like syntax. Gravity
   supports procedural programming, object-oriented programming,
   functional programming and data-driven programming. Thanks to
   special built-in methods, it can also be used as a prototype-based
   programming language."
   + Repo: https://github.com/marcobambini/gravity

 + [[http://wren.io/][Wren]] - "Wren is a small, fast, class-based concurrent scripting
   language. Think Smalltalk in a Lua-sized package with a dash of
   Erlang and wrapped up in a familiar, modern syntax."
   + Repo:
     + https://github.com/wren-lang/wren
     + https://github.com/Nelarius/wrenpp (C++ Wrapper)

 + [[https://never-lang.readthedocs.io/en/latest/][Never-lang]] - "Never is a simple functional programming
   language. Technically it may be classified as syntactically scoped,
   strongly typed, call by value, functional programming language. In
   practise Never offers basic data types, assignment, control flow,
   arrays, first order functions and some mathematical functions to
   make it useful to calculate expressions. Also it demonstrates how
   functions can be compiled, invoked and passed as parameters or
   results between other functions."
   + Repo: https://github.com/never-lang/never

 + [[https://github.com/mruby/mruby][mruby]] - Embeddedable Ruby Implementation
   * Github: https://github.com/mruby/mruby
   * "mruby is the lightweight implementation of the Ruby language
     complying to (part of) the ISO standard. Its syntax is Ruby 1.9
     compatible. mruby can be linked and embedded within your
     application. We provide the interpreter program "mruby" and the
     interactive mruby shell "mirb" as examples. You can also
     compile Ruby programs into compiled byte code using the mruby
     compiler "mrbc". All those tools reside in the "bin"
     directory. "mrbc" is also able to generate compiled byte code
     in a C source file, see the "mrbtest" program under the "test"
     directory for an example."

 + [[http://synthcode.com/wiki/chibi-scheme][Scheme / Lisp]] (Chibi Scheme Implementation)
   * "Chibi-Scheme [1] is a very small library intended for use as
     an extension and scripting language in C programs. In addition
     to support for lightweight VM-based threads, each VM itself
     runs in an isolated heap allowing multiple VMs to run
     simultaneously in different OS threads."
   * Github: https://github.com/ashinn/chibi-scheme
   * [[http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html][Embedding Scheme for a game mission scripting DSL]]

 + [[https://en.wikipedia.org/wiki/TinyScheme][Scheme / Lisp]] (TinyScheme Implementation)
   * Official Web Site: http://tinyscheme.sourceforge.net/home.html
   * Small embeddable Scheme implementation used by GNU GIMP image
     editor.

** Numerical and General Scientifc Computing               :math:hpc:general:
*** General Purpose

+ [[https://www.boost.org/doc/libs/1_70_0/libs/math/doc/html/overview.html][Boost Math toolkit]]
  + [[https://www.boost.org/doc/libs/1_70_0/libs/math/doc/html/dist.html][Chapter 5. Statistical Distributions and Functions]]
  + [[https://www.boost.org/doc/libs/1_70_0/libs/math/doc/html/interpolation.html][Interpolation]]
  + [[https://www.boost.org/doc/libs/1_70_0/libs/math/doc/html/quadrature.html][Quadrature and Differentiation]]

+ *GNU Scientific Library - GSL* (C-Library) - "The library provides a
  wide range of mathematical routines such as random number
  generators, special functions and least-squares fitting. There are
  over 1000 functions in total with an extensive test suite."
  + Site:
    + https://www.gnu.org/software/gsl/
  + Documentation:
    + https://www.gnu.org/software/gsl/doc/html/index.html
  + Repository:

+ *GLPK* - *GNU Linear Programming Kit* (C and Fortran Library) - "The GLPK (GNU Linear
  Programming Kit) package is intended for solving large-scale linear
  programming (LP), mixed integer programming (MIP), and other
  related problems. It is a set of routines written in ANSI C and
  organized in the form of a callable library."
  + Site: https://www.gnu.org/software/glpk/
  + Example:
    + https://en.wikibooks.org/wiki/GLPK/Using_the_GLPK_callable_library
  + GPLK for Windows: http://winglpk.sourceforge.net/

+ *NAG C Libraries* from Numerical Algorithm Group [COMMERCIAL] - "The
  world’s largest collection of robust, documented, tested and
  maintained numerical algorithms." 
  + Site: https://www.nag.co.uk/nag-c-library
  + [[https://www.nag.com/content/cplusplus-wrappers-nag-c-library][C++ Wrappers]]

+ *IMSL (International Mathematics and Statistics Library) Numeric* *Libraries* [COMMERCIAL] (C and Fortran)
  + "The IMSL Numerical Libraries are a comprehensive set of
    mathematical and statistical functions that programmers can embed
    into their software applications. Using these libraries adds
    performance and quality to an application and saves developers
    time because they don't need to write the functionality
    themselves. IMSL is composed of the following types of functions:
    Matrix Operations, Linear Algebra, Interpolation, Approximation,
    Numerical Quadrature, OPtimization, Special Functions, Finance adn
    Bond Calculation, Statistics, Time Series & Forecatising, Da
    minining, Distribution Functions, Neural Network"
  + See:
    + [[https://software.intel.com/en-us/articles/imsl-licensing-frequently-asked-questions][IMSL Licensing Frequently Asked Questions]]
    + [[https://www.roguewave.com/products-services/imsl-numerical-libraries][IMSL Numerical Libraries]]
  + Documentation:
    + https://docs.roguewave.com/en/imsl/

+ *Intel MKL* - Intel Math Kernel Library - [FREWARE] (C and Fortran
  Library) - "Intel® Math Kernel Library (Intel® MKL) optimizes code
  with minimal effort for future generations of Intel® processors. It
  is compatible with your choice of compilers, languages, operating
  systems, and linking and threading models.". Note: only C shared
  and static libraries are provided, not the source code. 
  + Site: https://software.intel.com/en-us/mkl
  + License:
    + [[https://software.intel.com/en-us/license/intel-simplified-software-license][Intel Simplified Software License (Version April 2018)]]
    + [[https://software.intel.com/en-us/mkl/license-faq][FAQ]]
  + Documentation:
    + https://software.intel.com/en-us/mkl-developer-reference-c
  + Wikipedia:
    + https://en.wikipedia.org/wiki/Math_Kernel_Library
  + Github:
    + https://github.com/intel/mkl-dnn
     
+ *Ceres Solver* "Ceres Solver [1] is an open source C++ library for
  modeling and solving large, complicated optimization problems. It
  can be used to solve Non-linear Least Squares problems with bounds
  constraints and general unconstrained optimization problems. It is
  a mature, feature rich, and performant library that has been used
  in production at Google since 2010. For more, see Why?. "
  + Site: http://ceres-solver.org/
  + Docs: http://ceres-solver.org/tutorial.html
  + Repo: https://github.com/ceres-solver/ceres-solver

+ *ARB* - *C library for arbitrary-precision ball arithmetic*
  + "Arb is a C library for rigorous real and complex arithmetic with
    arbitrary precision. Arb tracks numerical errors automatically
    using ball arithmetic, a form of interval arithmetic based on a
    midpoint-radius representation. On top of this, Arb provides a
    wide range of mathematical functionality, including polynomials,
    power series, matrices, integration, root-finding, and many
    transcendental functions. Arb is designed with efficiency as a
    primary goal, and is usually competitive with or faster than
    other arbitrary-precision packages. The code is thread-safe,
    portable, and extensively tested. Arb is free software
    distributed under the GNU Lesser General Public License (LGPL),
    version 2.1 or later"
  + Site: http://arblib.org/
  + Repo: https://github.com/fredrik-johansson/arb/

+ *Trillinos* (Develped by Sandia National Laboratories) - "The
  Trilinos Project is an effort to develop algorithms and enabling
  technologies within an object-oriented software framework for the
  solution of large-scale, complex multi-physics engineering and
  scientific problems. A unique design feature of Trilinos is its
  focus on packages."
  + Site: https://trilinos.github.io/
  + Repo: https://github.com/trilinos/Trilinos
  + See:
    + https://en.wikipedia.org/wiki/Trilinos

+ *FFTW* - "FFTW is a C subroutine library for computing the discrete
  Fourier transform (DFT) in one or more dimensions, of arbitrary
  input size, and of both real and complex data (as well as of
  even/odd data, i.e. the discrete cosine/sine transforms or
  DCT/DST). We believe that FFTW, which is free software, should
  become the FFT library of choice for most applications." 
  + Site: http://www.fftw.org/

+ *Apophenia* - "Apophenia is an open statistical library for working
  with data sets and statistical models. It provides functions on the
  same level as those of the typical stats package (such as OLS,
  Probit, or singular value decomposition) but gives the user more
  flexibility to be creative in model-building. The core functions
  are written in C, but experience has shown them to be easy to bind
  to in Python/Julia/Perl/Ruby/&c. It is written to scale well, to
  comfortably work with gigabyte data sets, million-step simulations,
  or computationally-intensive agent-based models."
  + Site: http://apophenia.info/
  + Repo: https://github.com/b-k/apophenia

*** CAS - Computer Algebra System, Symbolic Manipulation and Formula Evaluation 

+ *TinyExpr* - tiny recursive descent expression parser, compiler, and
  evaluation engine for math expressions.
  + Site: https://codeplea.com/tinyexpr
  + Repo: https://github.com/codeplea/tinyexpr

+ *SymEngine* - SymEngine is a fast symbolic manipulation library,
  written in C++
  + Site: https://www.sympy.org/en/index.html
  + Repo: https://github.com/symengine/symengine

+ *GiNac* - "GiNaC is a C++ library. It is designed to allow the
  creation of integrated systems that embed symbolic manipulations
  together with more established areas of computer science (like
  computation- intense numeric applications, graphical interfaces,
  etc.) under one roof. It is distributed under the terms and
  conditions of the GNU general public license (GPL). GiNaC is an
  iterated and recursive acronym for GiNaC is Not a CAS, where CAS
  stands for Computer Algebra System." 
  + Site: https://ginac.de/

+ *FORM* - The FORM project for symbolic manipulation of very big
  expressions.
  + Site: https://www.nikhef.nl/~form/aboutform/aboutform.html
  + Repository: https://github.com/vermaseren/form

+ *Exprtk* (Formula parser and evaluator) - "The C++ Mathematical
  Expression Toolkit Library (ExprTk) is a simple to use, easy to
  integrate and extremely efficient run-time mathematical expression
  parser and evaluation engine. ExprTk supports numerous forms of
  functional, logical and vector processing semantics and is very
  easily extendible."
  + Site: http://www.partow.net/programming/exprtk/
  + Repo: https://github.com/ArashPartow/exprtk

+ *IXION* - (Formula/spreadsheet evaluator) - "Ixion is a general
  purpose formula parser & interpreter that can calculate multiple
  named targets, or "cells". The goal of this project is to create a
  library for calculating the results of formula expressions stored in
  multiple named targets, or "cells".  The cells can be referenced
  from each other, and the library takes care of resolving their
  dependencies automatically upon calculation. The caller can run the
  calculation routine either in a single-threaded mode, or a
  multi-threaded mode.  The library also supports re-calculations
  where the contents of one or more cells have been modified since the
  last calculation, and a partial calculation of only the affected
  cells need to be calculated."
  + Site: https://ixion.readthedocs.io/en/latest/cpp/index.html
  + Repo: https://gitlab.com/ixion/ixion

*** Linear Algebra

+ [[https://www.boost.org/doc/libs/1_69_0/libs/numeric/ublas/doc/index.html][Boost.Ublas]] - "uBLAS is a C++ template class library that provides
  BLAS level 1, 2, 3 functionality for dense, packed and sparse
  matrices. The design and implementation unify mathematical notation
  via operator overloading and efficient code generation via
  expression templates." 

+ [[http://eigen.tuxfamily.org/index.php?title=Main_Page#Documentation][Eigen]] - "Eigen is a C++ template library for linear algebra:
  matrices, vectors, numerical solvers, and related algorithms."

+ [[http://arma.sourceforge.net/][Armadillo]] - "C++ library for linear algebra & scientific computing"

+ [[https://sourceforge.net/projects/blitz/][Blitz++]] - "Blitz++ is a C++ class library for scientific computing
  which provides performance on par with Fortran 77/90. It uses
  template techniques to achieve high performance. Blitz++ provides
  dense arrays and vectors, random number generators, and small
  vectors (useful for representing multicomponent or vector fields)."

+ [[https://bitbucket.org/blaze-lib/blaze][Blaze]] - "Blaze is an open-source, high-performance C++ math library
  for dense and sparse arithmetic. With its state-of-the-art Smart
  Expression Template implementation Blaze combines the elegance and
  ease of use of a domain-specific language with HPC-grade
  performance, making it one of the most intuitive and fastest C++
  math libraries available."

+ [[https://github.com/wichtounet/etl][ETL]] - Expression Templates Library (ETL) with GPU support

+ [[https://sleef.org/][SLEEF]] - SLEEF Vectorized Math Library - " SLEEF stands for SIMD
  Library for Evaluating Elementary Functions. It implements
  vectorized versions of all C99 real floating point math
  functions. It can utilize SIMD instructions of modern
  processors. SLEEF is designed to fully utilize SIMD computation by
  reducing the use of conditional branches and scatter/gather memory
  access. Our benchmarks show that the performance of SLEEF is
  comparable to that of the best commercial library. Unlike
  vendor-tuned libraries, SLEEF is portable : it can be easily ported
  to other architectures by writing a helper file, which is a thin
  abstraction layer of SIMD intrinsics. SLEEF is also designed to
  work with various operating systems and compilers." 
  + https://github.com/shibatch/sleef
*** Optimization

+ [[https://www.kthohr.com/optimlib.html][Optmlib]] - "OptimLib is a lightweight C++ library of numerical
  optimization methods for nonlinear functions."
  + https://github.com/kthohr/optim
*** Finite Element Methods 
 
+ *getfem* - "GetFEM++ is an open source library based on collaborative
  development. It aims to offer the most flexible framework for
  solving potentially coupled systems of linear and nonlinear partial
  differential equations with the finite element method. GetFEM++ is
  interfaced with some script languages (Python, Scilab and Matlab)
  so that almost all of the functionalities can be used just writing
  scripts. It works in arbitrary dimension and allow to couple 1D, 2D
  and 3D problems. GetFEM++ can be used to construct very generic
  finite element codes, where finite element methods, integration
  methods and the dimension of the problem are the parameters that
  can be changed very easily. This allows a wide range of
  experiments. Many examples and demos are provided." 
  + Site: http://getfem.org/

+ *MFem* - MFEM is a free, lightweight, scalable C++ library for finite
  element methods.
  + Features
    + Arbitrary high-order finite element meshes and spaces.
    + Wide variety of finite element discretization approaches.
    + Scalable to hundreds of thousands of cores.
  + Site: https://mfem.org/
  + Repo: https://github.com/mfem/mfem

+ *OFELI* - An Object Oriented Finite Element Library
  + "Based on a long experience in the development of finite element
    software, OFELI (Object Finite Element LIbrary) is a framework of
    C++ classes for the development of finite element programs. Its
    main features are:"
    + Various storage schemes of matrices (dense, sparse, skyline).
    + Direct methods of solution of linear systems of equations as well
      as various combinations of iterative solvers and
      preconditioners. 
    + Shape functions of most "popular" finite elements
    + Numerical solution of eigenvalue problems
    + Classes for the solution of most popular problems (Heat
      Transfer, Fluid Flow, Solid Mechanics, Electromagnetics, ...).
  + Site: http://www.ofeli.org/
** Domain Specific Scientific and Engineering Libraries :math:scientific:technical:hpc:

 * [[https://root.cern.ch/doc/v606/dir_90274118d43186b3dd199f7d2c0e1afe.html][CERN's Root Framework]] (Domain: High Energy Physics)
   + Description: ROOT Framework comprises the Cling C++ interactive
     interpreter; C++ reflection system (reflex); special mathematical
     functions ; plotting tools and GUI.
   + [[http://alicematters.web.cern.ch/?q=content/node/1053][40 Years of Large Scale Data Analysis in HEP: Interview with René Brun | ALICE Matters]]
   + 

 * [[https://cpp.openfoam.org/v6/index.html][OpenFoam]] (Domain: Physics, Mechanical Engineering and Chemical Engineering)
   * Open Source C++ library for CFD (Computational Fluid
     Dynamics) with toolboxes for fluid dynamics, chemical reactions,
     turbulence, heat transfer and so on.
   * More at: https://en.wikipedia.org/wiki/OpenFOAM
   * Doxygen Configuration:
     * https://github.com/OpenFOAM/OpenFOAM-6/tree/master/doc

 * [[http://mechsys.nongnu.org/][Mechsys]] - Multi-physics Simulation Library (Domain: Physics,
   Mechanical and Chemical Engineering) - "MechSys is aprogramming
   library for the implementation of simulation tools in
   mechanics. Its source code is mainly written in C++ with easier to
   use templates for further customization. Potential applications
   include, for instance, *solid mechanics* and the *dynamics of granular*
   materials using the *discrete element method*, and both computational
   *fluid dynamics* and *computational electromagnetics* using the *lattice*
   *Boltzmann method.*"

 * [[http://www.palabos.org/][Palabos]] - [[http://www.palabos.org/documentation/develguide/index.html][Doxygen]] (Domain: Physics, Mechanical/Chemical Engineering CFD)
   * Library for CFD - Computational Fluid Dynamics based on the
     lattice Boltzmann method. 

 * [[http://cantera.github.io/docs/sphinx/html/index.html][Cantera]] - [[http://web.mit.edu/2.62/cantera/doc/html/namespaceCantera.html][Doxygen]] (Domain: Chemical Engineering, Thermodynamics and Transport Processes)
   * "Cantera is an open-source suite of object-oriented software
     tools for problems involving chemical kinetics, thermodynamics,
     and/or transport processes. The software automates the chemical
     kinetic, thermodynamic, and transport calculations so that the
     users can efficiently incorporate detailed chemical
     thermo-kinetics and transport models into their calculations. The
     code utilizes object-oriented concepts for robust yet flexible
     phase models, and algorithms are generalized so that users can
     explore different phase models with minimal changes to their
     overall code. Currently, Cantera can be used from Python and
     Matlab, or in applications written in C/C++ and
     Fortran 90. Cantera also provides a limited number of solvers for
     time-dependent reactor networks and steady one-dimensional
     reacting flows. Cantera is currently used for applications
     including combustion, detonations, electrochemical energy
     conversion and storage, fuel cells, batteries, aqueous
     electrolyte solutions, plasmas, and thin film deposition."

 * [[https://libantioch.github.io/][Antioch]] - C++ Chemical Kinetics, Thermodynaimics, and Transport
   Library - "A New Templated Implementation Of Chemistry for
   Hydrodynamics (Antioch) was initiated to centralize work by some of
   the Antioch authors within the realm of hypersonic aerodynamics,
   based on the libMesh finite element library. In particular,
   although there exist C++ chemistry libraries, such as Cantera, we
   had needs for both thread-safety and high performance. Thus,
   Antioch was born. Antioch originally lived within the PECOS center
   at the Institute for Computational Engineering and Sciences (ICES)
   at The University of Texas at Austin." 
   * Repo: https://github.com/libantioch/antioch
   * [[https://libantioch.github.io/antioch/v0.4.0/html/namespaces.html][Doxygen docs]]

 * [[https://github.com/CoolProp/IF97][CoolProp/IF97]] - (Domain: Mechanical and Chemical Engineering) -
   Open-source C++ implementation of the IAPWS-IF97 equations - IAPWS
   Industrial Formulation 1997 for the Thermodynamic Properties of
   Water and Steam. Note: software for computing water and steam
   thermodynamic properties (Steam tables). 

 * [[https://www.roboticslibrary.org/][Robotics Library]] - [[http://doc.roboticslibrary.org/0.7.0/index.html][Doxygen]] (Domain: Robotics Kinematics, Mechanical Engineering)
   * "The Robotics Library (RL) is a self-contained C++ library for
     robot kinematics, motion planning and control. It covers
     mathematics, kinematics and dynamics, hardware abstraction,
     motion planning, collision detection, and visualization. It is
     being used by several research projects (e.g., JAHIR, JAMES,
     JAST, SMErobotics) and in education, available under a BSD
     license, and free for use in commercial applications."

 * [[https://www.groundai.com/project/the-control-toolbox-an-open-source-c-library-for-robotics-optimal-and-model-predictive-control/][Control Toolbox]] - [[https://adrlab.bitbucket.io/ct/v2.3/ct_doc/doc/html/index.html][Doxygen]] (Domain: Robotics, Control Systems, Mechanical Engineering)
   * "This is the ADRL Control Toolbox ('CT'), an open-source C++
     library for efficient modelling, control, estimation, trajectory
     optimization and model predictive control. The CT is applicable
     to a broad class of dynamic systems, but features additional
     modelling tools specially designed for robotics. This page
     outlines its general concept, its major building blocks and
     highlights selected application examples. The library contains
     several tools to design and evaluate controllers, model dynamical
     systems and solve optimal control problems."

 * [[https://drake.mit.edu/][Drake]] - [[https://drake.mit.edu/doxygen_cxx/index.html#://][Doxygen]] Collection of C++ tools for analysing Robot dynamics and
   building motion control systems.
   * "While there are an increasing number of simulation tools
     available for robotics, most of them function like a black box:
     commands go in, sensors come out. Drake aims to simulate even
     very complex dynamics of robots (e.g. including friction,
     contact, aerodynamics, …), but always with an emphasis on
     exposing the structure in the governing equations (sparsity,
     analytical gradients, polynomial structure, uncertainty
     quantification, …) and making this information available for
     advanced planning, control, and analysis algorithms. Drake
     provides interfaces to high-level languages (MATLAB, Python, …)
     to enable rapid-prototyping of new algorithms, and also aims to
     provide solid open-source implementations for many
     state-of-the-art algorithms. Finally, we hope Drake provides many
     compelling examples that can help people get started and provide
     much needed benchmarks. We are excited to accept user
     contributions to improve the coverage."

 * [[http://jsbsim.sourceforge.net/][JBSim]] - [[https://jsbsim-team.github.io/jsbsim/index.html#intro][Doxygen]] (Domain: Aerospace/Mechanical Engineering)
   * An open source, platform-independent, flight dynamics & control
     software library in C++
   * "JSBSim is an open source flight dynamics model (FDM) that
     compiles and runs under many operating systems, including
     Microsoft Windows, Apple Macintosh, Linux, IRIX, Cygwin (Unix on
     Windows), etc. The FDM is essentially the physics/math model that
     defines the movement of an aircraft, rocket, etc., under the
     forces and moments applied to it using the various control
     mechanisms and from the forces of nature. JSBSim has no native
     graphics. It can be run by itself as a standalone program, taking
     input from a script file and various vehicle configuration
     files. It can also be incorporated into a larger flight simulator
     implementation that includes a visual system."

 * [[https://simtk.org/][simtk]] - [[https://simtk.org/api_docs/opensim/api_docs/index.html][Doxygen]] (Domain: Biomedical research.)

 * [[https://libpf.com/docs/manuals/sdk.html][LIBPF]] - Flexible Process Flowsheeting [Commercial] => Library for
   modelling continous processes. (Chemical Engineering)
   + "LIBPF™: (LIBrary for Process Flowsheeting), library developed in
     C++ language, which includes objects well-known to a process
     engineer (dimensional quantities, material streams, reactions,
     phase separators, heat exchangers, reactors, etc.). This library
     make possible the creation of executable applications specific
     for a particular continuous industrial process. It is oriented to
     a system modeling and not for detailed single unit operation
     modeling." 

 * [[http://kalman.sourceforge.net/][KFilter]] -  KFilter - Free C++ Extended Kalman Filter Library
   * "KFilter is a library implementing an Extended Kalman Filter in
     C++. Configurable template classes are available. Subclassing
     allows to define different matrix contents for the filter to work
     with. Kalman filters are used for some time now, in aeronautics,
     robot vision and robotics in general. It is useful to estimate a
     state vector and correct the estimation by using measures taken
     from sensors. Its main uses is for tracking or data fusion. The
     library is fully operational and has been used in two research
     projects at Ecole Polytechnique de Montreal."

 * [[http://web.mit.edu/drela/Public/web/avl/][AVL]] - "AVL is a program for the aerodynamic and flight-dynamic
   analysis of rigid aircraft of arbitrary configuration. It employs
   an extended vortex lattice model for  the lifting surfaces,
   together with a slender-body model for fuselages and nacelles.
   General nonlinear flight states can be specified. The flight
   dynamic analysis  combines a full linearization of the aerodynamic
   model about any flight state,  together with specified mass
   properties."
   * Note: NOT A LIBRARY, it is an open source program written in C.
   * Video: [[https://www.youtube.com/watch?v=kS9iPD5irIo][Introduction to Aerodynamic Analysis using AVL]]
   * Related Repositories:
     + https://github.com/renoelmendorp/AVLWrapper
     + https://github.com/RobotLocomotion/avl (Fork of Mark Drela's
       AVL software (http://raphael.mit.edu/avl) which builds using
       cmake.)

 * [[http://fdtd.kintechlab.com/en/start][EMTL]] - *Electromagnetic Template Library* (Domain: Electronic
   Engineering and Physics) - is a С++ library forprogramming
   Finite-Difference Time-Domain (FDTD) simulations.
   * "The program is designed for quick and efficient programming of
     FDTD simulations and for extending the available FDTD algorithms
     with new techniques and features. The code implements fully
     functional API including MPI parallelization."
   * Capabilities
     * Calculation of the distribution of electromagnetic fields in a structure;
     * Real-time simulation of the propagation of electromagnetic wave packet through a structure;
     * Calculation of the transmission, reflection, and absorption
       coefficients as functions of incident wavelength and angle for
       periodic structures;
     * Calculation of the scattering cross-section and the angle
       distribution of the scattered wave for objects of arbitrary
       shape;
     * Sensitivity analysis of the impact of defects on the optical
       properties of periodic structures (photonic crystals);
     * Calculation of transfer-matrix (T-matrix) for planar layers of
       arbitrarily shaped scatterers;

 * [[https://github.com/tmolteno/necpp][NECPP]] - Antenna Modelling Library -  rewrite of the Numerical
   Electromagnetics Code (NEC-2) 
   * "NEC2++ is a C++ rewrite of the Numerical Electromagnetics Code
     (NEC-2) with many new features like automatic error detection
     when you specify the structure incorrectly and much faster
     execution. Nec2++ can analyse radiating as well as scattering
     properties of structures. The simulation engine in Nec2++ is
     compiled into a library for easy integration."
   * See:
     * http://elec.otago.ac.nz/w/index.php/Necpp
     * [[https://en.wikipedia.org/wiki/Numerical_Electromagnetics_Code][Numerical Electromagnetics Code]]
     * https://www.nec2.org/

 * [[https://github.com/gnuradio/gnuradio][GNU Radio]] - "GNU Radio is a free & open-source software
   development toolkit that provides signal processing blocks to
   implement software radios. It can be used with readily-available,
   low-cost external RF hardware to create software-defined radios,
   or without hardware in a simulation-like environment. It is
   widely used in hobbyist, academic, and commercial environments to
   support both wireless communications research and real-world
   radio systems."
   * Site: https://www.gnuradio.org/
   * Repo: https://github.com/gnuradio/gnuradio

 * [[https://github.com/kit-cel/gr-radar][gr-radio]] - *GNU Radio Radar Toolbox*
   * Site: https://grradar.wordpress.com/
   * Repo: https://github.com/kit-cel/gr-radar
   * See:
     * [[https://www.rochesterham.org/meetings/2015-12_SDR_Program.pdf][Exploring RF with Software Defined Radio]]
     * [[https://www.youtube.com/watch?v=WeGSCGN8DIo][gr-radar: GUI Demonstration with FSK Radar]]

 * [[https://github.com/hmatuschek/libsdr][LIBSDR]] - A simple software defined radio (SDR) library
   * Doxygen: https://hmatuschek.github.io/libsdr/

 * [[https://github.com/seqan/seqan][Seqan]] - The Library for Sequence Analysis (Biology)
   * "SeqAn is an open source C++ library of efficient algorithms and
     data structures for the analysis of sequences with the focus on
     biological data. Our library applies a unique generic design that
     guarantees high performance, generality, extensibility, and
     integration with other libraries. SeqAn is easy to use and
     simplifies the development of new software tools with a minimal
     loss of performance."

 * [[https://www.openchemistry.org/][Openchemistry]] 
   + "The Open Chemistry project is a collection of open source, cross
     platform libraries and applications for the exploration, analysis
     and generation of chemical data. The project builds upon various
     efforts by collaborators and innovators in open chemistry such as
     the Blue Obelisk, Quixote and the associated projects. We aim to
     improve the state of the art, and facilitate the open exchange of
     ideas and exchange of chemical data leveraging the best
     technologies ranging from quantum chemistry codes, molecular
     dynamics, informatics and visualization. This repository contains
     git submodules for the Open Chemistry projects: Avogadro,
     MoleQueue and MongoChem. It can be used to download all relevant
     source files as well as building many of the necessary
     dependencies. Please see the documentation in the submodules for
     more details about each project."
     + Repository: https://github.com/cryos/openchemistry

** Machine Learning and Computer Vision

 + [[https://docs.opencv.org/3.4/d4/db1/tutorial_documentation.html][OpenCV]] - Computer Vision / Machine Learning - The most well-known
   computer vision and image processing library. 
   * Repo: https://github.com/opencv/opencv

 + [[http://dlib.net/][Dlib]] - Open source library for deep learning, numerical algorithms,
   networks and image processing.

 + [[http://torch.ch/][Torch]] - "Torch is a scientific computing framework with wide support
   for machine learning algorithms that puts GPUs first. It is easy to
   use and efficient, thanks to an easy and fast scripting language,
   LuaJIT, and an underlying C/CUDA implementation."
   + Repo: https://github.com/torch/torch7

 + [[http://www.csie.ntu.edu.tw/~cjlin/liblinear/][liblinear]]

 + [[http://mlpack.org/][Mlpack]] - Machine Learning Package 

 + [[http://shogun-toolbox.org/][Shogun Toolbox]] - "Shogun is and open-source machine learning
   library that offers a wide range of efficient and unified machine
   learning methods." 

 + [[http://leenissen.dk/fann/wp/][Fann]] - "Fast Artificial Neural Network Library is a free open
   source neural network library, which implements multilayer
   artificial neural networks in C with support for both fully
   connected and sparsely connected networks. Cross-platform execution
   in both fixed and floating point are supported. It includes a
   framework for easy handling of training data sets. It is easy to
   use, versatile, well documented, and fast. Bindings to more than 20
   programming languages are available. An easy to read introduction
   article and a reference manual accompanies the library with
   examples and recommendations on how to use the library. Several
   graphical user interfaces are also available for the library."

** Parsers 
*** Libraries for building parsers 

String Processing Libraries
 
 + [[http://www.partow.net/programming/strtk/][StrTk - C++ String Toolkit Library]] - " The C++ String Toolkit
   Library (StrTk) consists of robust, optimized and portable string
   processing algorithms for the C++ language. StrTk is designed to be
   easy to use and integrate within existing code bases. Furthermore
   the library has a rich set of features that makes light work of any
   kind of string processing task." 

Parser Framework Libraries 

 * [[https://www.boost.org/doc/libs/1_69_0/libs/spirit/][Boost Spirit]] - Framework for building parsers which makes heavy use
   of template metaprogramming.

 * [[https://github.com/taocpp/PEGTL][PEGTL]] - "The Parsing Expression Grammar Template Library (PEGTL) is
   a zero-dependency C++ header-only parser combinator library for
   creating parsers according to a Parsing Expression Grammar (PEG)." 

 * [[https://github.com/r35382/bnflite][Bnflite]] - "BNFLite is a C++ template library for lightweight
   flexible grammar parsers. BNFLite offers creative approach when the
   developer can specify a language for further parsing directly in
   the C++ code. Moreover, such 'specifications' are executable now!
   Once the author participated in the development of some tool which
   was invented to integrate together a lot of proprietary
   modules. There were thousands combinations of command line options,
   poor examples, ambiguous docs. So the command line was not
   compatible from version to version. Up-to-date formal BNF specs of
   the command line language could help but not for projects with
   limited budget. Starting YACC era, there is a solution to support
   some extra executable code describing language specifics. As a
   rule, usage of such means is too heavy because it is extra stuff
   and it is not BNF. BNFLite does not have such drawbacks!"

 * [[https://github.com/TheLartians/Parser][TheLartians/Parser]] - "Build your own programming language! A C++17
   PEG parser generator supporting parser combination, memoization,
   left-recursion and context-dependent grammars. A linear-time C++17
   PEG parser generator supporting memoization, left-recursion and
   context-dependent grammars."

 * [[https://github.com/jwtowner/lug][jwtowner/lug]] - "Parsing expression grammar (PEG) embedded domain
   specific language and parsing machine for C++17."
   + Features:
     + Natural syntax more akin to external parser generator languages
     + Separation of syntatic and lexical rules, with customizable implicit whitespace skipping
     + Direct and indirect left recursion with precedence levels to
       disambiguate subexpressions with mixed left/right recursion
     + Header only library using C++17 language and library features
     + Relatively small with the intent of parser core to remain under 1500 lines of terse code
     + ... and more ... 

 * [[https://panthema.net/2007/stx-exparser/][STX-EXPARSER]] - "The STX Expression Parser provides a C++ framework,
   which can process user-specified expression strings containing
   program-specific variables. It can be integrated into applications
   to allow user-customized data selection and filtering. The
   expresssion strings are intuitive SQL-like WHERE-clauses and can
   contain arbitrarily complex arithmetic. At the same time the parse
   tree evaluation speed is guaranteed to be fast enough to safely
   iterate over larger data sets. The framework uses the Boost.Spirit
   parser library combined with a versatile custom scalar value
   class. The expression parser can process arbitrarily complex
   arithmetic expressions like those seen below. To access
   application-defined data, functions and variables may be included
   in the expression. An expression can be used as a boolean filter by
   using comparison and logic operators." 

 * [[https://github.com/grievejia/pcomb][PCOMB]] - "A lightweight parser combinator library written in
   C++14. Efficiency is not the goal of this library. After all,
   parsing is almost never a perfomrance bottleneck of a program
   analysis system. That being said, I try to avoid using heap
   allocation as much as possible. Most part of the parser is
   implemented with template metaprogramming and a small part is
   implemented using class inheritance. "

 * [[https://github.com/FrancoisChabot/abulafia][Abulafia]] - "A standalone C++ parsing framework - Abulafia is a C++
   expression templates library that generates parsers. The idea is to
   let programs contain ABNF-like grammars embedded directly within
   the code. It's heavily inspired by Boost::spirit::QI, but differs
   fundamentally from it in a number of respects. WARNING: Abulafia is
   still in early development. While many features work as intended,
   there are still a LOT of work to be done before it can be
   considered usable in a real environment."

Parser Code Generator 

 * [[https://www.antlr.org/][ANTLR]] - "ANTLR (ANother Tool for Language Recognition) is a
   powerful parser generator for reading, processing, executing, or
   translating structured text or binary files. It's widely used to
   build languages, tools, and frameworks. From a grammar, ANTLR
   generates a parser that can build and walk parse trees."
   + Note: Tool similar to flex/bison. It is Java application (jar
     executable) that can generate parser code for many programming
     languages including C++, C# (CSharp), Java, Python and ECMaScript
     (+JavaScript)+.
   + See:
     + https://tomassetti.me/getting-started-antlr-cpp/
     + https://github.com/antlr/antlr4/blob/master/doc/cpp-target.md
     + https://github.com/antlr/grammars-v4 - Colleciton of Antlr 4 Grammars.

*** XML - Extensible Markup Language

Types of XML Parser Libraries: 
 
 + DOM  (Document Object Model) based => Parses the XML building an
   tree data structure in the memory.

 + [[https://en.wikipedia.org/wiki/Simple_API_for_XML][SAX]] (Simple API for XML) based => Event driven API that works by
   defining callbacks that are called when the tree is parsed. The
   advantage is that the XML is not loaded entirely in the memory at
   once which gives a small memory footprint. 

 + [[https://en.wikipedia.org/wiki/XPath][XPath]]  based => The XML is parsed directly using XPATH query language.

Some XML Libraries 

 + [[http://rapidxml.sourceforge.net/][RapidXML]]

 + [[http://xmlsoft.org/][Libxml2]]

 + [[http://xerces.apache.org/xerces-c/][Xerces C++]]

 + [[http://pugixml.org/][Pugixml]]

 + [[http://www.grinninglizard.com/tinyxml/][TinyXML]]
*** JSON - JavaScript Object Notation

 + [[https://github.com/Tencent/rapidjson/][RapidJSON]] - [HEADER ONLY] "A fast JSON parser/generator for C++
   with both SAX/DOM style API. RapidJSON is a JSON parser and
   generator for C++. It was inspired by RapidXml." 
   * Documentation: http://rapidjson.org/
   * Developed by: Tencent 
   * RapidJSON is small but complete. It supports both SAX and DOM
     style API. The SAX parser is only a half thousand lines of code.
   * RapidJSON is fast. Its performance can be comparable to
     strlen(). It also optionally supports SSE2/SSE4.2 for
     acceleration.
   * RapidJSON is self-contained and header-only. It does not depend
     on external libraries such as BOOST. It even does not depend on
     STL.
   * RapidJSON is memory-friendly. Each JSON value occupies exactly 16
     bytes for most 32/64-bit machines (excluding text string). By
     default it uses a fast memory allocator, and the parser allocates
     memory compactly during parsing.
   * RapidJSON is Unicode-friendly. It supports UTF-8, UTF-16, UTF-32
     (LE & BE), and their detection, validation and transcoding
     internally. For example, you can read a UTF-8 file and let
     RapidJSON transcode the JSON strings into UTF-16 in the DOM. It
     also supports surrogates and "\u0000" (null character).

 + [[https://github.com/taocpp/json][taoJSON]] [Requires C++17] - "taoJSON is a zero-dependency C++
   header-only JSON library that provides a generic Value Class, uses
   Type Traits to interoperate with C++ types, uses an Events
   Interface to convert from and to JSON, JAXN, CBOR, MsgPack and
   UBJSON, and much more..."

 + [[https://github.com/dropbox/json11][JSON11]] - "json11 is a tiny JSON library for C++11, providing JSON
   parsing and serialization."
   + Developed by: Dropbox
   + Maintenance note: "This repo is stable but no longer
     actively maintained. No further development is planned, and no
     new feature PRs will be merged. Bug fixes may be merged on a
     volunteer basis. If you have questions or want to talk to other
     users of Djinni, you can join the Slack community via the link at
     the end of this document."

 + [[https://github.com/nlohmann/json][Github - nlohmann/json]] - "JSON for Modern C++"
   * Doxygen: https://nlohmann.github.io/json/

 + [[https://github.com/kazuho/picojson][PicoJSON]]  - "PicoJSON is a tiny JSON parser / serializer for C++
   with following properties: header-file only, no external
   dependencies (only uses standard C++ libraries), STL-frendly
   (arrays are represented by using std::vector, objects are
   std::map), provides both pull interface and streaming (event-based)
   interface."

 + [[https://github.com/lloyd/yajl][YAJL]] [C Library] - "A fast streaming JSON parsing library in C."
   + Site: http://lloyd.github.io/yajl/
   + "YAJL is data representation independent - BYODR!  Many JSON
     libraries impose a structure based data representation on you.
     This is a benefit in some cases and a drawback in others. YAJL
     uses callbacks to remain agnostic of the in-memory
     representation. So if you wish to build up an in-memory
     representation, you may do so using YAJL, but you must bring the
     code that defines and populates the in memory structure."
   + "AJL supports stream parsing - This means you do not need to hold
     the whole JSON representation in textual form in memory.  This
     makes YAJL ideal for filtering projects, where you're converting
     YAJL from one form to another (i.e. XML).  The included JSON
     pretty printer is an example of such a filter program."
   + "YAJL is fast - Minimal memory copying is performed.  YAJL, when
     possible, returns pointers into the client provided text
     (i.e. for strings that have no embedded escape chars, hopefully
     the common case).  I've put a lot of effort into profiling and
     tuning performance, but I have ignored a couple possible
     performance improvements to keep the interface clean, small, and
     flexible.  My hope is that YAJL will perform comparably to the
     fastest JSON parser out there." 

*** CSV - Comma Separated Value Files 

 * [[https://github.com/d99kris/rapidcsv/][rapidcsv]]  - "Rapidcsv is a C++ header-only library
   for CSV parsing. While the name admittedly was inspired by the
   rapidjson project, the objectives are not the same. The goal of
   rapidcsv is to be an easy-to-use CSV library enabling rapid
   development. For optimal performance (be it CPU or memory usage) a
   CSV parser implemented for the specific use-case is likely to be
   more performant."
   + License: BSD-3  

 * [[https://github.com/awdeorio/csvstream/][csvstream]] - "An easy-to-use CSV file parser for C++."
   + License: MIT

 * [[https://github.com/ben-strasser/fast-cpp-csv-parser][fast-cpp-csv-parser]] - "This is a small, easy-to-use and fast
   header-only library for reading comma separated value (CSV)
   files."
   * License: BSD-3 
   * Features:
     + Automatically rearranges columns by parsing the header line.
     + Disk I/O and CSV-parsing are overlapped using threads for efficiency.
     + Parsing features such as escaped strings can be enabled and
       disabled at compile time using templates. You only pay in speed
       for the features you actually use.
     + Can read multiple GB files in reasonable time.
     + Support for custom columns separators (i.e. Tab separated value
       files are supported), quote escaped strings, automatic space
       trimming.
     + Works with *nix and Windows newlines and automatically ignores
       UTF-8 BOMs.
     + Exception classes with enough context to format useful error
       messages. what() returns error messages ready to be shown to a
       user. 

*** TOML - Configuration File Format 
**** Overview 

TOML is a minimal human-readable and human-friendly configuration file
based on Windows INI file format. 

Specification: 
  + https://github.com/toml-lang/toml/blob/master/versions/en/toml-v0.5.0.md

Example of a TOML file: 

#+BEGIN_SRC conf 
  # This is a TOML document.

  title = "TOML Example"

  [owner]
  name = "Tom Preston-Werner"
  dob = 1979-05-27T07:32:00-08:00 # First class dates

  [database]
  server = "192.168.1.1"
  ports = [ 8001, 8001, 8002 ]
  connection_max = 5000
  enabled = true

  [servers]

    # Indentation (tabs and/or spaces) is allowed but not required
    [servers.alpha]
    ip = "10.0.0.1"
    dc = "eqdc10"

    [servers.beta]
    ip = "10.0.0.2"
    dc = "eqdc10"

  [clients]
  data = [ ["gamma", "delta"], [1, 2] ]

  # Line breaks are OK when inside arrays
  hosts = [
    "alpha",
    "omega"
  ]
#+END_SRC

**** Libraries 

 + [[https://github.com/skystrife/cpptoml][cpptompl]] - "cpptoml is a header-only library for parsing TOML."

 + [[https://github.com/ToruNiina/toml11][toml11]] - "toml11 is a C++11 header-only toml parser/encoder
   depending only on C++ standard library. compatible to the latest
   version of TOML v0.5.0 after version 2.0.0. " 

 + [[https://github.com/brglng/libtoml][libtoml]] - "Very tiny TOML parser and encoder in C. To build this
   library, compiler with C99 support is required."

 + [[https://github.com/mayah/tinytoml][tinytoml]] - "A header only C++11 library for parsing TOML. This
   parser is based on TOML v0.4.0. This library is distributed under
   simplified BSD License. tinytoml is a tiny TOML parser for C++11
   with following properties:"
   + header file only
   + C++11 library friendly (array is std::vector, table is std::map,
     time is std::chrono::system_clock::time_point).
   + no external dependencies (note: we're using cmake for testing,
     but it's not required to use this library). 

*** HCON - Human-Optimized Config Object Notation

 *Overview:*

HCON is a configuration file-format that is more ligthweight and
readable than JSON. The syntax looks like JSON and QT's QML. 

 + Specification:
   https://github.com/lightbend/config/blob/master/HOCON.md

 *Parsers* 

 + [[https://github.com/puppetlabs/cpp-hocon][cpp-hcon]] - A C++ port of the Typesafe Config library.

** REPL/SHELL - Interactive Command Line Interface - Terminal 

  + *replxx* - "A readline and libedit replacement that supports UTF-8,
    syntax highlighting, hints and Windows and is BSD licensed." 
    + repo: https://github.com/AmokHuginnsson/replxx

  + *Cli* - "A library for interactive command line interface in modern C++"
    + repo: https://github.com/daniele77/cli

  + *EditLine* (C Library) - "This is a small line editing library. It can
    be linked into almost any program to provide command line editing
    and history functions. It is call compatible with the FSF readline
    library, but at a fraction of the size, and as a result fewer
    features. It is also distributed under a much more liberal
    License. The small size (<30k), lack of dependencies (ncurses not
    needed!), and the free license should make this library interesting
    to many embedded developers." 
    + Site:  https://troglobit.com/projects/editline/
    + Repo: https://github.com/troglobit/editline

** Reflection 

  * [[https://www.rttr.org/][RTRR]] - *Runtime Type Reflection* - "RTTR stands for Run Time Type
    Reflection. It describes the ability of a computer program to
    introspect and modify an object at runtime. It is also the name of
    the library itself, which is written in C++ and released as open
    source library. The goal of this project is to provide an easy and
    intuitive way to use reflection in C++."
    + repo: https://github.com/rttrorg/rttr

  * [[https://www.cpgf.org][CPGF]] - "cpgf library is a cross platform C++ library for callback,
    reflection, serialization and script binding. It's written in
    standard C++ and doesn't require any preprocessor or tools. cpgf
    library is a cross platform C++ library for callback, reflection,
    serialization and script binding. It's written in standard C++ and
    doesn't require any preprocessor or tools."
    * Repo: https://github.com/cpgf/cpgf
    * Components in CPFG Library:
      * "cpgf reflection. Add runtime introspection and meta data
        reflection feature to C++. Have you ever envied the reflection
        system in C# and Java? Now we have it in C++!"
      * "cpgf serialization. Save C++ data and objects to persistent
        storage and then load back. Want the same serialization system
        that is in C# and Java? Try cpgf!"
      * "cpgf script binding. A script binding engine to connect Lua,
        Google V8 JavaScript, Python and Mozilla SpiderMonkey to
        C++. Now script binding in C++ is a piece of cake!"
      * "cpgf callback. A callback library to implement
        signal/slot/callback in C++. Want signal and slot without extra
        preprocessor? Try cpgf!"
      * 

  * [[https://github.com/Manu343726/ctti][CTTI]] - *Compile Time Type Information for C++* - "We know C++ is a
    statically typed compiled language, but it's disappointing that we
    cannot even get the name of a C++ type at compile time, having to
    use RTTI (Run Time Type Information) which introduces a lot of
    overhead. In fact, that's one of the most feared features of C++,
    usually disabled in performance dependent scenarios such as
    videogames programming. This library aims to provide features
    similar to RTTI std::type_info at compile-time, currently
    constexpr type name and a constexpr replacement of std::type_index
    for indexing maps with types."

  * [[https://github.com/Celtoys/clReflect][clReflect]] - "C++ Reflection using clang. clReflectTest is an
    up-to-date test of the clReflect library, showing how to build a
    database and load it at runtime. C++ primitives are not reflected
    by default and need to be marked by clcpp_reflect Reflection Specs
    or using reflect attributes." 

  * [[https://github.com/jhenstridge/gobject-cpp-reflection][gobject-cpp-reflection]] - "GObject oriented experiments with C++
    Static Reflection. This repository contains a few utility
    functions that make use of the draft C++ Static Reflection
    standard. Sadly this feature hasn't been included in the C++17
    standard, but an implementation for Clang is available as the
    reflexpr branch of the following repository:
    https://github.com/matus-chochlik/clang"

  * [[https://bitbucket.org/dwilliamson/reflectabit/src/default/][Reflectabit]] - "A minimal, registration-based C++ Reflection
    library." 

  * [[http://kifri.fri.uniza.sk/~chochlik/mirror-lib/html/][Mirror Reflection Utilities]] - "The aim of the Mirror library is to
    provide both compile-time and run-time meta-data describing C++
    constructs like namespaces, types typedef-ined types, enums,
    classes with their base classes, member variables, constructors,
    member functions, etc. and to provide uniform and generic
    interfaces for their introspection. Because standard C++ provides
    only a very limited set of meta-information to build upon, a
    potential drawback of this library is, that namespaces, types,
    classes, etc. need to be registered before they can be
    reflected. However Mirror tries to make the process of registering
    simple by providing a set of user-friendly registering macros and
    has the native and many of the other common types, classes,
    templates and namespaces pre-registered. Furthermore, a portable
    tool for automatic / semi-automatic registering is being worked
    on. Once registered the meta-data can be reused in a large number
    of situations. Mirror is designed with the principle of
    stratification in mind and tries to be as less intrusive as
    possible. New or existing classes do not need to be designed to
    directly support Mirror and no Mirror-related code is necessary in
    the class' definition, as far as some general guidelines are
    followed. This allows you to do reflection even on third-party
    code that you cannot modify."

** Spreadsheet                                       :math:excel:spreadsheet:

   + [[http://xlw.sourceforge.net/][XLW]] - Wrapper for Excel native extension C-API (XLL) which allows to make
     Excel extensions in C++.
     + Fork of XLW for using with CMake: [[https://github.com/caiorss/xlw-cmake-fork][xlw-cmake-fork]]

   + [[http://keyvalue.sourceforge.net/][KeyValue]] (C++ Wrapper for Excel native extension C-API XLL and Libreoffice Calc)
     + "KeyValue is a cross-platform library for making C++ objects
       accessible through LibreOffice Calc, Excel and other
       front-ends. Experience of spreadsheet users is enhanced by an
       object model and a handy key-value based interface. Actually,
       KeyValue does more than just help creating spreadsheet
       functions. The object model allows end-users to build C++ objects
       through the front-ends. These objects are stored in a repository
       for latter use at user's request. Additionally, KeyValue provides
       a set of services for an effective use of these objects. The
       library is named after one of its main features: The key-value
       based interface. Parameters are passed to functions (or, more
       precisely, processors) through key-value pairs in contrast to the
       standard positional interfaces of LibreOffice Calc, Excel, C/C++,
       etc."
     + Features:
       + Cross platform: Compilable by GCC for GNU/Linux and MSVC for Windows.
       + Front-ends: LibreOffice Calc (GNU/Linux and Windows) and Excel
         2007 add-ins are provided. (XML parser planned.)
       + Flexibility: KeyValue does not impose strong constraints on the
         design of libraries it is supposed to help. Therefore, existing
         libraries can use KeyValue without big code refactoring.
       + Loggers: Results, errors and general information can be reported
         in different types of loggers including consoles and files. 

   + [[https://github.com/tfussell/xlnt][XLNT]] - "Cross-platform user-friendly xlsx library for C++14 - xlnt
     is a modern C++ library for manipulating spreadsheets in memory and
     reading/writing them from/to XLSX files as described in ECMA 376
     4th edition. The first public release of xlnt version 1.0 was on
     May 10th, 2017. Current work is focused on increasing
     compatibility, improving performance, and brainstorming future
     development goals. For a high-level summary of what you can do with
     this library, see the feature list. Contributions are welcome in
     the form of pull requests or discussions on the repository's Issues
     page."

   + [[https://github.com/pyxll/xlfparser][Xlfparser]] - "Header only C++ library for tokenizing Excel formulas"

   + *IXION* - (Formula/spreadsheet evaluator) - "Ixion is a general
     purpose formula parser & interpreter that can calculate multiple
     named targets, or "cells". The goal of this project is to create a
     library for calculating the results of formula expressions stored in
     multiple named targets, or "cells".  The cells can be referenced
     from each other, and the library takes care of resolving their
     dependencies automatically upon calculation. The caller can run the
     calculation routine either in a single-threaded mode, or a
     multi-threaded mode.  The library also supports re-calculations
     where the contents of one or more cells have been modified since the
     last calculation, and a partial calculation of only the affected
     cells need to be calculated."
     + Site: https://ixion.readthedocs.io/en/latest/cpp/index.html
     + Repo: https://gitlab.com/ixion/ixion

** GUI - Graphical User Interface 

  + [[https://www.qt.io/][QT Toolkit]] (QT Framework) [BEST] - Not only a GUI toolkit, but also a
    full-fledge C++ framework with cross platform libraries for
    network, sockets, database access ... and so on.

  + [[http://www.wxwidgets.org/][WxWidgets]] 

  + [[http://www.gtkmm.org/][Gtkmm]] - Gtk (Written in C) + C++ interface
    + GTK is a GUI library derived from GIMP toolkit.
    + Drawback: Hard to use on Windows.

  + [[http://cegui.org.uk/][Cegui]] - Crazy Eddie's GUI System.

  + [[http://www.fltk.org/][Fltk]] - lightweight GUI library.

  + [[http://nanapro.org/en-us/][Nana]]

  + [[https://www.gnu.org/software/ncurses/][Ncurses]] - A (TUI) terminal user interface written in C. Provides
    many terminal widgets.

  + [[https://bitbucket.org/chromiumembedded/cef][CEF]] - Chromium Embedded Framework - "The Chromium Embedded
    Framework (CEF) is a simple framework for embedding Chromium-based
    browsers in other applications." 

  + [[https://sourceforge.net/projects/owlnext/][OWLNext C++ GUI]] [WINDOWS ONLY] - "An extensive update of Borland's Object Windows
    Library (OWL) for writing GUI applications in standard C++ on
    Microsoft Windows." 

  + [[https://juce.com/][Juce]]  [COMMERCIAL]

  + [[https://github.com/ocornut/imgui][Imgui]] - GUI Library for games

** GUI - Plotting Libraries and data visualization 

+ [[https://qwt.sourceforge.io/][Qwt]] (QT Framework Widgets) - Qt Widgets for Technical Applications*
  + License: LGPL

+ [[http://qwtplot3d.sourceforge.net/][Qwtplot3d]] - "QwtPlot3D is not a  program, but a feature-rich
  Qt/OpenGL-based C++ programming library, providing essentially a
  bunch of 3D-widgets for programmers. The library is zlib licensed."

+ [[http://cneben.github.io/QuickQanava/index.html][QuickQanava]] - "QuickQanava is a C++14 library designed to display
  graphs and relational content in a QtQuick application. QuickQanava
  provide QML components and C++ classes to visualize medium-sized
  directed graphs in a C++/QML application. QuickQanava does not
  provide advanced layout algorithms, but rather focus on displaying
  relational content in advanced dynamic user interfaces (with DnD
  support, resizable content, visual connection of nodes)."

+ [[https://www.gnu.org/software/plotutils/][GNU Plotutils]] - " The GNU plotutils package contains software for
  both programmers and technical users. Its centerpiece is libplot, a
  powerful C/C++ function library for exporting 2-D vector graphics
  in many file formats, both vector and bitmap. On the X Window
  System, it can also do 2-D vector graphics animations." 

+ [[http://www.openscenegraph.org/][OpenSceneGraph]] - "The OpenSceneGraph is an open source high
  performance 3D graphics toolkit, used by application developers in
  fields such as visual simulation, games, virtual reality,
  scientific visualization and modelling. Written entirely in
  Standard C++ and OpenGL it runs on all Windows platforms, OSX,
  GNU/Linux, IRIX, Solaris, HP-Ux, AIX and FreeBSD operating
  systems. The OpenSceneGraph is now well established as the world
  leading scene graph technology, used widely in the vis-sim, space,
  scientific, oil-gas, games and virtual reality industries." 

** GUI RAD - Rapid Application Development 

RAD Frameworks are a combination of library, IDE and GUI builder where
it is possible to build GUI applications by dragging and dropping user
interface elements in the and combining components in the same fashion
as Visual Basic or Delphi.

 + *Visual Studio* + Windows MFC (Microsft Foundation Classes) - Note:
   Windows only. 

 + *QT Creator* + QT Widgets or QTQuick/QML  - Note: QT Creator has a
   user interface designer.

 + [[https://www.ultimatepp.org/][Ultimate++]] - Ultimate++ is a C++ cross-platform rapid application
   development framework. 
   + License: BSD 

 + [[https://www.embarcadero.com/products/cbuilder][Embarcadero C++ Builder]] (Old Borland C++ Builder) - [Commercial]
** QT Framework - Widgets and QtQuick/QML                        :qt:qml:gui:

 + [[https://github.com/mikalv/awesome-qt-qml][Awesome Qt]]

 + [[https://github.com/benlau/qtci][QT-CI]] - "Collection of scripts to build Qt application in command
   line environment" 

 + [[https://github.com/jorgen/yat][YAT]] - "Yat (yet another terminal) is a VT100-emulating terminal
   written with Qt Quick."

 + [[https://www.qxorm.com/qxorm_en/home.html][QXORM]] - "QxOrm (the engine) + QxEntityEditor (the graphic editor) =
   the best solution to manage your persistent data layer in C++/Qt" 

 + [[https://bitbucket.org/michalmotyczko/qtadb/src/master/][QTADB]] - "QtADB is an app based on adb. It requires working android
   sdk (command “adb devices” listing your device), Qt libs version
   4.7, ROOT and busybox installed on phone."
   + Site: https://qtadb.wordpress.com/download/

 + [[https://github.com/equalsraf/neovim-qt][neovim-qt]] - "Neovim client library and GUI, in Qt5."

 + [[https://github.com/Kaffeine/telegram-qt][telegram-qt]] - "Qt-based library for Telegram network"

 + [[https://github.com/frankosterfeld/qtkeychain][QtKeyChain]] - "Platform-independent Qt API for storing passwords securely."

 + [[https://github.com/kypeli/kQOAuth][kQOAuth]] - "kQOAuth is a library written in C++ for Qt that
   implements the OAuth 1.0 authentication specification RFC 5849
   (http://tools.ietf.org/html/rfc5849). Greetings go to Dominik
   Kapusta for writing the original OAuth library using Qt, QOAuth
   (http://blog.ayoy.net/2009/6/24/oauth). However, I wanted to
   improve on the QOAuth’s approach in some ways. kQ…"

 + [[https://github.com/vogel/injeqt][InjectQt]] - "Simple dependency injection framework for Qt"

** Microsft Windows OS only 

  + MFC - Microsft Foundation Libraries
    + Framework for developing Windows GUI Applications.

  + ATL - Active Template Library
    + Template library for developing COM components.

  + WTL - Windows Template Library

  + [[https://github.com/alamaison/comet][COMET]] - "Modern (idiomatic) binding between COM and C++"

** Image Processing 
 
+ [[https://www.boost.org/doc/libs/1_38_0/libs/gil/doc/index.html][Boost.Gil]] - Generic Image Library

+ [[http://easybmp.sourceforge.net/][EasyBMP]]

+ [[http://cimg.sourceforge.net/][Cimg]] - "The CImg Library is a small, open-source, and modern C++
  toolkit for image processing http://cimg.eu"

+ [[https://itk.org/][ITK]] - National Library of Medicine Insight Segmentation and
  Registration Toolkit (ITK)

+ [[http://freeimage.sourceforge.net/][FreeImage]]

+ [[https://vtk.org/][VTK]] - Visualization Toolkit - library for scientific visualization.
  + See more at: https://en.wikipedia.org/wiki/VTK

+ [[https://opencv.org/][OpenCV]] - Computer Vision Framework.

** Logging 

+ [[http://www.pantheios.org/][Pantheios]]

+ [[http://logging.apache.org/log4cxx/index.html][log4cxx]]

+ [[http://boost-log.sourceforge.net/libs/log/doc/html/index.html][Boost.Log]]

** Network socket, web server, web socket and RPC libraries
*** General Network Socket Libraries 

 + [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_asio.html][Boost Asio]] - "Boost.Asio is a cross-platform C++ library for
   network and low-level I/O programming that provides developers with
   a consistent asynchronous model using a modern C++ approach." 

 + [[http://download.dre.vanderbilt.edu/][ACE]] - Adaptive Communication Environment - "The ADAPTIVE
   Communication Environment (ACE) is a freely available, open-source
   object-oriented (OO) framework that implements many core patterns
   for concurrent communication software. ACE provides a rich set of
   reusable C++ wrapper facades and framework components that perform
   common communication software tasks across a range of OS
   platforms. The communication software tasks provided by ACE include
   event demultiplexing and event handler dispatching, signal
   handling, service initialization, interprocess communication,
   shared memory management, message routing, dynamic
   (re)configuration of distributed services, concurrent execution and
   synchronization. ACE is targeted for developers of
   high-performance and real-time communication services and
   applications. It simplifies the development of OO network
   applications and services that utilize interprocess communication,
   event demultiplexing, explicit dynamic linking, and concurrency. In
   addition, ACE automates system configuration and reconfiguration by
   dynamically linking services into applications at run-time and
   executing these services in one or more processes or threads." 

 + [[http://zeromq.org/][ZeroMQ]] - Framework fro building distributed message systems or
   message brokers.

 + [[http://www.reasoning.biz/index.htm][Reason C++ framework]] - " Reason is a cross platform framework
   designed to bring the ease of use of Java, .Net, or Python to
   developers who require the performance and strength of C++."

 + [[http://sourcey.com/libsourcey/][libsourcey]] - "LibSourcey is a collection of cross platform C++11
   modules and classes that provide developers with an arsenal for
   rapidly developing high performance network based p2p and media
   streaming applications. Think of it as the power of libuv combined
   with the features of FFmpeg, OpenCV and WebRTC, all integrated with
   the ease and readability of the stl (C++ Standard Library)."
*** Http Client 

 + [[http://www.curlpp.org/][Curlpp]] - "cURLpp is a C++ wrapper for libcURL. libcURL is described
   as: a free and easy-to-use client-side URL transfer library,
   supporting FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE and
   LDAP. libcurl supports HTTPS certificates, HTTP POST, HTTP PUT, FTP
   uploading, kerberos, HTTP form based upload, proxies, cookies,
   user+password authentication, file transfer resume, http proxy
   tunneling and more! "

*** Http Servers and Web Frameworks 

 + [[https://www.boost.org/doc/libs/1_69_0/libs/beast/doc/html/index.html][Boost.Beast]] - "Beast is a C++ header-only library serving as a
   foundation for writing interoperable networking libraries by
   providing low-level HTTP/1, WebSocket, and networking protocol
   vocabulary types and algorithms using the consistent asynchronous
   model of Boost.Asio."

 + [[https://github.com/emweb/wt][Wt, Web Toolkit]] - "Wt is a C++ library for developing web
   applications. It consists of: libwt, a widget/rendering library;
   libwthttp, an (async I/O) HTTP/WebSockets server; libwtfcgi, a
   FastCGI connector library (Unix); libwtisapi, an ISAPI connector
   library (Windows); libwttest, a test connector environment. It also
   contains a C++ ORM, which can be used in a web application
   (obviously), but can also be used on its own: libwtdbo, a C++ ORM;
   libwtdbopostgres, PostgreSQL backend; libwtdbosqlite3, Sqlite3
   backend; libwtdbomysql, MySQL and MariaDB backend;
   libwtdbomssqlserver, Microsoft SQL Server backend;
   libwtdbofirebird, Firebird backend."
   + Note: Provides Widgets with an API similar to Desktop user
     interface GUI toolkits such as WxWidgets or Qt Framework.
   + Web Site: https://www.webtoolkit.eu/wt
   + License: Dual license GPL v2.0 and commercial.

 + [[https://github.com/cesanta/mongoose][Mongoose]] - "Mongoose Embedded Web Server Library - Mongoose is more
   than an embedded webserver. It is a multi-protocol embedded
   networking library with functions including TCP, HTTP client and
   server, WebSocket client and server, MQTT client and broker and
   much more. Mongoose is ideal for embedded environments. It has been
   designed for connecting devices and bringing them online. On the
   market since 2004, used by vast number of open source and
   commercial products - it even runs on the International Space
   station! Mongoose makes embedded network programming fast, robust,
   and easy."
   + Note: GPL 2.0 License and commercial license for closed source.

 + [[https://github.com/zaphoyd/websocketpp][WebSocketpp, aka WebSocket++]] - [WEB SOCKET SERVER] "WebSocket++ is
   a header only C++ library that implements RFC6455 The WebSocket
   Protocol. It allows integrating WebSocket client and server
   functionality into C++ programs. It uses interchangeable network
   transport modules including one based on raw char buffers, one
   based on C++ iostreams, and one based on Asio (either via Boost or
   standalone). End users can write additional transport policies to
   support other networking or event libraries as needed."

 + [[https://www.genivia.com/dev.html][gSOAP]] - "Our gSOAP toolkit allows C/C++ developers to focus on
   application logic instead of infrastructure, resulting in reduced
   development time, fewer bugs, and faster time to market."

 + [[https://github.com/daedric/httpp][Httpp]] - "Micro http server and client written in C++"

 + [[http://siliconframework.org/][Silicon C++ Web Framework]] - "Write Fast and Robust Web APIs with C++"

 + [[https://github.com/loentar/ngrest][Ngrest]] - "Fast and easy C++  RESTful WebServices framework"
*** RPC - Remote Procedure Call

 + [[http://rpclib.net/][RPCLIB]] - "rpclib is a RPC library for C++, providing both a client
   and server implementation. It is built using modern C++14, and as
   such, requires a recent compiler. Main highlights: Expose functions
   of your program to be called via RPC (from any language
   implementing msgpack-rpc); Call functions through RPC (of programs
   written in any language); No IDL to learn; No code generation step
   to integrate in your build, just C++."
   + Repository: https://github.com/rpclib/rpclib

 + [[https://capnproto.org/][CAPNPROTO]] - RPC system with a Cap'n proto serialziation format
   which the library page claims to be much faster than JSON and
   protocol buffers.
   + Repository: https://github.com/capnproto/capnproto
   + Features:
     + "The Cap’n Proto encoding is appropriate both as a _data_
       _interchange format_ and an _in-memory representation_, so once
       your structure is built, you can simply write the bytes
       straight out to disk!"
     + "mmap: Read a large Cap’n Proto file by memory-mapping it. The
       OS won’t even read in the parts that you don’t access."
     + "Inter-language communication: Calling C++ code from, say, Java
       or Python tends to be painful or slow. With Cap’n Proto, the
       _two languages can easily operate on the same in-memory data_
       _structure_."
     + "_Inter-process communication_: Multiple processes running on the
       same machine can share a Cap’n Proto message via shared
       memory. No need to pipe data through the kernel. Calling
       another process can be just as fast and easy as calling another
       thread."

 + [[https://zeroc.com/products/ice][ICE]] - "Ice is a comprehensive RPC framework with support for C++,
   C#, Java, JavaScript, Python, and more."
   + License: GPLv2 for open source projects, any commercial project
     requires buying a proper [[https://zeroc.com/licensing][license]].
*** Raw Sockets 

 *Low level socket manipulation and raw socket*

 + [[https://libtins.github.io/][Libtins]] - "libtins is a high-level, multiplatform C++ network
   packet sniffing and crafting library. Its main purpose is to
   provide the C++ developer an easy, efficient, platform and
   endianness-independent way to create tools which need to send,
   receive and manipulate network packets."

 + [[http://seladb.github.io/PcapPlusPlus-Doc/][PcapPlusPlus]] - "PcapPlusPlus is a multiplatform C++ network
   sniffing and packet parsing and crafting framework. It's meant to
   be lightweight, efficient and easy to use."

** Database 
 
+ [[https://github.com/google/leveldb][LevelDB]] - Embedded NO-SQL database library (not server) which is a
  fast key-value storage library written at Google that provides an
  ordered mapping from string keys to string values.
  + More:
    + https://dbdb.io/db/leveldb
    + https://en.wikipedia.org/wiki/LevelDB

+ [[http://lmdbxx.sourceforge.net/][LMDB++]]

+ [[http://otl.sourceforge.net/][OTL]]

+ [[http://soci.sourceforge.net/][SOCI]]

** Graphics and Game Engines 

+ [[https://www.ogre3d.org/][Ogre3D]] - Object-Oriented Graphics Rendering Engine
  + API Docs: https://ogrecave.github.io/ogre/api/latest/

+ [[http://www.libsdl.org/][SDL]] - "Simple DirectMedia Layer is a cross-platform development
  library designed to provide low level access to audio, keyboard,
  mouse, joystick, and graphics hardware via OpenGL and Direct3D. It
  is used by video playback software, emulators, and popular games
  including Valve's award winning catalog and many Humble Bundle
  games."

+ [[https://sourceforge.net/projects/alleg/][Allegro]] - "Allegro is a cross-platform library intended for use in
  computer games and other types of multimedia programming."

+ [[https://www.sfml-dev.org/][SFML]] - "SFML provides a simple interface to the various components
  of your PC, to ease the development of games and multimedia
  applications. It is composed of five modules: system, window,
  graphics, audio and network."

+ [[https://magnum.graphics/][Magnum Engine]] - "Lightweight and modular C++11/C++14 graphics
  middleware for games and data visualization." 

+ [[https://libcinder.org/about][Cinder]] - "Cinder is a C++ library for programming with aesthetic
  intent - the sort of development often called creative coding. This
  includes domains like graphics, audio, video, and computational
  geometry. Cinder is cross-platform, with official support for
  macOS, Windows, Linux, iOS, and Windows UWP." 

+ [[https://openframeworks.cc/][Openframeworks]] - "openFrameworks is an open source C++ toolkit for
  creative coding."

+ [[https://github.com/ocornut/imgui][Imgui]] - GUI Library for games

+ [[https://bkaradzic.github.io/bgfx/index.html][Bgfx]] - Cross-platform, graphics API agnostic, “Bring Your Own
  Engine/Framework” style rendering library, licensed under
  permissive BSD-2 clause open source license.

+ [[http://glew.sourceforge.net/][Glew]] - The OpenGL Extension Wrangler Library - " The OpenGL
  Extension Wrangler Library (GLEW) is a cross-platform open-source
  C/C++ extension loading library. GLEW provides efficient run-time
  mechanisms for determining which OpenGL extensions are supported on
  the target platform. OpenGL core and extension functionality is
  exposed in a single header file. GLEW has been tested on a variety
  of operating systems, including Windows, Linux, Mac OS X, FreeBSD,
  Irix, and Solaris."

+ [[https://github.com/glfw/glfw][glfw]] - "GLFW is an Open Source, multi-platform library for OpenGL,
  OpenGL ES and Vulkan application development. It provides a simple,
  platform-independent API for creating windows, contexts and
  surfaces, reading input, handling events, etc. GLFW natively
  supports Windows, macOS and Linux and other Unix-like systems. On
  Linux both X11 and Wayland is supported. GLFW is licensed under the
  zlib/libpng license."
  + Web Site: https://www.glfw.org

+ [[http://www.openscenegraph.org/][OpenSceneGraph]] - "The OpenSceneGraph is an open source high
  performance 3D graphics toolkit, used by application developers in
  fields such as visual simulation, games, virtual reality,
  scientific visualization and modelling. Written entirely in
  Standard C++ and OpenGL it runs on all Windows platforms, OSX,
  GNU/Linux, IRIX, Solaris, HP-Ux, AIX and FreeBSD operating
  systems. The OpenSceneGraph is now well established as the world
  leading scene graph technology, used widely in the vis-sim, space,
  scientific, oil-gas, games and virtual reality industries." 

+ [[https://glm.g-truc.net/0.9.9/index.html][GLM - OpenGL Mathematics]] - "OpenGL Mathematics (GLM) is a header only C++
  mathematics library for graphics software based on the OpenGL
  Shading Language (GLSL) specifications."

+ [[https://vis.uni-koeln.de/visionaray.html][Visionary]] - Visionaray - A C++ ray tracing template library
  + https://github.com/szellmann/visionaray
** Dependency Injection

+ [[http://wallaroolib.sourceforge.net/][Wallaroo]] - "Wallaroo is a dependency injection library for C++
  released under the BOOST software license. With wallaroo, you can
  easily separate the object graph from the class implementation. You
  can create objects and wire them using strings so that you can load
  the "object graph" from a configuration file."

+ [[https://github.com/ybainier/Hypodermic][Hypodermic]] - "Hypodermic is an IoC container for C++. It provides
  dependency injection to your existing design. Hypodermic is a
  non-intrusive header only IoC container for C++. It provides
  dependency injection to your existing design by managing the
  creation of your components and their dependencies in the right
  order, sparing you the trouble of writing and maintaining boiler
  plate code."   
** Crypto, hash and secure socket SSL / TSL 

+ [[https://www.cryptopp.com/][Crypto++]] - (Cryptopp) "Crypto++ Library is a free C++ class library
  of cryptographic schemes."

+ [[https://www.gnutls.org/][GNU TLS]] - The GnuTLS Transport Layer Security Library

+ [[https://www.openssl.org/][OpenSSL]] - "OpenSSL is a robust, commercial-grade, and full-featured
  toolkit for the Transport Layer Security (TLS) and Secure Sockets
  Layer (SSL) protocols. It is also a general-purpose cryptography
  library."

+ [[https://www.libressl.org/][LibreSSL]] - "LibreSSL is a version of the TLS/crypto stack forked
  from OpenSSL in 2014, with goals of modernizing the codebase,
  improving security, and applying best practice development
  processes. Primary development occurs inside the OpenBSD source tree
  with the usual care the project is known for. On a regular basis the
  code is re-packaged for portable use by other operating systems
  (Linux, FreeBSD, Windows, etc)." 

+ [[https://www.libtom.net/][Libtom]] - "LibTomCrypt is a fairly comprehensive, modular and
  portable cryptographic toolkit that provides developers with a vast
  array of well known published block ciphers, one-way hash
  functions, chaining modes, pseudo-random number generators, public
  key cryptography and a plethora of other routines."
  + https://github.com/libtom/libtomcrypt

+ [[https://botan.randombit.net/][Botan]] - "Botan’s goal is to be the best option for cryptography in
  C++ by offering the tools necessary to implement a range of
  practical systems, such as TLS protocol, X.509 certificates, modern
  AEAD ciphers, PKCS#11 and TPM hardware support, password hashing,
  and post quantum crypto schemes."

+ [[https://github.com/bitcoin-core/secp256k1][secp256k1]] - "Optimized C library for EC operations on curve
  secp256k1. This library is a work in progress and is being used to
  research best practices. Use at your own risk."

+ [[https://github.com/tplgy/cppcodec][CppCodec]] - "Header-only C++11 library to encode/decode base64,
  base64url, base32, base32hex and hex (a.k.a. base16) as specified in
  RFC 4648, plus Crockford's base32. MIT licensed with consistent,
  flexible API. Supports raw pointers, std::string and (templated)
  character vectors without unnecessary allocations. Cross-platform
  with measured decent performance and without compiler warnings." 

** Embedded Systems 
*** General

  * [[https://www.etlcpp.com/][ETLCPP]] - Embedded Template Library

  * [[https://github.com/sendyne/cppreg][CPPREG]] - "cppreg is a header-only C++11 library to facilitate the
    manipulation of MMIO registers (i.e., memory-mapped I/O registers)
    in embedded devices. The idea is to provide a way to write
    expressive code and minimize the likelihood of ill-defined
    expressions when dealing with hardware registers on a MCU
    (Microcontroller Unit)."

  * [[https://uavcan.org/][LIVUAVCAN]] - "Portable reference implementation of the UAVCAN
    protocol stack in C++ for embedded systems and Linux. UAVCAN is a
    lightweight protocol designed for reliable communication in
    aerospace and robotic applications via CAN bus."
    * Site: https://uavcan.org/
    * Repos:
      * https://github.com/UAVCAN/libuavcan
      * https://github.com/UAVCAN/libuavcan_stm32

  * [[http://cpputest.github.com][CppUtest]] - "CppUTest unit testing and mocking framework for C/C++ -
    CppUTest is a C /C++ based unit xUnit test framework for unit
    testing and for test-driving your code. It is written in C++ but is
    used in C and C++ projects and frequently used in *embedded systems*
    but it works for any C/C++ project."
    + http://cpputest.github.com
    + https://github.com/cpputest/cpputest

  * [[https://github.com/cesanta/mongoose][Mongoose]] - "Mongoose Embedded Web Server Library - Mongoose is more
    than an embedded webserver. It is a multi-protocol embedded
    networking library with functions including TCP, HTTP client and
    server, WebSocket client and server, MQTT client and broker and
    much more. Mongoose is ideal for embedded environments. It has been
    designed for connecting devices and bringing them online. On the
    market since 2004, used by vast number of open source and
    commercial products - it even runs on the International Space
    station! Mongoose makes embedded network programming fast, robust,
    and easy."
    + Note: GPL 2.0 License and commercial license for closed source.

  * [[https://www.arduinolibraries.info/libraries][Arduino Library List]] - "A list of the 2303 libraries registered in
    the Arduino Library Manager." 

*** Operating Systems for IOT 

 + [[http://www.contiki-os.org/#why][Contiki]] - "Contiki is an open source operating system for the
   Internet of Things. Contiki connects tiny low-cost, low-power
   microcontrollers to the Internet. Contiki is a powerful toolbox for
   building complex wireless systems.  Contiki is developed by a
   world-wide team of developers with contributions from Atmel, Cisco,
   ETH, Redwire LLC, SAP, Thingsquare, and many others, led by Adam
   Dunkels of Thingsquare."
   + Repository: https://github.com/contiki-os/contiki

 + [[https://www.zephyrproject.org][Zephyr]]  - "The Zephyr Project is a scalable real-time operating
   system (RTOS) supporting multiple hardware architectures, optimized
   for resource constrained devices, and built with security in
   mind. The Zephyr OS is based on a small-footprint kernel designed
   for use on resource-constrained systems: from simple embedded
   environmental sensors and LED wearables to sophisticated smart
   watches and IoT wireless gateways. The Zephyr kernel supports
   multiple architectures, including ARM Cortex-M, Intel x86, ARC,
   Nios II, Tensilica Xtensa, and RISC-V, and a large number of
   supported boards."
   + Repository: https://github.com/zephyrproject-rtos/zephyr

*** RTOS - Real Time Operating Systems 

+ [[http://sourceforge.net/projects/qpc/files/QP_C%252B%252B/4.5.04/][QP/C++]] -  RTOS kernel - License: dual GPL. Closed source
  applications require a commercial license.

+ [[http://distortos.org/][distortos]] - object-oriented C++ RTOS for microcontrollers

+ [[https://www.freertos.org/][FreeRTOS Kernel]] / RTOS

+ [[https://xenomai.org/][Linux Xenomai]] - " Xenomai brings POSIX and traditional RTOS APIs for
  porting time-critical applications to Linux-based platforms. When
  the native Linux kernel cannot meet the response time requirements
  of the application, Xenomai supplements it with Cobalt, a small
  real-time infrastructure which schedules time-critical activities
  independently from the main kernel logic." 
  + Repository: https://gitlab.denx.de/Xenomai/xenomai
  + See:
    + [[https://gitlab.denx.de/Xenomai/xenomai/wikis/Start_Here][Xenomai Wiki]]
    + [[https://elinux.org/images/7/76/Kiszka.pdf][Xenomai 3 - An Overview of the Real-Time Framework for Linux]]
    + [[http://linuxgizmos.com/real-time-linux-explained/][Real Time Linux explained, and constrated with Xenomai adn RTAI]]

+ [[https://www.rtems.org/][RTEMS]] / RTOS - Real-Time Executive for Multiprocessor Systems 
  + "The Real-Time Executive for Multiprocessor Systems or RTEMS is an
    open source Real Time Operating System (RTOS) that supports open
    standard application programming interfaces (API) such as
    POSIX. It is used in space flight, medical, networking and many
    more embedded devices using processor architectures including ARM,
    PowerPC, Intel, Blackfin, MIPS, Microblaze and more. Commercial
    support is available from US and European companies, and free
    support comes via the active global community."
  + Comes from: Aerospace Industry 
  + See:
    + [[https://blog.qt.io/blog/2018/05/03/qt-microncontrollers-mcu/][Qt on Microcontrollers (MCU)]]
    + [[http://rtemsramblings.blogspot.com/2010/02/nasa-solar-dynamic-observatory-launched.html][NASA Solar Dynamic Observatory Launched]]

+ [[http://ecos.sourceware.org/][eCOS]] / RTOS - Open Source Real Time Operating System
  + "eCos is a free open source real-time operating system intended
    for embedded applications. The highly configurable nature of
    eCos allows the operating system to be customised to precise
    application requirements, delivering the best possible run-time
    performance and an optimised hardware resource footprint. A
    thriving net community has grown up around the operating system
    ensuring on-going technical innovation and wide platform
    support."
  + Comes from: Automotive Industry 
*** Robot Control Software Frameworks
 
 * [[http://www.orocos.org/][Orocos]] - *Open Robot Control Software* - Set of libraries for
   implementing robot control software. 
   + Repositories:
     + https://github.com/orocos-toolchain/
     + https://github.com/orocos

 * [[https://www.ros.org/][ROS]] - *Robot Operating System* - "Set of software libraries and tools
   that help you build robot applications. From drivers to
   state-of-the-art algorithms, and with powerful developer tools, ROS
   has what you need for your next robotics project. And it's all open
   source." 

*** Modbus Protcol 

 + [[https://libmodbus.org/][libmodbus]] - "A Modbus library for Linux, Mac OS X, FreeBSD, QNX and Win32"

 + [[https://sourceforge.net/projects/qmodmaster/][QModMaster]] -  Modbus TCP,RTU Master Software - "QModMaster is a
   free Qt-based implementation of a ModBus master application. A
   graphical user interface allows easy communication with ModBus RTU
   and TCP slaves. QModMaster also includes a bus monitor for
   examining all traffic on the bus."

 + [[https://github.com/fanzhe98/modbuspp][modbuspp]] - A C++ Library for Modbus TCP Protocol
*** HMI and SCADA 

 + [[https://community.kde.org/Incubator/Projects/CuteHMI][CuteHMI]]  
   + "CuteHMI is meant to be a set of software components (libraries
     and executables) targeted at building *HMI* ( *Human Machine*
     *Interface*) applications. These components aim to fill the gap,
     between open-source editions of Qt and commercial software
     targeted at physical computing (*HMI / SCADA / IoT / BMS / RMS /
     etc*) build around it, thus providing complete open-source suite
     for such types of applications for home and industrial
     use. Example use case is to create user interface that can be
     used to communicate with PLC (programmable logic controller) to
     turn on air conditioning in the building for example."
   + Web Site:
     + https://cutehmi.kde.org/
   + Repository:
     + https://invent.kde.org/kde/cutehmi
   + Github Mirror:
     + https://github.com/michpolicht/CuteHMI

 + [[https://github.com/IndeemaSoftware/QSimpleScada][QSimpleScada]]
   + "Qt/C++ based simple SCADA framework, with dashboard, static and
     dynamic components. By using QSimpleScada framework you can build
     complex SCADA uis for your needs." 
     
*** Embedded Linux Libraries and tools 
 
   * [[https://busybox.net/][BusyBox]] (Application - GPL v2.0)
     * "BusyBox combines tinyversions of many common UNIX utilities
       into a single small executable.  It provides minimalist
       replacements for most of the utilities you usually find in
       bzip2, coreutils, dhcp, diffutils, e2fsprogs, file, findutils,
       gawk, grep, inetutils, less, modutils, net-tools, procps, ed,
       shadow, sysklogd, sysvinit, tar, util-linux, and vim.  The
       utilities in BusyBox often have fewer options than their
       full-featured cousins; however, the options that are included
       provide the expected functionality and behave very much like
       their larger counterparts. BusyBox has been written with
       size-optimization and limited resources in mind, both to
       produce small binaries and to reduce run-time memory
       usage. Busybox is also extremely modular so you can easily
       include or exclude commands (or features) at compile time.
       This makes it easy to customize embedded systems; to create a
       working system, just add /dev, /etc, and a Linux kernel.
       Busybox (usually together with uClibc) has also been used as a
       component of "thin client" desktop systems, live-CD
       distributions, rescue disks, installers, and so on."
     * Official GIT Repo: https://git.busybox.net/busybox/
     * Mirror Repository: https://github.com/mirror/busybox
     * Busybox for Android: https://github.com/meefik/busybox

   * [[http://landley.net/toybox/][ToyBox]] (BusyBox Clone with BSD License)
     * "Toybox combines common Linux command line utilities together
       into a single BSD-licensed executable that's simple, small,
       fast, reasonably standards-compliant, and powerful enough to
       turn Android into a development environment."
     * Site: http://landley.net/toybox/
     * Repo: https://github.com/landley/toybox

   * [[https://01.org/ell][ELL]] - Embedded Linux Library
     * "The Embedded Linux* Library (ELL) provides core, low-level
       functionality for system daemons. It typically has no
       dependencies other than the Linux kernel, C standard library,
       and libdl (for dynamic linking). While ELL is designed to be
       efficient and compact enough for use on embedded Linux
       platforms, it is not limited to resource-constrained systems."
     * Features:
       * Event loop that may run standalone or be integrated with another event loop
       * D-Bus client
       * Generic Netlink client
       * Timeout handling
       * Signal handling
       * Runtime plugins
       * Asynchronous/non-blocking I/O framework
       * Data structures: Queues (linked list), hash tables, ring buffers
       * String handling
       * Base64 encode/decode
       * File parsing (PEM, hwdb, settings)
       * Symmetric ciphers (kernel support required)
       * RSA cryptography (kernel support required)
       * Key handling

*** Linux CRT - Linux C-Runtime and C++-Runtime Libraries :clib:embedded:linux:

 Note: Listing of alternative Linux C-runtime libraries to the GLIBC (GNU LibC / GPL).

  * [[http://www.musl-libc.org/][MUSL]]
    + License: MIT 
    + Musl is a lightweight Linux C-runtime library suitable for
      generating portable static-linked self-contained executables.
    + "musl is a “libc”, an implementation of the standard library
      functionality described in the ISO C and POSIX standards, plus
      common extensions, intended for use on Linux-based
      systems. Whereas the kernel (Linux) governs access to hardware,
      memory, filesystems, and the privileges for accessing these
      resources, the C library is responsible for providing the actual
      C function interfaces userspace applications see, and for
      constructing higher-level buffered stdio, memory allocation
      management, thread creation and synchronization operations, and
      so on using the lower-level interfaces the kernel provides, as
      well as for implementing pure library routines of the C language
      like strstr, snprintf, strtol, exp, sqrt, etc."
    + Repository Mirror: https://github.com/ifduyue/musl

  * [[https://www.fefe.de/dietlibc/][DietLibc]]
    * "The diet libc is a libc that is optimized for small size. It
      can be used to create small statically linked binaries for Linux
      on alpha, arm, hppa, ia64, i386, mips, s390, sparc, sparc64, ppc
      and x86_64." 

  * [[https://uclibc-ng.org/][ULIBC]] 
    * License: LGPL-2.1
    * "uClibc-ng is a small C library for developing embedded Linux
      systems. It is much smaller than the GNU C Library, but nearly
      all applications supported by glibc also work perfectly with
      uClibc-ng."
    * Web Sites:
      * https://uclibc-ng.org/
      * https://uclibc.org/

  * [[https://en.wikipedia.org/wiki/Bionic_(software)][Bionic]] - Android CRT C-Runtime Library created by Google for
    Android Operating System. Unlike most Linux distribution built on
    top of Linux Kernel which uses the GLIBC (GNU C Library) as CRT,
    Android uses Bionic C library which is based on BSD C Library.
    * License: BSD-3
    * Repository: https://android.googlesource.com/platform/bionic

  * [[https://cxx.uclibc.org/][uClibC++]] (C++ Runtime Library)
    * "This is the page for the uClibc++ C++ library. It is currently
      in development and might as well be called alpha
      software. Nonetheless is it quite usable. More testing is needed,
      as always. For more information, check out the About, FAQ or
      Status pages to the left."

  * [[http://www.eglibc.org/home][EGLIBC]] [DISCONTINUED]
    * License: LGPL-2.1 
    * " Embedded GLIBC (EGLIBC) was a variant of the GNU C Library
      (GLIBC) that was designed to work well on embedded
      systems. EGLIBC strived to be source and binary compatible with
      GLIBC. EGLIBC's goals included reduced footprint, configurable
      components, better support for cross-compilation and
      cross-testing."

  * [[https://github.com/lpsantil/rt0][RT0]] - "A minimal C runtime for Linux i386 & x86_64"

  *See also:*

 Comparison between Linux C-Runtime Libraries:
  + http://www.etalabs.net/compare_libcs.html

 C Library Comparison:
  + https://wiki.osdev.org/C_Library

 Choosing System C Library:
  + https://events.static.linuxfound.org/sites/events/files/slides/libc-talk.pdf

 C library system-call wrappers, or the lack thereof
  + https://lwn.net/Articles/771441/
