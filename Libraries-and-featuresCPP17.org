#+INCLUDE: theme/style.org
#+TITLE: CPP / C++ Notes - C++17 New Features and Containers
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

 - [[wiki:index][Index]]

* C++17 New Features and Containers
** C++17 - Structured Bindings

 C++17 structured bindings allows to decompose data structures such as
 pairs, tuples, C-arrays and structs or classes with public fields in
 an uniform way. 

 Example: 
  + File: [[file:src/cpp17/cpp17-structured-bindings.cpp][file:src/cpp17/cpp17-structured-bindings.cpp]]
  + GIST: [[https://gist.github.com/caiorss/3fbb30bb6a9bc7672492bd8d9a7b5f41][cpp17-structured-bindings.cpp]]

 Compiling and running: 

 #+BEGIN_SRC sh 
  $ clang++ -std=c++1z -g -Wall -Wextra cpp17-structured-bindings.cpp -o cpp17-structured-bindings.bin  
  $ ./cpp17-structured-bindings.bin
 #+END_SRC

  *Parts in Main Function* 

  + Experiment 1 - Decompose pair. 

 #+BEGIN_SRC cpp 
     std::puts("\n=== EXPERIMENT 1: Decompose: pair - binding - pair =====");
     auto p = std::pair<std::string, int>("C++", 17);
     auto [name, version] = p;
     std::cout << " name = " << name << " ; version = " << version << std::endl;
 #+END_SRC

 Output: 

 #+BEGIN_SRC sh 
   === EXPERIMENT 1: Decompose: pair - binding - pair =====
    name = C++ ; version = 17
 #+END_SRC

  + Experiment 2 -  Decompose: map / 'hash-table' 

 #+BEGIN_SRC cpp 
    std::puts("\n=== EXPERIMENT 2: Decompose: map / 'hash-table' - =====");
    auto database = std::map<std::string, int>{{"c++", 17}, {"rust", 10}, {"Forth", 200}};
    for(const auto& [key, value] : database)
            std::cout << "key = " << key << " ; value = " << value << std::endl;
 #+END_SRC

 Output: 

 #+BEGIN_SRC sh 
   === EXPERIMENT 2: Decompose: map / 'hash-table' - =====
   key = Forth ; value = 200
   key = c++ ; value = 17
   key = rust ; value = 10
 #+END_SRC

  + Experiment 3 - Decompose: tuple

 #+BEGIN_SRC cpp 
    std::puts("\n=== EXPERIMENT 3: Decompose: tuple - =====");
    using DatabaseRow = std::tuple<int, std::string, double>;
    auto database = std::vector<DatabaseRow>{
            {100, "Fried tasty fresh cheese",   3.45},
            {400, "Super hot toasted coffee.", 6.25},
            {500, "Fresh Orange Juice",        4.50},
    };

    for(const auto& [id, name, price]: database)
            std::cout << " ROW=> id = " << id
                      << " ; name = "   << name
                      << " ; price = "  << price 
                      << std::endl;
 #+END_SRC

 Output:

 #+BEGIN_SRC sh 
   === EXPERIMENT 3: Decompose: tuple - =====
    ROW=> id = 100 ; name = Fried tasty fresh cheese ; price = 3.45
    ROW=> id = 400 ; name = Super hot toasted coffee. ; price = 6.25
    ROW=> id = 500 ; name = Fresh Orange Juice ; price = 4.5
 #+END_SRC

  + Experiment 4 - Decompose Structs 

 #+BEGIN_SRC cpp 
    std::puts("\n=== EXPERIMENT 4: Decompose: Structs - =====");
    struct GeoCoordinate{
            std::string name;
            double      latitude;
            double      longitude;
    };

    auto geoDatabase = std::deque<GeoCoordinate>{
             {"Bogota",         4.7110,  -74.0721}
            ,{"Beijing",       39.9042,  116.4074}
            ,{"Gauteng",      -26.2708,   28.1123}			
            ,{"Buenos Aires", -34.6037,  -58.3816}
            ,{"Brasilia",     -15.8267,  -47.9218}
    };
    std::cout << std::setprecision(3);

    std::for_each(geoDatabase.begin(), geoDatabase.end(),
                  [](const auto& city){
                      // Decompose struct into name, latitude and longitude
                      const auto& [name, lat, lon] = city;
                      std::cout << std::setw(15) << std::left  << name
                                << std::setw(8) << std::right << lat
                                << std::setw(8) << lon 
                                << "\n";						  
                  }); 
 #+END_SRC

 Output: 

 #+BEGIN_SRC text 
    === EXPERIMENT 4: Decompose: Structs - =====
    Bogota             4.71   -74.1
    Beijing            39.9     116
    Gauteng           -26.3    28.1
    Buenos Aires      -34.6   -58.4
    Brasilia          -15.8   -47.9
 #+END_SRC

  +  Decompose: C-Array 

 #+BEGIN_SRC cpp 
    std::puts("\n=== EXPERIMENT 5: Decompose: C-Array - =====");
    double array [3] = {10.23, 90.23, 100.0};
    auto [x, y, z] = array;
    std::printf(" array { x = %.3f ; y = %.3f ; z = %.3f }", x, y, z);
 #+END_SRC

 Output: 

 #+BEGIN_SRC sh 
   === EXPERIMENT 5: Decompose: C-Array - =====
    array { x = 10.230 ; y = 90.230 ; z = 100.000 }
 #+END_SRC

** C++17 std::invoke 
   :PROPERTIES:
   :ID:       5754cb0e-f4d3-434c-85e0-5ea55655a22f
   :END:

 Function which provides an uniform interface for invoking anything
 callable such as class member functions (ordinary methods), static
 member functions (static methods), functios and etc.

 See: https://en.cppreference.com/w/cpp/utility/functional/invoke

  + File: [[file:src/cpp17/cpp17-invoke.cpp][file:src/cpp17/cpp17-invoke.cpp]]
  + Online Compiler: http://rextester.com/IPY88297


 #+BEGIN_SRC cpp :tangle src/cpp17/cpp17-invoke.cpp
   #include <iostream>
   #include <string>
   #include <ostream>

   // std::invoke is provide by header functional
   #include <functional> 

   struct Dummy{
           double evalme(double x)	{
                   std::cerr << __FILE__ << ":" << __LINE__ << " I was evaluated ; 2x = " << 2 *x << '\n';
                   return 2 * x;
           }
           double operator()(double x){
                   std::cerr << __FILE__ << ":" << __LINE__ << " Call function-operator << 4 * x = " << 4 * x << '\n';
                   return 4 * x;
           }
   };

   double computeDouble(double x){
           std::cerr << __FILE__ << ":" << __LINE__ << " Computed double of 2x = " << 2 * x << '\n';
           return 2 * x;
   }

   int main(){
           std::invoke(computeDouble, 3.0);
           Dummy dummy;
           std::invoke(dummy, 3.0);
           std::invoke(Dummy(), 2.0);
           // Call method: .evalme indirectly 
           std::invoke(&Dummy::evalme, dummy, 3.0);
           return 0;
   }

 #+END_SRC

 Compile and run: 

 #+BEGIN_SRC sh 
   g++ cpp17-invoke.cpp -o out.bin -std=c++1z -Wall -Wextra && ./out.bin
   cpp17-invoke.cpp:20 Computed double of 2x = 6
   cpp17-invoke.cpp:14 Call function-operator << 4 * x = 12
   cpp17-invoke.cpp:14 Call function-operator << 4 * x = 8
   cpp17-invoke.cpp:9 I was evaluated ; 2x = 6
 #+END_SRC

** C++17 std::any 
   :PROPERTIES:
   :ID:       9397a9a0-e641-4cb6-89b7-24a82fe12d99
   :END:

This example shows how to use the C++17 std::any container which comes
froom boost::any.

See: https://en.cppreference.com/w/cpp/utility/any

File:  [[file:src/cpp17/cpp17-any.cpp][file:src/cpp17/cpp17-any.cpp]] 

#+BEGIN_SRC cpp :tangle src/cpp17/cpp17-any.cpp
  #include <iostream>
  #include <string>
  #include <iomanip>
  #include <ostream>

  #include <any>

  struct Point{
      double x;
      double y;
      Point(double x, double y): x(x), y(y) {}

      // Copy constructor
      Point(const Point& p){
          std::cerr << " -->> Copy constructor" << '\n';
          x = p.x;
          y = p.y;
      }   
  };

  std::ostream& operator<<(std::ostream& os, const Point& p){
      os << "Point(" << p.x << ", " << p.y << ") ";
      return os;
  }

  template<typename T>
  auto printInfo(std::any x) -> void{
      std::cout << " x.type = " << x.type().name()
                << " ; value(x) = "
                << std::any_cast<T>(x)
                << '\n';  
  }

  int main(){
      // Print boolean as 'true', 'false', instead of 0 or 1
      std::cout << std::boolalpha;
      std::any x = 1;
      printInfo<int>(x);
      x = 10.233;
      printInfo<double>(x);
      x = 'k';
      printInfo<char>(x);
      x = "hello world";
      printInfo<const char*>(x);
      x = std::string("hello world");
      printInfo<std::string>(x);  
      x = Point(100.0, 20.0);
      printInfo<Point>(x);
      std::cout << "Has value: x.has_value() = " << x.has_value() << '\n';
      x.reset();                                                         
      std::cout << "Has value: x.has_value() = " << x.has_value() << '\n';                                                               
      std::cout << "Try casting " << std::endl;
      x = "testing type casting";
      try{
          std::any_cast<int>(x);
      } catch (const std::bad_any_cast& ex) {
          std::cerr << " >>> Exception: what = " << ex.what() << '\n'; 
      }
      std::cerr << " >>> End the program gracefully" << '\n'; 
      return 0;
  }

#+END_SRC

Compiling with gcc: 

#+BEGIN_SRC sh 
  $ g++ --version
  g++ (GCC) 7.3.1 20180130 (Red Hat 7.3.1-2)
  .. ... ... ... 

  $ g++ cpp17-any.cpp -o out.bin -std=c++1z -Wall -Wextra && ./out.bin
   x.type = i ; value(x) = 1
   x.type = d ; value(x) = 10.233
   x.type = c ; value(x) = k
   x.type = PKc ; value(x) = hello world
   x.type = NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE ; value(x) = hello world
   -->> Copy constructor
   -->> Copy constructor
   x.type = 5Point ; value(x) =  -->> Copy constructor
  Point(100, 20) 
  Has value: x.has_value() = true
  Has value: x.has_value() = false
  Try casting 
   >>> Exception: what = bad any_cast
   >>> End the program gracefully
#+END_SRC

Compile with MSVC / VC++ on Windows: 

#+BEGIN_SRC sh 
  $ cl.exe cpp17-any.cpp /EHsc /Zi /nologo /std:c++17 /Fe:out.exe && out.exe
  cpp17-any.cpp
   x.type = int ; value(x) = 1
   x.type = double ; value(x) = 10.233
   x.type = char ; value(x) = k
   x.type = char const * __ptr64 ; value(x) = hello world
   x.type = class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > ; value(x) = hello world
   -->> Copy constructor
   -->> Copy constructor
   -->> Copy constructor
   x.type = struct Point ; value(x) = Point(100, 20) 
  Has value: x.has_value() = true
  Has value: x.has_value() = false
  Try casting 
   >>> Exception: what = Bad any_cast
   >>> End the program gracefully
#+END_SRC

** C++17 std::variant 

C++17 new std::variant which comes from Boost.Variant provides a
type-safe discriminated union or sum type which is similar to pattern
matching from functional programming languages like Haskell, OCaml and
Scala. In addition to those benefits, the std::variant is an
out-of-the-box generic visitor design pattern and a type-safe
replacement for old C-unions.

Potential Applications: 
 + Implement visitor OOP pattern.
 + Simulate or emulate pattern matching from functional languages.
 + Manipulate abstract syntax trees.

Useful concepts references: 
 + [[https://en.wikipedia.org/wiki/Tagged_union][Tagged union - Wikipedia]]
 + [[https://en.wikipedia.org/wiki/Algebraic_data_type][Algebraic data type - Wikipedia]]

Documentation: 
 + https://en.cppreference.com/w/cpp/utility/variant
 + [[https://www.boost.org/doc/libs/1_64_0/doc/html/variant.html][Chapter 45. Boost.Variant - 1.64.0]]

Code example: 

 - File: [[file:src/cpp17/variant.cpp][file:src/cpp17/variant.cpp]] 

#+BEGIN_SRC cpp :tangle src/cpp17/variant.cpp
  #include <iostream>
  #include <variant> // C++17
  #include <string>
  #include <ostream>
  #include <deque>
  #include <vector>
  #include <iomanip>

  template <class T>
  auto display(const std::string& name, const T& t) -> void;

  // Pattern matching using constexpr => May be the more performant way 
  template<class T>
  auto identifyAndPrint(const T& v) -> void;

  struct VisitorOperation{
          auto operator()(int num) -> void {
                  std::cout << "type = int     => value = " << num << "\n";
          }
          auto operator()(double num) -> void {
                  std::cout << "type = double  => value = " << num << "\n";
          }
          auto operator()(const std::string& s){
                  std::cout << "type = string  => value = " << s << "\n";
          }
  };

  int main(){
          // using <1>, <2>, ... <n> => Only available at C++17
          using std::cout, std::endl, std::cerr;
          auto nl = "\n";
          std::cout << std::boolalpha;
          cout << "========== Test 1 ==================" << nl;	
	
          // std::variant<int, double, std::string> somevar;
          auto x = std::variant<int, double, std::string>();
          x = 100;
          std::cout << "variant has int    = " << std::holds_alternative<int>(x) << nl;
          std::cout << "variant has double = " << std::holds_alternative<double>(x) << nl;
          std::cout << "variant has string = " << std::holds_alternative<std::string>(x) << nl;
          display("x", x);
          std::cout << "-------------------" << nl;
          x = 204.45;
          std::cout << "variant has double = " << std::holds_alternative<double>(x) << nl;	
          display("x", x);
          std::cout << "-------------------" << nl;
          x = "std::variant is awesome!";
          std::cout << "variant has string = " << std::holds_alternative<std::string>(x) << nl;
          display("x", x);

          cout << "========== Test 2 ==================" << nl;
          try{ 
                  // Try to get int 
                  int m = std::get<int>(x);
                  std::cout << "m = " << m << "\n";
          } catch(const std::bad_variant_access& ex){
                  std::cerr << "Error: Failed to extract int." << nl;
          }
          try{ 
                  // Try to get string 
                  auto s = std::get<std::string>(x);
                  std::cout << "s = " << s << nl;
          } catch(const std::bad_variant_access& ex){
                  std::cerr << "Error: Failed to extract string." << nl;
          }

          cout << "========== Test 3 ==================" << nl;
          x = -100;
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);
          x = 20.52;
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);

          x = "<hello world std::variant>";
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);

          cout << "========== Test 4 ==================" << nl;
          // auto + uniform initialization 
          auto xs = std::deque<std::variant<int, double, std::string>>{10.0, 20, 5, "hello", 10, "world"};
          for(const auto& e: xs){
                  identifyAndPrint(e);
          }
          cout << "========== Test 5 ==================" << nl;
          for(const auto& e: xs){
                  std::visit(VisitorOperation(), e);
          }	
          return 0;
  }

  // It works in a similar fashion to functional languages with
  // pattern matching such as Haskell, Scala, OCaml and so on.
  // std::variant is also a type-safe alternative to old C-unions.
  template <class T>
  auto display(const std::string& name, const T& t) -> void {
          auto nl = "\n";
          // Boost.Variant uses boost::get<TYPE>(&t), now changed to std::get_if
          if(auto n = std::get_if<int>(&t)){
                  std::cout << " = " << *n << nl;
                  return; // Early return 
          }
          if(auto d = std::get_if<double>(&t)){
                  std::cout << name << " = " << *d << nl;
                  return;
          }	
          if(auto s = std::get_if<std::string>(&t)){
                  std::cout << name << " = " << *s << nl;
                  return;
          }
          std::cout << "<UNKNOWN>" << std::endl;
  }

  template<class T>
  auto identifyAndPrint(const T& v) -> void{
          std::visit([](auto&& a){
              using C = std::decay_t<decltype(a)>;
              if constexpr(std::is_same_v<C, int>){
                              std::cout << "Type is int => value = " << a << "\n";
                              return;
              }
              if constexpr(std::is_same_v<C, double>){
                              std::cout << "Type is double => value = " << a << "\n";
                              return;
              }
              if constexpr(std::is_same_v<C, std::string>){
                              std::cout << "Type is string => value = " << a << "\n";
                              return;
              }
              std::cout << "Type is unknown" << "\n";
                             }, v);
  } // End of func. identifyAndPrint() ---//

#+END_SRC

Compile with GCC:

#+BEGIN_SRC sh 
 $ g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin 
#+END_SRC

Compile with Clang:

#+BEGIN_SRC sh 
 $ g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin 
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin

  ========== Test 1 ==================
  variant has int    = true
  variant has double = false
  variant has string = false
   = 100
  -------------------
  variant has double = true
  x = 204.45
  -------------------
  variant has string = true
  x = std::variant is awesome!
  ========== Test 2 ==================
  Error: Failed to extract int.
  s = std::variant is awesome!
  ========== Test 3 ==================
  x = -100
  x = 20.52
  x = <hello world std::variant>
  ========== Test 4 ==================
  Type is double => value = 10
  Type is int => value = 20
  Type is int => value = 5
  Type is string => value = hello
  Type is int => value = 10
  Type is string => value = world
  ========== Test 5 ==================
  type = double  => value = 10
  type = int     => value = 20
  type = int     => value = 5
  type = string  => value = hello
  type = int     => value = 10
  type = string  => value = world


#+END_SRC

** C++17 File system library 

The C++17 File system library, based on Boost file systems, provides
platform-agnostic file system operation such as listing directories,
checking file permissions, creating directories, copying files and so
on.

 *Small example about the library functionality*

Source: 
 + File: [[file:src/cpp17/cpp17-filesys1.cpp][file:src/cpp17/cpp17-filesys1.cpp]]
 + GIST: [[https://gist.github.com/caiorss/440dbcfadee02c2a81f925fa31078bbe][cpp17-filesys1.cpp]]

Compiling and running: 
  + Note: it is necessary to link against stdc++fs.
 
#+BEGIN_SRC sh 
  $ g++ cpp17-filesys.cpp -o cpp17-filesys.bin -std=c++1z -O3 -Wall -Wextra -lstdc++fs  
  $ ./cpp17-filesys.bin
#+END_SRC

Used headers and namespaces: 

#+BEGIN_SRC cpp
  #include <iostream>
  #include <string>
  #include <iterator>
  #include <iomanip>

  // C++17 - Requires compiler linking flag: -lstdc++fs on CLang or GCC.
  #include <filesystem>

  namespace fs = std::filesystem;
#+END_SRC

Helper template function for applying a function to the first N
entries.

#+BEGIN_SRC cpp 
   /** Iterate over first N entries of a file system iterator. */
   template<typename Range, typename Function>
   auto dotimes(size_t n, Range&& iterable, Function fun){
           size_t i = 0;
           auto it = fs::begin(iterable);
           auto end = fs::end(iterable);
           while(i < n && it != end ){
                   fun(it);
                   ++it;
                   i++;
           }
   }
#+END_SRC

 *Main Function* 

 + Experiment 1: 

#+BEGIN_SRC cpp 
    std::cout << std::boolalpha;
    std::cout << "\n EXPERIMENT 1 ===== Checking files in the system." << std::endl;
    fs::path p1 = "/etc/iscsi/initiatorname.iscsi";
    std::cout << "          p1 = " << p1 << std::endl;
    std::cout << "p1.string()  = " << p1.string() << std::endl;
    std::cout << "p1 ? exists  = " << fs::exists(p1) << std::endl;
    std::cout << "p1 ? is File = " << fs::is_regular_file(p1) << std::endl;
    std::cout << "p1 ? is Dir  = " << fs::is_directory(p1) << std::endl;

    fs::path p2 = "/boot";
    std::cout << "          p2 = " << p2 << std::endl;
    std::cout << "p2.string()  = " << p2.string() << std::endl;
    std::cout << "p2 ? exists  = " << fs::exists(p2) << std::endl;
    std::cout << "p2 ? is File = " << fs::is_regular_file(p2) << std::endl;
    std::cout << "p2 ? is Dir  = " << fs::is_directory(p2) << std::endl;

    fs::path p3 = "/boot/does/not/exist";
    std::cout << "          p3 = " << p3 << std::endl;
    std::cout << "p3.string()  = " << p3.string() << std::endl;
    std::cout << "p3 ? exists  = " << fs::exists(p3) << std::endl;
    std::cout << "p3 ? is File = " << fs::is_regular_file(p3) << std::endl;
    std::cout << "p3 ? is Dir  = " << fs::is_directory(p3) << std::endl;
#+END_SRC

Output: 

#+BEGIN_SRC sh 
   EXPERIMENT 1 ===== Checking files in the system.
            p1 = "/etc/iscsi/initiatorname.iscsi"
  p1.string()  = /etc/iscsi/initiatorname.iscsi
  p1 ? exists  = true
  p1 ? is File = true
  p1 ? is Dir  = false
            p2 = "/boot"
  p2.string()  = /boot
  p2 ? exists  = true
  p2 ? is File = false
  p2 ? is Dir  = true
            p3 = "/boot/does/not/exist"
  p3.string()  = /boot/does/not/exist
  p3 ? exists  = false
  p3 ? is File = false
  p3 ? is Dir  = false

#+END_SRC

 + Experiment 2: 

#+BEGIN_SRC cpp 
   std::cout << "\n EXPERIMENT 2 ===== Listing directory /etc =====" << std::endl;
   // Show first 10 files of directory /etc 
   dotimes(10, fs::directory_iterator("/etc"),
               [](auto p){
                   auto path = p->path();
                   std::cout << std::left
                             << std::setw(0) << path.filename().string()
                             << " " << std::setw(35)
                             << std::right << std::setw(40) << path
                             << std::endl;				
               });
#+END_SRC

Output:

#+BEGIN_SRC sh 
    EXPERIMENT 2 ===== Listing directory /etc =====
   chkconfig.d                       "/etc/chkconfig.d"
   DIR_COLORS.lightbgcolor           "/etc/DIR_COLORS.lightbgcolor"
   crypttab                          "/etc/crypttab"
   iscsi                             "/etc/iscsi"
   depmod.d                          "/etc/depmod.d"
   vbox                              "/etc/vbox"
   rhashrc                           "/etc/rhashrc"
   issue.net                         "/etc/issue.net"
   java                              "/etc/java"
   authselect                        "/etc/authselect"
#+END_SRC

 + Experiment 3: 

#+BEGIN_SRC cpp 
   std::cout << "\n EXPERIMENT 3 = Listing directory /etc (recursive) =====" << std::endl;
   dotimes(20, fs::recursive_directory_iterator("/etc/"),
                   [](auto p){
                       std::cout << std::right
                                 << std::setw(10)  << fs::is_directory(p->path())
                                 << std::setw(10)  << fs::is_regular_file(p->path())
                                 << std::setw(10)  << fs::is_symlink(p->path())
                                 << std::setw(10)  << " "
                                 << std::setw(5)   << std::left << p->path()					  
                                 << std::endl;
                   });
#+END_SRC

Output: 

 + 1st colum  => Directory
 + 2nd column => File
 + 3rd column => Symbolic link
 + 4th column => Absolute file path.

#+BEGIN_SRC sh 
   EXPERIMENT 3 = Listing directory /etc (recursive) =====
        true     false     false          "/etc/chkconfig.d"
       false      true     false          "/etc/DIR_COLORS.lightbgcolor"
       false      true     false          "/etc/crypttab"
        true     false     false          "/etc/iscsi"
       false      true     false          "/etc/iscsi/iscsid.conf"
       false      true     false          "/etc/iscsi/initiatorname.iscsi"
        true     false     false          "/etc/depmod.d"
        true     false     false          "/etc/vbox"
       false      true     false          "/etc/vbox/vbox.cfg"
       false      true     false          "/etc/rhashrc"
       false      true      true          "/etc/issue.net"
        true     false     false          "/etc/java"
       false      true     false          "/etc/java/font.properties"
       false      true     false          "/etc/java/java.conf"
#+END_SRC


Documentation: 

 + [[https://en.cppreference.com/w/cpp/filesystem][Filesystem library - cppreference.com]]
 + [[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0218r1.html][C++17 Filesystem -]]
 + [[https://www.boost.org/doc/libs/1_69_0/libs/filesystem/doc/tutorial.html][Boost Filesystem Tutorial]] (Note: it is not the std::filesystem
   library, but its predecessor, however it is worth reading it.)

