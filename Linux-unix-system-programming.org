#+INCLUDE: theme/style.org 
#+TITLE: Linux and Unix system programming 
#+DESCRIPTION: Linux, unix and posix system programming 
#+STARTUP: content 


* Unix System Programming focused on Linux 
** Overview 
*** Unix-like Operating Systems 

Unix-like operating system are a family of operating system based on
the AT&T Unix operating system, developed in the 1970's by [[https://en.m.wikipedia.org/wiki/Ken_Thompson][Ken Thompson]], 
[[https://en.m.wikipedia.org/wiki/Dennis_Ritchie][Dennis Ritchie]] and others. Later AT&T licensed Unix to third-party
vendors, what lead to many proprietary Unix variants. 

  *Some Unix-like operating systems are*

Desktop or Server:

  * _Mac OSX_ / Apple [Most Used]

  * _Linux-based or GNU-Linux based_ operating systems (Note: Linux is
    not an operating system, it is just the kernel) 
    + Debian Linux
    + Ubuntu Linux
    + Fedora Linux
    + Centos Linux 
    + Gentoo Linux
    + Arch   Linux
    + ... ... ...

  * [[https://en.m.wikipedia.org/wiki/FreeBSD][FreeBSD]]  

  * [[https://en.m.wikipedia.org/wiki/NetBSD][NetBSD]] 

  * [[https://en.m.wikipedia.org/wiki/OpenBSD][OpenBSD]]

  * [[https://en.m.wikipedia.org/wiki/DragonFly_BSD][DragonFly BSD]] 

  * [[https://en.m.wikipedia.org/wiki/Minix][Minix]] - Open source small operating system created for teaching
    about operating system concepts.

  * [[https://en.m.wikipedia.org/wiki/Solaris_(operating_system)][Solaris]] (from Sun Microsystems)

  * [[https://en.m.wikipedia.org/wiki/Z/OS][z/OS]] / IBM - Unix-variant for mainframes.

  * AIX / IBM

  * [[https://en.m.wikipedia.org/wiki/HP-UX][HP-UX]]

  * [[https://en.m.wikipedia.org/wiki/IRIX][IRIX]] 

  * [[https://en.m.wikipedia.org/wiki/Xenix][Xenix]] 

Mobile (touch devices): 

  * *Android* (Linux-based OS, but without GPL on the userland).
    + Unlike Desktop Linux distributions, Android uses the C runtime
      library [[https://en.wikipedia.org/wiki/Bionic_(software)][bionic]], derived from BSD, instead of GLIBC. Other
      significant differences is that Android does not uses [[https://en.wikipedia.org/wiki/X_Window_System][X11]] (X
      Windows System) as graphical user interface, instead the
      operating system uses the framebuffer directly. Shell command
      line tools, such as mv, ls, cp, and others, come from [[http://landley.net/toybox/about.html][toybox]]
      (BSD license), instead of [[https://busybox.net/about.html][busybox]] or other GNU tools.

  * iOS / Apple 

Embedded Systems: 

  + [[https://en.wikipedia.org/wiki/QNX][QNX]]

  + Linux (called Embedded-Linux)

  + [[https://en.m.wikipedia.org/wiki/Minix][Minix]]  

  + [[https://en.m.wikipedia.org/wiki/NetBSD][NetBSD]]

  + [[https://en.m.wikipedia.org/wiki/LynxOS][LynxOS]]


  *Common Features of Unix-like Operating Systems*


Nowadays, there may be many difference between Unix-like operating
systems, but they still have the following features in common: 

  + _Command line shell_
    * In the early days of computing, the shell or command line
      interpreter was the primary means of interaction between users
      and computers. A unix shell is used both as a scripting language
      and as an interactive command line interpreter for
      user interaction, launching processes, launching daemons (aka
      services), manipulating files and controlling the operating system.

    * Common Unix shells:
      * [[https://en.wikipedia.org/wiki/Almquist_shell][ash]]  (Almiquistt Shell)
      * [[https://en.wikipedia.org/wiki/C_shell][c-shell]]
      * [[https://en.wikipedia.org/wiki/Debian_Almquist_shell][dash]] (Debian Almiquist Shell)
      * tcsh
      * ksh  (Korn Shell)
      * Tcl
      * [[https://en.wikipedia.org/wiki/Bash_(Unix_shell)][bash]] (Bourn Shell) [Most used, most popular]
      * zsh                [Most popular]
      * fish               [Most popular]

  + _Command Line Applications_ (Command-Line Centric)
    + mv; cp; rm; mkdir; ls; telnet; ssh; ... and so on.

  + _Terminal Emulation_
    + Early Unix-like operating systems only ran in big and expensive
      _mainframe_ computers that were simultaneously shared by many
      users via physical dumb terminals attached through serial cables
      (RS232 - UART). The first terminals were _teletype printers_ (tty)
      where users could type commands and the teletype printer would
      print the the command output in a paper type. Later, dumb CRT
      (Cathode-Ray Tube) terminals were adopted. Those machines were
      comprised of a keyboard attached to a CRT video display as
      single unit attached to a mainframe via a serial cable. Physical
      Terminals, such as the once popular [[https://en.wikipedia.org/wiki/VT100][DEC VT100]], are long gone,
      but the are still _emulated_ by unix-based operating systems. For
      instance, most of those systems provide the following types of
      terminal emulation:

    + => /Virtual console/ => Kernel built-in terminal emulator, which can
      be accessed without any graphical user interface by typing
      Ctrl + Alt + F1, Ctrl + Alt + F[N] on Linux. BSD has different
      keybinds for the /virtual console/. Note: Mac-OSX does not have
      virtual console.

    + => /Graphical Terminal Emulator/ => Example: Xterm (X11); Gnome
      Terminal; Terminator; iTerm (MacOSX).

    + => /Serial console/ => Allows accessing a command line shell
      (bash, for instance) through a serial cable (RS232 /
      UART). Serial console is still used for accessing servers or
      embedded systems. 
      

  + _Text-centric_

    + Unix-like operating system has the tradition of storing
      configuration in human-readable text files, instead of binary files as
      Windows does. The benefits of using text files are the better
      reusability, searchability and reproducibility of
      configurations. All that one needs to reproduce the configuration
      in another machine is to copy the configuration file. 

    + Many applications also use text for configuration instead of
      graphical user interfaces.

    + Examples:
      + Linux-based operating system store many of their configuration
        as text files in the '/etc' directory. For instance, the file
        '/etc/fstab' controls the disk partitions mounted during boot
        time. As opposite to Unix-tradition, Windows and most of its
        applications store configuration in the registry file which
        is a binary file. 

      + Applications such as bash, vi, emacs store configuration in
        text files placed in default locations which are read during
        the initialization.

  + _POSIX Features_ / [[https://en.m.wikipedia.org/wiki/POSIX][POSIX]] - (Portable Operating System Interface) standard

    + POSIX System Calls
      + open(), read(), close() ... 

    + POSIX Functions encapsulating system calls 
      + open(), read(), close(), mmap(), dlopen(), dlclose() ...

    + POSIX Threads (_PThreads_) - Thread C API 

    + POSIX Shells

  + _BSD TCP/IP Sockets_  => TCP/IP networks were first implemented on Unix.

  + _Hierarchical file system_
    + File system with paths like: '/' (root directory); '.' (dot) as
      the current directory; '/home/user/data' (Linux);
      '/home/Users/somthing' (MacOSX) and so on.

  + _Dynamic Link_ (Symlink)
    + Allows file and directories to be accessed from other
      directories as they were in that location. 

  + _Virtual File Systems_
    + Many unix-like operating system provide virtual file-system
      (in-memory file systems) which exposes kernel and system
      information to user-space applications as human-readable text
      files. For instance, Linux has the _PROCFS_ (/proc directory) file
      system which exposes information about all the running
      processes. PROCFS also has the file _/proc/cpuinfo_ which contains
      information about the current machine microprocessor, such as:
      CPU cores; number of hyper threads; CPU features and
      capabilities.

  + _Everything is a file_ (or better everything is a file descriptor)
    + Many operating such as reading/writing sockets, pipes and so on,
      use the same read/write system-calls for file descriptors.
    + Hardware represented as device-files  
    + Kernel exposes information as text files (Linux)
    + Disk partitions are represented as files /dev/sda, /dev/sdb1,
      /dev/sdb2 ...
    + see: [[https://en.wikipedia.org/wiki/File_descriptor][file descriptor]]

  + _Device Files_ (a.k.a device nodes)
    + Device files are pseudo-files created in virtual file systems
      which allows user-space applications to interact with the
      _hardware peripherals_ by using reading and writing system-calls
      or just by reading and writing files. This feature is
      particularly important for industrial and embedded system
      applications as it allows reading sensor data, such as ADC  -
      Analog-To-Digital Converters or digital input, just by reading
      files and controlling actuators, such as motors, solenoids or
      valves just by writing to files. 

    + Note A: On Linux-based, operating systems, most device files are
      in the virtual file systems _devfs_ (/dev) and and _sysfs_ (/sys)
      directory.

    + Note B: Not all device files are associated to real hardware
      devices. The device-files /dev/null, /dev/zero, /dev/random,
      /dev/urandom, /dev/kmsg, /dev/tty0 are not associated to any
      real hardware.

    + Example 1: It allows user-space application to read and write
      from/to serial port devices by just reading or writing to the
      device file /dev/ttyS1, /dev/ttyUSB0, ...

    + Example 2: In single-board computers SBCs (embedded systems)
      such as Beagle Bone Black or Raspberry PI, both which contains
      SOC (System-On-Chip) embedded processors, it is possible to
      control GPIOs (General Purpose IO) which are digital IOs, and
      consequently any device attached to them, such as lights, LEDs,
      motors or valves, just by writing to the corresponding GPIO
      device file (/sys/class/gpio/gpio10/value). By writing 1 to the
      this file, the LED is turned on, by writing 0, the LED is turned
      off. The device-file feature allows controlling the hardware
      with any programming language, including, shell scripts, python,
      ruby, standard C++ (without volatile and embedded bare-metal
      restrictions) and so on.

    + Common Linux Device Files associated to hardware 
      + _/dev/mem_
        + => Device file that represents the physical RAM
          memory. It can be used for reading MMIO (Memory-Mapped IO)
          devices. 
      + /dev/lp0, /dev/lp1 => Parallel ports 
      + /dev/ttyS0, /dev/ttyS1, ... => Serial Ports
      + /dev/ttyUSB0, /dev/ttyUSB1, ... => USB-to-serial converters such as FTDI
      + /dev/sys/class/gpio/gpio10/export => GPIO / General Purpose Digital IO
      + /dev/sys/class/gpio/gpio10/value
      + ... ... ...
      + /dev/input/mice => Binary file contains mouse position, mouse
        buttons and and so on. The mouse position can be obtained by
        reading this file, without any special API.
      + /dev/fb0, /dev/fb1 ... => [[https://www.kernel.org/doc/Documentation/fb/framebuffer.txt][Framebuffer]] - allows user-space
        applications to control the graphics card and draw on the
        screen by just writing to a file. The framebuffer is the
        lowest level GUI in Linux kernel. Most embedded linux
        applications draw directly on framebuffer without X11
        (X-Windows System).

    + Linux Device Files not associated to hardware:
      + _/dev/kmsg_ 
        + => charavter device file containing kernel messages. The
          file is read by the command line tool '$ dmesg'. 
      + /dev/stdout => Console stdout 
      + /dev/stdin  => Console stdin 
      + /dev/stderr => Console stderr 
      + /dev/random => File which generates random numbers
      + /dev/urandom => File which generates random numbers
      + /dev/null => File used for discarding stdout or stderr of
        command line applications.
      + /dev/zero => Generate zero-values
      + /dev/null

 *Quotes* 

 
  + Ken Thompson

#+BEGIN_QUOTE
   I think the major good idea in Unix was its clean and simple
   interface: open, close, read, and write.
#+END_QUOTE

  + [[https://en.m.wikipedia.org/wiki/Doug_McIlroy][Doug Mcllroy]] - Creator of Unix Pipes 

#+BEGIN_QUOTE
   This is the Unix philosophy: Write programs that do one thing and
   do it well. Write programs to work together. Write programs to
   handle text streams, because that is a universal interface.
#+END_QUOTE


  + Brian Kernighan 

#+BEGIN_QUOTE
   Unix has, I think for many years, had a reputation as being
   difficult to learn and incomplete. Difficult to learn means that
   the set of shared conventions, and things that are assumed about
   the way it works, and the basic mechanisms, are just different from
   what they are in other systems.
#+END_QUOTE

  + [[https://en.m.wikipedia.org/wiki/Rob_Pike][Rob Pike]] - Member of the Unix design team; creator of GO (Golang)
    and Plan-9 operating system. 

#+BEGIN_QUOTE
    Even though the UNIX system introduces a number of innovative
    programs and techniques, no single program or idea makes it work
    well. Instead, what makes it effective is the approach to
    programming, a philosophy of using the computer. Although that
    philosophy can't be written down in a single sentence, at its
    heart is the idea that the power of a system comes more from the
    relationships among programs than from the programs
    themselves. Many UNIX programs do quite trivial things in
    isolation, but, combined with other programs, become general and
    useful tools.
#+END_QUOTE
 

 *See also* 

General Unix Concepts: 

  + [[https://en.m.wikipedia.org/wiki/Unix][Unix concept]]

  + [[http://www.catb.org/~esr/writings/taoup/][Book: The Art of Unix Programming]] - Eric Raymond 
    + 'The Art of Unix Programming attempts to capture the engineering
      wisdom and philosophy of the Unix community as it's applied
      today — not merely as it has been written down in the past, but
      as a living "special transmission, outside the scriptures"
      passed from guru to guru. Accordingly, the book doesn't focus so
      much on "what" as on "why", showing the connection between Unix
      philosophy and practice through case studies in widely available
      open-source software.'

  + [[https://en.m.wikipedia.org/wiki/Unix-like][Unix-like operating systems]]

  + [[https://en.m.wikipedia.org/wiki/POSIX][POSIX - Portable Operating System Interface]]

  + [[https://en.m.wikipedia.org/wiki/Unix_philosophy][Unix philosophy]]

  + [[https://en.wikipedia.org/wiki/Unix_shell][Unix Shell Scripting]]

  + [[https://en.m.wikipedia.org/wiki/Symbolic_link][Symbolic Link / symlink]]

  + [[https://en.m.wikipedia.org/wiki/Pipeline_(Unix)][Pipeline, Pipes - IPC (Inter Process Communication)]]

  + [[https://www.bottomupcs.com/file_descriptors.xhtml][Unix File Descriptors]]

  + [[https://en.wikipedia.org/wiki/File_descriptor][File Descriptors]]

  + [[https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/12_FileSystemImplementation.html][Operating Systems - File System Implementation]]

Papers and mail lists: 

  + [[https://people.eecs.berkeley.edu/~brewer/cs262/unix.pdf][The UNIX Time Sharing System {PDF}]] - Dennis M. Ritchie and Ken Thompson - Bell Laboratories

  + [[https://www.usenix.org/legacy/publications/library/proceedings/usenix03/tech/freenix03/full_papers/appavoo/appavoo_html/node18.html][Files, file descriptors, and name space]]

  + [[https://yarchive.net/comp/linux/everything_is_file.html][Linux kernel mail list discussion - Everything is a file]]

Usage of _Linux Device Files_ for controlling hardware (reading Sensors
and manipulating actuators):

  + /dev/mem -  [[https://stackoverflow.com/questions/12040303/how-to-access-physical-addresses-from-user-space-in-linux][memory - How to access physical addresses from user space in Linux? - Stack Overflow]]

  + /dev/mem - [[https://elinux.org/EBC_GPIO_via_mmap][EBC GPIO via mmap - eLinux.org]] 

  + /dev/mem - [[https://github.com/tchebb/memdump][GitHub - tchebb/memdump: A simple /dev/mem dumper for Linux]]

  + /dev/mem - [[https://man7.org/linux/man-pages/man4/kmem.4.html][kmem(4) - Linux manual page]] 

  + [[https://lwn.net/Articles/147901/][Who needs /dev/kmem? - LWN.net]]

  + [[https://unix.stackexchange.com/questions/101759/difference-between-device-file-and-device-drivers][Difference between Device file and device drivers]]

  + [[http://ibgwww.colorado.edu/~lessem/psyc5112/usail/peripherals/devices/devintro.html][Introduction to device drivers and device nodes]]

  + [[https://thehackerdiary.wordpress.com/2017/04/21/exploring-devinput-1/][The hacker diary - exploring /dev/input]] => Shows how to read the
    device file /dev/input/mice which contains mouse information such
    as position and buttons state.

  + [[https://www.ics.com/blog/how-control-gpio-hardware-c-or-c][How to Control GPIO Hardware from C or C++]]
    + Note: It only works in PCs with _industrial IO cards_ or systems
      with SOC processors (System-On-Chip) with GPIO devices; SBC -
      Single Board Computers, which are PCBs - printed circuit boards
      containin SOC microprocessors or MCU - Microcontrollers and all
      necessary supporting ICs (Integrated Circuits) such as RAM
      memory chips; flash memory chips; voltage regulators; USB
      connectors; ...

  + [[https://blog.mbedded.ninja/programming/operating-systems/linux/linux-serial-ports-using-c-cpp/][Linux Serial Ports Using C/C++]]

  + [[https://stackoverflow.com/questions/6947413/how-to-open-read-and-write-from-serial-port-in-c][How to open, read, and write from serial port in C?]]

  + [[https://www.iot-programmer.com/index.php/books/22-raspberry-pi-and-the-iot-in-c/chapters-raspberry-pi-and-the-iot-in-c/57-raspberry-pi-and-the-iot-in-c-sysfs-the-linux-way-to-gpio?start=1][Raspberry Pi And The IoT In C - SYSFS The Linux Way To GPIO]]


Terminal Emulation and Serial Console

  + [[https://www.ttwin.com/blog/270-history-terminal-emulation][A Brief History of Terminal Emulation]]

  + [[https://en.wikipedia.org/wiki/VT100][DEC VT100 CRT Terminal]]

  + [[https://en.wikipedia.org/wiki/Computer_terminal][Computer Terminal]]

  + [[https://www.kernel.org/doc/html/v4.15/admin-guide/serial-console.html][Linux Kernel Docs / Linux Serial Console]]

  + [[https://www.tldp.org/HOWTO/Remote-Serial-Console-HOWTO/intro-why.html][Remote Serial Console HOWTO Prev / Chapter 1. Introduction]]

  + [[https://wiki.archlinux.org/index.php/Working_with_the_serial_console][Arch Linux / Working with the serial console]]

  + [[https://elinux.org/Serial_console][Elinux - Serial Console]]

  + [[https://bootlin.com/doc/legacy/serial-drivers/linux-serial-drivers.pdf][Bootlin - Linux Serial Driver]]

  + [[https://developer.toradex.com/knowledge-base/how-to-disable-enable-debug-messages-in-linux][Configuring Serial Port Debug Console (Linux/U-Boot)]]

  + [[https://wiki.alpinelinux.org/wiki/Enable_Serial_Console_on_Boot][Alpine Linux - Enable Serial Console]]

  + [[https://www.linuxjournal.com/article/7206][Linux Serial Consoles for Servers and Clusters]]

  + [[https://roll.urown.net/server/serial-console.html][Roll Your Own Network / Serial Console]] (for servers, data-centers)

Plan 9 Operating System 

  + [[https://css.csail.mit.edu/6.824/2014/papers/plan9.pdf][Plan 89 from Bell Labs]] [PAPER] - Ken Thompson, Rob Pike, Dave Presotto, and others.

  + [[https://www.cs.kent.ac.uk/people/staff/srk21/research/papers/kell19unix-personal.pdf][Unix, Plan 9 and the Lurking Smalltak]] [PAPER]

  + [[https://woozle.org/papers/plan9.html][Making Unix a little more Plan9-like]]

  + [[https://wiki.installgentoo.com/wiki/Plan_9][Plan 9 - Gentoo Wiki]]

  + [[http://www.catb.org/esr/writings/taoup/html/plan9.html][Plan 9: The Way the Future Was - Chapter 20. Futures]]

  + [[https://www.slideshare.net/anantn/unix-plan9-from-bell-labs?qid=024d0f21-1e4b-4414-91a8-2d7d8a88ebba&v=&b=&from_search=2][Plan 9 - from Bell Labs - Unix++ Anyone?]]

  + [[http://groups.di.unipi.it/~nids/docs/the_plan-9_effect.html][The Plan-9 Effect or why you should not fix it if it ain't broken]]

  + [[https://www.slideshare.net/anantn/glendix-the-why-and-the-how?qid=024d0f21-1e4b-4414-91a8-2d7d8a88ebba&v=&b=&from_search=30][Glendix - A Plan 9/Linux Distribution]]

  + [[https://www.cs.cmu.edu/~davide/p9.html][Dr. David A. Eckhardt -- Plan 9]]

  + [[https://www.slideshare.net/jserv/plan-9-not-only-a-better-unix?qid=cab7305a-e78c-44bb-8b7f-88925f3717b4&v=&b=&from_search=17][Plan 9: Not (Only) A better UNIX]] - Jim Huang

  + [[https://www.slideshare.net/twopoint718/rc-the-plan-9-shell?qid=cab7305a-e78c-44bb-8b7f-88925f3717b4&v=&b=&from_search=18][Rc - The Plan 9 Shell]]

  + [[https://www.slideshare.net/oraccha/plan-9][Plan-9 from the outer space]] (Presentation, In Japanese)

  + [[https://9p.io/wiki/plan9/Unix_to_Plan_9_command_translation/index.html][UNIX to Plan 9 command translation]]

  + [[https://docs.huihoo.com/plan9/Plan9.pdf][The Unix Spirit set Free: Plan 9 from Bell Labs]]

  + [[http://fqa.9front.org/fqa0.html][Introduction to Plan 9]]

  + [[https://sigkill.dk/writings/guides/plan_9_tools.html#running-plan-9-userland-tools-on-unix][Running Plan 9 Userland Tools On Unix]]

*** Components of Linux-based operating systems 

  *Components of a Linux-based Operating System* 

   * Boot Loader => Loads the operating system
     + Examples:
       + Grub (Mostly used on Desktop)
       + [[https://en.wikipedia.org/wiki/SYSLINUX][Syslinux]] (Mostly used for booting CDROM ISO images, Linux
         Live CDs)

   * *Linux Kernel*
     + Maintainer: Linux Foundation

   * CRT - C-Runtime Library
     + Encapsulates kernel system-calls and basic services as C APIs
       for user-space applications.
     + Example:
       + GLIBC (GNU C-library, most used C library by Linux Desktop
         and server distributions). Maintained by: FSF - Free Software
         Foundation. 
       + Bionic - CRT library used by Android. 
       + MUSL - CRT library used for embedded systems and static linking.

   * User-space utilities

     + Shell - command line interpreter.
       * ASH 
       * Bash
       * ZSH
       * Fish

     + Basic Command Line Tools (ls, mv, pwd, ln, rm, file, ...)
       + Standalone tools (GNU)
       + Busybox => Is a single binary containing all command line
         tools as sub-commands. Busybox is widely used on
         Embedded-Linux systems. 

     + GUI - Graphical User Interface Stack (Not part of Kernel) - all
       GUI applications are built on top of kernel _framebuffer_.
       + X11 - X Windows System
       + GTK - Gimp Toolkit
       + QT

     + Package Managers
       + Examples:
         + DPKG (Debian)
         + RPM (Read-Hat Package Manager) => Used by Fedora.
         + Pacman => Arch Linux Distribution
         + Portage => Gentoo Distribution


  *Components of a Embedded Linux System* 

   + _Cross Compiler Toolchain_: Mostly GCC - GNU C Compiler
     + Note: The Linux Kernel uses many C proprietary extensions of
       GCC compiler, therefore it is almost impossible to compile the
       kernel using any other compiler. 

   + _Boot Loader_ => Loads the operating system 
     + [[https://en.wikipedia.org/wiki/Das_U-Boot][U-Boot]] (Most popular)
     + [[https://en.wikipedia.org/wiki/Barebox][Barebox]] 
     + [[https://en.wikipedia.org/wiki/RedBoot][RedBoot]] 
     + [[https://en.wikipedia.org/wiki/Yaboot][Yaboot]]  

   + _Linux Kernel_ (GPL v2 License)
     + Among other-things, the kernel provides: virtual memory
       management; processes; kernel-space (native) threads; kernel
       modules (device drivers) API and many other essential
       features. 

   + _CRT - C Runtime Library_
     * uLibC
     * MUSL
     * Bionic (Android C library)
     * GLIBC

   + _User-Space Utilities_

     * [[https://busybox.net/about.html][busybox]] (GPL v2 License) - Single binary executable containing
       many common unix command line utitlities in a single
       executable, such as: unix shell, ls, mv, cp, rm, zip, unzip, ... and so
       on. 
       + "BusyBox combines tiny versions of many common UNIX utilities
         into a single small executable. It provides replacements for
         most of the utilities you usually find in GNU fileutils,
         shellutils, etc. The utilities in BusyBox generally have
         fewer options than their full-featured GNU cousins; however,
         the options that are included provide the expected
         functionality and behave very much like their GNU
         counterparts. BusyBox provides a fairly complete environment
         for any small or embedded system."

     * [[http://landley.net/toybox/about.html][toybox]] (BSD License) => Used on Android. 
       * "Toybox combines many common Linux command line utilities
         together into a single BSD-licensed executable. It's simple,
         small, fast, and reasonably standards-compliant (POSIX-2008
         and LSB 4.1). Toybox's main goal is to make Android
         self-hosting by improving Android's command line utilities so
         it can build an installable Android Open Source Project image
         entirely from source under a stock Android system. After a
         talk at the 2013 Embedded Linux Conference explaining this
         plan (outline, video), Google merged toybox into AOSP and
         began shipping toybox in Android Mashmallow."

   + _BSP - Board Support Package_

     + Device drivers or kernel modules provided by SOC
       (System-On-Chip) manafucaturer. Most device drivers maps
       on-board peripherals, such as UART (serial communication
       device); GPIO - General Purporse IO; CAN - Controller Area
       Network or ADC - Analog-To-Digital Converter, to device files
       which allows user-space applications to control the hardware by
       just reading and writing files.

     + The device-files feature allows using _standard C or C++_ for
       interacting the aforementioned peripherals and any physical
       devices attached to them such as pumps, electric motors,
       , valves, sensors, accelerometers or gyroscopes. The
       device-file feature also allows controling the hardware with
       any scripting language such as: ruby, python, unix shell script
       (bash, ash, sh, ...) ...

   + _GUI - Graphical User Interface_
     * Framebuffer - Linux Kernel Device file which allows user-space
       applications to control graphical display. 
     * In-house GUI on top framebuffer (Lowest level)
     * SDL (LGPL) - http://www.libsdl.org/ - Library that came from Game Development.
     * QT on top of framebuffer
     * X11 - X Windows System (Rarely used, too heavy.)

  *See* 

   + [[https://elinux.org/DirectFB][Direct FB]] - Elinux

   + [[https://doc.qt.io/qt-5/embedded-linux.html][QT For Embedded Linux]] (QT Company)

   + [[https://doc.qt.io/archives/qt-4.8/qt-embedded-displaymanagement.html][Qt for Embedded Linux Display Management]]

   + [[https://bootlin.com/blog/building-a-linux-system-for-the-stm32mp1-enabling-qt5-for-graphical-applications/][Building a Linux system for the STM32MP1: enabling Qt5 for graphical applications - Bootlin's blog]]

   + [[https://elinux.org/images/6/64/Choosing-embedded-graphical-libraries.pdf][Choosing Embedded Graphical Libraries]]

   + [[https://itnext.io/top-five-libraries-for-creating-gui-on-embedded-linux-5ce03903be32][Top Five Libraries for creating GUI on Embedded Linux | by Kevin Muhuri | ITNEXT]]

** Command Line Essentials 
*** Overview 

Useful reminder of common built-in command line applications for many
unix-like operating systems, including Linux-distros; BSD-variants and
MacOSX.
*** Fundamentals 

 + => Change current prompt (works for Bash and ZSH shells)

#+BEGIN_SRC sh 
  $ export PS1=" $ >> "
  
  $ >> command typed by user  
  output line 0 
  output line 1 
  ... ... ... 
  output line N-1
#+END_SRC

 + *pwd* => Get current working directory 

#+BEGIN_SRC sh 
  $ pwd
  /home/mxpkf8/Downloads
#+END_SRC

 + *cd* - Change the current directory 

#+BEGIN_SRC sh 
  $ cd /Applications # OSX 
  $ cd ~/Downloads 
  $ cd /home/user/Downloads 
  $ cd /Users/user/Downloads
 
  # Enter in Home directory: 
  #   /Users/<USER> in Mac OSX 
  #   /home/<USER/ in Linux                 
  $ cd $HOME 
#+END_SRC

 + *ls* - List directory 

Linux: 

#+BEGIN_SRC sh 
  $ ls /

  bin@   dev/  home/  lib64@       media/  opt/   root/  sbin@  sys/  usr/
  boot/  etc/  lib@   lost+found/  mnt/    proc/  run/   srv/   tmp/  var/
#+END_SRC

Mac OSX: 

#+BEGIN_SRC sh 
   $ ls -l /System/Applications/Utilities/Terminal.app/Contents

   total 32
   -rw-r--r--   1 root  wheel  7998 Apr 17 22:57 Info.plist
   drwxr-xr-x   3 root  wheel    96 May 27 20:40 MacOS
   -rw-r--r--   1 root  wheel     8 Apr 17 22:57 PkgInfo
   drwxr-xr-x  74 root  wheel  2368 May 27 20:30 Resources
   drwxr-xr-x   3 root  wheel    96 Apr 17 22:57 _CodeSignature
   -rw-r--r--   1 root  wheel   510 Apr 17 22:58 version.plist
#+END_SRC

 + *rm* - Delete files or directory 

#+BEGIN_SRC sh 
  # Delete file 
  $ rm file.txt 

  # Delete directory dir2 and all sub-directories of dir2 
  $ rm -rf ./dir1/dir2

  # Delete directory dir2 and all sub-directories of dir2 in verbose mode 
  $ rm -rf -v ./dir1/dir2
#+END_SRC

 + *cat* - Display text file content 

Linux: 

#+BEGIN_SRC sh 
  $ cat /proc/uptime 
  11960.35 36214.14

  $ cat /proc/filesystems 
  nodev	sysfs
  nodev	tmpfs
  nodev	bdev
  nodev	proc
  nodev	cgroup
  nodev	cgroup2
  .. ... ... ... 
  ... ... ... .. 
#+END_SRC

Mac OSX: 

#+BEGIN_SRC sh 
   $ cat /System/Applications/Utilities/Terminal.app/Contents/Info.plist  

  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  <dict>
          <key>ATSApplicationFontsPath</key>
          <string>Fonts</string>
          <key>BuildMachineOSBuild</key>
          <string>18A391024</string>
    ... ...   ... ...   ... ...   ... ...   ... ...   ... ...   ... ... 
    ... ...   ... ...   ... ...   ... ...   ... ...   ... ...   ... ... 
#+END_SRC
*** Creating files and directories from command line

 + *mkdir* - Create directory (aka folder)

#+BEGIN_SRC sh 
  # Create single directory/folder 'somedir' at current directory
  $ mkdir somedir

  # Create single directory/folder 'somedir' at /tmp path
  $ mkdir -p /tmp/somedir

  # Create directory-tree root-folder, root-folder/sub1 and root-folder/sub1/sub2 
  $ mkdir -p /Users/unix/root-folder/sub1/sub2

  # Create directory tree 
  $ mkdir -p mydir/{subA,subB}/d1/d2

  $ tree mydir
  mydir
  ├── subA
  │   └── d1
  │       └── d2
  └── subB
      └── d1
          └── d2
#+END_SRC

 + *touch* - Create empty files: 

#+BEGIN_SRC sh 
  $ touch file1.txt somefile.cpp CMakeLists.txt 
#+END_SRC

 + Create multi-line file with echo 

#+BEGIN_SRC sh 
  $ echo line1 > file.txt
  $ echo line1 > file.txt
  $ echo line3 >> file.txt

  $ cat file.txt 
  line1
  line2
  line3
#+END_SRC

 + Create multi-line files with cat-EOF trick.

#+BEGIN_SRC sh 
  # Create a file with some content 
  $ cat > script.sh <<EOF
  #!/usr/bin/env sh 

  echo " => Showing root directory"
  ls /

  EOF

  $ cat script.sh 
  #!/usr/bin/env sh 

  echo " => Showing root directory"
  ls /

  $ sh script.sh 
   => Showing root directory
  bin   dev  home  lib64	     media  opt   root	sbin  sys  usr
  boot  etc  lib	 lost+found  mnt    proc  run	srv   tmp  var
#+END_SRC

*** Files and executables 

  + *which* - Get path to executable in $PATH environment variable. 

#+BEGIN_SRC sh 
  $ which xdg-open
  /usr/bin/xdg-open

  $ which zsh
  /usr/bin/zsh

  $ which brave
  /home/mxpkf8/Applications/brave/brave
#+END_SRC

  + *file* - Identify text or binary files by they "magic-number"
    (uniquely identifying byte sequence)

Linux: 

#+BEGIN_SRC sh 
   $ file /usr/bin/bash
   /usr/bin/bash: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV)
   , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2
   .. ... ... ... ... ... 

  $ file vs_buildtools__80950065.1591646379.exe 
  vs_buildtools__80950065.1591646379.exe: PE32 executable (GUI) Intel 80386, for MS Windows
#+END_SRC

Mac OSX: 

#+BEGIN_SRC sh 
  $ file /bin/zsh 
  /bin/zsh: Mach-O 64-bit executable x86_64

  $ file $HOME/Desktop/Console 
  /Users/unix/Desktop/Console: MacOS Alias file

  $ file /System/Applications/Utilities/Terminal.app/Contents/MacOS/Terminal
  /System/Applications/Utilities/Terminal.app/Contents/MacOS/Terminal: Mach-O 64-bit executable x86_64
#+END_SRC


  + Open file with default system Application / *xdg-open* (Linux with
    X11, BSD with X11); *open* (MacOSX)

Linux: 

#+BEGIN_SRC sh 
   # Open Desktop directory with default system file manager 
   $ xdg-open $HOME/Desktop 

   # Open file image.png with default system image viewer 
   $ xdg-open image.png 
#+END_SRC

Mac OSX: 

#+BEGIN_SRC sh 
   # Open /Volumes directory with default system file manager (finder)
   $ open /Volumes 

   # Open file CmakeLists.txt with default system text editor 
   $ open CMakeLists.txt 

   $ open disk-image.dmg 
#+END_SRC

*** System information 

 + *uname* => Get Kernel Version 

Linux: 

#+BEGIN_SRC sh 
  $ uname -a
  Linux localhost.localdomain 5.6.6-300.fc32.x86_64 #1 SMP Tue Apr 21 13:44:19 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
#+END_SRC

Mac OSX Catalina: 

#+BEGIN_SRC sh 
  $ uname -a 
  Darwin ghosts-iMac-Pro.local 19.5.0 Darwin Kernel Version 19.5.0: Tue May 26 20:41:44 PDT 2020; root:xnu-6153.121.2~2/RELEASE_X86_64 x86_64
#+END_SRC

 + *uptime* - Shows how long the machine is running. 

#+BEGIN_SRC sh 
   # Linux 
   $ >> uptime
   13:43:36 up  2:22,  1 user,  load average: 1.31, 1.00, 0.99

   # Mac OSX
   13:44  up  1:48, 2 users, load averages: 1.17 1.30 1.35
#+END_SRC

  + *whoami* - Show current user (Note: it also works on Windows)

#+BEGIN_SRC sh 
  $ whoami
  user_ml7abfg
#+END_SRC

  + *w* - Show logged users 

Linux: 

#+BEGIN_SRC sh 
   $ w
    13:37:31 up  2:16,  1 user,  load average: 0.63, 0.87, 0.98
   USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
   user_ml7abfg   :0        11:22   ?xdm?  43:26   0.00s /usr/libexec/gdm-x-session --register-session --
#+END_SRC

Mac OSX: 

#+BEGIN_SRC sh 
  $ w 
  13:38  up  1:42, 2 users, load averages: 1.86 1.53 1.44
  USER     TTY      FROM              LOGIN@  IDLE WHAT
  unix     console  -                11:58    1:39 -
  unix     s000     -                13:32       - w
#+END_SRC

 + *ps* - Show running processes 
   
Linux: 

#+BEGIN_SRC sh 
  $ ps -ef 
  UID          PID    PPID  C STIME TTY          TIME CMD
  root           1       0  0 11:21 ?        00:00:18 /usr/lib/systemd/systemd --switched-root --system --deserialize 29
  root           2       0  0 11:21 ?        00:00:00 [kthreadd]
  root           3       2  0 11:21 ?        00:00:00 [rcu_gp]
  root           4       2  0 11:21 ?        00:00:00 [rcu_par_gp]
   ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ... 
   ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ... 
  mxpkf8      2383    2382  0 11:22 ?        00:00:00 dbus-broker --log 4 --controller 9 --machine-
  mxpkf8      2387    1946  0 11:22 ?        00:00:01 /usr/libexec/at-spi2-registryd --use-gnome-se
  mxpkf8      2392       1  0 11:22 ?        00:00:00 /usr/bin/gpg-agent --sh --daemon --write-env-
  mxpkf8      2393    2149  0 11:22 tty2     00:01:18 xfwm4
   ... ... ... ... ... ...  ... ... ... ... ... ... 
   ... ... ... ... ... ...  ... ... ... ... ... ... 
#+END_SRC

Mac OSX:

#+BEGIN_SRC sh   
  $ ps -ef 
    UID   PID  PPID   C STIME   TTY           TIME CMD
      0     1     0   0 11:56AM ??         0:16.58 /sbin/launchd
      0    86     1   0 11:58AM ??         0:01.13 /usr/sbin/syslogd
      0    87     1   0 11:58AM ??         0:03.44 /usr/libexec/UserEventAgent (System)
      0    90     1   0 11:58AM ??         0:01.11 /System/Library/PrivateFrameworks/Uninstall.framework/Resources/uninstalld
      0    91     1   0 11:58AM ??         0:05.95 /usr/libexec/kextd
      0    92     1   0 11:58AM ??         0:09.31 /System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/FSEvents.framework/Versions/A/Support/fseventsd
      0    93     1   0 11:58AM ??         0:00.32 /System/Library/PrivateFrameworks/MediaRemo
   ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ... 
   ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ... 
    501  6102     1   0  1:29PM ??         0:00.26 /System/Library/CoreServices/CoreServicesUIAgent.app/Contents/MacOS/CoreServicesUIAgent
    501  6813     1   0  1:45PM ??         0:01.12 /System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/CVMCompiler 2
      0  6795   319   0  1:32PM ttys000    0:00.06 login -pf unix
    501  6796  6795   0  1:32PM ttys000    0:00.38 -zsh
      0  6816  6796   0  1:46PM ttys000    0:00.01 ps -ef
#+END_SRC

  + *env* - Show environment variables 

Linux: 

#+BEGIN_SRC sh 
   $ env
   IMSETTINGS_INTEGRATE_DESKTOP=yes
   SHELL=/bin/bash
   SESSION_MANAGER=local/unix:@/tmp/.ICE-unix/2149,unix/unix:/tmp/.ICE-unix/2149
   WINDOWID=52428803
   COLORTERM=truecolor
   XDG_CONFIG_DIRS=/etc/xdg
   HISTCONTROL=ignoredups
   XDG_MENU_PREFIX=xfce-
    ... .. ... ..  ... .. ... ..  ... .. ...
    ... .. ... ..  ... .. ... ..  ... .. ...
#+END_SRC

Mac OSX: 

#+BEGIN_SRC sh 
   $ env 

   TMPDIR=/var/folders/jh/w00bgbps79bddlbqwkv31d9m0000gn/T/
   XPC_FLAGS=0x0
   LaunchInstanceID=433A53AA-AB93-4CF7-9700-BA15B57FFDAC
   TERM=xterm-256color
   LANG=en_US.UTF-8
    ... ... ... ... ... ... ... 
    ... ... ... ... ... ... ... 
   SHELL=/bin/zsh
   HOME=/Users/unix
   LOGNAME=unix
   USER=unix
   PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
   SHLVL=1
   PWD=/Volumes/data/unix-explore
   OLDPWD=/Volumes/data
   PS1= $> 
   _=/usr/bin/env
#+END_SRC
** Widely used functions for strings and buffers in low level codes 

This section provides a recapitulation of the most widely used C
functions in low level code bases and legacy C codes. Those functions
are in the header <string.h> for C or <cstring> for C++.


  + _strlen()_ => Get length of null-terminated character array.
    + Docs: $ man strlen 

#+BEGIN_SRC cpp 
   size_t strlen(const char *s);

   root [39] const char* st1 = "unix posix irix linux";
   root [40] const char* st2 = "bsd msdos";

   root [41] strlen(st1)
   (unsigned long) 21

   root [42] strlen(st2)
   (unsigned long) 9
#+END_SRC

  + _strdup()_ => Copy a C-string allocating the copy with malloc. 

#+BEGIN_SRC cpp 
   char* strdup(const char *s);

   root [39] const char* st1 = "unix posix irix linux";

   root [43] char* p_copy = strdup(st1)
   (char *) "unix posix irix linux"

   // Release memory for heap-allocated string 
   root [47] free(p_copy)
#+END_SRC

  + _strcmp()_ => Compare two C-strings null-terminated (terminated with
    '\0' or 0x00 null char) array of characters. This function returns
    0 if the two strings are equal.
    + Docs: $ man strcmp 

#+BEGIN_SRC cpp 
    int strcmp(const char *s1, const char *s2);

    // ------- USAGE --------------------------//
    if ( strmcp(STRING_A, STRING_B) == 0 )
        puts(" => Strings are equal");
    else 
        puts(" => Strins are not equal");

    // ------ CERN's Root REPL Session -------// 
    root [0] #include <string.h>

    root [1] const char* s1 = "hello"; 
    root [2] const char* s2 = "world"; 
    root [3] const char* s3 = "world C++17 c11 ADA spark"; 
    root [4] const char* s4 = "hello"; 

    root [5] strcmp(s1, s2)
    (int) -15

    root [6] strcmp(s1, s3)
    (int) -15

    root [7] strcmp(s1, s4)
    (int) 0
#+END_SRC

  + _strcasecmp()_ => Compare two string ignoring case sensitivity. This
    function returns 0 if the string arguments are equal. Othewise, it
    returns anything other than 0. 

#+BEGIN_SRC cpp 
    int strcasecmp(const char *string1, const char *string2);

    // ---- USAGE ------------------------------------------// 

    if( strcasecmp(stringA, stringB) == 0 )
       printf(" Strings are equal Ok. \n");
    else 
       printf(" Strings are not equal. \n");

    // ----- CERN's ROOT REPL session ----------------------// 

    // Strings not equal 
    root [21] strcasecmp("app", "Application")
    (int) -108

    // Strings are equal 
    root [22] strcasecmp("application", "Application")
    (int) 0

    root [23] strcasecmp("AppLiCatION", "Application")
    (int) 0
    root [24] 
#+END_SRC

  + _sprintf()_ => Print string to a buffer. (Headers: <cstdio> in C++ or
    <stdio.h> in C). Note: this function is vulnerable to buffer
    overflow, if the data copied to the buffer is larger than its
    size. 

#+BEGIN_SRC cpp 
   int sprintf(char *str, const char *format, ...);

   // ---- CERN's ROOT REPL session ----------------------// 

   root [1] char buffer[300];
   root [2] memset(buffer, 0x00, 300)

   root [4] sprintf(buffer, "The root of %d is equal to %f", 2, 2.0);

   root [5] buffer
   (char [300]) "The root of 2 is equal to 2.000000\0\0\0\0\0\0\0\.... ... \0"

   root [7] std::cout << " buffer = <" << buffer << ">" << '\n';
   buffer = <The root of 2 is equal to 2.000000>
#+END_SRC

  + _snprintf()_ => Print string to a buffer limiting the number of
    characters that are copied to the buffer. The limitation of the
    number characters copied helps protecting against buffer overflow
    vulnerabilities. 

#+BEGIN_SRC cpp 
   int snprintf(char *str, size_t size, const char *format, ...);

   // ---- CERN's ROOT REPL session ----------------------------//
   root [0] char buf[200];
   root [1] memset(buf, '\0', 200); // Initialize buffer

   root [6] snprintf(buf, 10, "The square root of %f is equal to %.3f ", 10.0, sqrt(10.0));
   root [7] 
   root [7] buf
   (char [200]) "The squar\0\0\0\0\0... ...\0\0\0"

   root [8] snprintf(buf, 25, "The square root of %f is equal to %.3f ", 10.0, sqrt(10.0));
   root [9] 
   root [9] buf
   (char [200]) "The square root of 10.00\0\0\0...\0\0"


   root [10] snprintf(buf, 125, "The square root of %f is equal to %.3f ", 10.0, sqrt(10.0));
   root [11] 
   root [11] buf
   (char [200]) "The square root of 10.000000 is equal to 3.162 \0\0\0..\0\0"
#+END_SRC

  + _strcpy()_ => Copy string 'src' parameter (null-terminated array of
    characters) to a buffer.
    + Docs: $ man strcpy 
    + Note: It is vulnerable to buffer
      overflow, if the size of the string is bigger than the
      buffer. This function is often used to for copying string literals
      to a buffer.

#+BEGIN_SRC cpp 
     char* strcpy( char*       p_buffer      // Pointer to buffer (array of chars)
                  ,const char* c_string_src  // C-string 
                );

     root [9] char buffer[200];

     root [10] buffer
     (char [200]) "\0\0\0\0\0\0\0\0\0\0\0\0\0\0 ...... \0\0\0\0"

     root [11] strcpy(buffer, "Hello world C++17 C++20 ADA Rust")
     (char *) "Hello world C++17 C++20 ADA Rust"

     root [12] buffer
     (char [200]) "Hello world C++17 C++20 ADA Rust\0\0\0\0\0\0\0 ... ... \0\0\0"
#+END_SRC

  + _strncpy()_ => Copy N characters from string to buffer.
    + Docs: $ man strncpy 
    + Linux mapage: "The strcpy() function copies the string pointed
      to by src, including the terminating null byte ('\0'), to the
      buffer pointed to by dest.  The strings may not overlap, and the
      destination string dest must be large enough to receive the
      copy. Beware of buffer overruns!  (See BUGS.)"
    
#+BEGIN_SRC cpp 
   char* strncpy( char*       dest // Pointer to buffer 
                , const char* src  // C-string (null-terminated) that will be copied 
                , size_t      n    // Number of chars (bytes) from src that will be copied
                );

   // ---------- CERN's ROOT Repl Session ------------//

   root [13] char buff1[30];
   root [14] char buff2[30];

   root [15] const char* cstr = "Hello world C++17 embedded systems real time control systems";

   root [16] buff1
   (char [30]) "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"

   root [17] buff2
   (char [30]) "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"

   root [18] strncpy(buff1, cstr, 10)
   (char *) "Hello worl"

   root [19] buff1 
   (char [30]) "Hello worl\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"

   root [20] strncpy(buff2, cstr, 25)
   (char *) "Hello world C++17 embedde"

   root [21] buff2
   (char [30]) "Hello world C++17 embedde\0\0\0"
#+END_SRC  

 
  + _strcat()_ => Manpage: "The strcat() function appends the src string
    to the dest string, over‐ writing the terminating null byte ('\0')
    at the end of dest, and then adds a terminating null byte.  The
    strings may not overlap, and the dest string must have enough
    space for the result.  If dest is not large enough, program
    behavior is unpredictable; buffer overruns (aka buffer overflow)
    are a favorite avenue for attacking secure program"

    + Note: This function is unsafe and can introduce buffer overflow
      vulnerability if the size of the _src_ string is not limited.

#+BEGIN_SRC cpp 
   char *strcat(char *dest, const char *src);

   // ------------- CERN Root REPL  ------------------//
   const char* null_terminated_char_array1= "C++1z KALMAN FILTER sensor fusion data";
   char buffer1[100] = "Append cstring: ";

   root [3] buffer1
   (char [100]) "Append cstring: \0\0\0\0\0\0\0\0\0\0\0\0\0...\0\0"


   root [4] strcat(buffer1, null_terminated_char_array1)
   (char *) "Append cstring: C++1z KALMAN FILTER sensor fusion data"

   root [5] buffer1
   (char [100]) "Append cstring: C++1z KALMAN FILTER sensor fusion data\0\0....\0\0"

   root [6] strcat(buffer1, " string literal ")
   (char *) "Append cstring: C++1z KALMAN FILTER sensor fusion data string literal "

   root [7] buffer1 
   (char [100]) "Append cstring: C++1z KALMAN FILTER sensor fusion data string literal \0\0\0\0...\0\0"
#+END_SRC

  + _strncat()_ => Similar to strcat, but it limits the number of
    character to be copied from _src_ to a buffer. 

#+BEGIN_SRC cpp 
    char* strncat(char *dest, const char *src, size_t n);

    // ------------ CERN's Root REPL session ----------------------// 
    // 

    // Stack-allocated buffer 
    root [8] char buff[100];
    root [11] memset(buff, 100, 0x00); // Initialize buffer

    root [12] const char* str1 = "Hello world APL C++1z ADA RUST DLang OCaml";

    root [13] buff
    (char [100]) "\0\0\0\0\0\0\0\0\0\0\0\0\0\0...\0\0"

    root [14] strncat(buff, str1, 10)
    (char *) "Hello worl"


    root [15] buff
    (char [100]) "Hello worl\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 .. \0\0"

    root [16] strncat(buff, str1, 20)
    (char *) "Hello worlHello world APL C++1"

    root [17] buff
    (char [100]) "Hello worlHello world APL C++1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0....\0\0"

    root [18] strncat(buff, str1 + 25, 30)
    (char *) "Hello worlHello world APL C++1 RUST DLang OCaml"

    root [19] buff
    (char [100]) "Hello worlHello world APL C++1 RUST DLang OCaml\0\0...\0\0"
#+END_SRC

  + _memset()_ => Fill some memory area (buffer) with a constant byte. 

#+BEGIN_SRC cpp 
   void*  memset(void *s, int c, size_t n);

   // ------ CERN's ROOT REPL session -------------// 
   // 

   // Create a heap-allocated buffer containing 6 characters. 
   root [0] char* char_heap_buffer = (char*) malloc(6 * sizeof(char))
   (char *) "@\x0e" "e\x01"

   root [1] char_heap_buffer[0]
   (char) '@'

   root [2] char_heap_buffer[1]
   (char) '0x0e'

   root [3] char_heap_buffer[2]
   (char) 'e'

   // Intialize buffer char_hepa_buffer 
   root [9] memset(char_heap_buffer, 'z', 6)
   (void *) 0x128c760

   root [10] char_heap_buffer[0]
   (char) 'z'

   root [11] char_heap_buffer[1]
   (char) 'z'

   root [12] char_heap_buffer[2]
   (char) 'z'

   root [13] char_heap_buffer[3]
   (char) 'z'

   root [14] char_heap_buffer 
   (char *) "zzzzzz"

   root [15] free(char_heap_buffer)
#+END_SRC

  + _memcmp()_  => Compare the first N bytes of two buffers. It returns
    0 if all the first N bytes from two buffers are equal. Note: This
    function can only compare buffers containing POD data (Plain-Old
    Data) without any internal pointer or heap-allocated data. 

#+BEGIN_SRC cpp 
     int memcmp(  const void* s1 // Pointer to the beginning of buffer 1 
                , const void* s2 // Pointer to the beginning of buffer 2 
                , size_t n       // Number of bytes that will be compared 
              );  

   // -------- CERN's ROOT REPL Session -----------------------// 
    root [22] uint8_t bf1[] = { 0x01, 0xAB, 0x2C, 0x3C, 0xFF };
    root [26] uint8_t bf2[] = { 0x01, 0xAB, 0x2C, 0x3C, 0xFF, 0x85, 0x2A, 0x45 };
    root [30] uint8_t bfx[] = { 0x3A, 0xF8, 0x25 } 

    // Result: Non-zero => First 3 bytes of two buffers are not equal. 
    root [32] memcmp(bf1, bfx, 3)
    (int) -57

    // Result: Zero => First 5 bytes of two buffers are equal. 
    root [36] memcmp(bf1, bf2, 5)
    (int) 0

    // Result: Zero => First 2 bytes of two buffers are equal. 
    root [37] memcmp(bf1, bf2, 2)
    (int) 0

    root [13] free(heap_buffer)
#+END_SRC

  + _memcpy()_ => Copy N bytes from a memory area (or buffer) src to a
    memory area dest. This function can only copy POD (Plain Old Data)
    types, it cannot copy anything which contains pointers or
    heap-allocated data. 
 
#+BEGIN_SRC cpp 
   void* memcpy(void* dest, const void* src, size_t n);

   // ------- CERN's ROOT Repl session ---------------// 
   // 

   // ---- Char array --------//
   root [51] char buf1[10] = { 'h', 'e', 'l', 'l', 'o', ' ', 'c', 'p', 'p', '\0' }
   (char [10]) "hello cpp"

   root [53] char buf2[15] 
   (char [15]) "\0\0\0\0\0\0\0\0\0\0\0\0\0"

   root [54] memcpy(buf2, buf1, 10 * sizeof(char))
   (void *) 0x7f5c5cd7d1b5

   root [55] buf2
   (char [15]) "hello cpp\0\0\0\0"

   // ---- Int array -------//
   root [56] int arr1[5] = { 10, 20, 25, 100, -2}
   (int [5]) { 10, 20, 25, 100, -2 }

   root [57] int arr2[10]
   (int [10]) { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

   root [58] memcpy(arr2, arr1, 5 * sizeof(int))
   (void *) 0x7f5c5cd7d1f0

   root [59] arr2
   (int [10]) { 10, 20, 25, 100, -2, 0, 0, 0, 0, 0 }
#+END_SRC

  + _bzero()_ => Zero-initialize some memory area. In the words of
    manpage: "The bzero() function erases the data in the n bytes of
    the memory starting at the location pointed to by s, by writing
    zeros (bytes containing '\0') to that area."

#+BEGIN_SRC cpp 
   void bzero(void *s, size_t n);

   // ------------ CERN's ROOT REPL session --------------//
   //    

   // Heap-allocated buffer with 5 integers
   root [1] int* heap_buffer = (int*) malloc(5 * sizeof(int)) 
   (int *) 0x2c50ea0

   root [2] heap_buffer[0]
   (int) 37832720

   root [3] heap_buffer[1]
   (int) 0

   root [4] heap_buffer[2]
   (int) 51513872

   // Initialize buffer, filling it with zeroes. 
   root [7] bzero(heap_buffer, 5 * sizeof(int))

   root [8] heap_buffer
   (int *) 0x2c50ea0

   root [9] heap_buffer[0]
   (int) 0

   root [10] heap_buffer[1]
   (int) 0

   root [11] heap_buffer[2]
   (int) 0

   root [12] heap_buffer[4]
   (int) 0
#+END_SRC

  + _bcopy()_ => Manpage: "The bcopy() function copies n bytes from src
    to dest.  The result is correct, even when both areas overlap."
    + Note: Despite the manpage state that the function is deprecated
      it is still used by many legacy codes, so it is still worth
      knowing about it. 

#+BEGIN_SRC cpp 
   void bcopy(const void *src, void *dest, size_t n);

   // ----------- CERN's ROOT Repl Session --------------// 

   root [0] char buffer[50];
   root [1] bzero(buffer, 50 * sizeof(char))

   root [2] buffer 
   (char [50]) "\0\0\0\0\0\0\0\0\0\0\0... ...\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"

   // Null terminated array of chars
   root [3] const char* src1 = "This is the buffer 1"; 

   root [4] bcopy(src1, buffer, 10)

   root [5] buffer
   (char [50]) "This is th\0\0\0\0\0\0\0\0... ...0\0\0\0\0\0\0"

   root [6] bcopy(src1, buffer, 25)

   root [7] buffer
   (char [50]) "This is the buffer 1\0\0\0\0\x14\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"

   root [8] bcopy("control system Modelica / state space model / SIMULINK", buffer, 40)

   root [9] buffer
   (char [50]) "control system Modelica / state space mo\0\0\0\0\0\0\0\0"
#+END_SRC

** Creating Portable Binaries for Linux / GLIBC Dependency Hell 
*** Overview 

One of the greatest challenges of Linux desktop is building and
deploying portable applications and native executable which work on
any Linux distribution. Even if an application totally statically
linked against all dependencies or it is bundled with all its shared
libraries dependencies via LD_LIBRARY_PATH environment variable or
RPATH, the program may still fail to run in other Linux distribution
due to the GLIBC (GNU C library runtime) dependency. A GLIBC is _forward_
_compatible_, but not _backward compatible_, the GLIBC runtime failure is
more likely to happen if the application was built on a Linux
distribution using a newer version of GLIBC, but the program is
deployed in a distribution using an older version of GLIBC.

  * Side Note 1:
    + Applications built with GO (Golang) programming
      language are less likely to be affected by the GLIBC-issue, as GO
      compiler often does not link against the GLIBC and builds
      statically linked binaries which can be deployed everywhere.

  * Side Note 2:
    + The GLIBC issue do not only affect C++, all programming
      languages which generates native Linux executables, for
      instance, D-lang, Rust, OCaml, Haskell are also affected
      by the GLIBC compability problem.

  * Side Note 3:
    + Even [[https://appimage.org/][AppImage]], which is a solution for distributing binaries on
      Linux is affected by the GLIBC-problem. As a result, the
      AppImage documentation recommends building AppImage on Linux
      distributions with older versions of GlibC.

  * Side Node 4:
    * The GLIBC can be bypassed if the application invokes
      system-calls directly using assembly or inline assembly. On
      Linux, this is possible because the system calls are stable and well
      documented. This might be the approach used by Golang for
      avoiding the GLIBC dependency. 

Possible Solutions: 

  1. Link against an older version of GLIBC
     + Build the application in a system with the oldest possible version
       of GLIBC. _System_ in this context means: a linux virtual machine; a
       chroot environment or a docker image with an older version of
       GLIBC.

  2. Link against MUSL (CRT - C Runtime Library)
     + The MUSL library, is an alternative to GLIBC, which was
       designed for embedded systems and static linking, allows
       building statically linked binaries that does not suffer from
       the GLIBC compatibility problems. The drawback of this
       procedure is that dynamic loading with _dlopen_ API (dlopen,
       dlclose, dlsym functions) is still not supported.

  3. Deploy via Docker
     * Deploy the application via docker image. While this solution is
       acceptable for compilers, building environments, servers and
       command line applications, Docker is not suitable for games or
       Desktop GUI (Graphical User Interface) applications intended
       to be used by non-technical users.
     * Advantage:
       * Pack application, dependencies and configuration.
       * The deployment environment can be reproduced everywhere. 

  4. Distribute as source and recompile from source on every
     deployment machine. 

  5. Distribute the application via Linux distribution repositories
     * Distribute the application via official Linux distribution
       repositories by creating distribution-specific packages for
       every supported distribution. It means creating (.deb) Debian packages for
       Debian-based distributions; (.rpm) packages for Fedora and
       Centos; (.apk) alpine packages for Alpine.

 *Further Reading* 

General reading about Linux CRT (C Runtime Library), GlibC and alternatives:

   * [[https://abi-laboratory.pro/index.php?view=timeline&l=glibc][API/ABI changes review for glibc]]

   * [[https://www.etalabs.net/compare_libcs.html][Comparison of C/POSIX standard library implementations for Linux]]
     * Brief: "The table below and notes which follow are a comparison
       of some of the different standard library implementations
       available for Linux, with a particular focus on the balance
       between feature-richness and bloat. I have tried to be fair and
       objective, but as I am the author of musl, that may have
       influenced my choice of which aspects to compare. Future
       directions for this comparison include detailed performance
       benchmarking and inclusion of additional library
       implementations, especially Google's Bionic and other BSD libc
       ports."

   * [[https://lwn.net/Articles/488847/][A turning point for GNU libc [LWN.net]]] - Jonathan Corbet
     * Brief: "The kernel may be the core of a Linux system, but neither
       users nor applications deal with the kernel directly. Instead,
       almost all interactions with the kernel are moderated through the
       C library, which is charged with providing a standards-compliant
       interface to the kernel's functionality. There are a number of C
       library implementations available, but, outside of the embedded
       sphere, most Linux systems use the GNU C library, often just
       called "glibc." The development project behind glibc has a long
       and interesting history which took a new turn with the
       dissolution of its steering committee on March 26. ... ..."

   * [[https://lwn.net/Articles/771441/][C library system-call wrappers, or the lack thereof [LWN.net]]] - Jonathan Corbet
     * Brief: "User-space developers may be accustomed to thinking of
       system calls as direct calls into the kernel. Indeed, the first
       edition of The C Programming Language described read() and
       write() as "a direct entry into the operating system". In
       truth, user-level "system calls" are just functions in the C
       library like any other. But what happens when the developers of
       the C library refuse to provide access to system calls they
       don't like? The result is an ongoing conflict that has recently
       flared up again; it shows some of the difficulties that can
       arise when the system as a whole has no ultimate designer and
       the developers are not talking to each other. ... "

   * [[https://akkadia.org/drepper/symbol-versioning][ELF Symbol Versioning]] - _Ulrich Drepper_
     + Brief: "The symbol versioning implementation used on Linux with glibc
       2.1 o up is an extension of Sun's versioning.  It provides most
       of the functionality Sun has plus one decisive new element:
       symbol-level versioning with multiple definitions of a
       symbol. The implementation allows every DSO to either use
       versions for their symbols or not.  Depending on whether the
       DSO an object is linked against had symbols or not, the
       reference to the DSO requires symbols or not.  This is recorded
       in the binary by three new sections: ... ..."  

   * [[https://events.static.linuxfound.org/sites/events/files/slides/libc-talk.pdf][Choosing System C library]] - Khem Raj (Comcast) - Embedded Linux
     Conference	Europe 2014 Düsseldorf Germany.

   * [[https://wiki.osdev.org/C_Library][Wikidev - C Library]]
     * Brief: "The C standard library provides string manipulation
       (string.h), basic I/O (stdio.h), memory allocation (stdlib.h),
       and other basic functionality to C programs. The interface is
       described in the C standard, with further additions described
       in POSIX as well as vendor extensions. On Unix platforms, the
       library is named libc and is linked automatically into every
       executable. ... ."

   * [[https://www.lightofdawn.org/wiki/wiki.cgi/NewAppsOnOldGlibc][Running new applications on old glibc - (lightofdawn)]]
     + Brief: "Glibc (short for GNU Libc, or GNU C Library) is a
       library that provides the interface between application
       programs and the Linux kernel. Although its official name is
       the "C" library (library for programs written in the "C"
       language), virtually all dynamically linked program binaries
       depend on it - it is the de-facto system library in almost all
       Linux operating systems. ... "

   * [[https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host][linux - Multiple glibc libraries on a single host - Stack Overflow]]
     * Brief: "Multiple glibc libraries on a single host. My linux
       (SLES-8) server currently has glibc-2.2.5-235, but I have a
       program which won't work on this version and requires
       glibc-2.3.3. Is it possible to have multiple glibcs installed
       on the same host? This is the error I get when I run my program
       on the old glibc: ..." 

   * [[https://wiki.musl-libc.org/][musl libc Wiki]] [EMBEDDED-SYSTEMS] (Alternative to GLIBC - allows
     creating fully statically linked and self-contained binaries)
     + Brief: "musl is a C standard library implementation for
       Linux. This is a wiki maintained by the enthusiastic user
       community of musl. Some of musl’s major advantages over glibc
       and uClibc/uClibc-ng are its size, correctness, static
       linking support, and clean code."

   * [[https://github.com/ifduyue/musl][GitHub - ifduyue/musl]] - Unofficial mirror of MUSL (CRT)

   * [[https://wiki.musl-libc.org/projects-using-musl.html][musl libc - Projects using musl]] - List of projects using MUSL
     libC instead of GLIBC (GNU C Library)

   * [[https://sourceware.org/newlib/][The Newlib Homepage]] [EMBEDDED-SYSTEMS] (Alternative to GLIBC)
     * Brief: "Newlib is a C library intended for use on embedded
       systems. It is a conglomeration of several library parts, all
       under free software licenses that make them easily usable on
       embedded products. Newlib is only available in source form. It
       can be compiled for a wide array of processors, and will
       usually work on any architecture with the addition of a few
       low-level routines."

   * [[https://github.com/hwoarang/uClibc][GitHub - hwoarang/uClibc]] [EMBEDDED-SYSTEMS] (Alternative to GLIBC)
     * Brief: "uClibc (aka µClibc/pronounced yew-see-lib-see) is a C
       library for developing embedded Linux systems.  It is much
       smaller than the GNU C Library, but nearly all applications
       supported by glibc also work perfectly with uClibc.  Porting
       applications from glibc to uClibc typically involves just
       recompiling the source code. uClibc even supports shared
       libraries and threading.  It currently runs on standard Linux
       and MMU-less (also known as µClinux) systems with support for
       alpha, ARM, cris, e1, h8300, i386, i960, m68k, microblaze,
       mips/mipsel, PowerPC, SH, SPARC, and v850 processors. ..."

Utilities to Patch and modify ELF binaries and other general utilities: 

   * [[https://github.com/NixOS/patchelf][GitHub - NixOS/patchelf]]
     * "PatchELF is a simple utility for modifying existing ELF
       executables and libraries. In particular, it can do the
       following: Change the dynamic loader ("ELF interpreter") of
       executables; Change the RPATH of executables and libraries;
       Shrink the RPATH of executables and libraries."

   * [[https://github.com/wheybags/glibc_version_header/][GitHub - wheybags/glibc_version_header]] (Utility for ignoring ELF
     symbol version - note: it is not safe). 
     * Brief: "Build portable Linux binaries, no more linker errors on users'
       older machines from incompatible glibc versions. Essentially,
       this is a tool that allows you to specify the glibc version
       that you want to link against, regardless of what version is
       installed on your machine. This allows you to make portable
       Linux binaries, without having to build your binaries on an
       ancient distro (which is the current standard practice). "

   * [[https://github.com/emk/rust-musl-builder][GitHub - emk/rust-musl-builder]]
     * Brief: ": Docker images for compiling static Rust binaries
       using musl-libc and musl-gcc, with static versions of useful C
       libraries. Supports openssl and diesel crates. "

Reports of GLIBC dependency hell (Version mismatch): 

  + [[https://users.rust-lang.org/t/i-often-run-into-issues-with-glibc-versions-on-the-target-machine-is-there-anything-i-can-do-to-prevent-that/32242][I often run into issues with glibc versions on the target machine is there anything i can do to prevent that?]]

  + [[https://web.archive.org/save/https://www.dropboxforum.com/t5/Dropbox-installs-integrations/Cannot-run-latest-dropboxd-on-Centos-7-with-glibc-2-17-and/td-p/431544][Cannot run latest dropboxd on Centos 7 with glibc 2.17, and flatpak version crashes]]

*** The GLIBC Problem 

 *GLIBC - Problem Illustration with a Sample Project* 

GIST Containing all files used in this experiment: 

  + https://gist.github.com/0557cd0fa1d5370723b015e443a7c036

File: Makefile

#+BEGIN_SRC make 
  build:
          cmake --config Debug -H. -B_build2
          cmake --build _build2 --target 
#+END_SRC

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(Simple_Cmake_Project)

  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #========== Targets Configurations ============#
          add_executable( filesys filesys.cpp )
  target_link_libraries( filesys stdc++fs)
#+END_SRC

File: filesys.cpp 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <iterator>
  #include <iomanip>
  #include <filesystem>

  namespace fs = std::filesystem;

  template<typename Range, typename Function>
  auto dotimes(size_t n, Range&& iterable, Function fun)
  {
      size_t i = 0;
      auto it = fs::begin(iterable);
      auto end = fs::end(iterable);
      while(i < n && it != end ){
              fun(it);
              ++it;
              i++;
      }
  }

  int main(){

       std::cout << std::boolalpha;
       std::cout << "\n ===== Listing directory /etc =====" << std::endl;
       // Show first 10 files of directory /etc 
       dotimes(10, fs::directory_iterator("/etc"),
               [](auto p){
                    auto path = p->path();
                    std::cout << std::left
                              << std::setw(0) << path.filename().string()
                              << " " << std::setw(35)
                              << std::right << std::setw(40) << path
                              << std::endl;				
               });		
       return EXIT_SUCCESS;
  }
#+END_SRC

 *Steps for reproducing the problem* 

STEP 1: Get current machine infomation. 

  + GLIBC Version is: 2.34-2.fc32

#+BEGIN_SRC sh 
  # Current machine 
  $ cat /etc/fedora-release 
  Fedora release 32 (Thirty Two)

  # Current GLIBC Version 
  $ ld --version
  GNU ld version 2.34-2.fc32
  ... ... ... ... 
#+END_SRC

STEP 2: Build the application. 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/0557cd0fa1d5370723b015e443a7c036 gist && cd gist 
  $ cmake --config Debug -H. -B_build1
  $ cmake --build _build1 --target 

  $ file _build1/filesys 
  _build1/filesys: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, 
  interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d1a3628f794c66bcfb29303cfa4a528910f4e3e2
  , for GNU/Linux 3.2.0, not stripped
#+END_SRC

STEP 3: Run in the current machine (newer version of GLIBC)

#+BEGIN_SRC sh 
  $ _build1/filesys 

   ===== Listing directory /etc =====
  chrony.conf                       "/etc/chrony.conf"
  xl2tpd                            "/etc/xl2tpd"
  group                             "/etc/group"
  profile.d                         "/etc/profile.d"
  kde4rc                            "/etc/kde4rc"
  resolv.conf.8LUAL0                "/etc/resolv.conf.8LUAL0"
  geoclue                           "/etc/geoclue"
  bash_completion.d                 "/etc/bash_completion.d"
  cups                              "/etc/cups"
  mime.types                        "/etc/mime.types"
#+END_SRC

STEP 4: Attempt to run the binary in a distribution using an older
version of GLIBC. The distribution used was a QEMU-KVM virtual
machine running MX-Linux 19.2, distribution based on Debian, with
GLIBC version .

GLIBC Failure on MX-Linux Virtual Machine: 

#+BEGIN_SRC sh 
  #---------- Failure!! GLIC Incompa ------------------------------------#
   $ _build1/filesys 
   _build1/filesys: /lib/x86_64-linux-gnu/libstdc++.so.6: version 
    'GLIBCXX_3.4.26' not found (required by _build1/filesys)
#+END_SRC

Virtual Machine Information: 

#+BEGIN_SRC sh 
   #----------- Machine Info (MX Linux 19.2) -------------#
   # Kernel version 
   $ uname -r
   4.19.0-9-amd64

   # Distro name 
   $ cat /etc/issue 
   Welcome to MX 19.2 (patito feo) 64-bit! Powered by Debian.
   ... ... ... ... ............ .... ... ... .. 

   $ ld --version
   GNU ld (GNU Binutils for Debian) 2.31.1
   ... ... ... ... ... ... ... ... ... ... ... ... 
#+END_SRC

*** Solution 1 - via linking against older GLIBC 

As GLIBC is _forward compatible_, but not _backward compatible_. The
solution for this issue is to build the application on a _system_ with
the oldest possible version of GLIBC. System in this context, means: a
Linux virtual machine; a Chroot environment; or Docker image with an
older version of GLIBC. Other alternative is to replace GLIBC with
_MUSL_ CRT (C Runtime library), but the drawback is that MUSL does not
support dynamic loading (_dlopen_, _dlsym_ APIs). 

The solution adopted for solving this issue was to use a Docker image
based on [[https://github.com/phusion/holy-build-box][holy-build-box]], which is a Docker image based on Centos 6
Linux distribution containing a modern version of GCC compiler, CMake
and an older version of GLIBC.

See: 
  + https://github.com/phusion/holy-build-box

 _File: Dockerfile_ (Available at [[https://gist.github.com/0557cd0fa1d5370723b015e443a7c036][gist url]])

#+BEGIN_SRC sh 
  # $ docker run -it --rm -v $PWD:/work -w /work phusion/holy-build-box-64:latest bash 
  FROM phusion/holy-build-box-64:latest

  ENTRYPOINT [ "/hbb_exe/activate-exec", "bash"  ]
#+END_SRC

Build docker image: 

#+BEGIN_SRC sh 
   # Run at the directory where is Dockerfile 
   $ docker build -f Dockerfile -t linux-build . 
#+END_SRC

Enter in the docker image shell: 

#+BEGIN_SRC sh 
   $ docker run --rm -it -v $PWD:/cwd -w /cwd linux-build 
   Holy build box activated
   Prefix: /hbb_exe
   CFLAGS/CXXFLAGS: -g -O2 -fvisibility=hidden -I/hbb_exe/include 
   LDFLAGS: -L/hbb_exe/lib -static-libstdc++
   STATICLIB_CFLAGS: -g -O2 -fvisibility=hidden -I/hbb_exe/include 
   SHLIB_CFLAGS: -g -O2 -fvisibility=hidden -I/hbb_exe/include 
   SHLIB_LDFLAGS: -L/hbb_exe/lib -static-libstdc++

   [root@88c9630a2008 cwd]# ls
   _build1  CMakeLists.txt   Dockerfile   filesys.cpp   Makefile
#+END_SRC

Building the application: 

#+BEGIN_SRC sh 
  [root@88c9630a2008 cwd]# make 
  cmake --config Debug -H. -B_build2
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /cwd/_build2
  cmake --build _build2 --target 
  gmake[1]: Entering directory '/cwd/_build2'
  /hbb/bin/cmake -S/cwd -B/cwd/_build2 --check-build-system CMakeFiles/Makefile.cmake 0
  ... ... ... ... ... ... ... ... ... 
  ... ... ... ... ... ... ... ... ... ... ... ... 

  [root@88c9630a2008 cwd]# ls _build2
  CMakeCache.txt  CMakeFiles  cmake_install.cmake  filesys  Makefile
#+END_SRC

Running the application _build2/filesys in MX-Linux: 

#+BEGIN_SRC sh 
   # Built on Fedora 32 with newer version of GLIBC [FAILURE]
   $ _build1/filesys
   _build1/filesys: /lib/x86_64-linux-gnu/libstdc++.so.6: 
   version 'GLIBCXX_3.4.26' not found (required by _build1/filesys)


   # Built on Centos6 docker with older version of GLIBC [OK, WORKS]
   #--------------------------------------
   $ _build2/filesys

    ===== Listing directory /etc =====
   .java                             "/etc/.java"
   .pwd.lock                         "/etc/.pwd.lock"
   ImageMagick-6                     "/etc/ImageMagick-6"
   NetworkManager                    "/etc/NetworkManager"
   UPower                            "/etc/UPower"
   X11                               "/etc/X11"
   acpi                              "/etc/acpi"
   adduser.conf                      "/etc/adduser.conf"
   adjtime                           "/etc/adjtime"
   alsa                              "/etc/alsa"
#+END_SRC
*** Solution 2 - via linking against MUSL libC

Other alternative to avoid the GLIBC dependency problem is to build
the application statically linking against [[https://www.musl-libc.org/][MUSL - LibC]] which is an CRT
(C runtime library), initially developed for embedded systems, but that has
become an alternative to GLIBC. The easiest way to build statically
linking against MUSL is to use an Alpine docker image: 

 + Note: CRT - is a central component of Unix-like operating
   systems. It encapsulates system-calls and other operating system
   services for user-space applications. 

See: 
  * [[https://en.wikipedia.org/wiki/Musl][Musl - Wikipedia]]
  * [[https://wiki.debian.org/musl][Musl - Debian]]
  * [[https://www.arangodb.com/2018/04/static-binaries-c-plus-plus-application/][Static Binaries for a C++ Application - ArangoDB]]
  * [[https://doc.rust-lang.org/edition-guide/rust-2018/platform-and-target-support/musl-support-for-fully-static-binaries.html][MUSL support for fully static binaries - Rust Docs]]
  * [[http://www.etalabs.net/compare_libcs.html][Comparison of C/POSIX standard library implementations for Linux]]
  * [[https://elinux.org/images/8/8b/Room_For_Cooperation-_Bionic_and_musl.pdf][Elinux/Linaro - Bionic and musl - room for cooperation?]]

File: MuslBuilder.docker ([[https://gist.github.com/0557cd0fa1d5370723b015e443a7c036][Available at gist]])

#+BEGIN_SRC docker 
  FROM alpine:latest
  RUN apk add musl cmake make g++
#+END_SRC

 *Building:* 

Buildilg the docker containing MUSL and development tools:

#+BEGIN_SRC sh 
   $ git clone https://gist.github.com/0557cd0fa1d5370723b015e443a7c036 && cd gist 
   $ docker build -f MuslBuilder.docker -t musl-builder . 
#+END_SRC

Running a container of this docker image: 

#+BEGIN_SRC sh 
   $ docker run -it --rm -v $(pwd):/cwd -w /cwd -e UID=$(id -u) -e GID=$(id -g) musl-builder 
   /cwd $ cmake --config Debug -H. -B_build-musl -DCMAKE_EXE_LINKER_FLAGS="-static -Os"
   /cwd $ cmake --build _build-musl --target 
#+END_SRC

Exiting from the container and check the executable:

#+BEGIN_SRC sh 
  $ du -h _build-musl/filesys 
  8.7M	_build-musl/filesys
  8.7M	total

  $ file _build-musl/filesys 
  _build-musl/filesys: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV)
  , statically linked, with debug_info, not stripped

  # Check dependencies 
  $ ldd _build-musl/filesys 
          statically linked
#+END_SRC

Attempt to run from MX-Linux 19.2 (Older GLIBC)

#+BEGIN_SRC sh 
   $ _build-musl/filesys 

    ===== Listing directory /etc =====
   .java                             "/etc/.java"
   .pwd.lock                         "/etc/.pwd.lock"
   ImageMagick-6                     "/etc/ImageMagick-6"
   NetworkManager                    "/etc/NetworkManager"
   UPower                            "/etc/UPower"
   X11                               "/etc/X11"
   acpi                              "/etc/acpi"
   adduser.conf                      "/etc/adduser.conf"
   adjtime                           "/etc/adjtime"
   alsa                              "/etc/alsa"
#+END_SRC
*** Portable binary using Golang 

Applications built with GO programming language are not affect by
GLIBC compatibility problems since the GO compiler implementation
performs system calls without relying on the GLIBC. This feature
allows deploying GO binaries in any Linux distribution without
worrying about GLIBC binary compatibility. 

 *Demonstration* 

File: _goapp.go_ 

#+BEGIN_SRC c++ 
  package main 

  import (
      "fmt"
      "io/ioutil"
      "net/http"
      _ "bufio"
      _ "log"
  )

  func main() {
    
      fmt.Println(" => Started Ok")
    
      // ------- List root directory ---------//
      fmt.Println(" ---- List Root Directory ------")
    
      // No error handler for the sake of breviety. 
      files, _ := ioutil.ReadDir("/")
    
      for _, fn := range files { 
          fmt.Println(" => " + fn.Name() )         
      } 
    
      // ---- Http Request ------------------// 
      fmt.Println(" ------- Http Request -------------")
      resp, _ := http.Get("https://www.httpbin.org/get")
      body, _ := ioutil.ReadAll(resp.Body)
      fmt.Println(string(body))
  }
#+END_SRC

Compile sample GO application: 

#+BEGIN_SRC sh
   # Compiled  
   $ go build goapp.go    

   # Remove debug symbols 
   $ strip goapp 

   # Get file size in megabytes    
   $ >> du -h goapp
   4.9M    goapp

   # Check binary 
   $ >> file goapp
   goapp: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter 
   /lib64/ld-linux-x86-64.so.2, 
   Go BuildID=rXh5UDymAYyqH6QHp4N5/KktyZonaNBes2MLq_8eV/4lmCJtW64uAqpYg_AIb_/5S4-otZPFzRnjGyq3bBL
  , not stripped

  # Check shared libraries dependencies 
   $ >> ldd goapp
          linux-vdso.so.1 (0x00007ffee9b99000)
          libpthread.so.0 => /lib64/libpthread.so.0 (0x00007fc87c0c6000)
          libc.so.6 => /lib64/libc.so.6 (0x00007fc87befc000)
          /lib64/ld-linux-x86-64.so.2 (0x00007fc87c10d000)
#+END_SRC 

Run application in Fedora 32 distribution (Newer version of GLIBC): 

#+BEGIN_SRC sh 
    $ >> ./goapp 
    => Started Ok
    ---- List Root Directory ------
    => .autorelabel
    => bin
    => boot
    => dev
    => etc
    ... ... ... ... ... ... ... ... ... 
    ... ... ... ... ... ... ... ... ... 
    => usr
    => var
    ------- Http Request -------------
   {
     "args": {}, 
     "headers": {
       "Accept-Encoding": "gzip", 
       "Host": "www.httpbin.org", 
       "User-Agent": "Go-http-client/2.0", 
       "X-Amzn-Trace-Id": "Root=2-5f5650e9-4830a22ac821b598c22defbc"
     }, 
     "url": "https://www.httpbin.org/get"
   }
#+END_SRC

Run application in MX-Linux distribution, based on Debian (Older version of GLIBC):

#+BEGIN_SRC sh 
  $ ./goapp
   => Started Ok
   ---- List Root Directory ------
   => .cache
   => .config
   => .fehbg
   => bin
   => boot
   ... ... ... ... .... ... ... ... ... .... ... 
   ... ... ... ... .... ... ... ... ... .... ... 
   => var
   => vmlinuz
   ------- Http Request -------------
  {
    "args": {}, 
    "headers": {
      "Accept-Encoding": "gzip", 
      "Host": "www.httpbin.org", 
      "User-Agent": "Go-http-client/2.0", 
      "X-Amzn-Trace-Id": "Root=1-5f56523a-6cfd5015acb4421e26947afe"
    }, 
    "url": "https://www.httpbin.org/get"
  }

#+END_SRC

** Fully Statically linked executables for embedded Linux systems
*** Overview 

This sections presents a procedure for cross-compiling a fully
statically linked executable, without any dependency, that can be
deployed on any ARMV7-based Embedded Linux system, including
Beaglebone Black development board and Android (Armv7 based
processor).

This procedure uses  [[https://hub.docker.com/layers/muslcc/i686/arm-linux-musleabi/images/sha256-818ac763b91e0112f7a38e34949c69a91d24852dc794372e905c70bb48370d0b?context=explore][muslcc/i686:arm-linux-musleabi]] docker image
which contains a cross-compiling toolchain capable of compiling
C or C++ applications for Linux kernel running on Armv7 based
processors. This toolchain also uses Musl libC, instead of glibC (GNU
C runtime library). Musl allows building fully statically applications
that does not rely on any system dependency. As a result,
applications, built with  Musl, can be run on any Linux
distribution without being affected by GNU GlibC mismatch problems which
arises when an application or object-code, that was built linked
against an newer version of GlibC, is run on a system using an older
version of GlibC resulting in a runtime linking error.

References and reading: 

  + https://hub.docker.com/r/muslcc/i686/tags 

  + More toolchains at: https://elinux.org/Toolchains

  + [[https://cmake.org/pipermail/cmake/2011-October/046743.html][[CMake] Fwd: Save stripped debugging information]]

  + [[https://stackoverflow.com/questions/6687630/how-to-remove-unused-c-c-symbols-with-gcc-and-ld][How to remove unused C/C++ symbols with GCC and ld? - Stack Overflow]]

  + [[https://ownyourbits.com/2018/06/13/transparently-running-binaries-from-any-architecture-in-linux-with-qemu-and-binfmt_misc/][Transparently running binaries from any architecture in Linux with QEMU and binfmt_misc – Own your bits]]

*** Project Files

All files are available at: 

  + https://gist.github.com/b411be3b2a4364c7d4de18edd37da6a3


File: _Dockerfil.docker_

#+BEGIN_SRC sh 
  FROM muslcc/i686:armv7l-linux-musleabihf
  RUN  apk add make cmake 

  # ENTRYPOINT ["cmake"]
#+END_SRC
 
File: _Makefile_ 

  + Makefile for running project commands and documenting the building
    process. 

#+BEGIN_SRC sh 
  DOCKER_COMMAND=docker run -e UID=$(shell id -u) -e GID=$(shell id -g) --volume=$(shell pwd):/cwd  --workdir=/cwd musl-armv7

  # Builds docker image: musl-armv7
  docker:
          docker build -f Dockerfile.docker -t musl-armv7 .

  # Build testing application 
  build:
          ${DOCKER_COMMAND} cmake -H. -B_build-armv7 -DCMAKE_BUILD_TYPE=Debug
          ${DOCKER_COMMAND} cmake --build _build-armv7 --target 

  clean:
          rm -rf -v _build-armv7
#+END_SRC

File: _CMakeLists.txt_ 

#+BEGIN_SRC sh  
  cmake_minimum_required(VERSION 3.9)
  project(embedded-linux-armv7)

  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #====== Global compiler and linker settings ======#

  # (-static)           => Fully statically link Musl-LibC
  # (-Wl,--gc-sections) => Remove unused code
  #                        (requires: -fdata-sections and -ffunction-sections)
  set(CMAKE_EXE_LINKER_FLAGS "-static -Wl,--gc-sections")

  # Separate data and code sections in order to reduce binary size. 
  add_definitions( -fdata-sections -ffunction-sections )

  # Copy target executable, for instance my-exe to my-exe.debug 
  # and strip debugging symbols from my-exe.
  # 
  # Reference: https://cmake.org/pipermail/cmake/2011-October/046743.html
  macro(STRIP_DEBUG_SYMBOLS target)
    ADD_CUSTOM_COMMAND(TARGET ${target} POST_BUILD
      COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:${target}> ${CMAKE_BINARY_DIR}/${target}.debug
      COMMAND ${CMAKE_STRIP} -g $<TARGET_FILE:${target}>
    )
  endmacro()

  #========== Targets Configurations ============#

          add_executable( app portable-app.cpp )
   target_link_libraries( app stdc++fs)
     STRIP_DEBUG_SYMBOLS( app )

#+END_SRC

File: _portable-app.cpp_ 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string>
   #include <algorithm>
   #include <iomanip>
   #include <filesystem>
   #include <fstream> 
   #include <cassert> 

   namespace fs = std::filesystem;

   int main(int argc, char** argv)
   {

     assert( argc >= 2 && "Supposed to have at least one arguments");
     std::cout << std::boolalpha;
     std::string command = argv[1];

     if(command == "version")
     { 
         auto ifs = std::ifstream("/proc/version");
         assert( ifs.good() && "File supposed to exist" );  
         std::cout << ifs.rdbuf();
         return EXIT_SUCCESS;
     }

     std::cout << "\n ===== Listing directory /etc =====" << std::endl;

     if(command == "list")
     {
         // Show first 10 files of directory /etc 
       auto iter = fs::directory_iterator(argv[2]);

       std::for_each(fs::begin(iter), fs::end(iter)
                    ,[](auto p){
                      auto path = p.path();
                      std::cout << std::left
                                << std::setw(0) << path.filename().string()
                                << " " << std::setw(35)
                                << std::right << std::setw(40) << path
                                << std::endl;				
                    });    
       return EXIT_FAILURE;    
     }

     return EXIT_SUCCESS;
   }
#+END_SRC

*** Building and running 

 *STEP 1:* Downloading the source code. 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/b411be3b2a4364c7d4de18edd37da6a3 musl-armv7 && cd musl-armv7
#+END_SRC

 *STEP 2:* Building the docker image: 

#+BEGIN_SRC sh 
  $ docker build -f Dockerfile.docker -t musl-armv7 .

  Sending build context to Docker daemon  7.168kB
  Step 1/2 : FROM muslcc/i686:armv7l-linux-musleabihf
   ---> 4141d3dcca3f
  Step 2/2 : RUN  apk add make cmake
   ---> Using cache
   ---> c18ba0aa2335
  Successfully built c18ba0aa2335
  Successfully tagged musl-armv7:latest
#+END_SRC

 *STEP 3:* Cross-compile the sample application: 

Cross-compiling from command line: 

#+BEGIN_SRC sh 
  # Run the docker shell (sh)
  $ docker run --interactive --tty -e UID=$(id -u) -e GID=$(id -g) --volume=$(pwd):/cwd  --workdir=/cwd musl-armv7
  /cwd # 
  
  # Build the application 
  /cwd $ cmake -H. -B_build-armv7 -DCMAKE_BUILD_TYPE=Debug
  /cwd $ cmake --build _build-armv7 --target

  # Exit the docker shell 
  /cwd $ cmake --build _build-armv7 --target
#+END_SRC

Cross-compile in a single step using the helper Makefile: 

#+BEGIN_SRC sh  
  $ make build 
#+END_SRC 

Check the compiled executables: 

#+BEGIN_SRC sh 
  $ ls _build-armv7/
  CMakeFiles/  app*  app.debug*  CMakeCache.txt  cmake_install.cmake  Makefile

  # Version with debug symbols 
  $ file _build-armv7/app
  _build-armv7/app: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped

  $ du -h _build-armv7/app
  736K	_build-armv7/app
  736K	total

  # Version without debugging symbols 
  $ file _build-armv7/app.debug 
  _build-armv7/app.debug: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV)
  , statically linked, with debug_info, not stripped

  $ du -h _build-armv7/app.debug 
  9.4M	_build-armv7/app.debug
  9.4M	total
#+END_SRC

 *STEP 4:* Attempt to run the built executable on different machines.

Attempt to run the previous executables on the host machine (x86-64
processor - 64 bits):

#+BEGIN_SRC sh 
  $ _build-armv7/app
  bash: _build-armv7/app: cannot execute binary file: Exec format error

  $ _build-armv7/app.debug 
  bash: _build-armv7/app.debug: cannot execute binary file: Exec format error
#+END_SRC

Run ARMv7 Linux binary on a x86-64 host machine using [[https://www.qemu.org/][QEMU]] emulator: [[https://ownyourbits.com/2018/06/13/transparently-running-binaries-from-any-architecture-in-linux-with-qemu-and-binfmt_misc/][(OwnYourBits)]]

#+BEGIN_SRC sh 
   # Install Fedora Packages 
   $ sudo dnf install -y qemu-user.x86_64 qemu-user-static.x86_64

   # Run the Armv7 binary using QEMU-user 
   $ qemu-arm ./_build-armv7/app version 
   Linux version 5.8.4-200.fc32.x86_64 (mockbuild@bkernel01.iad2.fedoraproject.org) ... ... 

   $ qemu-arm ./_build-armv7/app list /

    ===== Listing directory /etc =====
   srv                                   "/srv"
   sys                                   "/sys"
   opt                                   "/opt"
   run                                   "/run"
   media                                 "/media"
   bin                                   "/bin"
   .autorelabel                          "/.autorelabel"
   root                                  "/root"
   var                                   "/var"
   etc                                   "/etc"
   tmp                                   "/tmp"
#+END_SRC

Run application in _Beaglebone Black_ (Armv7) embedded linux development
board, similar to Raspberry-Pi, but with more IO ports, peripherals
and ADC analog-to-digital converters: 

#+BEGIN_SRC sh 
  debian@beaglebone:~$ file app
  app: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped

  debian@beaglebone:~$ du -h app
  736K	app

  debian@beaglebone:~$ file app
  app: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped
  debian@beaglebone:~$ 

  debian@beaglebone:~$ ./app 
  Assertion failed: argc >= 2 && "Supposed to have at least one arguments" (/cwd/portable-app.cpp: main: 14)
  Aborted
  debian@beaglebone:~$ 

  debian@beaglebone:~$ ./app version 
  Linux version 4.14.71-ti-r80 (root@b2-am57xx-beagle-x15-2gb) (gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1)) #1 SMP PREEMPT Fri Oct 5 23:50:11 UTC 2018
  debian@beaglebone:~$ 

  debian@beaglebone:~$ ./app list /

   ===== Listing directory /etc =====
  sys                                   "/sys"
  opt                                   "/opt"
  sbin                                  "/sbin"
  home                                  "/home"
  dev                                   "/dev"
  nfs-uEnv.txt                          "/nfs-uEnv.txt"
  usr                                   "/usr"
  bin                                   "/bin"
  etc                                   "/etc"
  proc                                  "/proc"
  boot                                  "/boot"
   ... ... ...  ... ... ...  ... ... ... 
   ... ... ...  ... ... ...  ... ... ... 

#+END_SRC

Run in Android Armv-7 phone via [[https://developer.android.com/studio/command-line/adb][ADB]] (Android Debug Bridge): 

#+BEGIN_SRC sh 
  # Transver application to phone via ADB 
   $ adb push _build-armv7/app.debug /data/local/tmp 
  _build-armv7/app.debug: 1 file pushed. 11.1 MB/s (9793936 bytes in 0.842s)

  # Enter ADB shell and run the application. 
   $ >> adb shell 
  bali:/ $ cd /data/local/tmp

  bali:/data/local/tmp $ file app.debug                                                                                                       
  app.debug: ELF executable, 32-bit LSB arm, static, not stripped

  bali:/data/local/tmp $ du -h app.debug
  9.3M	app.debug

  134|bali:/data/local/tmp $ ./app.debug version                                                                                              
  Linux version 4.4.146+ (jenkins@jenkins-bali-wxg)  ... ... 
  bali:/data/local/tmp $ 


  1|bali:/data/local/tmp $ ./app.debug list /dev                                                                                              

   ===== Listing directory /etc =====
  wmtWifi                           "/dev/wmtWifi"
  stpgps                            "/dev/stpgps"
  fm                                "/dev/fm"
  stpbt                             "/dev/stpbt"
  stpwmt                            "/dev/stpwmt"
  wmtdetect                         "/dev/wmtdetect"
  radio                             "/dev/radio"
  ttyGS3                            "/dev/ttyGS3"
  ttyGS2                            "/dev/ttyGS2"
  ttyGS1                            "/dev/ttyGS1"
  ttyGS0                            "/dev/ttyGS0"
  mtp_usb                           "/dev/mtp_usb"
  usb_accessory                     "/dev/usb_accessory"
   ... ... ...  ... ... ...  ... ... ...  ... ... ... 
#+END_SRC

** Creating command line applications with CLI11 C++ Library
*** Overview 

Despite that GUI Graphical user interfaces applications are more used
nowadays than CLI command line applications, it still worth developing
CLI applications. Among other things, the benefits of CLI applications
over GUI can be summarized as: 

  + More precision
    + They are more precise than GUI for performing task. It is easier
      to guide someone by showing the command line steps rather than
      describing all buttons, menus, context menus that someone should
      click in order to accomplish some task. 

  + Scriptability
    + CLI applications are scriptable and they can be automated;
      called from other applications or scripts.

  + Reproducibility 
    + Unlike GUIs, CLI applications are reproducible and the sequence
      of steps for performing some task can be stored as text and
      later replayed by pasting the commands in a terminal or running
      them from a script. 

  + They can be combined
    + Unlike GUI, CLI applications can be combined with each other via
      stdout, stderr redirection. Example: CLI tools such as 'grep',
      'echo', 'ls', 'find', 'awk', 'sed' are often combined with each
      other in shell scripts for system configuration or automation.


  *Anotomy of CLI Applications* 

Simple command line application: 

#+BEGIN_SRC sh 
  $ ./<COMMAND> <P0> <P1> ... <PN> --flag0 --flag1 --switch0 value0 --switch1 value1 --switch value2 ... 

  # Or: 
  $ ./<COMMAND> <P0> <P1> ... <PN> \
       --flag0 --flag1 \
       --switch0 value0 --switch1 value1 --switch value2 ... 

  $ ./<COMMAND> <P0> <P1> ... <PN> --flag0 --flag1 \
       --switch0=value0 --switch1=value1 --switch=value2 ... 
#+END_SRC

Command line application with multiple subcommands: (i.e: git, docker)

#+BEGIN_SRC sh 
  $ ./<COMMAND> <SUBCOMMAND> <P0> <P1> ... <PN> \
       --flag0 --flag1 \
       --switch0 value0 --switch1 value1 --switch value2 ... 

  # OR: 
  $ ./<COMMAND> <SUBCOMMAND> <P0> <P1> ... <PN> \
       --flag0 --flag1 \
       --switch0=value0 --switch1=value1 --switch=value2 ... 
#+END_SRC

Where: 

   * <COMMAND>
     * Appplication or executable.

   * <SUBCOMMAND>
     * Metaphor: an action or verb performed on subjects (positional
       arguments).
     * Subcommand, similar to 'git checkout' or'docker run'. A
       subcommand or command represents an 

   * <P0>, <P1>, ..., <PN>
     + Metaphor: subjects 
     + Positional arguments (without '-' dash prefix) - they are
       essential (required) arguments for running an application. If
       they are not provided, an error happens.

   * -flag0 -flag1 ....
     * Metaphor: adjectives  
     * A flag is an optional command line switch which represents a
       boolean value. The usage of a flag sets the represented value
       as true and absence, sets the represented value as false.

   * --switch0=value0 --switch1=value1 ....
     * Metaphor: adjectives  
     * Switches are optional command line arguments associated to some
       program state. 

  *Example* - Breaking down command line parts:

#+BEGIN_SRC sh 
   $ docker run -i -t --rm --volume=$PWD:/cwd -w=/cwd xdxd/docker-binwalk bash     
#+END_SRC       
 
  * Command:
    + docker

  * Sub-command:
    + run

  * Positional arguments:
    + (xdxd/docker-binwalk) and (bash)

  * Flags:
    + (-i), (-t), (--rm)

  * Switches:
    + (--volume), (-w)

 
  *General recommendations* 

   * _DO ONLY ONE THING_ => The application should only do one thing. If
     it needs to perform more than one task, the best choice is to
     create a subcommand for every task.

   * _STATUS CODE_ => The status code allows scripts or any other
     application calling the current one to know whether the process
     execution was successful. 
     + => Return status code '0' (EXIT_SUCCESS) when the
       applications is terminated successfully
     + => Return any other value different than zero in case of failure. 

   * _DEFAULT VALUES_
     + Use reasonable default values for command line switches values
       and flags.
     + Show the default values of command line switches

   * _EXAMPLES_
     + Add commands that shows usage examples. 

   * _SIMPLE TASKS SHOULD BE SIMPLE_
     * Create subcommands for the most common use-cases for making
       simple tasks simple: make simple things simple and complex
       things possible (borrowed from Alan Kay).

   * _STDERR_ - for non essential information
     * Print non essential, logging or debug information to _stderr_,
       standard error output as it allows discarding separating the
       stdout (standard output) from stderr, redirecting stderr to
       file or discarding it by redirecting stderr to /dev/null.

   * _VERSION_ (--version)
     * Add switch for printing application version. 

   * _DRY-RUN_ (--dry-run)
     * Create a flag option (--dry-run) if the command performs any
       permanent non-reversible change, such as remove file. When the
       application receives the --dry-run option, the application only shows the
       non-reversible actions that would be executed, without actually
       performing them.

Subcommand for common tasks (Simple tasks should be simple): 

For instance, an alternative docker client could have a subcommand
'shell' for just running the shell as entrypoint. _$ dockw shell IMAGE_ could
be translated as the following docker command line. The subcommand
'shell' could assume that the current directory ($PWD) is mounted to
the directory /cwd in the docker image and this option could be
changed using the command line switch ~--workdir=<SOME_DIR>~.

#+BEGIN_SRC sh 
   # 'dockw shell MY_DOCKER_IMAGE ' subcommand from a hypothetical dockw tool 
   # is translated as: 
   $ docker run --rm -it -v $PWD:/cwd -w /cwd --entrypoint=sh MY_DOCKER_IMAGE 
#+END_SRC

*** Sample application with multiple sub-comamnds   

The following code contains a sample CLI application containing
multiple sub-commands:. 
 
GIST: 
  + https://gist.github.com/caiorss/1b6826b9722ba07667eefed2f82d667e 

CLI11 Library Documentation: 

  * [[https://cliutils.gitlab.io/CLI11Tutorial/][Introduction · CLI11 Tutorial]]

  * [[https://cliutils.gitlab.io/CLI11Tutorial/chapters/subcommands.html][Subcommands and the App · CLI11 Tutorial]]

  * [[https://indico.cern.ch/event/619465/contributions/2507949/attachments/1448567/2232649/20170424-diana-2.pdf][CLI11: Command line parsing made simple]] 

 *Files* 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.9)
   project(cliapp)

   #========== Global Configurations =============#
   #----------------------------------------------#

   set(CMAKE_CXX_STANDARD 17)     
   set(CMAKE_VERBOSE_MAKEFILE ON)
   set(CMAKE_CXX_EXTENSIONS OFF)

   # ------------ Download CPM CMake Script ----------------#

   ## Automatically donwload and use module CPM.cmake
   file(DOWNLOAD https://raw.githubusercontent.com/TheLartians/CPM.cmake/v0.26.2/cmake/CPM.cmake
                    "${CMAKE_BINARY_DIR}/CPM.cmake")
   include("${CMAKE_BINARY_DIR}/CPM.cmake")

   #----------- Add dependencies --------------------------#

   CPMAddPackage(
       NAME cli11
       URL  https://github.com/CLIUtils/CLI11/archive/v1.9.0.zip
       DOWNLOAD_ONLY YES
   )

   include_directories( ${cli11_SOURCE_DIR}/include )

   message([TRACE] " cli11_SOURCE_DIR =  ${cli11_SOURCE_DIR} ")

   #----------- Set targets -------------------------------#

   add_executable(cliapp cliapp.cpp)
   target_link_libraries(cliapp stdc++fs)

   install( TARGETS cliapp 
            RUNTIME DESTINATION bin)

#+END_SRC

File: cliapp.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 
   #include <vector> 
   #include <functional>
   #include <filesystem>
   #include <functional>

   #include <CLI/CLI.hpp>


   using namespace std::string_literals;
   namespace fs = std::filesystem;

   struct Command_list
   {
       std::string m_path = ".";
       bool m_filter_file = false;
       bool m_filter_dir  = false; 
       bool m_recursive   = false; 

       Command_list(CLI::App& app, std::string name)
       {
           this->install(app, name);
       }

       void install(CLI::App& app, std::string name)
       {
           CLI::App* cmd = app.add_subcommand(
               name, "List directory"
           );

           cmd->callback([this](){
               try {
                   this->list_directory();
                   // Status code  0 => OK finished successfuly 
                   return true; 
               } catch(std::exception const& ex) {
                   std::cout << " Error: " << ex.what() << '\n';
                   return false; 
               }
           });

           cmd->add_option("<PATH>",        m_path,        "Directory to be listed." )->required();
           cmd->add_flag("-f,--file",       m_filter_file, "Only list files");
           cmd->add_flag("-d,--directory",  m_filter_dir,  "Only list directories");
           cmd->add_flag("-r,--recursive",  m_recursive,   "List direcotyr in recursive way");
       }

   private:

       void list_directory()
       {
           if(m_filter_file && m_filter_dir)
               throw std::runtime_error("Error: --file and --dir flags cannot be simultaneously true.");

           using Predfun = std::function<bool (fs::path const&)>;
           auto predicate = Predfun{};

           auto iterate_dir = [&predicate](auto&& iterable){
               for(auto const& path :  iterable )
               {
                   if(predicate(path)) std::printf("  => %s\n", path.path().c_str()); 
               }
           };

           using ptr = bool (*) (fs::path const&);

           if(!m_filter_file && !m_filter_dir) 
               predicate = [](fs::path const& p){ return true; };

           if(m_filter_file) 
               predicate = (ptr) &fs::is_regular_file;

           if(m_filter_dir)
               predicate = (ptr) &fs::is_directory;

           if(!m_recursive)
               iterate_dir( fs::directory_iterator(m_path) );
           else 
               iterate_dir( fs::recursive_directory_iterator(m_path) );
       }   
   };

   class MiniWebServer
   {
       int         m_port = 8080; 
       std::string m_host = "0.0.0.0";
       std::string m_path = "."; 
       bool        m_auth = false; 
   public:
       // Set server TCP Port 
       void set_port(int port         ){ m_port = port; }
       // Hostnames that server will listen to 
       void set_host(std::string host ){ m_host = host; }
       // Set path containing server data 
       void set_path(std::string path ){ m_path = path; }
       void set_auth(bool flag        ){ m_auth = flag; }

       int  get_port(){ return m_port; }

       void run_server()
       {
           std::printf(" [INFO] Running web server => port = %d ; host = %s; path = %s \n"
               , m_port, m_host.c_str(), m_path.c_str());
           std::printf(" [INFO] Server has authentication => %s \n", m_auth ? "TRUE" : "FALSE" );
       }
   };


   template<typename T, typename Klass>
   auto bind_setter(Klass& cls, void (Klass::* setter) (T&&) )
   {
       return [&](T&& q){ 
           (cls.*setter)( std::forward(q) ); 
       };
   }

   template<typename T, typename Klass>
   auto bind_setter(std::shared_ptr<Klass> const& cls, void (Klass::* setter) (T) )
   {
       return [cls, setter](T q){ ((*cls).*setter)(q); };
   }

   void command_server( CLI::App&  app)
   {    

       CLI::App* cmd = app.add_subcommand(
           "server", "Run HTTP server for sharing files from some folder."
       );

       cmd->footer("Run local file sharing web server");

       // Created with shared_ptr in order to the object survive this scope
       // and avoid reference to destroyed object when it is referenced from callback. 
       auto server = std::make_shared<MiniWebServer>();

       cmd->callback([=]
       {
           std::cout << " [TRACE] ----- Callback invoked OK ------ \n";
           if(server->get_port() < 0 || server->get_port() > 65535)
           {
               std::cerr << " [ERROR] " << " Invalid TCP port range. " << '\n';
               // Returns non-zero status code
               return false;
           }
           server->run_server();
           return true;
       });

       cmd->add_option_function<std::string>(
             "<PATH>"
           , bind_setter<std::string>(server, &MiniWebServer::set_path)
           , "Directory to be shared in the web server."
       )->required();

       cmd->add_option_function<int>( 
           "-p,--port"
         , [=](auto q){ server->set_port(q); }
         , "Server TCP port, default: 8080"
       );

       cmd->add_option_function<std::string>( 
           "--host"
         , [=](auto q){ server->set_host(q); }
         , "Hostname that server will listen to (default: 0.0.0.0)"
       );

       cmd->add_flag( 
           "-a,--auth"
         // , [](auto q){ server->set_auth(q); }        
          , bind_setter<bool>(server, &MiniWebServer::set_auth)
          , "Shows the command line parameters passed to QEMU."
       );   
   }

   void command_version( CLI::App&  app, std::string name)
   {
       auto cmd = app.add_subcommand(name, "Show application version.");

       cmd->callback([=]{
           std::printf("cliapp version 0.1 - Your favorite U-NIX swiss army knife \n");

           // Return true for idnicating successful status code 
           return true; 
       });
   }

   int main(int argc, char** argv)
   {
       CLI::App app("cliapp");        
       app.footer("\n Command line demo toolbox.");

       command_version(app, "version");
       command_version(app, "v");
       Command_list cmd_list1(app, "ls");
       Command_list cmd_list2(app, "list");
       command_server(app); 

       // ----------- Parse Arguments ---------------//
       try
       {
           if(argc == 1){ 
               std::cout << app.help() << "\n";
               return 0;
            }
           app.require_subcommand();
           app.validate_positionals();
           app.parse(argc, argv);
       } catch(const CLI::ParseError &e)
       {

           return app.exit(e);
       } catch (std::exception& ex)
       {
           std::cout << ex.what() << std::endl;
           return EXIT_FAILURE;
       }

       return 0;
   }

#+END_SRC

 *Building on MacOSX* 

Install GCC 9.0 via *brew*. Note: Apple's default Clang compiler does
not have the C++17 file system library. 

#+BEGIN_SRC sh 
 $ brew install gcc@9
#+END_SRC

Get the code: 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/caiorss/1b6826b9722ba07667eefed2f82d667e src 
  $ cd src 
#+END_SRC

Override CMake default compiler: 

#+BEGIN_SRC sh 
   $ export CC=/usr/local/Cellar/gcc@9/9.3.0/bin/gcc-9
   $ export CXX=/usr/local/Cellar/gcc@9/9.3.0/bin/g++-9
#+END_SRC

Configuration step: 

#+BEGIN_SRC sh 
   $ cmake --config Release -H. -B_build
     ... .... ... ... .. ... ...
   -- Checking whether CXX compiler supports OSX deployment target flag - yes
   -- Check for working CXX compiler: /usr/local/Cellar/gcc@9/9.3.0/bin/g++-9
   -- Check for working CXX compiler: /usr/local/Cellar/gcc@9/9.3.0/bin/g++-9 - works
   -- Detecting CXX compiler ABI info
   -- Detecting CXX compiler ABI info - done
   -- Detecting CXX compile features
   -- Detecting CXX compile features - done
   -- CPM: adding package cli11@ ()

   [TRACE] cli11_SOURCE_DIR =  /Volumes/data/cliapp/_build/_deps/cli11-src 
   -- Configuring done
   -- Generating done
   -- Build files have been written to: /Volumes/data/cliapp/_build
#+END_SRC

Building step: 

#+BEGIN_SRC sh 
  $ cmake --build _build --target 
   ... ... ... ... ... ... ... ... 
   ... ... ... ... ... ... ... ... 
  [ 50%] Building CXX object CMakeFiles/cliapp.dir/cliapp.cpp.o
  /usr/local/Cellar/gcc@9/9.3.0/bin/g++-9   -I/Volumes/data/cliapp/_build/_deps/cli11-src/include  -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX10.15.sdk   -std=c++17 -o CMakeFiles/cliapp.dir/cliapp.cpp.o -c /Volumes/data/cliapp/cliapp.cpp
  [100%] Linking CXX executable cliapp
  /usr/local/Cellar/cmake/3.17.3/bin/cmake -E cmake_link_script CMakeFiles/cliapp.dir/link.txt --verbose=1
  /usr/local/Cellar/gcc@9/9.3.0/bin/g++-9   -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX10.15.sdk -Wl,-search_paths_first -Wl,-headerpad_max_install_names  CMakeFiles/cliapp.dir/cliapp.cpp.o  -o cliapp  -lstdc++fs 
  [100%] Built target cliapp
  /usr/local/Cellar/cmake/3.17.3/bin/cmake -E cmake_progress_start /Volumes/data/cliapp/_build/CMakeFiles 0
#+END_SRC

Check executable: 

#+BEGIN_SRC sh 
  $ file _build/cliapp
  _build/cliapp: Mach-O 64-bit executable x86_64
#+END_SRC

Show command line help: 

#+BEGIN_SRC sh 
  $ _build/cliapp 

  cliapp
  Usage: [OPTIONS] [SUBCOMMAND]

  Options:
    -h,--help                   Print this help message and exit

  Subcommands:
    version                     Show application version.
    ls                          List directory
    list                        List directory
    server                      Run HTTP server for sharing files from some folder.


   Command line demo toolbox.
#+END_SRC

Show help for 'server' subcommands: 

#+BEGIN_SRC sh 
  $ _build/cliapp server -h
  Run HTTP server for sharing files from some folder.
  Usage: _build/cliapp server [OPTIONS] <PATH>

  Positionals:
    <PATH> TEXT REQUIRED        Directory to be shared in the web server.

  Options:
    -h,--help                   Print this help message and exit
    -p,--port INT               Server TCP port, default: 8080
    --host TEXT                 Hostname that server will listen to (default: 0.0.0.0)
    -a,--auth                   Shows the command line parameters passed to QEMU.

  Run local file sharing web server
#+END_SRC

Show help for 'ls' subcommand: 

#+BEGIN_SRC sh 
  $ _build/cliapp ls -h
  List directory
  Usage: _build/cliapp ls [OPTIONS] <PATH>

  Positionals:
    <PATH> TEXT REQUIRED        Directory to be listed.

  Options:
    -h,--help                   Print this help message and exit
    -f,--file                   Only list files
    -d,--directory              Only list directories
    -r,--recursive              List direcotyr in recursive way


   Command line demo toolbox.
#+END_SRC

Run _server_ subcommand: 

#+BEGIN_SRC sh 
  $ _build/cliapp server /var/www 
   [TRACE] ----- Callback invoked OK ------ 
   [INFO] Running web server => port = 8080 ; host = 0.0.0.0; path = /var/www 
   [INFO] Server has authentication => FALSE 

  $ _build/cliapp server /var/www --port 9010 --host 127.0.0.1
   [TRACE] ----- Callback invoked OK ------ 
   [INFO] Running web server => port = 9010 ; host = 127.0.0.1; path = /var/www 
   [INFO] Server has authentication => FALSE 

  $ _build/cliapp server /var/www --port 9010 --host 127.0.0.1 --auth
   [TRACE] ----- Callback invoked OK ------ 
   [INFO] Running web server => port = 9010 ; host = 127.0.0.1; path = /var/www 
   [INFO] Server has authentication => TRUE 

  $ _build/cliapp server /var/www --port=9010 --host=127.0.0.1 --auth
   [TRACE] ----- Callback invoked OK ------ 
   [INFO] Running web server => port = 9010 ; host = 127.0.0.1; path = /var/www 
   [INFO] Server has authentication => TRUE 
#+END_SRC

Run _ls_ subcommand: 

#+BEGIN_SRC sh 
   $ _build/cliapp ls
   <PATH> is required
   Run with --help for more information.


   $ _build/cliapp ls /System/Applications
     => /System/Applications/Siri.app
     => /System/Applications/Music.app
     => /System/Applications/FindMy.app
     => /System/Applications/QuickTime Player.app
     => /System/Applications/Chess.app
     => /System/Applications/Photo Booth.app
     => /System/Applications/Books.app
   ... ... ... ... ... ... ... ... 
   ... ... ... ... ... ... ... ... ... 

   $ _build/cliapp ls /System/Applications/Utilities/Terminal.app --file --recursive
   ... ... ... ... ... ... ... ... 
   ... ... ... ... ... ... ... ... ... 

     => /System/Applications/Utilities/Terminal.app/Contents/Resources/ca.lproj/TTFindPanel.strings
     => /System/Applications/Utilities/Terminal.app/Contents/Info.plist
     => /System/Applications/Utilities/Terminal.app/Contents/PkgInfo
     => /System/Applications/Utilities/Terminal.app/Contents/version.plist


#+END_SRC
** Low level IO functions overview 

C-Library functions which encapsulates file-related systems calls.

Headers: 

#+BEGIN_SRC cpp 
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    #include <unistd.h>
#+END_SRC

  *Special File Descriptors* 

  + STDOUT_FILENO => File descritor for stdout (process standard output)
  + STDERR_FILENO => File descritor for stderr (process standard error output)
  + STDIN_FILENO => File descritor for stdin (process standard input)

  *Functions* 

  + close() => Close a file descriptor.
    + Doc: $ man 2 close 

#+BEGIN_SRC cpp 
  int close(int fd);
#+END_SRC

 + open() => Encapsulates open system call => Returns a file descritor
   number. When fails, it returns (-1) setting the global variable
   _errno_.
   + Doc: $ man 2 open 

#+BEGIN_SRC cpp 
   int open(const char *pathname, int flags);
#+END_SRC

  + creat() => Create file
    + Doc: $ man 2 creat 

#+BEGIN_SRC cpp 
   int creat(const char *pathname, mode_t mode)
#+END_SRC


  + read() => Read bytes from a file descriptor into a buffer, returning the
    number of bytes read. If there is an error, the functions returns
    (-1) setting the global variable _errno_.
    + Doc: $ man 2 read 

#+BEGIN_SRC cpp 
  ssize_t read(int fd, void *buf, size_t count);
#+END_SRC

  + write() => Write N bytes from a buffer to a file descriptor.
    + Doc: $ man 2 write 

#+BEGIN_SRC cpp 
  ssize_t write(int fd, const void *buf, size_t count);
#+END_SRC

** Low level IO - open(), read(), write() syscall functions

This code demonstrates the usage of the open(), read(), write(),
close() low-level IO library-calls for file descriptors which
encapsulates system-calls with the same name. 

GIST: 
 + https://gist.github.com/05fbba6475cca1dbdd50bbb2bd5ac8ae

File: unix-low-level-io.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>

   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>

   #include <cstring> // Import: char* strerror(in errnum);

   const char* 
   errno_to_cstring(int err)
   {
       // No such file or directory 
       if(err == ENOENT) return "ENOENT";
       // Operation not permitted 
       if(err == EPERM)  return "EPERM";
       // Onput/Output error 
       if(err == EIO)    return "EIO";

       if(err == EAGAIN) return "EAGAIN";
       if(err == EPERM)  return "EPERM";
       if(err == EPIPE)  return "EPIPE";

       return "<UNKNOWN>";
   }	


   /** Check whether file descriptor is regular file */
   bool fd_is_regular_file(int fd)
   {		
        struct stat fd_info; 
        // int fstat(int fd, struct stat *statbuf);
        int r = fstat(fd, &fd_info);
        return S_ISREG(fd_info.st_mode);
   }

   bool fd_is_directory(int fd)
   {
       struct stat fd_info; 
       // int fstat(int fd, struct stat *statbuf);
       int r = fstat(fd, &fd_info);
       return S_ISDIR(fd_info.st_mode);	
   }

   void print_errno_details(int err)
   {
       std::fprintf(stderr , "\n   =>    errno(int) = %d" 
                             "\n   =>    errno(str) = %s"
                             "\n   => errno message = %s \n"
                             , err, errno_to_cstring(err), strerror(err));
        std::fflush(stderr);
   }

   int main(int argc, char** argv)
   {
       std::puts(" [INFO] Program started. ");

       if(argc < 3){
               std::fprintf(stderr, " Usage:                             \n");
               std::fprintf(stderr, "  => To read a file:                \n");
               std::fprintf(stderr, "    $ %s file <FILE>                \n", argv[0]);
               std::fprintf(stderr, "  => To read stdin (console input): \n");
               std::fprintf(stderr, "    $ %s file -stdin                \n", argv[0]);
               return 0;
       }

       // Compare two c-strings return 0 (zero) when they are equal.
       // int strcmp(const char *s1, const char *s2)
       if( strcmp(argv[1], "file") != 0 )
       {
               std::fprintf(stderr, " [ERROR] Expected command file. \n");
               return EXIT_FAILURE;
       }

       // Variable for holding a file descriptor 
       int fd; 

       // The library-call open() attempts to open a file  and returns a "file-descriptor" 
       // (integer number ) when the operation is successful. The library-call 
       // returns (-1) when the operation fails. 
       // Note: It encapsulates the 'open' system call. 
       // 	
       if( strcmp(argv[2], "-stdin") == 0)
               fd = STDIN_FILENO; 
       else 
               fd = open(argv[2], O_RDONLY);

       if(fd == -1){
               // Get error flag 'errno' to get more details about current error.
               int err = errno;
               std::fprintf(stderr ," [ERROR] Failed to open file. ");
               print_errno_details(err);
               return EXIT_FAILURE;
       }

       std::fprintf(stdout, " [INFO] ?? File is regular file = %s \n"
                                 , fd_is_regular_file(fd) ? "TRUE" : "FALSE"  );
       std::fprintf(stdout, " [INFO] ?? File is directory file = %s \n"
                                 , fd_is_directory(fd) ? "TRUE" : "FALSE"  );				  
       // Flush file => Force changes to be immeditely written.
       std::fflush(stdout);

       // Buffer maximum size in bytes 
       constexpr size_t BUFFER_MAX_SIZE = 200; 	
       char buffer[BUFFER_MAX_SIZE];

       // Stream BUFFER_MAX_SIZE bytes from file descriptor 
       // to STDOUT_FILENO (file descriptor).
       //---------------------------------------------------
       ssize_t ret; 
       do {
               ret = read(fd, buffer, BUFFER_MAX_SIZE);		
               if(ret == -1) {
                       int err = errno; 
                       std::fprintf(stderr, " [ERROR] An error has happened => ");
                       print_errno_details(err);
                       close(fd);
                       return EXIT_FAILURE;
               }		
               ::write(STDOUT_FILENO, buffer, ret);
       } while( ret != 0);

       // Always close the file descriptor.
       close(fd);

       return 0;
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ unix-low-level-io.cpp -o unix-low-level-io.bin -std=c++1z -Wall -Wextra
#+END_SRC

Running:

  + Run 1

#+BEGIN_SRC sh 
 $ >> ./unix-low-level-io.bin 
 [INFO] Program started. 
 Usage:                             
  => To read a file:                
    $ ./unix-low-level-io.bin file <FILE>                
  => To read stdin (console input): 
    $ ./unix-low-level-io.bin file -stdin                
#+END_SRC

 + Run 2: 

#+BEGIN_SRC sh 
   $ >> ./unix-low-level-io.bin file /proc/filesystems 
   [INFO] Program started. 
   [INFO] ?? File is regular file = TRUE 
   [INFO] ?? File is directory file = FALSE 
  nodev	sysfs
  nodev	tmpfs
  nodev	bdev
  nodev	proc
  nodev	cgroup
  nodev	cgroup2
  ... ... ... 

  $ >> ./unix-low-level-io.bin file /etc/resolv.conf 
   [INFO] Program started. 
   [INFO] ?? File is regular file = TRUE 
   [INFO] ?? File is directory file = FALSE 
  # Generated by NetworkManager
  nameserver 194.165.12.10
#+END_SRC

 + Run 3: (Error)

#+BEGIN_SRC sh 
 $ >> ./unix-low-level-io.bin file /etc/resosad
 [INFO] Program started. 
 [ERROR] Failed to open file. 
   =>    errno(int) = 2
   =>    errno(str) = ENOENT
   => errno message = No such file or directory 

 $ >> ./unix-low-level-io.bin file /etc/shadow
 [INFO] Program started. 
 [ERROR] Failed to open file. 
   =>    errno(int) = 13
   =>    errno(str) = <UNKNOWN>
   => errno message = Permission denied 

 $ >> ./unix-low-level-io.bin file /
 [INFO] Program started. 
 [INFO] ?? File is regular file = FALSE 
 [INFO] ?? File is directory file = TRUE 
 [ERROR] An error has happened => 
   =>    errno(int) = 21
   =>    errno(str) = <UNKNOWN>
   => errno message = Is a directory 
#+END_SRC

 + Run 4 - read stdin file descriptor _STDIN_FILENO_

#+BEGIN_SRC 
   $ >> ./unix-low-level-io.bin file -stdin
   [INFO] Program started. 
   [INFO] ?? File is regular file = FALSE 
   [INFO] ?? File is directory file = FALSE 


  Hello world
  Hello world
   Unix-linux file descriptors - Low level IO
   Unix-linux file descriptors - Low level IO

  # User types Ctrl+D to close STDIN 
#+END_SRC

** Low level IO - creat() 

Creates a file using Unix-low level IO function creat() which
encapsulates the creat() system-call.

File: unix-creat.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 

   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   #include <cstring>

   void print_errno_details(int err);

   int main(int argc, char** argv)
   {
       // File is created with read, write permissions for owner 
       // ,groups and others
       mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;

       int fd = creat("/tmp/my-sample-file.txt", mode);
       if(fd  == -1){
           print_errno_details(errno);
           return EXIT_FAILURE;
       }

       constexpr size_t BUFFER_SIZE = 500;
       char buffer[BUFFER_SIZE];

       // Fill the whole buffer with '\0' null char characters
       memset(buffer, '\0', BUFFER_SIZE);

       // strcpy => Copy string literal to buffer. 
       strcpy(buffer, " [LINE 0] Write this message to buffer\n");
       fprintf(stdout, " Buffer size (non blank chars) = %zu \n", strlen(buffer));
       // Write strlen(buffer) bytes to file descriptor 
       write(fd, buffer, strlen(buffer));

       strcpy(buffer, " [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX\n");
       fprintf(stdout, " Buffer size (non blank chars) = %zu \n", strlen(buffer));
       fprintf(stdout, " Buffer content = '%s' \n", buffer);
       // Write strlen(buffer) bytes to file descriptor 
       write(fd, buffer, strlen(buffer));

       strcpy(buffer, " [LINE 2] FreeRTOS Linux RTAI Real-time RTMES QNX\n");
       write(fd, buffer, strlen(buffer));

       close(fd);
       return EXIT_SUCCESS;
   }

   // Ruires: #include <string>
   void print_errno_details(int err)
   {
           std::fprintf(stderr , "\n   =>    errno(int) = %d" 
                                 "\n   => errno message = %s \n"
                               , err, strerror(err));
           std::fflush(stderr);
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ unix-creat.cpp -o unix-creat.bin -std=c++1z -Wall -Wextra -g 
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ >> ./unix-creat.bin 
  Buffer size (non blank chars) = 39 
  Buffer size (non blank chars) = 44 
  Buffer content = ' [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX
 '
#+END_SRC

Content of generated file: 

#+BEGIN_SRC sh 
  $ >> cat /tmp/my-sample-file.txt 
  [LINE 0] Write this message to buffer
  [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX
  [LINE 2] FreeRTOS Linux RTAI Real-time RTMES QNX
#+END_SRC

Trace library-calls with _ltrace_ application: 
 
  +  $ ltrace ./unix-creat.bin

#+BEGIN_SRC sh 
  $ >> ltrace ./unix-creat.bin

  _ZNSt8ios_base4InitC1Ev(0x4040a9, 0xffff, 0x7ffcfe326598, 224) = 0
  __cxa_atexit(0x4010e0, 0x4040a9, 0x402008, 6)                  = 0
  creat(0x402010, 420, 0x7ffcfe326598, 256)                      = 3
  memset(0x7ffcfe326280, '\0', 500)                              = 0x7ffcfe326280
  strlen(" [LINE 0] Write this message to "...)                  = 39
  fprintf(0x7f95f2612500, " Buffer size (non blank chars) ="..., 39 Buffer size (non blank chars) = 39 
  ) = 37
  strlen(" [LINE 0] Write this message to "...)                  = 39
  write(3, " [LINE 0] Write this message to "..., 39)            = 39
  strlen(" [LINE 1] Unix, BSD, OSX, LINUX,"...)                  = 44
  fprintf(0x7f95f2612500, " Buffer size (non blank chars) ="..., 44 Buffer size (non blank chars) = 44 
  ) = 37
  fprintf(0x7f95f2612500, " Buffer content = '%s' \n", " [LINE 1] Unix, BSD, OSX, LINUX,"... Buffer content = ' [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX
  ' 
  ) = 66
  strlen(" [LINE 1] Unix, BSD, OSX, LINUX,"...)                  = 44
  write(3, " [LINE 1] Unix, BSD, OSX, LINUX,"..., 44)            = 44
  strlen(" [LINE 2] FreeRTOS Linux RTAI Re"...)                  = 50
  write(3, " [LINE 2] FreeRTOS Linux RTAI Re"..., 50)            = 50
  close(3)                                                       = 0
  _ZNSt8ios_base4InitD1Ev(0x4040a9, 0, 0x4010e0, 1)              = 0x7f95f2965e40
  +++ exited (status 0) +++

#+END_SRC

Trace system-calls with _strace_ application: 

  +  $ strace ./unix-creat.bin

#+BEGIN_SRC sh 
  $ strace ./unix-creat.bin 

  execve("./unix-creat.bin", ["./unix-creat.bin"], 0x7fff489b8e40 /* 83 vars */) = 0
  brk(NULL)                               = 0x57c000
  arch_prctl(0x3001 /* ARCH_??? */, 0x7fff751bd910) = -1 EINVAL (Invalid argument)
  access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
   ... ... ... ... ... ... ... ... ... ... ... ... ... ...
   ... ... ... ... ... ... ... ... ... ... ... ... ... ...

  mprotect(0x7fed4e032000, 4096, PROT_READ) = 0
  munmap(0x7fed4dfe4000, 136250)          = 0
  brk(NULL)                               = 0x57c000
  brk(0x59d000)                           = 0x59d000
  creat("/tmp/my-sample-file.txt", 0644)  = 3
  fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0xc), ...}) = 0
  write(1, " Buffer size (non blank chars) ="..., 37) = 37
  write(3, " [LINE 0] Write this message to "..., 39) = 39
  write(1, " Buffer size (non blank chars) ="..., 37) = 37
  write(1, " Buffer content = ' [LINE 1] Uni"..., 63) = 63
  write(1, "' \n", 3)                     = 3
  write(3, " [LINE 1] Unix, BSD, OSX, LINUX,"..., 44) = 44
  write(3, " [LINE 2] FreeRTOS Linux RTAI Re"..., 50) = 50
  close(3)                                = 0
  exit_group(0)                           = ?
  +++ exited with 0 +++
#+END_SRC
** Process Inputs, Outputs and States and PROCFS on Linux 

Any process may have the following inputs, outputs and states: 

 *Some Processes States:*

  + _Native executable_ used for creating the process. Every
    process has a native executable. A python process is the Python
    interpreter (python.exe on Windows) running python scripts. A Java
    process is the Java virtual machine (java.exe) running java
    *.class bytecodes or *.jar java packages.

  + _CWD_ => Current Working Directory
    + There is a single current working directory for every
      process. On Unix, the functions [[https://pubs.opengroup.org/onlinepubs/9699919799/functions/getcwd.html][getcwd()]] and [[http://man7.org/linux/man-pages/man2/chdir.2.html][chdir()]] gets and
      sets the current working directory.

  + _IP_ => Instruction Pointer (process context) => CPU registry that
    stores the current machine instruction to be run. 

  + _SP_ => Stack Poitner (process context) => CPU registry used for
    keeping track of the process call stack.

  + Note: all thoses states can be viewed and manipulated with a
    debugger, such as GDB, LLDB or Windows Debugger. A debugger can
    monitor, explore and manipulate the virtual memory of any process.  

 *Inputs:*

  + _Stdin_ (Standard Input) => User input read from console in some
    shell (cmd.exe on Windows) or bash, zsh on Unix-like OSes. 

  + Command line argument passed to main function

  + Environment variables set during the process instantiation with env
    or export commands on Unix-like operating systems.

  + Configuration files => read at a default fixed location such as
    ~/.bashrc (bash configuration file at ~/home/user/.bashrc/~ on Linux
    ); ~/.vimrc (vim configuration file)

  + Windows Registry entry for configuration during process
    initialization 

  + Input files read after initialization.

 *Outputs:*

  + _Stdout_ (Standard Output) => Process output print by functions such
    as printf; std::cout << ... visible in a terminal. (Unix heritage)

  + _Stderr_ (Standard Error Ouput) => Process error or logging output
    print by default in a terminal. stderr exists for allowing
    separating the output (stdout) from the error or logging output (stderr).

  + Statuds code => Value returned by function _int main(int argc, char** argv)_
    + Value 0 indicates success and that the process terminated
      successfuly.
    + Value different than zero indicates that the process terminated
      with errors.

  + Output file(s)

 *Both Input/Output:*

   + Sockets

   + IPC Inter Process Communication 

   + GUI - Graphical User Interface


#+BEGIN_SRC text 
             Command line arguments            
             int arc, char** argv (input)                  Configuration file: 
               >>-------+                         +--<<--  Input file read at fixed location
                         \                       /         Or Windows Registry entry 
                          \                      |
                          |                      |    
                          \/                    \ /   
                         +---------------------------------+
                         |   Process:                      |      
                         |                                 +--------->> Stdout (output)
             ---------->>|     EXE = /bin/some/executable  |            
           Stdin (input) |     PID = 9381 (Unique ID)      +--------->> Stderr (output)
                         |     CWD = /home/user/some/data  |       
                         |                                 |
                         |     IP - Instruction Pointer    +--------->>> Process status code: (output)
             ---------->>|     SP - Stack pointer          |    
    Environment          +-----------------------+--------+    int main(int argc, char** argv)
    Variables (input)                            |              {
                                                 |                  .... ... ...
    export PATH=$PATH:/opt/bin/program/bin       |                  int status_code = 0 
    export APP_LOG_LEVEL=INFO                    |                  return status_code;
                                                \ /              }
                                          Output File 
#+END_SRC

 *Example: View Process Information on Linux* 

All mentioned process internal states can be viewed with a debugger
such as GDB (GNU Debugger). On Linux, they can also be accessed with
the */proc* pseudo-file system created by the Linux kernel which exposes
many processes informations. 

Example: View information about the process which the PID is *19529* 

 + Start a Kotlin REPL process and get a PID: 

#+BEGIN_SRC java 
   $ kotlinc-jvm
   Welcome to Kotlin version 1.3.50 (JRE 1.8.0_162-b12)
   Type :help for help, :quit for quit
   >>> 
   >>> java.lang.management.ManagementFactory.getRuntimeMXBean().getName()
   res1: kotlin.String! = 23127@localhost.localdomain
   >>> 
#+END_SRC

 + Proc-File system for PID _23127_ 

#+BEGIN_SRC sh 
  $ ls /proc/23127
  attr/       cmdline          loginuid       personality   statm
  fd/         comm             maps           projid_map    status
  fdinfo/     coredump_filter  mem            root@         syscall
  map_files/  cpuset           mountinfo      sched         timers
  net/        cwd@             mounts         schedstat     timerslack_ns
  ns/         environ          mountstats     sessionid     uid_map
  task/       exe@             numa_maps      setgroups     wchan
  autogroup   gid_map          oom_adj        smaps
  auxv        io               oom_score      smaps_rollup
  cgroup      latency          oom_score_adj  stack
  clear_refs  limits           pagemap        stat
#+END_SRC

 + Get process executable: 
   + File: _/proc/<PID>/exe_ is a symbolic link to the process' native executable. 

#+BEGIN_SRC sh 
  $ readlink /proc/23127/exe 
  /home/archbox/opt/java/bin/java
#+END_SRC

 + Get process current directory:
   + File: _/proc/<PID>/cwd_ is a symbolic link to process' current directory.

#+BEGIN_SRC sh 
   $ readlink /proc/23127/cwd
   /home/archbox/projects/appdroid/build
#+END_SRC

 + Get command line arguments used to start the process.
   + File: _/proc/<PID>/cmdline_ contains the command line arguments
     used to start the process, passed to main(int argc, char** argv). 

#+BEGIN_SRC sh 
   $ cat /proc/23127/cmdline | strings -1

   /home/archbox/opt/java/bin/java
   -Xmx256M
   -Xms32M
   -noverify
   -cp
   /home/archbox/.sdkman/candidates/kotlin/1.3.50/lib/kotlin-preloader.jar
   org.jetbrains.kotlin.preloading.Preloader
   -cp
   /home/archbox/.sdkman/candidates/kotlin/1.3.50/lib/kotlin-compiler.jar
   org.jetbrains.kotlin.cli.jvm.K2JVMCompiler
#+END_SRC

 + Get process environment variables.
   + File: _/proc/<PID>/environ_ contains process' environment
     variables. 

#+BEGIN_SRC sh 
  $ cat /proc/23127/environ | strings -1

  QTINC=/usr/lib64/qt-3.3/include
  LC_ALL=en_US.UTF-8
  ...    ...    ...    ...    ... 
  ...    ...    ...    ...    ... 
  USERNAME=archbox
  JAVA_HOME=/home/archbox/opt/java
  KDEDIRS=/usr
  KOTLIN_HOME=/home/archbox/.sdkman/candidates/kotlin/1.3.50
  XDG_VTNR=2
  SSH_AUTH_SOCK=/tmp/ssh-7z2L0gyqQeeP/agent.3961
  ROOTSYS=/home/archbox/opt/root
  XDG_SESSION_ID=2
  MODULES_CMD=/usr/share/Modules/libexec/modulecmd.tcl
  ENV=/usr/share/Modules/init/profile.sh
  DESKTOP_SESSION=lxqt
  IMSETTINGS_MODULE=none
  PWD=/home/archbox/projects/appdroid/build
#+END_SRC

 + List all process' file descriptors. 

#+BEGIN_SRC sh 
   $ ls /proc/23127/fd
   0@  10@  12@  14@  16@  18@  2@   21@  24@  28@  3@   31@  4@  6@  8@
   1@  11@  13@  15@  17@  19@  20@  22@  27@  29@  30@  33@  5@  7@  9@

   $ ls -l /proc/23127/fd
   total 0
   lrwx------ 1 archbox archbox 64 Nov  4 12:11 0 -> /dev/pts/4
   lrwx------ 1 archbox archbox 64 Nov  4 12:11 1 -> /dev/pts/4
   lr-x------ 1 archbox archbox 64 Nov  4 12:11 10 -> /home/archbox/.sdkman/candidates/kotlin/1.3.50/lib/kotlin-script-runtime.jar
   lr-x------ 1 archbox archbox 64 Nov  4 12:11 11 -> /home/archbox/.sdkman/candidates/kotlin/1.3.50/lib/trove4j.jar
   lr-x------ 1 archbox archbox 64 Nov  4 12:11 12 -> /home/archbox/opt/java/jre/lib/jsse.jar
   lr-x------ 1 archbox archbox 64 Nov  4 12:11 13 -> /dev/random
   lr-x------ 1 archbox archbox 64 Nov  4 12:11 14 -> /dev/urandom
   ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 
   ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 
   lr-x------ 1 archbox archbox 64 Nov  4 12:11 8 -> /home/archbox/.sdkman/candidates/kotlin/1.3.50/lib/kotlin-stdlib.jar
   lr-x------ 1 archbox archbox 64 Nov  4 12:11 9 -> /home/archbox/.sdkman/candidates/kotlin/1.3.50/lib/kotlin-reflect.jar
#+END_SRC

  + List shared libraries loaded by process: [[https://stackoverflow.com/questions/5103443/how-to-check-what-shared-libraries-are-loaded-at-run-time-for-a-given-process][(Reference 5103443)]]

#+BEGIN_SRC sh 
   $ cat /proc/23127/maps | awk '{print $6}' | grep '\.so' | sort | uniq

   /home/archbox/opt/java/jre/lib/amd64/libjava.so
   /home/archbox/opt/java/jre/lib/amd64/libmanagement.so
   ...    ...    ...    ...    ...    ... 
   ...    ...    ...    ...    ...    ... 
   /usr/lib64/libc-2.27.so
   /usr/lib64/libdl-2.27.so
   /usr/lib64/libm-2.27.so
   /usr/lib64/libnss_files-2.27.so
   /usr/lib64/libpthread-2.27.so
   /usr/lib64/librt-2.27.so
   /usr/lib64/libutil-2.27.so
#+END_SRC

See also: 

   + [[http://man7.org/linux/man-pages/man5/proc.5.html][proc(5) - Linux manual page]] 

   + [[https://www.tecmint.com/exploring-proc-file-system-in-linux/][Exploring /proc File System in Linux]]

   + [[https://www.geeksforgeeks.org/proc-file-system-linux/][proc file system in Linux - GeeksforGeeks]]

** Information about file permissions, owner and group - fstat and stat syscalls 
*** Overview 

The following family of common UNIX functions allows obtaining
information about file permissions, owner, group and stick bits,
namely, set-uid and set-gid special bits. 

#+BEGIN_SRC cpp 
 #include <sys/stat.h>

 // Obtain permission and file information from file path 
 int stat(const char * path, struct stat* sb);

 // Obtain permission and file information from file path 
 int lstat(const char* path, struct stat* sb);

 // Obtain permission and file information from file-descriptor 
 int fstat(int fd, struct stat *sb);

 int fstatat(int fd, const char* path, struct stat *sb, int flag);
#+END_SRC

Fstat manpage: 

#+BEGIN_SRC cpp 
     struct stat {
         dev_t     st_dev;         /* ID of device containing file */
         ino_t     st_ino;         /* Inode number */
         mode_t    st_mode;        /* File type and mode */
         nlink_t   st_nlink;       /* Number of hard links */
         uid_t     st_uid;         /* User ID of owner */
         gid_t     st_gid;         /* Group ID of owner */
         dev_t     st_rdev;        /* Device ID (if special file) */
         off_t     st_size;        /* Total size, in bytes */
         blksize_t st_blksize;     /* Block size for filesystem I/O */
         blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

         /* Since Linux 2.6, the kernel supports nanosecond
            precision for the following timestamp fields.
            For the details before Linux 2.6, see NOTES. */

         struct timespec st_atim;  /* Time of last access */
         struct timespec st_mtim;  /* Time of last modification */
         struct timespec st_ctim;  /* Time of last status change */

     #define st_atime st_atim.tv_sec      /* Backward compatibility */
     #define st_mtime st_mtim.tv_sec
     #define st_ctime st_ctim.tv_sec
     };
#+END_SRC

See also: 

  + [[https://www.liquidweb.com/kb/how-do-i-set-up-setuid-setgid-and-sticky-bits-on-linux/][How Do I Set Up Setuid, Setgid, and Sticky Bits on Linux? | Liquid Web]]

Documentation: 

  + [[https://linux.die.net/man/2/fstat][Linux Manpage - fstat]]

  + [[https://www.freebsd.org/cgi/man.cgi?query=stat&sektion=2][FreeBSD sytem calls - stat, lstat, fstat - Get file status]]

  + [[https://man7.org/linux/man-pages/man3/getgrgid.3p.html][Linux Manpage - getgrgid()]] - Query /etc/group database 

  + [[https://www.freebsd.org/cgi/man.cgi?query=getgrgid][FreeBSD - getgrid()]] - Query /etc/group database.

  + [[https://pubs.opengroup.org/onlinepubs/009695399/functions/getpwuid.html][OpenGroup - Unix Specification  - getpwuid()]] 
*** Sample code 

 *File:* file-info.cpp 

#+BEGIN_SRC cpp 
  #include <iostream> 
  #include <string> 
  #include <functional>
  #include <cstring> 

  // -- Unix-specific Headers -------//
  #include <fcntl.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <unistd.h>

  #include <pwd.h>
  #include <grp.h>


  std::string 
  get_descriptor_type(struct stat const& fs)
  {
      int ftype = fs.st_mode & S_IFMT;
      if(ftype == S_IFDIR)  return "Directory";
      if(ftype == S_IFREG)  return "Regular file";
      if(ftype == S_IFLNK)  return "Symbolic link";
      if(ftype == S_IFBLK)  return "Block device file";
      if(ftype == S_IFCHR)  return "Character device file";    
      if(ftype == S_IFIFO)  return "FIFO or pipe"; 
      if(ftype == S_IFSOCK) return "Socket";
      return "Unknown";    
  }; 

  int main(int argc, char** argv)
  {
      if(argc != 2) {
          std::printf(" Usage: %s <FILE> \n", argv[0]);
          return 0;
      }

      struct stat fs; 
      struct passwd* fs_user = nullptr; 
      struct group*  fs_group = nullptr;


      //int fd = open(argv[1], O_RDONLY);
    
      if( ::stat(argv[1], &fs ) == -1) {
          std::fprintf(stderr, "Error: unable to open file => error = %s \n", strerror(errno) );
          return -1;
      }

      if( ( fs_user = ::getpwuid(fs.st_uid)) == nullptr )
      {
          std::fprintf(stderr, " Error: unable to get owner information \n");
          return -1;
      }

      if( ( fs_group = ::getgrgid(fs.st_gid)) == nullptr )
      {
          std::fprintf(stderr, " Error: unable to get group information \n");
          return -1;
      }


      // Print boolean as 'true' or 'false'
      std::cout << std::boolalpha;
      std::cout << "  [*]  File size in bytes: " << fs.st_size << '\n';
      std::cout << "  [*]  File size in Kilo bytes: " << static_cast<double>(fs.st_size) / 1024 << '\n';
      std::cout << "  [*]  File size in Mega bytes: " << static_cast<double>(fs.st_size) / (1024 * 1024) << '\n';
      std::cout << "  [*]           File type: " << get_descriptor_type(fs) << '\n';

      std::cout << "\n TEST FILE TYPE \n";
      std::cout << "  [*] ?      Is regular file =>> " << static_cast<bool>( S_ISREG(fs.st_mode) ) << '\n';
      std::cout << "  [*] ?         Is directory =>> " << static_cast<bool>( S_ISDIR(fs.st_mode) ) << '\n';
      std::cout << "  [*] ?     Is symbolic link =>> " << static_cast<bool>( S_ISLNK(fs.st_mode) ) << '\n';
      std::cout << "  [*] ?     Is block device  =>> " << static_cast<bool>( S_ISBLK(fs.st_mode) ) << '\n';
      std::cout << "  [*] ? Is character device  =>> " << static_cast<bool>( S_ISCHR(fs.st_mode) ) << '\n';

      std::cout << "\n ACCESS TIME \n";
      std::cout << "  [*] Time =>   last change: " << ctime(&fs.st_ctime);
      std::cout << "  [*] Time =>   last access: " << ctime(&fs.st_atime);
      std::cout << "  [*] Time => last modified: " << ctime(&fs.st_mtime);

      std::cout <<  "\n OWNER and GROUP \n";
      std::cout << "  [*] Owner: uid = " << fs.st_uid << " ;  user = " << fs_user->pw_name  << '\n';
      std::cout << "  [*] Group: gid = " << fs.st_gid << " ; group = " << fs_group->gr_name  << '\n';

      std::cout << "\n FILE PERMISSIONS \n";
      std::cout << "  =>>  Stick Bits: " << (fs.st_mode & S_ISUID ? "suid" : "-") 
                << "  "                  << (fs.st_mode & S_ISGID ? "sgid" : "-")
                << '\n';
      std::cout << "  =>>  Owner: " << (fs.st_mode & S_IRUSR  ? "r" : "-")   // File is readable   (can be read)
                << " "         << (fs.st_mode & S_IWUSR  ? "w" : "-")        // File is writeable  (can be written)
                << " "         << (fs.st_mode & S_IXUSR  ? "x" : "-")        // File is executable (can be executed - execv syscall)
                << '\n';
      std::cout << "  =>>  Group: " << (fs.st_mode & S_IRGRP  ? "r" : "-")  
                << " "            << (fs.st_mode & S_IWGRP  ? "w" : "-")  
                << " "            << (fs.st_mode & S_IXGRP  ? "x" : "-")
                << '\n';
      std::cout << "  =>> Others: " << (fs.st_mode & S_IROTH  ? "r" : "-")  
                << " "             << (fs.st_mode & S_IWOTH  ? "w" : "-")  
                << " "             << (fs.st_mode & S_IXOTH  ? "x" : "-")
                << '\n';    
      std::cout << " \n- Note: (r - read) ; (w - write); (x - execute) ; (suid - set-UID bit set) ; (sgid - set-GID bit set) \n";

      return 0;
  }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  # Build using GNU GCC (G++) compiler 
  $ g++ file-info.cpp -o file-info -std=c++1z -g -Wall -Wextra

  # Build using LLVM/Clang compiler 
  $ clang++ file-info.cpp -o file-info -std=c++1z -g -Wall -Wextra
#+END_SRC

Running:

  + Inspect directory /etc  

#+BEGIN_SRC sh 
  $ ./file-info /etc
    [*]  File size in bytes: 12288
    [*]  File size in Kilo bytes: 12
    [*]  File size in Mega bytes: 0.0117188
    [*]           File type: Directory

   TEST FILE TYPE 
    [*] ?      Is regular file =>> false
    [*] ?         Is directory =>> true
    [*] ?     Is symbolic link =>> false
    [*] ?     Is block device  =>> false
    [*] ? Is character device  =>> false

   ACCESS TIME 
    [*] Time =>   last change: Sun Aug  2 05:19:31 2020
    [*] Time =>   last access: Wed Aug  5 04:50:20 2020
    [*] Time => last modified: Sun Aug  2 05:19:31 2020

   OWNER and GROUP 
    [*] Owner: uid = 0 ;  user = root
    [*] Group: gid = 0 ; group = root

   FILE PERMISSIONS 
    =>>  Stick Bits: -  -
    =>>  Owner: r w x
    =>>  Group: r - x
    =>> Others: r - x

  - Note: (r - read) ; (w - write); (x - execute) ; (suid - set-UID bit set) ; (sgid - set-GID bit set) 
#+END_SRC

 + Inspect executable file: /bin/sudo 

#+BEGIN_SRC sh 
  $ ./file-info /bin/sudo
    [*]  File size in bytes: 182456
    [*]  File size in Kilo bytes: 178.18
    [*]  File size in Mega bytes: 0.174004
    [*]           File type: Regular file

   TEST FILE TYPE 
    [*] ?      Is regular file =>> true
    [*] ?         Is directory =>> false
    [*] ?     Is symbolic link =>> false
    [*] ?     Is block device  =>> false
    [*] ? Is character device  =>> false

   ACCESS TIME 
    [*] Time =>   last change: Tue May 12 01:52:08 2020
    [*] Time =>   last access: Sun Aug  2 05:20:57 2020
    [*] Time => last modified: Fri Mar 27 05:50:36 2020

   OWNER and GROUP 
    [*] Owner: uid = 0 ;  user = root
    [*] Group: gid = 0 ; group = root

   FILE PERMISSIONS 
    =>>  Stick Bits: suid  -
    =>>  Owner: - - x
    =>>  Group: - - x
    =>> Others: - - x

  - Note: (r - read) ; (w - write); (x - execute) ; (suid - set-UID bit set) ; (sgid - set-GID bit set) 
#+END_SRC

 + Inspect regular file: ~/bin/fserver.jsh

#+BEGIN_SRC sh 
   $ ./file-info ~/bin/fserver.jsh 
     [*]  File size in bytes: 9968346
     [*]  File size in Kilo bytes: 9734.71
     [*]  File size in Mega bytes: 9.50656
     [*]           File type: Regular file

    TEST FILE TYPE 
     [*] ?      Is regular file =>> true
     [*] ?         Is directory =>> false
     [*] ?     Is symbolic link =>> false
     [*] ?     Is block device  =>> false
     [*] ? Is character device  =>> false

    ACCESS TIME 
     [*] Time =>   last change: Tue May 12 12:35:32 2020
     [*] Time =>   last access: Tue Aug  4 03:21:06 2020
     [*] Time => last modified: Mon May 11 22:52:14 2020

    OWNER and GROUP 
     [*] Owner: uid = 1000 ;  user = myuser 
     [*] Group: gid = 1000 ; group = myuser 

    FILE PERMISSIONS 
     =>>  Stick Bits: -  -
     =>>  Owner: r w x
     =>>  Group: r w -
     =>> Others: r - -

   - Note: (r - read) ; (w - write); (x - execute) ; (suid - set-UID bit set) ; (sgid - set-GID bit set) 
#+END_SRC

 + Inspect block _device file_ /dev/sda that represets the main disk
   partition. 

#+BEGIN_SRC sh 
  $ ./file-info /dev/sda
    [*]  File size in bytes: 0
    [*]  File size in Kilo bytes: 0
    [*]  File size in Mega bytes: 0
    [*]           File type: Block device file

   TEST FILE TYPE 
    [*] ?      Is regular file =>> false
    [*] ?         Is directory =>> false
    [*] ?     Is symbolic link =>> false
    [*] ?     Is block device  =>> true
    [*] ? Is character device  =>> false

   ACCESS TIME 
    [*] Time =>   last change: Wed Jul  8 13:48:48 2020
    [*] Time =>   last access: Wed Jul  8 13:49:09 2020
    [*] Time => last modified: Wed Jul  8 13:48:48 2020

   OWNER and GROUP 
    [*] Owner: uid = 0 ;  user = root
    [*] Group: gid = 6 ; group = disk

   FILE PERMISSIONS 
    =>>  Stick Bits: -  -
    =>>  Owner: r w -
    =>>  Group: r w -
    =>> Others: - - -

  - Note: (r - read) ; (w - write); (x - execute) ; (suid - set-UID bit set) ; (sgid - set-GID bit set) 

#+END_SRC

 + Inspect character _device file_  /dev/mem that represents the
   physical memory (RAM memory). 

#+BEGIN_SRC sh 
   $ ./file-info /dev/mem
     [*]  File size in bytes: 0
     [*]  File size in Kilo bytes: 0
     [*]  File size in Mega bytes: 0
     [*]           File type: Character device file

    TEST FILE TYPE 
     [*] ?      Is regular file =>> false
     [*] ?         Is directory =>> false
     [*] ?     Is symbolic link =>> false
     [*] ?     Is block device  =>> false
     [*] ? Is character device  =>> true

    ACCESS TIME 
     [*] Time =>   last change: Wed Jul  8 13:48:49 2020
     [*] Time =>   last access: Wed Jul  8 13:48:49 2020
     [*] Time => last modified: Wed Jul  8 13:48:49 2020

    OWNER and GROUP 
     [*] Owner: uid = 0 ;  user = root
     [*] Group: gid = 9 ; group = kmem

    FILE PERMISSIONS 
     =>>  Stick Bits: -  -
     =>>  Owner: r w -
     =>>  Group: r - -
     =>> Others: - - -

   - Note: (r - read) ; (w - write); (x - execute) ; (suid - set-UID bit set) ; (sgid - set-GID bit set) 
#+END_SRC
** Information about current process 

File: current-process.cpp 

#+BEGIN_SRC cpp 
   #include <iostream> 
   #include <string> 
   #include <cstring> 

   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   #include <limits.h> // PATH_MAX constant (macro)

   auto get_cwd() -> std::string;
   auto set_cwd(const std::string& path) -> void;
   auto read_symlink(std::string const& path) -> std::string;

   int main(int argc, char** argv)
   {
       // Unique process ID (identifier) number 
       fprintf(stdout, "   => Process PID = %d \n", ::getpid());

       // PID for parent process
       fprintf(stdout, "   => Process PID = %d \n", ::getppid());

       // Current directory 
       fprintf(stdout, "   => Current directory = %s \n", get_cwd().c_str());

       fprintf(stdout, "\n Change the curren directory to /etc \n");
       set_cwd("/etc");
       fprintf(stdout, "   => Current directory = %s \n", get_cwd().c_str());

       // Note: It only works on Linux. The directory /proc/self is a pseudo-directory 
       //       whith pseudo-files containing information about the current process. 
       // 
       // the file /proc/self/exe is a symbolic link to the current executable.
       std::string exe_file = read_symlink("/proc/self/exe");
       fprintf(stdout, "  => Absolute Path of current executable = %s \n", exe_file.c_str());

       // Current directory 
       std::string exe_dir = read_symlink("/proc/self/cwd");
       fprintf(stdout, "  => Current directory of this executable = %s \n", exe_dir.c_str());

       fprintf(stdout, " [INFO] Finish Ok. \n");
       return 0;
   }

   // ----------- Functions Implementations ------------// 
   // 

   /** Get current working directory of current process */
   auto get_cwd() -> std::string 
   {
       char* buffer = ::getcwd(nullptr, 0);
       auto cwd = std::string(buffer);
       // Note buffer was allocated with malloc 
       free(buffer);
       return cwd;
   }

   /** Set current working directory for current process. */
   auto set_cwd(const std::string& path) -> void 
   {
        int status = ::chdir(path.c_str());
        if(status < 0)
            throw std::runtime_error("Failed to change directory.");
   }

   /** Read value of symbolic link 
    *  
    * Requires: <limits.h>, <sys/types.h>, <sys/stats.h>
    */
   auto read_symlink(std::string const& path) -> std::string 
   {
       // Create a buffer with size PATH_MAX + 1 filled with 0 ('\0'), null characters
       std::string buffer(PATH_MAX, 0);
       // ssize_t readlink(const char *pathname, char *buf, size_t bufsiz);
       ssize_t nread = ::readlink(path.c_str(), &buffer[0], PATH_MAX);
       if(nread == -1){
           fprintf(stderr, " Error: %s \n", strerror(errno));
           throw std::runtime_error("Error: unable to read symlink. Check 'errno' variable");
       }
       buffer.resize(nread);
       return buffer;
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
   $ >> g++ current-process.cpp -o current-process.elf -Wall -Wextra -ggdb
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ >> ./current-process.elf 
    => Process PID = 719155 
    => Process PID = 678179 
    => Current directory = /home/mxpkf8/temp-projects/unix-explore 

  Change the curren directory to /etc 
    => Current directory = /etc 
   => Absolute Path of current executable = /home/mxpkf8/temp-projects/unix-explore/current-process.elf 
   => Current directory of this executable = /etc 
  [INFO] Finish Ok.
#+END_SRC

** Dynamic Loading Shared Libraries / dlopen() API 
*** Overview 

The dlopen API provide access to the _dynamic linker_ services allowing
the current process to load and unload shared objects or shared
libraries in its address space (virtual memory).

This API for loading shared libraries is not only available on Linux,
it also can be found in FreeBSD, NetBSD, MacOSX, Android and so on.

Use cases: 

  + Load new code at-runtime

  + Load third-party code a runtime

  + Plugin systems, extensions or addons.

  + Load native code extensions in languages with interpreters written
    in C, such as Python, Ruby, Lua and so on. Note: Python native
    extensions are shared libraries. 

The Dlopen() API is available on most Unix-like operating systems,
such as: 

   * Linux 
   * MacOSX 
   * FreeBDS
   * NetBSD
   * OpenBSD
   * QNX

Documentation: 

  + http://gnu.wiki/man3/dlopen.3.php

  + [[https://man7.org/linux/man-pages/man3/dlopen.3.html][Dlopen API - Linux Manpages]]

  + [[https://www.freebsd.org/cgi/man.cgi?query=dlopen&apropos=0&sektion=0&manpath=SuSE+Linux%252Fi386+7.3&format=html][Free BSD - dlopen API documentation]]

  + [[https://docs.oracle.com/cd/E19048-01/chorus5/806-7014/6jftsjfdq/index.html][Dlopen - Oracle Documentation]]

  + [[http://www.qnx.com/developers/docs/6.5.0SP1.update/com.qnx.doc.neutrino_lib_ref/d/dlopen.html][Dlopen - QNX documentation]]

  + [[https://dwheeler.com/program-library/Program-Library-HOWTO/x172.html][Dynamically Loaded (DL) Libraries]]


Further Reading: 

  + [[https://cseweb.ucsd.edu/~gbournou/CSE131/the_inside_story_on_shared_libraries_and_dynamic_loading.pdf][Inside the history on shared libraries and dynamic loading]]

  + [[https://hackaday.com/2018/07/12/its-all-in-the-libs-building-a-plugin-system-using-dynamic-loading/][It 's all in the libs - Building a Plugin system using Dynamic Loading]]

  + [[http://docencia.ac.upc.edu/FIB/USO/Bibliografia/unix-c-libraries.html][Building And Using Static And Shared "C" Libraries]]

  + [[https://www.informit.com/articles/article.aspx?p=22435][More Shared Libraries-Dynamic Loading and Unloading]]

  + https://grugq.github.io/docs/subversiveld.pdf

  + [[https://github.com/mgood7123/universal-dynamic-loader][universal-dynamic-loader]] for Linux - "min-dl: minimal dynamic linker implementation"


Headers and libraries: 

  + Header:  #include <dlfcn.h>
  + Linking: (-ldl) flag 

 _Function dlopen()_:

  + Doc: $ man dlopen 
  + Loads a shared library and returns a _handle_ or _opaque pointer_
    casted as void pointer. The term _opaque_ means that the
    implementation is hidden and the pointer is only meant to be
    passed around to other functions.
  + Note: When this function fails, it returns null pointer.

#+BEGIN_SRC cpp 
      void* dlopen(const char* filename, int flags);
#+END_SRC

 _Function dlsym()_:

  + Doc: $ man dlsym
  + Obtains address of a shared library symbol from _handle_ (from
    dlopen). 
  + Params:
    + handle => Shared library handle obtained from _dlopen_
    + symbol  => Name of symbol to be loaded.
  + Return:
    + Address of symbol casted as void*. It can be a function-pointer
      or a pointer to global variable. If the symbol is not found, the
      function returns a null pointer. 

#+BEGIN_SRC cpp 
    void* dlsym(void* handle, const char* symbol);
#+END_SRC

 _Function dlvsym()_:

  + Doc: $ man dlvsym
    + Loads a specific version of a symbol. 

#+BEGIN_SRC cpp 
    void* dlvsym(void *handle, char *symbol, char *version);
#+END_SRC

 _Function dlclose()_: 

  + Doc: $ man dlclose()

#+BEGIN_SRC cpp 
  int dlclose(void *handle);
#+END_SRC

 _Function dlerror()_ 
   + Obtaines error messages from dlopen API.
   + Doc: $ man dlerror()

#+BEGIN_SRC cpp 
  char* dlerror(void);
#+END_SRC

 *Simplified type signatures with a C++-friendly notation*

#+BEGIN_SRC cpp 
   // Opaque pointer for shared library (shared object) handle 
   using HND = void* ; 
   // Opaque pointer for shared library symbol 
   using SYM = void* ; 

   HND  dlopen( const char* filename, int flags);
   SYM   dlsym( HND handle, const char* symbol);
   SYM  dlvsym( HND handle, char *symbol, char *version);
   int dlclose( HND handle );
#+END_SRC

 *Usage example* 

#+BEGIN_SRC cpp 
   #include <dlfcn.h>

   // Opaque pointer for shared library (shared object) handle 
   using HND = void* ; 
   // Opaque pointer for shared library symbol 
   using SYM = void* ; 

   void load_library()
   {
       // Load shared library 
       HND hnd = dlopen("/path/to/shared-library.so", RTLD_LAZY | RTLD_GLOBAL); 
       if(hnd == nullptr)
       {
          std::cerr << "  [ERROR] " << dlerror() << "\n";
          throw std::runtime_error("Error: unable to load shared library"); 
       }

       // Load symbol 
       SYM hsym = dlsym(hnd, "name_of_function"); 

       // if(!hsym)
       if(hsym == nullptr)
       {
          throw std::runtime_error("Error: symbol not found"); 
       }

       // Type alias for function pointer in modern C++ 
       //  => Note: The function to be loaded can only have C-linkage. 
       using name_of_function_t = void (*) (int param0, double param1, const char* param3);

       // Type alias for function pointer in old C++ (C++98)
       typedef void (*name_of_function_t) (int param0, double param1, const char* param3);       

       auto name_of_function_ptr = reinterpret_cast<name_of_function_t>(hsym); 
   
       // Call loaded function (Function pointer)
       name_of_function_ptr(100, 2.51, "string");

       // Unload shared library 
       dlclose(hsym);
   }
#+END_SRC

*** GTK3/GTK2 GUI using dynamic loading - low level 

The following sample code is a GTk3 or GTK2 GUI graphical user
interface application with GTK functions loaded from a GTK shared
library, without any compile-time linking. The advantage of this
approach is the greater portability across different versions of GTk
and the ability to switch between GT3 and GT2.

GIST: 
  + https://gist.github.com/d81dd9c422dc93ad4104b5e79259afdf

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.9)
   project(gtk-sample)

   #========== Global Configurations =============#
   #----------------------------------------------#

   set(CMAKE_CXX_STANDARD 17)     
   set(CMAKE_VERBOSE_MAKEFILE ON)

          add_executable( gtk-dlopen gtk-dlopen.cpp)
   target_link_libraries( gtk-dlopen dl )   
#+END_SRC

File: gtk-dlopen.cpp 

#+BEGIN_SRC cpp 
    #include <iostream>
    #include <cstring> 
    #include <cassert> 

    // Uses: dlopen(), dlclose(), ... 
    #include <dlfcn.h>

    // ---- Copied from GTK headers ------// 
    typedef char            gchar;
    typedef short           gshort;
    typedef long            glong;
    typedef int             gint;
    typedef gint            gboolean;
    typedef unsigned char   guchar;
    typedef unsigned short  gushort;
    typedef unsigned long   gulong;
    typedef unsigned int    guint;
    typedef float           gfloat;
    typedef double          gdouble;
    typedef void*           gpointer;
    typedef const void*     gconstpointer;

    enum class GtkWindowType
    {
        GTK_WINDOW_TOPLEVEL,
        GTK_WINDOW_POPUP
    };

    enum class GConnectFlags
    {
      G_CONNECT_AFTER	= 1 << 0,
      G_CONNECT_SWAPPED	= 1 << 1
    };

    template<typename TFun>
    TFun load_symbol(void* hnd, std::string symbol)
    {
        void* hSym = dlsym(hnd, symbol.c_str());
        if(hSym == nullptr)
        {
            std::string msg = std::string(" [Error] symbol not found: ") + symbol;
            throw std::runtime_error(msg);
        }    
        return reinterpret_cast<TFun>(hSym);
    }

    // Opaque type (aka incomplete type)
    struct GClosure;

    // -------- Function Pointers type aliases -------------------//
    using GCallback      = void  (*) (void);
    using GClosureNotify = void  (*) (gpointer data, GClosure* closure);
    using g_signal_connect_data_t =  gulong (*) (   gpointer instance
                                                  , const gchar*    detailed_signal
                                                  , GCallback       c_handler
                                                  , gpointer        data
                                                  , GClosureNotify  destroy_data
                                                  , GConnectFlags	connect_flags
                                              );

    int main(int argc, char** argv)
    {    
        std::string shared_lib =  [&]() -> std::string 
        {
            if(argc < 2) return "libgtk-3.so.0";
            return argv[1];
        }();

        std::cout << " [INFO] Loading shared library: " << shared_lib << "\n";

        //  void *dlopen(const char *filename, int flags);

        // Handle to shared library 
        void* hnd = dlopen(shared_lib.c_str(), RTLD_NOW | RTLD_GLOBAL);
        if(hnd == nullptr){ fprintf(stderr, "%s\n", dlerror());  }
        assert( hnd != nullptr );

        void* hSym = nullptr; 

        // --------- Load gtk_init_check function pointer ------- // 
        hSym = dlsym(hnd, "gtk_init_check");
        assert(hSym != nullptr);
        using gtk_init_check_t = gboolean (*) (int* argc, char*** argv);
        auto gtk_init_check = reinterpret_cast<gtk_init_check_t>(hSym);   

        // ------- Load remaining function pointers (symbols) --------// 
        //-----------------------------------------------------------//

        // opaque pointer 
        struct GtkWidget;

        using gkt_window_new_t = GtkWidget* (*) (int);
        auto gtk_window_new  = load_symbol<gkt_window_new_t>(hnd, "gtk_window_new");    
        auto gtk_widget_show = load_symbol<void (*) (GtkWidget*)>(hnd, "gtk_widget_show");
        auto gtk_main        = load_symbol<void (*) ()>(hnd, "gtk_main");

        using gtk_window_set_title_t = void (*) (GtkWidget* window, const gchar* title);
        auto gtk_window_set_title = load_symbol<gtk_window_set_title_t>(hnd, "gtk_window_set_title");

        using gtk_widget_set_size_t = void (*) (GtkWidget*, gint, gint);
        auto gtk_widget_set_size = load_symbol<gtk_widget_set_size_t>(hnd, "gtk_widget_set_size_request");

        auto gtk_main_quit = load_symbol<void (*) ()>(hnd, "gtk_main_quit");

        auto gtk_signal_connect_data 
              = load_symbol<g_signal_connect_data_t>(hnd, "g_signal_connect_data");

        /** ------- Build Window GUI - Graphical User Interface ----------**/

        // Call function pointer 
        gtk_init_check(&argc, &argv);

        GtkWidget* window = gtk_window_new( (int) GtkWindowType::GTK_WINDOW_TOPLEVEL);
        gtk_widget_set_size(window, 400, 500);
        gtk_window_set_title(window, "My GTK Window");
        gtk_widget_show(window);    

        gtk_signal_connect_data(  window         // Widget 
                                , "destroy"      // Event name 
                                , gtk_main_quit  // Callback                             
                                , nullptr        // Pointer to data (closure )
                                , nullptr 
                                , (GConnectFlags) 0 // GConnect flags 
                                );

        std::cout << " [INFO] Window running. OK! " << "\n";
        gtk_main();

        // Always close shared library handler.
        dlclose(hnd);

        std::cout << " [INFO] Shutdown gracefully. Ok. \n" ;
        return EXIT_SUCCESS;
    }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/d81dd9c422dc93ad4104b5e79259afdf && cd gist 
  $ g++ gtk-dlopen.cpp -o gtk-dlopen.bin -std=c++1z -ldl -ggdb -Wall -Wextra   
#+END_SRC

Checking the dependencies of gtk-dlopen.bin 

#+BEGIN_SRC sh 
   $ >> ldd gtk-dlopen.bin 
          linux-vdso.so.1 (0x00007ffd23fc4000)
          libdl.so.2 => /lib64/libdl.so.2 (0x00007f6a78428000)
          libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007f6a78238000)
          libm.so.6 => /lib64/libm.so.6 (0x00007f6a780f2000)
          libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007f6a780d7000)
          libc.so.6 => /lib64/libc.so.6 (0x00007f6a77f0d000)
          /lib64/ld-linux-x86-64.so.2 (0x00007f6a78453000)
#+END_SRC

Running: (load GTK shared library /lib64/libgtk-3.so.0)

#+BEGIN_SRC sh 
 $ >> ./gtk-dlopen.bin 
 [INFO] Loading shared library: /lib64/libgtk-3.so.0
 [INFO] Window running. OK! 
 [INFO] Shutdown gracefully. Ok. 
#+END_SRC

Running: (load GK2 shared library )

#+BEGIN_SRC sh 
   $ >> ./gtk-dlopen.bin /usr/lib64/libgtk-x11-2.0.so 
   [INFO] Loading shared library: /usr/lib64/libgtk-x11-2.0.so
   [INFO] Window running. OK! 
   [INFO] Shutdown gracefully. Ok. 
#+END_SRC

Verify exported symbols by gtk3 shared library: 

#+BEGIN_SRC sh 
    $ >> nm -D /lib64/libgtk-3.so.0 | grep init
           ... ... ... ... ..
           ... ... ... ... ..
           U g_async_initable_new_async
           U g_async_initable_new_finish
           U g_datalist_init
           U g_hash_table_iter_init
           U g_initable_get_type
           U g_initable_new
           U g_initially_unowned_get_type
           U g_mutex_init
           U g_once_init_enter
          ... ... ... ... ..
          ... ... ... ... ..
#+END_SRC

*** GTK3/GTK2 GUI using dynamic loading - high level C++ wrapper 

This proof-of-concept code contains a high-level wrapper class
SharedLibrary for abstracting away the dlopen() API. This class is
used for loading GTK3 or GTk2 shared library at runtime and then
showing modal notifications dialogs. The advantage of the dynamic
loading approach is the flexibility, portability and easier deployment
as the binary does not depends on any particular GTK shared library
version.

Note: 

  + The code of the class SharedLibrary can be reused on any other
    unix-like operating system with dlopen() API, such as FreeBDS,
    NetBSD, MacOSX and so on.

  + The Windows API for dynamic loading is LoadLibrary(),
    GetProcAddress(). 

GIST: 
  + https://gist.github.com/6bbb3b9491d4fad01d3875a559b7365b

  *Project Files* 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(gtk-dynamic-load-dialog)

  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  # ---- TARGETS Configuration ---------------#
         add_executable( gtk-dialog gtk-dialog.cpp gtk_types.hpp)
  target_link_libraries( gtk-dialog dl ) 
#+END_SRC

File: gtk-dialog.cpp 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string> 
  #include <cstring> 
  #include <cassert> 

  // Uses: dlopen(), dlclose(), ... 
  #include <dlfcn.h>

  #include "gtk_types.hpp"

  /** Requires header: <dlfcn.h> and linking flag (-ldl) */
  class SharedLibrary
  {
  public:
      using HND  = void*; 
      using HSYM = void*;
  private:
      HND         m_hnd  = nullptr; 
      std::string m_lib = "" ; 
      int         m_flags = 0;
  public:
      SharedLibrary(){}    
      ~SharedLibrary(){ this->unload(); }

      // Constructor delegation 
      SharedLibrary(std::string library)
          : SharedLibrary(library, RTLD_NOW | RTLD_GLOBAL)
      {  }

      SharedLibrary(std::string library, int flags)
      {
          this->load(library, flags);
      }

      // Disable copy constructor and copy-assignment operator 
      SharedLibrary(SharedLibrary const &) = delete;
      SharedLibrary& operator=(SharedLibrary const &) = delete;

      // Move constructor 
      SharedLibrary(SharedLibrary&& rhs) 
      {
          std::swap(m_hnd, rhs.m_hnd);
          std::swap(m_lib, rhs.m_lib);
          std::swap(m_flags, rhs.m_flags);
      }

      // Move assignment operator 
      SharedLibrary& operator=(SharedLibrary&& rhs) 
      {
          this->unload();
          std::swap(m_hnd, rhs.m_hnd);
          std::swap(m_lib, rhs.m_lib);
          std::swap(m_flags, rhs.m_flags);
          return *this;
      }

      HND         handler()   const { return m_hnd; }    
      bool        is_loaded() const { return m_hnd != nullptr; }    
      std::string library()   const { return m_lib; }

      /** Retrieve symbol from shared library */
      HSYM symbol_ptr(std::string name) const 
      {
          return ::dlsym(m_hnd, name.c_str());
      }

      /** @brief Get symbol from shared library
       ,* Note: The caller is resposible for checking if the symbol is (null) nullptr.
       ,*/
      template<typename TFun>
      TFun symbol(std::string name) const 
      {
          HSYM sym = ::dlsym(m_hnd, name.c_str());
          return reinterpret_cast<TFun>(sym);
      }

      /** @brief Attempts to load symbol and throws exception, if symbol is not found. */
      template<typename TFun>
      TFun symbol_or_fail(std::string name) const 
      {
          HSYM sym = ::dlsym(m_hnd, name.c_str());
        
          if(!sym){ 
              std::string msg = " [ERROR] Dlopen / dlsym() => unable find symbol";
              msg = msg + " <" + name + ">";
              throw std::runtime_error(msg); 
          }
          return reinterpret_cast<TFun>(sym);
      }

      void load(std::string library, int flags)
      {
          if(!this->is_loaded()) { this->unload(); }
          m_lib   = library;
          m_flags = flags;
          m_hnd = dlopen(library.c_str(), RTLD_NOW | RTLD_GLOBAL);        
          if(m_hnd == nullptr){ 
              std::string msg = " [ERROR] DlopenError: ";
              msg = msg + dlerror();
              throw std::runtime_error(msg);
          }
      }    

      void reload() 
      {
          this->unload();
          this->load(m_lib, m_flags);
      }

      void unload() 
      {
          if(!this->is_loaded()) { return; }
          ::dlclose(m_hnd);        
          m_hnd = nullptr;
      }

  }; // --- End of class SharedLibrary() ---- //

  using namespace GtkPP::fpointer;
  using namespace GtkPP::enums;

  struct GtkLib
  {
      SharedLibrary slib;

      GtkLib(std::string library)
          : slib( std::move(SharedLibrary(library)) )
      { 
          gtk_init_check         = slib.symbol_or_fail<gtk_init_check_t>("gtk_init_check");       
          gtk_main_quit          = slib.symbol_or_fail<gtk_main_quit_t>("gtk_main_quit");
          // gtk_main               = slib.symbol_or_fail<void (*) ()>("gtk_main");
          gtk_message_dialog_new = slib.symbol_or_fail<gtk_message_dialog_new_t>("gtk_message_dialog_new");
          gtk_widget_destroy     = slib.symbol_or_fail<gtk_widget_destroy_t>("gtk_widget_destroy");
          gtk_dialog_run         = slib.symbol_or_fail<gtk_dialog_run_t>("gtk_dialog_run");
          gtk_window_set_title   = slib.symbol<gtk_window_set_title_t>("gtk_window_set_title");

      }

      gtk_init_check_t         gtk_init_check; 
      gtk_main_quit_t          gtk_main_quit; 
      // gtk_main_t               gtk_main;
      gtk_message_dialog_new_t gtk_message_dialog_new;
      gtk_widget_destroy_t     gtk_widget_destroy;
      gtk_dialog_run_t         gtk_dialog_run;
      gtk_window_set_title_t   gtk_window_set_title;

      // Message box notification 
      void msgbox(  std::string title
                  , std::string text 
                  , GtkMessageType mtype = GtkMessageType::GTK_MESSAGE_INFO 
                  ) 
      {
         GtkWidget* dialog = this->gtk_message_dialog_new(  nullptr 
                                                  , (int) GtkDialogFlags::GTK_DIALOG_MODAL
                                                  , (int) mtype 
                                                  , (int) GtkButtonsType::GTK_BUTTONS_OK
                                                  , text.c_str()
                                                  );                                            
          assert( dialog != nullptr );    
          this->gtk_window_set_title(dialog, title.c_str());
          this->gtk_dialog_run(dialog);
          std::cout << " [INFO] Dialog destroyed OK " << "\n";
          this->gtk_widget_destroy(dialog);   
      }
  };


  int main(int argc, char** argv)
  {        
      // User can select his own GTK shared library, if it is not 
      // found. He can also select GTK2 shared library. 
      auto shared_lib =  [&]() -> std::string 
      {
          if(argc < 2) return "libgtk-3.so.0";
          return argv[1];
      }();
    
      std::cout << " [INFO] Loading shared library: " << shared_lib << "\n";   
      auto gtk = GtkLib{shared_lib};   

      // Alwas start the library before calling any GTK function 
      gtk.gtk_init_check(&argc, &argv);    

      gtk.msgbox("User notification", "Download completed. Ok.",     GtkMessageType::GTK_MESSAGE_INFO );    
      gtk.msgbox("Runtime error",     "KERNEL PANIC!! Reboot NOW!!", GtkMessageType::GTK_MESSAGE_ERROR );        

      std::cout << " [INFO] Shutdown gracefully. Ok. \n" ;
      return EXIT_SUCCESS;
  }
#+END_SRC

File: gtk_types.hpp 

#+BEGIN_SRC cpp 
  // ------ C++ Wrappers for dynamically loading GTK ----- //
  #ifndef _GTK_TYPES_HPP
  #define _GTK_TYPES_HPP

  namespace GtkPP 
  {
      namespace base {
          using gchar    = char;
          using gshort   = short;
          using glong    = long;
          using gint     = int;
          using gboolean = gint;
          using guchar   = unsigned short;
          using gulong   = unsigned long;
          using guint    = unsigned int;
          using gfloat   = float;
          using gdouble  = double;
          using gpointer = void*;          
          using gconstpointer = const void*;

      };
      // ------- Opaque Types / incomplete types ---------//
      namespace widget {        
          struct GtkWidget;
          struct GClosure;
          struct GtkWidget;
          struct GtkWindow;
          struct GtkDialog;
      };

      namespace enums {
          enum class GtkWindowType
          {
              GTK_WINDOW_TOPLEVEL,
              GTK_WINDOW_POPUP
          };

          enum class GConnectFlags
          {
          G_CONNECT_AFTER	= 1 << 0,
          G_CONNECT_SWAPPED	= 1 << 1
          };

          enum class GtkMessageType
          {
          GTK_MESSAGE_INFO,
          GTK_MESSAGE_WARNING,
          GTK_MESSAGE_QUESTION,
          GTK_MESSAGE_ERROR,
          GTK_MESSAGE_OTHER
          };

          enum class GtkButtonsType
          {
          GTK_BUTTONS_NONE,
          GTK_BUTTONS_OK,
          GTK_BUTTONS_CLOSE,
          GTK_BUTTONS_CANCEL,
          GTK_BUTTONS_YES_NO,
          GTK_BUTTONS_OK_CANCEL
          };

          enum class GtkDialogFlags
          {
          GTK_DIALOG_MODAL               = 1 << 0,
          GTK_DIALOG_DESTROY_WITH_PARENT = 1 << 1,
          GTK_DIALOG_USE_HEADER_BAR      = 1 << 2
          };
      };

      /** @brief Function pointers type aliases  */
      namespace fpointer 
      {
          using namespace base;
          using namespace widget;
          using enums::GConnectFlags;

          using GtkDialogFlags_t = int; 
          using GtkMessageType_t = int; 
          using GtkButtonsType_t = int;

          using gtk_init_check_t = gboolean (*) (int* argc, char*** argv);
          using gtk_dialog_run_t       = gint (*) (void* dialog);
          using gtk_widget_destroy_t   = void (*) (GtkWidget* widget);
          using gtk_window_set_title_t = void (*) (GtkWidget* window, const gchar* title);
          using gtk_main_quit_t        = void (*) ();

          using gtk_window_set_title_t = void (*) (GtkWidget* window, const gchar* title);


          using GCallback      = void  (*) (void);
          using GClosureNotify = void  (*) (gpointer data, GClosure* closure);
          using g_signal_connect_data_t =  gulong	(*) ( gpointer        instance
                                                      , const gchar*    detailed_signal
                                                      , GCallback       c_handler
                                                      , gpointer  	    data
                                                      , GClosureNotify  destroy_data
                                                      , GConnectFlags	connect_flags
                                                      );


          using gtk_message_dialog_new_t = GtkWidget* (*) ( GtkWindow       *parent,
                                                            GtkDialogFlags_t  flags,
                                                            GtkMessageType_t  type,
                                                            GtkButtonsType_t  buttons,
                                                            const gchar*    message_format
                                                          );


      };

  };

  #endif 
#+END_SRC

Building and running: 
 
#+BEGIN_SRC sh 
   # Download 
   $ >> git clone https://gist.github.com/6bbb3b9491d4fad01d3875a559b7365b gtk-dialog && cd gtk-dialog 

   # Configure 
   $ >> cmake --config Debug -H. -B_build

   # Build 
   $ >> cmake --build _build --target 

   # Run 
   $ >> _build/gtk-dialog 
   [INFO] Loading shared library: libgtk-3.so.0
   [INFO] Dialog destroyed OK 
   [INFO] Dialog destroyed OK 
   [INFO] Shutdown gracefully. Ok. 

#+END_SRC
** Library calls hooking/interception with LD_PRELOAD 
*** Overview 

The dynamic linker of many Unix-like operating systems, including
Linux-based ones and BSD variants, provide a LD_PRELOAD mechanism,
which allows intercepting and overriding (aka hooking) library calls
performed by applications withou any source code modification. A
library call can be overriden by setting the LD_PRELOAD environment
variable with a colon (':') separated list containing full paths of
shared libraries containing symbols with the same name as the
overriden functions.

Some use-cases of this feature are: 

  + Override library calls and modify the behavior of library calls.
  + Performance analysis.
  + Instrument library calls. 
  + Log library-calls
  + Trace memory allocation by overrading calloc, malloc and free
    functions. 
  + Patch executables without any source code modification or
    recompilation.

Notes and limitations: 

  * The dynamic linker LD_PRELOAD feature do not intercept kernel's
    system-calls, it can only intercept library calls (aka function
    calls) or GlibC (GNU C library) or any other CRT (C - Runtime
    Library) wrappers for _system calls_, informally called
    _syscalls_.

  * LD_PRELOAD trick cannot intercept functions of executables owned
    by root and with SETUID bit set. 

*** Sample code and experiment 

All sources available at GIST: 

  + GIST: https://gist.github.com/751fad7bf7707949e824ed2c19a73752

File: _build.sh_ (Build script)

#+BEGIN_SRC sh  
   #!/usr/bin/env sh

   # Build unix/Linux executable
   gcc unix-executable.c -o unix-executable.bin

   # Build Linux shared library: hook-files-a.so
   gcc hook-files-a.c -o hook-files-a.so -fpic -shared -ldl -Wall

   # Build Linux shared library: hook-files-b.so
   g++ hook-files-b.cpp -o hook-files-b.so -fpic -Wall -shared -ldl
#+END_SRC


File: _hook-files-a.c_  / C-version  (Shared library, aka shared object, hook-files-a.so)

#+BEGIN_SRC cpp   
  #define _GNU_SOURCE // Enables RTLD_NEXT constant.

  #include <stdio.h>
  #include <assert.h>
  #include <stdint.h>  

  // ----- Unix-specific headers ------- //
  #include <dlfcn.h>

  // Annotation for internal symbols not visible outside
  // this compilation unit (static storage class).
  #define HIDDEN static 

  // Anotation for calling function whenever the shared library
  // is loaded by some process. Note: this is a specific GNU 
  // language extension. 
  #define ON_LIBRARY_LOADED __attribute__((constructor))

  typedef uint32_t pid_t;
  typedef uint32_t mode_t;

  extern  pid_t getpid(void);

  __attribute__((constructor)) static 
  void init_library1()
  {
    fprintf(stderr, " [INFO] init_library1() / Library loaded Ok. \n");
  }

  HIDDEN ON_LIBRARY_LOADED 
  void init_library2()
  {
    fprintf(stderr, " [INFO] init_library2() / Library loaded Ok. \n");
  }

  /** Intercepts (aka hooks) and overrides open() function 
   ,*  from libC (GLIBC) that encapsulates open() system-call 
   ,*  (aka syscall).
   ,*---------------------------------------------------------*/
  int open(const char* pathname, int flags, mode_t mode)
  {
     // Type alias for function pointer with same
     // signature as the open() function. 
     typedef int (* open_t) (  const char* pathname
                             , int         flags
                             , mode_t      mode);
  
     // Load old symbol of original C function that was overriden
     open_t open_real = (open_t) dlsym(RTLD_NEXT, "open");

     // Sanity checking => calls abort() if symbol is not found.
     assert( open_real );
   
     // Log intercepted functional call
     // pid =>> Process ID of process that loaded this
     // shared library. 
     fprintf( stderr
              , " [TRACE] pid = %d / open() ->> File = %s \n"
              , getpid(), pathname);

     // Pass control back to intercepted (hooked) function. 
     return open_real(pathname, flags, mode);
  }


  FILE* fopen64(const char* filename, const char* type)
  {
        typedef FILE* (* fopen64_t) (  const char* filename
                                     , const char* type);

        fopen64_t old_fun = (fopen64_t) dlsym(RTLD_NEXT, "fopen64");
        assert( old_fun != NULL);

        fprintf( stderr
                 , " [TRACE] pid = %d / fopen64() ->> File = %s \n"
                 , getpid(), filename);     
    
        return old_fun(filename, type);
  }
#+END_SRC


File: _hook-files-b.cpp_  / C++-version  (Shared library /hook-files-b.so/ )

#+BEGIN_SRC cpp  
  #include <iostream>
  #include <cassert>
  // Equivalent to C-header <stdint.h> std::uint32_t ... and so on.
  #include <cstdint>  

  // ----- Unix-specific headers ------- //

  #include <dlfcn.h>

  // Annotqtion for defining functions with C-linkage
  // that must conform to C ABI and calling conventions.
  #define EXTERN_C extern "C"

  // Annotation for internal symbols not visible outside
  // this compilation unit (static storage class).
  #define HIDDEN static 

  // Anotation for calling function whenever the shared library
  // is loaded by some process. Note: this is a specific GNU 
  // language extension. 
  #define ON_LIBRARY_LOADED __attribute__((constructor))

  // This symbol will be resolved at linking-time by the Linker 
  extern "C" pid_t getpid(void);


  __attribute__((constructor)) static 
  void init_library1()
  {
    fprintf( stderr," [INFO] init_library1() / Library loaded Ok. \n");
  }

  HIDDEN ON_LIBRARY_LOADED 
  void init_library2()
  {
    fprintf( stderr, " [INFO] init_library2() / Library loaded Ok. \n");
  }

  /** Intercepts (aka hooks) and overrides open() function 
   ,*  from libC (GLIBC) that encapsulates open() system-call 
   ,*  (aka syscall).
   ,*---------------------------------------------------------*/
  EXTERN_C
  int open(const char* pathname, int flags, mode_t mode)
  {
     // Type alias for function pointer with same
     // signature as the open() function. 
     using open_t = int (*) (  const char* pathname
                             , int         flags
                             , mode_t      mode);
  
     // Load old symbol of original C function that was overriden
     open_t open_real = (open_t) dlsym(RTLD_NEXT, "open");

     // Sanity checking => calls abort() if symbol is not found.
     assert( open_real != nullptr);
   
     // Log intercepted functional call
     // pid =>> Process ID of process that loaded this
     // shared library. 
     std::fprintf( stderr
                  , " [TRACE] pid = %d / open() ->> File = %s \n"
                  , getpid(), pathname);

     // Pass control back to intercepted (hooked) function. 
     return open_real(pathname, flags, mode);
  }

  EXTERN_C
  FILE* fopen64(const char* filename, const char* type)
  {
      using fopen64_real = FILE* (*) ( const char* filename
                                     , const char* type);

      auto old_fun = (fopen64_real) dlsym(RTLD_NEXT, "fopen64");
      assert( old_fun != nullptr);

       std::fprintf( stderr
                  , " [TRACE] pid = %d / fopen64() ->> File = %s \n"
                  , getpid(), filename);     
    
      return old_fun(filename, type);
  }
#+END_SRC

Building executable and shared libraries (aka shared objects - 'unix
terminology'):

#+BEGIN_SRC sh 
    $ >> git clone https://gist.github.com/751fad7bf7707949e824ed2c19a73752 api-hooking && cd api-hooking 
    $ >> sh build.sh

    $ ls
    build.sh  hook-files-a.c  hook-files-b.cpp  unix-executable.c

    # Check generated object-codes:
    #------------------------------------------------------------------#
    $ >> file hook-files-a.so 
    hook-files-a.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV) ... ...

    $ >> file hook-files-b.so
    hook-files-b.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV) ... ...

    $ >> file unix-executable.bin 
    unix-executable.bin: ELF 64-bit LSB executable, x86-64, ... ... ...
#+END_SRC

Running executable _unix-executable.bin_ 

#+BEGIN_SRC sh 
    $ >> ./unix-executable.bin  
   unix-executable.bin: unix-executable.c:8: main: Assertion `argc == 2 && "Missing file argument"' failed.
   fish: “./unix-executable.bin” terminated by signal SIGABRT (Abort)

   $ >> ./unix-executable.bin /proc/devices 
   [LINE] 1 = Character devices:
    [LINE] 2 =   1 mem
    [LINE] 3 =   4 /dev/vc/0
    [LINE] 4 =   4 tty
   ... ... ... ... ... 
   ... ... ... ... ... 
    [LINE] 67 = 253 device-mapper
    [LINE] 68 = 254 mdp
    [LINE] 69 = 259 blkext
#+END_SRC

Intercepting library-call (ak function) _fopen64()_ using LD_PRELOAD.

#+BEGIN_SRC sh 
   # Using hook-files-a.so (C version)
   #-------------------------------------------------
   $ >> env LD_PRELOAD=$PWD/hook-files-a.so ./unix-executable.bin /proc/devices 
   [INFO] init_library1() / Library loaded Ok. 
   [INFO] init_library2() / Library loaded Ok. 
   [TRACE] pid = 231690 / fopen64() ->> File = /proc/devices 
   [LINE] 1 = Character devices:
    [LINE] 2 =   1 mem
    [LINE] 3 =   4 /dev/vc/0
    [LINE] 4 =   4 tty
    [LINE] 5 =   4 ttyS
    [LINE] 6 =   5 /dev/tty
    [LINE] 7 =   5 /dev/console
    ... ... ... ... 
   ... ... ... ... ... 

   # Using hook-files-b.so (C++ version)
   #-------------------------------------------------
   $ >> env LD_PRELOAD=$PWD/hook-files-b.so ./unix-executable.bin /proc/devices
   [INFO] init_library1() / Library loaded Ok. 
   [INFO] init_library2() / Library loaded Ok. 
   [TRACE] pid = 231790 / fopen64() ->> File = /proc/devices 
   [LINE] 1 = Character devices:
    [LINE] 2 =   1 mem
    [LINE] 3 =   4 /dev/vc/0
    [LINE] 4 =   4 tty
    [LINE] 5 =   4 ttyS
    [LINE] 6 =   5 /dev/tty
    [LINE] 7 =   5 /dev/console
   ... ...  ... ...  ... ...  ... ...  ... ... 
   ... ...  ... ...  ... ...  ... ...  ... ... 
#+END_SRC

Intercepting library-call (ak function) _fopen64()_ using LD_PRELOAD,
but discarding _stdout_ (standard console output) by redirecting it to
/dev/null in order to only display the _stderr_ logged by the
replacement functions. 

#+BEGIN_SRC sh 
   # C version 
   $ >> env LD_PRELOAD=$PWD/hook-files-a.so ./unix-executable.bin /proc/devices > /dev/null
   [INFO] init_library1() / Library loaded Ok. 
   [INFO] init_library2() / Library loaded Ok. 
   [TRACE] pid = 231957 / fopen64() ->> File = /proc/devices 

   # C+++ version 
   $ >> env LD_PRELOAD=$PWD/hook-files-b.so ./unix-executable.bin /proc/devices > /dev/null
   [INFO] init_library1() / Library loaded Ok. 
   [INFO] init_library2() / Library loaded Ok. 
   [TRACE] pid = 231994 / fopen64() ->> File = /proc/devices 
#+END_SRC

Tracing library calls with _ltrace_ utility: 

#+BEGIN_SRC sh  
    $ >> ltrace ./unix-executable.bin /proc/devices
   fopen64("/proc/devices", "r")                         = 0x19722a0
   getline(0x7fff02a9a640, 0x7fff02a9a638, 0x19722a0, 0x7fff02a9a638) = 19
   fprintf(0x7f50e3769500, " [LINE] %d = %s ", 1, "Character devices:\n" [LINE] 1 = Character devices:
   ) = 32
   getline(0x7fff02a9a640, 0x7fff02a9a638, 0x19722a0, 0x7fff02a9a638) = 8
   fprintf(0x7f50e3769500, " [LINE] %d = %s ", 2, "  1 mem\n"  [LINE] 2 =   1 mem
   ) = 21
   getline(0x7fff02a9a640, 0x7fff02a9a638, 0x19722a0, 0x7fff02a9a638) = 14
   fprintf(0x7f50e3769500, " [LINE] %d = %s ", 3, "  4 /dev/vc/0\n"  [LINE] 3 =   4 /dev/vc/0
   ) = 27
   getline(0x7fff02a9a640, 0x7fff02a9a638, 0x19722a0, 0x7fff02a9a638) = 8
   fprintf(0x7f50e3769500, " [LINE] %d = %s ", 4, "  4 tty\n"  [LINE] 4 =   4 tty
     ... ... ...   ... ... ...   ... ... ...   ... ... ...   ... ... ...   ... ... ... 
     ... ... ...   ... ... ...   ... ... ...   ... ... ...   ... ... ...   ... ... ... 
   getline(0x7fff02a9a640, 0x7fff02a9a638, 0x19722a0, 0x7fff02a9a638) = -1
   free(0x1972480)                                       = <void>
   fclose(0x19722a0)                                     = 0
    +++ exited (status 0) +++
#+END_SRC

Tracing system-calls calls with _strace_ utility: 

#+BEGIN_SRC 
  $ >> strace ./unix-executable.bin /proc/devices

  execve("./unix-executable.bin", ["./unix-executable.bin", "/proc/devices"], 0x7ffc6f5c0ba8 /* 83 vars */) = 0
   ... ... ... ...  ... ... ... ... ... ... ... ... 
   ... ... ... ...  ... ... ... ... ... ... ... ... 

  openat(AT_FDCWD, "/proc/devices", O_RDONLY) = 3
  fstat(3, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
  read(3, "Character devices:\n  1 mem\n  4 /"..., 1024) = 694
  fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0xa), ...}) = 0
  write(1, " [LINE] 1 = Character devices:\n", 31 [LINE] 1 = Character devices:
  ) = 31
  write(1, "  [LINE] 2 =   1 mem\n", 21  [LINE] 2 =   1 mem
  )  = 21
  write(1, "  [LINE] 3 =   4 /dev/vc/0\n", 27  [LINE] 3 =   4 /dev/vc/0
  ) = 27
  write(1, "  [LINE] 4 =   4 tty\n", 21  [LINE] 4 =   4 tty
  )  = 21
   ... ... ...  ... ... ...  ... ... ...  ... ... ...  ... ... ... 
   ... ... ...  ... ... ...  ... ... ...  ... ... ...  ... ... ... 
#+END_SRC

Determining files opened by /uptime/ executable. 

#+BEGIN_SRC sh  
    $ which uptime
    /usr/bin/uptime

    $ file $(which uptime)
    /usr/bin/uptime: ELF 64-bit LSB shared object, x86-64, ... ... 

   # Indicates how long the machine is running: 
   $ >> uptime 
   15:45:45 up 3 days, 19:39,  1 user,  load average: 0.32, 0.59, 0.58

   # Run 1 
   $ >> env LD_PRELOAD=$PWD/hook-files-b.so uptime
   [INFO] init_library1() / Library loaded Ok. 
   [INFO] init_library2() / Library loaded Ok. 
   [TRACE] pid = 232426 / open() ->> File = /proc/uptime 
   [TRACE] pid = 232426 / open() ->> File = /proc/loadavg 
   15:46:39 up 3 days, 19:40,  1 user,  load average: 0.55, 0.61, 0.59

   # Run 2 - Discard stdout, preserving only stderr 
   $ >> env LD_PRELOAD=$PWD/hook-files-b.so uptime > /dev/null
   [INFO] init_library1() / Library loaded Ok. 
   [INFO] init_library2() / Library loaded Ok. 
   [TRACE] pid = 232456 / open() ->> File = /proc/uptime 
   [TRACE] pid = 232456 / open() ->> File = /proc/loadavg 

   $ >> cat /proc/uptime 
   330114.72 1249234.16

   $ >> cat /proc/loadavg 
   0.40 0.55 0.57 1/1838 232504
#+END_SRC

Determining files opened by /free/ executable which indicates the amount
of free RAM memory in megabytes in the current machine:

#+BEGIN_SRC sh  
   $ free -m
                 total        used        free      shared  buff/cache   available
   Mem:          15897        6603        2236        1768        7057        7378
   Swap:             0           0           0

   # Intercept library calls 
   #--------------------------------------------------------------------
   $ >> env LD_PRELOAD=$PWD/hook-files-b.so free -m
    [INFO] init_library1() / Library loaded Ok. 
    [INFO] init_library2() / Library loaded Ok. 
    [TRACE] pid = 232965 / open() ->> File = /proc/meminfo 
                 total        used        free      shared  buff/cache   available
   Mem:          15897        6601        2238        1768        7058        7380
   Swap:             0           0           0

   # Intercept library calls and discard stdout
   # , keeping only stderr (standard error output)
   #--------------------------------------------------------------------
    $ >> env LD_PRELOAD=$PWD/hook-files-b.so free -m > /dev/null 
    [INFO] init_library1() / Library loaded Ok. 
    [INFO] init_library2() / Library loaded Ok. 
    [TRACE] pid = 233016 / open() ->> File = /proc/meminfo

   # Inspect file /proc/meminfo 
   #--------------------------------------------------------------------
    $ >> cat /proc/meminfo 
   MemTotal:       16279408 kB
   MemFree:         2271428 kB
   MemAvailable:    7552036 kB
   Buffers:         1178620 kB
    ... ... ... ... ... ... 
    ... ... ... ... ... ... 
   HugePages_Surp:        0
   Hugepagesize:       2048 kB
   Hugetlb:               0 kB
   DirectMap4k:      604380 kB
   DirectMap2M:    12916736 kB
   DirectMap1G:     4194304 kB

#+END_SRC

** Launching processes with exec and fork system-call wrappers 

This code demonstrates the usage of exec and fork system-calls wrapper
functions, namely, execvp() and fork() functions. 

 *Relevant functions signature* 

Fork
  + Linux Manpage: "fork() creates a new process by duplicating the
    calling process.  The new process is referred to as the child
    process.  The calling process is referred to as the parent
    process."
  + Note: The function 'fork' is not the system call fork, but a
    C wrapper around this sytem call provided by the C runtime
    library. (GLIBC - GNU C library in the machine where this was tested.)

#+BEGIN_SRC cpp 
  pid_t fork(void);
#+END_SRC

Execvp (wraps exec system call)
  + The exec system calls is always called when a new process is
    launched/created. It replaces the process image of the current
    process with a new one from the launched executable.
  + Note: In addition to native executables, on Unix-like operating
    systems, an executable can also be any scripting file starting
    with shebang as first line such as "#!/usr/bin/env sh"

#+BEGIN_SRC cpp 
   int execvp(const char *file, char *const argv[]);
#+END_SRC

Waitpid => Waits for a state of change of a process.
  + It can be used for waiting for process termination. 
 
#+BEGIN_SRC cpp 
   pid_t waitpid(pid_t pid, int *wstatus, int options);
#+END_SRC

 *Documentation* 

  + [[https://man7.org/linux/man-pages/man2/fork.2.html][fork() Linux Manpage]]

  + [[https://www.freebsd.org/cgi/man.cgi?query=execvp][Execvp() => FreeBSD Manpage]]

 *Further Reading*

  + [[https://en.wikipedia.org/wiki/Fork_(system_call)][Fork (system call) - Wikipedia]]

  + [[http://people.cs.pitt.edu/~aus/cs449/ts-lecture14.pdf][Fork() System Calland ProcessesCS449 Spring 2016]]

  + [[https://www.cs.columbia.edu/~junfeng/11sp-w4118/lectures/unix.pdf][Chapter 0 - Operating system interfaces {PDF}]]

 *Sample Code* 

GIST: 
 + https://gist.github.com/133e91ba3732718cb228310173368674

File: unix-process.cpp 

#+BEGIN_SRC cpp 
   // ------ File: unix-process.cpp -----------------------------------------------------------//
   // Description: Shows hows to launch processes on Unix with Exec and Fork syscall wrappers.
   //-------------------------------------------------------------------------------------------//

   #include <iostream>
   #include <vector>

   // ----- Unix/Linux headers -----// 
   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   #include <sys/wait.h>

   #include <cstring> // Import: char* strerror(in errnum);

   // -------------- Declarations --------------------------//

   void print_errno_details(int err);
   void execvp_test();
   void execvp_cpp(std::string app, std::vector<std::string> args);

   // Launch a new process without terminate this process. 
   // It combines fork + exec system-calls. 
   void fork_exec(std::string app, std::vector<std::string> args);

   // -------------  MAIN() ------------------------------//

   int main(int argc, char** argv)
   {
        std::puts(" [INFO] Program started. ");

        if(argc < 2){
           std::printf(" Usage:  ./unix-process <OPTION>");
           return EXIT_SUCCESS;
        }

        std::string opt = argv[1];

        if(opt == "0")
        {
           execvp_test();
        }
        // Test execvp 
        if(opt == "1")
        {
            execvp_cpp("thunar", { "/etc" } );
            return EXIT_SUCCESS;
        }
        // Fork-exec 
        if(opt == "2")
        {
            fork_exec("konsole", { "-e", "tmux", "a"} );
        }	

        std::puts(" [TRACE] Finish execution. ");
        return 0;
   }

   // ------------- Definitions ------------------------//

   void print_errno_details(int err)
   {
           std::fprintf(stderr ,"\n   =>    errno(int) = %d" 
                                "\n   => errno message = %s \n"
                               , err, strerror(err));
           std::fflush(stderr);
   }


   // Test exec system-call wrapper function (execvp)
   void execvp_test()
   {    
           const char* app    = "thunar";

           const char* args[] = {  app     // Process name, can be anything 
                                  , "/etc"  // Arguments passed to the process 
                                  , nullptr // Always terminate the argument array with null pointer 
                                 };

           // Encapsulates execv system call. 
           // int execvp(const char *file, char *const argv[]);
           if( execvp(app, (char *const *) args) == -1)
           {
                 std::fprintf(stderr, " Error: unable to launch process");
                 print_errno_details(errno);
                 throw std::runtime_error("Error: failed to launch process");
           }

   }

   // C++ wrapper for the exevp() library-call 
   // It replaces the current process image with a new one 
   // from other executable. 
   void execvp_cpp(  std::string app
                   , std::vector<std::string> args)
   {
        std::vector<const char*> pargs;
        pargs.reserve(args.size() + 1);
        pargs.push_back(app.c_str());
        for(auto const& a: args){ pargs.push_back(a.c_str()); }
        pargs.push_back(nullptr);

        // Signature: int execvp(const char *file, char *const argv[]);

        // execvp(app.c_str(), execvp(app.c_str(), (char* const *) pargs.data() )
        int status = execvp(app.c_str(), (char* const*) pargs.data() );
        if( status == -1)
        {
             std::fprintf(stderr, " Error: unable to launch process");
             print_errno_details(errno);
             throw std::runtime_error("Error: failed to launch process");
        }
   }

   void fork_exec(std::string app, std::vector<std::string> args)
   {
        std::printf(" [TRACE] <BEFORE FORK> PID of parent process = %d \n", getpid());

        // PID of child process (copy of this process)
        pid_t pid = fork();

        if(pid == -1)
        {
            std::fprintf(stderr, "Error: unable to launch process");
            print_errno_details(errno);
            throw std::runtime_error("Error: unable to launch process");
        }
        if(pid == 0){
             std::printf(" [TRACE] Running on child process => PID_CHILD = %d \n", getpid());	

             // Close file descriptors, in order to disconnect the process from the terminal.
             // This procedure allows the process to be launched as a daemon (aka service).
             close(STDOUT_FILENO);
             close(STDERR_FILENO);
             close(STDIN_FILENO );

             // Execvp system call, replace the image of this process with a new one
             // from an executable. 
             execvp_cpp(app, args);		
             return;
        }

        std::printf(" [TRACE] <AFTER FORK> PID of parent process = %d \n", getpid());

        // pid_t waitpid(pid_t pid, int *wstatus, int options);
        int status;

        std::printf(" [TRACE] Waiting for child process to finish. ");

        // Wait for child process termination.
        // From header: #include <sys/wait.h>
        if(waitpid(pid, &status, 0) == -1)
        {
            print_errno_details(errno);
            throw std::runtime_error("Error: cannot wait for child process");
        }

        std::printf(" [TRACE] Child process has been terminated Ok.");
       // -------- Parent process ----------------//
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
   $ >> g++ unix-process.cpp -o unix-process.bin -std=c++1z -Wall -Wextra -g
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   ~/t/unix-explore
   $ >> ./unix-process.bin 0
   [INFO] Program started. 

   ~/t/unix-explore
   $ >> ./unix-process.bin 1
   [INFO] Program started. 

   ~/t/unix-explore
   $ >> ./unix-process.bin 2
   [INFO] Program started. 
   [TRACE] <BEFORE FORK> PID of parent process = 774929 
   [TRACE] <AFTER FORK> PID of parent process = 774929 
   [TRACE] Running on child process => PID_CHILD = 774930 
   [TRACE] Waiting for child process to finish.  [TRACE] Child process has been terminated Ok. [TRACE] Finish execution. 
#+END_SRC
** Reading subprocess output via Popen() 

The convenience function popen(), which is a combination of fork() +
exec() and pipe() functions, allows reading a subprocess
output. Note: this function is also available on Windows.

Header: 
  + <stdio.h> in C
  + <cstdio> in C++ 

 *Documentation*

  + [[https://pubs.opengroup.org/onlinepubs/009695399/functions/popen.html][Popen - opengroup()]] 

  + [[https://www.freebsd.org/cgi/man.cgi?query=popen&sektion=3&manpath=freebsd-release-ports][FreeBSD Documentation]]

  + [[https://en.m.wikipedia.org/wiki/Pipeline_(Unix)][Ppeline (Unix)]]

 *Functions*

Popen: 
   + This function executes: 'sh -c <COMMAND>' via, fork() + exec()
     and pipe(), returning a file stream. Note: sh is a unix-shell.

#+BEGIN_SRC cpp 
   FILE* popen(const char* command, const char* mode); 
#+END_SRC

Pclose

#+BEGIN_SRC cpp
  int  pclose(FILE* stream);
#+END_SRC

  *Sample Application* 

File: popen-test.cpp

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string> 

  // Provides; popen(), pclose()
  #include <cstdio>

  int main(int argc, char** argv)
  {
       std::puts("\n === EXPERIMENT 1 - popen() using buffer ========\n");
       {
           // Equivalent to: fork() + exec() + pipe()
           FILE* fd = popen("ls /", "r");

           if(fd == nullptr){
              fprintf(stderr, "Error: failed to run command. Check ERRNO variable. \n");
              return EXIT_FAILURE;
           }

           constexpr size_t BUFFER_SIZE = 500;
           // Buffer initialized with null char 
           char buffer[BUFFER_SIZE] = {0};

           while( fgets(buffer, BUFFER_SIZE, fd) != nullptr )
           {
              fprintf(stdout, "%s", buffer);
           }

           pclose(fd);		
       }

       std::puts("\n === EXPERIMENT 2 - popen() reading line-by-line ========\n");
       {
           FILE* fd = popen("ps -ef", "r");
           char*   pline = nullptr; 
           size_t  size  = 0; 
           ssize_t nread = 0;
           int     count = 0;
           do {
              nread = getdelim(&pline, &size, '\n', fd);
              std::cout << "  [" << count++ << "]" << " => " << pline;
           } while( nread != -1 && count < 8);
           pclose(fd);
       }

       return EXIT_SUCCESS;
  }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ popen-test.cpp -o popen-test -std=c++1z -Wall -Wextra -g
#+END_SRC

Running: 

#+BEGIN_SRC sh 
      $ ./popen-test 

       === EXPERIMENT 1 - popen() using buffer ========

      bin
      boot
      dev
      etc
      home
    . .... ... ... ... 
      ... ... ... ... ...
      usr
      var

       === EXPERIMENT 2 - popen() reading line-by-line ========

        [0] => UID          PID    PPID  C STIME TTY          TIME CMD
        [1] => root           1       0  0 Jun08 ?        00:48:25 /usr/lib/systemd/systemd ... ... ...
        [2] => root           2       0  0 Jun08 ?        00:00:00 [kthreadd]
        [3] => root           3       2  0 Jun08 ?        00:00:00 [rcu_gp]
        [4] => root           4       2  0 Jun08 ?        00:00:00 [rcu_par_gp]
        [5] => root           6       2  0 Jun08 ?        00:00:00 [kworker/0:0H-events_highpri]
        [6] => root           9       2  0 Jun08 ?        00:00:00 [mm_percpu_wq]
        [7] => root          10       2  0 Jun08 ?        00:00:54 [ksoftirqd/0]
#+END_SRC

** Unix Pipes - Inter Process Communication 

Unix pipe is an inter-process communication facility which allows the
output of a process to be the input of a another. It can be used for
reading the output of a subprocess. 

 *Documentation* 

   + [[https://www.freebsd.org/cgi/man.cgi?pipe(2)][FreeBSD - pipe()]]

   + [[https://linuxhint.com/dup2_system_call_c/][Dup2 - system call]]

   + [[https://en.wikipedia.org/wiki/Dup_(system_call)][Dup (system call)]]

   + [[https://www.gnu.org/software/libc/manual/html_node/Duplicating-Descriptors.html][Duplicating Descriptors - GNU GlibC]]

   + [[https://www-users.cs.umn.edu/~kauffman/4061/05-io-files-pipes.pdf][CSCI 4061: Input/Output with Files, Pipes]]

   + http://unixwiz.net/techtips/remap-pipe-fds.html

   + [[https://users.cs.cf.ac.uk/Dave.Marshall/C/node23.html][Inter Process Communication (IPC), pipes]]

   + [[http://perugini.cps.udayton.edu/teaching/books/SPUC/www/lecture_notes/pipes.html][IPC - I/O Redirection & IPC, & Special Files: Unamed & Named Pipes, FIFOs]]

   + [[https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf][Chapter 5 - Writing Your Own Shell]]

 *Main Functions* 

Function pipe()

  + Encapsulates: pipe() system-call

  + Linux Manpage: "pipe() creates a pipe, a unidirectional data
    channel that can be used for interprocess communication.  The
    array pipefd is used to return two file descriptors referring to
    the ends of the pipe.  pipefd[0] refers to the read end of the
    pipe.  pipefd[1] refers to the write end of the pipe."

  + pipefd[0] => File descriptor for reading the pipe.

  + pipefd[1] => File descriptor for writing to the pipe.

#+BEGIN_SRC cpp 
   #include <unistd.h>

   int pipe(int pipefd[2]);
#+END_SRC

Function dup2()

  + Encapsulates: dup2() system-call 

  + Duplicate file descriptor, used for IO redirection.

  + dup2( fd1, STDOUT_FILENO ) => Example: redirect current process'
    stdout to file descriptor fd1. 

#+BEGIN_SRC cpp 
   int dup2(int oldfd, int newfd);
#+END_SRC

  *Sample Code* 

This code spawns a subprocess using fork() + exec() and uses pipes to
read the subprocess output which are stdout and stderr of the "ls -l -a /".  

File: pipe-test.cpp

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 

   // ---- Unix headers --------// 
   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/wait.h>


   int main(int argc, char** argv)
   {	
       /** Application to be called or its absolute path */
       const char* app = "ls";

       // Arguments ('-l' '-a' '/') for ls -l -a /
       const char* args [] = { /* First argument - process name (can be anything)   */  
                                "ls" 
                               /* Arguments passed to application */
                               , "-l", "-a", "/"
                               /* Sentinel value - always nullptr */
                               , nullptr  
                            };

       constexpr size_t PIPE_READ = 0;
       constexpr size_t PIPE_WRITE = 1;

       int fd[2];

       // ----- Create pipe IPC channel --------//
       if( pipe(fd) == -1){
          std::fprintf(stderr, "Error: cannot create pipe \n");
          return EXIT_FAILURE;
       }

       // ----------- Fork() ----------------//

       pid_t cpid = fork();
       if(cpid == -1)
       {
            std::fprintf(stderr, "Error: unable to launch process \n");
            return EXIT_FAILURE;         
       }
       if(cpid == 0)
       {
           /** ------- BEGIN of child process ------ **/
           std::printf(" [TRACE] Child process => PID_CHILD = %d \n", getpid());  		

           // Connect child process' stdin to read-end of the pipe.
           dup2( fd[PIPE_READ], STDIN_FILENO );

           // Redirect child process' stdout (STDOUT_FILENO) to the write-end of the pipe. 
           dup2( fd[PIPE_WRITE], STDOUT_FILENO );
           // Redirect child process' stderr to write-end of the pipe.
           dup2( fd[PIPE_WRITE], STDERR_FILENO );

           // Run process - exec() syscall => the new process image 
           // has the same PID as the child process. 
           execvp(app, (char *const *) args);
           return 0;          
           /** ------- END of child process ------ **/
        }

        // ---- Continue parent process ---------//

        std::printf(" [TRACE] <AFTER FORK> PID of parent process = %d \n", getpid());
        constexpr size_t BUFSIZE = 200;
        ssize_t nread = 0;
        char buffer[BUFSIZE];

        // Close unnused end of the pipe.
        close(fd[PIPE_WRITE]);

        // Write bytes read from the pipe (write-end), written by child process
        // , to the stdout.
        do {	
             nread = read( fd[PIPE_READ], &buffer, BUFSIZE);
             write(STDOUT_FILENO, buffer, nread);		
        } while ( nread > 0);

        std::printf(" [TRACE] Waiting for child process termination. \n");

        close(fd[PIPE_READ]);

        // Wait for child process termination 
        ::wait(nullptr);
        return EXIT_SUCCESS;

        } // -- End of main() --- //
#+END_SRC

Building: 

#+BEGIN_SRC cpp 
   $ >> g++ pipe-test.cpp -o pipe-test.bin -std=c++1z -g -Wall -Wextra
#+END_SRC

Running:

#+BEGIN_SRC cpp
    $ >> ./pipe-test.bin 
    [TRACE] <AFTER FORK> PID of parent process = 1352693 
    [TRACE] Child process => PID_CHILD = 1352694 
   total 72
   dr-xr-xr-x.  18 root root  4096 May 17 21:36 .
   dr-xr-xr-x.  18 root root  4096 May 17 21:36 ..
   -rw-r--r--    1 root root     0 May 17 21:36 .autorelabel
   lrwxrwxrwx.   1 root root     7 Jan 28 15:30 bin -> usr/bin
   dr-xr-xr-x.   6 root root  4096 May 17 15:17 boot
   drwxr-xr-x   21 root root  4200 Jun 28 19:22 dev
   ... ... ... ... ... ... ... ... ... ... 
   ... ... ... ... ... ... ... ... ... ... ... ... 
   lrwxrwxrwx.   1 root root     8 Jan 28 15:30 sbin -> usr/sbin
   drwxr-xr-x.   2 root root  4096 May 12 14:50 srv
   dr-xr-xr-x   13 root root     0 Jun  8 11:58 sys
   drwxrwxrwt   31 root root   680 Jun 30 04:02 tmp
   drwxr-xr-x.  12 root root  4096 Apr 22 19:35 usr
   drwxr-xr-x.  22 root root  4096 Apr 22 19:39 var
    [TRACE] Waiting for child process termination. 
#+END_SRC

** Reading/Listings directory contents 

API Documentations: 
 
  + [[https://man7.org/linux/man-pages/man3/opendir.3.html][Linux Manpage - opendir()]]

  + [[https://www.freebsd.org/cgi/man.cgi?query=opendir&sektion=3][FreeBSD manpage - opendir()]]

  + [[https://www.man7.org/linux/man-pages/man3/readdir.3.html][Linux manpage - readdir()]]

Functions used: 

#+BEGIN_SRC cpp 
   DIR *opendir(const char *name);

   int readdir(   unsigned int fd
                , struct old_linux_dirent* dirp,
                , unsigned int count);
#+END_SRC

File: unix-readdir.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>

   // #include <string>
   #include <sys/types.h>
   #include <dirent.h>  // Get function opendir
   #include <errno.h>

   #include <sys/types.h>
   #include <sys/stat.h>
   #include <unistd.h>


   template<typename Callback>
   void iterate_directory(const std::string& path, Callback&& callback)
   {
       DIR *dir;
       struct dirent *dp;

       dir = opendir(path.c_str()) ;

       // To determine the cause of error - It is necessary to check the error code.
       if (dir == nullptr) throw std::runtime_error("Error: Cannot read directory");

       while ((dp = readdir(dir)) != nullptr) 
       {
          if(path == "/")
               callback(dp->d_name);
          else 
               callback(path + "/" + dp->d_name);		
       };
       closedir(dir);
   }

   int main(int argc, char** argv)
   {
        std::cout << " List directory contents " << std::endl;

        if(argc < 2)
        {
            std::cout << "Usage: ./unix-readdir <DIRECTORY>" << "\n";
            return EXIT_SUCCESS;
        }

        int idx = 0;
        iterate_directory(argv[1], [&idx](auto const& path)
        {
            std::cout << "  [" << idx++  << "] path => " << path << "\n";
        });
        return EXIT_SUCCESS;
   }

#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ unix-readdir.cpp -o unix-readdir.bin -std=c++1z -g -Wall -Wextra 
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ >> ./unix-readdir.bin /
   List directory contents 
    [0] path => srv
    [1] path => sys
    [2] path => ..
    [3] path => opt
    [4] path => .
    [5] path => run
    [6] path => media
    ... ... ... 
    [18] path => lib
    [19] path => usr
    [20] path => boot
    [21] path => mnt
    [22] path => sbin
  ... .. .... ... ... 

   $ >> ./unix-readdir.bin /boot 
   List directory contents 
    [0] path => /boot/..
    [1] path => /boot/.
    [2] path => /boot/initramfs-5.6.12-300.fc32.x86_64.img
    [3] path => /boot/grub2
    [4] path => /boot/vmlinuz-0-rescue-a1ac43b933e24659bba5edf2b9cec1e1
    [5] path => /boot/memtest86+-5.01
    [6] path => /boot/initramfs-5.6.6-300.fc32.x86_64.img
     ... ... ...     ... ... ...     ... ... ...     ... ... ...     
#+END_SRC
** Memory Mapped Files - mmap 
*** Overview 

File mapping is an operating system mechanism which maps a disk file
to a process virtual memory. This operating system feature allows
accessing the file as it was in the process memory. 

Benefits: 

  + Transparent access to file, allows accessing the file as it was an
    ordinary memory. (the file is accessible by pointer)

  + Good for processing large files which does not fit in the machine
    RAM memory.

Use-cases: 
  
  + Read large files

  + IPC - Inter-Process Communication 

  + Process complicated binary files

  + Modify complex binary files. The file can be modified by just
    changing a memory, in other words, modifying the contents of a
    memory address. 

  + Implement JIT - Just-In-Time compiler and execute assembly code at runtime.

The _mmap API_ is available in most Unix-like operating systems: 

  + Linux
  + BSD-family: MacOSX, FreeBDS, NetBSD, OpenBSD
  + Solaris 
  + QNX, AIX

  *Mmap API functions*

File descriptors: 

#+BEGIN_SRC cpp 
    #include <unistd.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>

    // Returns file descriptor of a disk-file 
    int open(const char *pathname, int flags);

    // Close file descriptor (release resource)
    int close(int fd);
#+END_SRC

Mmap: 

  + Doc: $ man mmap
  + Linux Manpage Description: "mmap() creates a new mapping in the
    virtual address space of the calling process.  The starting
    address for the new mapping is specified in addr.  The length
    argument speci‐ fies the length of the mapping (which must be
    greater than 0)"

  + Argument: _prot_ (Memory Protection)
    + PROT_READ  => Pages may be written (most used)
    + PROT_WRITE => Pages may be written (allows changing the file by writing to the mapped memory)
    + PROT_NONE  => Pages may not be accessed
    + PROT_EXEC  => Pages may be executed => Allows executing machine
      code (assembly) at runtime. Use case: JIT - Just-In-Time
      compiler

  + Argument: _flags_
    + MAP_SHARED  => Multiple processes can share the same _file_
                  _mapping_. This flag is used for IPC - Inter Process
                  Communication. 
    + MAP_PRIVATE => Only the current process can access the file mapping.

#+BEGIN_SRC cpp 
   #include <sys/mman.h>

   void* mmap(  void*   addr    // (often nullptr) Address that the file will be mapped 
              , size_t  length  // Length of file mapping (often the file size)
              , int     prot    // Flags for memory protection 
              , int     flags   // Flags for process access conttrol (private | shared)
              , int     fd      // File descriptor to be mapped into virtual memory
              , off_t   offset  // (often zero) Offset from the beginning of the file 
             );
#+END_SRC

munmap:

  + Doc: $ man munmap
  + Linux Manpage doc: "The munmap() system call deletes the mappings
    for the specified address range, and causes further references to
    addresses within the range to generate invalid memory ref‐
    erences.  The region is also automatically unmapped when the
    process is terminated.  On the other hand, closing the file
    descriptor does not unmap the region."

  + Param _addr_: Address of memory mapping (value returned by mmap)

  + Param _length:_ length of file mapping, often it is the file size.

#+BEGIN_SRC cpp 
    // For mmap and munmap 
    #include <sys/mman.h>     

    int munmap( void *addr, size_t length);
#+END_SRC

Hyperlinks to manpage documentation of related-functions: 

  + [[https://linux.die.net/man/2/mmap][mmap]] (Linux manpage)

  + [[https://linux.die.net/man/2/remap_file_pages][remap_file_pages]]

  + [[https://linux.die.net/man/2/mremap][mremap]] (Linux manpage)

  + [[https://linux.die.net/man/2/msync][msync]]


 *References and further reading* 

General: 

   + [[https://en.wikipedia.org/wiki/Mmap][mmap - Wikipedia]]

   + [[https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemAdvancedPT/MappingFilesIntoMemory/MappingFilesIntoMemory.html][Apple - Mapping Files Into Memory]]

   + [[https://upsilon.cc/~zack/teaching/1415/progsyst/cours-05-mmap.pdf][Programmation SystèmeCours 5 — Memory Mapping]] ([[http://web.archive.org/web/20200622232258/https://upsilon.cc/~zack/teaching/1415/progsyst/cours-05-mmap.pdf][Web Archive]])

   + [[https://unix.stackexchange.com/questions/474926/how-does-memory-mapping-a-file-have-significant-performance-increases-over-the-s/475014][How does memory mapping a file have significant performance increases over the standard I/O system calls?]]

   + [[https://courses.engr.illinois.edu/cs241/sp2014/lecture/27-IPC.pdf][Interprocess Communication: Memory mapped files and pipes]]

   + [[http://web.cs.ucla.edu/honors/UPLOADS/kousha/thesis.pdf][Linux Memory Mapped System Call Performance]]

   + [[https://w3.cs.jmu.edu/kirkpams/OpenCSF/Books/csf/html/MMap.html][Shared Memory with Memory-Mapped Files]]

   + [[https://www.sublimetext.com/blog/articles/use-mmap-with-care][Use mmap With Care - Sublime HQ]]

   + [[http://www.idryman.org/blog/2017/06/28/opic-a-memory-allocator-for-fast-serialization/][Writing a Memory Allocator for Fast Serialization]]

   + [[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2044.html][Paper: Memory Mapped Files And Shared Memory For C++]]

   + [[https://indico.cern.ch/event/658060/contributions/2898569/attachments/1622526/2582399/pivarski-serialization.pdf][Overview of Serialization Technologies]] - CERN

   + [[https://www.usenix.org/sites/default/files/conference/protected-files/hotstorage17_slides_choi.pdf][Efficient Memory Mapped File I/O for In-Memory File Systems]]

   + [[https://engineering.mongodb.com/post/getting-storage-engines-ready-for-fast-storage-devices][Getting storage engines ready for fast storage devices]]

   + [[http://blogs.networkingfutures.co.uk/post/2015/12/28/Windows-Services-Implementing-Non-Persisted-Memory-Mapped-Files-Exposing-IPC-Style-Communications.aspx][Introduction to Memory Mapped Files]] (.NET Specific)


MMAP - File Memory Mapping for other programming languages

   + https://docs.rs/flatdata/0.5.0/flatdata/ (Rust library for mmap)

   + [[https://www.red-gate.com/simple-talk/dotnet/net-development/sharing-caring-using-memory-mapped-files-net/][Sharing is Caring: Using Memory Mapped Files in .NET]]

   + [[https://coders-corner.net/2013/03/22/inter-process-communication-with-memory-mapped-files-part-01-transfer-a-data-structure-and-an-object/][Inter-Process Communication with Memory-Mapped Files, Part 01]]

   + [[https://github.com/jampp/sharedbuffers/][Python SharedBuffer - library for mmap]]

   + https://docs.julialang.org/en/v1/stdlib/Mmap/ - Julia Language library for mmap (memory-mapped files)

   + [[https://engineering.indeedblog.com/blog/2015/02/memory-mapping-with-util-mmap/][Memory Mapping with util-mmap]] - mmap for Java.
*** Example (C) - mmap for reading Windows PE32 files 

This code uses mmap API (memory mapped files) for reading metadata
from PE (Portable Executable) - Windows native executable files or
windows object-code. 

GIST: 
  + https://gist.github.com/166265f6dc85c8d9cc2dc00253caae78

File: unix-mmap.c 

#+BEGIN_SRC cpp 
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h> 
    #include <assert.h>

    // --- Unix/Posix headers ---------//
    #include <unistd.h>
    #include <sys/mman.h>
    #include <sys/stat.h>
    #include <fcntl.h>

    #define IMAGE_SIZEOF_SHORT_NAME            8
    #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES  16

    typedef int32_t  LONG;
    typedef uint16_t WORD;
    typedef uint32_t DWORD;
    typedef uint8_t  BYTE;
    typedef uint64_t ULONGLONG;;

    // Source: <winttt.h>  => Original: typedef struct _IMAGE_DOS_HEADER
    typedef struct {            
        WORD   e_magic;                     
        WORD   e_cblp;                   
        WORD   e_cp;                     
        WORD   e_crlc;                   
        WORD   e_cparhdr;                
        WORD   e_minalloc;               
        WORD   e_maxalloc;               
        WORD   e_ss;                     
        WORD   e_sp;                     
        WORD   e_csum;                   
        WORD   e_ip;                     
        WORD   e_cs;                     
        WORD   e_lfarlc;                 
        WORD   e_ovno;                   
        WORD   e_res[4];                 
        WORD   e_oemid;                  
        WORD   e_oeminfo;                
        WORD   e_res2[10];               
        //  Offset to the PE header from the beginning of the file. 
        LONG   e_lfanew;                    
      } IMAGE_DOS_HEADER;

     typedef struct {
        DWORD Signature; 
        WORD  Machine;
        WORD  NumberOfSections;
        DWORD TimeDateStamp;
        DWORD PointerToSymbolTable;
        DWORD NumberOfSymbols;
        WORD  SizeOfOptionalHeader;
        WORD  Characteristics;
     } PE_HEADER;


    ssize_t get_file_size(int fd)
    {
        struct stat file_stat; 
        if( fstat(fd, &file_stat) == -1 )
            return -1;
        return file_stat.st_size;
    }

    int main(int argc, char** argv)
    {   
        // ----------- Validate arguments ----------------------------//
        if(argc < 2)
        {
            fprintf(stderr, "Usage: /unix-mmap <FILE> \n");
            return EXIT_FAILURE;
        }

        // ----------- Get file descriptor ----------------------------//

        // Get read-only file descriptor of file 
        int fd = open(argv[1], O_RDONLY);
        if(fd == -1){
            fprintf(stderr, " Error: unable to open file. check ERRNO variable \n");
            return EXIT_FAILURE;
        }

        ssize_t size = get_file_size(fd);
        if(size == -1){
            fprintf(stderr, " Error: unable to get file size \n");
            return EXIT_FAILURE;
        }

        // ----------- Map file in to process' virtual memory ---------------------------//

        void* fmap = mmap(    NULL        /* Often set to zero, aka nullpointer           */
                            , size        /* Size of file mapping in bytes                */
                            , PROT_READ   /* Open in read-only mode                       */
                            , MAP_PRIVATE /* Only this process can access this memory-map */
                            , fd          /* File descriptor of file to be memory mapped  */
                            , 0x00        /* Offset from the beggining of the file        */
                         );

        if( fmap == MAP_FAILED)
        {
            fprintf(stderr, " Error: memory mapped failed. check ERRNO \n");
            return EXIT_FAILURE;
        }

        // --------- Process file -----------------------------------------// 

        unsigned char* bmap = (unsigned char*) fmap; 

        // char file_signature [2] = { bmap[0], bmap[1], bmap[2], bmap[3], 0x00 };
        printf(" File signature = %c %c 0x%X 0x%X \n", bmap[0], bmap[1], bmap[2], bmap[3]);

        IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*) fmap;
        PE_HEADER*        pe_header  = fmap + dos_header->e_lfanew;

        assert( pe_header->Signature == 0x4550 );

        printf("\n ========= [DOS HEADER] =================\n");
        printf("   MAGIC NUMBER = 0x%X (hex) \n", dos_header->e_magic);
        printf("   MAGIC NUMBER = %c %c  (str) \n", dos_header->e_magic & 0xFF, (dos_header->e_magic >> 8) & 0xFF);
        printf("       e_lfanew = 0x%X \n",      dos_header->e_lfanew);

        printf("\n ======== [PE - Header] ================\n");
        printf(" Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 \n");
        printf("\n");
        printf("          Signature = 0x%X \n", pe_header->Signature);
        printf("            Machine = 0x%X \n", pe_header->Machine);
        printf(" Number of sections = %d \n",   pe_header->NumberOfSections);

        // ---------- Release Resource ------------------------------------// 

        // Unmap memory segment 
        munmap(fmap, size);
        // Release file-descriptor resource
        close(fd);

        return 0;
    } // --- End of main() ----// 


#+END_SRC

Build: 

#+BEGIN_SRC sh 
  $ gcc unix-mmap.c -o unix-mmap-c.bin -Wall -Wextra -g
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   $ ./unix-mmap-c.bin notepad.exe 
    File signature = M Z 0x90 0x0 

    ========= [DOS HEADER] =================
      MAGIC NUMBER = 0x5A4D (hex) 
      MAGIC NUMBER = M Z  (str) 
          e_lfanew = 0xF8 

    ======== [PE - Header] ================
    Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 

             Signature = 0x4550 
               Machine = 0x8664 
    Number of sections = 7 
  
#+END_SRC
*** Example (C++) - mmap for reading Windows PE32 files 

GIST: 
  + https://gist.github.com/166265f6dc85c8d9cc2dc00253caae78

File: unix-mmap.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 
   #include <fstream> 
   #include <cstdint> 
   #include <cassert>

   // --- Unix/Posix headers ---------//
   #include <unistd.h>
   #include <sys/mman.h>
   #include <sys/stat.h>
   #include <fcntl.h>

   constexpr size_t IMAGE_SIZEOF_SHORT_NAME = 8;
   constexpr size_t IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;

   // using LONG      = long;
   using LONG      = std::int32_t;
   using WORD      = std::uint16_t;  // unsigned short;
   using DWORD     = std::uint32_t;  // unsigned long; 
   using BYTE      = std::uint8_t;   //unsigned char;
   using ULONGLONG = std::uint64_t;  // unsigned long long 

   // Source: <winttt.h>  => Original: typedef struct _IMAGE_DOS_HEADER
   struct IMAGE_DOS_HEADER {            
       WORD   e_magic;                     
       WORD   e_cblp;                   
       WORD   e_cp;                     
       WORD   e_crlc;                   
       WORD   e_cparhdr;                
       WORD   e_minalloc;               
       WORD   e_maxalloc;               
       WORD   e_ss;                     
       WORD   e_sp;                     
       WORD   e_csum;                   
       WORD   e_ip;                     
       WORD   e_cs;                     
       WORD   e_lfarlc;                 
       WORD   e_ovno;                   
       WORD   e_res[4];                 
       WORD   e_oemid;                  
       WORD   e_oeminfo;                
       WORD   e_res2[10];               
       //  Offset to the PE header from the beginning of the file. 
       LONG   e_lfanew;                    
     };

    struct PE_HEADER
    {
       DWORD Signature; 
       WORD  Machine;
       WORD  NumberOfSections;
       DWORD TimeDateStamp;
       DWORD PointerToSymbolTable;
       DWORD NumberOfSymbols;
       WORD  SizeOfOptionalHeader;
       WORD  Characteristics;
    };


   ssize_t get_file_size(int fd)
   {
       struct stat file_stat; 
       if( fstat(fd, &file_stat) == -1 )
           throw std::runtime_error("Error: unable to get file size");
       return file_stat.st_size;
   }

   int main(int argc, char** argv)
   {   
       // ----------- Validate arguments ----------------------------//
       if(argc < 2)
       {
           std::fprintf(stderr, "Usage: /unix-mmap <FILE> \n");
           return EXIT_FAILURE;
       }

       // ----------- Get file descriptor ----------------------------//

       // Get read-only file descriptor of file 
       int fd = open(argv[1], O_RDONLY);
       if(fd == -1){
           std::fprintf(stderr, " Error: unable to open file. check ERRNO variable \n");
           return EXIT_FAILURE;
       }

       ssize_t size = get_file_size(fd);

       // ----------- Map file in to process' virtual memory ---------------------------//

       void* fmap = mmap(    nullptr     /* Often set to zero, aka nullpointer           */
                           , size        /* Size of file mapping in bytes                */
                           , PROT_READ   /* Open in read-only mode                       */
                           , MAP_PRIVATE /* Only this process can access this memory-map */
                           , fd          /* File descriptor of file to be memory mapped  */
                           , 0x00        /* Offset from the beggining of the file        */
                        );

       if( fmap == MAP_FAILED)
       {
           std::fprintf(stderr, " Error: memory mapped failed. check ERRNO \n");
           return EXIT_FAILURE;
       }

       // --------- Process file -----------------------------------------// 

       const auto bmap = reinterpret_cast<unsigned char*>(fmap); 

       // char file_signature [2] = { bmap[0], bmap[1], bmap[2], bmap[3], 0x00 };
       std::printf(" File signature = %c %c 0x%X 0x%X \n", bmap[0], bmap[1], bmap[2], bmap[3]);

       IMAGE_DOS_HEADER* dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(fmap);
       PE_HEADER*        pe_header  = reinterpret_cast<PE_HEADER*>( (uintptr_t) fmap + dos_header->e_lfanew);

       assert( pe_header->Signature == 0x4550 );

       std::printf("\n ========= [DOS HEADER] =================\n");
       std::printf("   MAGIC NUMBER = 0x%X (hex) \n", dos_header->e_magic);
       std::printf("   MAGIC NUMBER = %c %c  (str) \n", dos_header->e_magic & 0xFF, (dos_header->e_magic >> 8) & 0xFF);
       std::printf("       e_lfanew = 0x%X \n",      dos_header->e_lfanew);

       std::printf("\n ======== [PE - Header] ================\n");
       std::printf(" Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 \n");
       std::printf("\n");
       std::printf("          Signature = 0x%X \n", pe_header->Signature);
       std::printf("            Machine = 0x%X \n", pe_header->Machine);
       std::printf(" Number of sections = %d \n",   pe_header->NumberOfSections);


       // ---------- Release Resource ------------------------------------// 

       // Unmap memory segment 
       munmap(fmap, size);
       // Release file-descriptor resource
       close(fd);

       return 0;
   } // --- End of main() ----// 


#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ clang++ unix-mmap.cpp -o unix-mmap.bin -std=c++1z -Wall -Wextra -g
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   $ ./unix-mmap.bin ipconfig.exe 
    File signature = M Z 0x90 0x0 

    ========= [DOS HEADER] =================
      MAGIC NUMBER = 0x5A4D (hex) 
      MAGIC NUMBER = M Z  (str) 
          e_lfanew = 0xE8 

    ======== [PE - Header] ================
    Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 

             Signature = 0x4550 
               Machine = 0x8664 
    Number of sections = 6 


   $ ./unix-mmap.bin notepad.exe 
    File signature = M Z 0x90 0x0 

    ========= [DOS HEADER] =================
      MAGIC NUMBER = 0x5A4D (hex) 
      MAGIC NUMBER = M Z  (str) 
          e_lfanew = 0xF8 

    ======== [PE - Header] ================
    Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 

             Signature = 0x4550 
               Machine = 0x8664 
    Number of sections = 7 
#+END_SRC
*** Example (C++) - mmap for reading Windows PE32 with class 

This code uses a class FileMapping for encapsulating Unix
memory-mapped files which simplifies the usage of the mmap feature and
makes the code cleaner and safer. 

GIST: 
  + https://gist.github.com/166265f6dc85c8d9cc2dc00253caae78

File: unix-mmap-class.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 
   #include <fstream> 
   #include <cstdint> 
   #include <cassert>

   // --- Unix/Posix headers ---------//
   #include <unistd.h>
   #include <sys/mman.h>
   #include <sys/stat.h>
   #include <fcntl.h>

   constexpr size_t IMAGE_SIZEOF_SHORT_NAME = 8;
   constexpr size_t IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;

   // using LONG      = long;
   using LONG      = std::int32_t;
   using WORD      = std::uint16_t;  // unsigned short;
   using DWORD     = std::uint32_t;  // unsigned long; 
   using BYTE      = std::uint8_t;   //unsigned char;
   using ULONGLONG = std::uint64_t;  // unsigned long long 

   // Source: <winttt.h>  => Original: typedef struct _IMAGE_DOS_HEADER
   struct IMAGE_DOS_HEADER {            
       WORD   e_magic;                     
       WORD   e_cblp;                   
       WORD   e_cp;                     
       WORD   e_crlc;                   
       WORD   e_cparhdr;                
       WORD   e_minalloc;               
       WORD   e_maxalloc;               
       WORD   e_ss;                     
       WORD   e_sp;                     
       WORD   e_csum;                   
       WORD   e_ip;                     
       WORD   e_cs;                     
       WORD   e_lfarlc;                 
       WORD   e_ovno;                   
       WORD   e_res[4];                 
       WORD   e_oemid;                  
       WORD   e_oeminfo;                
       WORD   e_res2[10];               
       //  Offset to the PE header from the beginning of the file. 
       LONG   e_lfanew;                    
     };

    struct PE_HEADER
    {
       DWORD Signature; 
       WORD  Machine;
       WORD  NumberOfSections;
       DWORD TimeDateStamp;
       DWORD PointerToSymbolTable;
       DWORD NumberOfSymbols;
       WORD  SizeOfOptionalHeader;
       WORD  Characteristics;
    };

   /** Class for encapsulating memory mapped files*/
   class FileMapping
   {
       int   m_fd      = -1; 
       void* m_addr    = nullptr; 
       ssize_t m_size  = -1;

       ssize_t get_file_size(int fd)
       {
           struct stat file_stat; 
           if( fstat(fd, &file_stat) == -1 )
               throw std::runtime_error("Error: unable to get file size");
           return file_stat.st_size;
       }

   public: 
       // Disable copy constructor 
       FileMapping(FileMapping const&) = delete;
       // Disable copy assignment operator 
       FileMapping& operator=(FileMapping const&) = delete;    

       /** 
        * @param file_path - File to be memory-mapped to current process. 
        */
       FileMapping(std::string file_path)
       {
           // Get read-only file descriptor of file 
           m_fd = open(file_path.c_str(), O_RDONLY);        
           if(m_fd == -1){
               throw std::runtime_error("Unable to open file");
           }      

           m_size = get_file_size(m_fd);
           if(m_size == -1)
               throw std::runtime_error("Unable to get file size");


           m_addr = ::mmap( nullptr     
                           , m_size       
                           , PROT_READ   
                           , MAP_PRIVATE 
                           , m_fd        
                           , 0x00        
                       );
           if( m_addr == MAP_FAILED)
           {
               throw std::runtime_error("Error: failed to map file to memory");
           }

       }

       ~FileMapping()
       {
           // Unmap memory segment 
           munmap(m_addr, m_size);
           // Release file-descriptor resource
           close(m_fd);

           m_fd = -1;
           m_addr = nullptr;
           m_size = -1;
       }

       /** @brief Returns pointer file mapping address. */
       void* addr() const { return m_addr; }  

       /** @brief  Get casted pointer to an offset of the file mapping address. */
       template<typename T>
       T addr_rel(std::ptrdiff_t offset) const { 
           return reinterpret_cast<T>( reinterpret_cast<uintptr_t>(m_addr) + offset);  
       }

   }; // --- End of class FileMapping ---- //


   int main(int argc, char** argv)
   {   
       // ----------- Validate arguments ----------------------------//
       if(argc < 2)
       {
           std::fprintf(stderr, "Usage: /unix-mmap <FILE> \n");
           return EXIT_FAILURE;
       }

       FileMapping fmap(argv[1]);

       // --------- Process file -----------------------------------------// 

       const auto bmap = fmap.addr_rel<unsigned char*>(0x00);

       // char file_signature [2] = { bmap[0], bmap[1], bmap[2], bmap[3], 0x00 };
       std::printf(" File signature = %c %c 0x%X 0x%X \n", bmap[0], bmap[1], bmap[2], bmap[3]);

       IMAGE_DOS_HEADER* dos_header = fmap.addr_rel<IMAGE_DOS_HEADER*>(0x00);
       PE_HEADER*        pe_header  = fmap.addr_rel<PE_HEADER*>( dos_header->e_lfanew);

       assert( pe_header->Signature == 0x4550 );

       std::printf("\n ========= [DOS HEADER] =================\n");
       std::printf("   MAGIC NUMBER = 0x%X (hex) \n", dos_header->e_magic);
       std::printf("   MAGIC NUMBER = %c %c  (str) \n", dos_header->e_magic & 0xFF, (dos_header->e_magic >> 8) & 0xFF);
       std::printf("       e_lfanew = 0x%X \n",      dos_header->e_lfanew);

       std::printf("\n ======== [PE - Header] ================\n");
       std::printf(" Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 \n");
       std::printf("\n");
       std::printf("          Signature = 0x%X \n", pe_header->Signature);
       std::printf("            Machine = 0x%X \n", pe_header->Machine);
       std::printf(" Number of sections = %d \n",   pe_header->NumberOfSections);

       return 0;
   } // --- End of main() ----// 


#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ unix-mmap-class.cpp -o unix-mmap-class.bin -std=c++1z -g -Wall -Wextra
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   $ ./unix-mmap-class.bin notepad.exe 
    File signature = M Z 0x90 0x0 

    ========= [DOS HEADER] =================
      MAGIC NUMBER = 0x5A4D (hex) 
      MAGIC NUMBER = M Z  (str) 
          e_lfanew = 0xF8 

    ======== [PE - Header] ================
    Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 

             Signature = 0x4550 
               Machine = 0x8664 
    Number of sections = 7 
#+END_SRC
** Sockets - TCP/IP and Unix Domain Sockets 
*** Overview 

Sockets are inter process communication mechanism, intruduced by Unix
BSD 4.1 circa 1982, which allows multiple processes running at
different machines to communicate across TCP/IP network.

 *Main Implementations*

  + BSD Sockets => Pervarsive on Unix-like operating systems: BSD, Linux, MacOSX, ....,
  + Winsocks    => Microsft Windows only (Windows NT and Windows CE families)

 *Domain and Connection Type*

A socket endpoint is defined by its _domain_ and connection _type_. 

Most common socket domains:

  * AF_INET   => IPv4 - Internet Protocol [Most used]
  * AF_INET6  => IPv6 - Intenert Protocol (IPv6)
  * AF_UNIX   => Unix Domain socket on local machine [Most used]

Most common connection Types: 

  * SOCK_STREAM => [[https://en.wikipedia.org/wiki/Transmission_Control_Protocol][TCP]] - Transmission Control Protocol
  * SOCK_DGRAM  => [[https://en.wikipedia.org/wiki/User_Datagram_Protocol][UDP]] - User Datagram Protocol 
  * SOCK_RAW    => Raw network protocol (Requires root permission)

Socket server or socket client: 

  * socket client
    * => Connects to socket server and always starts the
      connection. Example: curl; web browser (http client); netcat

  * socket server
    * => Listen some port and waits client connection. It can handle
      one or more clients. Example: Http server, nginx, ssh server.

TCP/IP connection tuple: 

   + Hostname or IP address (IPv4 or IPv6)
     + 0.0.0.0     / address used by a socket server for listening all hosts.
     + 127.0.0.1   / Localhost
     + 'localhost' / Local machine 
   + Port number: 16 bits number 

Common TCP/IP Ports: 

   * 20, 21 - FTP server 
   * 22 - SSH server
   * 23 - Telnet (SSH predecessor)
   * 80 - HTTP server
   * 443 - HTTPS (HTTP + SSL/TSL) - Http with SSL encryption
   * 143 - IMAP - Mail
   * 25  - SMTP - Simple Mail Transfer Protocol
   * More at: [[https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers][List of TCP and UDP port numbers]]

 *Further Reading* 

  + [[https://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_10.html][Sockets - Unix Open Group Specification]]

  + [[https://en.wikipedia.org/wiki/Berkeley_sockets][Berkeley sockets (BSD Sockets)]]

  + [[https://www.networkworld.com/article/3327557/using-the-linux-ss-command-to-examine-network-and-socket-connections.html][Using the Linux ss command to examine network and socket connections]]

  + [[http://www.qnx.com/developers/docs/qnx_4.25_docs/tcpip50/prog_guide/sock_ipc_tut.html][QNX - A socket-based IPC tutorial]]

  + [[https://devblogs.microsoft.com/commandline/af_unix-comes-to-windows/][AF_UNIX comes to Windows | Windows Command Line / windows socket network]]

  + [[https://blog.myhro.info/2017/01/how-fast-are-unix-domain-sockets][How fast are Unix Domain Sockets?]]

*** BSD Socket APIs

Headers: 
   + #include <sys/types.h>         
   + #include <sys/socket.h>
   + #include <netdb.h> 

Functions for creating and disposing sockets:  

 + _socket()_
   + Linux Manpage: "socket() creates an endpoint for communication
     and returns a file descriptor that refers to that endpoint.  The
     file descriptor returned by a successful call will be the
     lowest-numbered file descriptor not currently open for the
     process."
   + Note: returns -1 when an error happens and sets the _errno_
     thread-local global variable.

#+BEGIN_SRC cpp 
   int socket(int domain, int type, int protocol);

   // Usage for TCP/IPv4 
   int sockfd = socket(AF_INET, SOCK_STREAM, 0); 
   if(sockfd == -1){ printf("Error: failed to create a socket connect."); abort(); }

   // Usage for UDP/IPv4 
   int sockfd = socket(AF_INET, SOCK_DGRAM, 0); 

   // Usage for Unix socket with TCP 
   int sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

   // Usage for Unix socket with UDP 
   int sockfd = socket(AF_UNIX, SOCK_DGRAM, 0);
#+END_SRC

 + _close()_ => Close file descriptor or socket file descriptor. 

#+BEGIN_SRC cpp 
  int close(int fd);
#+END_SRC

Functions for setting a socket as client-socket: 

  + _connect()_ => Connect a client socket to a given address. On error,
    (-1) is returned. On success, 0 is returned. 

#+BEGIN_SRC cpp 
   int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
#+END_SRC

Functions for setting a socket as a  server socket.

  + _bind()_ [SOCKET SERVER] => Bind a given port for listening income
    connections. (used for socket servers)

#+BEGIN_SRC cpp 
   int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);

    struct sockaddr {
        sa_family_t sa_family;
        char        sa_data[14];
    };
#+END_SRC

  + listen() [SOCKET SERVER]

    + Linux Manpage: "listen() marks the socket referred to by sockfd
      as a passive socket, that is, as a socket that will be used to
      accept incoming connection requests using accept(2)."

    + Linux Manpage: "The backlog argument defines the maximum length
      to which the queue of pending connections for sockfd may grow.
      If a connection request arrives when the queue is full, the
      client may receive an error with an indication of ECONNRE‐ FUSED
      or, if the underlying protocol supports retransmission, the
      request may be ignored so that a later reattempt at connection
      succeeds."

#+BEGIN_SRC cpp 
  int listen(int sockfd, int backlog);
#+END_SRC

  + setsockopt() => Manipulate socket options.
    + Doc: $ man setsockopt

#+BEGIN_SRC cpp 
       int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
#+END_SRC


Functions for sending and receiving messages: 

  + send() => Send a buffer to a socket.
    + Doc: $ man send 

#+BEGIN_SRC cpp 
   ssize_t send(int sockfd, const void *buf, size_t len, int flags);
#+END_SRC

  + recv() => Receive a message from a socket.
    + Doc: $ man recv 

#+BEGIN_SRC cpp 
  ssize_t recv(int sockfd, void *buf, size_t len, int flags);
#+END_SRC

Functions for dealing with network address: 

  + gethostbyname()
    + Translate hostname or IPv4 into IPv4 address. This function
      performs a DNS query. 

#+BEGIN_SRC cpp 
   struct hostent*  gethostbyname(const char* name);

   struct hostent {
       char  *h_name;            /* official name of host */
       char **h_aliases;         /* alias list */
       int    h_addrtype;        /* host address type */
       int    h_length;          /* length of address */
       char **h_addr_list;       /* list of addresses */
   }
   #define h_addr h_addr_list[0] /* for backward compatibility */
#+END_SRC


*** Simple TCP/IP socket echo server 

Description: 

  + Sample code for a single-thread TCP/IP socket server listening at
    port 8095. 

GIST: 
 + https://gist.github.com/6337cd80b9eadad26f386320c1c67cc6

File: socket-echo-server.cpp

#+BEGIN_SRC cpp 
    // File: socket-echo-server.cpp 
    // Desc: Simple socket server with a single thread. 

    #include <iostream>
    #include <string> 
    #include <vector>
    #include <cassert> 
    #include <cstring>  // memcpy 

    // ----- Unix/Linux headers -----// 
    #include <unistd.h>
    #include <fcntl.h>
    #include <sys/types.h>    
    #include <sys/socket.h>
    #include <netdb.h>

    // -------------  MAIN() ------------------------------//

    int main(int argc, char** argv)
    {
         std::puts(" [INFO] Program started. ");

         // The port should be a 16 bits number (Note: binding to some low port numbers 
         // requires administrative/root privilege.)
         std::uint16_t port = 8095;

         // The address can be: 
         //   '0.0.0.0'   for listening all hosts 
         //   '127.0.0.1' for local host 
         const char* hostname = "0.0.0.0";

         // --- Create socket file descriptor -----------------------//

         int sockfd = socket (  AF_INET       // domain:   IPv4
                              , SOCK_STREAM   // type:     TCP 
                              , 0             // protocol: (value 0) 
                             );
         // Returns (-1) on failure 
         assert( sockfd != - 1);

         // ---------- query address ------------------------------//

         // Note: the keyword 'struct' is not necessary here (redundant). 
         struct hostent* h = gethostbyname(hostname);
         assert(h != nullptr);

         struct sockaddr_in sa; 
         // memset(&sa, 0x00, sizeof(sa));
         // set address 
         memcpy(&sa.sin_addr.s_addr, h->h_addr, h->h_length);

         //bcopy( h->h_addr, &sa.sin_addr.s_addr, h->h_length );

         sa.sin_family = AF_INET;
         // The function htons convert a number to big-endian format. 
         sa.sin_port   = htons(port); 

         // ----- Bind to Port and wait for client connections ---------//

         if( ::bind(sockfd, (sockaddr *) &sa, sizeof(sa)) == -1)
         {
             fprintf(stderr, "Error: unable to bind socket \n");
             return EXIT_FAILURE;
         }

         // Enables binding to the same address 
         int enable_reuseaddr = 1;
         if ( setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &enable_reuseaddr, sizeof(int)) < 0 )
         {
             fprintf(stderr, "Error: unable to set socket option. \n");
             return EXIT_FAILURE;
         }

         fprintf(stderr, " [TRACE] Listening client connection \n");

         int backlog = 5;
         assert( listen(sockfd, backlog) != -1 );

         // --------------- Server Main Loop --------------------------//

         // Infinite loop where client connections are handled
         while(true)
         {	
             /* [[ ============== BEGIN client loop =========== ]] */

             struct sockaddr_in client_sa; 
             socklen_t addrlen = sizeof(sockaddr_in); 

             fprintf(stderr, " [TRACE] Waiting for client connection. \n");
             int sock_client = accept(sockfd, (sockaddr *) &client_sa, &addrlen );

             if(sock_client == -1)
             {
                  fprintf(stderr, " Error: failure to handle client socket. Check errno \n");
                  close(sock_client);
                  continue;
             }
             const char* welcome_msg = "\n => [INFO] Hello world client side!! \n";		

             // Send buffer content to client socket 
             send(sock_client, welcome_msg, strlen(welcome_msg), 0);

             char buffer[300];

             while(true){
                 // Read message from client socket 
                 ssize_t n = recv(sock_client, &buffer, 300, 0);
                 if(n == 0){ break; }

                 std::fprintf(stdout, " [INFO] Received: ");			
                 ::write(STDOUT_FILENO, buffer, n);

                 // Send content back 
                 send(sock_client, buffer, n, 0);

                 // Compare 4 first bytes of buffer and 'quit' 
                 if( strncmp(buffer, "quit", 4) == 0)
                 {
                     fprintf(stderr, " [TRACE] Shutdown connection. Ok. \n");
                     // Close client connection 
                     shutdown(sock_client, SHUT_RDWR);
                     close(sock_client);
                     break;
                 }			
             }

         } /* [[ ============== END client loop =========== ]] */

         // Release resource => RAII (Resource-Acquisition-Is-Initialization) fits here. 
         close(sockfd);
         return 0;
    }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ socket-echo-server.cpp -o socket-echo-server.elf -std=c++1z -Wall -Wextra
#+END_SRC

Running server: 

#+BEGIN_SRC sh 
   $ ./socket-echo-server.elf 
    [INFO] Program started. 
    [TRACE] Listening client connection 
    [TRACE] Waiting for client connection. 
   c++1z ada spark high performance
   c++2z c++20 C++17 c++14 C89 c90 ancient unix
   quit
    [TRACE] Shutdown connection. Ok. 
    [TRACE] Waiting for client connection. 

#+END_SRC

Running client: (netcat tool)

#+BEGIN_SRC sh 
   $ nc localhost 8095

    => [INFO] Hello world client side!! 
   c++1z ada spark high performance
   c++1z ada spark high performance
   c++2z c++20 C++17 c++14 C89 c90 ancient unix
   c++2z c++20 C++17 c++14 C89 c90 ancient unix
   quit
   quit

   ^C
#+END_SRC
*** Simple Unix-domain socket echo server 

GIST:  
  + https://gist.github.com/ac308ab6a4cd8d92f02b4f9baeb910f3

File: unix-domain-echo-server.cpp

#+BEGIN_SRC cpp 
    // File: socket-echo-server.cpp 
    // Desc: Simple socket server with a single thread. 

    #include <iostream>
    #include <string> 
    #include <vector>
    #include <cassert> 
    #include <cstring>  // memcpy 

    // ----- Unix/Linux headers -----// 
    #include <unistd.h>
    #include <fcntl.h>
    #include <sys/types.h>    
    #include <sys/socket.h>
    #include <sys/un.h>

    // -------------  MAIN() ------------------------------//

    int main(int argc, char** argv)
    {
         std::puts(" [INFO] Program started. ");
         const char* unix_sock_file = "/tmp/unix-socket-file";

         // --- Create socket file descriptor -----------------------//

         int sockfd = socket (  AF_UNIX, SOCK_STREAM, 0);
         assert( sockfd != - 1);

         struct sockaddr_un sa; 
         sa.sun_family = AF_UNIX; 
         strcpy( sa.sun_path, unix_sock_file);	

         // Remove file if it exists.	
         unlink(unix_sock_file);

         // ----- Bind to unix domain socket and wait for client connections ---------//
         if( ::bind(sockfd, (sockaddr *) &sa, sizeof(sa)) == -1)
         {
             int err = errno; 
             fprintf(stderr, "Error: unable to bind socket \n");
             fprintf(stderr, " [ERROR] => %s", strerror(err));
             return EXIT_FAILURE;
         }

         // Enables binding to the same address 
         int enable_reuseaddr = 1;
         if ( setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &enable_reuseaddr, sizeof(int)) < 0 )
         {
             fprintf(stderr, "Error: unable to set socket option. \n");
             return EXIT_FAILURE;
         }


         fprintf(stderr, " [TRACE] Listening client connection \n");

         int backlog = 5;
         assert( listen(sockfd, backlog) != -1 );

         // --------------- Server Main Loop --------------------------//

         // Infinite loop where client connections are handled
         while(true)
         {	
               /* [[ ============== BEGIN client loop =========== ]] */

               struct sockaddr_un client_sa; 
               socklen_t addrlen = sizeof(sockaddr_un); 

               fprintf(stderr, " [TRACE] Waiting for client connection. \n");
               int sock_client = accept(sockfd, (sockaddr *) &client_sa, &addrlen );

               if(sock_client == -1)
               {
                       fprintf(stderr, " Error: failure to handle client socket. Check errno \n");
                       close(sock_client);
                       continue;
               }
               const char* welcome_msg = "\n => [INFO] Hello world client side!! \n";		

               // Send buffer content to client socket 
               send(sock_client, welcome_msg, strlen(welcome_msg), 0);

               char buffer[300];

               while(true){
                     // Read message from client socket 
                     ssize_t n = recv(sock_client, &buffer, 300, 0);
                     if(n == 0){ break; }

                     std::fprintf(stdout, " [INFO] Received: ");			
                     ::write(STDOUT_FILENO, buffer, n);

                     // Send content back 
                     send(sock_client, buffer, n, 0);

                     // Compare 4 first bytes of buffer and 'quit' 
                     if( strncmp(buffer, "quit", 4) == 0)
                     {
                        fprintf(stderr, " [TRACE] Shutdown connection. Ok. \n");
                        // Close client connection 
                        shutdown(sock_client, SHUT_RDWR);
                        close(sock_client);
                        break;
                     }			
             }

       } /* [[ ============== END client loop =========== ]] */

       // Release resource => RAII (Resource-Acquisition-Is-Initialization) fits here. 
       close(sockfd);
       return 0;
    }
#+END_SRC

Build: 

#+BEGIN_SRC sh 
  $ g++ unix-domain-echo-server.cpp -o unix-domain-echo-server.bin -std=c++1z -Wall -Wextra -g
#+END_SRC

Run server: 

#+BEGIN_SRC sh 
  $ ./unix-domain-echo-server.bin 
   [INFO] Program started. 
   [TRACE] Listening client connection 
   [TRACE] Waiting for client connection. 
  unix irix posix linux macosx kernel
  c++1z c++14 c++20 ADA spark ADA rust C++ Lisp

  quit
   [TRACE] Shutdown connection. Ok. 
   [TRACE] Waiting for client connection. 
#+END_SRC

Run client (netcat) : 

#+BEGIN_SRC sh 
  $ nc -v -U /tmp/unix-socket-file 
  Ncat: Version 7.80 ( https://nmap.org/ncat )
  Ncat: Connected to /tmp/unix-socket-file.

   => [INFO] Hello world client side!! 
  unix irix posix linux macosx kernel
  unix irix posix linux macosx kernel
  c++1z c++14 c++20 ADA spark ADA rust C++ Lisp
  c++1z c++14 c++20 ADA spark ADA rust C++ Lisp


  quit
  quit
  ^C
#+END_SRC

Check unix-socket file: 

#+BEGIN_SRC sh 
  $ file /tmp/unix-socket-file 
  /tmp/unix-socket-file: socket

  $ ls -l /tmp/unix-socket-file 
  srwxrwxr-x 1 mxpkf8 mxpkf8 0 Jul  2 01:22 /tmp/unix-socket-file=
#+END_SRC

** Sockets with IO Multiplexing [DRAFT]
*** Overview 

A recurrent need in network socket programming is to handle multiple
incoming client socket connections that need to be managed
simultaneously. For instance, if a blocking read operation is
performed on a client socket from a http(web) server, the server will
not be able to serve the remaining client sockets while the read
operation is ongoing. Several solutions have adopted for solving this
issue, such as: 

   * _Blocking IO (+) One process per connection_
     + Peform fork() system call, creating a child process wich is a
       copy of current process and let it manage the socket file
       descriptor.
     + Drawbacks: Complex, expensive and slow. A process has lots of operating
       system resources associated with it, including virtual memory,
       file descriptors and so on. Another issue is the complexity from
       IPC - Inter-Process Communication. 

   * _Blockign IO (+) One thread per connection_
     * Spawn/create a new thread for every connection.
     * Drawbacks: Although, this approach is less expensive than
       open-process-per-connection method, it is still expensive and
       non-scalable, specially for handling thousands of connections.

   * _Bloking IO (+) Thread Pool_
     * Reuse a set of pre-existing threads for managing each
       connection and avoid the overhead of creating and destroying too
       many threads.
     * Drawbacks: It only works for non-long running client socket
       connections such as HTTP connections that are closed as soon as
       possible. The drawback of this method is that it assumption that
       any task submited to thread pool will finish as soon as possible
       and not block the worker thread, otherwise, it will be
       unusable. The asummption implies that the connection should be
       closed as fast as possible, which means that the thread-pool
       approach is only suitable for HTTP servers which usually close
       the client socket connection after every request.

   * _Multiplexed IO_ [BEST]
     * Many operating systems provide multiplexed IO facilities, such
       as _select_, _poll_ and _epoll_ on Linux, _keque_ on BSD-variants and
       Mac-OSX and _IOCP_ on Windows. Multiplexed IO allow managing
       multiple file descriptors of any type in a single thread,
       consequently this feature allows handling multiple client
       socket connetions with far less overhead than using one thread
       for every connection. This type IO API is that makes the
       scalability of Nginx web server and NodeJS.

     * Multiplexed IO works in the following way: first the
       application register the file descriptors it is interested in
       monitoring; then the calling code calls a multiplexed IO
       function that blocks the current thread during some amount of
       time or indefinitely, the IO multiplexing function only
       returns when any of the file descriptors are ready to be read
       or written. The calling code handles each file descriptor by
       iterating over the data structure returned by the IO
       multiplexing function which contains the file descriptors
       events.

     * Drawbacks:
       * Event-driven with possible callback hell which can be avoided
         with _user-space threads_ (aka: coroutines, goroutines, green
         threads). 
       * Any operation which takes a significant time needs to be run
         in another thread, otherwise the threads handling the
         connection will be blocked and unable to server any other
         client request.

     * Wrappers:
       * Multiplexed IO APIs are not standardized. As a result,
         several high level wrappers have been created for providing
         an uniform and cross-platform API for multiplexed IO. Some of
         those wrapper libraries are:
         * /Boost.ASIO/ - C++ library for scalable and cross-platform network programming. 
         * /libUV/      - C library used by NodeJS; Julia language and so on.
         * /libev/
         * /libEvent/

     * Note: Many documents also calls multiplexed IO as _event-driven_
       _IO_, _non-blocking IO_ and so on.

     * Note: The EPool API cannot monitor file descriptors of regular
       files. For this case, the Linux kernel provides the _iNotify_ API.

See: 

  + [[https://eklitzke.org/blocking-io-nonblocking-io-and-epoll][Blocking I/O, Nonblocking I/O, And Epoll]]

  + [[https://medium.com/@copyconstruct/the-method-to-epolls-madness-d9d2d6378642][The method to epoll’s madness. My previous post covered the… | by Cindy Sridharan | Medium]] 

*** Epoll() multiplexed IO API 

Epoll is a highly scalable and efficient Linux-only multiplexed IO API
which allows monitoring an unlimted amount of file descriptors, and
consequentely file descriptors related to regular files, device files
and sockets. This API is that makes the scalability of NodeJS and
Nginx web server possible. 

Manpage: 
  + [[https://man7.org/linux/man-pages/man2/epoll_create.2.html][epoll_create()]]
  + [[https://man7.org/linux/man-pages/man2/epoll_ctl.2.html][epoll_ctl()]]

Header file: 
  + #include <sys/epoll.h>

Structs: 

  + The events is a Or bitmaks, some of the flags are:
    + EPOLLIN  => "The associated file is available for read(2) operations."
    + EPOLLOUT => "The associated file is available for write(2) operations."
    + EPOLLHUP => "Hang up happened on the associated file descriptor."
    + EPOLLET => "Requests edge-triggered notification for the
      associated file descriptor.  The default behavior for epoll is
      level-triggered.  See epoll(7) for more detailed information
      about edge triggered and level-triggered notification."

#+BEGIN_SRC cpp 
     typedef union epoll_data {
         void        *ptr;
         int          fd;
         uint32_t     u32;
         uint64_t     u64;
     } epoll_data_t;

     struct epoll_event {
         uint32_t     events;      /* Epoll events */
         epoll_data_t data;        /* User data variable */
     };
#+END_SRC

Functions: 

  + _epoll_create1(int)_ => Creates epoll object, returns epoll file descriptor.
    + "If flags is 0, then, other than the fact that the obsolete size
      argument is dropped, epoll_create1() is the same as
      epoll_create().  The following value can be included in flags to
      obtain different behavior:"

#+BEGIN_SRC cpp 
   int epoll_create1(int flags);

   // ------ Usage ---------------------//
   // Epoll file descriptor 
   int epfd; 
   if( (epfd = epoll_create1(0)) == -1 )
   { 
      perror("Unable to get epoll file descriptor. Check ERRNO variable."); 
      exit(1);
   }

  // .... Use Epoll ....

  // Close when no longer needed. 
  close(epfd); 
#+END_SRC

  + _epoll_ctl()_ => Modify, remove or add file descriptors to the
    /interest list/, set of monitored file descriptors.
    + Doc: $ man epoll_ctl
    + Doc: [[https://man7.org/linux/man-pages/man2/epoll_ctl.2.html][Manpage]]

    + Some values of 'op': 

#+BEGIN_SRC cpp  
    int epoll_ctl(  int epfd                     // Epoll file descriptor (Epoll object)
                  , int op                       // Operation to be performed 
                  , int fd                       // File descritor 
                  , struct epoll_event *event    // Pointer to epoll_event 
                 );

    //---------------------------------------------------//
    // Usage example for registering file descriptor     //
    // add file descriptor to interest list.             // 
    // --------------------------------------------------//

    int fd = STDIN_FILENO; // Stdin, console 
    epoll_event ev; 
    // Monitor when file descriptor is available for read operations.
    ev.events  = EPOLLIN;
    // Monitor when file descriptor is available for write operations.
    ev.events  = EPOLLIN | EPOLLOUT;
    ev.data.fd = fd; 
    if( epoll_ctrl(epfd, EPOLL_CTL_ADD, fd, &ev ) == -1 )
    {  perror("Error: failure. Check errno.");
       exit(1);
    }

    //---------------------------------------------------//
    // Usage example for removing file descriptor        //
    // --------------------------------------------------//
    epoll_event ev; 
    ev.events  = EPOLLIN;
    ev.data.fd = fd; 
    if( epoll_ctrl(epfd, EPOLL_CTL_DEL, fd,  ) == -1 )
    {  perror("Error: failure. Check errno.");
       exit(1);
    }
#+END_SRC

  + _epoll_wait()_ - IO multiplexing function - blocks the current
    thread for some amount of time until an event related to a
    monitored file descriptor has happened.
    + Manpage: "wait for an I/O event on an epoll file descriptor"

    + /epfd/ => Epoll file descriptor

    + /events/ => (Output) Pointer to array containing the events
      related to the monitored file descriptors. This array is
      allocated by the calling code.

    + /maxevents/ => Maximum number of monitored events (often the size
      of events array).

    + /timeout/ => Number of milliseconds that epoll_wait() blocks the
      current thread. If this value is (-1), the calling thread is
      indefinitely until some IO event happens.

#+BEGIN_SRC cpp 
   int epoll_wait(int epfd, struct epoll_event *events,
                  int maxevents, int timeout); 
#+END_SRC

Usage example of epoll_wait() with level triggered.

#+BEGIN_SRC cpp 
    // ============ Usage for servers ===================// 
    // 
    void Epoll_fd_option(int epoll_fd, int fd, int events)
     {
         epoll_event ev; 
         ev.events  = events;
         ev.data.fd = fd; 
         int res = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &ev);
         if(res == -1){
             perror("Error: EPoll / unable to register file descritor");
         }    
    }

    constexpr size_t MAX_EVENTS = 10;     
    int server = socket(AF_INET, SOCK_STREAM, 0);
     .. .... ... ...

    // Create epoll object 
    int epfd = epoll_create1(0);
    epoll_event notifications[MAX_EVENTS];
    
    // Monitor incoming connections 
    Epoll_fd_option(epfd, server, EPOLLIN);

    // Monitor stdin (console file descriptor)
    Epoll_fd_option(epfd, STDIN_FILENO, EPOLLIN);

    charr buffer[300];

    for(;;) {
         // Current thread blocked until any event happens.
         // Returns number of evetns 
         int nfsd = epoll_wait(epfd, notifications, MAX_EVENTS, -1); 

         for(int i = 0; i < nfsd; i++)
         {
             epoll_event ev = notifications[i];

             if(ev.data.fd == server)
             {
                  // Accept connection return a client socket 
                  int client_fd = accept(server, (sockaddr *) &client.sa, &addrlen);
                  Epoll_fd_option(epfdm, client_fd, EPOLLIN);
                  continue;
             }

            // Client socket ready for reading operations.
            if(ev.events & EPOLLIN)
            {
                // Read 300 bytes from client socket file descriptor to buffer 
                int n = read(ev.dada.fd, buffer, 300);

                if(n == 0){ close(ev.data.fd); continue; }

                // Send back n bytes to client socket 
                write(ev.data.fd, buffer, n);
                continue;
            }

            if(ev.events & EPOLLOUT)
            { 
               // Perform write operations 
               ... ... .... ...                 
            }

         } // --- End for --- //

    } // --- End for --- //

    close(epfd);
#+END_SRC
*** Epoll() example - sample code 

GIST: 
  + https://gist.github.com/f88892ac263b96ba9d989c582dc3ccf1

Description: 
  + Sample TCP/IPv4 network server using epoll() multiplexed IO API
    for managing STDIN (console input) and multiple client sockets in
    a single thread. The server also sends any message typed in server
    console to all connected clients.
  + Note: It uses level triggered IO. 

File: multiplex-epoll-server.cpp 

#+BEGIN_SRC cpp 
    // File: socket-echo-server.cpp
    // Desc: Simple socket server with a single thread.

    #include <iostream>
    #include <string>
    #include <vector>
    #include <cassert>
    #include <cstring> // memcpy

    // ----- Unix/Linux headers -----//
    #include <unistd.h>
    #include <fcntl.h>
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <netdb.h>
    #include <signal.h>

    // Only available on Linux
    #include <sys/epoll.h> 

    struct Socket 
    {
        int           sockfd; 
        sockaddr_in   sa;     
    };

    struct RecvMsg
    {
        ssize_t     size;
        std::string msg;
    };

    void socket_close(Socket& sock);

    void    fd_write(int fd, std::string const& text);
    RecvMsg fd_read(int fd, size_t buffer_max = 500);

    /** Make a server socket */
    Socket socket_make_server(uint16_t port, const char* hostname = "0.0.0.0");
    /** Accept connetion from a server socket and returns a client socket */
    Socket socket_accept(Socket& server); 

    /** Register file descriptor to be monitored by Epoll */
    void Epoll_register_fd(int epoll_fd, int fd)
    {
        epoll_event ev; 
        ev.events  = EPOLLIN;
        ev.data.fd = fd; 
        int res = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &ev);
        if(res == -1){
            throw std::runtime_error("Error: EPoll / unable to register file descritor");
        }    
    }

    /** Remove file descriptor from monitoring list. */
    void Epoll_remove_fd(int epoll_fd, int fd)
    {
        epoll_event ev;
        int res = epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, &ev);
    }

    /*  Multiplex IO - Blocks current thread until any of monitored file descriptors 
     *  has 
     */
    int Epoll_wait(int epoll_fd, size_t max_events, std::vector<epoll_event>& events)
    {
        // Returns number of events received 
        int nfd = epoll_wait( epoll_fd     // Epoll file descripotr 
                            , &events[0]   // [output] Array containing received events 
                            , max_events   // Maximum number of events 
                            , -1           // Timeout (-1) => Block indefinitely
                            );

        return nfd;
    }


    int main(int argc, char **argv)
    {
        std::puts(" [INFO] Program started. ");

        // --- Create socket file descriptor -----------------------//
        Socket server = socket_make_server(9026, "0.0.0.0");

        constexpr size_t MAX_EVENTS = 10;     
        int epfd = epoll_create1(0);
        assert(epfd != - 1);
        auto events = std::vector<epoll_event>(MAX_EVENTS);

        // Register stdin 
        Epoll_register_fd(epfd, STDIN_FILENO);

        // Register socket server 
        Epoll_register_fd(epfd, server.sockfd);

        // Contains client sockets file descriptors 
        std::vector<Socket> clients; 


        // Server-accept infinite loop 
        for(;;)
        {
            std::printf(" [TRACE] Epoll waiting for events \n");

            int nfsd = Epoll_wait(epfd, MAX_EVENTS, events);            
            assert( nfsd != - 1);

            std::printf(" [TRACE] Epoll events arrived => nfsd = %d \n", nfsd);

            for(int i = 0; i < nfsd; i++)
            {
                auto ev = events[i];

                std::printf(" ----------------------------------------------------\n");

                if( (ev.events & EPOLLERR) || (ev.events & EPOLLHUP) )
                {
                    std::printf(" [ERROR] Epoll error has happened. \n");
                    continue;
                }

                // STDIN event => It happens after user types something and
                // hit RETURN on terminal.
                if( ev.data.fd == STDIN_FILENO )
                {
                    std::printf(" [TRACE] Received STDIN event \n");
                    std::string line;
                    std::getline(std::cin, line);
                    std::cout << " \n STDIN = " + line << "\n";

                    // Send typed message to all client sockets
                    for(Socket& cli: clients)
                        fd_write(cli.sockfd, " STDIN = " + line + "\n");

                    // Quit server 
                    if(line == "exit"){ 
                        std::puts(" [INFO] Shutdown server OK.");
                        return EXIT_SUCCESS;
                    }
                    continue;
                }

                // Event that happens when there is a new connection.
                if(ev.data.fd == server.sockfd)
                {                
                    Socket client = socket_accept(server);        
                    Epoll_register_fd(epfd, client.sockfd);

                    std::printf(" [TRACE] Accept client connection => ID = %d \n", client.sockfd);                
                    fd_write(client.sockfd,  "\n => [SERVER INFO] Hello world client side!! \n");
                    // socket_nonblock(client);
                    clients.push_back(client);
                    continue;
                }

                // Event that happens when some client socket sends data. 
                // EPOLIN event means that the file descriptor is ready for input. 
                if(ev.events & EPOLLIN)            
                {
                   int fd = ev.data.fd;
                   std::printf("\n [TRACE] Receive client event => ID = %d \n", fd);
                   RecvMsg resp = fd_read(fd, 500);                                             
                   if(resp.size == 0)
                   {
                       std::printf("\n [CLIENT ID = %d] =>> Disconnected from server. \n", fd);
                       close(fd);
                       continue;
                   }
                   std::printf("\n [CLIENT ID = %d] =>> size = %d ; msg = %s \n", fd, resp.size, resp.msg.c_str());
                   fd_write(fd, " [SERVER ECHO] => ID = " + std::to_string(fd) + " => " + resp.msg);
                }

            }


        } /* [[ ============== END client loop =========== ]] */

        socket_close(server);
        return 0;

    } // --- End of main() -------------//

    // ----------- Function Implementations ----------------------------------------//

    void 
    socket_close(Socket& sock)
    {
        ::close(sock.sockfd);
        sock.sockfd = -1;    
    }


    void fd_write(int fd, std::string const& text)
    {
        ::write(fd, text.c_str(), text.size());
    }

    RecvMsg fd_read(int fd, size_t buffer_max)
    {
        std::string buffer(buffer_max, 0x00);
        ssize_t n = read(fd, &buffer[0], buffer_max);
        buffer.resize(n);
        return RecvMsg{n, buffer};
    }


    Socket 
    socket_make_server(uint16_t port, const char* hostname)
    {
        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        // Returns (-1) on failure
        assert(sockfd != -1);

        // ---------- query address ------------------------------//
        // Note: the keyword 'struct' is not necessary here (redundant).
        struct hostent *h = gethostbyname(hostname);
        assert(h != nullptr);
        struct sockaddr_in sa;
        memcpy(&sa.sin_addr.s_addr, h->h_addr, h->h_length);
        sa.sin_family = AF_INET;
        // The function htons convert a number to big-endian format.
        sa.sin_port = htons(port);

        // ----- Bind to Port and wait for client connections ---------//
        if (::bind(sockfd, (sockaddr *)&sa, sizeof(sa)) == -1)            
            throw std::runtime_error("Error: unable to bind socket \n");


        // Enables binding to the same address
        int enable_reuseaddr = 1;
        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &enable_reuseaddr, sizeof(int)) < 0)
            throw std::runtime_error("Error: unable to set socket option. \n");

        // Ignore SIGPIPE signal which would cause abnormal termination of socket server
        // Requires: #include <signal.h> header.
        signal(SIGPIPE, SIG_IGN);

        fprintf(stderr, " [TRACE] Listening client connection \n");
        int backlog = 5;
        assert(listen(sockfd, backlog) != -1);

        return Socket{ sockfd, sa };
    }

    Socket 
    socket_accept(Socket& server)
    {
        Socket client;
        socklen_t addrlen = sizeof(sockaddr_in);
        client.sockfd = accept(server.sockfd, (sockaddr *) &client.sa, &addrlen);

        if (client.sockfd == -1)
        {
            fprintf(stderr, " Error: failure to handle client socket. Check errno \n");
            close(client.sockfd);
        }
        return client;
    }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
   g++ multiplex-epoll-server.cpp -o out.bin -std=c++1z -Wall -Wextra 
#+END_SRC

Running: (Server - terminal 1)

#+BEGIN_SRC sh 
   ./out.bin 

   [INFO] Program started. 
   [TRACE] Listening client connection 
   [TRACE] Epoll waiting for events 
   [TRACE] Epoll events arrived => nfsd = 1 
   ----------------------------------------------------
   [TRACE] Accept client connection => ID = 7 
   [TRACE] Epoll waiting for events 
   [TRACE] Epoll events arrived => nfsd = 1 
   ----------------------------------------------------

   [TRACE] Receive client event => ID = 7 

   [CLIENT ID = 7] =>> size = 19 ; msg = hello world server

   [TRACE] Epoll waiting for events 
   [TRACE] Epoll events arrived => nfsd = 1 
   ----------------------------------------------------
   [TRACE] Accept client connection => ID = 8 
   [TRACE] Epoll waiting for events 
   [TRACE] Epoll events arrived => nfsd = 1 
   ----------------------------------------------------

   [TRACE] Receive client event => ID = 8 

   [CLIENT ID = 8] =>> size = 30 ; msg = connect server from client 2 

   [TRACE] Epoll waiting for events 
  message typed in stdin is sent to all client sockets.
   [TRACE] Epoll events arrived => nfsd = 1 
   ----------------------------------------------------
   [TRACE] Received STDIN event 

   STDIN = message typed in stdin is sent to all client sockets.
   [TRACE] Epoll waiting for events 
   [TRACE] Epoll events arrived => nfsd = 1 
   ----------------------------------------------------

   [TRACE] Receive client event => ID = 8 

   [CLIENT ID = 8] =>> size = 24 ; msg = from client 2 to server

   [TRACE] Epoll waiting for events 
   [TRACE] Epoll events arrived => nfsd = 1 
   ----------------------------------------------------
#+END_SRC

Running: (Client 1 netcat from terminal 2)

#+BEGIN_SRC sh 
   $ >> nc -v localhost 9026
  Ncat: Version 7.80 ( https://nmap.org/ncat )
  Ncat: Connection to ::1 failed: Connection refused.
  Ncat: Trying next address...
  Ncat: Connected to 127.0.0.1:9026.

   => [SERVER INFO] Hello world client side!! 
  hello world server
   [SERVER ECHO] => ID = 7 => hello world server
   STDIN = message typed in stdin is sent to all client sockets.
  from client 1 to server
   [SERVER ECHO] => ID = 7 => from client 1 to server
  ^C⏎   
#+END_SRC

Running: (Client 2 netcat from terminal 3)

#+BEGIN_SRC sh
  $ nc -v localhost  9026
  Ncat: Version 7.80 ( https://nmap.org/ncat )
  Ncat: Connection to ::1 failed: Connection refused.
  Ncat: Trying next address...
  Ncat: Connected to 127.0.0.1:9026.

   => [SERVER INFO] Hello world client side!! 
  connect server from client 2 
   [SERVER ECHO] => ID = 8 => connect server from client 2 
   STDIN = message typed in stdin is sent to all client sockets.
  from client 2 to server
   [SERVER ECHO] => ID = 8 => from client 2 to server
  ^C

#+END_SRC
