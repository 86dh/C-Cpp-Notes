#+INCLUDE: theme/style.org 
#+TITLE: Linux and Unix system programming 
#+DESCRIPTION: Linux, unix and posix system programming 
#+STARTUP: content 


* Unix System Programming focused on Linux 
** Unix-like Operating Systems 

Unix-like operating system are a family of operating system based on
the AT&T Unix operating system, developed in the 1970's by [[https://en.m.wikipedia.org/wiki/Ken_Thompson][Ken Thompson]], 
[[https://en.m.wikipedia.org/wiki/Dennis_Ritchie][Dennis Ritchie]] and others. Later AT&T licensed Unix to third-party
vendors, what lead to many proprietary Unix variants. 

  *Some Unix-like operating systems are*

Desktop or Server:

  * _Mac OSX_ / Apple [Most Used]

  * _Linux-based or GNU-Linux based_ operating systems (Note: Linux is
    just the kernel) 
    + Debian Linux
    + Ubuntu Linux
    + Fedora Linux
    + Gentoo Linux
    + Arch   Linux
    + ... ... ...

  * [[https://en.m.wikipedia.org/wiki/FreeBSD][FreeBSD]]  

  * [[https://en.m.wikipedia.org/wiki/NetBSD][NetBSD]] 

  * [[https://en.m.wikipedia.org/wiki/OpenBSD][OpenBSD]]

  * [[https://en.m.wikipedia.org/wiki/DragonFly_BSD][DragonFly BSD]] 

  * [[https://en.m.wikipedia.org/wiki/Minix][Minix]] - Open source small operating system created for teaching
    about operating system concepts.

  * [[https://en.m.wikipedia.org/wiki/Solaris_(operating_system)][Solaris]] (from Sun Microsystems)

  * [[https://en.m.wikipedia.org/wiki/Z/OS][z/OS]] / IBM - Unix-variant for mainframes.

  * AIX / IBM

  * [[https://en.m.wikipedia.org/wiki/HP-UX][HP-UX]]

  * [[https://en.m.wikipedia.org/wiki/IRIX][IRIX]] 

  * [[https://en.m.wikipedia.org/wiki/Xenix][Xenix]] 

Mobile: 

  * Android (Linux-based OS, but without GNU on the userland) 

  * iOS / Apple 

Embedded Systems: 

  + [[https://en.wikipedia.org/wiki/QNX][QNX]]

  + Linux (called Embedded-Linux)

  + [[https://en.m.wikipedia.org/wiki/Minix][Minix]]  

  + [[https://en.m.wikipedia.org/wiki/NetBSD][NetBSD]]

  + [[https://en.m.wikipedia.org/wiki/LynxOS][LynxOS]]


  *Common Features of Unix-like Operating Systems*


Nowadays, there may be many difference between Unix-like operating
systems, but they still have the following features in common: 

  + _Command line shell_
    * In the early days of computing, the shell or command line
      interpreter was the primary means of interaction between users
      and computers. A unix shell is used both as a scripting language
      and as an interactive command line interpreter for
      user interaction, launching processes, launching daemons (aka
      services), manipulating files and controlling the operating system.

    * Common Unix shells:
      * [[https://en.wikipedia.org/wiki/Almquist_shell][ash]]  (Almiquistt Shell)
      * [[https://en.wikipedia.org/wiki/C_shell][c-shell]]
      * [[https://en.wikipedia.org/wiki/Debian_Almquist_shell][dash]] (Debian Almiquist Shell)
      * tcsh
      * ksh  (Korn Shell)
      * Tcl
      * [[https://en.wikipedia.org/wiki/Bash_(Unix_shell)][bash]] (Bourn Shell) [Most used, most popular]
      * zsh                [Most popular]
      * fish               [Most popular]

  + _Command Line Applications_ (Command-Line Centric)
    + mv; cp; rm; mkdir; ls; telnet; ssh; ... and so on.

  + _Terminal Emulation_
    + Early Unix-like operating systems only ran in big and expensive
      _mainframe_ computers that were simultaneously shared by many
      users via physical dumb terminals attached through serial cables
      (RS232 - UART). The first terminals were _teletype printers_ (tty)
      where users could type commands and the teletype printer would
      print the the command output in a paper type. Later, dumb CRT
      (Cathode-Ray Tube) terminals were adopted. Those machines were
      comprised of a keyboard attached to a CRT video display as
      single unit attached to a mainframe via a serial cable. Physical
      Terminals, such as the once popular [[https://en.wikipedia.org/wiki/VT100][DEC VT100]], are long gone,
      but the are still _emulated_ by unix-based operating systems. For
      instance, most of those systems provide the following types of
      terminal emulation:

    + => /Virtual console/ => Kernel built-in terminal emulator, which can
      be accessed without any graphical user interface by typing
      Ctrl + Alt + F1, Ctrl + Alt + F[N] on Linux. BSD has different
      keybinds for the /virtual console/. Note: Mac-OSX does not have
      virtual console.

    + => /Graphical Terminal Emulator/ => Example: Xterm (X11); Gnome
      Terminal; Terminator; iTerm (MacOSX).

    + => /Serial console/ => Allows accessing a command line shell
      (bash, for instance) through a serial cable (RS232 /
      UART). Serial console is still used for accessing servers or
      embedded systems. 
      

  + _Text-centric_

    + Unix-like operating system has the tradition of storing
      configuration in human-readable text files, instead of binary files as
      Windows does. The benefits of using text files are the better
      reusability, searchability and reproducibility of
      configurations. All that one needs to reproduce the configuration
      in another machine is to copy the configuration file. 

    + Many applications also use text for configuration instead of
      graphical user interfaces.

    + Examples:
      + Linux-based operating system store many of their configuration
        as text files in the '/etc' directory. For instance, the file
        '/etc/fstab' controls the disk partitions mounted during boot
        time. As opposite to Unix-tradition, Windows and most of its
        applications store configuration in the registry file which
        is a binary file. 

      + Applications such as bash, vi, emacs store configuration in
        text files placed in default locations which are read during
        the initialization.

  + _POSIX Features_ / [[https://en.m.wikipedia.org/wiki/POSIX][POSIX]] - (Portable Operating System Interface) standard

    + POSIX System Calls
      + open(), read(), close() ... 

    + POSIX Functions encapsulating system calls 
      + open(), read(), close(), mmap(), dlopen(), dlclose() ...

    + POSIX Threads (_PThreads_) - Thread C API 

    + POSIX Shells

  + _BSD TCP/IP Sockets_  => TCP/IP networks were first implemented on Unix.

  + _Hierarchical file system_
    + File system with paths like: '/' (root directory); '.' (dot) as
      the current directory; '/home/user/data' (Linux);
      '/home/Users/somthing' (MacOSX) and so on.

  + _Dynamic Link_ (Symlink)
    + Allows file and directories to be accessed from other
      directories as they were in that location. 

  + _Virtual File Systems_
    + Many unix-like operating system provide virtual file-system
      (in-memory file systems) which exposes kernel and system
      information to user-space applications as human-readable text
      files. For instance, Linux has the _PROCFS_ (/proc directory) file
      system which exposes information about all the running
      processes. PROCFS also has the file _/proc/cpuinfo_ which contains
      information about the current machine microprocessor, such as:
      CPU cores; number of hyper threads; CPU features and
      capabilities.

  + _Everything is a file_ (or better everything is a file descriptor)
    + Many operating such as reading/writing sockets, pipes and so on,
      use the same read/write system-calls for file descriptors.
    + Hardware represented as device-files  
    + Kernel exposes information as text files (Linux)
    + Disk partitions are represented as files /dev/sda, /dev/sdb1,
      /dev/sdb2 ...
    + see: [[https://en.wikipedia.org/wiki/File_descriptor][file descriptor]]

  + _Device Files_ (a.k.a device nodes)
    + Device files are pseudo-files created in virtual file systems
      which allows user-space applications to interact with the
      _hardware peripherals_ by using reading and writing system-calls
      or just by reading and writing files. This feature is
      particularly important for industrial and embedded system
      applications as it allows reading sensor data, such as ADC  -
      Analog-To-Digital Converters or digital input, just by reading
      files and controlling actuators, such as motors, solenoids or
      valves just by writing to files. 

    + Note A: On Linux-based, operating systems, most device files are
      in the virtual file systems _devfs_ (/dev) and and _sysfs_ (/sys)
      directory.

    + Note B: Not all device files are associated to real hardware
      devices. The device-files /dev/null, /dev/zero, /dev/random,
      /dev/urandom, /dev/kmsg, /dev/tty0 are not associated to any
      real hardware.

    + Example 1: It allows user-space application to read and write
      from/to serial port devices by just reading or writing to the
      device file /dev/ttyS1, /dev/ttyUSB0, ...

    + Example 2: In single-board computers SBCs (embedded systems)
      such as Beagle Bone Black or Raspberry PI, both which contains
      SOC (System-On-Chip) embedded processors, it is possible to
      control GPIOs (General Purpose IO) which are digital IOs, and
      consequently any device attached to them, such as lights, LEDs,
      motors or valves, just by writing to the corresponding GPIO
      device file (/sys/class/gpio/gpio10/value). By writing 1 to the
      this file, the LED is turned on, by writing 0, the LED is turned
      off. The device-file feature allows controlling the hardware
      with any programming language, including, shell scripts, python,
      ruby, standard C++ (without volatile and embedded bare-metal
      restrictions) and so on.

    + Common Linux Device Files associated to hardware 
      + /dev/lp0, /dev/lp1 => Parallel ports 
      + /dev/ttyS0, /dev/ttyS1, ... => Serial Ports
      + /dev/ttyUSB0, /dev/ttyUSB1, ... => USB-to-serial converters such as FTDI
      + /dev/sys/class/gpio/gpio10/export => GPIO / General Purpose Digital IO
      + /dev/sys/class/gpio/gpio10/value
      + ... ... ...
      + /dev/input/mice => Binary file contains mouse position, mouse
        buttons and and so on. The mouse position can be obtained by
        reading this file, without any special API.
      + /dev/fb0, /dev/fb1 ... => [[https://www.kernel.org/doc/Documentation/fb/framebuffer.txt][Framebuffer]] - allows user-space
        applications to control the graphics card and draw on the
        screen by just writing to a file. The framebuffer is the
        lowest level GUI in Linux kernel. Most embedded linux
        applications draw directly on framebuffer without X11
        (X-Windows System).

    + Linux Device Files not associated to hardware:
      + /dev/kmsg => pseudo-text file containing kernel messages.
      + /dev/stdout => Console stdout 
      + /dev/stdin  => Console stdin 
      + /dev/stderr => Console stderr 
      + /dev/random => file which generate random numbers
      + /dev/urandom
      + /dev/null   => File used to discard stdout or stderr of
        command line applications.
      + /dev/zero 

 *See also* 

General Unix Concepts: 

  + [[https://en.m.wikipedia.org/wiki/Unix][Unix concept]]

  + [[https://en.m.wikipedia.org/wiki/Unix-like][Unix-like operating systems]]

  + [[https://en.m.wikipedia.org/wiki/POSIX][POSIX - Portable Operating System Interface]]

  + [[https://en.m.wikipedia.org/wiki/Unix_philosophy][Unix philosophy]]

  + [[https://en.wikipedia.org/wiki/Unix_shell][Unix Shell Scripting]]

  + [[https://en.m.wikipedia.org/wiki/Symbolic_link][Symbolic Link / symlink]]

  + [[https://en.m.wikipedia.org/wiki/Pipeline_(Unix)][Pipeline, Pipes - IPC (Inter Process Communication)]]

  + [[https://www.bottomupcs.com/file_descriptors.xhtml][Unix File Descriptors]]

  + [[https://en.wikipedia.org/wiki/File_descriptor][File Descriptors]]

  + [[https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/12_FileSystemImplementation.html][Operating Systems - File System Implementation]]

Papers and mail lists: 

  + [[https://people.eecs.berkeley.edu/~brewer/cs262/unix.pdf][The UNIX Time Sharing System]] - Dennis M. Ritchie and Ken Thompson - Bell Laboratories

  + [[https://www.usenix.org/legacy/publications/library/proceedings/usenix03/tech/freenix03/full_papers/appavoo/appavoo_html/node18.html][Files, file descriptors, and name space]]

  + [[https://yarchive.net/comp/linux/everything_is_file.html][Linux kernel mail list discussion - Everything is a file]]

Usage of _Linux Device Files_ for controlling hardware (reading Sensors
and manipulating actuators):

  + [[https://unix.stackexchange.com/questions/101759/difference-between-device-file-and-device-drivers][Difference between Device file and device drivers]]

  + [[http://ibgwww.colorado.edu/~lessem/psyc5112/usail/peripherals/devices/devintro.html][Introduction to device drivers and device nodes]]

  + [[https://thehackerdiary.wordpress.com/2017/04/21/exploring-devinput-1/][The hacker diary - exploring /dev/input]] => Shows how to read the
    device file /dev/input/mice which contains mouse information such
    as position and buttons state.

  + [[https://www.ics.com/blog/how-control-gpio-hardware-c-or-c][How to Control GPIO Hardware from C or C++]]
    + Note: It only works in PCs with _industrial IO cards_ or systems
      with SOC processors (System-On-Chip) with GPIO devices; SBC -
      Single Board Computers, which are PCBs - printed circuit boards
      containin SOC microprocessors or MCU - Microcontrollers and all
      necessary supporting ICs (Integrated Circuits) such as RAM
      memory chips; flash memory chips; voltage regulators; USB
      connectors; ...

  + [[https://blog.mbedded.ninja/programming/operating-systems/linux/linux-serial-ports-using-c-cpp/][Linux Serial Ports Using C/C++]]

  + [[https://stackoverflow.com/questions/6947413/how-to-open-read-and-write-from-serial-port-in-c][How to open, read, and write from serial port in C?]]

  + [[https://www.iot-programmer.com/index.php/books/22-raspberry-pi-and-the-iot-in-c/chapters-raspberry-pi-and-the-iot-in-c/57-raspberry-pi-and-the-iot-in-c-sysfs-the-linux-way-to-gpio?start=1][Raspberry Pi And The IoT In C - SYSFS The Linux Way To GPIO]]


Terminal Emulation and Serial Console

  + [[https://www.ttwin.com/blog/270-history-terminal-emulation][A Brief History of Terminal Emulation]]

  + [[https://en.wikipedia.org/wiki/VT100][DEC VT100 CRT Terminal]]

  + [[https://en.wikipedia.org/wiki/Computer_terminal][Computer Terminal]]

  + [[https://www.kernel.org/doc/html/v4.15/admin-guide/serial-console.html][Linux Kernel Docs / Linux Serial Console]]

  + [[https://www.tldp.org/HOWTO/Remote-Serial-Console-HOWTO/intro-why.html][Remote Serial Console HOWTO Prev / Chapter 1. Introduction]]

  + [[https://wiki.archlinux.org/index.php/Working_with_the_serial_console][Arch Linux / Working with the serial console]]

  + [[https://elinux.org/Serial_console][Elinux - Serial Console]]

  + [[https://bootlin.com/doc/legacy/serial-drivers/linux-serial-drivers.pdf][Bootlin - Linux Serial Driver]]

  + [[https://developer.toradex.com/knowledge-base/how-to-disable-enable-debug-messages-in-linux][Configuring Serial Port Debug Console (Linux/U-Boot)]]

  + [[https://wiki.alpinelinux.org/wiki/Enable_Serial_Console_on_Boot][Alpine Linux - Enable Serial Console]]

  + [[https://www.linuxjournal.com/article/7206][Linux Serial Consoles for Servers and Clusters]]

  + [[https://roll.urown.net/server/serial-console.html][Roll Your Own Network / Serial Console]] (for servers, data-centers)

** Creating Portable Binaries for Linux / GLIBC hell 
*** Overview 

One of the greatest challenges of Linux desktop is building and
deploying portable applications and native executable which work on
any Linux distribution. Even if an application totally statically
linked against all dependencies or it is bundled with all its shared
libraries dependencies via LD_LIBRARY_PATH environment variable or
RPATH, the program may still fail to run in other Linux distribution
due to the GLIBC (GNU C library runtime) dependency. A GLIBC is _forward_
_compatible_, but not _backward compatible_, the GLIBC runtime failure is
more likely to happen if the application was built on a Linux
distribution using a newer version of GLIBC, but the program is
deployed in a distribution using an older version of GLIBC.

  * Side Note 1:
    + Applications built with GO (Golang) programming
      language are less likely to be affected by the GLIBC-issue, as GO
      compiler often does not link against the GLIBC and builds
      statically linked binaries which can be deployed everywhere.

  * Side Note 2:
    + The GLIBC issue do not only affect C++, all programming
      languages which generates native Linux executables, for
      instance, D-lang, Rust, OCaml, Haskell are also affected
      by the GLIBC compability problem.

  * Side Note 3:
    + Even [[https://appimage.org/][AppImage]], which is a solution for distributing binaries on
      Linux is affected by the GLIBC-problem. As a result, the
      AppImage documentation recommends building AppImage on Linux
      distributions with older versions of GlibC.

Possible Solutions: 

  1. Link against an older version of GLIBC
     + Build the application in a system with the oldest possible version
       of GLIBC. _System_ in this context means: a linux virtual machine; a
       chroot environment or a docker image with an older version of
       GLIBC.

  2. Link against MUSL (CRT - C Runtime Library)
     + The MUSL library, is an alternative to GLIBC, which was
       designed for embedded systems and static linking, allows
       building statically linked binaries that does not suffer from
       the GLIBC compatibility problems. The drawback of this
       procedure is that dynamic loading with _dlopen_ API (dlopen,
       dlclose, dlsym functions) is still not supported.

  3. Deploy via Docker
     * Deploy the application via docker image. While this solution is
       acceptable for compilers, building environments, servers and
       command line applications, Docker is not suitable for games or
       Desktop GUI (Graphical User Interface) applications intended
       to be used by non-technical users.
     * Advantage:
       * Pack application, dependencies and configuration.
       * The deployment environment can be reproduced everywhere. 

  4. Distribute as source and recompile from source on every
     deployment machine. 

  5. Distribute the application via Linux distribution repositories
     * Distribute the application via official Linux distribution
       repositories by creating distribution-specific packages for
       every supported distribution. It means creating (.deb) Debian packages for
       Debian-based distributions; (.rpm) packages for Fedora and
       Centos; (.apk) alpine packages for Alpine.

*** The GLIBC Problem 

 *GLIBC - Problem Illustration with a Sample Project* 

GIST Containing all files used in this experiment: 

  + https://gist.github.com/0557cd0fa1d5370723b015e443a7c036

File: Makefile

#+BEGIN_SRC make 
  build:
          cmake --config Debug -H. -B_build2
          cmake --build _build2 --target 
#+END_SRC

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(Simple_Cmake_Project)

  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #========== Targets Configurations ============#
          add_executable( filesys filesys.cpp )
  target_link_libraries( filesys stdc++fs)
#+END_SRC

File: filesys.cpp 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <iterator>
  #include <iomanip>
  #include <filesystem>

  namespace fs = std::filesystem;

  template<typename Range, typename Function>
  auto dotimes(size_t n, Range&& iterable, Function fun)
  {
      size_t i = 0;
      auto it = fs::begin(iterable);
      auto end = fs::end(iterable);
      while(i < n && it != end ){
              fun(it);
              ++it;
              i++;
      }
  }

  int main(){

       std::cout << std::boolalpha;
       std::cout << "\n ===== Listing directory /etc =====" << std::endl;
       // Show first 10 files of directory /etc 
       dotimes(10, fs::directory_iterator("/etc"),
               [](auto p){
                    auto path = p->path();
                    std::cout << std::left
                              << std::setw(0) << path.filename().string()
                              << " " << std::setw(35)
                              << std::right << std::setw(40) << path
                              << std::endl;				
               });		
       return EXIT_SUCCESS;
  }
#+END_SRC

 *Steps for reproducing the problem* 

STEP 1: Get current machine infomation. 

  + GLIBC Version is: 2.34-2.fc32

#+BEGIN_SRC sh 
  # Current machine 
  $ cat /etc/fedora-release 
  Fedora release 32 (Thirty Two)

  # Current GLIBC Version 
  $ ld --version
  GNU ld version 2.34-2.fc32
  ... ... ... ... 
#+END_SRC

STEP 2: Build the application. 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/0557cd0fa1d5370723b015e443a7c036 gist && cd gist 
  $ cmake --config Debug -H. -B_build1
  $ cmake --build _build1 --target 

  $ file _build1/filesys 
  _build1/filesys: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, 
  interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d1a3628f794c66bcfb29303cfa4a528910f4e3e2
  , for GNU/Linux 3.2.0, not stripped
#+END_SRC

STEP 3: Run in the current machine (newer version of GLIBC)

#+BEGIN_SRC sh 
  $ _build1/filesys 

   ===== Listing directory /etc =====
  chrony.conf                       "/etc/chrony.conf"
  xl2tpd                            "/etc/xl2tpd"
  group                             "/etc/group"
  profile.d                         "/etc/profile.d"
  kde4rc                            "/etc/kde4rc"
  resolv.conf.8LUAL0                "/etc/resolv.conf.8LUAL0"
  geoclue                           "/etc/geoclue"
  bash_completion.d                 "/etc/bash_completion.d"
  cups                              "/etc/cups"
  mime.types                        "/etc/mime.types"
#+END_SRC

STEP 4: Attempt to run the binary in a distribution using an older
version of GLIBC. The distribution used was a QEMU-KVM virtual
machine running MX-Linux 19.2, distribution based on Debian, with
GLIBC version .

GLIBC Failure on MX-Linux Virtual Machine: 

#+BEGIN_SRC sh 
  #---------- Failure!! GLIC Incompa ------------------------------------#
   $ _build1/filesys 
   _build1/filesys: /lib/x86_64-linux-gnu/libstdc++.so.6: version 
    'GLIBCXX_3.4.26' not found (required by _build1/filesys)
#+END_SRC

Virtual Machine Information: 

#+BEGIN_SRC sh 
   #----------- Machine Info (MX Linux 19.2) -------------#
   # Kernel version 
   $ uname -r
   4.19.0-9-amd64

   # Distro name 
   $ cat /etc/issue 
   Welcome to MX 19.2 (patito feo) 64-bit! Powered by Debian.
   ... ... ... ... ............ .... ... ... .. 

   $ ld --version
   GNU ld (GNU Binutils for Debian) 2.31.1
   ... ... ... ... ... ... ... ... ... ... ... ... 
#+END_SRC

*** Solution 1 - via linking against older GLIBC 

As GLIBC is _forward compatible_, but not _backward compatible_. The
solution for this issue is to build the application on a _system_ with
the oldest possible version of GLIBC. System in this context, means: a
Linux virtual machine; a Chroot environment; or Docker image with an
older version of GLIBC. Other alternative is to replace GLIBC with
_MUSL_ CRT (C Runtime library), but the drawback is that MUSL does not
support dynamic loading (_dlopen_, _dlsym_ APIs). 

The solution adopted for solving this issue was to use a Docker image
based on [[https://github.com/phusion/holy-build-box][holy-build-box]], which is a Docker image based on Centos 6
Linux distribution containing a modern version of GCC compiler, CMake
and an older version of GLIBC.

See: 
  + https://github.com/phusion/holy-build-box

 _File: Dockerfile_ (Available at [[https://gist.github.com/0557cd0fa1d5370723b015e443a7c036][gist url]])

#+BEGIN_SRC sh 
  # $ docker run -it --rm -v $PWD:/work -w /work phusion/holy-build-box-64:latest bash 
  FROM phusion/holy-build-box-64:latest

  ENTRYPOINT [ "/hbb_exe/activate-exec", "bash"  ]
#+END_SRC

Build docker image: 

#+BEGIN_SRC sh 
   # Run at the directory where is Dockerfile 
   $ docker build -f Dockerfile -t linux-build . 
#+END_SRC

Enter in the docker image shell: 

#+BEGIN_SRC sh 
   $ docker run --rm -it -v $PWD:/cwd -w /cwd linux-build 
   Holy build box activated
   Prefix: /hbb_exe
   CFLAGS/CXXFLAGS: -g -O2 -fvisibility=hidden -I/hbb_exe/include 
   LDFLAGS: -L/hbb_exe/lib -static-libstdc++
   STATICLIB_CFLAGS: -g -O2 -fvisibility=hidden -I/hbb_exe/include 
   SHLIB_CFLAGS: -g -O2 -fvisibility=hidden -I/hbb_exe/include 
   SHLIB_LDFLAGS: -L/hbb_exe/lib -static-libstdc++

   [root@88c9630a2008 cwd]# ls
   _build1  CMakeLists.txt   Dockerfile   filesys.cpp   Makefile
#+END_SRC

Building the application: 

#+BEGIN_SRC sh 
  [root@88c9630a2008 cwd]# make 
  cmake --config Debug -H. -B_build2
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /cwd/_build2
  cmake --build _build2 --target 
  gmake[1]: Entering directory '/cwd/_build2'
  /hbb/bin/cmake -S/cwd -B/cwd/_build2 --check-build-system CMakeFiles/Makefile.cmake 0
  ... ... ... ... ... ... ... ... ... 
  ... ... ... ... ... ... ... ... ... ... ... ... 

  [root@88c9630a2008 cwd]# ls _build2
  CMakeCache.txt  CMakeFiles  cmake_install.cmake  filesys  Makefile
#+END_SRC

Running the application _build2/filesys in MX-Linux: 

#+BEGIN_SRC sh 
   # Built on Fedora 32 with newer version of GLIBC [FAILURE]
   $ _build1/filesys
   _build1/filesys: /lib/x86_64-linux-gnu/libstdc++.so.6: 
   version 'GLIBCXX_3.4.26' not found (required by _build1/filesys)


   # Built on Centos6 docker with older version of GLIBC [OK, WORKS]
   #--------------------------------------
   $ _build2/filesys

    ===== Listing directory /etc =====
   .java                             "/etc/.java"
   .pwd.lock                         "/etc/.pwd.lock"
   ImageMagick-6                     "/etc/ImageMagick-6"
   NetworkManager                    "/etc/NetworkManager"
   UPower                            "/etc/UPower"
   X11                               "/etc/X11"
   acpi                              "/etc/acpi"
   adduser.conf                      "/etc/adduser.conf"
   adjtime                           "/etc/adjtime"
   alsa                              "/etc/alsa"
#+END_SRC
*** Solution 2 - via linking against MUSL libC

Other alternative to avoid the GLIBC dependency problem is to build
the application statically linking against [[https://www.musl-libc.org/][MUSL - LibC]] which is an CRT
(C runtime library), initially developed for embedded systems, but that has
become an alternative to GLIBC. The easiest way to build statically
linking against MUSL is to use an Alpine docker image: 

 + Note: CRT - is a central component of Unix-like operating
   systems. It encapsulates system-calls and other operating system
   services for user-space applications. 

See: 
  * [[https://en.wikipedia.org/wiki/Musl][Musl - Wikipedia]]
  * [[https://wiki.debian.org/musl][Musl - Debian]]
  * [[https://www.arangodb.com/2018/04/static-binaries-c-plus-plus-application/][Static Binaries for a C++ Application - ArangoDB]]
  * [[https://doc.rust-lang.org/edition-guide/rust-2018/platform-and-target-support/musl-support-for-fully-static-binaries.html][MUSL support for fully static binaries - Rust Docs]]
  * [[http://www.etalabs.net/compare_libcs.html][Comparison of C/POSIX standard library implementations for Linux]]
  * [[https://elinux.org/images/8/8b/Room_For_Cooperation-_Bionic_and_musl.pdf][Elinux/Linaro - Bionic and musl - room for cooperation?]]

File: MuslBuilder.docker ([[https://gist.github.com/0557cd0fa1d5370723b015e443a7c036][Available at gist]])

#+BEGIN_SRC docker 
  FROM alpine:latest
  RUN apk add musl cmake make g++
#+END_SRC

 *Building:* 

Buildilg the docker containing MUSL and development tools:

#+BEGIN_SRC sh 
   $ git clone https://gist.github.com/0557cd0fa1d5370723b015e443a7c036 && cd gist 
   $ docker build -f MuslBuilder.docker -t musl-builder . 
#+END_SRC

Running a container of this docker image: 

#+BEGIN_SRC sh 
   $ docker run -it --rm -v $(pwd):/cwd -w /cwd -e UID=$(id -u) -e GID=$(id -g) musl-builder 
   /cwd $ cmake --config Debug -H. -B_build-musl -DCMAKE_EXE_LINKER_FLAGS="-static -Os"
   /cwd # cmake --build _build-musl --target 
#+END_SRC

Exiting from the container and check the executable:

#+BEGIN_SRC sh 
  $ du -h _build-musl/filesys 
  8.7M	_build-musl/filesys
  8.7M	total

  $ file _build-musl/filesys 
  _build-musl/filesys: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV)
  , statically linked, with debug_info, not stripped

  # Check dependencies 
  $ ldd _build-musl/filesys 
          statically linked
#+END_SRC

Attempt to run from MX-Linux 19.2 (Older GLIBC)

#+BEGIN_SRC sh 
   $ _build-musl/filesys 

    ===== Listing directory /etc =====
   .java                             "/etc/.java"
   .pwd.lock                         "/etc/.pwd.lock"
   ImageMagick-6                     "/etc/ImageMagick-6"
   NetworkManager                    "/etc/NetworkManager"
   UPower                            "/etc/UPower"
   X11                               "/etc/X11"
   acpi                              "/etc/acpi"
   adduser.conf                      "/etc/adduser.conf"
   adjtime                           "/etc/adjtime"
   alsa                              "/etc/alsa"
#+END_SRC
** Low level IO functions overview 

C-Library functions which encapsulates file-related systems calls.

Headers: 

#+BEGIN_SRC cpp 
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    #include <unistd.h>
#+END_SRC

  *Special File Descriptors* 

  + STDOUT_FILENO => File descritor for stdout (process standard output)
  + STDERR_FILENO => File descritor for stderr (process standard error output)
  + STDIN_FILENO => File descritor for stdin (process standard input)

  *Functions* 

  + close() => Close a file descriptor.
    + Doc: $ man 2 close 

#+BEGIN_SRC cpp 
  int close(int fd);
#+END_SRC

 + open() => Encapsulates open system call => Returns a file descritor
   number. When fails, it returns (-1) setting the global variable
   _errno_.
   + Doc: $ man 2 open 

#+BEGIN_SRC cpp 
   int open(const char *pathname, int flags);
#+END_SRC

  + creat() => Create file
    + Doc: $ man 2 creat 

#+BEGIN_SRC cpp 
   int creat(const char *pathname, mode_t mode)
#+END_SRC


  + read() => Read bytes from a file descriptor into a buffer, returning the
    number of bytes read. If there is an error, the functions returns
    (-1) setting the global variable _errno_.
    + Doc: $ man 2 read 

#+BEGIN_SRC cpp 
  ssize_t read(int fd, void *buf, size_t count);
#+END_SRC

  + write() => Write N bytes from a buffer to a file descriptor.
    + Doc: $ man 2 write 

#+BEGIN_SRC cpp 
  ssize_t write(int fd, const void *buf, size_t count);
#+END_SRC

** Low level IO - open(), read(), write() syscall functions

This code demonstrates the usage of the open(), read(), write(),
close() low-level IO library-calls for file descriptors which
encapsulates system-calls with the same name. 

GIST: 
 + https://gist.github.com/05fbba6475cca1dbdd50bbb2bd5ac8ae

File: unix-low-level-io.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>

   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>

   #include <cstring> // Import: char* strerror(in errnum);

   const char* 
   errno_to_cstring(int err)
   {
       // No such file or directory 
       if(err == ENOENT) return "ENOENT";
       // Operation not permitted 
       if(err == EPERM)  return "EPERM";
       // Onput/Output error 
       if(err == EIO)    return "EIO";

       if(err == EAGAIN) return "EAGAIN";
       if(err == EPERM)  return "EPERM";
       if(err == EPIPE)  return "EPIPE";

       return "<UNKNOWN>";
   }	


   /** Check whether file descriptor is regular file */
   bool fd_is_regular_file(int fd)
   {		
        struct stat fd_info; 
        // int fstat(int fd, struct stat *statbuf);
        int r = fstat(fd, &fd_info);
        return S_ISREG(fd_info.st_mode);
   }

   bool fd_is_directory(int fd)
   {
       struct stat fd_info; 
       // int fstat(int fd, struct stat *statbuf);
       int r = fstat(fd, &fd_info);
       return S_ISDIR(fd_info.st_mode);	
   }

   void print_errno_details(int err)
   {
       std::fprintf(stderr , "\n   =>    errno(int) = %d" 
                             "\n   =>    errno(str) = %s"
                             "\n   => errno message = %s \n"
                             , err, errno_to_cstring(err), strerror(err));
        std::fflush(stderr);
   }

   int main(int argc, char** argv)
   {
       std::puts(" [INFO] Program started. ");

       if(argc < 3){
               std::fprintf(stderr, " Usage:                             \n");
               std::fprintf(stderr, "  => To read a file:                \n");
               std::fprintf(stderr, "    $ %s file <FILE>                \n", argv[0]);
               std::fprintf(stderr, "  => To read stdin (console input): \n");
               std::fprintf(stderr, "    $ %s file -stdin                \n", argv[0]);
               return 0;
       }

       // Compare two c-strings return 0 (zero) when they are equal.
       // int strcmp(const char *s1, const char *s2)
       if( strcmp(argv[1], "file") != 0 )
       {
               std::fprintf(stderr, " [ERROR] Expected command file. \n");
               return EXIT_FAILURE;
       }

       // Variable for holding a file descriptor 
       int fd; 

       // The library-call open() attempts to open a file  and returns a "file-descriptor" 
       // (integer number ) when the operation is successful. The library-call 
       // returns (-1) when the operation fails. 
       // Note: It encapsulates the 'open' system call. 
       // 	
       if( strcmp(argv[2], "-stdin") == 0)
               fd = STDIN_FILENO; 
       else 
               fd = open(argv[2], O_RDONLY);

       if(fd == -1){
               // Get error flag 'errno' to get more details about current error.
               int err = errno;
               std::fprintf(stderr ," [ERROR] Failed to open file. ");
               print_errno_details(err);
               return EXIT_FAILURE;
       }

       std::fprintf(stdout, " [INFO] ?? File is regular file = %s \n"
                                 , fd_is_regular_file(fd) ? "TRUE" : "FALSE"  );
       std::fprintf(stdout, " [INFO] ?? File is directory file = %s \n"
                                 , fd_is_directory(fd) ? "TRUE" : "FALSE"  );				  
       // Flush file => Force changes to be immeditely written.
       std::fflush(stdout);

       // Buffer maximum size in bytes 
       constexpr size_t BUFFER_MAX_SIZE = 200; 	
       char buffer[BUFFER_MAX_SIZE];

       // Stream BUFFER_MAX_SIZE bytes from file descriptor 
       // to STDOUT_FILENO (file descriptor).
       //---------------------------------------------------
       ssize_t ret; 
       do {
               ret = read(fd, buffer, BUFFER_MAX_SIZE);		
               if(ret == -1) {
                       int err = errno; 
                       std::fprintf(stderr, " [ERROR] An error has happened => ");
                       print_errno_details(err);
                       close(fd);
                       return EXIT_FAILURE;
               }		
               ::write(STDOUT_FILENO, buffer, ret);
       } while( ret != 0);

       // Always close the file descriptor.
       close(fd);

       return 0;
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ unix-low-level-io.cpp -o unix-low-level-io.bin -std=c++1z -Wall -Wextra
#+END_SRC

Running:

  + Run 1

#+BEGIN_SRC sh 
 $ >> ./unix-low-level-io.bin 
 [INFO] Program started. 
 Usage:                             
  => To read a file:                
    $ ./unix-low-level-io.bin file <FILE>                
  => To read stdin (console input): 
    $ ./unix-low-level-io.bin file -stdin                
#+END_SRC

 + Run 2: 

#+BEGIN_SRC sh 
   $ >> ./unix-low-level-io.bin file /proc/filesystems 
   [INFO] Program started. 
   [INFO] ?? File is regular file = TRUE 
   [INFO] ?? File is directory file = FALSE 
  nodev	sysfs
  nodev	tmpfs
  nodev	bdev
  nodev	proc
  nodev	cgroup
  nodev	cgroup2
  ... ... ... 

  $ >> ./unix-low-level-io.bin file /etc/resolv.conf 
   [INFO] Program started. 
   [INFO] ?? File is regular file = TRUE 
   [INFO] ?? File is directory file = FALSE 
  # Generated by NetworkManager
  nameserver 194.165.12.10
#+END_SRC

 + Run 3: (Error)

#+BEGIN_SRC sh 
 $ >> ./unix-low-level-io.bin file /etc/resosad
 [INFO] Program started. 
 [ERROR] Failed to open file. 
   =>    errno(int) = 2
   =>    errno(str) = ENOENT
   => errno message = No such file or directory 

 $ >> ./unix-low-level-io.bin file /etc/shadow
 [INFO] Program started. 
 [ERROR] Failed to open file. 
   =>    errno(int) = 13
   =>    errno(str) = <UNKNOWN>
   => errno message = Permission denied 

 $ >> ./unix-low-level-io.bin file /
 [INFO] Program started. 
 [INFO] ?? File is regular file = FALSE 
 [INFO] ?? File is directory file = TRUE 
 [ERROR] An error has happened => 
   =>    errno(int) = 21
   =>    errno(str) = <UNKNOWN>
   => errno message = Is a directory 
#+END_SRC

 + Run 4 - read stdin file descriptor _STDIN_FILENO_

#+BEGIN_SRC 
   $ >> ./unix-low-level-io.bin file -stdin
   [INFO] Program started. 
   [INFO] ?? File is regular file = FALSE 
   [INFO] ?? File is directory file = FALSE 


  Hello world
  Hello world
   Unix-linux file descriptors - Low level IO
   Unix-linux file descriptors - Low level IO

  # User types Ctrl+D to close STDIN 
#+END_SRC

** Low level IO - creat() 

Creates a file using Unix-low level IO function creat() which
encapsulates the creat() system-call.

File: unix-creat.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 

   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   #include <cstring>

   void print_errno_details(int err);

   int main(int argc, char** argv)
   {
       // File is created with read, write permissions for owner 
       // ,groups and others
       mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;

       int fd = creat("/tmp/my-sample-file.txt", mode);
       if(fd  == -1){
           print_errno_details(errno);
           return EXIT_FAILURE;
       }

       constexpr size_t BUFFER_SIZE = 500;
       char buffer[BUFFER_SIZE];

       // Fill the whole buffer with '\0' null char characters
       memset(buffer, '\0', BUFFER_SIZE);

       // strcpy => Copy string literal to buffer. 
       strcpy(buffer, " [LINE 0] Write this message to buffer\n");
       fprintf(stdout, " Buffer size (non blank chars) = %zu \n", strlen(buffer));
       // Write strlen(buffer) bytes to file descriptor 
       write(fd, buffer, strlen(buffer));

       strcpy(buffer, " [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX\n");
       fprintf(stdout, " Buffer size (non blank chars) = %zu \n", strlen(buffer));
       fprintf(stdout, " Buffer content = '%s' \n", buffer);
       // Write strlen(buffer) bytes to file descriptor 
       write(fd, buffer, strlen(buffer));

       strcpy(buffer, " [LINE 2] FreeRTOS Linux RTAI Real-time RTMES QNX\n");
       write(fd, buffer, strlen(buffer));

       close(fd);
       return EXIT_SUCCESS;
   }

   // Ruires: #include <string>
   void print_errno_details(int err)
   {
           std::fprintf(stderr , "\n   =>    errno(int) = %d" 
                                 "\n   => errno message = %s \n"
                               , err, strerror(err));
           std::fflush(stderr);
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ unix-creat.cpp -o unix-creat.bin -std=c++1z -Wall -Wextra -g 
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ >> ./unix-creat.bin 
  Buffer size (non blank chars) = 39 
  Buffer size (non blank chars) = 44 
  Buffer content = ' [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX
 '
#+END_SRC

Content of generated file: 

#+BEGIN_SRC sh 
  $ >> cat /tmp/my-sample-file.txt 
  [LINE 0] Write this message to buffer
  [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX
  [LINE 2] FreeRTOS Linux RTAI Real-time RTMES QNX
#+END_SRC

Trace library-calls with _ltrace_ application: 
 
  +  $ ltrace ./unix-creat.bin

#+BEGIN_SRC sh 
  $ >> ltrace ./unix-creat.bin

  _ZNSt8ios_base4InitC1Ev(0x4040a9, 0xffff, 0x7ffcfe326598, 224) = 0
  __cxa_atexit(0x4010e0, 0x4040a9, 0x402008, 6)                  = 0
  creat(0x402010, 420, 0x7ffcfe326598, 256)                      = 3
  memset(0x7ffcfe326280, '\0', 500)                              = 0x7ffcfe326280
  strlen(" [LINE 0] Write this message to "...)                  = 39
  fprintf(0x7f95f2612500, " Buffer size (non blank chars) ="..., 39 Buffer size (non blank chars) = 39 
  ) = 37
  strlen(" [LINE 0] Write this message to "...)                  = 39
  write(3, " [LINE 0] Write this message to "..., 39)            = 39
  strlen(" [LINE 1] Unix, BSD, OSX, LINUX,"...)                  = 44
  fprintf(0x7f95f2612500, " Buffer size (non blank chars) ="..., 44 Buffer size (non blank chars) = 44 
  ) = 37
  fprintf(0x7f95f2612500, " Buffer content = '%s' \n", " [LINE 1] Unix, BSD, OSX, LINUX,"... Buffer content = ' [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX
  ' 
  ) = 66
  strlen(" [LINE 1] Unix, BSD, OSX, LINUX,"...)                  = 44
  write(3, " [LINE 1] Unix, BSD, OSX, LINUX,"..., 44)            = 44
  strlen(" [LINE 2] FreeRTOS Linux RTAI Re"...)                  = 50
  write(3, " [LINE 2] FreeRTOS Linux RTAI Re"..., 50)            = 50
  close(3)                                                       = 0
  _ZNSt8ios_base4InitD1Ev(0x4040a9, 0, 0x4010e0, 1)              = 0x7f95f2965e40
  +++ exited (status 0) +++

#+END_SRC

Trace system-calls with _strace_ application: 

  +  $ strace ./unix-creat.bin

#+BEGIN_SRC sh 
  $ strace ./unix-creat.bin 

  execve("./unix-creat.bin", ["./unix-creat.bin"], 0x7fff489b8e40 /* 83 vars */) = 0
  brk(NULL)                               = 0x57c000
  arch_prctl(0x3001 /* ARCH_??? */, 0x7fff751bd910) = -1 EINVAL (Invalid argument)
  access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
   ... ... ... ... ... ... ... ... ... ... ... ... ... ...
   ... ... ... ... ... ... ... ... ... ... ... ... ... ...

  mprotect(0x7fed4e032000, 4096, PROT_READ) = 0
  munmap(0x7fed4dfe4000, 136250)          = 0
  brk(NULL)                               = 0x57c000
  brk(0x59d000)                           = 0x59d000
  creat("/tmp/my-sample-file.txt", 0644)  = 3
  fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0xc), ...}) = 0
  write(1, " Buffer size (non blank chars) ="..., 37) = 37
  write(3, " [LINE 0] Write this message to "..., 39) = 39
  write(1, " Buffer size (non blank chars) ="..., 37) = 37
  write(1, " Buffer content = ' [LINE 1] Uni"..., 63) = 63
  write(1, "' \n", 3)                     = 3
  write(3, " [LINE 1] Unix, BSD, OSX, LINUX,"..., 44) = 44
  write(3, " [LINE 2] FreeRTOS Linux RTAI Re"..., 50) = 50
  close(3)                                = 0
  exit_group(0)                           = ?
  +++ exited with 0 +++
#+END_SRC
** Information about current process 

File: current-process.cpp 

#+BEGIN_SRC cpp 
   #include <iostream> 
   #include <string> 
   #include <cstring> 

   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   #include <limits.h> // PATH_MAX constant (macro)

   auto get_cwd() -> std::string;
   auto set_cwd(const std::string& path) -> void;
   auto read_symlink(std::string const& path) -> std::string;

   int main(int argc, char** argv)
   {
       // Unique process ID (identifier) number 
       fprintf(stdout, "   => Process PID = %d \n", ::getpid());

       // PID for parent process
       fprintf(stdout, "   => Process PID = %d \n", ::getppid());

       // Current directory 
       fprintf(stdout, "   => Current directory = %s \n", get_cwd().c_str());

       fprintf(stdout, "\n Change the curren directory to /etc \n");
       set_cwd("/etc");
       fprintf(stdout, "   => Current directory = %s \n", get_cwd().c_str());

       // Note: It only works on Linux. The directory /proc/self is a pseudo-directory 
       //       whith pseudo-files containing information about the current process. 
       // 
       // the file /proc/self/exe is a symbolic link to the current executable.
       std::string exe_file = read_symlink("/proc/self/exe");
       fprintf(stdout, "  => Absolute Path of current executable = %s \n", exe_file.c_str());

       // Current directory 
       std::string exe_dir = read_symlink("/proc/self/cwd");
       fprintf(stdout, "  => Current directory of this executable = %s \n", exe_dir.c_str());

       fprintf(stdout, " [INFO] Finish Ok. \n");
       return 0;
   }

   // ----------- Functions Implementations ------------// 
   // 

   /** Get current working directory of current process */
   auto get_cwd() -> std::string 
   {
       char* buffer = ::getcwd(nullptr, 0);
       auto cwd = std::string(buffer);
       // Note buffer was allocated with malloc 
       free(buffer);
       return cwd;
   }

   /** Set current working directory for current process. */
   auto set_cwd(const std::string& path) -> void 
   {
        int status = ::chdir(path.c_str());
        if(status < 0)
            throw std::runtime_error("Failed to change directory.");
   }

   /** Read value of symbolic link 
    *  
    * Requires: <limits.h>, <sys/types.h>, <sys/stats.h>
    */
   auto read_symlink(std::string const& path) -> std::string 
   {
       // Create a buffer with size PATH_MAX + 1 filled with 0 ('\0'), null characters
       std::string buffer(PATH_MAX, 0);
       // ssize_t readlink(const char *pathname, char *buf, size_t bufsiz);
       ssize_t nread = ::readlink(path.c_str(), &buffer[0], PATH_MAX);
       if(nread == -1){
           fprintf(stderr, " Error: %s \n", strerror(errno));
           throw std::runtime_error("Error: unable to read symlink. Check 'errno' variable");
       }
       buffer.resize(nread);
       return buffer;
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
   $ >> g++ current-process.cpp -o current-process.elf -Wall -Wextra -ggdb
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ >> ./current-process.elf 
    => Process PID = 719155 
    => Process PID = 678179 
    => Current directory = /home/mxpkf8/temp-projects/unix-explore 

  Change the curren directory to /etc 
    => Current directory = /etc 
   => Absolute Path of current executable = /home/mxpkf8/temp-projects/unix-explore/current-process.elf 
   => Current directory of this executable = /etc 
  [INFO] Finish Ok.
#+END_SRC

** Dynamic Loading Shared Libraries / dlopen() API 
*** Overview 

The dlopen API provide access to the _dynamic linker_ services allowing
the current process to load and unload shared objects or shared
libraries in its address space (virtual memory).

This API for loading shared libraries is not only available on Linux,
it also can be found in FreeBSD, NetBSD, MacOSX, Android and so on.

Use cases: 

  + Load new code at-runtime

  + Load third-party code a runtime

  + Plugin systems, extensions or addons.

  + Load native code extensions in languages with interpreters written
    in C, such as Python, Ruby, Lua and so on. Note: Python native
    extensions are shared libraries. 

The Dlopen() API is available on most Unix-like operating systems,
such as: 

   * Linux 
   * MacOSX 
   * FreeBDS
   * NetBSD
   * OpenBSD
   * QNX

Documentation: 

  + http://gnu.wiki/man3/dlopen.3.php

  + [[https://man7.org/linux/man-pages/man3/dlopen.3.html][Dlopen API - Linux Manpages]]

  + [[https://www.freebsd.org/cgi/man.cgi?query=dlopen&apropos=0&sektion=0&manpath=SuSE+Linux%252Fi386+7.3&format=html][Free BSD - dlopen API documentation]]

  + [[https://docs.oracle.com/cd/E19048-01/chorus5/806-7014/6jftsjfdq/index.html][Dlopen - Oracle Documentation]]

  + [[http://www.qnx.com/developers/docs/6.5.0SP1.update/com.qnx.doc.neutrino_lib_ref/d/dlopen.html][Dlopen - QNX documentation]]

  + [[https://dwheeler.com/program-library/Program-Library-HOWTO/x172.html][Dynamically Loaded (DL) Libraries]]


Further Reading: 

  + [[https://cseweb.ucsd.edu/~gbournou/CSE131/the_inside_story_on_shared_libraries_and_dynamic_loading.pdf][Inside the history on shared libraries and dynamic loading]]

  + [[https://hackaday.com/2018/07/12/its-all-in-the-libs-building-a-plugin-system-using-dynamic-loading/][It 's all in the libs - Building a Plugin system using Dynamic Loading]]

  + [[http://docencia.ac.upc.edu/FIB/USO/Bibliografia/unix-c-libraries.html][Building And Using Static And Shared "C" Libraries]]

  + [[https://www.informit.com/articles/article.aspx?p=22435][More Shared Libraries-Dynamic Loading and Unloading]]

  + https://grugq.github.io/docs/subversiveld.pdf

  + [[https://github.com/mgood7123/universal-dynamic-loader][universal-dynamic-loader]] for Linux - "min-dl: minimal dynamic linker implementation"


Headers and libraries: 

  + Header:  #include <dlfcn.h>
  + Linking: (-ldl) flag 

 _Function dlopen()_:

  + Doc: $ man dlopen 
  + Loads a shared library and returns a _handle_ or _opaque pointer_
    casted as void pointer. The term _opaque_ means that the
    implementation is hidden and the pointer is only meant to be
    passed around to other functions.
  + Note: When this function fails, it returns null pointer.

#+BEGIN_SRC cpp 
      void* dlopen(const char* filename, int flags);
#+END_SRC

 _Function dlsym()_:

  + Doc: $ man dlsym
  + Obtains address of a shared library symbol from _handle_ (from
    dlopen). 
  + Params:
    + handle => Shared library handle obtained from _dlopen_
    + symbol  => Name of symbol to be loaded.
  + Return:
    + Address of symbol casted as void*. It can be a function-pointer
      or a pointer to global variable. If the symbol is not found, the
      function returns a null pointer. 

#+BEGIN_SRC cpp 
    void* dlsym(void* handle, const char* symbol);
#+END_SRC

 _Function dlvsym()_:

  + Doc: $ man dlvsym
    + Loads a specific version of a symbol. 

#+BEGIN_SRC cpp 
    void* dlvsym(void *handle, char *symbol, char *version);
#+END_SRC

 _Function dlclose()_: 

  + Doc: $ man dlclose()

#+BEGIN_SRC cpp 
  int dlclose(void *handle);
#+END_SRC

 _Function dlerror()_ 
   + Obtaines error messages from dlopen API.
   + Doc: $ man dlerror()

#+BEGIN_SRC cpp 
  char* dlerror(void);
#+END_SRC

 *Simplified type signatures with a C++-friendly notation*

#+BEGIN_SRC cpp 
   // Opaque pointer for shared library (shared object) handle 
   using HND = void* ; 
   // Opaque pointer for shared library symbol 
   using SYM = void* ; 

   HND  dlopen( const char* filename, int flags);
   SYM   dlsym( HND handle, const char* symbol);
   SYM  dlvsym( HND handle, char *symbol, char *version);
   int dlclose( HND handle );
#+END_SRC

 *Usage example* 

#+BEGIN_SRC cpp 
   #include <dlfcn.h>

   // Opaque pointer for shared library (shared object) handle 
   using HND = void* ; 
   // Opaque pointer for shared library symbol 
   using SYM = void* ; 

   void load_library()
   {
       // Load shared library 
       HND hnd = dlopen("/path/to/shared-library.so", RTLD_LAZY | RTLD_GLOBAL); 
       if(hnd == nullptr)
       {
          std::cerr << "  [ERROR] " << dlerror() << "\n";
          throw std::runtime_error("Error: unable to load shared library"); 
       }

       // Load symbol 
       SYM hsym = dlsym(hnd, "name_of_function"); 

       // if(!hsym)
       if(hsym == nullptr)
       {
          throw std::runtime_error("Error: symbol not found"); 
       }

       // Type alias for function pointer in modern C++ 
       //  => Note: The function to be loaded can only have C-linkage. 
       using name_of_function_t = void (*) (int param0, double param1, const char* param3);

       // Type alias for function pointer in old C++ (C++98)
       typedef void (*name_of_function_t) (int param0, double param1, const char* param3);       

       auto name_of_function_ptr = reinterpret_cast<name_of_function_t>(hsym); 
   
       // Call loaded function (Function pointer)
       name_of_function_ptr(100, 2.51, "string");

       // Unload shared library 
       dlclose(hsym);
   }
#+END_SRC

*** GTK3/GTK2 GUI using dynamic loading - low level 

The following sample code is a GTk3 or GTK2 GUI graphical user
interface application with GTK functions loaded from a GTK shared
library, without any compile-time linking. The advantage of this
approach is the greater portability across different versions of GTk
and the ability to switch between GT3 and GT2.

GIST: 
  + https://gist.github.com/d81dd9c422dc93ad4104b5e79259afdf

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.9)
   project(gtk-sample)

   #========== Global Configurations =============#
   #----------------------------------------------#

   set(CMAKE_CXX_STANDARD 17)     
   set(CMAKE_VERBOSE_MAKEFILE ON)

          add_executable( gtk-dlopen gtk-dlopen.cpp)
   target_link_libraries( gtk-dlopen dl )   
#+END_SRC

File: gtk-dlopen.cpp 

#+BEGIN_SRC cpp 
    #include <iostream>
    #include <cstring> 
    #include <cassert> 

    // Uses: dlopen(), dlclose(), ... 
    #include <dlfcn.h>

    // ---- Copied from GTK headers ------// 
    typedef char            gchar;
    typedef short           gshort;
    typedef long            glong;
    typedef int             gint;
    typedef gint            gboolean;
    typedef unsigned char   guchar;
    typedef unsigned short  gushort;
    typedef unsigned long   gulong;
    typedef unsigned int    guint;
    typedef float           gfloat;
    typedef double          gdouble;
    typedef void*           gpointer;
    typedef const void*     gconstpointer;

    enum class GtkWindowType
    {
        GTK_WINDOW_TOPLEVEL,
        GTK_WINDOW_POPUP
    };

    enum class GConnectFlags
    {
      G_CONNECT_AFTER	= 1 << 0,
      G_CONNECT_SWAPPED	= 1 << 1
    };

    template<typename TFun>
    TFun load_symbol(void* hnd, std::string symbol)
    {
        void* hSym = dlsym(hnd, symbol.c_str());
        if(hSym == nullptr)
        {
            std::string msg = std::string(" [Error] symbol not found: ") + symbol;
            throw std::runtime_error(msg);
        }    
        return reinterpret_cast<TFun>(hSym);
    }

    // Opaque type (aka incomplete type)
    struct GClosure;

    // -------- Function Pointers type aliases -------------------//
    using GCallback      = void  (*) (void);
    using GClosureNotify = void  (*) (gpointer data, GClosure* closure);
    using g_signal_connect_data_t =  gulong (*) (   gpointer instance
                                                  , const gchar*    detailed_signal
                                                  , GCallback       c_handler
                                                  , gpointer        data
                                                  , GClosureNotify  destroy_data
                                                  , GConnectFlags	connect_flags
                                              );

    int main(int argc, char** argv)
    {    
        std::string shared_lib =  [&]() -> std::string 
        {
            if(argc < 2) return "libgtk-3.so.0";
            return argv[1];
        }();

        std::cout << " [INFO] Loading shared library: " << shared_lib << "\n";

        //  void *dlopen(const char *filename, int flags);

        // Handle to shared library 
        void* hnd = dlopen(shared_lib.c_str(), RTLD_NOW | RTLD_GLOBAL);
        if(hnd == nullptr){ fprintf(stderr, "%s\n", dlerror());  }
        assert( hnd != nullptr );

        void* hSym = nullptr; 

        // --------- Load gtk_init_check function pointer ------- // 
        hSym = dlsym(hnd, "gtk_init_check");
        assert(hSym != nullptr);
        using gtk_init_check_t = gboolean (*) (int* argc, char*** argv);
        auto gtk_init_check = reinterpret_cast<gtk_init_check_t>(hSym);   

        // ------- Load remaining function pointers (symbols) --------// 
        //-----------------------------------------------------------//

        // opaque pointer 
        struct GtkWidget;

        using gkt_window_new_t = GtkWidget* (*) (int);
        auto gtk_window_new  = load_symbol<gkt_window_new_t>(hnd, "gtk_window_new");    
        auto gtk_widget_show = load_symbol<void (*) (GtkWidget*)>(hnd, "gtk_widget_show");
        auto gtk_main        = load_symbol<void (*) ()>(hnd, "gtk_main");

        using gtk_window_set_title_t = void (*) (GtkWidget* window, const gchar* title);
        auto gtk_window_set_title = load_symbol<gtk_window_set_title_t>(hnd, "gtk_window_set_title");

        using gtk_widget_set_size_t = void (*) (GtkWidget*, gint, gint);
        auto gtk_widget_set_size = load_symbol<gtk_widget_set_size_t>(hnd, "gtk_widget_set_size_request");

        auto gtk_main_quit = load_symbol<void (*) ()>(hnd, "gtk_main_quit");

        auto gtk_signal_connect_data 
              = load_symbol<g_signal_connect_data_t>(hnd, "g_signal_connect_data");

        /** ------- Build Window GUI - Graphical User Interface ----------**/

        // Call function pointer 
        gtk_init_check(&argc, &argv);

        GtkWidget* window = gtk_window_new( (int) GtkWindowType::GTK_WINDOW_TOPLEVEL);
        gtk_widget_set_size(window, 400, 500);
        gtk_window_set_title(window, "My GTK Window");
        gtk_widget_show(window);    

        gtk_signal_connect_data(  window         // Widget 
                                , "destroy"      // Event name 
                                , gtk_main_quit  // Callback                             
                                , nullptr        // Pointer to data (closure )
                                , nullptr 
                                , (GConnectFlags) 0 // GConnect flags 
                                );

        std::cout << " [INFO] Window running. OK! " << "\n";
        gtk_main();

        // Always close shared library handler.
        dlclose(hnd);

        std::cout << " [INFO] Shutdown gracefully. Ok. \n" ;
        return EXIT_SUCCESS;
    }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/d81dd9c422dc93ad4104b5e79259afdf && cd gist 
  $ g++ gtk-dlopen.cpp -o gtk-dlopen.bin -std=c++1z -ldl -ggdb -Wall -Wextra   
#+END_SRC

Checking the dependencies of gtk-dlopen.bin 

#+BEGIN_SRC sh 
   $ >> ldd gtk-dlopen.bin 
          linux-vdso.so.1 (0x00007ffd23fc4000)
          libdl.so.2 => /lib64/libdl.so.2 (0x00007f6a78428000)
          libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007f6a78238000)
          libm.so.6 => /lib64/libm.so.6 (0x00007f6a780f2000)
          libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007f6a780d7000)
          libc.so.6 => /lib64/libc.so.6 (0x00007f6a77f0d000)
          /lib64/ld-linux-x86-64.so.2 (0x00007f6a78453000)
#+END_SRC

Running: (load GTK shared library /lib64/libgtk-3.so.0)

#+BEGIN_SRC sh 
 $ >> ./gtk-dlopen.bin 
 [INFO] Loading shared library: /lib64/libgtk-3.so.0
 [INFO] Window running. OK! 
 [INFO] Shutdown gracefully. Ok. 
#+END_SRC

Running: (load GK2 shared library )

#+BEGIN_SRC sh 
   $ >> ./gtk-dlopen.bin /usr/lib64/libgtk-x11-2.0.so 
   [INFO] Loading shared library: /usr/lib64/libgtk-x11-2.0.so
   [INFO] Window running. OK! 
   [INFO] Shutdown gracefully. Ok. 
#+END_SRC

Verify exported symbols by gtk3 shared library: 

#+BEGIN_SRC sh 
    $ >> nm -D /lib64/libgtk-3.so.0 | grep init
           ... ... ... ... ..
           ... ... ... ... ..
           U g_async_initable_new_async
           U g_async_initable_new_finish
           U g_datalist_init
           U g_hash_table_iter_init
           U g_initable_get_type
           U g_initable_new
           U g_initially_unowned_get_type
           U g_mutex_init
           U g_once_init_enter
          ... ... ... ... ..
          ... ... ... ... ..
#+END_SRC

*** GTK3/GTK2 GUI using dynamic loading - high level C++ wrapper 

This proof-of-concept code contains a high-level wrapper class
SharedLibrary for abstracting away the dlopen() API. This class is
used for loading GTK3 or GTk2 shared library at runtime and then
showing modal notifications dialogs. The advantage of the dynamic
loading approach is the flexibility, portability and easier deployment
as the binary does not depends on any particular GTK shared library
version.

Note: 

  + The code of the class SharedLibrary can be reused on any other
    unix-like operating system with dlopen() API, such as FreeBDS,
    NetBSD, MacOSX and so on.

  + The Windows API for dynamic loading is LoadLibrary(),
    GetProcAddress(). 

GIST: 
  + https://gist.github.com/6bbb3b9491d4fad01d3875a559b7365b

  *Project Files* 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(gtk-dynamic-load-dialog)

  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  # ---- TARGETS Configuration ---------------#
         add_executable( gtk-dialog gtk-dialog.cpp gtk_types.hpp)
  target_link_libraries( gtk-dialog dl ) 
#+END_SRC

File: gtk-dialog.cpp 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string> 
  #include <cstring> 
  #include <cassert> 

  // Uses: dlopen(), dlclose(), ... 
  #include <dlfcn.h>

  #include "gtk_types.hpp"

  /** Requires header: <dlfcn.h> and linking flag (-ldl) */
  class SharedLibrary
  {
  public:
      using HND  = void*; 
      using HSYM = void*;
  private:
      HND         m_hnd  = nullptr; 
      std::string m_lib = "" ; 
      int         m_flags = 0;
  public:
      SharedLibrary(){}    
      ~SharedLibrary(){ this->unload(); }

      // Constructor delegation 
      SharedLibrary(std::string library)
          : SharedLibrary(library, RTLD_NOW | RTLD_GLOBAL)
      {  }

      SharedLibrary(std::string library, int flags)
      {
          this->load(library, flags);
      }

      // Disable copy constructor and copy-assignment operator 
      SharedLibrary(SharedLibrary const &) = delete;
      SharedLibrary& operator=(SharedLibrary const &) = delete;

      // Move constructor 
      SharedLibrary(SharedLibrary&& rhs) 
      {
          std::swap(m_hnd, rhs.m_hnd);
          std::swap(m_lib, rhs.m_lib);
          std::swap(m_flags, rhs.m_flags);
      }

      // Move assignment operator 
      SharedLibrary& operator=(SharedLibrary&& rhs) 
      {
          this->unload();
          std::swap(m_hnd, rhs.m_hnd);
          std::swap(m_lib, rhs.m_lib);
          std::swap(m_flags, rhs.m_flags);
          return *this;
      }

      HND         handler()   const { return m_hnd; }    
      bool        is_loaded() const { return m_hnd != nullptr; }    
      std::string library()   const { return m_lib; }

      /** Retrieve symbol from shared library */
      HSYM symbol_ptr(std::string name) const 
      {
          return ::dlsym(m_hnd, name.c_str());
      }

      /** @brief Get symbol from shared library
       ,* Note: The caller is resposible for checking if the symbol is (null) nullptr.
       ,*/
      template<typename TFun>
      TFun symbol(std::string name) const 
      {
          HSYM sym = ::dlsym(m_hnd, name.c_str());
          return reinterpret_cast<TFun>(sym);
      }

      /** @brief Attempts to load symbol and throws exception, if symbol is not found. */
      template<typename TFun>
      TFun symbol_or_fail(std::string name) const 
      {
          HSYM sym = ::dlsym(m_hnd, name.c_str());
        
          if(!sym){ 
              std::string msg = " [ERROR] Dlopen / dlsym() => unable find symbol";
              msg = msg + " <" + name + ">";
              throw std::runtime_error(msg); 
          }
          return reinterpret_cast<TFun>(sym);
      }

      void load(std::string library, int flags)
      {
          if(!this->is_loaded()) { this->unload(); }
          m_lib   = library;
          m_flags = flags;
          m_hnd = dlopen(library.c_str(), RTLD_NOW | RTLD_GLOBAL);        
          if(m_hnd == nullptr){ 
              std::string msg = " [ERROR] DlopenError: ";
              msg = msg + dlerror();
              throw std::runtime_error(msg);
          }
      }    

      void reload() 
      {
          this->unload();
          this->load(m_lib, m_flags);
      }

      void unload() 
      {
          if(!this->is_loaded()) { return; }
          ::dlclose(m_hnd);        
          m_hnd = nullptr;
      }

  }; // --- End of class SharedLibrary() ---- //

  using namespace GtkPP::fpointer;
  using namespace GtkPP::enums;

  struct GtkLib
  {
      SharedLibrary slib;

      GtkLib(std::string library)
          : slib( std::move(SharedLibrary(library)) )
      { 
          gtk_init_check         = slib.symbol_or_fail<gtk_init_check_t>("gtk_init_check");       
          gtk_main_quit          = slib.symbol_or_fail<gtk_main_quit_t>("gtk_main_quit");
          // gtk_main               = slib.symbol_or_fail<void (*) ()>("gtk_main");
          gtk_message_dialog_new = slib.symbol_or_fail<gtk_message_dialog_new_t>("gtk_message_dialog_new");
          gtk_widget_destroy     = slib.symbol_or_fail<gtk_widget_destroy_t>("gtk_widget_destroy");
          gtk_dialog_run         = slib.symbol_or_fail<gtk_dialog_run_t>("gtk_dialog_run");
          gtk_window_set_title   = slib.symbol<gtk_window_set_title_t>("gtk_window_set_title");

      }

      gtk_init_check_t         gtk_init_check; 
      gtk_main_quit_t          gtk_main_quit; 
      // gtk_main_t               gtk_main;
      gtk_message_dialog_new_t gtk_message_dialog_new;
      gtk_widget_destroy_t     gtk_widget_destroy;
      gtk_dialog_run_t         gtk_dialog_run;
      gtk_window_set_title_t   gtk_window_set_title;

      // Message box notification 
      void msgbox(  std::string title
                  , std::string text 
                  , GtkMessageType mtype = GtkMessageType::GTK_MESSAGE_INFO 
                  ) 
      {
         GtkWidget* dialog = this->gtk_message_dialog_new(  nullptr 
                                                  , (int) GtkDialogFlags::GTK_DIALOG_MODAL
                                                  , (int) mtype 
                                                  , (int) GtkButtonsType::GTK_BUTTONS_OK
                                                  , text.c_str()
                                                  );                                            
          assert( dialog != nullptr );    
          this->gtk_window_set_title(dialog, title.c_str());
          this->gtk_dialog_run(dialog);
          std::cout << " [INFO] Dialog destroyed OK " << "\n";
          this->gtk_widget_destroy(dialog);   
      }
  };


  int main(int argc, char** argv)
  {        
      // User can select his own GTK shared library, if it is not 
      // found. He can also select GTK2 shared library. 
      auto shared_lib =  [&]() -> std::string 
      {
          if(argc < 2) return "libgtk-3.so.0";
          return argv[1];
      }();
    
      std::cout << " [INFO] Loading shared library: " << shared_lib << "\n";   
      auto gtk = GtkLib{shared_lib};   

      // Alwas start the library before calling any GTK function 
      gtk.gtk_init_check(&argc, &argv);    

      gtk.msgbox("User notification", "Download completed. Ok.",     GtkMessageType::GTK_MESSAGE_INFO );    
      gtk.msgbox("Runtime error",     "KERNEL PANIC!! Reboot NOW!!", GtkMessageType::GTK_MESSAGE_ERROR );        

      std::cout << " [INFO] Shutdown gracefully. Ok. \n" ;
      return EXIT_SUCCESS;
  }
#+END_SRC

File: gtk_types.hpp 

#+BEGIN_SRC cpp 
  // ------ C++ Wrappers for dynamically loading GTK ----- //
  #ifndef _GTK_TYPES_HPP
  #define _GTK_TYPES_HPP

  namespace GtkPP 
  {
      namespace base {
          using gchar    = char;
          using gshort   = short;
          using glong    = long;
          using gint     = int;
          using gboolean = gint;
          using guchar   = unsigned short;
          using gulong   = unsigned long;
          using guint    = unsigned int;
          using gfloat   = float;
          using gdouble  = double;
          using gpointer = void*;          
          using gconstpointer = const void*;

      };
      // ------- Opaque Types / incomplete types ---------//
      namespace widget {        
          struct GtkWidget;
          struct GClosure;
          struct GtkWidget;
          struct GtkWindow;
          struct GtkDialog;
      };

      namespace enums {
          enum class GtkWindowType
          {
              GTK_WINDOW_TOPLEVEL,
              GTK_WINDOW_POPUP
          };

          enum class GConnectFlags
          {
          G_CONNECT_AFTER	= 1 << 0,
          G_CONNECT_SWAPPED	= 1 << 1
          };

          enum class GtkMessageType
          {
          GTK_MESSAGE_INFO,
          GTK_MESSAGE_WARNING,
          GTK_MESSAGE_QUESTION,
          GTK_MESSAGE_ERROR,
          GTK_MESSAGE_OTHER
          };

          enum class GtkButtonsType
          {
          GTK_BUTTONS_NONE,
          GTK_BUTTONS_OK,
          GTK_BUTTONS_CLOSE,
          GTK_BUTTONS_CANCEL,
          GTK_BUTTONS_YES_NO,
          GTK_BUTTONS_OK_CANCEL
          };

          enum class GtkDialogFlags
          {
          GTK_DIALOG_MODAL               = 1 << 0,
          GTK_DIALOG_DESTROY_WITH_PARENT = 1 << 1,
          GTK_DIALOG_USE_HEADER_BAR      = 1 << 2
          };
      };

      /** @brief Function pointers type aliases  */
      namespace fpointer 
      {
          using namespace base;
          using namespace widget;
          using enums::GConnectFlags;

          using GtkDialogFlags_t = int; 
          using GtkMessageType_t = int; 
          using GtkButtonsType_t = int;

          using gtk_init_check_t = gboolean (*) (int* argc, char*** argv);
          using gtk_dialog_run_t       = gint (*) (void* dialog);
          using gtk_widget_destroy_t   = void (*) (GtkWidget* widget);
          using gtk_window_set_title_t = void (*) (GtkWidget* window, const gchar* title);
          using gtk_main_quit_t        = void (*) ();

          using gtk_window_set_title_t = void (*) (GtkWidget* window, const gchar* title);


          using GCallback      = void  (*) (void);
          using GClosureNotify = void  (*) (gpointer data, GClosure* closure);
          using g_signal_connect_data_t =  gulong	(*) ( gpointer        instance
                                                      , const gchar*    detailed_signal
                                                      , GCallback       c_handler
                                                      , gpointer  	    data
                                                      , GClosureNotify  destroy_data
                                                      , GConnectFlags	connect_flags
                                                      );


          using gtk_message_dialog_new_t = GtkWidget* (*) ( GtkWindow       *parent,
                                                            GtkDialogFlags_t  flags,
                                                            GtkMessageType_t  type,
                                                            GtkButtonsType_t  buttons,
                                                            const gchar*    message_format
                                                          );


      };

  };

  #endif 
#+END_SRC

Building and running: 
 
#+BEGIN_SRC sh 
   # Download 
   $ >> git clone https://gist.github.com/6bbb3b9491d4fad01d3875a559b7365b gtk-dialog && cd gtk-dialog 

   # Configure 
   $ >> cmake --config Debug -H. -B_build

   # Build 
   $ >> cmake --build _build --target 

   # Run 
   $ >> _build/gtk-dialog 
   [INFO] Loading shared library: libgtk-3.so.0
   [INFO] Dialog destroyed OK 
   [INFO] Dialog destroyed OK 
   [INFO] Shutdown gracefully. Ok. 

#+END_SRC

** Launching processes with exec and fork system wrappers 

This code demonstrates the usage of exec and fork system-calls wrapper
functions, namely, execvp() and fork() functions. 

 *Relevant functions signature* 

Fork
  + Linux Manpage: "fork() creates a new process by duplicating the
    calling process.  The new process is referred to as the child
    process.  The calling process is referred to as the parent
    process."
  + Note: The function 'fork' is not the system call fork, but a
    C wrapper around this sytem call provided by the C runtime
    library. (GLIBC - GNU C library in the machine where this was tested.)

#+BEGIN_SRC cpp 
  pid_t fork(void);
#+END_SRC

Execvp (wraps exec system call)
  + The exec system calls is always called when a new process is
    launched/created. It replaces the process image of the current
    process with a new one from the launched executable.
  + Note: In addition to native executables, on Unix-like operating
    systems, an executable can also be any scripting file starting
    with shebang as first line such as "#!/usr/bin/env sh"

#+BEGIN_SRC cpp 
   int execvp(const char *file, char *const argv[]);
#+END_SRC

Waitpid => Waits for a state of change of a process.
  + It can be used for waiting for process termination. 
 
#+BEGIN_SRC cpp 
   pid_t waitpid(pid_t pid, int *wstatus, int options);
#+END_SRC

 *Documentation* 

  + [[https://man7.org/linux/man-pages/man2/fork.2.html][fork() Linux Manpage]]

  + [[https://www.freebsd.org/cgi/man.cgi?query=execvp][Execvp() => FreeBSD Manpage]]

 *Further Reading*

  + [[https://en.wikipedia.org/wiki/Fork_(system_call)][Fork (system call) - Wikipedia]]

  + [[http://people.cs.pitt.edu/~aus/cs449/ts-lecture14.pdf][Fork() System Calland ProcessesCS449 Spring 2016]]

  + [[https://www.cs.columbia.edu/~junfeng/11sp-w4118/lectures/unix.pdf][Chapter 0 - Operating system interfaces {PDF}]]

 *Sample Code* 

GIST: 
 + https://gist.github.com/133e91ba3732718cb228310173368674

File: unix-process.cpp 

#+BEGIN_SRC cpp 
   // ------ File: unix-process.cpp -----------------------------------------------------------//
   // Description: Shows hows to launch processes on Unix with Exec and Fork syscall wrappers.
   //-------------------------------------------------------------------------------------------//

   #include <iostream>
   #include <vector>

   // ----- Unix/Linux headers -----// 
   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   #include <sys/wait.h>

   #include <cstring> // Import: char* strerror(in errnum);

   // -------------- Declarations --------------------------//

   void print_errno_details(int err);
   void execvp_test();
   void execvp_cpp(std::string app, std::vector<std::string> args);

   // Launch a new process without terminate this process. 
   // It combines fork + exec system-calls. 
   void fork_exec(std::string app, std::vector<std::string> args);

   // -------------  MAIN() ------------------------------//

   int main(int argc, char** argv)
   {
        std::puts(" [INFO] Program started. ");

        if(argc < 2){
           std::printf(" Usage:  ./unix-process <OPTION>");
           return EXIT_SUCCESS;
        }

        std::string opt = argv[1];

        if(opt == "0")
        {
           execvp_test();
        }
        // Test execvp 
        if(opt == "1")
        {
            execvp_cpp("thunar", { "/etc" } );
            return EXIT_SUCCESS;
        }
        // Fork-exec 
        if(opt == "2")
        {
            fork_exec("konsole", { "-e", "tmux", "a"} );
        }	

        std::puts(" [TRACE] Finish execution. ");
        return 0;
   }

   // ------------- Definitions ------------------------//

   void print_errno_details(int err)
   {
           std::fprintf(stderr ,"\n   =>    errno(int) = %d" 
                                "\n   => errno message = %s \n"
                               , err, strerror(err));
           std::fflush(stderr);
   }


   // Test exec system-call wrapper function (execvp)
   void execvp_test()
   {    
           const char* app    = "thunar";

           const char* args[] = {  app     // Process name, can be anything 
                                  , "/etc"  // Arguments passed to the process 
                                  , nullptr // Always terminate the argument array with null pointer 
                                 };

           // Encapsulates execv system call. 
           // int execvp(const char *file, char *const argv[]);
           if( execvp(app, (char *const *) args) == -1)
           {
                 std::fprintf(stderr, " Error: unable to launch process");
                 print_errno_details(errno);
                 throw std::runtime_error("Error: failed to launch process");
           }

   }

   // C++ wrapper for the exevp() library-call 
   // It replaces the current process image with a new one 
   // from other executable. 
   void execvp_cpp(  std::string app
                   , std::vector<std::string> args)
   {
        std::vector<const char*> pargs;
        pargs.reserve(args.size() + 1);
        pargs.push_back(app.c_str());
        for(auto const& a: args){ pargs.push_back(a.c_str()); }
        pargs.push_back(nullptr);

        // Signature: int execvp(const char *file, char *const argv[]);

        // execvp(app.c_str(), execvp(app.c_str(), (char* const *) pargs.data() )
        int status = execvp(app.c_str(), (char* const*) pargs.data() );
        if( status == -1)
        {
             std::fprintf(stderr, " Error: unable to launch process");
             print_errno_details(errno);
             throw std::runtime_error("Error: failed to launch process");
        }
   }

   void fork_exec(std::string app, std::vector<std::string> args)
   {
        std::printf(" [TRACE] <BEFORE FORK> PID of parent process = %d \n", getpid());

        // PID of child process (copy of this process)
        pid_t pid = fork();

        if(pid == -1)
        {
            std::fprintf(stderr, "Error: unable to launch process");
            print_errno_details(errno);
            throw std::runtime_error("Error: unable to launch process");
        }
        if(pid == 0){
             std::printf(" [TRACE] Running on child process => PID_CHILD = %d \n", getpid());	

             // Close file descriptors, in order to disconnect the process from the terminal.
             // This procedure allows the process to be launched as a daemon (aka service).
             close(STDOUT_FILENO);
             close(STDERR_FILENO);
             close(STDIN_FILENO );

             // Execvp system call, replace the image of this process with a new one
             // from an executable. 
             execvp_cpp(app, args);		
             return;
        }

        std::printf(" [TRACE] <AFTER FORK> PID of parent process = %d \n", getpid());

        // pid_t waitpid(pid_t pid, int *wstatus, int options);
        int status;

        std::printf(" [TRACE] Waiting for child process to finish. ");

        // Wait for child process termination.
        // From header: #include <sys/wait.h>
        if(waitpid(pid, &status, 0) == -1)
        {
            print_errno_details(errno);
            throw std::runtime_error("Error: cannot wait for child process");
        }

        std::printf(" [TRACE] Child process has been terminated Ok.");
       // -------- Parent process ----------------//
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
   $ >> g++ unix-process.cpp -o unix-process.bin -std=c++1z -Wall -Wextra -g
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   ~/t/unix-explore
   $ >> ./unix-process.bin 0
   [INFO] Program started. 

   ~/t/unix-explore
   $ >> ./unix-process.bin 1
   [INFO] Program started. 

   ~/t/unix-explore
   $ >> ./unix-process.bin 2
   [INFO] Program started. 
   [TRACE] <BEFORE FORK> PID of parent process = 774929 
   [TRACE] <AFTER FORK> PID of parent process = 774929 
   [TRACE] Running on child process => PID_CHILD = 774930 
   [TRACE] Waiting for child process to finish.  [TRACE] Child process has been terminated Ok. [TRACE] Finish execution. 
#+END_SRC
** Reading/Listings directory contents 

API Documentations: 
 
  + [[https://man7.org/linux/man-pages/man3/opendir.3.html][Linux Manpage - opendir()]]

  + [[https://www.freebsd.org/cgi/man.cgi?query=opendir&sektion=3][FreeBSD manpage - opendir()]]

  + [[https://www.man7.org/linux/man-pages/man3/readdir.3.html][Linux manpage - readdir()]]

Functions used: 

#+BEGIN_SRC cpp 
   DIR *opendir(const char *name);

   int readdir(   unsigned int fd
                , struct old_linux_dirent* dirp,
                , unsigned int count);
#+END_SRC

File: unix-readdir.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>

   // #include <string>
   #include <sys/types.h>
   #include <dirent.h>  // Get function opendir
   #include <errno.h>

   #include <sys/types.h>
   #include <sys/stat.h>
   #include <unistd.h>


   template<typename Callback>
   void iterate_directory(const std::string& path, Callback&& callback)
   {
       DIR *dir;
       struct dirent *dp;

       dir = opendir(path.c_str()) ;

       // To determine the cause of error - It is necessary to check the error code.
       if (dir == nullptr) throw std::runtime_error("Error: Cannot read directory");

       while ((dp = readdir(dir)) != nullptr) 
       {
          if(path == "/")
               callback(dp->d_name);
          else 
               callback(path + "/" + dp->d_name);		
       };
       closedir(dir);
   }

   int main(int argc, char** argv)
   {
        std::cout << " List directory contents " << std::endl;

        if(argc < 2)
        {
            std::cout << "Usage: ./unix-readdir <DIRECTORY>" << "\n";
            return EXIT_SUCCESS;
        }

        int idx = 0;
        iterate_directory(argv[1], [&idx](auto const& path)
        {
            std::cout << "  [" << idx++  << "] path => " << path << "\n";
        });
        return EXIT_SUCCESS;
   }

#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ unix-readdir.cpp -o unix-readdir.bin -std=c++1z -g -Wall -Wextra 
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ >> ./unix-readdir.bin /
   List directory contents 
    [0] path => srv
    [1] path => sys
    [2] path => ..
    [3] path => opt
    [4] path => .
    [5] path => run
    [6] path => media
    ... ... ... 
    [18] path => lib
    [19] path => usr
    [20] path => boot
    [21] path => mnt
    [22] path => sbin
  ... .. .... ... ... 

   $ >> ./unix-readdir.bin /boot 
   List directory contents 
    [0] path => /boot/..
    [1] path => /boot/.
    [2] path => /boot/initramfs-5.6.12-300.fc32.x86_64.img
    [3] path => /boot/grub2
    [4] path => /boot/vmlinuz-0-rescue-a1ac43b933e24659bba5edf2b9cec1e1
    [5] path => /boot/memtest86+-5.01
    [6] path => /boot/initramfs-5.6.6-300.fc32.x86_64.img
     ... ... ...     ... ... ...     ... ... ...     ... ... ...     
#+END_SRC


** Memory Mapped Files - mmap 
*** Overview 

File mapping is an operating system mechanism which maps a disk file
to a process virtual memory. This operating system feature allows
accessing the file as it was in the process memory. 

Benefits: 

  + Transparent access to file, allows accessing the file as it was an
    ordinary memory. (the file is accessible by pointer)

  + Good for processing large files which does not fit in the machine
    RAM memory.

Use-cases: 
  
  + Read large files

  + IPC - Inter-Process Communication 

  + Process complicated binary files

  + Modify complex binary files. The file can be modified by just
    changing a memory, in other words, modifying the contents of a
    memory address. 

  + Implement JIT - Just-In-Time compiler and execute assembly code at runtime.

The _mmap API_ is available in most Unix-like operating systems: 

  + Linux
  + BSD-family: MacOSX, FreeBDS, NetBSD, OpenBSD
  + Solaris 
  + QNX, AIX

  *Mmap API functions*

File descriptors: 

#+BEGIN_SRC cpp 
    #include <unistd.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>

    // Returns file descriptor of a disk-file 
    int open(const char *pathname, int flags);

    // Close file descriptor (release resource)
    int close(int fd);
#+END_SRC

Mmap: 

  + Doc: $ man mmap
  + Linux Manpage Description: "mmap() creates a new mapping in the
    virtual address space of the calling process.  The starting
    address for the new mapping is specified in addr.  The length
    argument speci‐ fies the length of the mapping (which must be
    greater than 0)"

  + Argument: _prot_ (Memory Protection)
    + PROT_READ  => Pages may be written (most used)
    + PROT_WRITE => Pages may be written (allows changing the file by writing to the mapped memory)
    + PROT_NONE  => Pages may not be accessed
    + PROT_EXEC  => Pages may be executed => Allows executing machine
      code (assembly) at runtime. Use case: JIT - Just-In-Time
      compiler

  + Argument: _flags_
    + MAP_SHARED  => Multiple processes can share the same _file_
                  _mapping_. This flag is used for IPC - Inter Process
                  Communication. 
    + MAP_PRIVATE => Only the current process can access the file mapping.

#+BEGIN_SRC cpp 
   #include <sys/mman.h>

   void* mmap(  void*   addr    // (often nullptr) Address that the file will be mapped 
              , size_t  length  // Length of file mapping (often the file size)
              , int     prot    // Flags for memory protection 
              , int     flags   // Flags for process access conttrol (private | shared)
              , int     fd      // File descriptor to be mapped into virtual memory
              , off_t   offset  // (often zero) Offset from the beginning of the file 
             );
#+END_SRC

munmap:

  + Doc: $ man munmap
  + Linux Manpage doc: "The munmap() system call deletes the mappings
    for the specified address range, and causes further references to
    addresses within the range to generate invalid memory ref‐
    erences.  The region is also automatically unmapped when the
    process is terminated.  On the other hand, closing the file
    descriptor does not unmap the region."

  + Param _addr_: Address of memory mapping (value returned by mmap)

  + Param _length:_ length of file mapping, often it is the file size.

#+BEGIN_SRC cpp 
    // For mmap and munmap 
    #include <sys/mman.h>     

    int munmap( void *addr, size_t length);
#+END_SRC

Hyperlinks to manpage documentation of related-functions: 

  + [[https://linux.die.net/man/2/mmap][mmap]] (Linux manpage)

  + [[https://linux.die.net/man/2/remap_file_pages][remap_file_pages]]

  + [[https://linux.die.net/man/2/mremap][mremap]] (Linux manpage)

  + [[https://linux.die.net/man/2/msync][msync]]


 *References and further reading* 

General: 

   + [[https://en.wikipedia.org/wiki/Mmap][mmap - Wikipedia]]

   + [[https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemAdvancedPT/MappingFilesIntoMemory/MappingFilesIntoMemory.html][Apple - Mapping Files Into Memory]]

   + [[https://upsilon.cc/~zack/teaching/1415/progsyst/cours-05-mmap.pdf][Programmation SystèmeCours 5 — Memory Mapping]] ([[http://web.archive.org/web/20200622232258/https://upsilon.cc/~zack/teaching/1415/progsyst/cours-05-mmap.pdf][Web Archive]])

   + [[https://unix.stackexchange.com/questions/474926/how-does-memory-mapping-a-file-have-significant-performance-increases-over-the-s/475014][How does memory mapping a file have significant performance increases over the standard I/O system calls?]]

   + [[https://courses.engr.illinois.edu/cs241/sp2014/lecture/27-IPC.pdf][Interprocess Communication: Memory mapped files and pipes]]

   + [[http://web.cs.ucla.edu/honors/UPLOADS/kousha/thesis.pdf][Linux Memory Mapped System Call Performance]]

   + [[https://w3.cs.jmu.edu/kirkpams/OpenCSF/Books/csf/html/MMap.html][Shared Memory with Memory-Mapped Files]]

   + [[https://www.sublimetext.com/blog/articles/use-mmap-with-care][Use mmap With Care - Sublime HQ]]

   + [[http://www.idryman.org/blog/2017/06/28/opic-a-memory-allocator-for-fast-serialization/][Writing a Memory Allocator for Fast Serialization]]

   + [[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2044.html][Paper: Memory Mapped Files And Shared Memory For C++]]

   + [[https://indico.cern.ch/event/658060/contributions/2898569/attachments/1622526/2582399/pivarski-serialization.pdf][Overview of Serialization Technologies]] - CERN

   + [[https://www.usenix.org/sites/default/files/conference/protected-files/hotstorage17_slides_choi.pdf][Efficient Memory Mapped File I/O for In-Memory File Systems]]

   + [[https://engineering.mongodb.com/post/getting-storage-engines-ready-for-fast-storage-devices][Getting storage engines ready for fast storage devices]]

   + [[http://blogs.networkingfutures.co.uk/post/2015/12/28/Windows-Services-Implementing-Non-Persisted-Memory-Mapped-Files-Exposing-IPC-Style-Communications.aspx][Introduction to Memory Mapped Files]] (.NET Specific)


MMAP - File Memory Mapping for other programming languages

   + https://docs.rs/flatdata/0.5.0/flatdata/ (Rust library for mmap)

   + [[https://www.red-gate.com/simple-talk/dotnet/net-development/sharing-caring-using-memory-mapped-files-net/][Sharing is Caring: Using Memory Mapped Files in .NET]]

   + [[https://coders-corner.net/2013/03/22/inter-process-communication-with-memory-mapped-files-part-01-transfer-a-data-structure-and-an-object/][Inter-Process Communication with Memory-Mapped Files, Part 01]]

   + [[https://github.com/jampp/sharedbuffers/][Python SharedBuffer - library for mmap]]

   + https://docs.julialang.org/en/v1/stdlib/Mmap/ - Julia Language library for mmap (memory-mapped files)

   + [[https://engineering.indeedblog.com/blog/2015/02/memory-mapping-with-util-mmap/][Memory Mapping with util-mmap]] - mmap for Java.
*** Example (C) - mmap for reading Windows PE32 files 

This code uses mmap API (memory mapped files) for reading metadata
from PE (Portable Executable) - Windows native executable files or
windows object-code. 

GIST: 
  + https://gist.github.com/166265f6dc85c8d9cc2dc00253caae78

File: unix-mmap.c 

#+BEGIN_SRC cpp 
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h> 
    #include <assert.h>

    // --- Unix/Posix headers ---------//
    #include <unistd.h>
    #include <sys/mman.h>
    #include <sys/stat.h>
    #include <fcntl.h>

    #define IMAGE_SIZEOF_SHORT_NAME            8
    #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES  16

    typedef int32_t  LONG;
    typedef uint16_t WORD;
    typedef uint32_t DWORD;
    typedef uint8_t  BYTE;
    typedef uint64_t ULONGLONG;;

    // Source: <winttt.h>  => Original: typedef struct _IMAGE_DOS_HEADER
    typedef struct {            
        WORD   e_magic;                     
        WORD   e_cblp;                   
        WORD   e_cp;                     
        WORD   e_crlc;                   
        WORD   e_cparhdr;                
        WORD   e_minalloc;               
        WORD   e_maxalloc;               
        WORD   e_ss;                     
        WORD   e_sp;                     
        WORD   e_csum;                   
        WORD   e_ip;                     
        WORD   e_cs;                     
        WORD   e_lfarlc;                 
        WORD   e_ovno;                   
        WORD   e_res[4];                 
        WORD   e_oemid;                  
        WORD   e_oeminfo;                
        WORD   e_res2[10];               
        //  Offset to the PE header from the beginning of the file. 
        LONG   e_lfanew;                    
      } IMAGE_DOS_HEADER;

     typedef struct {
        DWORD Signature; 
        WORD  Machine;
        WORD  NumberOfSections;
        DWORD TimeDateStamp;
        DWORD PointerToSymbolTable;
        DWORD NumberOfSymbols;
        WORD  SizeOfOptionalHeader;
        WORD  Characteristics;
     } PE_HEADER;


    ssize_t get_file_size(int fd)
    {
        struct stat file_stat; 
        if( fstat(fd, &file_stat) == -1 )
            return -1;
        return file_stat.st_size;
    }

    int main(int argc, char** argv)
    {   
        // ----------- Validate arguments ----------------------------//
        if(argc < 2)
        {
            fprintf(stderr, "Usage: /unix-mmap <FILE> \n");
            return EXIT_FAILURE;
        }

        // ----------- Get file descriptor ----------------------------//

        // Get read-only file descriptor of file 
        int fd = open(argv[1], O_RDONLY);
        if(fd == -1){
            fprintf(stderr, " Error: unable to open file. check ERRNO variable \n");
            return EXIT_FAILURE;
        }

        ssize_t size = get_file_size(fd);
        if(size == -1){
            fprintf(stderr, " Error: unable to get file size \n");
            return EXIT_FAILURE;
        }

        // ----------- Map file in to process' virtual memory ---------------------------//

        void* fmap = mmap(    NULL        /* Often set to zero, aka nullpointer           */
                            , size        /* Size of file mapping in bytes                */
                            , PROT_READ   /* Open in read-only mode                       */
                            , MAP_PRIVATE /* Only this process can access this memory-map */
                            , fd          /* File descriptor of file to be memory mapped  */
                            , 0x00        /* Offset from the beggining of the file        */
                         );

        if( fmap == MAP_FAILED)
        {
            fprintf(stderr, " Error: memory mapped failed. check ERRNO \n");
            return EXIT_FAILURE;
        }

        // --------- Process file -----------------------------------------// 

        unsigned char* bmap = (unsigned char*) fmap; 

        // char file_signature [2] = { bmap[0], bmap[1], bmap[2], bmap[3], 0x00 };
        printf(" File signature = %c %c 0x%X 0x%X \n", bmap[0], bmap[1], bmap[2], bmap[3]);

        IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*) fmap;
        PE_HEADER*        pe_header  = fmap + dos_header->e_lfanew;

        assert( pe_header->Signature == 0x4550 );

        printf("\n ========= [DOS HEADER] =================\n");
        printf("   MAGIC NUMBER = 0x%X (hex) \n", dos_header->e_magic);
        printf("   MAGIC NUMBER = %c %c  (str) \n", dos_header->e_magic & 0xFF, (dos_header->e_magic >> 8) & 0xFF);
        printf("       e_lfanew = 0x%X \n",      dos_header->e_lfanew);

        printf("\n ======== [PE - Header] ================\n");
        printf(" Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 \n");
        printf("\n");
        printf("          Signature = 0x%X \n", pe_header->Signature);
        printf("            Machine = 0x%X \n", pe_header->Machine);
        printf(" Number of sections = %d \n",   pe_header->NumberOfSections);

        // ---------- Release Resource ------------------------------------// 

        // Unmap memory segment 
        munmap(fmap, size);
        // Release file-descriptor resource
        close(fd);

        return 0;
    } // --- End of main() ----// 


#+END_SRC

Build: 

#+BEGIN_SRC sh 
  $ gcc unix-mmap.c -o unix-mmap-c.bin -Wall -Wextra -g
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   $ ./unix-mmap-c.bin notepad.exe 
    File signature = M Z 0x90 0x0 

    ========= [DOS HEADER] =================
      MAGIC NUMBER = 0x5A4D (hex) 
      MAGIC NUMBER = M Z  (str) 
          e_lfanew = 0xF8 

    ======== [PE - Header] ================
    Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 

             Signature = 0x4550 
               Machine = 0x8664 
    Number of sections = 7 
  
#+END_SRC
*** Example (C++) - mmap for reading Windows PE32 files 

GIST: 
  + https://gist.github.com/166265f6dc85c8d9cc2dc00253caae78

File: unix-mmap.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 
   #include <fstream> 
   #include <cstdint> 
   #include <cassert>

   // --- Unix/Posix headers ---------//
   #include <unistd.h>
   #include <sys/mman.h>
   #include <sys/stat.h>
   #include <fcntl.h>

   constexpr size_t IMAGE_SIZEOF_SHORT_NAME = 8;
   constexpr size_t IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;

   // using LONG      = long;
   using LONG      = std::int32_t;
   using WORD      = std::uint16_t;  // unsigned short;
   using DWORD     = std::uint32_t;  // unsigned long; 
   using BYTE      = std::uint8_t;   //unsigned char;
   using ULONGLONG = std::uint64_t;  // unsigned long long 

   // Source: <winttt.h>  => Original: typedef struct _IMAGE_DOS_HEADER
   struct IMAGE_DOS_HEADER {            
       WORD   e_magic;                     
       WORD   e_cblp;                   
       WORD   e_cp;                     
       WORD   e_crlc;                   
       WORD   e_cparhdr;                
       WORD   e_minalloc;               
       WORD   e_maxalloc;               
       WORD   e_ss;                     
       WORD   e_sp;                     
       WORD   e_csum;                   
       WORD   e_ip;                     
       WORD   e_cs;                     
       WORD   e_lfarlc;                 
       WORD   e_ovno;                   
       WORD   e_res[4];                 
       WORD   e_oemid;                  
       WORD   e_oeminfo;                
       WORD   e_res2[10];               
       //  Offset to the PE header from the beginning of the file. 
       LONG   e_lfanew;                    
     };

    struct PE_HEADER
    {
       DWORD Signature; 
       WORD  Machine;
       WORD  NumberOfSections;
       DWORD TimeDateStamp;
       DWORD PointerToSymbolTable;
       DWORD NumberOfSymbols;
       WORD  SizeOfOptionalHeader;
       WORD  Characteristics;
    };


   ssize_t get_file_size(int fd)
   {
       struct stat file_stat; 
       if( fstat(fd, &file_stat) == -1 )
           throw std::runtime_error("Error: unable to get file size");
       return file_stat.st_size;
   }

   int main(int argc, char** argv)
   {   
       // ----------- Validate arguments ----------------------------//
       if(argc < 2)
       {
           std::fprintf(stderr, "Usage: /unix-mmap <FILE> \n");
           return EXIT_FAILURE;
       }

       // ----------- Get file descriptor ----------------------------//

       // Get read-only file descriptor of file 
       int fd = open(argv[1], O_RDONLY);
       if(fd == -1){
           std::fprintf(stderr, " Error: unable to open file. check ERRNO variable \n");
           return EXIT_FAILURE;
       }

       ssize_t size = get_file_size(fd);

       // ----------- Map file in to process' virtual memory ---------------------------//

       void* fmap = mmap(    nullptr     /* Often set to zero, aka nullpointer           */
                           , size        /* Size of file mapping in bytes                */
                           , PROT_READ   /* Open in read-only mode                       */
                           , MAP_PRIVATE /* Only this process can access this memory-map */
                           , fd          /* File descriptor of file to be memory mapped  */
                           , 0x00        /* Offset from the beggining of the file        */
                        );

       if( fmap == MAP_FAILED)
       {
           std::fprintf(stderr, " Error: memory mapped failed. check ERRNO \n");
           return EXIT_FAILURE;
       }

       // --------- Process file -----------------------------------------// 

       const auto bmap = reinterpret_cast<unsigned char*>(fmap); 

       // char file_signature [2] = { bmap[0], bmap[1], bmap[2], bmap[3], 0x00 };
       std::printf(" File signature = %c %c 0x%X 0x%X \n", bmap[0], bmap[1], bmap[2], bmap[3]);

       IMAGE_DOS_HEADER* dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(fmap);
       PE_HEADER*        pe_header  = reinterpret_cast<PE_HEADER*>( (uintptr_t) fmap + dos_header->e_lfanew);

       assert( pe_header->Signature == 0x4550 );

       std::printf("\n ========= [DOS HEADER] =================\n");
       std::printf("   MAGIC NUMBER = 0x%X (hex) \n", dos_header->e_magic);
       std::printf("   MAGIC NUMBER = %c %c  (str) \n", dos_header->e_magic & 0xFF, (dos_header->e_magic >> 8) & 0xFF);
       std::printf("       e_lfanew = 0x%X \n",      dos_header->e_lfanew);

       std::printf("\n ======== [PE - Header] ================\n");
       std::printf(" Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 \n");
       std::printf("\n");
       std::printf("          Signature = 0x%X \n", pe_header->Signature);
       std::printf("            Machine = 0x%X \n", pe_header->Machine);
       std::printf(" Number of sections = %d \n",   pe_header->NumberOfSections);


       // ---------- Release Resource ------------------------------------// 

       // Unmap memory segment 
       munmap(fmap, size);
       // Release file-descriptor resource
       close(fd);

       return 0;
   } // --- End of main() ----// 


#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ clang++ unix-mmap.cpp -o unix-mmap.bin -std=c++1z -Wall -Wextra -g
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   $ ./unix-mmap.bin ipconfig.exe 
    File signature = M Z 0x90 0x0 

    ========= [DOS HEADER] =================
      MAGIC NUMBER = 0x5A4D (hex) 
      MAGIC NUMBER = M Z  (str) 
          e_lfanew = 0xE8 

    ======== [PE - Header] ================
    Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 

             Signature = 0x4550 
               Machine = 0x8664 
    Number of sections = 6 


   $ ./unix-mmap.bin notepad.exe 
    File signature = M Z 0x90 0x0 

    ========= [DOS HEADER] =================
      MAGIC NUMBER = 0x5A4D (hex) 
      MAGIC NUMBER = M Z  (str) 
          e_lfanew = 0xF8 

    ======== [PE - Header] ================
    Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 

             Signature = 0x4550 
               Machine = 0x8664 
    Number of sections = 7 
#+END_SRC
*** Example (C++) - mmap for reading Windows PE32 with class 

This code uses a class FileMapping for encapsulating Unix
memory-mapped files which simplifies the usage of the mmap feature and
makes the code cleaner and safer. 

GIST: 
  + https://gist.github.com/166265f6dc85c8d9cc2dc00253caae78

File: unix-mmap-class.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 
   #include <fstream> 
   #include <cstdint> 
   #include <cassert>

   // --- Unix/Posix headers ---------//
   #include <unistd.h>
   #include <sys/mman.h>
   #include <sys/stat.h>
   #include <fcntl.h>

   constexpr size_t IMAGE_SIZEOF_SHORT_NAME = 8;
   constexpr size_t IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;

   // using LONG      = long;
   using LONG      = std::int32_t;
   using WORD      = std::uint16_t;  // unsigned short;
   using DWORD     = std::uint32_t;  // unsigned long; 
   using BYTE      = std::uint8_t;   //unsigned char;
   using ULONGLONG = std::uint64_t;  // unsigned long long 

   // Source: <winttt.h>  => Original: typedef struct _IMAGE_DOS_HEADER
   struct IMAGE_DOS_HEADER {            
       WORD   e_magic;                     
       WORD   e_cblp;                   
       WORD   e_cp;                     
       WORD   e_crlc;                   
       WORD   e_cparhdr;                
       WORD   e_minalloc;               
       WORD   e_maxalloc;               
       WORD   e_ss;                     
       WORD   e_sp;                     
       WORD   e_csum;                   
       WORD   e_ip;                     
       WORD   e_cs;                     
       WORD   e_lfarlc;                 
       WORD   e_ovno;                   
       WORD   e_res[4];                 
       WORD   e_oemid;                  
       WORD   e_oeminfo;                
       WORD   e_res2[10];               
       //  Offset to the PE header from the beginning of the file. 
       LONG   e_lfanew;                    
     };

    struct PE_HEADER
    {
       DWORD Signature; 
       WORD  Machine;
       WORD  NumberOfSections;
       DWORD TimeDateStamp;
       DWORD PointerToSymbolTable;
       DWORD NumberOfSymbols;
       WORD  SizeOfOptionalHeader;
       WORD  Characteristics;
    };

   /** Class for encapsulating memory mapped files*/
   class FileMapping
   {
       int   m_fd      = -1; 
       void* m_addr    = nullptr; 
       ssize_t m_size  = -1;

       ssize_t get_file_size(int fd)
       {
           struct stat file_stat; 
           if( fstat(fd, &file_stat) == -1 )
               throw std::runtime_error("Error: unable to get file size");
           return file_stat.st_size;
       }

   public: 
       // Disable copy constructor 
       FileMapping(FileMapping const&) = delete;
       // Disable copy assignment operator 
       FileMapping& operator=(FileMapping const&) = delete;    

       /** 
        * @param file_path - File to be memory-mapped to current process. 
        */
       FileMapping(std::string file_path)
       {
           // Get read-only file descriptor of file 
           m_fd = open(file_path.c_str(), O_RDONLY);        
           if(m_fd == -1){
               throw std::runtime_error("Unable to open file");
           }      

           m_size = get_file_size(m_fd);
           if(m_size == -1)
               throw std::runtime_error("Unable to get file size");


           m_addr = ::mmap( nullptr     
                           , m_size       
                           , PROT_READ   
                           , MAP_PRIVATE 
                           , m_fd        
                           , 0x00        
                       );
           if( m_addr == MAP_FAILED)
           {
               throw std::runtime_error("Error: failed to map file to memory");
           }

       }

       ~FileMapping()
       {
           // Unmap memory segment 
           munmap(m_addr, m_size);
           // Release file-descriptor resource
           close(m_fd);

           m_fd = -1;
           m_addr = nullptr;
           m_size = -1;
       }

       /** @brief Returns pointer file mapping address. */
       void* addr() const { return m_addr; }  

       /** @brief  Get casted pointer to an offset of the file mapping address. */
       template<typename T>
       T addr_rel(std::ptrdiff_t offset) const { 
           return reinterpret_cast<T>( reinterpret_cast<uintptr_t>(m_addr) + offset);  
       }

   }; // --- End of class FileMapping ---- //


   int main(int argc, char** argv)
   {   
       // ----------- Validate arguments ----------------------------//
       if(argc < 2)
       {
           std::fprintf(stderr, "Usage: /unix-mmap <FILE> \n");
           return EXIT_FAILURE;
       }

       FileMapping fmap(argv[1]);

       // --------- Process file -----------------------------------------// 

       const auto bmap = fmap.addr_rel<unsigned char*>(0x00);

       // char file_signature [2] = { bmap[0], bmap[1], bmap[2], bmap[3], 0x00 };
       std::printf(" File signature = %c %c 0x%X 0x%X \n", bmap[0], bmap[1], bmap[2], bmap[3]);

       IMAGE_DOS_HEADER* dos_header = fmap.addr_rel<IMAGE_DOS_HEADER*>(0x00);
       PE_HEADER*        pe_header  = fmap.addr_rel<PE_HEADER*>( dos_header->e_lfanew);

       assert( pe_header->Signature == 0x4550 );

       std::printf("\n ========= [DOS HEADER] =================\n");
       std::printf("   MAGIC NUMBER = 0x%X (hex) \n", dos_header->e_magic);
       std::printf("   MAGIC NUMBER = %c %c  (str) \n", dos_header->e_magic & 0xFF, (dos_header->e_magic >> 8) & 0xFF);
       std::printf("       e_lfanew = 0x%X \n",      dos_header->e_lfanew);

       std::printf("\n ======== [PE - Header] ================\n");
       std::printf(" Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 \n");
       std::printf("\n");
       std::printf("          Signature = 0x%X \n", pe_header->Signature);
       std::printf("            Machine = 0x%X \n", pe_header->Machine);
       std::printf(" Number of sections = %d \n",   pe_header->NumberOfSections);

       return 0;
   } // --- End of main() ----// 


#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ unix-mmap-class.cpp -o unix-mmap-class.bin -std=c++1z -g -Wall -Wextra
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   $ ./unix-mmap-class.bin notepad.exe 
    File signature = M Z 0x90 0x0 

    ========= [DOS HEADER] =================
      MAGIC NUMBER = 0x5A4D (hex) 
      MAGIC NUMBER = M Z  (str) 
          e_lfanew = 0xF8 

    ======== [PE - Header] ================
    Note: if machine is 0x8664 => the processor is AMD-Intel x86-64 

             Signature = 0x4550 
               Machine = 0x8664 
    Number of sections = 7 
#+END_SRC
