#+INCLUDE: theme/style.org 
#+TITLE: Linux and Unix system programming 
#+DESCRIPTION: Linux, unix and posix system programming 
#+STARTUP: content 


* Linux and Unix system programming 
** Low level IO functions 

C-Library functions which encapsulates file-related systems calls.

Headers: 

#+BEGIN_SRC cpp 
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    #include <unistd.h>
#+END_SRC

  *Special File Descriptors* 

  + STDOUT_FILENO => File descritor for stdout (process standard output)
  + STDERR_FILENO => File descritor for stderr (process standard error output)
  + STDIN_FILENO => File descritor for stdin (process standard input)

  *Functions* 

  + close() => Close a file descriptor.
    + Doc: $ man 2 close 

#+BEGIN_SRC cpp 
  int close(int fd);
#+END_SRC

 + open() => Encapsulates open system call => Returns a file descritor
   number. When fails, it returns (-1) setting the global variable
   _errno_.
   + Doc: $ man 2 open 

#+BEGIN_SRC cpp 
   int open(const char *pathname, int flags);
#+END_SRC

  + creat() => Create file
    + Doc: $ man 2 creat 

#+BEGIN_SRC cpp 
   int creat(const char *pathname, mode_t mode)
#+END_SRC


  + read() => Read bytes from a file descriptor into a buffer, returning the
    number of bytes read. If there is an error, the functions returns
    (-1) setting the global variable _errno_.
    + Doc: $ man 2 read 

#+BEGIN_SRC cpp 
  ssize_t read(int fd, void *buf, size_t count);
#+END_SRC

  + write() => Write N bytes from a buffer to a file descriptor.
    + Doc: $ man 2 write 

#+BEGIN_SRC cpp 
  ssize_t write(int fd, const void *buf, size_t count);
#+END_SRC



** Low level IO - open(), read(), write() syscall functions

This code demonstrates the usage of the open(), read(), write(),
close() low-level IO library-calls for file descriptors which
encapsulates system-calls with the same name. 

GIST: 
 + https://gist.github.com/05fbba6475cca1dbdd50bbb2bd5ac8ae

File: unix-low-level-io.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>

   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>

   #include <cstring> // Import: char* strerror(in errnum);

   const char* 
   errno_to_cstring(int err)
   {
       // No such file or directory 
       if(err == ENOENT) return "ENOENT";
       // Operation not permitted 
       if(err == EPERM)  return "EPERM";
       // Onput/Output error 
       if(err == EIO)    return "EIO";

       if(err == EAGAIN) return "EAGAIN";
       if(err == EPERM)  return "EPERM";
       if(err == EPIPE)  return "EPIPE";

       return "<UNKNOWN>";
   }	


   /** Check whether file descriptor is regular file */
   bool fd_is_regular_file(int fd)
   {		
        struct stat fd_info; 
        // int fstat(int fd, struct stat *statbuf);
        int r = fstat(fd, &fd_info);
        return S_ISREG(fd_info.st_mode);
   }

   bool fd_is_directory(int fd)
   {
       struct stat fd_info; 
       // int fstat(int fd, struct stat *statbuf);
       int r = fstat(fd, &fd_info);
       return S_ISDIR(fd_info.st_mode);	
   }

   void print_errno_details(int err)
   {
       std::fprintf(stderr , "\n   =>    errno(int) = %d" 
                             "\n   =>    errno(str) = %s"
                             "\n   => errno message = %s \n"
                             , err, errno_to_cstring(err), strerror(err));
        std::fflush(stderr);
   }

   int main(int argc, char** argv)
   {
       std::puts(" [INFO] Program started. ");

       if(argc < 3){
               std::fprintf(stderr, " Usage:                             \n");
               std::fprintf(stderr, "  => To read a file:                \n");
               std::fprintf(stderr, "    $ %s file <FILE>                \n", argv[0]);
               std::fprintf(stderr, "  => To read stdin (console input): \n");
               std::fprintf(stderr, "    $ %s file -stdin                \n", argv[0]);
               return 0;
       }

       // Compare two c-strings return 0 (zero) when they are equal.
       // int strcmp(const char *s1, const char *s2)
       if( strcmp(argv[1], "file") != 0 )
       {
               std::fprintf(stderr, " [ERROR] Expected command file. \n");
               return EXIT_FAILURE;
       }

       // Variable for holding a file descriptor 
       int fd; 

       // The library-call open() attempts to open a file  and returns a "file-descriptor" 
       // (integer number ) when the operation is successful. The library-call 
       // returns (-1) when the operation fails. 
       // Note: It encapsulates the 'open' system call. 
       // 	
       if( strcmp(argv[2], "-stdin") == 0)
               fd = STDIN_FILENO; 
       else 
               fd = open(argv[2], O_RDONLY);

       if(fd == -1){
               // Get error flag 'errno' to get more details about current error.
               int err = errno;
               std::fprintf(stderr ," [ERROR] Failed to open file. ");
               print_errno_details(err);
               return EXIT_FAILURE;
       }

       std::fprintf(stdout, " [INFO] ?? File is regular file = %s \n"
                                 , fd_is_regular_file(fd) ? "TRUE" : "FALSE"  );
       std::fprintf(stdout, " [INFO] ?? File is directory file = %s \n"
                                 , fd_is_directory(fd) ? "TRUE" : "FALSE"  );				  
       // Flush file => Force changes to be immeditely written.
       std::fflush(stdout);

       // Buffer maximum size in bytes 
       constexpr size_t BUFFER_MAX_SIZE = 200; 	
       char buffer[BUFFER_MAX_SIZE];

       // Stream BUFFER_MAX_SIZE bytes from file descriptor 
       // to STDOUT_FILENO (file descriptor).
       //---------------------------------------------------
       ssize_t ret; 
       do {
               ret = read(fd, buffer, BUFFER_MAX_SIZE);		
               if(ret == -1) {
                       int err = errno; 
                       std::fprintf(stderr, " [ERROR] An error has happened => ");
                       print_errno_details(err);
                       close(fd);
                       return EXIT_FAILURE;
               }		
               ::write(STDOUT_FILENO, buffer, ret);
       } while( ret != 0);

       // Always close the file descriptor.
       close(fd);

       return 0;
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ unix-low-level-io.cpp -o unix-low-level-io.bin -std=c++1z -Wall -Wextra
#+END_SRC

Running:

  + Run 1

#+BEGIN_SRC sh 
 $ >> ./unix-low-level-io.bin 
 [INFO] Program started. 
 Usage:                             
  => To read a file:                
    $ ./unix-low-level-io.bin file <FILE>                
  => To read stdin (console input): 
    $ ./unix-low-level-io.bin file -stdin                
#+END_SRC

 + Run 2: 

#+BEGIN_SRC sh 
   $ >> ./unix-low-level-io.bin file /proc/filesystems 
   [INFO] Program started. 
   [INFO] ?? File is regular file = TRUE 
   [INFO] ?? File is directory file = FALSE 
  nodev	sysfs
  nodev	tmpfs
  nodev	bdev
  nodev	proc
  nodev	cgroup
  nodev	cgroup2
  ... ... ... 

  $ >> ./unix-low-level-io.bin file /etc/resolv.conf 
   [INFO] Program started. 
   [INFO] ?? File is regular file = TRUE 
   [INFO] ?? File is directory file = FALSE 
  # Generated by NetworkManager
  nameserver 194.165.12.10
#+END_SRC

 + Run 3: (Error)

#+BEGIN_SRC sh 
 $ >> ./unix-low-level-io.bin file /etc/resosad
 [INFO] Program started. 
 [ERROR] Failed to open file. 
   =>    errno(int) = 2
   =>    errno(str) = ENOENT
   => errno message = No such file or directory 

 $ >> ./unix-low-level-io.bin file /etc/shadow
 [INFO] Program started. 
 [ERROR] Failed to open file. 
   =>    errno(int) = 13
   =>    errno(str) = <UNKNOWN>
   => errno message = Permission denied 

 $ >> ./unix-low-level-io.bin file /
 [INFO] Program started. 
 [INFO] ?? File is regular file = FALSE 
 [INFO] ?? File is directory file = TRUE 
 [ERROR] An error has happened => 
   =>    errno(int) = 21
   =>    errno(str) = <UNKNOWN>
   => errno message = Is a directory 
#+END_SRC

 + Run 4 - read stdin file descriptor _STDIN_FILENO_

#+BEGIN_SRC 
   $ >> ./unix-low-level-io.bin file -stdin
   [INFO] Program started. 
   [INFO] ?? File is regular file = FALSE 
   [INFO] ?? File is directory file = FALSE 


  Hello world
  Hello world
   Unix-linux file descriptors - Low level IO
   Unix-linux file descriptors - Low level IO

  # User types Ctrl+D to close STDIN 
#+END_SRC

** Low level IO - creat() 

Creates a file using Unix-low level IO function creat() which
encapsulates the creat() system-call.

File: unix-creat.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 

   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   #include <cstring>

   void print_errno_details(int err);

   int main(int argc, char** argv)
   {
       // File is created with read, write permissions for owner 
       // ,groups and others
       mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;

       int fd = creat("/tmp/my-sample-file.txt", mode);
       if(fd  == -1){
           print_errno_details(errno);
           return EXIT_FAILURE;
       }

       constexpr size_t BUFFER_SIZE = 500;
       char buffer[BUFFER_SIZE];

       // Fill the whole buffer with '\0' null char characters
       memset(buffer, '\0', BUFFER_SIZE);

       // strcpy => Copy string literal to buffer. 
       strcpy(buffer, " [LINE 0] Write this message to buffer\n");
       fprintf(stdout, " Buffer size (non blank chars) = %zu \n", strlen(buffer));
       // Write strlen(buffer) bytes to file descriptor 
       write(fd, buffer, strlen(buffer));

       strcpy(buffer, " [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX\n");
       fprintf(stdout, " Buffer size (non blank chars) = %zu \n", strlen(buffer));
       fprintf(stdout, " Buffer content = '%s' \n", buffer);
       // Write strlen(buffer) bytes to file descriptor 
       write(fd, buffer, strlen(buffer));

       strcpy(buffer, " [LINE 2] FreeRTOS Linux RTAI Real-time RTMES QNX\n");
       write(fd, buffer, strlen(buffer));

       close(fd);
       return EXIT_SUCCESS;
   }

   // Ruires: #include <string>
   void print_errno_details(int err)
   {
           std::fprintf(stderr , "\n   =>    errno(int) = %d" 
                                 "\n   => errno message = %s \n"
                               , err, strerror(err));
           std::fflush(stderr);
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ unix-creat.cpp -o unix-creat.bin -std=c++1z -Wall -Wextra -g 
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ >> ./unix-creat.bin 
  Buffer size (non blank chars) = 39 
  Buffer size (non blank chars) = 44 
  Buffer content = ' [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX
 '
#+END_SRC

Content of generated file: 

#+BEGIN_SRC sh 
  $ >> cat /tmp/my-sample-file.txt 
  [LINE 0] Write this message to buffer
  [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX
  [LINE 2] FreeRTOS Linux RTAI Real-time RTMES QNX
#+END_SRC

Trace library-calls with _ltrace_ application: 
 
  +  $ ltrace ./unix-creat.bin

#+BEGIN_SRC sh 
  $ >> ltrace ./unix-creat.bin

  _ZNSt8ios_base4InitC1Ev(0x4040a9, 0xffff, 0x7ffcfe326598, 224) = 0
  __cxa_atexit(0x4010e0, 0x4040a9, 0x402008, 6)                  = 0
  creat(0x402010, 420, 0x7ffcfe326598, 256)                      = 3
  memset(0x7ffcfe326280, '\0', 500)                              = 0x7ffcfe326280
  strlen(" [LINE 0] Write this message to "...)                  = 39
  fprintf(0x7f95f2612500, " Buffer size (non blank chars) ="..., 39 Buffer size (non blank chars) = 39 
  ) = 37
  strlen(" [LINE 0] Write this message to "...)                  = 39
  write(3, " [LINE 0] Write this message to "..., 39)            = 39
  strlen(" [LINE 1] Unix, BSD, OSX, LINUX,"...)                  = 44
  fprintf(0x7f95f2612500, " Buffer size (non blank chars) ="..., 44 Buffer size (non blank chars) = 44 
  ) = 37
  fprintf(0x7f95f2612500, " Buffer content = '%s' \n", " [LINE 1] Unix, BSD, OSX, LINUX,"... Buffer content = ' [LINE 1] Unix, BSD, OSX, LINUX, AIX, POSIX
  ' 
  ) = 66
  strlen(" [LINE 1] Unix, BSD, OSX, LINUX,"...)                  = 44
  write(3, " [LINE 1] Unix, BSD, OSX, LINUX,"..., 44)            = 44
  strlen(" [LINE 2] FreeRTOS Linux RTAI Re"...)                  = 50
  write(3, " [LINE 2] FreeRTOS Linux RTAI Re"..., 50)            = 50
  close(3)                                                       = 0
  _ZNSt8ios_base4InitD1Ev(0x4040a9, 0, 0x4010e0, 1)              = 0x7f95f2965e40
  +++ exited (status 0) +++

#+END_SRC

Trace system-calls with _strace_ application: 

  +  $ strace ./unix-creat.bin

#+BEGIN_SRC sh 
  $ strace ./unix-creat.bin 

  execve("./unix-creat.bin", ["./unix-creat.bin"], 0x7fff489b8e40 /* 83 vars */) = 0
  brk(NULL)                               = 0x57c000
  arch_prctl(0x3001 /* ARCH_??? */, 0x7fff751bd910) = -1 EINVAL (Invalid argument)
  access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
   ... ... ... ... ... ... ... ... ... ... ... ... ... ...
   ... ... ... ... ... ... ... ... ... ... ... ... ... ...

  mprotect(0x7fed4e032000, 4096, PROT_READ) = 0
  munmap(0x7fed4dfe4000, 136250)          = 0
  brk(NULL)                               = 0x57c000
  brk(0x59d000)                           = 0x59d000
  creat("/tmp/my-sample-file.txt", 0644)  = 3
  fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0xc), ...}) = 0
  write(1, " Buffer size (non blank chars) ="..., 37) = 37
  write(3, " [LINE 0] Write this message to "..., 39) = 39
  write(1, " Buffer size (non blank chars) ="..., 37) = 37
  write(1, " Buffer content = ' [LINE 1] Uni"..., 63) = 63
  write(1, "' \n", 3)                     = 3
  write(3, " [LINE 1] Unix, BSD, OSX, LINUX,"..., 44) = 44
  write(3, " [LINE 2] FreeRTOS Linux RTAI Re"..., 50) = 50
  close(3)                                = 0
  exit_group(0)                           = ?
  +++ exited with 0 +++
#+END_SRC
** Information about current process 

File: current-process.cpp 

#+BEGIN_SRC cpp 
   #include <iostream> 
   #include <string> 
   #include <cstring> 

   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   #include <limits.h> // PATH_MAX constant (macro)

   auto get_cwd() -> std::string;
   auto set_cwd(const std::string& path) -> void;
   auto read_symlink(std::string const& path) -> std::string;

   int main(int argc, char** argv)
   {
       // Unique process ID (identifier) number 
       fprintf(stdout, "   => Process PID = %d \n", ::getpid());

       // PID for parent process
       fprintf(stdout, "   => Process PID = %d \n", ::getppid());

       // Current directory 
       fprintf(stdout, "   => Current directory = %s \n", get_cwd().c_str());

       fprintf(stdout, "\n Change the curren directory to /etc \n");
       set_cwd("/etc");
       fprintf(stdout, "   => Current directory = %s \n", get_cwd().c_str());

       // Note: It only works on Linux. The directory /proc/self is a pseudo-directory 
       //       whith pseudo-files containing information about the current process. 
       // 
       // the file /proc/self/exe is a symbolic link to the current executable.
       std::string exe_file = read_symlink("/proc/self/exe");
       fprintf(stdout, "  => Absolute Path of current executable = %s \n", exe_file.c_str());

       // Current directory 
       std::string exe_dir = read_symlink("/proc/self/cwd");
       fprintf(stdout, "  => Current directory of this executable = %s \n", exe_dir.c_str());

       fprintf(stdout, " [INFO] Finish Ok. \n");
       return 0;
   }

   // ----------- Functions Implementations ------------// 
   // 

   /** Get current working directory of current process */
   auto get_cwd() -> std::string 
   {
       char* buffer = ::getcwd(nullptr, 0);
       auto cwd = std::string(buffer);
       // Note buffer was allocated with malloc 
       free(buffer);
       return cwd;
   }

   /** Set current working directory for current process. */
   auto set_cwd(const std::string& path) -> void 
   {
        int status = ::chdir(path.c_str());
        if(status < 0)
            throw std::runtime_error("Failed to change directory.");
   }

   /** Read value of symbolic link 
    *  
    * Requires: <limits.h>, <sys/types.h>, <sys/stats.h>
    */
   auto read_symlink(std::string const& path) -> std::string 
   {
       // Create a buffer with size PATH_MAX + 1 filled with 0 ('\0'), null characters
       std::string buffer(PATH_MAX, 0);
       // ssize_t readlink(const char *pathname, char *buf, size_t bufsiz);
       ssize_t nread = ::readlink(path.c_str(), &buffer[0], PATH_MAX);
       if(nread == -1){
           fprintf(stderr, " Error: %s \n", strerror(errno));
           throw std::runtime_error("Error: unable to read symlink. Check 'errno' variable");
       }
       buffer.resize(nread);
       return buffer;
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
   $ >> g++ current-process.cpp -o current-process.elf -Wall -Wextra -ggdb
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ >> ./current-process.elf 
    => Process PID = 719155 
    => Process PID = 678179 
    => Current directory = /home/mxpkf8/temp-projects/unix-explore 

  Change the curren directory to /etc 
    => Current directory = /etc 
   => Absolute Path of current executable = /home/mxpkf8/temp-projects/unix-explore/current-process.elf 
   => Current directory of this executable = /etc 
  [INFO] Finish Ok.
#+END_SRC

** Dynamic Loading Shared Libraries 
*** Overview 

 The dlopen API provide access to the _dynamic linker_ services allowing
the current process to load and unload shared objects or shared
libraries in its address space (virtual memory).

This API for loading shared libraries is not only available on Linux,
it also can be found in FreeBSD, NetBSD, MacOSX, Android and so on.

Use cases: 

  + Load new code at-runtime

  + Load third-party code a runtime

  + Plugin systems, extensions or addons.

  + Load native code extensions in languages with interpreters written
    in C, such as Python, Ruby, Lua and so on. Note: Python native
    extensions are shared libraries. 

Documentation: 

  + http://gnu.wiki/man3/dlopen.3.php

  + [[https://man7.org/linux/man-pages/man3/dlopen.3.html][Dlopen API - Linux Manpages]]

  + [[https://www.freebsd.org/cgi/man.cgi?query=dlopen&apropos=0&sektion=0&manpath=SuSE+Linux%252Fi386+7.3&format=html][Free BSD - dlopen API documentation]]

  + [[https://docs.oracle.com/cd/E19048-01/chorus5/806-7014/6jftsjfdq/index.html][Dlopen - Oracle Documentation]]

  + [[http://www.qnx.com/developers/docs/6.5.0SP1.update/com.qnx.doc.neutrino_lib_ref/d/dlopen.html][Dlopen - QNX documentation]]

  + [[https://dwheeler.com/program-library/Program-Library-HOWTO/x172.html][Dynamically Loaded (DL) Libraries]]


Further Reading: 

  + [[https://cseweb.ucsd.edu/~gbournou/CSE131/the_inside_story_on_shared_libraries_and_dynamic_loading.pdf][Inside the history on shared libraries and dynamic loading]]

  + [[https://hackaday.com/2018/07/12/its-all-in-the-libs-building-a-plugin-system-using-dynamic-loading/][It 's all in the libs - Building a Plugin system using Dynamic Loading]]

  + [[http://docencia.ac.upc.edu/FIB/USO/Bibliografia/unix-c-libraries.html][Building And Using Static And Shared "C" Libraries]]

  + [[https://www.informit.com/articles/article.aspx?p=22435][More Shared Libraries-Dynamic Loading and Unloading]]

  + https://grugq.github.io/docs/subversiveld.pdf

  + [[https://github.com/mgood7123/universal-dynamic-loader][universal-dynamic-loader]] for Linux - "min-dl: minimal dynamic linker implementation"


Headers and libraries: 

  + Header:  #include <dlfcn.h>
  + Linking: (-ldl) flag 

 _Function dlopen()_:

  + Doc: $ man dlopen 
  + Loads a shared library and returns a _handle_ or _opaque pointer_
    casted as void pointer. The term _opaque_ means that the
    implementation is hidden and the pointer is only meant to be
    passed around to other functions.
  + Note: When this function fails, it returns null pointer.

#+BEGIN_SRC cpp 
      void* dlopen(const char* filename, int flags);
#+END_SRC

 _Function dlsym()_:

  + Doc: $ man dlsym
  + Obtains address of a shared library symbol from _handle_ (from
    dlopen). 
  + Params:
    + handle => Shared library handle obtained from _dlopen_
    + symbol  => Name of symbol to be loaded.
  + Return:
    + Address of symbol casted as void*. It can be a function-pointer
      or a pointer to global variable. If the symbol is not found, the
      function returns a null pointer. 

#+BEGIN_SRC cpp 
    void* dlsym(void* handle, const char* symbol);
#+END_SRC

 _Function dlvsym()_:

  + Doc: $ man dlvsym
    + Loads a specific version of a symbol. 

#+BEGIN_SRC cpp 
    void* dlvsym(void *handle, char *symbol, char *version);
#+END_SRC

 _Function dlclose()_: 

  + Doc: $ man dlclose()

#+BEGIN_SRC cpp 
  int dlclose(void *handle);
#+END_SRC

 _Function dlerror()_ 
   + Obtaines error messages from dlopen API.
   + Doc: $ man dlerror()

#+BEGIN_SRC cpp 
  char* dlerror(void);
#+END_SRC

 *Simplified type signatures with a C++-friendly notation*

#+BEGIN_SRC cpp 
   // Opaque pointer for shared library (shared object) handle 
   using HND = void* ; 
   // Opaque pointer for shared library symbol 
   using SYM = void* ; 

   HND  dlopen( const char* filename, int flags);
   SYM   dlsym( HND handle, const char* symbol);
   SYM  dlvsym( HND handle, char *symbol, char *version);
   int dlclose( HND handle );
#+END_SRC

 *Usage example* 

#+BEGIN_SRC cpp 
   #include <dlfcn.h>

   // Opaque pointer for shared library (shared object) handle 
   using HND = void* ; 
   // Opaque pointer for shared library symbol 
   using SYM = void* ; 

   void load_library()
   {
       // Load shared library 
       HND hnd = dlopen("/path/to/shared-library.so", RTLD_LAZY | RTLD_GLOBAL); 
       if(hnd == nullptr)
       {
          std::cerr << "  [ERROR] " << dlerror() << "\n";
          throw std::runtime_error("Error: unable to load shared library"); 
       }

       // Load symbol 
       SYM hsym = dlsym(hnd, "name_of_function"); 

       // if(!hsym)
       if(hsym == nullptr)
       {
          throw std::runtime_error("Error: symbol not found"); 
       }

       // Function signature type alias 
       //  => The function to be loaded can only have C-linkage. 
       using name_of_function_t = void (*) (int param0, double param1, const char* param3);
       
       //  Function pointer. 
       auto name_of_function_ptr = reinterpret_cast<name_of_function_t>(hsym); 
    
       // Call loaded function 
       name_of_function_ptr(100, 2.51, "string");

       // Unload shared library 
       dlclose(hsym);
   }
#+END_SRC


 
*** GK3 GUI with dynamic linking 

The following sample code is a GTk3 or GTK2 GUI graphical user
interface application with GTK functions loaded from a GTK shared
library, without any compile-time linking. The advantage of this
approach is the greater portability across different versions of GTk
and the ability to switch between GT3 and GT2.

GIST: 
  + https://gist.github.com/d81dd9c422dc93ad4104b5e79259afdf

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.9)
   project(gtk-sample)

   #========== Global Configurations =============#
   #----------------------------------------------#

   set(CMAKE_CXX_STANDARD 17)     
   set(CMAKE_VERBOSE_MAKEFILE ON)

          add_executable( gtk-dlopen gtk-dlopen.cpp)
   target_link_libraries( gtk-dlopen dl )   
#+END_SRC

File: gtk-dlopen.cpp 

#+BEGIN_SRC cpp 
    #include <iostream>
    #include <cstring> 
    #include <cassert> 

    // Uses: dlopen(), dlclose(), ... 
    #include <dlfcn.h>

    // ---- Copied from GTK headers ------// 
    typedef char            gchar;
    typedef short           gshort;
    typedef long            glong;
    typedef int             gint;
    typedef gint            gboolean;
    typedef unsigned char   guchar;
    typedef unsigned short  gushort;
    typedef unsigned long   gulong;
    typedef unsigned int    guint;
    typedef float           gfloat;
    typedef double          gdouble;
    typedef void*           gpointer;
    typedef const void*     gconstpointer;

    enum class GtkWindowType
    {
        GTK_WINDOW_TOPLEVEL,
        GTK_WINDOW_POPUP
    };

    enum class GConnectFlags
    {
      G_CONNECT_AFTER	= 1 << 0,
      G_CONNECT_SWAPPED	= 1 << 1
    };

    template<typename TFun>
    TFun load_symbol(void* hnd, std::string symbol)
    {
        void* hSym = dlsym(hnd, symbol.c_str());
        if(hSym == nullptr)
        {
            std::string msg = std::string(" [Error] symbol not found: ") + symbol;
            throw std::runtime_error(msg);
        }    
        return reinterpret_cast<TFun>(hSym);
    }

    // Opaque type (aka incomplete type)
    struct GClosure;

    // -------- Function Pointers type aliases -------------------//
    using GCallback      = void  (*) (void);
    using GClosureNotify = void  (*) (gpointer data, GClosure* closure);
    using g_signal_connect_data_t =  gulong	(*) (   gpointer instance
                                                      , const gchar*    detailed_signal
                                                      , GCallback       c_handler
                                                      , gpointer        data
                                                      , GClosureNotify  destroy_data
                                                      , GConnectFlags	connect_flags
                                                  );

    int main(int argc, char** argv)
    {    
        std::string shared_lib =  [&]() -> std::string 
        {
            if(argc < 2) return "/lib64/libgtk-3.so.0";
            return argv[1];
        }();

        std::cout << " [INFO] Loading shared library: " << shared_lib << "\n";

        //  void *dlopen(const char *filename, int flags);

        // Handle to shared library 
        void* hnd = dlopen(shared_lib.c_str(), RTLD_NOW | RTLD_GLOBAL);
        if(hnd == nullptr){ fprintf(stderr, "%s\n", dlerror());  }
        assert( hnd != nullptr );

        void* hSym = nullptr; 

        // --------- Load gtk_init_check function pointer ------- // 
        hSym = dlsym(hnd, "gtk_init_check");
        assert(hSym != nullptr);
        using gtk_init_check_t = gboolean (*) (int* argc, char*** argv);
        auto gtk_init_check = reinterpret_cast<gtk_init_check_t>(hSym);   

        // ------- Load remaining function pointers (symbols) --------// 
        //-----------------------------------------------------------//

        // opaque pointer 
        struct GtkWidget;

        using gkt_window_new_t = GtkWidget* (*) (int);
        auto gtk_window_new  = load_symbol<gkt_window_new_t>(hnd, "gtk_window_new");    
        auto gtk_widget_show = load_symbol<void (*) (GtkWidget*)>(hnd, "gtk_widget_show");
        auto gtk_main        = load_symbol<void (*) ()>(hnd, "gtk_main");

        using gtk_window_set_title_t = void (*) (GtkWidget* window, const gchar* title);
        auto gtk_window_set_title = load_symbol<gtk_window_set_title_t>(hnd, "gtk_window_set_title");

        using gtk_widget_set_size_t = void (*) (GtkWidget*, gint, gint);
        auto gtk_widget_set_size = load_symbol<gtk_widget_set_size_t>(hnd, "gtk_widget_set_size_request");

        auto gtk_main_quit = load_symbol<void (*) ()>(hnd, "gtk_main_quit");

        auto gtk_signal_connect_data 
              = load_symbol<g_signal_connect_data_t>(hnd, "g_signal_connect_data");

        /** ------- Build Window GUI - Graphical User Interface ----------**/

        // Call function pointer 
        gtk_init_check(&argc, &argv);

        GtkWidget* window = gtk_window_new( (int) GtkWindowType::GTK_WINDOW_TOPLEVEL);
        gtk_widget_set_size(window, 400, 500);
        gtk_window_set_title(window, "My GTK Window");
        gtk_widget_show(window);    

        gtk_signal_connect_data(  window         // Widget 
                                , "destroy"      // Event name 
                                , gtk_main_quit  // Callback                             
                                , nullptr        // Pointer to data (closure )
                                , nullptr 
                                , (GConnectFlags) 0 // GConnect flags 
                                );

        std::cout << " [INFO] Window running. OK! " << "\n";
        gtk_main();

        // Always close shared library handler.
        dlclose(hnd);

        std::cout << " [INFO] Shutdown gracefully. Ok. \n" ;
        return EXIT_SUCCESS;
    }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/d81dd9c422dc93ad4104b5e79259afdf && cd gist 
  $ g++ gtk-dlopen.cpp -o gtk-dlopen.bin -std=c++1z -ldl -ggdb -Wall -Wextra   
#+END_SRC

Checking the dependencies of gtk-dlopen.bin 

#+BEGIN_SRC sh 
   $ >> ldd gtk-dlopen.bin 
          linux-vdso.so.1 (0x00007ffd23fc4000)
          libdl.so.2 => /lib64/libdl.so.2 (0x00007f6a78428000)
          libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007f6a78238000)
          libm.so.6 => /lib64/libm.so.6 (0x00007f6a780f2000)
          libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007f6a780d7000)
          libc.so.6 => /lib64/libc.so.6 (0x00007f6a77f0d000)
          /lib64/ld-linux-x86-64.so.2 (0x00007f6a78453000)
#+END_SRC

Running: (load GTK shared library /lib64/libgtk-3.so.0)

#+BEGIN_SRC sh 
 $ >> ./gtk-dlopen.bin 
 [INFO] Loading shared library: /lib64/libgtk-3.so.0
 [INFO] Window running. OK! 
 [INFO] Shutdown gracefully. Ok. 
#+END_SRC

Running: (load GK2 shared library )

#+BEGIN_SRC sh 
   $ >> ./gtk-dlopen.bin /usr/lib64/libgtk-x11-2.0.so 
   [INFO] Loading shared library: /usr/lib64/libgtk-x11-2.0.so
   [INFO] Window running. OK! 
   [INFO] Shutdown gracefully. Ok. 
#+END_SRC

Verify exported symbols by gtk3 shared library: 

#+BEGIN_SRC sh 
    $ >> nm -D /lib64/libgtk-3.so.0 | grep init
           ... ... ... ... ..
           ... ... ... ... ..
           U g_async_initable_new_async
           U g_async_initable_new_finish
           U g_datalist_init
           U g_hash_table_iter_init
           U g_initable_get_type
           U g_initable_new
           U g_initially_unowned_get_type
           U g_mutex_init
           U g_once_init_enter
          ... ... ... ... ..
          ... ... ... ... ..
#+END_SRC


** Launching processes with exec and fork system wrappers 

This code demonstrates the usage of exec and fork system-calls wrapper
functions, namely, execvp() and fork() functions. 

 *Relevant functions signature* 

Fork
  + Linux Manpage: "fork() creates a new process by duplicating the
    calling process.  The new process is referred to as the child
    process.  The calling process is referred to as the parent
    process."
  + Note: The function 'fork' is not the system call fork, but a
    C wrapper around this sytem call provided by the C runtime
    library. (GLIBC - GNU C library in the machine where this was tested.)

#+BEGIN_SRC cpp 
  pid_t fork(void);
#+END_SRC

Execvp (wraps exec system call)
  + The exec system calls is always called when a new process is
    launched/created. It replaces the process image of the current
    process with a new one from the launched executable.
  + Note: In addition to native executables, on Unix-like operating
    systems, an executable can also be any scripting file starting
    with shebang as first line such as "#!/usr/bin/env sh"

#+BEGIN_SRC cpp 
   int execvp(const char *file, char *const argv[]);
#+END_SRC

Waitpid => Waits for a state of change of a process.
  + It can be used for waiting for process termination. 
 
#+BEGIN_SRC cpp 
   pid_t waitpid(pid_t pid, int *wstatus, int options);
#+END_SRC

 *Documentation* 

  + [[https://man7.org/linux/man-pages/man2/fork.2.html][fork() Linux Manpage]]

  + [[https://www.freebsd.org/cgi/man.cgi?query=execvp][Execvp() => FreeBSD Manpage]]

 *Further Reading*

  + [[https://en.wikipedia.org/wiki/Fork_(system_call)][Fork (system call) - Wikipedia]]

  + [[http://people.cs.pitt.edu/~aus/cs449/ts-lecture14.pdf][Fork() System Calland ProcessesCS449 Spring 2016]]

  + [[https://www.cs.columbia.edu/~junfeng/11sp-w4118/lectures/unix.pdf][Chapter 0 - Operating system interfaces {PDF}]]

 *Sample Code* 

GIST: 
 + https://gist.github.com/133e91ba3732718cb228310173368674

File: unix-process.cpp 

#+BEGIN_SRC cpp 
   // ------ File: unix-process.cpp -----------------------------------------------------------//
   // Description: Shows hows to launch processes on Unix with Exec and Fork syscall wrappers.
   //-------------------------------------------------------------------------------------------//

   #include <iostream>
   #include <vector>

   // ----- Unix/Linux headers -----// 
   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <fcntl.h>
   #include <sys/wait.h>

   #include <cstring> // Import: char* strerror(in errnum);

   // -------------- Declarations --------------------------//

   void print_errno_details(int err);
   void execvp_test();
   void execvp_cpp(std::string app, std::vector<std::string> args);

   // Launch a new process without terminate this process. 
   // It combines fork + exec system-calls. 
   void fork_exec(std::string app, std::vector<std::string> args);

   // -------------  MAIN() ------------------------------//

   int main(int argc, char** argv)
   {
        std::puts(" [INFO] Program started. ");

        if(argc < 2){
           std::printf(" Usage:  ./unix-process <OPTION>");
           return EXIT_SUCCESS;
        }

        std::string opt = argv[1];

        if(opt == "0")
        {
           execvp_test();
        }
        // Test execvp 
        if(opt == "1")
        {
            execvp_cpp("thunar", { "/etc" } );
            return EXIT_SUCCESS;
        }
        // Fork-exec 
        if(opt == "2")
        {
            fork_exec("konsole", { "-e", "tmux", "a"} );
        }	

        std::puts(" [TRACE] Finish execution. ");
        return 0;
   }

   // ------------- Definitions ------------------------//

   void print_errno_details(int err)
   {
           std::fprintf(stderr ,"\n   =>    errno(int) = %d" 
                                "\n   => errno message = %s \n"
                               , err, strerror(err));
           std::fflush(stderr);
   }


   // Test exec system-call wrapper function (execvp)
   void execvp_test()
   {    
           const char* app    = "thunar";

           const char* args[] = {  app     // Process name, can be anything 
                                  , "/etc"  // Arguments passed to the process 
                                  , nullptr // Always terminate the argument array with null pointer 
                                 };

           // Encapsulates execv system call. 
           // int execvp(const char *file, char *const argv[]);
           if( execvp(app, (char *const *) args) == -1)
           {
                 std::fprintf(stderr, " Error: unable to launch process");
                 print_errno_details(errno);
                 throw std::runtime_error("Error: failed to launch process");
           }

   }

   // C++ wrapper for the exevp() library-call 
   // It replaces the current process image with a new one 
   // from other executable. 
   void execvp_cpp(  std::string app
                   , std::vector<std::string> args)
   {
        std::vector<const char*> pargs;
        pargs.reserve(args.size() + 1);
        pargs.push_back(app.c_str());
        for(auto const& a: args){ pargs.push_back(a.c_str()); }
        pargs.push_back(nullptr);

        // Signature: int execvp(const char *file, char *const argv[]);

        // execvp(app.c_str(), execvp(app.c_str(), (char* const *) pargs.data() )
        int status = execvp(app.c_str(), (char* const*) pargs.data() );
        if( status == -1)
        {
             std::fprintf(stderr, " Error: unable to launch process");
             print_errno_details(errno);
             throw std::runtime_error("Error: failed to launch process");
        }
   }

   void fork_exec(std::string app, std::vector<std::string> args)
   {
        std::printf(" [TRACE] <BEFORE FORK> PID of parent process = %d \n", getpid());

        // PID of child process (copy of this process)
        pid_t pid = fork();

        if(pid == -1)
        {
            std::fprintf(stderr, "Error: unable to launch process");
            print_errno_details(errno);
            throw std::runtime_error("Error: unable to launch process");
        }
        if(pid == 0){
             std::printf(" [TRACE] Running on child process => PID_CHILD = %d \n", getpid());	

             // Close file descriptors, in order to disconnect the process from the terminal.
             // This procedure allows the process to be launched as a daemon (aka service).
             close(STDOUT_FILENO);
             close(STDERR_FILENO);
             close(STDIN_FILENO );

             // Execvp system call, replace the image of this process with a new one
             // from an executable. 
             execvp_cpp(app, args);		
             return;
        }

        std::printf(" [TRACE] <AFTER FORK> PID of parent process = %d \n", getpid());

        // pid_t waitpid(pid_t pid, int *wstatus, int options);
        int status;

        std::printf(" [TRACE] Waiting for child process to finish. ");

        // Wait for child process termination.
        // From header: #include <sys/wait.h>
        if(waitpid(pid, &status, 0) == -1)
        {
            print_errno_details(errno);
            throw std::runtime_error("Error: cannot wait for child process");
        }

        std::printf(" [TRACE] Child process has been terminated Ok.");
       // -------- Parent process ----------------//
   }
#+END_SRC

Building: 

#+BEGIN_SRC sh 
   $ >> g++ unix-process.cpp -o unix-process.bin -std=c++1z -Wall -Wextra -g
#+END_SRC

Running: 

#+BEGIN_SRC sh 
   ~/t/unix-explore
   $ >> ./unix-process.bin 0
   [INFO] Program started. 

   ~/t/unix-explore
   $ >> ./unix-process.bin 1
   [INFO] Program started. 

   ~/t/unix-explore
   $ >> ./unix-process.bin 2
   [INFO] Program started. 
   [TRACE] <BEFORE FORK> PID of parent process = 774929 
   [TRACE] <AFTER FORK> PID of parent process = 774929 
   [TRACE] Running on child process => PID_CHILD = 774930 
   [TRACE] Waiting for child process to finish.  [TRACE] Child process has been terminated Ok. [TRACE] Finish execution. 
#+END_SRC
** Read/List directory contents 

Functions used: 

#+BEGIN_SRC cpp 
   DIR *opendir(const char *name);

   int readdir(   unsigned int fd
                , struct old_linux_dirent* dirp,
                , unsigned int count);
#+END_SRC

File: unix-readdir.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>

   // #include <string>
   #include <sys/types.h>
   #include <dirent.h>  // Get function opendir
   #include <errno.h>

   #include <sys/types.h>
   #include <sys/stat.h>
   #include <unistd.h>


   template<typename Callback>
   void iterate_directory(const std::string& path, Callback&& callback)
   {
       DIR *dir;
       struct dirent *dp;

       dir = opendir(path.c_str()) ;

       // To determine the cause of error - It is necessary to check the error code.
       if (dir == nullptr) throw std::runtime_error("Error: Cannot read directory");

       while ((dp = readdir(dir)) != nullptr) 
       {
          if(path == "/")
               callback(dp->d_name);
          else 
               callback(path + "/" + dp->d_name);		
       };
       closedir(dir);
   }

   int main(int argc, char** argv)
   {
        std::cout << " List directory contents " << std::endl;

        if(argc < 2)
        {
            std::cout << "Usage: ./unix-readdir <DIRECTORY>" << "\n";
            return EXIT_SUCCESS;
        }

        int idx = 0;
        iterate_directory(argv[1], [&idx](auto const& path)
        {
            std::cout << "  [" << idx++  << "] path => " << path << "\n";
        });
        return EXIT_SUCCESS;
   }

#+END_SRC

Building: 

#+BEGIN_SRC sh 
  $ g++ unix-readdir.cpp -o unix-readdir.bin -std=c++1z -g -Wall -Wextra 
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ >> ./unix-readdir.bin /
   List directory contents 
    [0] path => srv
    [1] path => sys
    [2] path => ..
    [3] path => opt
    [4] path => .
    [5] path => run
    [6] path => media
    ... ... ... 
    [18] path => lib
    [19] path => usr
    [20] path => boot
    [21] path => mnt
    [22] path => sbin
  ... .. .... ... ... 

   $ >> ./unix-readdir.bin /boot 
   List directory contents 
    [0] path => /boot/..
    [1] path => /boot/.
    [2] path => /boot/initramfs-5.6.12-300.fc32.x86_64.img
    [3] path => /boot/grub2
    [4] path => /boot/vmlinuz-0-rescue-a1ac43b933e24659bba5edf2b9cec1e1
    [5] path => /boot/memtest86+-5.01
    [6] path => /boot/initramfs-5.6.6-300.fc32.x86_64.img
     ... ... ...     ... ... ...     ... ... ...     ... ... ...     
#+END_SRC

** Creating Portable Binaries for Linux / GLIBC hell 

 *The Problem* 

One of the greatest challenges of Linux desktop is building and
deploying portable applications and native executable which work on
any Linux distribution. Even if an application totally statically
linked against all dependencies or it is bundled with all its shared
libraries dependencies via LD_LIBRARY_PATH environment variable or
RPATH, the program may still fail to run in other Linux distribution
due to the GLIBC (GNU C library runtime) dependency. A GLIBC is _forward_
_compatible_, but not _backward compatible_, the GLIBC runtime failure is
more likely to happen if the application was built on a Linux
distribution using a newer version of GLIBC, but the program is
deployed in a distribution using an older version of GLIBC.

  + Side Note: Applications built with GO (Golang) programming
    language are less likely to be affected by the GLIBC-issue as
    often, the compiler does not link against the GLIBC.

GIST Containing all files used in this experiment: 

  + https://gist.github.com/0557cd0fa1d5370723b015e443a7c036

 *GLIBC - Problem Illustration with a Sample Project* 

File: Makefile

#+BEGIN_SRC make 
  build:
          cmake --config Debug -H. -B_build2
          cmake --build _build2 --target 
#+END_SRC

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(Simple_Cmake_Project)

  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #========== Targets Configurations ============#
          add_executable( filesys filesys.cpp )
  target_link_libraries( filesys stdc++fs)
#+END_SRC

File: filesys.cpp 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <iterator>
  #include <iomanip>
  #include <filesystem>

  namespace fs = std::filesystem;

  template<typename Range, typename Function>
  auto dotimes(size_t n, Range&& iterable, Function fun)
  {
      size_t i = 0;
      auto it = fs::begin(iterable);
      auto end = fs::end(iterable);
      while(i < n && it != end ){
              fun(it);
              ++it;
              i++;
      }
  }

  int main(){

       std::cout << std::boolalpha;
       std::cout << "\n ===== Listing directory /etc =====" << std::endl;
       // Show first 10 files of directory /etc 
       dotimes(10, fs::directory_iterator("/etc"),
               [](auto p){
                    auto path = p->path();
                    std::cout << std::left
                              << std::setw(0) << path.filename().string()
                              << " " << std::setw(35)
                              << std::right << std::setw(40) << path
                              << std::endl;				
               });		
       return EXIT_SUCCESS;
  }
#+END_SRC

 *Steps for reproducing the problem* 

STEP 1: Get current machine infomation. 

  + GLIBC Version is: 2.34-2.fc32

#+BEGIN_SRC sh 
  # Current machine 
  $ cat /etc/fedora-release 
  Fedora release 32 (Thirty Two)

  # Current GLIBC Version 
  $ ld --version
  GNU ld version 2.34-2.fc32
  ... ... ... ... 
#+END_SRC

STEP 2: Build the application. 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/0557cd0fa1d5370723b015e443a7c036 gist && cd gist 
  $ cmake --config Debug -H. -B_build1
  $ cmake --build _build1 --target 

  $ file _build1/filesys 
  _build1/filesys: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, 
  interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d1a3628f794c66bcfb29303cfa4a528910f4e3e2
  , for GNU/Linux 3.2.0, not stripped
#+END_SRC

STEP 3: Run in the current machine (newer version of GLIBC)

#+BEGIN_SRC sh 
  $ _build1/filesys 

   ===== Listing directory /etc =====
  chrony.conf                       "/etc/chrony.conf"
  xl2tpd                            "/etc/xl2tpd"
  group                             "/etc/group"
  profile.d                         "/etc/profile.d"
  kde4rc                            "/etc/kde4rc"
  resolv.conf.8LUAL0                "/etc/resolv.conf.8LUAL0"
  geoclue                           "/etc/geoclue"
  bash_completion.d                 "/etc/bash_completion.d"
  cups                              "/etc/cups"
  mime.types                        "/etc/mime.types"
#+END_SRC

STEP 4: Attempt to run the binary in a distribution using an older
version of GLIBC. The distribution used was a QEMU-KVM virtual
machine running MX-Linux 19.2, distribution based on Debian, with
GLIBC version .

#+BEGIN_SRC sh 
  #---------- Failure ------------------------------------#
   $ _build1/filesys 
   _build1/filesys: /lib/x86_64-linux-gnu/libstdc++.so.6: version 
    `GLIBCXX_3.4.26' not found (required by _build1/filesys)

   #----------- Machine Info (MX Linux 19.2) -------------#
   # Kernel version 
   $ uname -r
   4.19.0-9-amd64

   # Distro name 
   $ cat /etc/issue 
   Welcome to MX 19.2 (patito feo) 64-bit! Powered by Debian.
   ... ... ... ... ............ .... ... ... .. 

   $ ld --version
   GNU ld (GNU Binutils for Debian) 2.31.1
   ... ... ... ... ... ... ... ... ... ... ... ... 
#+END_SRC

 *Solution* 

As GLIBC is _forward compatible_, but not _backward compatible_. The
solution for this issue is to build the application on a _system_ with
the oldest possible version of GLIBC. System in this context, means: a
Linux virtual machine; a Chroot environment; or Docker image with an
older version of GLIBC. Other alternative is to replace GLIBC with
_MUSL_ CRT (C Runtime library), but the drawback is that MUSL does not
support dynamic loading (_dlopen_, _dlsym_ APIs). 

The solution adopted for solving this issue was to use a Docker image
based on [[https://github.com/phusion/holy-build-box][holy-build-box]], which is a Docker image based on Centos 6
Linux distribution containing a modern version of GCC compiler, CMake
and an older version of GLIBC.

See: 
  + https://github.com/phusion/holy-build-box

 _File: Dockerfile_ (Available at [[https://gist.github.com/0557cd0fa1d5370723b015e443a7c036][gist url]])

#+BEGIN_SRC sh 
  # $ docker run -it --rm -v $PWD:/work -w /work phusion/holy-build-box-64:latest bash 
  FROM phusion/holy-build-box-64:latest

  ENTRYPOINT [ "/hbb_exe/activate-exec", "bash"  ]
#+END_SRC

Build docker image: 

#+BEGIN_SRC sh 
   # Run at the directory where is Dockerfile 
   $ docker build -f Dockerfile -t linux-build . 
#+END_SRC

Enter in the docker image shell: 

#+BEGIN_SRC sh 
   $ docker run --rm -it -v $PWD:/cwd -w /cwd linux-build 
   Holy build box activated
   Prefix: /hbb_exe
   CFLAGS/CXXFLAGS: -g -O2 -fvisibility=hidden -I/hbb_exe/include 
   LDFLAGS: -L/hbb_exe/lib -static-libstdc++
   STATICLIB_CFLAGS: -g -O2 -fvisibility=hidden -I/hbb_exe/include 
   SHLIB_CFLAGS: -g -O2 -fvisibility=hidden -I/hbb_exe/include 
   SHLIB_LDFLAGS: -L/hbb_exe/lib -static-libstdc++

   [root@88c9630a2008 cwd]# ls
   _build1  CMakeLists.txt   Dockerfile   filesys.cpp   Makefile
#+END_SRC

Build the application: 

#+BEGIN_SRC sh 
  [root@88c9630a2008 cwd]# make 
  cmake --config Debug -H. -B_build2
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /cwd/_build2
  cmake --build _build2 --target 
  gmake[1]: Entering directory '/cwd/_build2'
  /hbb/bin/cmake -S/cwd -B/cwd/_build2 --check-build-system CMakeFiles/Makefile.cmake 0
  ... ... ... ... ... ... ... ... ... 
  ... ... ... ... ... ... ... ... ... ... ... ... 

  [root@88c9630a2008 cwd]# ls _build2
  CMakeCache.txt  CMakeFiles  cmake_install.cmake  filesys  Makefile
#+END_SRC

Run the application _build2/filesys in MX-Linux: 

#+BEGIN_SRC sh 
   # Built on Fedora 32 with newer version of GLIBC [FAILURE]
   $ _build1/filesys
   _build1/filesys: /lib/x86_64-linux-gnu/libstdc++.so.6: 
   version 'GLIBCXX_3.4.26' not found (required by _build1/filesys)


   # Built on Centos6 docker with older version of GLIBC [OK, WORKS]
   #--------------------------------------
   $ _build2/filesys

    ===== Listing directory /etc =====
   .java                             "/etc/.java"
   .pwd.lock                         "/etc/.pwd.lock"
   ImageMagick-6                     "/etc/ImageMagick-6"
   NetworkManager                    "/etc/NetworkManager"
   UPower                            "/etc/UPower"
   X11                               "/etc/X11"
   acpi                              "/etc/acpi"
   adduser.conf                      "/etc/adduser.conf"
   adjtime                           "/etc/adjtime"
   alsa                              "/etc/alsa"
#+END_SRC

