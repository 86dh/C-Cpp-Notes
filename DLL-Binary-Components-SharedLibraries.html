<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-12-17 Mon 22:28 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shared Libraries - Binary Components</title>
<meta name="generator" content="Org mode" />
<meta name="description" content="cpp c++ code examples, demonstrations, design pattern and integration."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<link href="theme/org-nav-theme.css" rel="stylesheet">
<script src="theme/org-nav-theme.js"></script>
<link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Shared Libraries - Binary Components</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org31a0109">1. Shared Libraries - Binary Components</a>
<ul>
<li><a href="#orgdadac25">1.1. Overview</a></li>
<li><a href="#orgc2ac30f">1.2. Example 1 - Shared Library libtest.dll - DLLs on Windows</a>
<ul>
<li><a href="#org9f213c2">1.2.1. Overview</a></li>
<li><a href="#orgfaa5a8d">1.2.2. Header macros</a></li>
<li><a href="#orgf78e902">1.2.3. Namespace Linalg</a></li>
<li><a href="#org4632646">1.2.4. C-interface of Namespace Linalg</a></li>
<li><a href="#orgf6a272a">1.2.5. Non-polymorphic Class - SampleClass</a></li>
<li><a href="#org938f6ff">1.2.6. C-interface for SampleClass</a></li>
<li><a href="#org0ff8267">1.2.7. Polymorphic class InterfaceClass</a></li>
<li><a href="#org8a3ac8d">1.2.8. DLL startup function DLLMain</a></li>
<li><a href="#orgdaf4e84">1.2.9. DLL entry point for run32dll.exe</a></li>
<li><a href="#org5e46c02">1.2.10. C++ Client program - client1.cpp</a></li>
<li><a href="#org114d1a0">1.2.11. Load DLL in Python3 REPL</a></li>
<li><a href="#orgd542cbc">1.2.12. Python 3 Client Code - Wrapper Module</a></li>
<li><a href="#org6cd2749">1.2.13. View symbols exported by the DLL</a></li>
</ul>
</li>
<li><a href="#org9c2d63f">1.3. <span class="todo TODO">TODO</span> Shared Libraries on Linux</a></li>
</ul>
</li>
</ul>
</div>
</div>
<ul class="org-ul">
<li><a href='index.html'>Index</a></li>
</ul>

<div id="outline-container-org31a0109" class="outline-2">
<h2 id="org31a0109"><span class="section-number-2">1</span> Shared Libraries - Binary Components</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgdadac25" class="outline-3">
<h3 id="orgdadac25"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Shared libraries are compiled object-code exporting functions, data
structures and classes which can be used by many different
programs. They provide many benefits such as: faster compilation time;
less disk space usage since each program using the library do not
need a copy of the library source code or its compiled-code; ability
to update the library and provide security fixes to client
applications without recompilation, just by replacing the library
file. 
</p>

<p>
On Windows, shared libraries are called DLLs which stands for Dynamic
Linked Libraries, on Unix-like operating systems such as Linux, BSD
and MacOSX, they are called SO - shared objects or DSO - dynamic
shared objects. 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Comparison of shared libraries across different operating systems</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Operating</th>
<th scope="col" class="org-left">Long Name</th>
<th scope="col" class="org-left">Short name</th>
<th scope="col" class="org-left">File</th>
<th scope="col" class="org-left">Binary Format</th>
</tr>

<tr>
<th scope="col" class="org-left">System</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Extension</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Windows</td>
<td class="org-left">Dynamic Linked Library</td>
<td class="org-left">DLL</td>
<td class="org-left">.dll</td>
<td class="org-left">PE32/PE64 - Portable Executable</td>
</tr>

<tr>
<td class="org-left">Linux</td>
<td class="org-left">(Dynamic) Shared Object</td>
<td class="org-left">DSO or SO</td>
<td class="org-left">.so</td>
<td class="org-left">ELF or ELF64 (for 64 bits processors)</td>
</tr>

<tr>
<td class="org-left">BSD</td>
<td class="org-left">(Dynamic) Shared Object</td>
<td class="org-left">DSO or SO</td>
<td class="org-left">.so</td>
<td class="org-left">ELF or ELF64</td>
</tr>

<tr>
<td class="org-left">MacOSX</td>
<td class="org-left">-</td>
<td class="org-left">dylib</td>
<td class="org-left">.dylib or .so</td>
<td class="org-left">MachO</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Shared libraries are similar to executables, however they do not
have the main() function entry point.</li>
</ul>

<p>
In addition to C and C++, shared libraries, containing functions with
C-linkage, can also be used as binary components (libraries) and be
consumed from higher level programming languages such as Python, Ruby,
Java or C# through some foreign-function interface. In Python
C-functions can be imported from shared libraries using the <a href="https://docs.python.org/3/library/ctypes.html">cytpes</a>
library; in C# C-functions can be consumed using the P-invoke API and
in Java it is possible to use C-functions from shared libraries using
the JNI (Java Native Interface) or JNA, which is easier to use.
</p>


<p>
Note: 
</p>
<ul class="org-ul">
<li>Shared libraries are specific to a particular operating system and
are not part of C++ standard.</li>
</ul>

<p>
Use Cases and advantages: 
</p>

<ul class="org-ul">
<li>Multiple programs can reuse the same library reducing disk space.</li>

<li>Faster compilation once the shared library is compiled.</li>

<li>Changes in the library such as security fixes, updates and new
features may not require client programs recompilation if the ABI is
not broken.</li>

<li><span class="underline">Better for security updates</span>. For instance, if a program is
statically compiled with open-ssl library, a program
recompilation would be required to update the library to a new
version with security fixes for some vulnerability. It could even
be a greater security problem and waste of space, if all
application depending on open-ssl were statically liked with this
library. If a program uses the open-sll shared library, the library
can be updated just by replacing a file and the program it will not
need to be recompiled as long as there are no ABI breaking changes.</li>

<li><span class="underline">Plugin system</span> =&gt; The main program can contain an interface class
called IInterface and load its implementations from shared
libraries plugins. The implementation classes provided by the
plugins or shared library files allow the program to be updated and
extended at runtime without recompilation.</li>

<li><span class="underline">Cross language interoperability</span> =&gt; Functions using C-linkage can be
called from any high level programming language with foreign
function interface such as Python with ctypes library. C++
functions and classes cannot be called due to name mangling and
compiler ABI issues. The workaround to this problem is to create a
C-interface or functions with C-linkage for classes, functions and
namespaces. Instances of a class can be passed around as opaque
pointers (void*).</li>
</ul>

<p>
Problems: 
</p>

<ul class="org-ul">
<li>Due to C++ lack of standard <span class="underline">ABI Application Binary Interface</span>,
classes, STL containers, functions without C-linkage and namespaces
may not be reusable with a client program compiled with different
compiler than used to build the library. However, even in this
case, there is still the benefit of faster compilation time if the
shared library and the client application are part of the same
project.
<ul class="org-ul">
<li>TL;DR =&gt; Classes, STL and functions without C-linkage of shared
library cannot be used with a different compiler than the one
used to build the DLL.</li>
</ul></li>

<li>Cross-compiling interoperability - The only way to ensure that a
shared library can work with all compilers is by using a functions
with C-linkage (functions with extern "C") annotation and creating
C-linkage functions wrappers to classes, STL containers and
classes.</li>

<li>Classes can be made compatible among different compilers by using
an interface class, a class with only pure virtual member
functions, using only compatible types in the methods signature or
declaration, therefore it cannot use STL container types such as
std::string or std::vector. However, each implementation of an
interface class can use STL containers internally.</li>
</ul>


<p>
<b>MSDN Documentation</b>
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/cpp/build/exporting-cpp-functions-for-use-in-c-language-executables?view=vs-2017">Exporting C++ Functions for Use in C-Language Executables</a></li>

<li><a href="https://docs.microsoft.com/en-us/cpp/build/exporting-c-functions-for-use-in-c-or-cpp-language-executables?view=vs-2017">Exporting C Functions for Use in C or C++ Language Executables</a></li>
</ul>


<p>
<b>Further Reading</b>
</p>

<ul class="org-ul">
<li><a href="http://moppi.inside.org/demopaja/sdk_help/dll_functions.html">Creating the DLL functions</a></li>

<li><a href="https://www.codeproject.com/Articles/28969//Articles/28969/HowTo-Export-C-classes-from-a-DLL">HowTo: Export C++ classes from a DLL - CodeProject</a></li>

<li><a href="http://gernotklingler.com/blog/creating-using-shared-libraries-different-compilers-different-operating-systems/">Creating and using shared libraries with different compilers on different operating systems - Gernot.Klingler</a></li>

<li><a href="http://bigbang.waterlin.org/bang/using-python-ctypes-to-link-cpp-library/">The Big Bang on Reading Busy » Blog Archive » Using Python ctypes to link C/C++ library</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc2ac30f" class="outline-3">
<h3 id="orgc2ac30f"><span class="section-number-3">1.2</span> Example 1 - Shared Library libtest.dll - DLLs on Windows</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org9f213c2" class="outline-4">
<h4 id="org9f213c2"><span class="section-number-4">1.2.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
<b>Source:</b>
</p>

<p>
Shared library Source Code
</p>

<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/testlib.cpp">file:src/dlls/example-windows1/testlib.cpp</a></li>
<li>File: <a href="src/dlls/example-windows1/testlib.hpp">file:src/dlls/example-windows1/testlib.hpp</a></li>
</ul>

<p>
Sample Client C++ Program:
</p>

<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/client1.cpp">file:src/dlls/example-windows1/client1.cpp</a></li>
</ul>

<p>
Sample Python 3 Client code: (Python3 module wrapper library)
</p>

<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/testlib.py">file:src/dlls/example-windows1/testlib.py</a></li>
</ul>

<p>
GIST - Better for online view: 
</p>

<ul class="org-ul">
<li><a href="https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71">Gisthub</a></li>
</ul>

<p>
<b>Compile the DLL libtest.dll and client program with MSVC</b> 
</p>

<p>
Shared Library 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ cl.exe testlib.cpp /EHsc /LD /nologo user32.lib
</pre>
</div>

<p>
C++ Client program (client code)
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ cl.exe /EHsc client.cpp /Fe:out.exe testlib.lib &amp;&amp; out.exe
</pre>
</div>

<p>
<b>Compile the DLL libtest.dll and client program with Mingw/GCC</b> 
</p>

<p>
Shared Library 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ testlib.cpp -o <span class="org-keyword">testlib.dll</span> -g -shared -std=c++14 -Wall
</pre>
</div>

<p>
C++ Client program 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ client.cpp -o <span class="org-keyword">client.exe</span> -g -std=c++14 testlib.dll -Wall
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfaa5a8d" class="outline-4">
<h4 id="orgfaa5a8d"><span class="section-number-4">1.2.2</span> Header macros</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Sources:
</p>
<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/testlib.cpp">file:src/dlls/example-windows1/testlib.cpp</a></li>
<li>File: <a href="src/dlls/example-windows1/testlib.hpp">file:src/dlls/example-windows1/testlib.hpp</a></li>
</ul>

<p>
<b>teslib.hpp / Heade File - Macros</b>
</p>

<p>
The header files uses the following macros to reduce the boilerplate
necessary to export the library functions and classes. 
</p>

<ul class="org-ul">
<li>file: libstes.hpp =&gt; Macros for exporting functions and classes.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> _WIN32
  <span class="org-comment-delimiter">// </span><span class="org-comment">If not compiled for Windows, remove declspec directive.</span>
<span class="org-preprocessor">  #define</span> <span class="org-function-name">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">param</span><span class="org-rainbow-delimiters-depth-1">)</span>  
<span class="org-preprocessor">#endif</span> 

<span class="org-preprocessor">#define</span> <span class="org-variable-name">EXPORT_CPP</span>  <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-preprocessor">#ifdef</span> __cplusplus
  <span class="org-comment-delimiter">// </span><span class="org-comment">Indicat that a given symbol/function has C-linkage and</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">does not have name mangling. </span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">EXPORT_C</span> <span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">#else</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If a C-compiler uses this header, remove 'extern "C"'</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">EXPORT_C</span>  <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">#endif</span> 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf78e902" class="outline-4">
<h4 id="orgf78e902"><span class="section-number-4">1.2.3</span> Namespace Linalg</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
<b>Functions of Namespace Linalg</b> 
</p>

<p>
Namespace containing sample linear algebra functions, the function norm
computes an Euclidean norm of a N-dimension vector, the function
linTransform computes a linear transformation performing the
computation v[i] * a + b for each vector element. 
</p>

<p>
On Windows, all DLL symbols, such as functions, variables and clases,
are private by default, they are not exported by default as happens in
Unix-like OSes shared libraries. Therefore, in order to a function be
exported in a Windows shared library, it is necessary to use the MSVC or visual C++
compiler extension <code>__declspec(dllexport)</code> before the function declaration.
</p>

<ul class="org-ul">
<li>Interface =&gt; File: <b>testlib.hpp</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">The macro __cplusplus is used for allowing this </span>
<span class="org-comment"> * header to be used from 'C'. If a C compiler is used</span>
<span class="org-comment"> * all definitions inside this #ifdef are discarded.</span>
<span class="org-comment"> */</span>
<span class="org-preprocessor">#ifdef</span> __cplusplus
<span class="org-keyword">namespace</span> <span class="org-constant">Linalg</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        EXPORT_CPP <span class="org-type">double</span> <span class="org-function-name">norm</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        EXPORT_CPP <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">linTransform</span><span class="org-rainbow-delimiters-depth-2">(</span>
                <span class="org-type">double</span> <span class="org-variable-name">a</span>,
                <span class="org-type">double</span> <span class="org-variable-name">b</span>,
                <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span>
                <span class="org-rainbow-delimiters-depth-2">)</span>;

        EXPORT_CPP
        <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp;
        <span class="org-function-name">printVector</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">)</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-preprocessor">#endif</span> 
</pre>
</div>

<p>
The macro <code>EXPORT_CPP</code> expands to: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">EXPORT_CPP <span class="org-type">double</span> <span class="org-function-name">norm</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Macro EXPORT_CPP expansion </span>
<span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">double</span> <span class="org-function-name">norm</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
The compiler directives <b>#ifdef __cplusplus &#x2026; #endif</b> are used for
disabling this code block when the header is used by a C-compiler as
the C-language does not support classes, namespaces and many other C++
features. 
</p>

<ul class="org-ul">
<li>Implementation =&gt; file: <b>testlib.cpp</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Linear algebra tools </span>
<span class="org-keyword">namespace</span> <span class="org-constant">Linalg</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-2">(</span>dllexport<span class="org-rainbow-delimiters-depth-2">)</span>
     <span class="org-type">double</span> <span class="org-function-name">norm</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-type">double</span> <span class="org-variable-name">sum</span> = 0.0;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span> : xs<span class="org-rainbow-delimiters-depth-3">)</span> sum += x * x;
            <span class="org-keyword">return</span> <span class="org-constant">std</span>::sqrt<span class="org-rainbow-delimiters-depth-3">(</span>sum<span class="org-rainbow-delimiters-depth-3">)</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>

      <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-2">(</span>dllexport<span class="org-rainbow-delimiters-depth-2">)</span>
     <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
     <span class="org-function-name">linTransform</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">){</span>
         <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">out</span><span class="org-rainbow-delimiters-depth-3">(</span>xs.size<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
         ... ... .... 
     <span class="org-rainbow-delimiters-depth-2">}</span>

    ... ... 
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4632646" class="outline-4">
<h4 id="org4632646"><span class="section-number-4">1.2.4</span> C-interface of Namespace Linalg</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
<b>C-interface of Namespace Linalg</b> 
</p>

<p>
A C-interface is necessary for ensuring that the DLL can be called
from a C-program or a foreign function interface of a higher level
language. 
</p>

<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Function declaration.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">======= C-interface for Linalg namespace =========//</span>
<span class="org-comment-delimiter">/* </span><span class="org-comment">----- C-Wrappers for Linalg namespace ---- */</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Handle or opaque pointer for std::vector&lt;double&gt; */</span>
<span class="org-keyword">typedef</span> <span class="org-type">void</span>* <span class="org-type">hVectorD</span>;

<span class="org-keyword">extern</span> <span class="org-string">"C"</span>  <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">double</span> <span class="org-function-name">testlib_vectorD_Linalg_norm</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">extern</span> <span class="org-string">"C"</span>  <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">void</span> <span class="org-function-name">testlib_vectorD_Linalg_printVector</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>, <span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
The <b>extern "C"</b> statements are necessary to compile the functions with
<span class="underline">C-linkage</span>, it means without <span class="underline">name mangling</span> (aka name decoration). In
every C program, the function symbols are generally the same as their
names. However, as C++ supports templates and function overloading,
many functions can have the same, with different type signatures,
C++ compiler mangles or decorates function names with a different
schema to make the symbol unique. 
</p>

<p>
Functions with C-linkage, can only use C-compatible types or PODs
types (Plain Old Data). Therefore, they cannot use STL container,
std::vector, std::string and so on. 
</p>

<p>
The statement <code>__declspec(dllexport)</code> is necessary to make annotated
functions' symbols visible. On Unix-like systems and Linux, it is not
necessary as it is MSVC (cl.exe) compiler extension. 
</p>


<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; C-interface function implementations.</li>
</ul>

<p>
The type synonym hVectorD is handle or a opaque poiter for the type
std::vector&lt;double&gt;. It is a workaround, to pass std::vector&lt;double&gt;
accross a DLL functions with C-linkage and use std::vector&lt;double&gt;
from C programs or foreign function interfaces. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Handler for double vector </span>
<span class="org-keyword">using</span> <span class="org-type">hVectorD</span> = <span class="org-type">void</span>*;
<span class="org-keyword">using</span> <span class="org-type">pVectorD</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>*;

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for vector&lt;double&gt; constructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">hVectorD</span>
<span class="org-function-name">testlib_vectorD_make0</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>n, x<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
  ... ... ...     ... ... ...     ... ... ... 

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for vector&lt;double&gt; destructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">void</span>
<span class="org-function-name">testlib_vectorD_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-keyword">delete</span> <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">pVectorD</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>hv<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapepr for Linalg::norm function */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">double</span>
<span class="org-function-name">testlib_vectorD_Linalg_norm</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">return</span> <span class="org-constant">Linalg</span>::norm<span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">pVectorD</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>hv<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
  ... ... ...     ... ... ...     ... ... ... 

</pre>
</div>
</div>
</div>



<div id="outline-container-orgf6a272a" class="outline-4">
<h4 id="orgf6a272a"><span class="section-number-4">1.2.5</span> Non-polymorphic Class - SampleClass</h4>
<div class="outline-text-4" id="text-1-2-5">
<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Class declaration.</li>
</ul>

<p>
In order to a class be exported in a Windows' shared library, it
requires the annotation <code>__declspec(dllexport)</code>.
</p>

<p>
Note: It will not be possible to compiled client program using this
class with a compiler different from the used to build the shared
library libtest.dll. It happens because, the C++ ABI - Application
Binary Interface is not the same accross different compilers. If the
DLL is compiled with MSVC, the only way to use this class from a
program compiled using MingW or even a different version of MSVC is
by using a C-interface (functions with C-linkage) and opaque
pointers (void* pointers). 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">======= Non-polymorphic class exported by DLL =========//</span>
<span class="org-preprocessor">#ifdef</span> __cplusplus
<span class="org-comment-delimiter">// </span><span class="org-comment">Non-polymorphic class </span>
<span class="org-keyword">class</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">SampleClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-variable-name">SampleClass</span><span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-variable-name">SampleClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; name<span class="org-rainbow-delimiters-depth-2">)</span>;   
        ~<span class="org-variable-name">SampleClass</span><span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
        <span class="org-type">int</span> <span class="org-variable-name">get</span><span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-type">void</span> <span class="org-variable-name">set</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> n<span class="org-rainbow-delimiters-depth-2">)</span>;    
<span class="org-function-name">private</span>:
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
        <span class="org-type">int</span> <span class="org-variable-name">m_counter</span>;  
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-preprocessor">#endif</span> 
</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; Class implementation.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">SampleClass</span>::SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>
   : m_name<span class="org-rainbow-delimiters-depth-1">(</span>name<span class="org-rainbow-delimiters-depth-1">)</span>, m_counter<span class="org-rainbow-delimiters-depth-1">(</span>0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Instance created with name = "</span> &lt;&lt; m_name &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">/** </span><span class="org-comment">Delegated constructor on right-hand-side */</span>
<span class="org-function-name">SampleClass</span>::SampleClass<span class="org-rainbow-delimiters-depth-1">()</span>: SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"unnamed"</span><span class="org-rainbow-delimiters-depth-1">){}</span>   

<span class="org-function-name">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"SampleClass =&gt; name = "</span><span class="org-rainbow-delimiters-depth-2">)</span> + m_name +  <span class="org-string">" deleted"</span>;
    DbgTrace<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::string <span class="org-constant">SampleClass</span>::getName<span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> m_name;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">int</span> <span class="org-constant">SampleClass</span>::<span class="org-constant">SampleClass</span>::<span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-1">(){</span>        
    <span class="org-keyword">return</span> m_counter;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">void</span> <span class="org-constant">SampleClass</span>::<span class="org-function-name">set</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Counter set to value = "</span> &lt;&lt; n &lt;&lt; <span class="org-constant">std</span>::endl;
    m_counter = n;
<span class="org-rainbow-delimiters-depth-1">}</span>   
</pre>
</div>
</div>
</div>

<div id="outline-container-org938f6ff" class="outline-4">
<h4 id="org938f6ff"><span class="section-number-4">1.2.6</span> C-interface for SampleClass</h4>
<div class="outline-text-4" id="text-1-2-6">
<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Functions declarations.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/* </span><span class="org-comment">----- C-Wrappers for SampleClass namespace ---- */</span>
<span class="org-keyword">using</span> <span class="org-type">hSampleClass</span> = <span class="org-type">void</span>*;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Nullable constructor zero-arg constructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">hSampleClass</span>
<span class="org-function-name">testlib_SampleClass_make0</span><span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Other constructor */</span>
EXPORT_C <span class="org-type">hSampleClass</span> <span class="org-function-name">testlib_SampleClass_make1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Destructor */</span>
EXPORT_C
<span class="org-type">void</span>
<span class="org-function-name">testlib_SampleClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Wrapper for get method */</span>
EXPORT_C
<span class="org-type">int</span>
<span class="org-function-name">testlib_SampleClass_get</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Wrapper for set method */</span>
EXPORT_C
<span class="org-type">void</span>
<span class="org-function-name">testlib_SampleClass_set</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">EXPORT_C</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>*
testlib_SampleClass_getName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; Functions implementation.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">hSampleClass</span> = <span class="org-type">void</span>*;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Nullable constructor zero-arg constructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">hSampleClass</span>
<span class="org-function-name">testlib_SampleClass_make0</span><span class="org-rainbow-delimiters-depth-1">(){</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">SampleClass</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Other constructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">hSampleClass</span>
<span class="org-function-name">testlib_SampleClass_make1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">SampleClass</span><span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Destructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">void</span>
<span class="org-function-name">testlib_SampleClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">delete</span> <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">SampleClass</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>hnd<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Wrapper for get method */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">int</span>
<span class="org-function-name">testlib_SampleClass_get</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">SampleClass</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>hnd<span class="org-rainbow-delimiters-depth-2">)</span>-&gt;get<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0ff8267" class="outline-4">
<h4 id="org0ff8267"><span class="section-number-4">1.2.7</span> Polymorphic class InterfaceClass</h4>
<div class="outline-text-4" id="text-1-2-7">
<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Class declaration.</li>
</ul>

<p>
As the name implies, this class is an interface class, which is a
class containing only pure virtual functions (abstract methods). As a
result, it is declared only in the header file and cannot be
instatiated directly. 
</p>

<p>
This class uses only C-types to be binary compatible with different
compilers, if it used STL containers such as string or any other
non-compatible C-type, it would not be possible to compile a C++
program using Mingw/GCC against this DLL built with MSVC.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Polymorphic Interface class binary compatible across different</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">compilers as it does not use any STL container on the interface.</span>
<span class="org-preprocessor">#ifdef</span> __cplusplus
<span class="org-keyword">struct</span> <span class="org-type">InterfaceClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">/* </span><span class="org-comment">Returns class unique ID */</span>
        <span class="org-keyword">virtual</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = 0;
        <span class="org-comment-delimiter">/** </span><span class="org-comment">Set class internal state */</span>
        <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
        <span class="org-keyword">virtual</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> = 0;

        <span class="org-comment-delimiter">/** </span><span class="org-comment">Virtual constructor */</span>
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">InterfaceClass</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">virtual ~InterfaceClass();</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-preprocessor">#else</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">InterfaceClass</span> <span class="org-type">void</span> 
<span class="org-preprocessor">#endif</span> 
</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; class ImplementationA of interface InterfaceClass.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">ImplementationA</span>: <span class="org-keyword">public</span> <span class="org-type">InterfaceClass</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
<span class="org-function-name">public</span>:
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span> = <span class="org-string">"ImplementationA"</span>;

    <span class="org-function-name">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">()</span>: m_name<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Unammed-A"</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-function-name">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>
       : m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span> 
    ~<span class="org-function-name">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">(){</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] ImplementationA deleted =&gt; name = "</span>
                   &lt;&lt; m_name
                   &lt;&lt; <span class="org-string">" ; type = "</span> &lt;&lt; class_id
                   &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>     
        <span class="org-keyword">return</span> class_id;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        m_name = name;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> m_name.c_str<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; class ImplementationB of interface InterfaceClass.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">ImplementationB</span>: <span class="org-keyword">public</span> <span class="org-type">InterfaceClass</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
<span class="org-function-name">public</span>:
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span> = <span class="org-string">"ImplementationB"</span>;

    <span class="org-function-name">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">()</span>: m_name<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Unammed-B"</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-function-name">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>
       : m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span> 
    ~<span class="org-function-name">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] ImplementationB deleted =&gt; name = "</span>
                  &lt;&lt; m_name
                  &lt;&lt; <span class="org-string">" ; type = "</span> &lt;&lt; class_id
                  &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>     
            <span class="org-keyword">return</span> class_id;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
            m_name = name;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
            <span class="org-keyword">return</span> m_name.c_str<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; C-interface and factory function to load
implementations from the DLL.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Factory function */</span>
EXPORT_C <span class="org-type">InterfaceClass</span>* <span class="org-function-name">teslib_InterfaceClass_factory</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for destructor */</span>
EXPORT_C <span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for getID method */</span>
<span class="org-type">EXPORT_C</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">EXPORT_C</span> <span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_setName</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">EXPORT_C</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; C-interfaces and factory functions
definitions.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">EXPORT_C <span class="org-type">InterfaceClass</span>*
<span class="org-function-name">teslib_InterfaceClass_factory</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">s</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span>class_id<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>s == <span class="org-string">"ImplementationA"</span><span class="org-rainbow-delimiters-depth-2">)</span>
            <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>s == <span class="org-string">"ImplementationB"</span><span class="org-rainbow-delimiters-depth-2">)</span>
            <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

EXPORT_C <span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">delete</span> hinst;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">EXPORT_C</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> hinst-&gt;getID<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">EXPORT_C</span>
<span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_setName</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    hinst-&gt;setName<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">EXPORT_C</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">return</span> hinst-&gt;getName<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8a3ac8d" class="outline-4">
<h4 id="org8a3ac8d"><span class="section-number-4">1.2.8</span> DLL startup function DLLMain</h4>
<div class="outline-text-4" id="text-1-2-8">
<p>
When a Windows shared library is loaded at compile-time or at runtime
by some process, the function DLLMain is always invoked, it is similar
to the function main() from an executable. 
</p>

<p>
Note: logging statements with printf, std::cout, std::cerr will not
printed if the DLL is loaded by some non-console program, a program
compiled to the <span class="underline">window subsystem</span>. Therefore, the easiest way to log is
to use the OutputDebugString function which output can viewed by the
DebugView sysinternal tool. 
</p>


<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; DLL main function.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">- DLL Entry point - main function of DLL which is executed when</span>
<span class="org-comment">    the DLL is loaded by some process.</span>
<span class="org-comment"> */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
BOOL <span class="org-type">APIENTRY</span> <span class="org-function-name">DllMain</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">HINSTANCE</span> <span class="org-variable-name">hInst</span>, <span class="org-type">DWORD</span> <span class="org-variable-name">reason</span>, <span class="org-type">LPVOID</span> <span class="org-variable-name">lpReserved</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span> =
           <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"DLL Loaded into the process =&gt; PID = "</span><span class="org-rainbow-delimiters-depth-2">)</span>
           + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-2">(</span>::GetCurrentProcessId<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   WindbgTrace<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;
   DbgTrace<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;      
    <span class="org-keyword">switch</span> <span class="org-rainbow-delimiters-depth-2">(</span>reason<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">case</span> DLL_PROCESS_ATTACH:
        WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL attached to process"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL attached to process."</span><span class="org-rainbow-delimiters-depth-3">)</span>;           
      <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> DLL_PROCESS_DETACH:
        WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"=&gt; DLL detached."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"=&gt; DLL attached"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
      <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> DLL_THREAD_ATTACH:
        WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL attached to thread"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL detached to thread."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> DLL_THREAD_DETACH:
        WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL detached from thread"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL detached from thread."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
      <span class="org-keyword">break</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">return</span> TRUE;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Another more portable way to peform some way action when the DLL is
loaded by a process or unloaded is to use a static object. The startup
task is executed int the object's constructor and the finalization
task, which happens when the process ends, is executed at object's
destructor. 
</p>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; Static Object for replacing DLLMain</li>
</ul>

<p>
The class _StaticObject and a static instance of it is defined within
an anonymous namespace to make them private to the compilation unit
testlib.cpp and not allow them to be used from anywhere else. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Class private to this compilation unit - cannot be accessed from</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">any other file</span>
<span class="org-keyword">namespace</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">class</span> <span class="org-type">_StaticObject</span><span class="org-rainbow-delimiters-depth-2">{</span>     
   <span class="org-keyword">public</span>:
       <span class="org-keyword">using</span> <span class="org-type">Action</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>;
       <span class="org-type">Action</span> <span class="org-variable-name">m_end</span>;

       <span class="org-function-name">_StaticObject</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Action</span> <span class="org-variable-name">init</span>, <span class="org-type">Action</span> <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-3">)</span>
               :  m_end<span class="org-rainbow-delimiters-depth-3">(</span>end<span class="org-rainbow-delimiters-depth-3">)</span>
       <span class="org-rainbow-delimiters-depth-3">{</span>
               init<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-rainbow-delimiters-depth-3">}</span>
       ~<span class="org-function-name">_StaticObject</span><span class="org-rainbow-delimiters-depth-3">(){</span> m_end<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
   <span class="org-rainbow-delimiters-depth-2">}</span>;

   <span class="org-comment-delimiter">// </span><span class="org-comment">Static object for replacing DLLMain </span>
   <span class="org-keyword">auto</span> <span class="org-variable-name">initDLL</span> = _StaticObject<span class="org-rainbow-delimiters-depth-2">(</span>
      <span class="org-rainbow-delimiters-depth-3">[]{</span>
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [StaticObject] =&gt; Initialize DLL"</span>
                       &lt;&lt; <span class="org-constant">std</span>::endl;                        
      <span class="org-rainbow-delimiters-depth-3">}</span>,
      <span class="org-rainbow-delimiters-depth-3">[]{</span>   
           <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [StaticObject] =&gt; Shutdown DLL"</span>
                     &lt;&lt; <span class="org-constant">std</span>::endl;                              
      <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdaf4e84" class="outline-4">
<h4 id="orgdaf4e84"><span class="section-number-4">1.2.9</span> DLL entry point for run32dll.exe</h4>
<div class="outline-text-4" id="text-1-2-9">
<p>
This function is a DLL entry point for the Windows program
rundll32.exe which can execute this function with: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ rundll32.exe testlib.dll,entryPoint1
$ rundll32.exe testlib.dll,entryPoint1 arg0 arg1 <span class="org-type">arg2</span> ... <span class="org-variable-name">argn</span> 
</pre>
</div>

<p>
When the DLL testlib.dll is run with run32dll calling the function
entryPoint1, it will display a message box. 
</p>

<p>
Note: It is an optional function which could be used for installing
the DLL in the system or creating some entry in Windows' registry. 
</p>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">void</span> <span class="org-function-name">entryPoint1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">HWND</span> <span class="org-variable-name">hwn</span>, <span class="org-type">HINSTANCE</span> <span class="org-variable-name">hinst</span>, <span class="org-type">LPSTR</span> <span class="org-variable-name">cmdLine</span>, <span class="org-type">int</span> <span class="org-variable-name">nCmdShow</span><span class="org-rainbow-delimiters-depth-1">){</span>  
     DbgDisp<span class="org-rainbow-delimiters-depth-2">(</span>cmdLine<span class="org-rainbow-delimiters-depth-2">)</span>;
     OutputDebugString<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Rudll32 called entryPoint1()"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     MessageBoxA<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">NULL</span>, <span class="org-string">"DLL ENTRY POINT"</span>, <span class="org-string">"Entry point 1"</span>, 0<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5e46c02" class="outline-4">
<h4 id="org5e46c02"><span class="section-number-4">1.2.10</span> C++ Client program - client1.cpp</h4>
<div class="outline-text-4" id="text-1-2-10">
<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/client1.cpp">file:src/dlls/example-windows1/client1.cpp</a></li>
</ul>

<p>
<b>File client1.cpp</b>
</p>

<p>
Includes: 
</p>

<ul class="org-ul">
<li>Note: (#include "testlib.hpp") a header file between quotes,
indicates to the compiler that the header is in the same directory
as the source file client1.cpp.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">ostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string">"testlib.hpp"</span>
</pre>
</div>

<p>
Declaration of functions with C-linkages not declarated in the header
testlib.hpp
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-type">hVectorD</span> <span class="org-function-name">testlib_vectorD_make0</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-type">hVectorD</span> <span class="org-function-name">testlib_vectorD_make1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">array</span> <span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-type">void</span> <span class="org-function-name">testlib_vectorD_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Main function - Experiment 1 and Experiment 2:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> DISABLE
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n=== EXPERIMENT 1 ===&gt; Import C++ functions from DLL"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

DbgTrace<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Main process starts here."</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> xs<span class="org-rainbow-delimiters-depth-1">{</span>1.0, 2.0, 3.0, 4.0, 5.0<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; Linalg::norm(xs) "</span> &lt;&lt; <span class="org-constant">Linalg</span>::norm<span class="org-rainbow-delimiters-depth-1">(</span>xs<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"=&gt; xs = "</span>; <span class="org-constant">Linalg</span>::printVector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cout, xs<span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"=== EXPERIMENT 2 ===&gt; Import class from DLL"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-keyword">auto</span> <span class="org-variable-name">cls</span> = SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Dummy"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
cls.set<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"cls.getName() = "</span> &lt;&lt; cls.getName<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"    cls.get() = "</span> &lt;&lt; cls.get<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-preprocessor">#endif</span> <span class="org-comment-delimiter">// </span><span class="org-comment">-- eof DISABLE flag</span>
</pre>
</div>

<p>
Main Function - Experiment 3 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">//</span><span class="org-comment">=========&gt;&gt; Load functions and classes using C-interface ==============//</span>

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n== EPERIMENT 3 ===&gt; Import C-functions from DLL - C-interface"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-type">double</span> <span class="org-variable-name">arr</span> <span class="org-rainbow-delimiters-depth-1">[]</span> = <span class="org-rainbow-delimiters-depth-1">{</span>1, 2, 3, 4, 5<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">hVectorD</span> <span class="org-variable-name">v1</span> = testlib_vectorD_make1<span class="org-rainbow-delimiters-depth-1">(</span>5, arr<span class="org-rainbow-delimiters-depth-1">)</span>;
testlib_vectorD_Linalg_printVector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"v1"</span>, v1<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"norm(v1) = "</span> &lt;&lt; testlib_vectorD_Linalg_norm<span class="org-rainbow-delimiters-depth-1">(</span>v1<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;

testlib_vectorD_delete<span class="org-rainbow-delimiters-depth-1">(</span>v1<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Main Functions - Experiment 4 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n== EPERIMENT 4 ===&gt; Non-polymorphic class with C-interface "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-type">hSampleClass</span> <span class="org-variable-name">hcls</span> = testlib_SampleClass_make1<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"[EXPERIMENT4]ClassHandle-OOP-C-API"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"[EXPERIMENT 4] hcls.getName() = "</span> &lt;&lt; testlib_SampleClass_getName<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
testlib_SampleClass_set<span class="org-rainbow-delimiters-depth-1">(</span>hcls, 100<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"[EXPERIMENT 4] hcls.get()     = "</span> &lt;&lt; testlib_SampleClass_get<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
testlib_SampleClass_set<span class="org-rainbow-delimiters-depth-1">(</span>hcls, 200<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"[EXPERIMENT 4] hcls.get()     = "</span> &lt;&lt; testlib_SampleClass_get<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;

testlib_SampleClass_delete<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span>;   
</pre>
</div>

<p>
Main Functions - Experiment 5 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n== EPERIMENT 5 ===&gt; Load polymorphic classes from DLL "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinstA</span> = teslib_InterfaceClass_factory<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ImplementationA"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinstB</span> = teslib_InterfaceClass_factory<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ImplementationB"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstA-&gt;getID() = "</span> &lt;&lt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstA-&gt;getID() = "</span> &lt;&lt; hinstB-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
hinstA-&gt;setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ClassA-implA"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
hinstB-&gt;setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ClassB-implB"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstA-&gt;getName() = "</span> &lt;&lt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstB-&gt;getName() = "</span> &lt;&lt; hinstB-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-comment-delimiter">// </span><span class="org-comment">Note: If delete is used directly to delete hinstA and hinstB,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">a segmentatin fault will happen whenc compiling with Mingw/GCC</span>
testlib_InterfaceClass_delete<span class="org-rainbow-delimiters-depth-1">(</span>hinstA<span class="org-rainbow-delimiters-depth-1">)</span>;
testlib_InterfaceClass_delete<span class="org-rainbow-delimiters-depth-1">(</span>hinstB<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] After deleting instances"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

DbgTrace<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Program ended OK."</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Compile and run client code with MSVC</b>
</p>

<p>
Note: Both the DLL and the client code are compiled with MSVC-2017 64
bits target.
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cl.exe /EHsc client.cpp /nologo /Fe:client1.exe testlib.lib &amp;&amp; client1.exe

<span class="org-comment-delimiter"># </span><span class="org-comment">Output: </span>
client.cpp
   Creating library client1.lib and object client1.exp
 [StaticObject] =&gt; Initialize DLL
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the process =&gt; PID = 1112
<span class="org-function-name">testlib.cpp</span>:45: &lt;DllMain&gt; DLL attached to process.

=== EXPERIMENT 1 ===&gt; Import C++ functions from DLL
<span class="org-function-name">client.cpp</span>:33: &lt;main&gt; Main process starts here.
 =&gt; Linalg::norm(xs) 7.4162
=&gt; xs = [5]( 1, 2, 3, 4, 5,  )
=== EXPERIMENT 2 ===&gt; Import class from DLL
 Instance created with name = Dummy
 Counter set to value = 100
<span class="org-function-name">cls.getName</span>() = Dummy
    cls.get() = 100

== EPERIMENT 3 ===&gt; Import C-functions from DLL - C-interface
v1 = [5]( 1, 2, 3, 4, 5,  )
<span class="org-function-name">norm</span>(v1) = 7.4162

== EPERIMENT 4 ===&gt; Non-polymorphic class with C-interface 
 Instance created with name = [EXPERIMENT4]ClassHandle-OOP-C-API
[EXPERIMENT 4] hcls.getName() = [EXPERIMENT4]ClassHandle-OOP-C-API
 Counter set to value = 100
[EXPERIMENT 4] hcls.get()     = 100
 Counter set to value = 200
[EXPERIMENT 4] hcls.get()     = 200
<span class="org-function-name">testlib.cpp</span>:159: &lt;SampleClass::~SampleClass&gt; SampleClass =&gt; name = [EXPERIMENT4]ClassHandle-OOP-C-API deleted

== EPERIMENT 5 ===&gt; Load polymorphic classes from DLL 
 =&gt; hinstA-&gt;getID() = ImplementationA
 =&gt; hinstA-&gt;getID() = ImplementationB
 =&gt; hinstA-&gt;getName() = ImplementationA
 =&gt; hinstB-&gt;getName() = ImplementationB
 [INFO] ImplementationA deleted =&gt; name = ClassA-implA ; <span class="org-builtin">type</span> = ImplementationA
 [INFO] ImplementationB deleted =&gt; name = ClassB-implB ; <span class="org-builtin">type</span> = ImplementationB
 [INFO] After deleting instances
<span class="org-function-name">client.cpp</span>:87: &lt;main&gt; Program ended OK.
<span class="org-function-name">testlib.cpp</span>:159: &lt;SampleClass::~SampleClass&gt; SampleClass =&gt; name = Dummy deleted
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the process =&gt; PID = 1112
<span class="org-function-name">testlib.cpp</span>:49: &lt;DllMain&gt; =&gt; DLL attached
 [StaticObject] =&gt; Shutdown DLL

</pre>
</div>

<p>
<b>[FAILURE] ABI - Issue - Compile with Mingw client1.cpp against testlib.dll built with MSVC</b>
</p>

<p>
The client code is compiled with Mingw and the library was built with
MSVC-2017 for 64 bits target.
</p>

<p>
Build and run client [FAILURE]:
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ client1.cpp -g -o <span class="org-keyword">client1-gcc.exe</span> -std=c++14 testlib.dll  &amp;&amp; client1-gcc.exe
<span class="org-function-name">C</span>:\Users\archbox\AppData\Local\Temp\cckNg9eZ.o: In function `main<span class="org-warning">'</span>:
<span class="org-function-name">client1.cpp</span>:35: undefined reference to `<span class="org-constant">Linalg</span>::norm<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:36: undefined reference to `<span class="org-constant">Linalg</span>::printVector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp;, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:39: undefined reference to `<span class="org-constant">SampleClass</span>::SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">__cxx11</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:40: undefined reference to `<span class="org-constant">SampleClass</span>::set<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:41: undefined reference to `<span class="org-constant">SampleClass</span>::getName<span class="org-rainbow-delimiters-depth-1">[</span>abi:cxx11<span class="org-rainbow-delimiters-depth-1">]()</span> <span class="org-keyword">const</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:42: undefined reference to `<span class="org-constant">SampleClass</span>::get<span class="org-rainbow-delimiters-depth-1">()</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:39: undefined reference to `<span class="org-constant">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">()</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:39: undefined reference to `<span class="org-constant">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">()</span><span class="org-warning">'</span>
<span class="org-function-name">collect2.exe</span>: error: ld returned 1 exit status
Compilation <span class="org-compilation-error">exited abnormally</span> with code <span class="org-compilation-error">1</span> at Sun Dec 16 17:41:47
</pre>
</div>

<p>
The compilation fails because C++ does not have a standard and stable
ABI - Application Binary Interface, as a result, it is not possible to
use an object-code (here - any type of compiled code) built by a
different compiler than the current one. The ABI comprises the name
mangling schema or name decoration schema which is compiler-dependent,
padding, class memory layout and so on. In addition to ABI issues, the
STL - Standard Template Library implementations may not be compatible
and also not be the same across different compilers. 
</p>

<p>
The only way to ensure that a DLL can work with all possible compilers
is to use a functions with C-linkage (extern "C") with opaque pointers
(void*) for passing around classes and wrapped STL containers. Classes
can be used by different compilers, only if they are interface classes
(classes with only pure virtual functions) containing only
C-compatible types in the declaration. 
</p>


<p>
<b>Compile with Mingw client1.cpp against testlib.dll built with MSVC</b>
</p>

<p>
The compilation works when compiling with the custom flag -DDISABLE.
The directive <span class="underline">#ifndef DISABLE &#x2026; #endif</span> removes all usages of the
namespace Linalg and the class SampleClass. This flag makes main the
function use only functions with C-linkage and the interface class
InterfaceClass.
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ client.cpp -g -o <span class="org-keyword">client-gcc.exe</span> -std=c++14 testlib.dll -DDISABLE   &amp;&amp; client-gcc.exe

   <span class="org-rainbow-delimiters-depth-1">[</span>StaticObject<span class="org-rainbow-delimiters-depth-1">]</span> =&gt; Initialize DLL
  testlib.cpp:39: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> DLL Loaded into the process =&gt; PID = 5724
  testlib.cpp:45: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> DLL attached to process.

  == EPERIMENT 3 ===&gt; Import C-functions from DLL - C-interface
  v1 = <span class="org-rainbow-delimiters-depth-1">[</span>5<span class="org-rainbow-delimiters-depth-1">](</span> 1, 2, 3, 4, 5,  <span class="org-rainbow-delimiters-depth-1">)</span>
  norm<span class="org-rainbow-delimiters-depth-1">(</span>v1<span class="org-rainbow-delimiters-depth-1">)</span> = 7.4162

  == EPERIMENT 4 ===&gt; Non-polymorphic <span class="org-keyword">class</span> with C-interface 
   Instance created with name = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">EXPERIMENT4</span><span class="org-rainbow-delimiters-depth-1">]</span>ClassHandle-OOP-C-API
  <span class="org-rainbow-delimiters-depth-1">[</span>EXPERIMENT 4<span class="org-rainbow-delimiters-depth-1">]</span> hcls.getName<span class="org-rainbow-delimiters-depth-1">()</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">EXPERIMENT4</span><span class="org-rainbow-delimiters-depth-1">]</span>ClassHandle-OOP-C-API
   Counter set to value = 100
  <span class="org-rainbow-delimiters-depth-1">[</span>EXPERIMENT 4<span class="org-rainbow-delimiters-depth-1">]</span> hcls.get<span class="org-rainbow-delimiters-depth-1">()</span>     = 100
   Counter set to value = 200
  <span class="org-rainbow-delimiters-depth-1">[</span>EXPERIMENT 4<span class="org-rainbow-delimiters-depth-1">]</span> hcls.get<span class="org-rainbow-delimiters-depth-1">()</span>     = 200
  testlib.cpp:159: <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">&gt;</span> SampleClass =&gt; name = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">EXPERIMENT4</span><span class="org-rainbow-delimiters-depth-1">]</span>ClassHandle-OOP-C-API deleted

  == EPERIMENT 5 ===&gt; Load polymorphic classes from DLL 
   =&gt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationA
   =&gt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationB
   =&gt; hinstA-&gt;getName<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationA
   =&gt; hinstB-&gt;getName<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationB
   <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> ImplementationA deleted =&gt; name = ClassA-implA ; type = ImplementationA
   <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> ImplementationB deleted =&gt; name = ClassB-implB ; type = ImplementationB
   <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> After deleting instances
  client.cpp:87: <span class="org-rainbow-delimiters-depth-1">&lt;</span>main<span class="org-rainbow-delimiters-depth-1">&gt;</span> Program ended OK.
  testlib.cpp:39: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> DLL Loaded into the process =&gt; PID = 5724
  testlib.cpp:49: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> =&gt; DLL attached
   <span class="org-rainbow-delimiters-depth-1">[</span>StaticObject<span class="org-rainbow-delimiters-depth-1">]</span> =&gt; Shutdown DLL
</pre>
</div>
</div>
</div>






<div id="outline-container-org114d1a0" class="outline-4">
<h4 id="org114d1a0"><span class="section-number-4">1.2.11</span> Load DLL in Python3 REPL</h4>
<div class="outline-text-4" id="text-1-2-11">
<p>
Functions with C-linkage can be called by Python using the ctypes
library. The following code presents how it can be done: 
</p>

<p>
<b>Table for C types / Python ctypes conversion</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">C-type</th>
<th scope="col" class="org-left">Python C-types</th>
<th scope="col" class="org-left">C-type</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">char</td>
<td class="org-left">ctypes.c_char</td>
<td class="org-left">char*</td>
<td class="org-left">ctypes.POINTER(ctypes.c_char)</td>
</tr>

<tr>
<td class="org-left">int</td>
<td class="org-left">ctypes.c_int</td>
<td class="org-left">int*</td>
<td class="org-left">ctypes.POINTER(ctypes.c_int)</td>
</tr>

<tr>
<td class="org-left">size_t</td>
<td class="org-left">ctypes.c_int</td>
<td class="org-left">-</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">double</td>
<td class="org-left">ctypes.c_double</td>
<td class="org-left">double*</td>
<td class="org-left">ctypes.POINTER(ctypes.c_double)</td>
</tr>

<tr>
<td class="org-left">void</td>
<td class="org-left">None</td>
<td class="org-left">void*</td>
<td class="org-left">ctypes.c_void_p</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Get a Python string from a <span class="underline">const char* ptr</span> or <span class="underline">char* ptr</span>, use ctypes.string_at(ptr).</li>
<li>Pass a python string to an API with const char*
(ctypes.POINTER(ctypes.c_char)) as argument, use Function("string-argument".encode('utf-8'))</li>
</ul>

<p>
Python C-types documentation and further reading: 
</p>

<ul class="org-ul">
<li><a href="https://docs.python.org/3/library/ctypes.html">ctypes — A foreign function library for Python — Python 3.7.2rc1 documentation</a></li>
<li><a href="https://dbader.org/blog/python-ctypes-tutorial">Extending Python With C Libraries and the “ctypes” Module – dbader.org</a></li>
<li><a href="https://www.programcreek.com/python/example/1108/ctypes.CDLL">ctypes.CDLL Python Example</a></li>
<li><a href="https://blogs.msdn.microsoft.com/yizhang/2018/01/20/calling-c-functions-from-python-part-1-using-ctypes/">Calling C functions from Python – part 1 – using ctypes – Yi Zhang's MSDN Blog</a></li>
<li><a href="https://en.wikibooks.org/wiki/Python_Programming/Extending_with_ctypes">Python Programming/Extending with ctypes - Wikibooks, open books for an open world</a></li>
<li><a href="https://pgi-jcns.fz-juelich.de/portal/pages/using-c-from-python.html">Using C from Python: How to create a ctypes wrapper - Scientific IT-Systems</a></li>
</ul>

<p>
<b>Load the library:</b>
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-function-name">C</span>:\Users\archbox\Desktop\experiments
&#955; <span class="org-string">"C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\python"</span>
Python 3.6.5 |Anaconda, Inc.| (default, Mar 29 2018, 13:32:41) [MSC v.1900 64 bit (AMD64)] on win32
Type <span class="org-string">"help"</span>, <span class="org-string">"copyright"</span>, <span class="org-string">"credits"</span> <span class="org-keyword">or</span> <span class="org-string">"license"</span> <span class="org-keyword">for</span> more information.

&gt;&gt;&gt; <span class="org-keyword">import</span> ctypes

<span class="org-comment-delimiter"># </span><span class="org-comment">This messages is print by the DLLMain function </span>
&gt;&gt;&gt; <span class="org-variable-name">lib</span> = ctypes.cdll.LoadLibrary(<span class="org-string">"testlib.dll"</span>)
 [StaticObject] =&gt; Initialize DLL
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the <span class="org-variable-name">process</span> =&gt; <span class="org-variable-name">PID</span> = 4280
<span class="org-function-name">testlib.cpp</span>:45: &lt;DllMain&gt; DLL attached to process.
&gt;&gt;&gt; testlib.cpp:39: &lt;DllMain&gt; DLL Loaded into the <span class="org-variable-name">process</span> =&gt; <span class="org-variable-name">PID</span> = 4280
<span class="org-function-name">testlib.cpp</span>:53: &lt;DllMain&gt; DLL detached to thread.
</pre>
</div>

<p>
Check whether exported functions with C-linkage exist: 
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; lib.testlib_vectorD_make0
&lt;_FuncPtr <span class="org-builtin">object</span> at 0x0000021BFCAFF388&gt;

&gt;&gt;&gt; lib.testlib_vectorD_Linalg_printVector
&lt;_FuncPtr <span class="org-builtin">object</span> at 0x0000021BFCAFF458&gt;
&gt;&gt;&gt;

&gt;&gt;&gt; lib.testlib_vectorD_delete
&lt;_FuncPtr <span class="org-builtin">object</span> at 0x0000021BFCAFF528&gt;

<span class="org-comment-delimiter"># </span><span class="org-comment">Function which does not exist.</span>
&gt;&gt;&gt; lib.testlib_InterfaceClass_do_not_exist
Traceback (most recent call last):
  File <span class="org-string">"&lt;stdin&gt;"</span>, line 1, <span class="org-keyword">in</span> &lt;module&gt;
  File <span class="org-string">"C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\lib\ctypes\__init__.py"</span>, line 361, <span class="org-keyword">in</span> __getattr__
    <span class="org-variable-name">func</span> = <span class="org-keyword">self</span>.__getitem__(name)
  File <span class="org-string">"C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\lib\ctypes\__init__.py"</span>, line 366, <span class="org-keyword">in</span> __getitem__
    <span class="org-variable-name">func</span> = <span class="org-keyword">self</span>._FuncPtr((name_or_ordinal, <span class="org-keyword">self</span>))
<span class="org-function-name">AttributeError</span>: function <span class="org-string">'testlib_InterfaceClass_do_not_exist'</span> <span class="org-keyword">not</span> found
</pre>
</div>

<p>
<b>Load std::vector&lt;double&gt; and Linalg namespace wrapper functions</b>
</p>

<p>
Set up the std::vector&lt;double&gt; functions to be imported.
</p>

<ul class="org-ul">
<li>Note: hVectorD =&gt; Handle for std::vector&lt;double&gt; is the same as
void* or an opaque pointer.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Funciton: hVectorD testlib_vectorD_make0(size_t n, double x)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set function arguments</span>
<span class="org-variable-name">lib.testlib_vectorD_make0.argtypes</span> = [ctypes.c_int, ctypes.c_double]
<span class="org-comment-delimiter"># </span><span class="org-comment">Set return type </span>
<span class="org-variable-name">lib.testlib_vectorD_make0.restype</span>  = ctypes.c_void_p

<span class="org-comment-delimiter"># </span><span class="org-comment">void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv)</span>
<span class="org-variable-name">lib.testlib_vectorD_Linalg_printVector.argtypes</span> = [ctypes.POINTER(ctypes.c_char), ctypes.c_void_p ]
<span class="org-variable-name">lib.testlib_vectorD_Linalg_printVector.restype</span> = <span class="org-constant">None</span> 

<span class="org-comment-delimiter"># </span><span class="org-comment">Set vector elements hv[n] = x</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">void testlib_vectorD_set(hVectorD hv, size_t n, double x)</span>
<span class="org-variable-name">lib.testlib_vectorD_set.argtypes</span> = [ctypes.c_void_p, ctypes.c_int, ctypes.c_double]
<span class="org-variable-name">lib.testlib_vectorD_set.restype</span>  = <span class="org-constant">None</span>
</pre>
</div>

<p>
Testing C-interface functions for std::vector&lt;double&gt;: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Creating a std::vector&lt;double&gt; with 4 elements equal to 3.0 </span>
&gt;&gt;&gt; <span class="org-variable-name">vec1</span> = lib.testlib_vectorD_make0(4, 3.0)

<span class="org-comment-delimiter"># </span><span class="org-comment">This number is the memory address held by the opaque pointer,</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">it cannot be used directly. </span>
&gt;&gt;&gt; vec1
2319184200912
&gt;&gt;&gt;
<span class="org-comment-delimiter"># </span><span class="org-comment">========== Modify vector elements ======== #</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Printarray2 the wrapped std::vector&lt;double&gt;</span>
&gt;&gt;&gt; lib.testlib_vectorD_Linalg_printVector(<span class="org-string">"vec1"</span>.encode(<span class="org-string">'utf-8'</span>), vec1)
<span class="org-variable-name">vec1</span> = [4]( 3, 3, 3, 3,  )
&gt;&gt;&gt;

&gt;&gt;&gt; lib.testlib_vectorD_set(vec1, 0, 5.0)
&gt;&gt;&gt; lib.testlib_vectorD_set(vec1, 1, 10.5)
&gt;&gt;&gt; lib.testlib_vectorD_set(vec1, 2, 4.78)

&gt;&gt;&gt; lib.testlib_vectorD_Linalg_printVector(<span class="org-string">"vec1"</span>.encode(<span class="org-string">'utf-8'</span>), vec1)
<span class="org-variable-name">vec1</span> = [4]( 5, 10.5, 4.78, 3,  )
</pre>
</div>

<p>
Compute vector Euclidian norm: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Wrapper for function </span>
<span class="org-comment-delimiter"># </span><span class="org-comment">double Linalg::norm(const std::vector&lt;double&gt;&amp; xs)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">double testlib_vectorD_Linalg_norm(hVectorD hv)</span>
<span class="org-variable-name">lib.testlib_vectorD_Linalg_norm.argtypes</span> = [ ctypes.c_void_p ]
<span class="org-variable-name">lib.testlib_vectorD_Linalg_norm.restype</span>  = ctypes.c_double

&gt;&gt;&gt; lib.testlib_vectorD_Linalg_printVector(<span class="org-string">"vec1"</span>.encode(<span class="org-string">'utf-8'</span>), vec1)
<span class="org-variable-name">vec1</span> = [4]( 5, 10.5, 4.78, 3,  )

&gt;&gt;&gt; lib.testlib_vectorD_Linalg_norm(vec1)
12.926654632966722

<span class="org-comment-delimiter"># </span><span class="org-comment">Check if calculations are right </span>
&gt;&gt;&gt; math.sqrt(5 * 5 + 10.5 * 10.5 + 4.78 * 4.78 + 3 * 3)
12.926654632966722
&gt;&gt;&gt;
</pre>
</div>

<p>
Delete vector vec1 using its destructor function: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Function: void testlib_vectorD_delete(hVectorD hv)</span>
<span class="org-variable-name">lib.testlib_vectorD_delete.argtypes</span> = [ ctypes.c_void_p ]
<span class="org-variable-name">lib.testlib_vectorD_delete.restype</span> = <span class="org-constant">None</span>

&gt;&gt;&gt; lib.testlib_vectorD_delete(vec1)
</pre>
</div>

<p>
<b>Load wrapper function for interface class InterfaceClass</b>
</p>

<p>
Load factory function: 
</p>
<ul class="org-ul">
<li>void* teslib_InterfaceClass_factory(const char* class_id)</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">InterfaceClass* teslib_InterfaceClass_factory(const char* class_id)</span>
<span class="org-variable-name">lib.teslib_InterfaceClass_factory.argtypes</span> = [ ctypes.POINTER(ctypes.c_char) ]
<span class="org-variable-name">lib.teslib_InterfaceClass_factory.restype</span>  = ctypes.c_void_p

<span class="org-comment-delimiter"># </span><span class="org-comment">const char* testlib_InterfaceClass_getID(InterfaceClass* hinst)</span>
<span class="org-variable-name">lib.testlib_InterfaceClass_getID.argtypes</span> = [ ctypes.c_void_p ]
<span class="org-variable-name">lib.testlib_InterfaceClass_getID.restype</span>  = ctypes.POINTER(ctypes.c_char)
</pre>
</div>

<p>
Creating class instances and testing member function C-wrappers:
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-variable-name">hinstA</span> = lib.teslib_InterfaceClass_factory(<span class="org-string">"ImplementationA"</span>.encode(<span class="org-string">'utf-8'</span>))
&gt;&gt;&gt; hinstA
2319184196864
&gt;&gt;&gt;

&gt;&gt;&gt; <span class="org-variable-name">hinstB</span> = lib.teslib_InterfaceClass_factory(<span class="org-string">"ImplementationB"</span>.encode(<span class="org-string">'utf-8'</span>))
&gt;&gt;&gt; hinstB
2319184198016

&gt;&gt;&gt; <span class="org-variable-name">s1</span> = lib.testlib_InterfaceClass_getID(hinstA)
&gt;&gt;&gt; s1
&lt;ctypes.LP_c_char <span class="org-builtin">object</span> at 0x0000021BFBBF14C8&gt;
&gt;&gt;&gt; ctypes.string_at(s1)
b<span class="org-string">'ImplementationA'</span>
&gt;&gt;&gt;

&gt;&gt;&gt; <span class="org-variable-name">s2</span> = lib.testlib_InterfaceClass_getID(hinstB)
&gt;&gt;&gt; ctypes.string_at(s2)
b<span class="org-string">'ImplementationB'</span>

&gt;&gt;&gt; ctypes.string_at(lib.testlib_InterfaceClass_getID(hinstB))
b<span class="org-string">'ImplementationB'</span>
&gt;&gt;&gt;
</pre>
</div>

<p>
Load more C-wrappers for member function of class InterfaceClass:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">const char* testlib_InterfaceClass_getName(InterfaceClass* hinst) </span>
<span class="org-variable-name">lib.testlib_InterfaceClass_getName.argtypes</span> = [ ctypes.c_void_p ]
<span class="org-variable-name">lib.testlib_InterfaceClass_getName.restype</span>  = ctypes.POINTER(ctypes.c_char)

<span class="org-comment-delimiter"># </span><span class="org-comment">void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name)</span>
&gt;&gt;&gt; <span class="org-variable-name">lib.testlib_InterfaceClass_setName.argtypes</span> = [ ctypes.c_void_p, ctypes.POINTER(ctypes.c_char) ]
&gt;&gt;&gt; <span class="org-variable-name">lib.testlib_InterfaceClass_setName.restype</span> = <span class="org-constant">None</span>

&gt;&gt;&gt; lib.testlib_InterfaceClass_getName(hinstA)
&lt;ctypes.LP_c_char <span class="org-builtin">object</span> at 0x0000021BFBBF1548&gt;

&gt;&gt;&gt; ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstA))
b<span class="org-string">'Unammed-A'</span>

&gt;&gt;&gt; ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstB))
b<span class="org-string">'Unammed-B'</span>

&gt;&gt;&gt; lib.testlib_InterfaceClass_setName(hinstA, <span class="org-string">"Instance-ClassA1"</span>.encode(<span class="org-string">'utf-8'</span>))
&gt;&gt;&gt; ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstA))
b<span class="org-string">'Instance-ClassA1'</span>

&gt;&gt;&gt; lib.testlib_InterfaceClass_setName(hinstB, <span class="org-string">"Instance-B1"</span>.encode(<span class="org-string">'utf-8'</span>))
&gt;&gt;&gt; ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstB))
b<span class="org-string">'Instance-B1'</span>

</pre>
</div>

<p>
Load C-functions wrappers for the InterfaceClass destructor and
dispose both instances hinstA and hinstB: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Destructor function:</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">void testlib_InterfaceClass_delete(InterfaceClass* hinst)</span>
&gt;&gt;&gt; <span class="org-variable-name">lib.testlib_InterfaceClass_delete.argtypes</span> = [ ctypes.c_void_p ]
&gt;&gt;&gt; <span class="org-variable-name">lib.testlib_InterfaceClass_delete.restype</span>  = <span class="org-constant">None</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Dispose class hinstA, delete this object </span>
&gt;&gt;&gt; lib.testlib_InterfaceClass_delete(hinstA)
 [INFO] ImplementationA <span class="org-variable-name">deleted</span> =&gt; <span class="org-variable-name">name</span> = Instance-ClassA1 ; <span class="org-builtin">type</span> = ImplementationA

&gt;&gt;&gt; lib.testlib_InterfaceClass_delete(hinstB)
 [INFO] ImplementationB <span class="org-variable-name">deleted</span> =&gt; <span class="org-variable-name">name</span> = Instance-B1 ; <span class="org-builtin">type</span> = ImplementationB
</pre>
</div>

<p>
Exit python3 REPL:
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-constant">exit</span>()
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the <span class="org-variable-name">process</span> =&gt; <span class="org-variable-name">PID</span> = 4280
<span class="org-function-name">testlib.cpp</span>:49: &lt;DllMain&gt; =&gt; DLL attached
 [StaticObject] =&gt; Shutdown DLL
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd542cbc" class="outline-4">
<h4 id="orgd542cbc"><span class="section-number-4">1.2.12</span> Python 3 Client Code - Wrapper Module</h4>
<div class="outline-text-4" id="text-1-2-12">
<p>
All the boilerplate code required to load the shared library
testlib.dll can be eliminated by crafting a python module file and
wrapper classes.
</p>

<p>
Source:
</p>
<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/testlib.py">file:src/dlls/example-windows1/testlib.py</a></li>
<li>Gist: <a href="https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71">Gisthub</a></li>
</ul>


<p>
<b>Module Initialization:</b>
</p>

<ul class="org-ul">
<li>File: testlib.py</li>
</ul>

<p>
The function _config initializes the wrapper module, loading the DLL -
share library testlib.dll into the current Python3 interpreter process
and setting up the C-functions (functions exported with C-linkage,
without name mangling) exported by the library.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> ctypes

<span class="org-comment-delimiter"># </span><span class="org-comment">Library handler </span>
<span class="org-variable-name">_lib</span> = ctypes.cdll.LoadLibrary(<span class="org-string">"testlib.dll"</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">Startup ctypes FFI - Foreign Function Interface </span>
<span class="org-keyword">def</span> <span class="org-function-name">_config</span>():
    <span class="org-keyword">print</span>(<span class="org-string">"Intializing library"</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">======= std::vector&lt;double&gt; and Linalg:: namespace ==========##</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">hVectorD testlib_vectorD_make0(size_t n, double x)</span>
    <span class="org-variable-name">_lib.testlib_vectorD_make0.argtypes</span> = [ctypes.c_int, ctypes.c_double]
    <span class="org-variable-name">_lib.testlib_vectorD_make0.restype</span>  = ctypes.c_void_p

    <span class="org-comment-delimiter"># </span><span class="org-comment">hVectorD testlib_vectorD_make1(size_t n, double array [])</span>
    <span class="org-variable-name">_lib.testlib_vectorD_make1.argtypes</span> = [ctypes.c_int, ctypes.POINTER(ctypes.c_double)]
    <span class="org-variable-name">_lib.testlib_vectorD_make1.restype</span>  = ctypes.c_void_p    

    <span class="org-comment-delimiter"># </span><span class="org-comment">void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv)</span>
    <span class="org-variable-name">_lib.testlib_vectorD_Linalg_printVector.argtypes</span> = [ctypes.POINTER(ctypes.c_char), ctypes.c_void_p ]
    <span class="org-variable-name">_lib.testlib_vectorD_Linalg_printVector.restype</span> = <span class="org-constant">None</span>
     ... ....    ... ....    ... ....    ... ....    ... ....    ... .... 

<span class="org-comment-delimiter"># </span><span class="org-comment">Initializae module.</span>
_config()
</pre>
</div>

<p>
The class VectorD is a wrapper class for the STL class
std::vector&lt;double&gt; and the namespace Linalg containing linear algebra
functions. 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">VectorD</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, handle):
        <span class="org-keyword">self</span>.hnd = ctypes.c_void_p(handle)
        <span class="org-keyword">self</span>.name = <span class="org-string">"std::vector&lt;double&gt; vx"</span>

    <span class="org-type">@classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">fromValue</span>(cls, size, x):
        <span class="org-keyword">return</span> VectorD(_lib.testlib_vectorD_make0(size, x))

    <span class="org-type">@classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">fromArray</span>(cls, array):
        <span class="org-variable-name">carray_size_n</span> = ctypes.c_double * <span class="org-builtin">len</span>(array)
        <span class="org-keyword">return</span> VectorD(_lib.testlib_vectorD_make1(<span class="org-builtin">len</span>(array), carray_size_n(*array)))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructor </span>
    <span class="org-keyword">def</span> <span class="org-function-name">__del__</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">print</span>(<span class="org-string">" [TRACE] - Vector disposed - C++ Destructor invoked Ok."</span>)
        _lib.testlib_vectorD_delete(<span class="org-keyword">self</span>.hnd)

    <span class="org-keyword">def</span> <span class="org-function-name">setName</span>(<span class="org-keyword">self</span>, name):
        <span class="org-keyword">self</span>.name = name

    <span class="org-comment-delimiter"># </span><span class="org-comment">Display vector </span>
    <span class="org-keyword">def</span> <span class="org-function-name">disp</span>(<span class="org-keyword">self</span>):
        _lib.testlib_vectorD_Linalg_printVector(<span class="org-keyword">self</span>.name.encode(<span class="org-string">'utf-8'</span>), <span class="org-keyword">self</span>.hnd)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Set element at nth position </span>
    <span class="org-keyword">def</span> <span class="org-function-name">set</span>(<span class="org-keyword">self</span>, idx, x):
        _lib.testlib_vectorD_set(<span class="org-keyword">self</span>.hnd, idx, x)

    <span class="org-keyword">def</span> <span class="org-function-name">norm</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> _lib.testlib_vectorD_Linalg_norm(<span class="org-keyword">self</span>.hnd)
</pre>
</div>

<p>
The class CPPInterfaceClass is a wrapper for the C++ interface class
InterfaceClass exported by the DLL. The python wrapper class contains
factory methods .factory, .makeA for loading the implementation class
ImplementationA and the method .makeB for loading the implementation
ImplementationB. 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Proxy for C++ Interface class in the shared library </span>
<span class="org-keyword">class</span> <span class="org-type">CPPInterfaceClass</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Constructor </span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, handle):
        <span class="org-keyword">self</span>.hnd = ctypes.c_void_p(handle)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructor </span>
    <span class="org-keyword">def</span> <span class="org-function-name">__del__</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Call C++ destructor</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">print(" [__del__] =&gt; self.hnd = " + str(self.hnd))</span>
        _lib.testlib_InterfaceClass_delete(<span class="org-keyword">self</span>.hnd)

    <span class="org-type">@classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">factory</span>(cls, classID):
        <span class="org-keyword">return</span> CPPInterfaceClass(_lib.teslib_InterfaceClass_factory(classID.encode(<span class="org-string">'utf-8'</span>)))

    <span class="org-type">@classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">makeA</span>(cls):              
        <span class="org-doc">"Instantiate the class ImplementationA from the DLL."</span>
        <span class="org-keyword">return</span> CPPInterfaceClass.factory(<span class="org-string">"ImplementationA"</span>)

    <span class="org-type">@classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">makeB</span>(cls):              
        <span class="org-doc">"Instantiate the class ImplementationB from the DLL."</span>
        <span class="org-keyword">return</span> CPPInterfaceClass.factory(<span class="org-string">"ImplementationB"</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">getType</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> ctypes.string_at(_lib.testlib_InterfaceClass_getID(<span class="org-keyword">self</span>.hnd)).decode(<span class="org-string">'utf-8'</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">getName</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> ctypes.string_at(_lib.testlib_InterfaceClass_getName(<span class="org-keyword">self</span>.hnd)).decode(<span class="org-string">'utf-8'</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">setName</span>(<span class="org-keyword">self</span>, name):
        _lib.testlib_InterfaceClass_setName(<span class="org-keyword">self</span>.hnd, name.encode(<span class="org-string">'utf-8'</span>))

    <span class="org-comment-delimiter"># </span><span class="org-comment">String representation </span>
    <span class="org-keyword">def</span> <span class="org-function-name">__str__</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">s</span>   = <span class="org-string">"CInterfaceClass ; type = "</span> + <span class="org-keyword">self</span>.getType()
        <span class="org-variable-name">s</span> +=  <span class="org-string">" - name =  "</span> + <span class="org-keyword">self</span>.getName() + <span class="org-string">"\n"</span>
        <span class="org-keyword">return</span> s

    <span class="org-comment-delimiter"># </span><span class="org-comment">Make class printable in the REPL</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__repr__</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.__str__()    
</pre>
</div>

<p>
Usage in Python3 REPL:
</p>

<ul class="org-ul">
<li>Import module</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">$ C:/Users/archbox/Miniconda3/pkgs/python-3.6.5-h0c2934d_0/python
Python 3.6.5 |Anaconda, Inc.| (default, Mar 29 2018, 13:32:41) [MSC v.1900 64 bit (AMD64)] on win32
Type <span class="org-string">"help"</span>, <span class="org-string">"copyright"</span>, <span class="org-string">"credits"</span> <span class="org-keyword">or</span> <span class="org-string">"license"</span> <span class="org-keyword">for</span> more information.
&gt;&gt;&gt;

&gt;&gt;&gt; <span class="org-keyword">from</span> testlib <span class="org-keyword">import</span> VectorD
 [StaticObject] =&gt; Initialize DLL
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the <span class="org-variable-name">process</span> =&gt; <span class="org-variable-name">PID</span> = 5776
<span class="org-function-name">testlib.cpp</span>:45: &lt;DllMain&gt; DLL attached to process.
Intializing library
Library initialized OK.

&gt;&gt;&gt; <span class="org-keyword">from</span> testlib <span class="org-keyword">import</span> CPPInterfaceClass
</pre>
</div>

<ul class="org-ul">
<li>Testing class VectorD - wrapper for std::vector&lt;double&gt;</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-variable-name">v1</span> = VectorD.fromValue(5, 3.0)
&gt;&gt;&gt; v1.disp()
<span class="org-function-name">std</span>::vector&lt;double&gt; <span class="org-variable-name">vx</span> = [5]( 3, 3, 3, 3, 3,  )

&gt;&gt;&gt; v1.setName(<span class="org-string">"v1"</span>)
&gt;&gt;&gt; v1.disp()
<span class="org-variable-name">v1</span> = [5]( 3, 3, 3, 3, 3,  )

&gt;&gt;&gt; v1.norm()
6.708203932499369

&gt;&gt;&gt; v1.<span class="org-builtin">set</span>(0, 5)
&gt;&gt;&gt; v1.<span class="org-builtin">set</span>(1, 4.5)
&gt;&gt;&gt; v1.<span class="org-builtin">set</span>(2, 9.8)
&gt;&gt;&gt; v1.<span class="org-builtin">set</span>(3, 18.4)

&gt;&gt;&gt; v1.disp()
<span class="org-variable-name">v1</span> = [5]( 5, 4.5, 9.8, 18.4, 3,  )
&gt;&gt;&gt;
&gt;&gt;&gt; v1.norm()
22.10995251012539

&gt;&gt;&gt; <span class="org-variable-name">v1</span> = 100
 [TRACE] - Vector disposed - C++ Destructor invoked Ok.

&gt;&gt;&gt; <span class="org-variable-name">v2</span> = VectorD.fromArray([4.0, 10.25, 9.6, 3, 10, 6, 15])
&gt;&gt;&gt; v2.disp()
<span class="org-function-name">std</span>::vector&lt;doubl&gt; <span class="org-variable-name">vx</span> = [7]( 4, 10.25, 9.6, 3, 10, 6, 15,  )

&gt;&gt;&gt; v2.norm()
24.15

&gt;&gt;&gt; v2.<span class="org-builtin">set</span>(0, 100)
&gt;&gt;&gt; v2.<span class="org-builtin">set</span>(1, 200)

&gt;&gt;&gt; v2.disp()
<span class="org-function-name">std</span>::vector&lt;double&gt; <span class="org-variable-name">vx</span> = [7]( 100, 200, 9.6, 3, 10, 6, 15,  )

&gt;&gt;&gt; v2.norm()
224.63784186997523
&gt;&gt;&gt;

</pre>
</div>

<ul class="org-ul">
<li>Testing class CPPInterfaceClass, proxy for C++ classes
InterfaceClass, ImplementationA and ImplementationB.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-keyword">from</span> testlib <span class="org-keyword">import</span> CPPInterfaceClass

<span class="org-comment-delimiter"># </span><span class="org-comment">======== Load ImplementationA  ============== # </span>
<span class="org-comment-delimiter">#</span>
&gt;&gt;&gt; <span class="org-variable-name">a</span> = CPPInterfaceClass.makeA()
&gt;&gt;&gt; a
CInterfaceClass ; <span class="org-builtin">type</span> = ImplementationA - <span class="org-variable-name">name</span> =  Unammed-A

&gt;&gt;&gt; a.getType()
<span class="org-string">'ImplementationA'</span>
&gt;&gt;&gt; a.getName()
<span class="org-string">'Unammed-A'</span>
&gt;&gt;&gt; a.setName(<span class="org-string">"Instance-of-ImplA"</span>)
&gt;&gt;&gt; a
CInterfaceClass ; <span class="org-builtin">type</span> = ImplementationA - <span class="org-variable-name">name</span> =  Instance-of-ImplA

<span class="org-comment-delimiter"># </span><span class="org-comment">======== Load ImplementationB  ============== # </span>
<span class="org-comment-delimiter">#</span>
&gt;&gt;&gt; <span class="org-variable-name">b</span> = CPPInterfaceClass.makeB()
&gt;&gt;&gt; b
CInterfaceClass ; <span class="org-builtin">type</span> = ImplementationB - <span class="org-variable-name">name</span> =  Unammed-B

&gt;&gt;&gt; b.setName(<span class="org-string">"Instance-of-class-B"</span>)
&gt;&gt;&gt; b.getName()
<span class="org-string">'Instance-of-class-B'</span>
&gt;&gt;&gt;
&gt;&gt;&gt; b.getType()
<span class="org-string">'ImplementationB'</span>

</pre>
</div>

<ul class="org-ul">
<li>Exit REPL.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-constant">exit</span>()
 [TRACE] - Vector disposed - C++ Destructor invoked Ok.
 [INFO] ImplementationB <span class="org-variable-name">deleted</span> =&gt; <span class="org-variable-name">name</span> = Instance-of-<span class="org-keyword">class</span>-B ; <span class="org-builtin">type</span> = ImplementationB
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the <span class="org-variable-name">process</span> =&gt; <span class="org-variable-name">PID</span> = 5776
<span class="org-function-name">testlib.cpp</span>:49: &lt;DllMain&gt; =&gt; DLL attached
 [StaticObject] =&gt; Shutdown DLL
</pre>
</div>
</div>
</div>
<div id="outline-container-org6cd2749" class="outline-4">
<h4 id="org6cd2749"><span class="section-number-4">1.2.13</span> View symbols exported by the DLL</h4>
<div class="outline-text-4" id="text-1-2-13">
<p>
<b>Location of dumpbin tool</b>
</p>

<p>
The symbols exported by the DLL can viewed with the dumpbin tool
available from the MSVC developer console.
</p>

<div class="org-src-container">
<pre class="src src-sh">$ where dumpbin.exe
<span class="org-function-name">C</span>:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.12.25827\bin\Hostx64\x64\dumpbin.exe
</pre>
</div>

<p>
<b>Show DLL exported symbols</b>
</p>

<div class="org-src-container">
<pre class="src src-sh">$ dumpbin.exe /exports testlib.dll 
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-txt">Microsoft (R) COFF/PE Dumper Version 14.12.25835.0
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file testlib.dll

File Type: DLL

  Section contains the following exports for testlib.dll

    00000000 characteristics
    FFFFFFFF time date stamp
        0.00 version
           1 ordinal base
          31 number of functions
          31 number of names

    ordinal hint RVA      name

          1    0 00005C50 ??0SampleClass@@QEAA@AEBV0@@Z
          2    1 00001650 ??0SampleClass@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
          3    2 000015E0 ??0SampleClass@@QEAA@XZ
          4    3 000016E0 ??1SampleClass@@QEAA@XZ
          5    4 00007280 ??4SampleClass@@QEAAAEAV0@AEBV0@@Z
          6    5 00001880 ?get@SampleClass@@QEAAHXZ
          7    6 00001830 ?getName@SampleClass@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
          8    7 00001370 ?linTransform@Linalg@@YA?AV?$vector@NV?$allocator@N@std@@@std@@NNAEAV23@@Z
          9    8 000012D0 ?norm@Linalg@@YANAEBV?$vector@NV?$allocator@N@std@@@std@@@Z
         10    9 00001480 ?printVector@Linalg@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEAV?$vector@NV?$allocator@N@std@@@3@@Z
         11    A 000018A0 ?set@SampleClass@@QEAAXH@Z
         12    B 00001D50 DllMain
         13    C 00002720 entryPoint1
         14    D 00002800 main
         15    E 00001B10 teslib_InterfaceClass_factory
         16    F 00001C60 testlib_InterfaceClass_delete
         17   10 00001CC0 testlib_InterfaceClass_getID
         18   11 00001D20 testlib_InterfaceClass_getName
         19   12 00001CF0 testlib_InterfaceClass_setName
         20   13 00001A10 testlib_SampleClass_delete
         21   14 00001A60 testlib_SampleClass_get
         22   15 00001AB0 testlib_SampleClass_getName
         23   16 00001900 testlib_SampleClass_make0
         24   17 00001950 testlib_SampleClass_make1
         25   18 00001A80 testlib_SampleClass_set
         26   19 00001560 testlib_vectorD_Linalg_norm
         27   1A 00001580 testlib_vectorD_Linalg_printVector
         28   1B 000026D0 testlib_vectorD_delete
         29   1C 00002590 testlib_vectorD_make0
         30   1D 00002610 testlib_vectorD_make1
         31   1E 00002690 testlib_vectorD_set

  Summary

        3000 .data
        4000 .pdata
       18000 .rdata
        1000 .reloc
       2F000 .text
</pre>
</div>

<p>
Note that: 
</p>

<ul class="org-ul">
<li>Functions with C-linkage are not mangled, their symbols match
their names, for instance:</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"> 15    E 00001B10 teslib_InterfaceClass_factory
16    F 00001C60 testlib_InterfaceClass_delete
17   10 00001CC0 testlib_InterfaceClass_getID
18   11 00001D20 testlib_InterfaceClass_getName
19   12 00001CF0 testlib_InterfaceClass_setName
20   13 00001A10 testlib_SampleClass_delete
21   14 00001A60 testlib_SampleClass_get
22   15 00001AB0 testlib_SampleClass_getName
</pre>
</div>

<ul class="org-ul">
<li>Functions, member functions, namespaces and everything without
C-linkage are mangled, the compiler generate an unique name for the
generated symbols:</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"> 1    0 00005C50 ??0SampleClass@@QEAA@AEBV0@@Z
 2    1 00001650 ??0SampleClass@@QEAA@AEBV?$<span class="org-variable-name">basic_string</span>@DU?$<span class="org-variable-name">char_traits</span>@D@std@@V?$<span class="org-variable-name">allocator</span>@D@2@@std@@@Z
 3    2 000015E0 ??0SampleClass@@QEAA@XZ
 4    3 000016E0 ??1SampleClass@@QEAA@XZ
 5    4 00007280 ??4SampleClass@@QEAAAEAV0@AEBV0@@Z
 6    5 00001880 ?get@SampleClass@@QEAAHXZ
 7    6 00001830 ?getName@SampleClass@@QEBA?AV?$<span class="org-variable-name">basic_string</span>@DU?$<span class="org-variable-name">char_traits</span>@D@std@@V?$<span class="org-variable-name">allocator</span>@D@2@@std@@XZ
 8    7 00001370 ?linTransform@Linalg@@YA?AV?$<span class="org-variable-name">vector</span>@NV?$<span class="org-variable-name">allocator</span>@N@std@@@std@@NNAEAV23@@Z
 9    8 000012D0 ?norm@Linalg@@YANAEBV?$<span class="org-variable-name">vector</span>@NV?$<span class="org-variable-name">allocator</span>@N@std@@@std@@@Z
10    9 00001480 ?printVector@Linalg@@YAAEAV?$<span class="org-variable-name">basic_ostream</span>@DU?$<span class="org-variable-name">char_traits</span>@D@std@@@std@@AEAV23@AEAV?$<span class="org-variable-name">vector</span>@NV?$<span class="org-variable-name">allocator</span>@N@std@@@3@@Z
11    A 000018A0 ?set@SampleClass@@QEAAXH@Z
</pre>
</div>

<p>
It is possible to demangle those symbols with the tool - <a href="https://demangler.com/">https://demangler.com/</a>
</p>

<ul class="org-ul">
<li>Symbol: ??0SampleClass@@QEAA@AEBV0@@Z demangled:</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-function-name">public</span>: __cdecl SampleClass::SampleClass(class SampleClass const &amp; __ptr64) __ptr64
</pre>
</div>

<ul class="org-ul">
<li>Symbol: ?get@SampleClass@@QEAAHXZ demangled:</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-function-name">public</span>: int __cdecl SampleClass::get(void) __ptr64
</pre>
</div>

<ul class="org-ul">
<li>Symbol: ?linTransform@Linalg@@YA?AV?$vector@NV?$allocator@N@std@@@std@@NNAEAV23@@Z demangled:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>,<span class="org-keyword">class</span> <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">__cdecl</span> <span class="org-constant">Linalg</span>::<span class="org-function-name">linTransform</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span>,<span class="org-type">double</span>,<span class="org-keyword">class</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>,<span class="org-keyword">class</span> <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp; <span class="org-variable-name">__ptr64</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9c2d63f" class="outline-3">
<h3 id="org9c2d63f"><span class="section-number-3">1.3</span> <span class="todo TODO">TODO</span> Shared Libraries on Linux</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2018-12-17 Mon 22:28</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
