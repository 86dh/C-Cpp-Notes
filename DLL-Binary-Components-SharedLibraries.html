<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-03-05 Tue 01:20 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shared Libraries - Binary Components</title>
<meta name="generator" content="Org mode" />
<meta name="description" content="cpp c++ code examples, demonstrations, design pattern and integration."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<link href="theme/org-nav-theme.css" rel="stylesheet">
<script src="theme/org-nav-theme.js"></script>
<link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Shared Libraries - Binary Components</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7b2eead">1. Shared Libraries - Binary Components</a>
<ul>
<li><a href="#org2a30cd6">1.1. Overview</a></li>
<li><a href="#org6999924">1.2. Design Guidelines for C-Interfaces</a></li>
<li><a href="#org438dcca">1.3. Cross platform Shared Library, C-Interfaces and Language Interoperability</a>
<ul>
<li><a href="#orga159901">1.3.1. Overview</a></li>
<li><a href="#orgb3ebef9">1.3.2. Header macros</a></li>
<li><a href="#org265375c">1.3.3. Namespace Linalg</a></li>
<li><a href="#org47796d7">1.3.4. C-interface of Namespace Linalg</a></li>
<li><a href="#org2225627">1.3.5. Non-polymorphic Class - SampleClass</a></li>
<li><a href="#org631db84">1.3.6. C-interface for SampleClass</a></li>
<li><a href="#orga7f81ad">1.3.7. Polymorphic class InterfaceClass</a></li>
<li><a href="#org8322649">1.3.8. DLL startup function DLLMain</a></li>
<li><a href="#org0ec782a">1.3.9. DLL entry point for run32dll.exe</a></li>
<li><a href="#org902a738">1.3.10. C++ Client program - client1.cpp</a></li>
<li><a href="#org555f1b9">1.3.11. Load DLL in Python3 REPL</a></li>
<li><a href="#org772e24a">1.3.12. Python 3 Client Code - Wrapper Module</a></li>
<li><a href="#orgda1a9da">1.3.13. CSharp Client Code - PInvoke</a></li>
<li><a href="#org4030acf">1.3.14. View symbols exported by the shared library</a></li>
</ul>
</li>
<li><a href="#org3f50548">1.4. Return string from a C++ function to Python Ctypes</a></li>
<li><a href="#org46dce88">1.5. Python native module (shared library)</a>
<ul>
<li><a href="#org87a489b">1.5.1. Overview</a></li>
<li><a href="#org56a9b6e">1.5.2. Module Code</a></li>
<li><a href="#org18e4d25">1.5.3. Loading the native module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<ul class="org-ul">
<li><a href='index.html'>Index</a></li>
</ul>

<div id="outline-container-org7b2eead" class="outline-2">
<h2 id="org7b2eead"><span class="section-number-2">1</span> Shared Libraries - Binary Components</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org2a30cd6" class="outline-3">
<h3 id="org2a30cd6"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Shared libraries are compiled object-code exporting functions, data
structures and classes which can be used by many different
programs. They provide many benefits such as: faster compilation time;
less disk space usage since each program using the library do not
need a copy of the library source code or its compiled-code; ability
to update the library and provide security fixes to client
applications without recompilation, just by replacing the library
file. 
</p>

<p>
On Windows, shared libraries are called DLLs which stands for Dynamic
Linked Libraries, on Unix-like operating systems such as Linux, BSD
and MacOSX, they are called SO - shared objects or DSO - dynamic
shared objects. 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Comparison of shared libraries across different operating systems</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Operating</th>
<th scope="col" class="org-left">Long Name</th>
<th scope="col" class="org-left">Short name</th>
<th scope="col" class="org-left">File</th>
<th scope="col" class="org-left">Binary Format</th>
</tr>

<tr>
<th scope="col" class="org-left">System</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Extension</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Windows</td>
<td class="org-left">Dynamic Linked Library</td>
<td class="org-left">DLL</td>
<td class="org-left">.dll</td>
<td class="org-left">PE32/PE64 - Portable Executable</td>
</tr>

<tr>
<td class="org-left">Linux</td>
<td class="org-left">(Dynamic) Shared Object</td>
<td class="org-left">DSO or SO</td>
<td class="org-left">.so</td>
<td class="org-left">ELF or ELF64 (for 64 bits processors)</td>
</tr>

<tr>
<td class="org-left">BSD</td>
<td class="org-left">(Dynamic) Shared Object</td>
<td class="org-left">DSO or SO</td>
<td class="org-left">.so</td>
<td class="org-left">ELF or ELF64</td>
</tr>

<tr>
<td class="org-left">MacOSX</td>
<td class="org-left">-</td>
<td class="org-left">dylib</td>
<td class="org-left">.dylib or .so</td>
<td class="org-left">MachO</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Shared libraries are similar to executables, however they do not
have the main() function entry point.</li>
</ul>

<p>
In addition to C and C++, shared libraries, containing functions with
C-linkage, can also be used as binary components (libraries) and be
consumed from higher level programming languages such as Python, Ruby,
Java or C# through some foreign-function interface. In Python
C-functions can be imported from shared libraries using the <a href="https://docs.python.org/3/library/ctypes.html">cytpes</a>
library; in C# C-functions can be consumed using the P-invoke API and
in Java it is possible to use C-functions from shared libraries using
the JNI (Java Native Interface) or JNA, which is easier to use.
</p>


<p>
Note: 
</p>
<ul class="org-ul">
<li>Shared libraries are specific to a particular operating system and
are not part of C++ standard.</li>
</ul>

<p>
Use Cases and advantages: 
</p>

<ul class="org-ul">
<li>Multiple programs can reuse the same library reducing disk space.</li>

<li>Faster compilation once the shared library is compiled.</li>

<li>Changes in the library such as security fixes, updates and new
features may not require client programs recompilation if the ABI is
not broken.</li>

<li><span class="underline">Better for security updates</span>. For instance, if a program is
statically compiled with open-ssl library, a program
recompilation would be required to update the library to a new
version with security fixes for some vulnerability. It could even
be a greater security problem and waste of space, if all
application depending on open-ssl were statically liked with this
library. If a program uses the open-sll shared library, the library
can be updated just by replacing a file and the program it will not
need to be recompiled as long as there are no ABI breaking changes.</li>

<li><span class="underline">Plugin system</span> =&gt; The main program can contain an interface class
called IInterface and load its implementations from shared
libraries plugins. The implementation classes provided by the
plugins or shared library files allow the program to be updated and
extended at runtime without recompilation.</li>

<li><span class="underline">Cross language interoperability</span> =&gt; Functions using C-linkage can be
called from any high level programming language with foreign
function interface such as Python with ctypes library. C++
functions and classes cannot be called due to name mangling and
compiler ABI issues. The workaround to this problem is to create a
C-interface or functions with C-linkage for classes, functions and
namespaces. Instances of a class can be passed around as opaque
pointers (void*).</li>
</ul>

<p>
Problems: 
</p>

<ul class="org-ul">
<li>Due to C++ lack of standard <span class="underline">ABI Application Binary Interface</span>,
classes, STL containers, functions without C-linkage and namespaces
may not be reusable with a client program compiled with different
compiler than used to build the library. However, even in this
case, there is still the benefit of faster compilation time if the
shared library and the client application are part of the same
project.
<ul class="org-ul">
<li>TL;DR =&gt; Classes, STL and functions without C-linkage of shared
library cannot be used with a different compiler than the one
used to build the DLL.</li>
</ul></li>

<li>Cross-compiling interoperability - The only way to ensure that a
shared library can work with all compilers is by using a functions
with C-linkage (functions with extern "C") annotation and creating
C-linkage functions wrappers to classes, STL containers and
classes.</li>

<li>Classes can be made compatible among different compilers by using
an interface class, a class with only pure virtual member
functions, using only compatible types in the methods signature or
declaration, therefore it cannot use STL container types such as
std::string or std::vector. However, each implementation of an
interface class can use STL containers internally.</li>
</ul>


<p>
<b>MSDN Documentation</b>
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/cpp/build/exporting-cpp-functions-for-use-in-c-language-executables?view=vs-2017">Exporting C++ Functions for Use in C-Language Executables</a></li>

<li><a href="https://docs.microsoft.com/en-us/cpp/build/exporting-c-functions-for-use-in-c-or-cpp-language-executables?view=vs-2017">Exporting C Functions for Use in C or C++ Language Executables</a></li>
</ul>


<p>
<b>Further Reading</b>
</p>

<ul class="org-ul">
<li><a href="http://moppi.inside.org/demopaja/sdk_help/dll_functions.html">Creating the DLL functions</a></li>

<li><a href="https://www.codeproject.com/Articles/28969//Articles/28969/HowTo-Export-C-classes-from-a-DLL">HowTo: Export C++ classes from a DLL - CodeProject</a></li>

<li><a href="http://gernotklingler.com/blog/creating-using-shared-libraries-different-compilers-different-operating-systems/">Creating and using shared libraries with different compilers on different operating systems - Gernot.Klingler</a></li>

<li><a href="http://bigbang.waterlin.org/bang/using-python-ctypes-to-link-cpp-library/">The Big Bang on Reading Busy » Blog Archive » Using Python ctypes to link C/C++ library</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6999924" class="outline-3">
<h3 id="org6999924"><span class="section-number-3">1.2</span> Design Guidelines for C-Interfaces</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<b>Macro for C-linkage and exporting symbols</b>
</p>

<p>
Instead of: 
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Non portable C-linkage due to compiler-specifc extension.</label><pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Does not work on Unix-like OSes. </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Only works on compilers with supporting this MSVC (Visual VC++) compiler-extension. </span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>  
<span class="org-type">double</span> <span class="org-function-name">SomeFunctionWithCLinkage</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  ... function code ... 
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Better export the symbol using a macro for ensuring cross-platform
portability:  
</p>

<ul class="org-ul">
<li>Note: Names of macros should be unique in order to avoid name
collisions. This is why the macros are prefixed with library
name.</li>
<li>Note: <code>__declspec(dllexport)</code> =&gt; MSVC (Visual C++) compiler
extension only supported on MSVC and Mingw. (No in C++ ISO standard)</li>
<li>Note: <code>__attribute__ ((visibility ("default")))</code> =&gt; GCC/Clang
compiler extension used on Unix-like Oses for making symbols
hidden by default.</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>Macros for defining C-linkage and exporting symbols in a cross-platform way.</label><pre class="src src-cpp"><span class="org-preprocessor">#if</span> <span class="org-preprocessor">defined</span><span class="org-rainbow-delimiters-depth-1">(</span>__cplusplus<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Code being compiled with C++ compiler </span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">MATHTOOLS_EXTERN_C</span> <span class="org-keyword">extern</span> <span class="org-string">"C"</span>
<span class="org-preprocessor">#else</span> 
  <span class="org-comment-delimiter">// </span><span class="org-comment">Code being compiled with C compiler (Not C++ compiler)</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">MATHTOOLS_EXTERN_C</span> 
<span class="org-preprocessor">#endif</span> 

<span class="org-preprocessor">#if</span> <span class="org-preprocessor">defined</span><span class="org-rainbow-delimiters-depth-1">(</span>_WIN32<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">MS Windows DLLs (*.dll)</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">MATHTOOLS_EXPORT_C</span> MATHTOOLS_EXTERN_C <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">#else</span> 
  <span class="org-comment-delimiter">// </span><span class="org-comment">Unix-like Shared Object (.so) operating systems and GCC.</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">MATHTOOLS_EXPORT_C</span> MATHTOOLS_EXTERN_C <span class="org-keyword">__attribute__</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>visibility <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"default"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">#endif</span> 
</pre>
</div>

<p>
So, the function code becomes: 
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>Function with C-linkage exported with cross-platform portability.</label><pre class="src src-cpp">MATHTOOLS_EXPORT_C
<span class="org-type">double</span> <span class="org-function-name">SomeFunctionWithCLinkage</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  ... function code ... 
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Name Prefix</b>
</p>

<p>
Functions with C-linkage are always in the global namespace, therefore
every function needs an unique name in order to avoid name clashing
which can result in undefined behavior. A good practice to avoid those name
collisions is to use a common prefix before in the name of every
function, for instance: 
</p>

<p>
Instead of:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>Name schema prone to name clashes and undefined behavior.</label><pre class="src src-cpp"><span class="org-type">MATHTOOLS_EXPORT_C</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* GetVersion<span class="org-rainbow-delimiters-depth-1">()</span>;
<span class="org-type">MATHTOOLS_EXPORT_C</span> <span class="org-type">double</span> <span class="org-function-name">RootSolver</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x0</span>, <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>* <span class="org-variable-name">function</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Or in multi-line style:</span>
<span class="org-type">MATHTOOLS_EXPORT_C</span> 
<span class="org-keyword">const</span> <span class="org-type">char</span>* GetVersion<span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-type">MATHTOOLS_EXPORT_C</span> 
<span class="org-type">double</span> <span class="org-function-name">RootSolver</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x0</span>, <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>* <span class="org-variable-name">function</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Better: 
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>Better name schema prefixed by library name.</label><pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">All functions contains the library name as a prefix in order to avoid </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">name clashes.</span>
<span class="org-type">MATHTOOLS_EXPORT_C</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* mathtools_GetVersion<span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-type">MATHTOOLS_EXPORT_C</span> 
<span class="org-type">double</span> <span class="org-function-name">mathtools_RootSolver</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x0</span>, <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>* <span class="org-variable-name">function</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Naming Schema for C-wrapers or C-interfaces for C++ classes</b> 
</p>

<p>
Sample class: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Plotter</span><span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">struct</span> <span class="org-type">impl</span>; 
  <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">impl</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">m_pimpl</span>;    
<span class="org-function-name">public</span>: 
  <span class="org-function-name">Plotter</span><span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-function-name">Plotter</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">width</span>, <span class="org-type">double</span> <span class="org-variable-name">height</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-function-name">Plotter</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Plotter</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">default</span>;
 ~<span class="org-function-name">Plotter</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;

 <span class="org-type">void</span> <span class="org-function-name">addPoint</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">)</span>;
 <span class="org-type">void</span> <span class="org-function-name">clear</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
C-wrappers schema: 
</p>

<ul class="org-ul">
<li>C-interface for default constructor</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>C-interface for class default constructor.</label><pre class="src src-cpp">MATHTOOLS_EXPORT_C
<span class="org-type">Plotter</span>* <span class="org-function-name">mathtools_Plotter_new</span><span class="org-rainbow-delimiters-depth-1">()</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-type">Plotter</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<ul class="org-ul">
<li>C-interface or C-Wrapepr for second constructor:</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>C-interface for class overload constructor.</label><pre class="src src-cpp">MATHTOOLS_EXPORT_C
<span class="org-type">Plotter</span>* <span class="org-function-name">mathtools_Plotter_new2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">width</span>, <span class="org-type">double</span> <span class="org-variable-name">height</span><span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-type">Plotter</span><span class="org-rainbow-delimiters-depth-2">(</span>width, height<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>C-interface for copy constructor:</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>C-interface for class copy constructor.</label><pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Wrapper for copy constructor </span>
MATHTOOLS_EXPORT_C
<span class="org-type">Plotter</span>* <span class="org-function-name">mathtools_Plotter_new_copy</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Plotter</span>* <span class="org-variable-name">hPlotter</span><span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-type">Plotter</span><span class="org-rainbow-delimiters-depth-2">(</span>*hPlotter<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>C-interface for destructor:</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span>C-interface for class destructor.</label><pre class="src src-cpp">MATHTOOLS_EXPORT_C
<span class="org-type">void</span> <span class="org-function-name">mathtools_Plotter_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Plotter</span>* <span class="org-variable-name">hPlotter</span><span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">delete</span> hPlotter;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>C-interface for class method.
<ul class="org-ul">
<li>As C-interfaces cannot throw exceptions, the last parameter is
used for returning an error code.</li>
</ul></li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span>C-interface for class ordinary method.</label><pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Schema: &lt;Library Name&gt;_&lt;Class Name&gt;_&lt;method&gt;</span>
MATHTOOLS_EXPORT_C
<span class="org-type">void</span> <span class="org-function-name">mathtools_Plotter_addPoint</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Plotter</span>* <span class="org-variable-name">hPlotter</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   hPlotter-&gt;addPoint<span class="org-rainbow-delimiters-depth-2">(</span>x, y<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Exceptions and Error Handling</b> 
</p>

<ul class="org-ul">
<li>DO NOT: Throw exceptions in functions with C-linkage (extern "C")
as exceptions are incompatibles among different compilers. Moreover, the
C-language cannot handle exceptions.</li>

<li>DO: Instead of exceptions, return an error code enumeration as a
function return value or as function parameter.</li>
</ul>

<p>
Example: If a function throws exceptions such as the function
<code>mathtools_Plotter_addPoint</code>, the exceptions should be caught and the
function should return an error code eihter as return value or
function parameter.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span>Error handling for C-interface functions or C-APIs</label><pre class="src src-cpp">MATHTOOLS_EXPORT_C
<span class="org-type">void</span> <span class="org-function-name">mathtools_Plotter_addPoint</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Plotter</span>* <span class="org-variable-name">hPlotter</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span>, <span class="org-type">int</span>* <span class="org-variable-name">ErrorCode</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    *ErrorCode = <span class="org-constant">ErrorEnum</span>::OK;
    <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
       <span class="org-comment-delimiter">// </span><span class="org-comment">Method addPoint throws exceptions </span>
       hPlotter-&gt;addPoint<span class="org-rainbow-delimiters-depth-3">(</span>x, y<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Exception1</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">){</span>
       *ErrorCode = <span class="org-constant">ErrorEnum</span>::NO_SPACE_ERROR; <span class="org-comment-delimiter">// </span><span class="org-comment">Set with value of some enum </span>
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Exception2</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">){</span>
       *ErrorCode = <span class="org-constant">ErrorEnum</span>::SOME_ERROR_ENUM;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Passing std::string STL Object across a DLL boundary</b>
</p>

<p>
Type synonym:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">h prefix stands for handle </span>
<span class="org-keyword">using</span> <span class="org-type">hString</span> = <span class="org-constant">std</span>::string*;
</pre>
</div>

<p>
C-interface for std::string default constructor.
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C  
<span class="org-type">hString</span> <span class="org-function-name">libprefix_string_new</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">std::nothrow =&gt; Do not throw std::bad_alloc, just return </span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">a null pointer on failure.</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">()</span>;   
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
C-interface for std::string copy-constructor. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C  
<span class="org-type">hString</span> <span class="org-function-name">libprefix_string_new_copy</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hString</span> <span class="org-variable-name">hstr</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">std::nothrow =&gt; Do not throw std::bad_alloc, just return </span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">a null pointer on failure.</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">(</span>*hstr<span class="org-rainbow-delimiters-depth-2">)</span>;   
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
C-interface for std::string overloaded constructor.
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C  
<span class="org-type">hString</span> <span class="org-function-name">libprefix_string_new2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;   
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
C-interface for std::string destructor.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Style 1: </span>
LIBRARY_EXPORT_C 
<span class="org-type">hString</span> <span class="org-function-name">libprefix_string_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hString</span> <span class="org-variable-name">hstr</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">delete</span> hstr;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Style 2: </span>
LIBRARY_EXPORT_C <span class="org-type">hString</span> 
<span class="org-function-name">libprefix_string_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hString</span> <span class="org-variable-name">hstr</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">delete</span> hstr;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Style 3: </span>
LIBRARY_EXPORT_C 
<span class="org-type">hString</span> 
<span class="org-function-name">libprefix_string_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hString</span> <span class="org-variable-name">hstr</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">delete</span> hstr;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Style 4: Trailing return-type.</span>
LIBRARY_EXPORT_C 
<span class="org-keyword">auto</span> libprefix_string_delete<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hString</span> <span class="org-variable-name">hstr</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">hString</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">delete</span> hstr;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
C-interface for std::string getter, returns const char*.
</p>


<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">LIBRARY_EXPORT_C</span> 
<span class="org-keyword">const</span> <span class="org-type">char</span>*
libprefix_string_get<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hString</span> <span class="org-variable-name">hstr</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">return</span> hstr-&gt;data<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
C-interface for std::string setter.
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C 
<span class="org-type">void</span> 
<span class="org-function-name">libprefix_string_set</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hString</span> <span class="org-variable-name">hstr</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   *hstr = text; 
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
C-interface for std::string concat.
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C 
<span class="org-type">void</span> 
<span class="org-function-name">libprefix_string_conat</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hString</span> <span class="org-variable-name">hstr</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">text</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   *hstr = *hstr + text; 
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
C-function to print std::string object 
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C 
<span class="org-type">void</span> 
<span class="org-function-name">libprefix_string_print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hString</span> <span class="org-variable-name">hstr</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; *hstr &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
C-wrapper to method std::string::clear()
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C 
<span class="org-type">void</span> 
<span class="org-function-name">libprefix_string_clear</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hString</span> <span class="org-variable-name">hstr</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   hstr-&gt;clear<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Passing std::vector&lt;double&gt; across a DLL boundary</b>
</p>

<p>
Handle type: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">hVectorD</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>*;
</pre>
</div>

<p>
Constructors: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C 
<span class="org-type">hVectorD</span> <span class="org-function-name">libprefix_vectorD_new</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

LIBRARY_EXPORT_C 
<span class="org-type">hVectorD</span> <span class="org-function-name">libprefix_vectorD_new2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>n, x<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

LIBRARY_EXPORT_C 
<span class="org-type">hVectorD</span> <span class="org-function-name">libprefix_vectorD_new3</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">[]</span> array<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Iterator-range constructor </span>
  <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>array, array + n<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Destructor: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C 
<span class="org-type">void</span> <span class="org-function-name">libprefix_vectorD_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hvec</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">delete</span> hvec;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Get size: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C 
<span class="org-type">size_t</span> <span class="org-function-name">libprefix_vectorD_size</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hvec</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  hvec-&gt;size<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Getter: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C 
<span class="org-type">double</span> <span class="org-function-name">libprefix_vectorD_get</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hvec</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> hvec-&gt;<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-2">[](</span>n<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Setter: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">LIBRARY_EXPORT_C 
<span class="org-type">void</span> <span class="org-function-name">libprefix_vectorD_set</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hvec</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  hvec-&gt;<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-2">[](</span>n<span class="org-rainbow-delimiters-depth-2">)</span> = x;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Element-wise fundamental math function 'sin()': 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Returns a new vector Out[i],  Out[i] = sin(Input[i]), i = 0, 1, 2... Input.size() </span>
LIBRARY_EXPORT_C 
<span class="org-type">hVector</span> <span class="org-function-name">libprefix_vectorD_sin</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hvec</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>hvec-&gt;size<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt;= hvec-&gt;size<span class="org-rainbow-delimiters-depth-3">()</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
     <span class="org-rainbow-delimiters-depth-2">(</span>*result<span class="org-rainbow-delimiters-depth-2">)[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-constant">std</span>::sin<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>*hvec<span class="org-rainbow-delimiters-depth-3">)[</span>i<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">return</span> result;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Returns a new vector Out[i],  Out[i] = exp(Input[i]), i = 0, 1, 2... Input.size() </span>
LIBRARY_EXPORT_C 
<span class="org-type">hVector</span> <span class="org-function-name">libprefix_vectorD_exp</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hvec</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span>hvec-&gt;size<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt;= hvec-&gt;size<span class="org-rainbow-delimiters-depth-3">()</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
     <span class="org-rainbow-delimiters-depth-2">(</span>*result<span class="org-rainbow-delimiters-depth-2">)[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-constant">std</span>::exp<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>*hvec<span class="org-rainbow-delimiters-depth-3">)[</span>i<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">return</span> result;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Higher order C-function to apply a function to each element: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Returns a new vector Out[i],  Out[i] = exp(Input[i]), i = 0, 1, 2... Input.size() </span>
LIBRARY_EXPORT_C 
<span class="org-type">hVector</span> 
<span class="org-function-name">libprefix_vectorD_map</span><span class="org-rainbow-delimiters-depth-1">(</span> 
             <span class="org-type">hVectorD</span> <span class="org-variable-name">hvec</span>              <span class="org-comment-delimiter">/* </span><span class="org-comment">Vector handle */</span>
            ,<span class="org-type">double</span> <span class="org-function-name">Function</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">Function pointer to math function */</span>                                      
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">auto</span> <span class="org-variable-name">result</span> = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>hvec-&gt;size<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt;= hvec-&gt;size<span class="org-rainbow-delimiters-depth-3">()</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
     <span class="org-rainbow-delimiters-depth-2">(</span>*result<span class="org-rainbow-delimiters-depth-2">)[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> = Function<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>*hvec<span class="org-rainbow-delimiters-depth-3">)[</span>i<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">return</span> result;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<p>
<b>See also:</b>
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/22797418/how-do-i-safely-pass-objects-especially-stl-objects-to-and-from-a-dll">c++ - How do I safely pass objects, especially STL objects, to and from a DLL? - Stack Overflow</a></li>
</ul>
</div>
</div>

<div id="outline-container-org438dcca" class="outline-3">
<h3 id="org438dcca"><span class="section-number-3">1.3</span> Cross platform Shared Library, C-Interfaces and Language Interoperability</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-orga159901" class="outline-4">
<h4 id="orga159901"><span class="section-number-4">1.3.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
<b>Source:</b>
</p>

<p>
Shared library Source Code
</p>

<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/testlib.cpp">file:src/dlls/example-windows1/testlib.cpp</a></li>
<li>File: <a href="src/dlls/example-windows1/testlib.hpp">file:src/dlls/example-windows1/testlib.hpp</a></li>
</ul>

<p>
Sample Client C++ Program:
</p>

<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/client1.cpp">file:src/dlls/example-windows1/client1.cpp</a></li>
</ul>

<p>
Sample Python 3 Client code: (Python3 module wrapper library)
</p>

<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/testlib.py">file:src/dlls/example-windows1/testlib.py</a></li>
</ul>

<p>
GIST - Better for online view: 
</p>

<ul class="org-ul">
<li><a href="https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71">Gisthub</a></li>
</ul>

<p>
<b>Compile the DLL libtest.dll and client program with MSVC</b> 
</p>

<p>
Shared Library 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ cl.exe testlib.cpp /EHsc /LD /nologo user32.lib
</pre>
</div>

<p>
C++ Client program (client code)
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ cl.exe /EHsc client1.cpp /Fe:client1.exe testlib.lib &amp;&amp; out.exe
</pre>
</div>

<p>
<b>Compile the DLL libtest.dll and client program with Mingw/GCC</b> 
</p>

<p>
Shared Library 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ testlib.cpp -o <span class="org-keyword">testlib.dll</span> -g -fvisibility=hidden -shared -std=c++14 -Wall
</pre>
</div>

<p>
C++ Client program 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ client.cpp -o <span class="org-keyword">client.exe</span> -g -std=c++14 testlib.dll -Wall
</pre>
</div>

<p>
<b>Compile and run from GIST</b> 
</p>

<p>
Clone the GIST (<a href="https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71">Gisthub</a>).
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Clone GIST: </span>
$ git clone https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71 dllex1
Cloning into <span class="org-string">'dllex1'</span>...
<span class="org-function-name">remote</span>: Enumerating objects: 66, done.
<span class="org-function-name">remote</span>: Counting objects: 100% (66/66), done.
<span class="org-function-name">remote</span>: Compressing objects: 100% (47/47), done.
<span class="org-function-name">remote</span>: Total 66 (delta 36), reused 45 (delta 19), pack-reused 0
Unpacking objects: 100% (66/66), done.

<span class="org-comment-delimiter"># </span><span class="org-comment">Enter directory containing sources</span>
$ cd dllex1/

$ tree .
<span class="org-builtin">.</span>
&#9500;&#9472;&#9472; build.bat
&#9500;&#9472;&#9472; client1.cpp
&#9500;&#9472;&#9472; CMakeLists.txt
&#9500;&#9472;&#9472; Makefile
&#9500;&#9472;&#9472; pywrapper.py
&#9500;&#9472;&#9472; testlib.cpp
&#9492;&#9472;&#9472; testlib.hpp

0 directories, 7 files

</pre>
</div>

<p>
Build shared library on Linux.
</p>

<ul class="org-ul">
<li>For Linux, build DLL and client code with make linux.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ make linux
<span class="org-builtin">echo</span> <span class="org-string">"Build shared library"</span>
Build shared library
g++ testlib.cpp -o <span class="org-keyword">libtestlib.so</span>  -std=c++14 -fPIC -shared -Wall
<span class="org-builtin">echo</span> <span class="org-string">"Build client code 1"</span>
Build client code 1
g++ client1.cpp -o <span class="org-keyword">client1.bin</span> -std=c++14 libtestlib.so 

$ file libtestlib.so 
<span class="org-function-name">libtestlib.so</span>: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), 
dynamically linked, <span class="org-variable-name">BuildID</span>[sha1]=52a16d16991d7aa71763140e97a1422c1387711d, not stripped

$ file client1.bin 
<span class="org-function-name">client1.bin</span>: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, 
interpreter /lib64/ld-linux-x86-64.so.2, 
<span class="org-keyword">for</span> GNU/Linux 3.2.0, <span class="org-variable-name">BuildID</span>[sha1]=1a4885e112f72372cfd66816a564f49a24110c50, not stripped

</pre>
</div>

<p>
Build shared library on Windows: 
</p>

<ul class="org-ul">
<li>Just run the batch script build-windows.bat or double click at it.</li>
</ul>

<div class="org-src-container">
<pre class="src src-bat">$ build-windows.bat
**********************************************************************
** Visual Studio 2017 Developer Command <span class="org-builtin">Prompt</span> v15.5.6
** Copyright (c) 2017 Microsoft Corporation
**********************************************************************
[vcvarsall.bat] Environment initialized <span class="org-keyword">for</span>: 'x64'
testlib.cpp
   Creating library testlib.lib and object testlib.exp
Microsoft (R) C/C++ Optimizing Compiler Version 19.12.25835 <span class="org-keyword">for</span> x64
Copyright (C) Microsoft Corporation.  All rights reserved.

client1.cpp
Microsoft (R) Incremental Linker Version 14.12.25835.0
Copyright (C) Microsoft Corporation.  All rights reserved.

<span class="org-function-name">/out</span>:client1.exe
client1.obj
testlib.lib
   Creating library client1.lib and object client1.exp
 [StaticObject] =&gt; Initialize DLL
<span class="org-function-name">testlib.cpp</span>:48: &lt;DllMain&gt; DLL Loaded into the process =&gt; PID = 1240
<span class="org-function-name">testlib.cpp</span>:54: &lt;DllMain&gt; DLL attached to process.

=== EXPERIMENT 1 ===&gt; Import C++ functions from DLL
<span class="org-function-name">client1.cpp</span>:38: &lt;main&gt; Main process starts here.
 =&gt; Linalg::norm(xs) 7.4162
=&gt; xs = [5]( 1, 2, 3, 4, 5,  )
=== EXPERIMENT 2 ===&gt; Import class from DLL
 Instance created with name = Dummy

 .. ... ...  .. ... ...  .. ... ...  .. ... ... 
</pre>
</div>


<p>
Run C++ client code:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./client1.bin 
 [StaticObject] =&gt; Initialize DLL

=== EXPERIMENT 1 ===&gt; Import C++ functions from DLL
<span class="org-function-name">client1.cpp</span>:38: &lt;main&gt; Main process starts here.
 =&gt; Linalg::norm(xs) 7.4162
=&gt; xs = [5]( 1, 2, 3, 4, 5,  )
=== EXPERIMENT 2 ===&gt; Import class from DLL
 Instance created with name = Dummy
 Counter set to value = 100
<span class="org-function-name">cls.getName</span>() = Dummy
    cls.get() = 100

... ... ... 
</pre>
</div>

<p>
Run Python client code:
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ make py
python3 pywrapper.py
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> libpath = libtestlib.so
 <span class="org-rainbow-delimiters-depth-1">[</span>StaticObject<span class="org-rainbow-delimiters-depth-1">]</span> =&gt; Initialize DLL
Intializing library
Library initialized OK.

 .. ... ... ... 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb3ebef9" class="outline-4">
<h4 id="orgb3ebef9"><span class="section-number-4">1.3.2</span> Header macros</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Sources:
</p>
<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/testlib.cpp">file:src/dlls/example-windows1/testlib.cpp</a></li>
<li>File: <a href="src/dlls/example-windows1/testlib.hpp">file:src/dlls/example-windows1/testlib.hpp</a></li>
</ul>

<p>
<b>teslib.hpp / Heade File - Macros</b>
</p>

<p>
The header files uses the following macros to reduce the boilerplate
necessary to export the library functions and classes. 
</p>

<ul class="org-ul">
<li>file: testlib.hpp =&gt; Macros for exporting functions and classes.</li>
</ul>


<p>
<b>Macro: EXPORT_CPP</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Macro EXPORT_CPP makes a symbol visible. */</span>
<span class="org-preprocessor">#if</span> <span class="org-preprocessor">defined</span><span class="org-rainbow-delimiters-depth-1">(</span>_WIN32<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">EXPORT_CPP</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">#else</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">EXPORT_CPP</span> <span class="org-keyword">__attribute__</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>visibility <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"default"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If not compiled on Windows, remove declspec compiler extension.</span>
<span class="org-preprocessor">  #if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> <span class="org-keyword">__declspec</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">For GCC only - make exported symbol visible symbol </span>
<span class="org-preprocessor">    #define</span> <span class="org-function-name">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">param</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">__attribute__</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>visibility <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"default"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">  #endif</span>
<span class="org-preprocessor">#endif</span> 
</pre>
</div>

<p>
The macro EXPORT_CPP annotates the symbol as visible by expanding to:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">On Windows EXPORT_CPP becomes </span>
<span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">On Unix-like OSes, Linux, BSD, OSX ... </span>
 <span class="org-keyword">__attribute__</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>visibility <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"default"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
So a function <span class="underline">int SomeFunction(double x, double y)</span> becomes:
</p>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-comment-delimiter">// </span><span class="org-comment">Makes this symbol visible (exported) in the library (DLL)</span>
 EXPORT_CPP <span class="org-type">int</span> <span class="org-function-name">SomeFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> , <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">On Windows: </span>
<span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">int</span> <span class="org-function-name">SomeFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> , <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">On Unix-like operating systems or Linux: </span>
<span class="org-keyword">__attribute__</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>visibility <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"default"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">int</span> <span class="org-function-name">SomeFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> , <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>


<p>
<b>Macro EXPORT_C:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/* </span><span class="org-comment">Macro EXPORT_C is used for exporting symbol with C-linkage, it</span>
<span class="org-comment"> * means, without name mangling */</span>
<span class="org-preprocessor">#ifdef</span> __cplusplus
  <span class="org-comment-delimiter">// </span><span class="org-comment">extern "C" - Indicates that a given symbol/function has C-linkage and</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">does not have name mangling.</span>
  <span class="org-comment-delimiter">// </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">On Linux EXPORT_C becomes</span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">=&gt; extern "C" __attribute__ ((visibility ("default")))</span>
  <span class="org-comment-delimiter">// </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">On Windows EXPORT_C becomes </span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">=&gt; extern "C" __declspec(dllexport)</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">EXPORT_C</span> <span class="org-keyword">extern</span> <span class="org-string">"C"</span> EXPORT_CPP
<span class="org-preprocessor">#else</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If a C-compiler uses this header, remove 'extern "C"'</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">EXPORT_C</span>  EXPORT_CPP
<span class="org-preprocessor">#endif</span> 
</pre>
</div>

<p>
Export symbols with C-linkage, it means that the function is exported
without name decoration or <span class="underline">name mangling</span>. The function symbol matches
exactly its name. Functions with C-linkage can be called by C-code;
C++ code compiled with other compilers without ABI issues and foreign
function interfaces of scripting languages such as Python Ctypes or C#
Pinvoke. Note: If a function is defined with C-linkage, it can only use
C-compatible types. So, it is no possible to define functions with
C-linkage with overload, default parameter or non C-compatible
arguments.
</p>

<ul class="org-ul">
<li>On Windows, this macro is expanded to:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">EXPORT_C <span class="org-type">int</span> <span class="org-function-name">functionWith_C_linkage</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">MyClass</span>* <span class="org-variable-name">pointerToClass</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">z</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">On Windows it becomes: </span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>  <span class="org-type">int</span> <span class="org-function-name">functionWith_C_linkage</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">MyClass</span>* <span class="org-variable-name">pointerToClass</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">z</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">This function could also be declared as:</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-type">int</span> <span class="org-function-name">functionWith_C_linkage</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">MyClass</span>* <span class="org-variable-name">pointerToClass</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">z</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>On Unix-like OSes or linux, the macro EXPORT_C expands to:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">EXPORT_C <span class="org-type">int</span> <span class="org-function-name">functionWith_C_linkage</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">MyClass</span>* <span class="org-variable-name">pointerToClass</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">z</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">On Linux, it becomes:</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__attribute__</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>visibility <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"default"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">int</span> <span class="org-function-name">functionWith_C_linkage</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">MyClass</span>* <span class="org-variable-name">pointerToClass</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">z</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">This function could also be declared as:</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__attribute__</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>visibility <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"default"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-type">int</span> <span class="org-function-name">functionWith_C_linkage</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">MyClass</span>* <span class="org-variable-name">pointerToClass</span>, <span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">z</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
On Unix-like operating system (GCC or Clang compilers), all
functions in an object-code (aka compiled code) becomes visible by
default what can lead to undefined behavior when there are name
clashes due to repeated symbols. With appropriate compiler options
such as -fvisibility=hidden, the symbols can be made private by
default as happens in Windows where is necessary to annotate the
symbol as visible explicitly with __declspec(dllexport). On Unix-like
OSes for GCC and Clang compiler the annotation for making the symbol
visible is <code>__attribute__ ((visibility ("default")))</code>. This statement
has no effect if the appropriate compiler flags are not set.
</p>
</div>
</div>

<div id="outline-container-org265375c" class="outline-4">
<h4 id="org265375c"><span class="section-number-4">1.3.3</span> Namespace Linalg</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
<b>Functions of Namespace Linalg</b> 
</p>

<p>
Namespace containing sample linear algebra functions, the function norm
computes an Euclidean norm of a N-dimension vector, the function
linTransform computes a linear transformation performing the
computation v[i] * a + b for each vector element. 
</p>

<p>
On Windows, all DLL symbols, such as functions, variables and clases,
are private by default, they are not exported by default as happens in
Unix-like OSes shared libraries. Therefore, in order to a function be
exported in a Windows shared library, it is necessary to use the MSVC or visual C++
compiler extension <code>__declspec(dllexport)</code> before the function declaration.
</p>

<ul class="org-ul">
<li>Interface =&gt; File: <b>testlib.hpp</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#ifdef</span> __cplusplus

<span class="org-keyword">namespace</span> <span class="org-constant">Linalg</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        EXPORT_CPP
        <span class="org-type">double</span> <span class="org-function-name">norm</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        EXPORT_CPP <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-function-name">linTransform</span><span class="org-rainbow-delimiters-depth-2">(</span>
                <span class="org-type">double</span> <span class="org-variable-name">a</span>,
                <span class="org-type">double</span> <span class="org-variable-name">b</span>,
                <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span>
                <span class="org-rainbow-delimiters-depth-2">)</span>;

        EXPORT_CPP
        <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp;
        <span class="org-function-name">printVector</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">)</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-preprocessor">#endif</span> 
</pre>
</div>

<p>
The compiler directives <b>#ifdef __cplusplus &#x2026; #endif</b> are used for
disabling this code block when the header is used by a C-compiler as
the C-language does not support classes, namespaces and many other C++
features. 
</p>

<ul class="org-ul">
<li>file: <b>testlib.cpp</b> - Implementation</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Linear algebra tools </span>
 <span class="org-keyword">namespace</span> <span class="org-constant">Linalg</span><span class="org-rainbow-delimiters-depth-1">{</span>
         EXPORT_CPP 
          <span class="org-type">double</span> <span class="org-function-name">norm</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">){</span>
                <span class="org-type">double</span> <span class="org-variable-name">sum</span> = 0.0;
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span> : xs<span class="org-rainbow-delimiters-depth-3">)</span> sum += x * x;
                <span class="org-keyword">return</span> <span class="org-constant">std</span>::sqrt<span class="org-rainbow-delimiters-depth-3">(</span>sum<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        EXPORT_CPP
        <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-function-name">linTransform</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">){</span>
                <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">out</span><span class="org-rainbow-delimiters-depth-3">(</span>xs.size<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; xs.size<span class="org-rainbow-delimiters-depth-4">()</span>; i++<span class="org-rainbow-delimiters-depth-3">){</span>      
                        out<span class="org-rainbow-delimiters-depth-4">[</span>i<span class="org-rainbow-delimiters-depth-4">]</span> = a * xs<span class="org-rainbow-delimiters-depth-4">[</span>i<span class="org-rainbow-delimiters-depth-4">]</span> + b;
                <span class="org-rainbow-delimiters-depth-3">}</span>
                <span class="org-keyword">return</span> out;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        EXPORT_CPP
        <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp;
        <span class="org-function-name">printVector</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">){</span>
                os &lt;&lt; <span class="org-string">"["</span> &lt;&lt; xs.size<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"]( "</span>;
                <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp;  <span class="org-variable-name">x</span>: xs<span class="org-rainbow-delimiters-depth-3">)</span>
                        os &lt;&lt; x &lt;&lt; <span class="org-string">", "</span>;
                <span class="org-keyword">return</span> os &lt;&lt; <span class="org-string">" )"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>   
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org47796d7" class="outline-4">
<h4 id="org47796d7"><span class="section-number-4">1.3.4</span> C-interface of Namespace Linalg</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
<b>C-interface of Namespace Linalg</b> 
</p>

<p>
A C-interface is necessary for ensuring that the DLL can be called
from a C-program or a foreign function interface of a higher level
language. 
</p>

<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Function declaration.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">======= C-interface for Linalg namespace =========//</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Handle or opaque pointer for std::vector&lt;double&gt; */</span>
<span class="org-keyword">typedef</span> <span class="org-type">void</span>* <span class="org-type">hVectorD</span>;

<span class="org-comment-delimiter">/* </span><span class="org-comment">----- C-Wrappers for Linalg namespace ---- */</span>

EXPORT_C 
<span class="org-type">double</span> <span class="org-function-name">testlib_vectorD_Linalg_norm</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">)</span>;

EXPORT_C 
<span class="org-type">void</span> <span class="org-function-name">testlib_vectorD_Linalg_printVector</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>, <span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">)</span>;

</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; C-interface function implementations.</li>
</ul>

<p>
The type synonym hVectorD is handle or a opaque poiter for the type
std::vector&lt;double&gt;. It is a workaround, to pass std::vector&lt;double&gt;
accross a DLL functions with C-linkage and use std::vector&lt;double&gt;
from C programs or foreign function interfaces. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">//</span><span class="org-comment">=========== C-wrappers ---------------///</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Handler for double vector </span>
<span class="org-keyword">using</span> <span class="org-type">hVectorD</span> = <span class="org-type">void</span>*;
<span class="org-keyword">using</span> <span class="org-type">pVectorD</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>*;

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for vector&lt;double&gt; constructor */</span>
EXPORT_C  
<span class="org-type">hVectorD</span> <span class="org-function-name">testlib_vectorD_make0</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>n, x<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for range constructor */</span>
EXPORT_C
<span class="org-type">hVectorD</span> <span class="org-function-name">testlib_vectorD_make1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">array</span> <span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>array, array + n<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for setting elements of vector&lt;double&gt; */</span>
EXPORT_C 
<span class="org-type">void</span> <span class="org-function-name">testlib_vectorD_set</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">pVectorD</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>hv<span class="org-rainbow-delimiters-depth-2">)</span>-&gt;<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-2">[](</span>n<span class="org-rainbow-delimiters-depth-2">)</span> = x;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for vector&lt;double&gt; destructor */</span>
EXPORT_C <span class="org-type">void</span> <span class="org-function-name">testlib_vectorD_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">delete</span> <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">pVectorD</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>hv<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapepr for Linalg::norm function */</span>
EXPORT_C 
<span class="org-type">double</span> <span class="org-function-name">testlib_vectorD_Linalg_norm</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">return</span> <span class="org-constant">Linalg</span>::norm<span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">pVectorD</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>hv<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

EXPORT_C 
<span class="org-type">void</span> <span class="org-function-name">testlib_vectorD_Linalg_printVector</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>, <span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; name &lt;&lt; <span class="org-string">" = "</span>;
    <span class="org-constant">Linalg</span>::printVector<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cout, *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">pVectorD</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>hv<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org2225627" class="outline-4">
<h4 id="org2225627"><span class="section-number-4">1.3.5</span> Non-polymorphic Class - SampleClass</h4>
<div class="outline-text-4" id="text-1-3-5">
<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Class declaration.</li>
</ul>

<p>
In order to a class be exported in a Windows' shared library, it
requires the annotation <code>__declspec(dllexport)</code>.
</p>

<p>
Note: It will not be possible to compiled client program using this
class with a compiler different from the used to build the shared
library libtest.dll. It happens because, the C++ ABI - Application
Binary Interface is not the same accross different compilers. If the
DLL is compiled with MSVC, the only way to use this class from a
program compiled using MingW or even a different version of MSVC is
by using a C-interface (functions with C-linkage) and opaque
pointers (void* pointers). 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">======= Non-polymorphic class exported by DLL =========//</span>

<span class="org-preprocessor">#ifdef</span> __cplusplus
<span class="org-comment-delimiter">// </span><span class="org-comment">Non-polymorphic class </span>
<span class="org-keyword">class</span> <span class="org-type">EXPORT_CPP</span> <span class="org-variable-name">SampleClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        SampleClass<span class="org-rainbow-delimiters-depth-2">()</span>;
        SampleClass<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>;   
        ~SampleClass<span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
        <span class="org-type">int</span> <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-type">void</span> <span class="org-function-name">set</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span>;    
<span class="org-function-name">private</span>:
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
        <span class="org-type">int</span> <span class="org-variable-name">m_counter</span>;  
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-preprocessor">#endif</span> 
</pre>
</div>


<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; Class implementation.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">SampleClass</span>::SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>
   : m_name<span class="org-rainbow-delimiters-depth-1">(</span>name<span class="org-rainbow-delimiters-depth-1">)</span>, m_counter<span class="org-rainbow-delimiters-depth-1">(</span>0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Instance created with name = "</span> &lt;&lt; m_name &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">/** </span><span class="org-comment">Delegated constructor on right-hand-side */</span>
<span class="org-function-name">SampleClass</span>::SampleClass<span class="org-rainbow-delimiters-depth-1">()</span>: SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"unnamed"</span><span class="org-rainbow-delimiters-depth-1">){}</span>   

<span class="org-function-name">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"SampleClass =&gt; name = "</span><span class="org-rainbow-delimiters-depth-2">)</span> + m_name +  <span class="org-string">" deleted"</span>;
    DbgTrace<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::string <span class="org-constant">SampleClass</span>::getName<span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> m_name;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">int</span> <span class="org-constant">SampleClass</span>::<span class="org-constant">SampleClass</span>::<span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-1">(){</span>        
    <span class="org-keyword">return</span> m_counter;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">void</span> <span class="org-constant">SampleClass</span>::<span class="org-function-name">set</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Counter set to value = "</span> &lt;&lt; n &lt;&lt; <span class="org-constant">std</span>::endl;
    m_counter = n;
<span class="org-rainbow-delimiters-depth-1">}</span>   
</pre>
</div>
</div>
</div>

<div id="outline-container-org631db84" class="outline-4">
<h4 id="org631db84"><span class="section-number-4">1.3.6</span> C-interface for SampleClass</h4>
<div class="outline-text-4" id="text-1-3-6">
<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Functions declarations.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/* </span><span class="org-comment">----- C-Wrappers for SampleClass namespace ---- */</span>
<span class="org-keyword">using</span> <span class="org-type">hSampleClass</span> = <span class="org-type">void</span>*;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Nullable constructor zero-arg constructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">hSampleClass</span>
<span class="org-function-name">testlib_SampleClass_make0</span><span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Other constructor */</span>
EXPORT_C <span class="org-type">hSampleClass</span> <span class="org-function-name">testlib_SampleClass_make1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Destructor */</span>
EXPORT_C
<span class="org-type">void</span>
<span class="org-function-name">testlib_SampleClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Wrapper for get method */</span>
EXPORT_C
<span class="org-type">int</span>
<span class="org-function-name">testlib_SampleClass_get</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Wrapper for set method */</span>
EXPORT_C
<span class="org-type">void</span>
<span class="org-function-name">testlib_SampleClass_set</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">EXPORT_C</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>*
testlib_SampleClass_getName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; Functions implementation.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/* </span><span class="org-comment">----- C-Wrappers for SampleClass namespace ---- */</span>

<span class="org-keyword">using</span> <span class="org-type">hSampleClass</span> = <span class="org-type">void</span>*;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Nullable constructor zero-arg constructor */</span>
EXPORT_C 
<span class="org-type">hSampleClass</span>
<span class="org-function-name">testlib_SampleClass_make0</span><span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Other constructor */</span>
EXPORT_C <span class="org-type">hSampleClass</span> <span class="org-function-name">testlib_SampleClass_make1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Destructor */</span>
EXPORT_C
<span class="org-type">void</span>
<span class="org-function-name">testlib_SampleClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Wrapper for get method */</span>
EXPORT_C
<span class="org-type">int</span>
<span class="org-function-name">testlib_SampleClass_get</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Wrapper for set method */</span>
EXPORT_C
<span class="org-type">void</span>
<span class="org-function-name">testlib_SampleClass_set</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">EXPORT_C</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>*
testlib_SampleClass_getName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

</pre>
</div>
</div>
</div>

<div id="outline-container-orga7f81ad" class="outline-4">
<h4 id="orga7f81ad"><span class="section-number-4">1.3.7</span> Polymorphic class InterfaceClass</h4>
<div class="outline-text-4" id="text-1-3-7">
<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Class declaration.</li>
</ul>

<p>
As the name implies, this class is an interface class, which is a
class containing only pure virtual functions (abstract methods). As a
result, it is declared only in the header file and cannot be
instatiated directly. 
</p>

<p>
This class uses only C-types to be binary compatible with different
compilers, if it used STL containers such as string or any other
non-compatible C-type, it would not be possible to compile a C++
program using Mingw/GCC against this DLL built with MSVC.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Polymorphic Interface class binary compatible across different</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">compilers as it does not use any STL container on the interface.</span>
<span class="org-preprocessor">#ifdef</span> __cplusplus
<span class="org-keyword">struct</span> <span class="org-type">InterfaceClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">/* </span><span class="org-comment">Returns class unique ID */</span>
        <span class="org-keyword">virtual</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = 0;
        <span class="org-comment-delimiter">/** </span><span class="org-comment">Set class internal state */</span>
        <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
        <span class="org-keyword">virtual</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> = 0;

        <span class="org-comment-delimiter">/** </span><span class="org-comment">Virtual constructor */</span>
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">InterfaceClass</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">virtual ~InterfaceClass();</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-preprocessor">#else</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">InterfaceClass</span> <span class="org-type">void</span> 
<span class="org-preprocessor">#endif</span> 
</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; class ImplementationA of interface InterfaceClass.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">ImplementationA</span>: <span class="org-keyword">public</span> <span class="org-type">InterfaceClass</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
<span class="org-function-name">public</span>:
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span> = <span class="org-string">"ImplementationA"</span>;

    <span class="org-function-name">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">()</span>: m_name<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Unammed-A"</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-function-name">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>
       : m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span> 
    ~<span class="org-function-name">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">(){</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] ImplementationA deleted =&gt; name = "</span>
                   &lt;&lt; m_name
                   &lt;&lt; <span class="org-string">" ; type = "</span> &lt;&lt; class_id
                   &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>     
        <span class="org-keyword">return</span> class_id;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        m_name = name;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> m_name.c_str<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; class ImplementationB of interface InterfaceClass.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">ImplementationB</span>: <span class="org-keyword">public</span> <span class="org-type">InterfaceClass</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
<span class="org-function-name">public</span>:
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span> = <span class="org-string">"ImplementationB"</span>;

    <span class="org-function-name">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">()</span>: m_name<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Unammed-B"</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-function-name">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>
       : m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span> 
    ~<span class="org-function-name">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] ImplementationB deleted =&gt; name = "</span>
                  &lt;&lt; m_name
                  &lt;&lt; <span class="org-string">" ; type = "</span> &lt;&lt; class_id
                  &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>     
            <span class="org-keyword">return</span> class_id;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
            m_name = name;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
            <span class="org-keyword">return</span> m_name.c_str<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; C-interface and factory function to load
implementations from the DLL.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Factory function */</span>
EXPORT_C <span class="org-type">InterfaceClass</span>* <span class="org-function-name">teslib_InterfaceClass_factory</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for destructor */</span>
EXPORT_C <span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for getID method */</span>
<span class="org-type">EXPORT_C</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">EXPORT_C</span> <span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_setName</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">EXPORT_C</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; C-interfaces and factory functions
definitions.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">EXPORT_C <span class="org-type">InterfaceClass</span>*
<span class="org-function-name">teslib_InterfaceClass_factory</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">s</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span>class_id<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>s == <span class="org-string">"ImplementationA"</span><span class="org-rainbow-delimiters-depth-2">)</span>
            <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>s == <span class="org-string">"ImplementationB"</span><span class="org-rainbow-delimiters-depth-2">)</span>
            <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

EXPORT_C <span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">delete</span> hinst;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">EXPORT_C</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> hinst-&gt;getID<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">EXPORT_C</span>
<span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_setName</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    hinst-&gt;setName<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">EXPORT_C</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">return</span> hinst-&gt;getName<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8322649" class="outline-4">
<h4 id="org8322649"><span class="section-number-4">1.3.8</span> DLL startup function DLLMain</h4>
<div class="outline-text-4" id="text-1-3-8">
<p>
When a Windows shared library is loaded at compile-time or at runtime
by some process, the function DLLMain is always invoked, it is similar
to the function main() from an executable. 
</p>

<p>
Note: logging statements with printf, std::cout, std::cerr will not
printed if the DLL is loaded by some non-console program, a program
compiled to the <span class="underline">window subsystem</span>. Therefore, the easiest way to log is
to use the OutputDebugString function which output can viewed by the
DebugView sysinternal tool. 
</p>


<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; DLL main function.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">- DLL Entry point - main function of DLL which is executed when </span>
<span class="org-comment">    the DLL is loaded by some process. </span>
<span class="org-comment"> */</span>
<span class="org-preprocessor">#if</span> <span class="org-preprocessor">defined</span><span class="org-rainbow-delimiters-depth-1">(</span>_WIN32<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
BOOL <span class="org-type">APIENTRY</span> <span class="org-function-name">DllMain</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">HINSTANCE</span> <span class="org-variable-name">hInst</span>, <span class="org-type">DWORD</span> <span class="org-variable-name">reason</span>, <span class="org-type">LPVOID</span> <span class="org-variable-name">lpReserved</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span> =
            <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"DLL Loaded into the process =&gt; PID = "</span><span class="org-rainbow-delimiters-depth-2">)</span>
            + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-2">(</span>::GetCurrentProcessId<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    WindbgTrace<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;
    DbgTrace<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">switch</span> <span class="org-rainbow-delimiters-depth-2">(</span>reason<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">case</span> DLL_PROCESS_ATTACH:
        WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL attached to process"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL attached to process."</span><span class="org-rainbow-delimiters-depth-3">)</span>;           
      <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> DLL_PROCESS_DETACH:
         WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"=&gt; DLL detached."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
         DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"=&gt; DLL attached"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
      <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> DLL_THREAD_ATTACH:
        WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL attached to thread"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL detached to thread."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
      <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> DLL_THREAD_DETACH:
        WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL detached from thread"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL detached from thread."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
      <span class="org-keyword">break</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">return</span> TRUE;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-preprocessor">#endif</span> 
</pre>
</div>


<p>
Another more portable way to peform some way action when the DLL is
loaded by a process or unloaded is to use a static object. The startup
task is executed int the object's constructor and the finalization
task, which happens when the process ends, is executed at object's
destructor. This approach may a better replacement for DLLMain
function, which is specific for Windows, as this technique works both
on Windows and any other Unix-like operating system. 
</p>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; Static Object for replacing DLLMain</li>
</ul>

<p>
The class _StaticObject and a static instance of it is defined within
an anonymous namespace to make them private to the compilation unit
testlib.cpp and not allow them to be used from anywhere else. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Class private to this compilation unit - cannot be accessed from</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">any other file</span>
<span class="org-keyword">namespace</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">class</span> <span class="org-type">_StaticObject</span><span class="org-rainbow-delimiters-depth-2">{</span>     
   <span class="org-keyword">public</span>:
       <span class="org-keyword">using</span> <span class="org-type">Action</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>;
       <span class="org-type">Action</span> <span class="org-variable-name">m_end</span>;

       <span class="org-function-name">_StaticObject</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Action</span> <span class="org-variable-name">init</span>, <span class="org-type">Action</span> <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-3">)</span>
               :  m_end<span class="org-rainbow-delimiters-depth-3">(</span>end<span class="org-rainbow-delimiters-depth-3">)</span>
       <span class="org-rainbow-delimiters-depth-3">{</span>
               init<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-rainbow-delimiters-depth-3">}</span>
       ~<span class="org-function-name">_StaticObject</span><span class="org-rainbow-delimiters-depth-3">(){</span> m_end<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
   <span class="org-rainbow-delimiters-depth-2">}</span>;

   <span class="org-comment-delimiter">// </span><span class="org-comment">Static object for replacing DLLMain </span>
   <span class="org-keyword">auto</span> <span class="org-variable-name">initDLL</span> = _StaticObject<span class="org-rainbow-delimiters-depth-2">(</span>
      <span class="org-rainbow-delimiters-depth-3">[]{</span>
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [StaticObject] =&gt; Initialize DLL"</span>
                       &lt;&lt; <span class="org-constant">std</span>::endl;                        
      <span class="org-rainbow-delimiters-depth-3">}</span>,
      <span class="org-rainbow-delimiters-depth-3">[]{</span>   
           <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [StaticObject] =&gt; Shutdown DLL"</span>
                     &lt;&lt; <span class="org-constant">std</span>::endl;                              
      <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0ec782a" class="outline-4">
<h4 id="org0ec782a"><span class="section-number-4">1.3.9</span> DLL entry point for run32dll.exe</h4>
<div class="outline-text-4" id="text-1-3-9">
<p>
This function is a DLL entry point for the Windows program
rundll32.exe which can execute this function with: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ rundll32.exe testlib.dll,entryPoint1
$ rundll32.exe testlib.dll,entryPoint1 arg0 arg1 <span class="org-type">arg2</span> ... <span class="org-variable-name">argn</span> 
</pre>
</div>

<p>
When the DLL testlib.dll is run with run32dll calling the function
entryPoint1, it will display a message box. 
</p>

<p>
Note: It is an optional function which could be used for installing
the DLL in the system or creating some entry in Windows' registry. 
</p>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#if</span> <span class="org-preprocessor">defined</span><span class="org-rainbow-delimiters-depth-1">(</span>_WIN32<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">void</span> <span class="org-function-name">entryPoint1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">HWND</span> <span class="org-variable-name">hwn</span>, <span class="org-type">HINSTANCE</span> <span class="org-variable-name">hinst</span>, <span class="org-type">LPSTR</span> <span class="org-variable-name">cmdLine</span>, <span class="org-type">int</span> <span class="org-variable-name">nCmdShow</span><span class="org-rainbow-delimiters-depth-1">){</span>  
     DbgDisp<span class="org-rainbow-delimiters-depth-2">(</span>cmdLine<span class="org-rainbow-delimiters-depth-2">)</span>;
     OutputDebugString<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Rudll32 called entryPoint1()"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     MessageBoxA<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">NULL</span>, <span class="org-string">"DLL ENTRY POINT"</span>, <span class="org-string">"Entry point 1"</span>, 0<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-preprocessor">#endif</span> 
</pre>
</div>
</div>
</div>
<div id="outline-container-org902a738" class="outline-4">
<h4 id="org902a738"><span class="section-number-4">1.3.10</span> C++ Client program - client1.cpp</h4>
<div class="outline-text-4" id="text-1-3-10">
<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/client1.cpp">file:src/dlls/example-windows1/client1.cpp</a></li>
</ul>

<p>
<b>File client1.cpp</b>
</p>

<p>
Includes: 
</p>

<ul class="org-ul">
<li>Note: (#include "testlib.hpp") a header file between quotes,
indicates to the compiler that the header is in the same directory
as the source file client1.cpp.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">ostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string">"testlib.hpp"</span>
</pre>
</div>

<p>
Declaration of functions with C-linkages not declarated in the header
testlib.hpp
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-type">hVectorD</span> <span class="org-function-name">testlib_vectorD_make0</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-type">hVectorD</span> <span class="org-function-name">testlib_vectorD_make1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">array</span> <span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-type">void</span> <span class="org-function-name">testlib_vectorD_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Main function - Experiment 1 and Experiment 2:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> DISABLE
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n=== EXPERIMENT 1 ===&gt; Import C++ functions from DLL"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

DbgTrace<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Main process starts here."</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> xs<span class="org-rainbow-delimiters-depth-1">{</span>1.0, 2.0, 3.0, 4.0, 5.0<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; Linalg::norm(xs) "</span> &lt;&lt; <span class="org-constant">Linalg</span>::norm<span class="org-rainbow-delimiters-depth-1">(</span>xs<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"=&gt; xs = "</span>; <span class="org-constant">Linalg</span>::printVector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cout, xs<span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"=== EXPERIMENT 2 ===&gt; Import class from DLL"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-keyword">auto</span> <span class="org-variable-name">cls</span> = SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Dummy"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
cls.set<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"cls.getName() = "</span> &lt;&lt; cls.getName<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"    cls.get() = "</span> &lt;&lt; cls.get<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-preprocessor">#endif</span> <span class="org-comment-delimiter">// </span><span class="org-comment">-- eof DISABLE flag</span>
</pre>
</div>

<p>
Main Function - Experiment 3 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">//</span><span class="org-comment">=========&gt;&gt; Load functions and classes using C-interface ==============//</span>

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n== EXPERIMENT 3 ===&gt; Import C-functions from DLL - C-interface"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-type">double</span> <span class="org-variable-name">arr</span> <span class="org-rainbow-delimiters-depth-1">[]</span> = <span class="org-rainbow-delimiters-depth-1">{</span>1, 2, 3, 4, 5<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">hVectorD</span> <span class="org-variable-name">v1</span> = testlib_vectorD_make1<span class="org-rainbow-delimiters-depth-1">(</span>5, arr<span class="org-rainbow-delimiters-depth-1">)</span>;
testlib_vectorD_Linalg_printVector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"v1"</span>, v1<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"norm(v1) = "</span> &lt;&lt; testlib_vectorD_Linalg_norm<span class="org-rainbow-delimiters-depth-1">(</span>v1<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;

testlib_vectorD_delete<span class="org-rainbow-delimiters-depth-1">(</span>v1<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Main Functions - Experiment 4 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n== EXPERIMENT 4 ===&gt; Non-polymorphic class with C-interface "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-type">hSampleClass</span> <span class="org-variable-name">hcls</span> = testlib_SampleClass_make1<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"[EXPERIMENT4]ClassHandle-OOP-C-API"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"[EXPERIMENT 4] hcls.getName() = "</span> &lt;&lt; testlib_SampleClass_getName<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
testlib_SampleClass_set<span class="org-rainbow-delimiters-depth-1">(</span>hcls, 100<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"[EXPERIMENT 4] hcls.get()     = "</span> &lt;&lt; testlib_SampleClass_get<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
testlib_SampleClass_set<span class="org-rainbow-delimiters-depth-1">(</span>hcls, 200<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"[EXPERIMENT 4] hcls.get()     = "</span> &lt;&lt; testlib_SampleClass_get<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;

testlib_SampleClass_delete<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span>;   
</pre>
</div>

<p>
Main Functions - Experiment 5 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n== EXPERIMENT 5 ===&gt; Load polymorphic classes from DLL "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinstA</span> = teslib_InterfaceClass_factory<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ImplementationA"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinstB</span> = teslib_InterfaceClass_factory<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ImplementationB"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstA-&gt;getID() = "</span> &lt;&lt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstA-&gt;getID() = "</span> &lt;&lt; hinstB-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
hinstA-&gt;setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ClassA-implA"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
hinstB-&gt;setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ClassB-implB"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstA-&gt;getName() = "</span> &lt;&lt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstB-&gt;getName() = "</span> &lt;&lt; hinstB-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-comment-delimiter">// </span><span class="org-comment">Note: If delete is used directly to delete hinstA and hinstB,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">a segmentatin fault will happen whenc compiling with Mingw/GCC</span>
testlib_InterfaceClass_delete<span class="org-rainbow-delimiters-depth-1">(</span>hinstA<span class="org-rainbow-delimiters-depth-1">)</span>;
testlib_InterfaceClass_delete<span class="org-rainbow-delimiters-depth-1">(</span>hinstB<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] After deleting instances"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

DbgTrace<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Program ended OK."</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Compile and run client code with MSVC</b>
</p>

<p>
Note: Both the DLL and the client code are compiled with MSVC-2017 64
bits target.
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cl.exe /EHsc client.cpp /nologo /Fe:client1.exe testlib.lib &amp;&amp; client1.exe

<span class="org-comment-delimiter"># </span><span class="org-comment">Output: </span>
client.cpp
   Creating library client1.lib and object client1.exp
 [StaticObject] =&gt; Initialize DLL
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the process =&gt; PID = 1112
<span class="org-function-name">testlib.cpp</span>:45: &lt;DllMain&gt; DLL attached to process.

=== EXPERIMENT 1 ===&gt; Import C++ functions from DLL
<span class="org-function-name">client.cpp</span>:33: &lt;main&gt; Main process starts here.
 =&gt; Linalg::norm(xs) 7.4162
=&gt; xs = [5]( 1, 2, 3, 4, 5,  )
=== EXPERIMENT 2 ===&gt; Import class from DLL
 Instance created with name = Dummy
 Counter set to value = 100
<span class="org-function-name">cls.getName</span>() = Dummy
    cls.get() = 100

== EXPERIMENT 3 ===&gt; Import C-functions from DLL - C-interface
v1 = [5]( 1, 2, 3, 4, 5,  )
<span class="org-function-name">norm</span>(v1) = 7.4162

== EXPERIMENT 4 ===&gt; Non-polymorphic class with C-interface 
 Instance created with name = [EXPERIMENT4]ClassHandle-OOP-C-API
[EXPERIMENT 4] hcls.getName() = [EXPERIMENT4]ClassHandle-OOP-C-API
 Counter set to value = 100
[EXPERIMENT 4] hcls.get()     = 100
 Counter set to value = 200
[EXPERIMENT 4] hcls.get()     = 200
<span class="org-function-name">testlib.cpp</span>:159: &lt;SampleClass::~SampleClass&gt; SampleClass =&gt; name = [EXPERIMENT4]ClassHandle-OOP-C-API deleted

== EXPERIMENT 5 ===&gt; Load polymorphic classes from DLL 
 =&gt; hinstA-&gt;getID() = ImplementationA
 =&gt; hinstA-&gt;getID() = ImplementationB
 =&gt; hinstA-&gt;getName() = ImplementationA
 =&gt; hinstB-&gt;getName() = ImplementationB
 [INFO] ImplementationA deleted =&gt; name = ClassA-implA ; <span class="org-builtin">type</span> = ImplementationA
 [INFO] ImplementationB deleted =&gt; name = ClassB-implB ; <span class="org-builtin">type</span> = ImplementationB
 [INFO] After deleting instances
<span class="org-function-name">client.cpp</span>:87: &lt;main&gt; Program ended OK.
<span class="org-function-name">testlib.cpp</span>:159: &lt;SampleClass::~SampleClass&gt; SampleClass =&gt; name = Dummy deleted
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the process =&gt; PID = 1112
<span class="org-function-name">testlib.cpp</span>:49: &lt;DllMain&gt; =&gt; DLL attached
 [StaticObject] =&gt; Shutdown DLL

</pre>
</div>

<p>
<b>[FAILURE] ABI - Issue - Compile with Mingw client1.cpp against testlib.dll built with MSVC</b>
</p>

<p>
The client code is compiled with Mingw and the library was built with
MSVC-2017 for 64 bits target.
</p>

<p>
Build and run client [FAILURE]:
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ client1.cpp -g -o <span class="org-keyword">client1-gcc.exe</span> -std=c++14 testlib.dll  &amp;&amp; client1-gcc.exe
<span class="org-function-name">C</span>:\Users\archbox\AppData\Local\Temp\cckNg9eZ.o: In function `main<span class="org-warning">'</span>:
<span class="org-function-name">client1.cpp</span>:35: undefined reference to `<span class="org-constant">Linalg</span>::norm<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:36: undefined reference to `<span class="org-constant">Linalg</span>::printVector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp;, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:39: undefined reference to `<span class="org-constant">SampleClass</span>::SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">__cxx11</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:40: undefined reference to `<span class="org-constant">SampleClass</span>::set<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:41: undefined reference to `<span class="org-constant">SampleClass</span>::getName<span class="org-rainbow-delimiters-depth-1">[</span>abi:cxx11<span class="org-rainbow-delimiters-depth-1">]()</span> <span class="org-keyword">const</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:42: undefined reference to `<span class="org-constant">SampleClass</span>::get<span class="org-rainbow-delimiters-depth-1">()</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:39: undefined reference to `<span class="org-constant">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">()</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:39: undefined reference to `<span class="org-constant">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">()</span><span class="org-warning">'</span>
<span class="org-function-name">collect2.exe</span>: error: ld returned 1 exit status
Compilation <span class="org-compilation-error">exited abnormally</span> with code <span class="org-compilation-error">1</span> at Sun Dec 16 17:41:47
</pre>
</div>

<p>
The compilation fails because C++ does not have a standard and stable
ABI - Application Binary Interface, as a result, it is not possible to
use an object-code (here - any type of compiled code) built by a
different compiler than the current one. The ABI comprises the name
mangling schema or name decoration schema which is compiler-dependent,
padding, class memory layout and so on. In addition to ABI issues, the
STL - Standard Template Library implementations may not be compatible
and also not be the same across different compilers. 
</p>

<p>
The only way to ensure that a DLL can work with all possible compilers
is to use a functions with C-linkage (extern "C") with opaque pointers
(void*) for passing around classes and wrapped STL containers. Classes
can be used by different compilers, only if they are interface classes
(classes with only pure virtual functions) containing only
C-compatible types in the declaration. 
</p>


<p>
<b>Compile with Mingw client1.cpp against testlib.dll built with MSVC</b>
</p>

<p>
The compilation works when compiling with the custom flag -DDISABLE.
The directive <span class="underline">#ifndef DISABLE &#x2026; #endif</span> removes all usages of the
namespace Linalg and the class SampleClass. This flag makes main the
function use only functions with C-linkage and the interface class
InterfaceClass.
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ client.cpp -g -o <span class="org-keyword">client-gcc.exe</span> -std=c++14 testlib.dll -DDISABLE   &amp;&amp; client-gcc.exe

   <span class="org-rainbow-delimiters-depth-1">[</span>StaticObject<span class="org-rainbow-delimiters-depth-1">]</span> =&gt; Initialize DLL
  testlib.cpp:39: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> DLL Loaded into the process =&gt; PID = 5724
  testlib.cpp:45: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> DLL attached to process.

  == EXPERIMENT 3 ===&gt; Import C-functions from DLL - C-interface
  v1 = <span class="org-rainbow-delimiters-depth-1">[</span>5<span class="org-rainbow-delimiters-depth-1">](</span> 1, 2, 3, 4, 5,  <span class="org-rainbow-delimiters-depth-1">)</span>
  norm<span class="org-rainbow-delimiters-depth-1">(</span>v1<span class="org-rainbow-delimiters-depth-1">)</span> = 7.4162

  == EXPERIMENT 4 ===&gt; Non-polymorphic <span class="org-keyword">class</span> with C-interface 
   Instance created with name = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">EXPERIMENT4</span><span class="org-rainbow-delimiters-depth-1">]</span>ClassHandle-OOP-C-API
  <span class="org-rainbow-delimiters-depth-1">[</span>EXPERIMENT 4<span class="org-rainbow-delimiters-depth-1">]</span> hcls.getName<span class="org-rainbow-delimiters-depth-1">()</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">EXPERIMENT4</span><span class="org-rainbow-delimiters-depth-1">]</span>ClassHandle-OOP-C-API
   Counter set to value = 100
  <span class="org-rainbow-delimiters-depth-1">[</span>EXPERIMENT 4<span class="org-rainbow-delimiters-depth-1">]</span> hcls.get<span class="org-rainbow-delimiters-depth-1">()</span>     = 100
   Counter set to value = 200
  <span class="org-rainbow-delimiters-depth-1">[</span>EXPERIMENT 4<span class="org-rainbow-delimiters-depth-1">]</span> hcls.get<span class="org-rainbow-delimiters-depth-1">()</span>     = 200
  testlib.cpp:159: <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">&gt;</span> SampleClass =&gt; name = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">EXPERIMENT4</span><span class="org-rainbow-delimiters-depth-1">]</span>ClassHandle-OOP-C-API deleted

  == EXPERIMENT 5 ===&gt; Load polymorphic classes from DLL 
   =&gt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationA
   =&gt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationB
   =&gt; hinstA-&gt;getName<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationA
   =&gt; hinstB-&gt;getName<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationB
   <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> ImplementationA deleted =&gt; name = ClassA-implA ; type = ImplementationA
   <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> ImplementationB deleted =&gt; name = ClassB-implB ; type = ImplementationB
   <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> After deleting instances
  client.cpp:87: <span class="org-rainbow-delimiters-depth-1">&lt;</span>main<span class="org-rainbow-delimiters-depth-1">&gt;</span> Program ended OK.
  testlib.cpp:39: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> DLL Loaded into the process =&gt; PID = 5724
  testlib.cpp:49: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> =&gt; DLL attached
   <span class="org-rainbow-delimiters-depth-1">[</span>StaticObject<span class="org-rainbow-delimiters-depth-1">]</span> =&gt; Shutdown DLL
</pre>
</div>
</div>
</div>

<div id="outline-container-org555f1b9" class="outline-4">
<h4 id="org555f1b9"><span class="section-number-4">1.3.11</span> Load DLL in Python3 REPL</h4>
<div class="outline-text-4" id="text-1-3-11">
<p>
Functions with C-linkage can be called by Python using the ctypes
library. The following code presents how it can be done: 
</p>

<p>
<b>Table for C types / Python ctypes conversion</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">C-type</th>
<th scope="col" class="org-left">Python C-types</th>
<th scope="col" class="org-left">C-type</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">char</td>
<td class="org-left">ctypes.c_char</td>
<td class="org-left">char*</td>
<td class="org-left">ctypes.POINTER(ctypes.c_char)</td>
</tr>

<tr>
<td class="org-left">int</td>
<td class="org-left">ctypes.c_int</td>
<td class="org-left">int*</td>
<td class="org-left">ctypes.POINTER(ctypes.c_int)</td>
</tr>

<tr>
<td class="org-left">size_t</td>
<td class="org-left">ctypes.c_int</td>
<td class="org-left">-</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">double</td>
<td class="org-left">ctypes.c_double</td>
<td class="org-left">double*</td>
<td class="org-left">ctypes.POINTER(ctypes.c_double)</td>
</tr>

<tr>
<td class="org-left">void</td>
<td class="org-left">None</td>
<td class="org-left">void*</td>
<td class="org-left">ctypes.c_void_p</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Get a Python string from a <span class="underline">const char* ptr</span> or <span class="underline">char* ptr</span>, use ctypes.string_at(ptr).</li>
<li>Pass a python string to an API with const char*
(ctypes.POINTER(ctypes.c_char)) as argument, use Function("string-argument".encode('utf-8'))</li>
</ul>

<p>
Python C-types documentation and further reading: 
</p>

<ul class="org-ul">
<li><a href="https://docs.python.org/3/library/ctypes.html">ctypes — A foreign function library for Python — Python 3.7.2rc1 documentation</a></li>
<li><a href="https://dbader.org/blog/python-ctypes-tutorial">Extending Python With C Libraries and the “ctypes” Module – dbader.org</a></li>
<li><a href="https://www.programcreek.com/python/example/1108/ctypes.CDLL">ctypes.CDLL Python Example</a></li>
<li><a href="https://blogs.msdn.microsoft.com/yizhang/2018/01/20/calling-c-functions-from-python-part-1-using-ctypes/">Calling C functions from Python – part 1 – using ctypes – Yi Zhang's MSDN Blog</a></li>
<li><a href="https://en.wikibooks.org/wiki/Python_Programming/Extending_with_ctypes">Python Programming/Extending with ctypes - Wikibooks, open books for an open world</a></li>
<li><a href="https://pgi-jcns.fz-juelich.de/portal/pages/using-c-from-python.html">Using C from Python: How to create a ctypes wrapper - Scientific IT-Systems</a></li>
</ul>

<p>
<b>Load the library:</b>
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-function-name">C</span>:\Users\archbox\Desktop\experiments
&#955; <span class="org-string">"C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\python"</span>
Python 3.6.5 |Anaconda, Inc.| (default, Mar 29 2018, 13:32:41) [MSC v.1900 64 bit (AMD64)] on win32
Type <span class="org-string">"help"</span>, <span class="org-string">"copyright"</span>, <span class="org-string">"credits"</span> <span class="org-keyword">or</span> <span class="org-string">"license"</span> <span class="org-keyword">for</span> more information.

&gt;&gt;&gt; <span class="org-keyword">import</span> ctypes

<span class="org-comment-delimiter"># </span><span class="org-comment">This messages is print by the DLLMain function </span>
&gt;&gt;&gt; <span class="org-variable-name">lib</span> = ctypes.cdll.LoadLibrary(<span class="org-string">"testlib.dll"</span>)
 [StaticObject] =&gt; Initialize DLL
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the <span class="org-variable-name">process</span> =&gt; <span class="org-variable-name">PID</span> = 4280
<span class="org-function-name">testlib.cpp</span>:45: &lt;DllMain&gt; DLL attached to process.
&gt;&gt;&gt; testlib.cpp:39: &lt;DllMain&gt; DLL Loaded into the <span class="org-variable-name">process</span> =&gt; <span class="org-variable-name">PID</span> = 4280
<span class="org-function-name">testlib.cpp</span>:53: &lt;DllMain&gt; DLL detached to thread.
</pre>
</div>

<p>
Check whether exported functions with C-linkage exist: 
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; lib.testlib_vectorD_make0
&lt;_FuncPtr <span class="org-builtin">object</span> at 0x0000021BFCAFF388&gt;

&gt;&gt;&gt; lib.testlib_vectorD_Linalg_printVector
&lt;_FuncPtr <span class="org-builtin">object</span> at 0x0000021BFCAFF458&gt;
&gt;&gt;&gt;

&gt;&gt;&gt; lib.testlib_vectorD_delete
&lt;_FuncPtr <span class="org-builtin">object</span> at 0x0000021BFCAFF528&gt;

<span class="org-comment-delimiter"># </span><span class="org-comment">Function which does not exist.</span>
&gt;&gt;&gt; lib.testlib_InterfaceClass_do_not_exist
Traceback (most recent call last):
  File <span class="org-string">"&lt;stdin&gt;"</span>, line 1, <span class="org-keyword">in</span> &lt;module&gt;
  File <span class="org-string">"C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\lib\ctypes\__init__.py"</span>, line 361, <span class="org-keyword">in</span> __getattr__
    <span class="org-variable-name">func</span> = <span class="org-keyword">self</span>.__getitem__(name)
  File <span class="org-string">"C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\lib\ctypes\__init__.py"</span>, line 366, <span class="org-keyword">in</span> __getitem__
    <span class="org-variable-name">func</span> = <span class="org-keyword">self</span>._FuncPtr((name_or_ordinal, <span class="org-keyword">self</span>))
<span class="org-function-name">AttributeError</span>: function <span class="org-string">'testlib_InterfaceClass_do_not_exist'</span> <span class="org-keyword">not</span> found
</pre>
</div>

<p>
<b>Load std::vector&lt;double&gt; and Linalg namespace wrapper functions</b>
</p>

<p>
Set up the std::vector&lt;double&gt; functions to be imported.
</p>

<ul class="org-ul">
<li>Note: hVectorD =&gt; Handle for std::vector&lt;double&gt; is the same as
void* or an opaque pointer.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Funciton: hVectorD testlib_vectorD_make0(size_t n, double x)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Set function arguments</span>
<span class="org-variable-name">lib.testlib_vectorD_make0.argtypes</span> = [ctypes.c_int, ctypes.c_double]
<span class="org-comment-delimiter"># </span><span class="org-comment">Set return type </span>
<span class="org-variable-name">lib.testlib_vectorD_make0.restype</span>  = ctypes.c_void_p

<span class="org-comment-delimiter"># </span><span class="org-comment">void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv)</span>
<span class="org-variable-name">lib.testlib_vectorD_Linalg_printVector.argtypes</span> = [ctypes.POINTER(ctypes.c_char), ctypes.c_void_p ]
<span class="org-variable-name">lib.testlib_vectorD_Linalg_printVector.restype</span> = <span class="org-constant">None</span> 

<span class="org-comment-delimiter"># </span><span class="org-comment">Set vector elements hv[n] = x</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">void testlib_vectorD_set(hVectorD hv, size_t n, double x)</span>
<span class="org-variable-name">lib.testlib_vectorD_set.argtypes</span> = [ctypes.c_void_p, ctypes.c_int, ctypes.c_double]
<span class="org-variable-name">lib.testlib_vectorD_set.restype</span>  = <span class="org-constant">None</span>
</pre>
</div>

<p>
Testing C-interface functions for std::vector&lt;double&gt;: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Creating a std::vector&lt;double&gt; with 4 elements equal to 3.0 </span>
&gt;&gt;&gt; <span class="org-variable-name">vec1</span> = lib.testlib_vectorD_make0(4, 3.0)

<span class="org-comment-delimiter"># </span><span class="org-comment">This number is the memory address held by the opaque pointer,</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">it cannot be used directly. </span>
&gt;&gt;&gt; vec1
2319184200912
&gt;&gt;&gt;
<span class="org-comment-delimiter"># </span><span class="org-comment">========== Modify vector elements ======== #</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Printarray2 the wrapped std::vector&lt;double&gt;</span>
&gt;&gt;&gt; lib.testlib_vectorD_Linalg_printVector(<span class="org-string">"vec1"</span>.encode(<span class="org-string">'utf-8'</span>), vec1)
<span class="org-variable-name">vec1</span> = [4]( 3, 3, 3, 3,  )
&gt;&gt;&gt;

&gt;&gt;&gt; lib.testlib_vectorD_set(vec1, 0, 5.0)
&gt;&gt;&gt; lib.testlib_vectorD_set(vec1, 1, 10.5)
&gt;&gt;&gt; lib.testlib_vectorD_set(vec1, 2, 4.78)

&gt;&gt;&gt; lib.testlib_vectorD_Linalg_printVector(<span class="org-string">"vec1"</span>.encode(<span class="org-string">'utf-8'</span>), vec1)
<span class="org-variable-name">vec1</span> = [4]( 5, 10.5, 4.78, 3,  )
</pre>
</div>

<p>
Compute vector Euclidian norm: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Wrapper for function </span>
<span class="org-comment-delimiter"># </span><span class="org-comment">double Linalg::norm(const std::vector&lt;double&gt;&amp; xs)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">double testlib_vectorD_Linalg_norm(hVectorD hv)</span>
<span class="org-variable-name">lib.testlib_vectorD_Linalg_norm.argtypes</span> = [ ctypes.c_void_p ]
<span class="org-variable-name">lib.testlib_vectorD_Linalg_norm.restype</span>  = ctypes.c_double

&gt;&gt;&gt; lib.testlib_vectorD_Linalg_printVector(<span class="org-string">"vec1"</span>.encode(<span class="org-string">'utf-8'</span>), vec1)
<span class="org-variable-name">vec1</span> = [4]( 5, 10.5, 4.78, 3,  )

&gt;&gt;&gt; lib.testlib_vectorD_Linalg_norm(vec1)
12.926654632966722

<span class="org-comment-delimiter"># </span><span class="org-comment">Check if calculations are right </span>
&gt;&gt;&gt; math.sqrt(5 * 5 + 10.5 * 10.5 + 4.78 * 4.78 + 3 * 3)
12.926654632966722
&gt;&gt;&gt;
</pre>
</div>

<p>
Delete vector vec1 using its destructor function: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Function: void testlib_vectorD_delete(hVectorD hv)</span>
<span class="org-variable-name">lib.testlib_vectorD_delete.argtypes</span> = [ ctypes.c_void_p ]
<span class="org-variable-name">lib.testlib_vectorD_delete.restype</span> = <span class="org-constant">None</span>

&gt;&gt;&gt; lib.testlib_vectorD_delete(vec1)
</pre>
</div>

<p>
<b>Load wrapper function for interface class InterfaceClass</b>
</p>

<p>
Load factory function: 
</p>
<ul class="org-ul">
<li>void* teslib_InterfaceClass_factory(const char* class_id)</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">InterfaceClass* teslib_InterfaceClass_factory(const char* class_id)</span>
<span class="org-variable-name">lib.teslib_InterfaceClass_factory.argtypes</span> = [ ctypes.POINTER(ctypes.c_char) ]
<span class="org-variable-name">lib.teslib_InterfaceClass_factory.restype</span>  = ctypes.c_void_p

<span class="org-comment-delimiter"># </span><span class="org-comment">const char* testlib_InterfaceClass_getID(InterfaceClass* hinst)</span>
<span class="org-variable-name">lib.testlib_InterfaceClass_getID.argtypes</span> = [ ctypes.c_void_p ]
<span class="org-variable-name">lib.testlib_InterfaceClass_getID.restype</span>  = ctypes.POINTER(ctypes.c_char)
</pre>
</div>

<p>
Creating class instances and testing member function C-wrappers:
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-variable-name">hinstA</span> = lib.teslib_InterfaceClass_factory(<span class="org-string">"ImplementationA"</span>.encode(<span class="org-string">'utf-8'</span>))
&gt;&gt;&gt; hinstA
2319184196864
&gt;&gt;&gt;

&gt;&gt;&gt; <span class="org-variable-name">hinstB</span> = lib.teslib_InterfaceClass_factory(<span class="org-string">"ImplementationB"</span>.encode(<span class="org-string">'utf-8'</span>))
&gt;&gt;&gt; hinstB
2319184198016

&gt;&gt;&gt; <span class="org-variable-name">s1</span> = lib.testlib_InterfaceClass_getID(hinstA)
&gt;&gt;&gt; s1
&lt;ctypes.LP_c_char <span class="org-builtin">object</span> at 0x0000021BFBBF14C8&gt;
&gt;&gt;&gt; ctypes.string_at(s1)
b<span class="org-string">'ImplementationA'</span>
&gt;&gt;&gt;

&gt;&gt;&gt; <span class="org-variable-name">s2</span> = lib.testlib_InterfaceClass_getID(hinstB)
&gt;&gt;&gt; ctypes.string_at(s2)
b<span class="org-string">'ImplementationB'</span>

&gt;&gt;&gt; ctypes.string_at(lib.testlib_InterfaceClass_getID(hinstB))
b<span class="org-string">'ImplementationB'</span>
&gt;&gt;&gt;
</pre>
</div>

<p>
Load more C-wrappers for member function of class InterfaceClass:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">const char* testlib_InterfaceClass_getName(InterfaceClass* hinst) </span>
<span class="org-variable-name">lib.testlib_InterfaceClass_getName.argtypes</span> = [ ctypes.c_void_p ]
<span class="org-variable-name">lib.testlib_InterfaceClass_getName.restype</span>  = ctypes.POINTER(ctypes.c_char)

<span class="org-comment-delimiter"># </span><span class="org-comment">void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name)</span>
&gt;&gt;&gt; <span class="org-variable-name">lib.testlib_InterfaceClass_setName.argtypes</span> = [ ctypes.c_void_p, ctypes.POINTER(ctypes.c_char) ]
&gt;&gt;&gt; <span class="org-variable-name">lib.testlib_InterfaceClass_setName.restype</span> = <span class="org-constant">None</span>

&gt;&gt;&gt; lib.testlib_InterfaceClass_getName(hinstA)
&lt;ctypes.LP_c_char <span class="org-builtin">object</span> at 0x0000021BFBBF1548&gt;

&gt;&gt;&gt; ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstA))
b<span class="org-string">'Unammed-A'</span>

&gt;&gt;&gt; ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstB))
b<span class="org-string">'Unammed-B'</span>

&gt;&gt;&gt; lib.testlib_InterfaceClass_setName(hinstA, <span class="org-string">"Instance-ClassA1"</span>.encode(<span class="org-string">'utf-8'</span>))
&gt;&gt;&gt; ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstA))
b<span class="org-string">'Instance-ClassA1'</span>

&gt;&gt;&gt; lib.testlib_InterfaceClass_setName(hinstB, <span class="org-string">"Instance-B1"</span>.encode(<span class="org-string">'utf-8'</span>))
&gt;&gt;&gt; ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstB))
b<span class="org-string">'Instance-B1'</span>

</pre>
</div>

<p>
Load C-functions wrappers for the InterfaceClass destructor and
dispose both instances hinstA and hinstB: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Destructor function:</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">void testlib_InterfaceClass_delete(InterfaceClass* hinst)</span>
&gt;&gt;&gt; <span class="org-variable-name">lib.testlib_InterfaceClass_delete.argtypes</span> = [ ctypes.c_void_p ]
&gt;&gt;&gt; <span class="org-variable-name">lib.testlib_InterfaceClass_delete.restype</span>  = <span class="org-constant">None</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Dispose class hinstA, delete this object </span>
&gt;&gt;&gt; lib.testlib_InterfaceClass_delete(hinstA)
 [INFO] ImplementationA <span class="org-variable-name">deleted</span> =&gt; <span class="org-variable-name">name</span> = Instance-ClassA1 ; <span class="org-builtin">type</span> = ImplementationA

&gt;&gt;&gt; lib.testlib_InterfaceClass_delete(hinstB)
 [INFO] ImplementationB <span class="org-variable-name">deleted</span> =&gt; <span class="org-variable-name">name</span> = Instance-B1 ; <span class="org-builtin">type</span> = ImplementationB
</pre>
</div>

<p>
Exit python3 REPL:
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-constant">exit</span>()
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the <span class="org-variable-name">process</span> =&gt; <span class="org-variable-name">PID</span> = 4280
<span class="org-function-name">testlib.cpp</span>:49: &lt;DllMain&gt; =&gt; DLL attached
 [StaticObject] =&gt; Shutdown DLL
</pre>
</div>
</div>
</div>

<div id="outline-container-org772e24a" class="outline-4">
<h4 id="org772e24a"><span class="section-number-4">1.3.12</span> Python 3 Client Code - Wrapper Module</h4>
<div class="outline-text-4" id="text-1-3-12">
<p>
All the boilerplate code required to load the shared library
testlib.dll can be eliminated by crafting a python module file and
wrapper classes.
</p>

<p>
Source:
</p>
<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/pywrapper.py">file:src/dlls/example-windows1/pywrapper.py</a></li>
<li>Gist: <a href="https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71">Gisthub</a></li>
</ul>


<p>
<b>Module Initialization:</b>
</p>

<ul class="org-ul">
<li>File: pywrapper.py</li>
</ul>

<p>
The function _config initializes the wrapper module, loading the DLL -
share library testlib.dll into the current Python3 interpreter process
and setting up the C-functions (functions exported with C-linkage,
without name mangling) exported by the library.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> ctypes

<span class="org-keyword">def</span> <span class="org-function-name">_getSharedLibrary</span>(libname):
    <span class="org-keyword">import</span> sys
    <span class="org-keyword">import</span> os
    <span class="org-variable-name">libfile</span> = libname 
    <span class="org-keyword">if</span> sys.platform == <span class="org-string">"linux"</span> <span class="org-keyword">or</span> sys.platform == <span class="org-string">"linux2"</span>:
        <span class="org-variable-name">libfile</span> = <span class="org-string">"lib"</span> + libname + <span class="org-string">".so"</span>
    <span class="org-keyword">elif</span> sys.platform == <span class="org-string">"darwin"</span>:
        <span class="org-variable-name">libfile</span> =  libname + <span class="org-string">".dylyb"</span>
    <span class="org-keyword">elif</span>  sys.platform == <span class="org-string">"win32"</span>:
        <span class="org-variable-name">libfile</span> = libname + <span class="org-string">".dll"</span>
    <span class="org-variable-name">libpath</span> = os.path.join(os.path.dirname(__file__), libfile)
    <span class="org-keyword">print</span>(<span class="org-string">" [INFO] libpath = "</span> + libpath)
    <span class="org-keyword">return</span> libpath

<span class="org-comment-delimiter"># </span><span class="org-comment">_lib = ctypes.cdll.LoadLibrary("testlib")</span>
<span class="org-variable-name">_lib</span> = ctypes.cdll.LoadLibrary(_getSharedLibrary(<span class="org-string">"testlib"</span>))

<span class="org-comment-delimiter"># </span><span class="org-comment">Startup ctypes FFI - Foreign Function Interface </span>
<span class="org-keyword">def</span> <span class="org-function-name">_config</span>():
    <span class="org-keyword">print</span>(<span class="org-string">"Intializing library"</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">======= std::vector&lt;double&gt; and Linalg:: namespace ==========##</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">hVectorD testlib_vectorD_make0(size_t n, double x)</span>
    <span class="org-variable-name">_lib.testlib_vectorD_make0.argtypes</span> = [ctypes.c_int, ctypes.c_double]
    <span class="org-variable-name">_lib.testlib_vectorD_make0.restype</span>  = ctypes.c_void_p

    <span class="org-comment-delimiter"># </span><span class="org-comment">hVectorD testlib_vectorD_make1(size_t n, double array [])</span>
    <span class="org-variable-name">_lib.testlib_vectorD_make1.argtypes</span> = [ctypes.c_int, ctypes.POINTER(ctypes.c_double)]
    <span class="org-variable-name">_lib.testlib_vectorD_make1.restype</span>  = ctypes.c_void_p    

_config()
</pre>
</div>

<p>
The class VectorD is a wrapper class for the STL class
std::vector&lt;double&gt; and the namespace Linalg containing linear algebra
functions. 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">VectorD</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, handle):
        <span class="org-keyword">self</span>.hnd = ctypes.c_void_p(handle)
        <span class="org-keyword">self</span>.name = <span class="org-string">"std::vector&lt;double&gt; vx"</span>

    <span class="org-type">@classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">fromValue</span>(cls, size, x):
        <span class="org-keyword">return</span> VectorD(_lib.testlib_vectorD_make0(size, x))

    <span class="org-type">@classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">fromArray</span>(cls, array):
        <span class="org-variable-name">carray_size_n</span> = ctypes.c_double * <span class="org-builtin">len</span>(array)
        <span class="org-keyword">return</span> VectorD(_lib.testlib_vectorD_make1(<span class="org-builtin">len</span>(array), carray_size_n(*array)))

    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructor </span>
    <span class="org-keyword">def</span> <span class="org-function-name">__del__</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">print</span>(<span class="org-string">" [TRACE] - Vector disposed - C++ Destructor invoked Ok."</span>)
        _lib.testlib_vectorD_delete(<span class="org-keyword">self</span>.hnd)

    <span class="org-keyword">def</span> <span class="org-function-name">setName</span>(<span class="org-keyword">self</span>, name):
        <span class="org-keyword">self</span>.name = name

    <span class="org-comment-delimiter"># </span><span class="org-comment">Display vector </span>
    <span class="org-keyword">def</span> <span class="org-function-name">disp</span>(<span class="org-keyword">self</span>):
        _lib.testlib_vectorD_Linalg_printVector(<span class="org-keyword">self</span>.name.encode(<span class="org-string">'utf-8'</span>), <span class="org-keyword">self</span>.hnd)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Set element at nth position </span>
    <span class="org-keyword">def</span> <span class="org-function-name">set</span>(<span class="org-keyword">self</span>, idx, x):
        _lib.testlib_vectorD_set(<span class="org-keyword">self</span>.hnd, idx, x)

    <span class="org-keyword">def</span> <span class="org-function-name">norm</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> _lib.testlib_vectorD_Linalg_norm(<span class="org-keyword">self</span>.hnd)
</pre>
</div>

<p>
The class CPPInterfaceClass is a wrapper for the C++ interface class
InterfaceClass exported by the DLL. The python wrapper class contains
factory methods .factory, .makeA for loading the implementation class
ImplementationA and the method .makeB for loading the implementation
ImplementationB. 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Proxy for C++ Interface class in the shared library </span>
<span class="org-keyword">class</span> <span class="org-type">CPPInterfaceClass</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">Constructor </span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, handle):
        <span class="org-keyword">self</span>.hnd = ctypes.c_void_p(handle)

    <span class="org-comment-delimiter"># </span><span class="org-comment">Destructor </span>
    <span class="org-keyword">def</span> <span class="org-function-name">__del__</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">Call C++ destructor</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">print(" [__del__] =&gt; self.hnd = " + str(self.hnd))</span>
        _lib.testlib_InterfaceClass_delete(<span class="org-keyword">self</span>.hnd)

    <span class="org-type">@classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">factory</span>(cls, classID):
        <span class="org-keyword">return</span> CPPInterfaceClass(_lib.teslib_InterfaceClass_factory(classID.encode(<span class="org-string">'utf-8'</span>)))

    <span class="org-type">@classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">makeA</span>(cls):              
        <span class="org-doc">"Instantiate the class ImplementationA from the DLL."</span>
        <span class="org-keyword">return</span> CPPInterfaceClass.factory(<span class="org-string">"ImplementationA"</span>)

    <span class="org-type">@classmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">makeB</span>(cls):              
        <span class="org-doc">"Instantiate the class ImplementationB from the DLL."</span>
        <span class="org-keyword">return</span> CPPInterfaceClass.factory(<span class="org-string">"ImplementationB"</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">getType</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> ctypes.string_at(_lib.testlib_InterfaceClass_getID(<span class="org-keyword">self</span>.hnd)).decode(<span class="org-string">'utf-8'</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">getName</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> ctypes.string_at(_lib.testlib_InterfaceClass_getName(<span class="org-keyword">self</span>.hnd)).decode(<span class="org-string">'utf-8'</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">setName</span>(<span class="org-keyword">self</span>, name):
        _lib.testlib_InterfaceClass_setName(<span class="org-keyword">self</span>.hnd, name.encode(<span class="org-string">'utf-8'</span>))

    <span class="org-comment-delimiter"># </span><span class="org-comment">String representation </span>
    <span class="org-keyword">def</span> <span class="org-function-name">__str__</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">s</span>   = <span class="org-string">"CInterfaceClass ; type = "</span> + <span class="org-keyword">self</span>.getType()
        <span class="org-variable-name">s</span> +=  <span class="org-string">" - name =  "</span> + <span class="org-keyword">self</span>.getName() + <span class="org-string">"\n"</span>
        <span class="org-keyword">return</span> s

    <span class="org-comment-delimiter"># </span><span class="org-comment">Make class printable in the REPL</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__repr__</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.__str__()    
</pre>
</div>

<p>
Function test1() runs an example code:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">test1</span>():
    <span class="org-keyword">print</span>(<span class="org-string">"\n ========  Test 1 - std::vector&lt;double&gt; wrapper and Linalg module ======"</span>)
    <span class="org-variable-name">v1</span> = VectorD.fromValue(4, 3.5)
    <span class="org-keyword">print</span>(<span class="org-string">" [*]=&gt; Before changing std::vector&lt;double&gt; object"</span>)
    v1.disp()
    <span class="org-keyword">print</span>(<span class="org-string">"v1.norm() = "</span> + <span class="org-builtin">str</span>(v1.norm()))
    <span class="org-keyword">print</span>()
    <span class="org-keyword">print</span>(<span class="org-string">" [*]=&gt; After changing std::vector&lt;double&gt; object"</span>)
    v1.<span class="org-builtin">set</span>(0, 5); v1.<span class="org-builtin">set</span>(1, 2.6); v1.<span class="org-builtin">set</span>(2, 9.81); v1.<span class="org-builtin">set</span>(3, 3.76)
    v1.disp()
    <span class="org-keyword">print</span>(<span class="org-string">"v1.norm() "</span> + <span class="org-builtin">str</span>(v1.norm()))
    <span class="org-keyword">print</span>()

    <span class="org-keyword">print</span>(<span class="org-string">"\n ========  Interface class 'InterfaceClass' ======"</span>)
    <span class="org-variable-name">clsA</span> = CPPInterfaceClass.makeA()
    <span class="org-keyword">print</span>(<span class="org-string">"clsA = "</span> + <span class="org-builtin">str</span>(clsA))
    <span class="org-keyword">print</span>(<span class="org-string">"clsA.getType() = "</span> + clsA.getType())

    <span class="org-variable-name">clsB</span> = CPPInterfaceClass.makeB()
    <span class="org-keyword">print</span>(<span class="org-string">"clsB = "</span> + <span class="org-builtin">str</span>(clsB))
    <span class="org-keyword">print</span>(<span class="org-string">"clsB.getType() = "</span> + clsB.getType())    

<span class="org-keyword">if</span> <span class="org-builtin">__name__</span> == <span class="org-string">"__main__"</span>:    
    test1()

</pre>
</div>

<p>
<b>Usage in Python3 REPL:</b>
</p>

<p>
This step assumes that the shared library file (testlib.dll on Windows
or libtestlib.so on Unix-like OS or Linux) is in the same directory as
the python script pywrapper.py.
</p>

<ul class="org-ul">
<li>Import module</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">$ C:/Users/archbox/Miniconda3/pkgs/python-3.6.5-h0c2934d_0/python
Python 3.6.5 |Anaconda, Inc.| (default, Mar 29 2018, 13:32:41) [MSC v.1900 64 bit (AMD64)] on win32
Type <span class="org-string">"help"</span>, <span class="org-string">"copyright"</span>, <span class="org-string">"credits"</span> <span class="org-keyword">or</span> <span class="org-string">"license"</span> <span class="org-keyword">for</span> more information.
&gt;&gt;&gt;

&gt;&gt;&gt; <span class="org-keyword">from</span> testlib <span class="org-keyword">import</span> VectorD
 [StaticObject] =&gt; Initialize DLL
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the <span class="org-variable-name">process</span> =&gt; <span class="org-variable-name">PID</span> = 5776
<span class="org-function-name">testlib.cpp</span>:45: &lt;DllMain&gt; DLL attached to process.
Intializing library
Library initialized OK.

&gt;&gt;&gt; <span class="org-keyword">from</span> testlib <span class="org-keyword">import</span> CPPInterfaceClass
</pre>
</div>

<ul class="org-ul">
<li>Testing class VectorD - wrapper for std::vector&lt;double&gt;</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-variable-name">v1</span> = VectorD.fromValue(5, 3.0)
&gt;&gt;&gt; v1.disp()
<span class="org-function-name">std</span>::vector&lt;double&gt; <span class="org-variable-name">vx</span> = [5]( 3, 3, 3, 3, 3,  )

&gt;&gt;&gt; v1.setName(<span class="org-string">"v1"</span>)
&gt;&gt;&gt; v1.disp()
<span class="org-variable-name">v1</span> = [5]( 3, 3, 3, 3, 3,  )

&gt;&gt;&gt; v1.norm()
6.708203932499369

&gt;&gt;&gt; v1.<span class="org-builtin">set</span>(0, 5)
&gt;&gt;&gt; v1.<span class="org-builtin">set</span>(1, 4.5)
&gt;&gt;&gt; v1.<span class="org-builtin">set</span>(2, 9.8)
&gt;&gt;&gt; v1.<span class="org-builtin">set</span>(3, 18.4)

&gt;&gt;&gt; v1.disp()
<span class="org-variable-name">v1</span> = [5]( 5, 4.5, 9.8, 18.4, 3,  )
&gt;&gt;&gt;
&gt;&gt;&gt; v1.norm()
22.10995251012539

&gt;&gt;&gt; <span class="org-variable-name">v1</span> = 100
 [TRACE] - Vector disposed - C++ Destructor invoked Ok.

&gt;&gt;&gt; <span class="org-variable-name">v2</span> = VectorD.fromArray([4.0, 10.25, 9.6, 3, 10, 6, 15])
&gt;&gt;&gt; v2.disp()
<span class="org-function-name">std</span>::vector&lt;doubl&gt; <span class="org-variable-name">vx</span> = [7]( 4, 10.25, 9.6, 3, 10, 6, 15,  )

&gt;&gt;&gt; v2.norm()
24.15

&gt;&gt;&gt; v2.<span class="org-builtin">set</span>(0, 100)
&gt;&gt;&gt; v2.<span class="org-builtin">set</span>(1, 200)

&gt;&gt;&gt; v2.disp()
<span class="org-function-name">std</span>::vector&lt;double&gt; <span class="org-variable-name">vx</span> = [7]( 100, 200, 9.6, 3, 10, 6, 15,  )

&gt;&gt;&gt; v2.norm()
224.63784186997523
&gt;&gt;&gt;

</pre>
</div>

<ul class="org-ul">
<li>Testing class CPPInterfaceClass, proxy for C++ classes
InterfaceClass, ImplementationA and ImplementationB.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-keyword">from</span> testlib <span class="org-keyword">import</span> CPPInterfaceClass

<span class="org-comment-delimiter"># </span><span class="org-comment">======== Load ImplementationA  ============== # </span>
<span class="org-comment-delimiter">#</span>
&gt;&gt;&gt; <span class="org-variable-name">a</span> = CPPInterfaceClass.makeA()
&gt;&gt;&gt; a
CInterfaceClass ; <span class="org-builtin">type</span> = ImplementationA - <span class="org-variable-name">name</span> =  Unammed-A

&gt;&gt;&gt; a.getType()
<span class="org-string">'ImplementationA'</span>
&gt;&gt;&gt; a.getName()
<span class="org-string">'Unammed-A'</span>
&gt;&gt;&gt; a.setName(<span class="org-string">"Instance-of-ImplA"</span>)
&gt;&gt;&gt; a
CInterfaceClass ; <span class="org-builtin">type</span> = ImplementationA - <span class="org-variable-name">name</span> =  Instance-of-ImplA

<span class="org-comment-delimiter"># </span><span class="org-comment">======== Load ImplementationB  ============== # </span>
<span class="org-comment-delimiter">#</span>
&gt;&gt;&gt; <span class="org-variable-name">b</span> = CPPInterfaceClass.makeB()
&gt;&gt;&gt; b
CInterfaceClass ; <span class="org-builtin">type</span> = ImplementationB - <span class="org-variable-name">name</span> =  Unammed-B

&gt;&gt;&gt; b.setName(<span class="org-string">"Instance-of-class-B"</span>)
&gt;&gt;&gt; b.getName()
<span class="org-string">'Instance-of-class-B'</span>
&gt;&gt;&gt;
&gt;&gt;&gt; b.getType()
<span class="org-string">'ImplementationB'</span>

</pre>
</div>

<ul class="org-ul">
<li>Exit REPL.</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-constant">exit</span>()
 [TRACE] - Vector disposed - C++ Destructor invoked Ok.
 [INFO] ImplementationB <span class="org-variable-name">deleted</span> =&gt; <span class="org-variable-name">name</span> = Instance-of-<span class="org-keyword">class</span>-B ; <span class="org-builtin">type</span> = ImplementationB
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the <span class="org-variable-name">process</span> =&gt; <span class="org-variable-name">PID</span> = 5776
<span class="org-function-name">testlib.cpp</span>:49: &lt;DllMain&gt; =&gt; DLL attached
 [StaticObject] =&gt; Shutdown DLL
</pre>
</div>
</div>
</div>

<div id="outline-container-orgda1a9da" class="outline-4">
<h4 id="orgda1a9da"><span class="section-number-4">1.3.13</span> CSharp Client Code - PInvoke</h4>
<div class="outline-text-4" id="text-1-3-13">
<p>
The services provided by the DLL can be consumed from C# or any other
.NET language via Pinvoke-API which is the Foreign-Function Interface
of .NET platform. The Pinvoke API can import C-function or C++
demangled functions exported with extern "C". 
</p>

<p>
C++ classes, namespaces and functions without C-linkage (extern "C")
cannot be loaded directly by P-Invoke or any other Foreign
Function-Interface as C++ does not define a standard and ABI -
Application Binary Interface, every compiler has its own name mangling
schema, padding bytes and class memory layout for non-POD (Plain-Old
data) types. A workaround to call C++ from an FFI is to defined
C-interface comprised of functions with C-linkage and opaque pointers
(void*) for passing class instances around or invoking C++ functions.
</p>

<p>
File: <a href="https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71#file-client-csharp-cs">client-sharp.cs</a>
</p>

<p>
Compiling and running:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ csc.exe client-csharp.cs &amp;&amp; client-csharp.exe
</pre>
</div>

<p>
Wrapper for class std::vector&lt;double&gt; and namespace Linalg.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">VectorD</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Constructor Function:</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">hVectorD testlib_vectorD_make0(size_t n, double x)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">void* testlib_vectorD_make0(size_t n, double x)</span>
        <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">DllImport</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"testlib.dll"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span>
        <span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-keyword">extern</span>
        IntPtr testlib_vectorD_make0<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">size</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">DllImport</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"testlib.dll"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span>
        <span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-keyword">extern</span>
        IntPtr testlib_vectorD_make1<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">[]</span> x<span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Destructor function:</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">void testlib_vectorD_delete(hVectorD hv)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">void testlib_vectorD_delete(void* hv)</span>
        <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">DllImport</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"testlib.dll"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span>
        <span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-keyword">extern</span>
        IntPtr testlib_vectorD_delete<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IntPtr</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">void testlib_vectorD_Linalg_printVector(const char* name, vector* hv)</span>
        <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">DllImport</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"testlib.dll"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span>
        <span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-keyword">extern</span>
        <span class="org-type">void</span> testlib_vectorD_Linalg_printVector<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">string</span> <span class="org-variable-name">name</span>, <span class="org-type">IntPtr</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">double testlib_vectorD_Linalg_norm(hVectorD hv)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">double testlib_vectorD_Linalg_norm(void* hv)</span>
        <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">DllImport</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"testlib.dll"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span>
        <span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-keyword">extern</span>
        <span class="org-type">double</span> testlib_vectorD_Linalg_norm<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IntPtr</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">void testlib_vectorD_set(hVectorD hv, size_t n, double x)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">void testlib_vectorD_set(void* hv, size_t n, double x)</span>
        <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">DllImport</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"testlib.dll"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span>
        <span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-keyword">extern</span>
        <span class="org-type">void</span> testlib_vectorD_set<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IntPtr</span> <span class="org-variable-name">hv</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">------------ Objet Oriented Wrapper --------//</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Hadle </span>
        <span class="org-keyword">private</span> IntPtr m_handle;

        <span class="org-keyword">public</span> VectorD<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">size</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span>
                m_handle = testlib_vectorD_make0<span class="org-rainbow-delimiters-depth-3">(</span>size, x<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">public</span> VectorD<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">[]</span> array<span class="org-rainbow-delimiters-depth-2">){</span>
                m_handle = testlib_vectorD_make1<span class="org-rainbow-delimiters-depth-3">(</span>array.Length, array<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>        
        <span class="org-comment-delimiter">// </span><span class="org-comment">Finalized destructor </span>
        ~<span class="org-function-name">VectorD</span><span class="org-rainbow-delimiters-depth-2">(){</span>
                testlib_vectorD_delete<span class="org-rainbow-delimiters-depth-3">(</span>m_handle<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">public</span> <span class="org-type">void</span> print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">string</span> <span class="org-variable-name">name</span> = <span class="org-string">"std::vector&lt;double&gt;"</span><span class="org-rainbow-delimiters-depth-2">){</span>
                testlib_vectorD_Linalg_printVector<span class="org-rainbow-delimiters-depth-3">(</span>name, m_handle<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">public</span> <span class="org-type">void</span> set<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span>
                testlib_vectorD_set<span class="org-rainbow-delimiters-depth-3">(</span>m_handle, n, x<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">public</span> <span class="org-type">double</span> norm<span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-keyword">return</span> testlib_vectorD_Linalg_norm<span class="org-rainbow-delimiters-depth-3">(</span>m_handle<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Wrapper for C++ interface class 'InterfaceClass' and its
implementations, class ImplementationA and ImplementationB:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">CPPInterfaceClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Handle type =&gt; Opaque pointer for InterfaceClass instances.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">using HInterf = IntPtr;</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Factory function for loading functions from this interface.</span>
        <span class="org-comment-delimiter">//</span><span class="org-comment">-----------------------------------------------------------</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">InterfaceClass* teslib_InterfaceClass_factory(const char* class_id)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">void** teslib_InterfaceClass_factory(const char* class_id)</span>
        <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">DllImport</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"testlib.dll"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span>
        <span class="org-keyword">private</span> <span class="org-keyword">static</span> <span class="org-keyword">extern</span>
        IntPtr teslib_InterfaceClass_factory<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">string</span> <span class="org-variable-name">class_id</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">void testlib_InterfaceClass_delete(InterfaceClass* hinst)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">void testlib_InterfaceClass_delete(void*)</span>
        <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">DllImport</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"testlib.dll"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span>
        <span class="org-keyword">private</span> <span class="org-keyword">static</span> <span class="org-keyword">extern</span>
        <span class="org-type">void</span> testlib_InterfaceClass_delete<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IntPtr</span> <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">char* testlib_InterfaceClass_getID(InterfaceClass* hinst)</span>
        <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">DllImport</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"testlib.dll"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span>        
        <span class="org-keyword">private</span> <span class="org-keyword">static</span> <span class="org-keyword">extern</span> IntPtr testlib_InterfaceClass_getID<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IntPtr</span> <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name)</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Note: Charset.UNICODE does not work as it is UTF16 (Wide Unicode), not UTF-8</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">which is the C++ default unicode type.</span>
        <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">DllImport</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"testlib.dll"</span>, CharSet = CharSet.Ansi<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span>
        <span class="org-keyword">private</span> <span class="org-keyword">static</span> <span class="org-keyword">extern</span>
        <span class="org-type">void</span> testlib_InterfaceClass_setName<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IntPtr</span> <span class="org-variable-name">hinst</span>, <span class="org-type">string</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">char* testlib_InterfaceClass_getName(InterfaceClass* hinst)</span>
        <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">DllImport</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"testlib.dll"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span>
        <span class="org-keyword">private</span> <span class="org-keyword">static</span> <span class="org-keyword">extern</span>
        IntPtr testlib_InterfaceClass_getName<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IntPtr</span> <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-keyword">private</span> IntPtr m_handle;

        <span class="org-keyword">private</span> CPPInterfaceClass<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IntPtr</span> <span class="org-variable-name">handle</span><span class="org-rainbow-delimiters-depth-2">){</span>
                m_handle = handle;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        ~<span class="org-function-name">CPPInterfaceClass</span><span class="org-rainbow-delimiters-depth-2">(){</span>
                testlib_InterfaceClass_delete<span class="org-rainbow-delimiters-depth-3">(</span>m_handle<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">/** </span><span class="org-comment">Creates an instance of the the C++ implementation ImplementationA (class) from the </span>
<span class="org-comment">         * C++ interface: 'InterfaceClass' </span>
<span class="org-comment">         */</span>
        <span class="org-keyword">public</span> <span class="org-keyword">static</span> CPPInterfaceClass ImplementationA<span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">CPPInterfaceClass</span><span class="org-rainbow-delimiters-depth-3">(</span>teslib_InterfaceClass_factory<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"ImplementationA"</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-comment-delimiter">/** </span><span class="org-comment">Creates an instance of the C++ implementationa ImplementationB (class) */</span>
        <span class="org-keyword">public</span> <span class="org-keyword">static</span> CPPInterfaceClass ImplementationB<span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">CPPInterfaceClass</span><span class="org-rainbow-delimiters-depth-3">(</span>teslib_InterfaceClass_factory<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"ImplementationB"</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Get type of the wrapped C++ class </span>
        <span class="org-keyword">public</span> string GetID<span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-type">IntPtr</span> <span class="org-variable-name">p</span> = testlib_InterfaceClass_getID<span class="org-rainbow-delimiters-depth-3">(</span>m_handle<span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-keyword">return</span> Marshal.PtrToStringAnsi<span class="org-rainbow-delimiters-depth-3">(</span>p<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Get/Set name of current instance </span>
        <span class="org-keyword">public</span> string Name
        <span class="org-rainbow-delimiters-depth-2">{</span>
                get<span class="org-rainbow-delimiters-depth-3">{</span>
                        <span class="org-type">IntPtr</span> <span class="org-variable-name">p</span> = testlib_InterfaceClass_getName<span class="org-rainbow-delimiters-depth-4">(</span>m_handle<span class="org-rainbow-delimiters-depth-4">)</span>;
                        <span class="org-keyword">return</span> Marshal.PtrToStringAnsi<span class="org-rainbow-delimiters-depth-4">(</span>p<span class="org-rainbow-delimiters-depth-4">)</span>;
                <span class="org-rainbow-delimiters-depth-3">}</span>
                set<span class="org-rainbow-delimiters-depth-3">{</span>
                        testlib_InterfaceClass_setName<span class="org-rainbow-delimiters-depth-4">(</span>m_handle, value<span class="org-rainbow-delimiters-depth-4">)</span>;
                <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Main function - Experiment 1:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" ===== EXPERIMENT 1 = Using C-functions directly =="</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [CSharp] Loading Native DLL C++ Shared Library"</span><span class="org-rainbow-delimiters-depth-1">)</span>;                
<span class="org-type">IntPtr</span> <span class="org-variable-name">vectorObject</span> = VectorD.testlib_vectorD_make0<span class="org-rainbow-delimiters-depth-1">(</span>5, 3.0<span class="org-rainbow-delimiters-depth-1">)</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [CSharp] Opaque pointer = "</span>, vectorObject.ToString<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
VectorD.testlib_vectorD_Linalg_printVector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"vectorX"</span>, vectorObject<span class="org-rainbow-delimiters-depth-1">)</span>;


<span class="org-type">double</span> <span class="org-variable-name">x</span> = VectorD.testlib_vectorD_Linalg_norm<span class="org-rainbow-delimiters-depth-1">(</span>vectorObject<span class="org-rainbow-delimiters-depth-1">)</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [CSharp] Vector norm = "</span> + x.ToString<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [CSharp] End application"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
VectorD.testlib_vectorD_delete<span class="org-rainbow-delimiters-depth-1">(</span>vectorObject<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">===== EXPERIMENT 1 = Using C-functions directly ==
 [CSharp] Loading Native DLL C++ Shared Library
 [StaticObject] =&gt; Initialize DLL
testlib.cpp:48: &lt;DllMain&gt; DLL Loaded into the process =&gt; PID = 1320
testlib.cpp:54: &lt;DllMain&gt; DLL attached to process.
 [CSharp] Opaque pointer = 
vectorX = [5]( 3, 3, 3, 3, 3,  )
 [CSharp] Vector norm = 6.70820393249937
 [CSharp] End application
</pre>
</div>

<ul class="org-ul">
<li>Main function - Experiment 2:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" ===== EXPERIMENT 2 = Using OOP wrapper for std::vector ==="</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" ==&gt; Before changing vector"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">VectorD</span> <span class="org-variable-name">v1</span> = <span class="org-keyword">new</span> <span class="org-type">VectorD</span><span class="org-rainbow-delimiters-depth-1">(</span>10, 3.5<span class="org-rainbow-delimiters-depth-1">)</span>;
v1.print<span class="org-rainbow-delimiters-depth-1">()</span>;
v1.print<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"vector_v1"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"v1.norm() = "</span> + v1.norm<span class="org-rainbow-delimiters-depth-2">()</span>.ToString<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" ==&gt; After changing vector"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
v1.set<span class="org-rainbow-delimiters-depth-1">(</span>1, 10.0<span class="org-rainbow-delimiters-depth-1">)</span>; v1.set<span class="org-rainbow-delimiters-depth-1">(</span>2, 5.53<span class="org-rainbow-delimiters-depth-1">)</span>; v1.set<span class="org-rainbow-delimiters-depth-1">(</span>3, 8.96<span class="org-rainbow-delimiters-depth-1">)</span>;
v1.set<span class="org-rainbow-delimiters-depth-1">(</span>4, -10.34<span class="org-rainbow-delimiters-depth-1">)</span>; v1.set<span class="org-rainbow-delimiters-depth-1">(</span>8, 80.54<span class="org-rainbow-delimiters-depth-1">)</span>;
v1.print<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"v1_changed"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" ==&gt; Creating Vector from Array"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">VectorD</span> <span class="org-variable-name">v2</span> = <span class="org-keyword">new</span> <span class="org-type">VectorD</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">[]</span> <span class="org-rainbow-delimiters-depth-2">{</span>4.5, -8.84, 78.23, 652.3, 34.56, 45.12<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
v2.print<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"v2"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"v2.norm() = "</span> + v2.norm<span class="org-rainbow-delimiters-depth-2">()</span>.ToString<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>


<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text"> ===== EXPERIMENT 2 = Using OOP wrapper for std::vector ===
 ==&gt; Before changing vector
std::vector&lt;double&gt; = [10]( 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5,  )
vector_v1 = [10]( 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5,  )
v1.norm() = 11.0679718105893
 ==&gt; After changing vector
v1_changed = [10]( 3.5, 10, 5.53, 8.96, -10.34, 3.5, 3.5, 3.5, 80.54, 3.5,  )
 ==&gt; Creating Vector from Array
v2 = [6]( 4.5, -8.84, 78.23, 652.3, 34.56, 45.12,  )
v2.norm() = 659.502711518307
</pre>
</div>

<ul class="org-ul">
<li>Main function - Experiment 3:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" ===== EXPERIMENT 3 = OOP wrapper for InterfaceClass  ==="</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">CPPInterfaceClass</span> <span class="org-variable-name">instA</span> = CPPInterfaceClass.ImplementationA<span class="org-rainbow-delimiters-depth-1">()</span>;
<span class="org-type">CPPInterfaceClass</span> <span class="org-variable-name">instB</span> = CPPInterfaceClass.ImplementationB<span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Console.WriteLine("instA.Name = " + instA.Name);</span>
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"instA.GetID() = "</span> + instA.GetID<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"instB.GetID() = "</span> + instB.GetID<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" **=&gt; Before changing"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"instA.Name = "</span> + instA.Name<span class="org-rainbow-delimiters-depth-1">)</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"instB.Name = "</span> + instB.Name<span class="org-rainbow-delimiters-depth-1">)</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n **=&gt; Before changing"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
instA.Name = <span class="org-string">"Instance-of-ImplA"</span>;
instB.Name = <span class="org-string">"Instance-of-ImplB"</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"instA.Name = "</span> + instA.Name<span class="org-rainbow-delimiters-depth-1">)</span>;
Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"instB.Name = "</span> + instB.Name<span class="org-rainbow-delimiters-depth-1">)</span>;

Console.WriteLine<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" ===== END  ==========================="</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text"> ===== EXPERIMENT 3 = OOP wrapper for InterfaceClass  ===
instA.GetID() = ImplementationA
instB.GetID() = ImplementationB
 **=&gt; Before changing
instA.Name = Unammed-A
instB.Name = Unammed-B

 **=&gt; Before changing
instA.Name = Instance-of-ImplA
instB.Name = Instance-of-ImplB
 ===== END  ===========================
testlib.cpp:48: &lt;DllMain&gt; DLL Loaded into the process =&gt; PID = 1320
testlib.cpp:62: &lt;DllMain&gt; DLL detached to thread.
 [INFO] ImplementationB deleted =&gt; name = Instance-of-ImplB ; type = ImplementationB
 [INFO] ImplementationA deleted =&gt; name = Instance-of-ImplA ; type = ImplementationA
testlib.cpp:48: &lt;DllMain&gt; DLL Loaded into the process =&gt; PID = 1320
testlib.cpp:58: &lt;DllMain&gt; =&gt; DLL attached
 [StaticObject] =&gt; Shutdown DLL
</pre>
</div>
</div>
</div>

<div id="outline-container-org4030acf" class="outline-4">
<h4 id="org4030acf"><span class="section-number-4">1.3.14</span> View symbols exported by the shared library</h4>
<div class="outline-text-4" id="text-1-3-14">
</div>
<ol class="org-ol">
<li><a id="org77b57c1"></a>View exported symbols on Windows (dumpbin)<br />
<div class="outline-text-5" id="text-1-3-14-1">
<p>
<b>Location of dumpbin tool</b>
</p>

<p>
The symbols exported by the DLL can viewed with the dumpbin tool
available from the MSVC developer console.
</p>

<div class="org-src-container">
<pre class="src src-sh">$ where dumpbin.exe
<span class="org-function-name">C</span>:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.12.25827\bin\Hostx64\x64\dumpbin.exe
</pre>
</div>

<p>
<b>Show DLL exported symbols</b>
</p>

<div class="org-src-container">
<pre class="src src-sh">$ dumpbin.exe /exports testlib.dll 
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-txt">Microsoft (R) COFF/PE Dumper Version 14.12.25835.0
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file testlib.dll

File Type: DLL

  Section contains the following exports for testlib.dll

    00000000 characteristics
    FFFFFFFF time date stamp
        0.00 version
           1 ordinal base
          31 number of functions
          31 number of names

    ordinal hint RVA      name

          1    0 00005C50 ??0SampleClass@@QEAA@AEBV0@@Z
          2    1 00001650 ??0SampleClass@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
          3    2 000015E0 ??0SampleClass@@QEAA@XZ
          4    3 000016E0 ??1SampleClass@@QEAA@XZ
          5    4 00007280 ??4SampleClass@@QEAAAEAV0@AEBV0@@Z
          6    5 00001880 ?get@SampleClass@@QEAAHXZ
          7    6 00001830 ?getName@SampleClass@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
          8    7 00001370 ?linTransform@Linalg@@YA?AV?$vector@NV?$allocator@N@std@@@std@@NNAEAV23@@Z
          9    8 000012D0 ?norm@Linalg@@YANAEBV?$vector@NV?$allocator@N@std@@@std@@@Z
         10    9 00001480 ?printVector@Linalg@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEAV?$vector@NV?$allocator@N@std@@@3@@Z
         11    A 000018A0 ?set@SampleClass@@QEAAXH@Z
         12    B 00001D50 DllMain
         13    C 00002720 entryPoint1
         14    D 00002800 main
         15    E 00001B10 teslib_InterfaceClass_factory
         16    F 00001C60 testlib_InterfaceClass_delete
         17   10 00001CC0 testlib_InterfaceClass_getID
         18   11 00001D20 testlib_InterfaceClass_getName
         19   12 00001CF0 testlib_InterfaceClass_setName
         20   13 00001A10 testlib_SampleClass_delete
         21   14 00001A60 testlib_SampleClass_get
         22   15 00001AB0 testlib_SampleClass_getName
         23   16 00001900 testlib_SampleClass_make0
         24   17 00001950 testlib_SampleClass_make1
         25   18 00001A80 testlib_SampleClass_set
         26   19 00001560 testlib_vectorD_Linalg_norm
         27   1A 00001580 testlib_vectorD_Linalg_printVector
         28   1B 000026D0 testlib_vectorD_delete
         29   1C 00002590 testlib_vectorD_make0
         30   1D 00002610 testlib_vectorD_make1
         31   1E 00002690 testlib_vectorD_set

  Summary

        3000 .data
        4000 .pdata
       18000 .rdata
        1000 .reloc
       2F000 .text
</pre>
</div>

<p>
Note that: 
</p>

<ul class="org-ul">
<li>Functions with C-linkage are not mangled, their symbols match
their names, for instance:</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"> 15    E 00001B10 teslib_InterfaceClass_factory
16    F 00001C60 testlib_InterfaceClass_delete
17   10 00001CC0 testlib_InterfaceClass_getID
18   11 00001D20 testlib_InterfaceClass_getName
19   12 00001CF0 testlib_InterfaceClass_setName
20   13 00001A10 testlib_SampleClass_delete
21   14 00001A60 testlib_SampleClass_get
22   15 00001AB0 testlib_SampleClass_getName
</pre>
</div>

<ul class="org-ul">
<li>Functions, member functions, namespaces and everything without
C-linkage are mangled, the compiler generate an unique name for the
generated symbols:</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"> 1    0 00005C50 ??0SampleClass@@QEAA@AEBV0@@Z
 2    1 00001650 ??0SampleClass@@QEAA@AEBV?$<span class="org-variable-name">basic_string</span>@DU?$<span class="org-variable-name">char_traits</span>@D@std@@V?$<span class="org-variable-name">allocator</span>@D@2@@std@@@Z
 3    2 000015E0 ??0SampleClass@@QEAA@XZ
 4    3 000016E0 ??1SampleClass@@QEAA@XZ
 5    4 00007280 ??4SampleClass@@QEAAAEAV0@AEBV0@@Z
 6    5 00001880 ?get@SampleClass@@QEAAHXZ
 7    6 00001830 ?getName@SampleClass@@QEBA?AV?$<span class="org-variable-name">basic_string</span>@DU?$<span class="org-variable-name">char_traits</span>@D@std@@V?$<span class="org-variable-name">allocator</span>@D@2@@std@@XZ
 8    7 00001370 ?linTransform@Linalg@@YA?AV?$<span class="org-variable-name">vector</span>@NV?$<span class="org-variable-name">allocator</span>@N@std@@@std@@NNAEAV23@@Z
 9    8 000012D0 ?norm@Linalg@@YANAEBV?$<span class="org-variable-name">vector</span>@NV?$<span class="org-variable-name">allocator</span>@N@std@@@std@@@Z
10    9 00001480 ?printVector@Linalg@@YAAEAV?$<span class="org-variable-name">basic_ostream</span>@DU?$<span class="org-variable-name">char_traits</span>@D@std@@@std@@AEAV23@AEAV?$<span class="org-variable-name">vector</span>@NV?$<span class="org-variable-name">allocator</span>@N@std@@@3@@Z
11    A 000018A0 ?set@SampleClass@@QEAAXH@Z
</pre>
</div>

<p>
It is possible to demangle those symbols with the tool - <a href="https://demangler.com/">https://demangler.com/</a>
</p>

<ul class="org-ul">
<li>Symbol: ??0SampleClass@@QEAA@AEBV0@@Z demangled:</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-function-name">public</span>: __cdecl SampleClass::SampleClass(class SampleClass const &amp; __ptr64) __ptr64
</pre>
</div>

<ul class="org-ul">
<li>Symbol: ?get@SampleClass@@QEAAHXZ demangled:</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-function-name">public</span>: int __cdecl SampleClass::get(void) __ptr64
</pre>
</div>

<ul class="org-ul">
<li>Symbol: ?linTransform@Linalg@@YA?AV?$vector@NV?$allocator@N@std@@@std@@NNAEAV23@@Z demangled:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>,<span class="org-keyword">class</span> <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">__cdecl</span> <span class="org-constant">Linalg</span>::<span class="org-function-name">linTransform</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span>,<span class="org-type">double</span>,<span class="org-keyword">class</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>,<span class="org-keyword">class</span> <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp; <span class="org-variable-name">__ptr64</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</li>

<li><a id="orgfac9545"></a>View exports symbols on Unix-like OSes (nm)<br />
<div class="outline-text-5" id="text-1-3-14-2">
<p>
View exported symbols with nm:
</p>

<ul class="org-ul">
<li>Note that only functions annotated with extern "C" such as
<span class="underline">teslib_InterfaceClass_factory</span> are not mangled.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ nm -D libtestlib.so 

000000000020a3d8 B __bss_start
                 U __cxa_atexit
                 w __cxa_finalize
                 U __cxa_pure_virtual
000000000020a3d8 D _edata
000000000020a440 B _end
000000000000710c T _fini
                 w __gmon_start__
... ...   ... ...   ... ...   ... ...   ... ... 
0000000000005512 T teslib_InterfaceClass_factory
0000000000005629 T testlib_InterfaceClass_delete
0000000000005656 T testlib_InterfaceClass_getID
00000000000056a8 T testlib_InterfaceClass_getName
0000000000005677 T testlib_InterfaceClass_setName
000000000000545c T testlib_SampleClass_delete
000000000000548f T testlib_SampleClass_get
00000000000054cc T testlib_SampleClass_getName

... ... ... ...   ... ... ... ... 

0000000000005076 T _ZN11SampleClassC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
0000000000005106 T _ZN11SampleClassC2Ev
0000000000005196 T _ZN11SampleClassD1Ev

</pre>
</div>

<p>
View exported symbols demangled (without name mangling):
</p>

<div class="org-src-container">
<pre class="src src-sh"> $ nm -CD libtestlib.so 
 000000000020a3d8 B __bss_start
                  U __cxa_atexit
                  w __cxa_finalize

  ... ... ...  ... ... ...  ... ... ...  ... ... ... 

 0000000000004fe7 T testlib_vectorD_Linalg_norm
 000000000000500f T testlib_vectorD_Linalg_printVector
 0000000000004e52 T testlib_vectorD_make0
 0000000000004ee2 T testlib_vectorD_make1
 0000000000004f80 T testlib_vectorD_set
                  U _Unwind_Resume
                  U operator delete(void*)
                  U operator delete(void*, unsigned long)
 00000000000052fe T SampleClass::get()
 0000000000005310 T SampleClass::set(int)

  ...  ...  ...  ...  ...  ...  ... 

 00000000000070ac W double* std::__copy_move&lt;false, true, std::random_access_iterator_tag&gt;::__copy_m&lt;double&gt;(double const*, double const*, double*)
 0000000000006cfe W void std::_Destroy_aux&lt;true&gt;::__destroy&lt;double*&gt;(double*, double*)
 0000000000006c74 W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_M_allocate(unsigned long)
 0000000000006a44 W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_Vector_impl::_Vector_impl(std::allocator&lt;double&gt; const&amp;)
 0000000000006a44 W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_Vector_impl::_Vector_impl(std::allocator&lt;double&gt; const&amp;)
 000000000000681a W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_Vector_impl::~_Vector_impl()
 000000000000681a W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_Vector_impl::~_Vector_impl()
 0000000000006ae8 W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_M_deallocate(double*, unsigned long)
 0000000000006a8e W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_M_create_storage(unsigned long)
 0000000000006926 W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_M_get_Tp_allocator()
 0000000000006836 W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_Vector_base(unsigned long, std::allocator&lt;double&gt; const&amp;)
 00000000000069d2 W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_Vector_base(std::allocator&lt;double&gt; const&amp;)
 0000000000006836 W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_Vector_base(unsigned long, std::allocator&lt;double&gt; const&amp;)
 00000000000069d2 W std::_Vector_base&lt;double, std::allocator&lt;double&gt; &gt;::_Vector_base(std::allocator&lt;double&gt; const&amp;)

... ... ... ... ... 

0000000000006706 W std::<span class="org-keyword">function</span>&lt;void ()&gt;::<span class="org-keyword">function</span>(std::<span class="org-keyword">function</span>&lt;void ()&gt; const&amp;)
0000000000006706 W std::<span class="org-keyword">function</span>&lt;void ()&gt;::<span class="org-keyword">function</span>(std::<span class="org-keyword">function</span>&lt;void ()&gt; const&amp;)
00000000000062b2 W std::<span class="org-keyword">function</span>&lt;void ()&gt;::~function()
00000000000062b2 W std::<span class="org-keyword">function</span>&lt;void ()&gt;::~function()
                 U std::ios_base::Init::Init()
                 U std::ios_base::Init::~Init()
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org3f50548" class="outline-3">
<h3 id="org3f50548"><span class="section-number-3">1.4</span> Return string from a C++ function to Python Ctypes</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Example: Create a function with C linkage or C-API which returns a
dynamically allocated string to the caller. 
</p>

<ul class="org-ul">
<li>Source:  <a href="https://gist.github.com/caiorss/fc0e628daf7bbb4e8484491856a07c38">Gist with all files</a></li>
</ul>

<p>
Necessary C-string functions: 
</p>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/c/experimental/dynamic/strdup">strdup</a></li>
<li><a href="https://en.cppreference.com/w/c/string/byte/strcpy">strcpy, strcpy_s</a></li>
<li><a href="http://www.cplusplus.com/reference/cstring/strlen/">strlen</a></li>
</ul>

<p>
Build shared library - DLL (cstr.so):
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ cstr.cpp -o <span class="org-keyword">cstr.so</span> -std=c++1z -O0 -g -shared -fPIC -std=c++1z 
</pre>
</div>

<p>
<b>File cstr.cpp</b> 
</p>

<p>
Headers: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstring</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>     <span class="org-comment-delimiter">// </span><span class="org-comment">std::strncpy</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#if</span> <span class="org-preprocessor">defined</span><span class="org-rainbow-delimiters-depth-1">(</span>_WIN32<span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">MS-Windows </span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">EXPORT_C</span>  <span class="org-keyword">extern</span> <span class="org-string">"C"</span> __declexpec<span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">#else</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Unix</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">EXPORT_C</span>  <span class="org-keyword">extern</span> <span class="org-string">"C"</span> 
<span class="org-preprocessor">#endif</span> 

</pre>
</div>

<p>
Function - version A: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-comment-delimiter">/** </span><span class="org-comment">Design 1: Buffer allocated by the caller.</span>
<span class="org-comment"> * @param[in]     x            Float point number </span>
<span class="org-comment"> * @param[in,out] buffer       Buffer allocated by the caller. </span>
<span class="org-comment"> * @param[in]     buffer_size  Size of buffer allocated by the caller in bytes.</span>
<span class="org-comment"> * @return                     Size of copied array.</span>
<span class="org-comment"> */</span>
EXPORT_C <span class="org-type">size_t</span> 
<span class="org-function-name">square_root_as_stringA</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">char</span>* <span class="org-variable-name">buffer</span>, <span class="org-type">size_t</span> <span class="org-variable-name">buffer_size</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">ss</span>;
     ss = ss + <span class="org-string">"The square root of x = "</span> + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>
             + <span class="org-string">" is equal to "</span> + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-2">(</span>sqrt<span class="org-rainbow-delimiters-depth-3">(</span>x<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-constant">std</span>::strncpy<span class="org-rainbow-delimiters-depth-2">(</span>buffer, ss.data<span class="org-rainbow-delimiters-depth-3">()</span>, buffer_size<span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span> ss.size<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Function - version B: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Design 2: Buffer allocated by the caller. If the buffer is null, the function </span>
<span class="org-comment"> *            returns the required buffer size.</span>
<span class="org-comment"> * @param[in]     x            Float point number </span>
<span class="org-comment"> * @param[in,out] buffer       Buffer allocated by the caller. </span>
<span class="org-comment"> * @param[in]     buffer_size  Size of buffer allocated by the caller in bytes.</span>
<span class="org-comment"> * @return                     Size of copied array or required buffer size.                                </span>
<span class="org-comment"> */</span>
EXPORT_C <span class="org-type">size_t</span> 
<span class="org-function-name">square_root_as_stringB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">char</span>* <span class="org-variable-name">buffer</span>, <span class="org-type">size_t</span> <span class="org-variable-name">buffer_size</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">ss</span>;
     ss = ss + <span class="org-string">"The square root of x = "</span> + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>
             + <span class="org-string">" is equal to "</span> + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-2">(</span>sqrt<span class="org-rainbow-delimiters-depth-3">(</span>x<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>buffer == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span>
             <span class="org-keyword">return</span> ss.size<span class="org-rainbow-delimiters-depth-2">()</span>;
     <span class="org-constant">std</span>::strncpy<span class="org-rainbow-delimiters-depth-2">(</span>buffer, ss.data<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">const char* */</span>, buffer_size<span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span> ss.size<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Function - version C:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Design3: Buffer allocated by callee (this code) and released by the</span>
<span class="org-comment"> * caller. */</span>
EXPORT_C <span class="org-type">char</span>* 
<span class="org-function-name">square_root_as_stringC</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">ss</span>;
     ss = ss + <span class="org-string">"The square root of x = "</span> + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>
             + <span class="org-string">" is equal to "</span> + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-2">(</span>sqrt<span class="org-rainbow-delimiters-depth-3">(</span>x<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span> strdup<span class="org-rainbow-delimiters-depth-2">(</span>ss.data<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

EXPORT_C <span class="org-type">void</span> 
<span class="org-function-name">cstring_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span>* <span class="org-variable-name">pCstring</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] C-string deleted, memory released. OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::free<span class="org-rainbow-delimiters-depth-2">(</span>pCstring<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>file: cstrp.py</b> (Python Wrapepr)
</p>

<p>
Initial configuration: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> ctypes 

<span class="org-variable-name">CString</span>   = ctypes.POINTER(ctypes.c_char)
<span class="org-variable-name">STDString</span> = ctypes.c_void_p 
<span class="org-variable-name">CVoid</span>     = <span class="org-constant">None</span> 
<span class="org-variable-name">dll</span> = ctypes.cdll.LoadLibrary(<span class="org-string">"cstr.so"</span>)
</pre>
</div>

<p>
Wrapper for function A:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">print</span>(<span class="org-string">"\n EXPERIMENT1 =&gt; Call square_root_as_stringA"</span>)
<span class="org-keyword">print</span>(<span class="org-string">"============================================="</span>)
<span class="org-variable-name">dll.square_root_as_stringA.argtypes</span> = [ ctypes.c_double,
                                        CString,
                                        ctypes.c_size_t ]
<span class="org-variable-name">dll.square_root_as_stringA.restype</span>  = ctypes.c_size_t

<span class="org-variable-name">buf_size</span> = 1024 <span class="org-comment-delimiter"># </span><span class="org-comment">1 Kbyte = 1024 bytes</span>
<span class="org-variable-name">buf</span>      = ctypes.create_string_buffer(buf_size)
<span class="org-variable-name">n_read</span>   = dll.square_root_as_stringA(100.45, buf, buf_size)

<span class="org-keyword">print</span>(<span class="org-string">"Size = "</span>, n_read, <span class="org-string">" ; RESULT = "</span>, buf.value)
</pre>
</div>

<p>
Wrapper for function B:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">print</span>(<span class="org-string">"\n EXPERIMENT 2 =&gt; Call square_root_as_stringB"</span>)
<span class="org-keyword">print</span>(<span class="org-string">"============================================="</span>)
<span class="org-variable-name">dll.square_root_as_stringB.argtypes</span> = [ ctypes.c_double,
                                        CString,
                                        ctypes.c_size_t ]
<span class="org-variable-name">dll.square_root_as_stringB.restype</span>  = ctypes.c_size_t

<span class="org-variable-name">x</span> = 200.45
<span class="org-variable-name">required_size</span> = dll.square_root_as_stringB(x, ctypes.c_char_p(0), 0)
<span class="org-variable-name">buf</span>           = ctypes.create_string_buffer(required_size)
dll.square_root_as_stringB(x, buf, required_size)
<span class="org-keyword">print</span>(<span class="org-string">" RESULT = "</span>, buf.value)
</pre>
</div>

<p>
Wrapper for function C: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">print</span>(<span class="org-string">"\n EXPERIMENT 3 =&gt; Call square_root_as_stringC"</span>)
<span class="org-keyword">print</span>(<span class="org-string">"============================================="</span>)

<span class="org-variable-name">dll.square_root_as_stringC.argtypes</span> = [ ctypes.c_double ]
<span class="org-variable-name">dll.square_root_as_stringC.restype</span>  = ctypes.c_char_p

<span class="org-variable-name">dll.cstring_delete.argtypes</span> = [ ctypes.c_char_p ]
<span class="org-variable-name">dll.cstring_delete.restype</span>  = CVoid

<span class="org-variable-name">hCString</span> = dll.square_root_as_stringC(167.42)
<span class="org-keyword">print</span>(<span class="org-string">" RESULT = "</span>, hCString)
</pre>
</div>

<p>
<b>Program output</b> 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ python3 cstr.py 

 EXPERIMENT1 =&gt; Call square_root_as_stringA
=============================================
Size =  55  ; RESULT =  b<span class="org-string">'The square root of x = 100.450000 is equal to 10.022475'</span>

 EXPERIMENT 2 =&gt; Call square_root_as_stringB
=============================================
 RESULT =  b<span class="org-string">'The square root of x = 200.450000 is equal to 14.158037'</span>

 EXPERIMENT 3 =&gt; Call square_root_as_stringC
=============================================
 RESULT =  b<span class="org-string">'The square root of x = 167.420000 is equal to 12.939088'</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org46dce88" class="outline-3">
<h3 id="org46dce88"><span class="section-number-3">1.5</span> Python native module (shared library)</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org87a489b" class="outline-4">
<h4 id="org87a489b"><span class="section-number-4">1.5.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
Many programming languages provide a C-native interfaces such as
Python C-API or Java Native Interface where it is possible to create
native-code libraries in C without overhead of virtual machine code
interpretation. The advantage of a code for a C native interface
(native API) of some programming language is the easier usage and
better integration with the target language. The drawback for
developing some native library with this approach is that the library
will be tight coupled with the language native C API, as a result, it
will be hard to port or call the code from other programming
language. In addition, it may require deeper knowledge of the native C
API. 
</p>

<p>
Other approaches for developing shared libraries for Python native
API:
</p>

<ul class="org-ul">
<li><b>Pybind11 header-only library</b> =&gt; Provides a C++-friendly syntax and
interface to the Python native C API. It allows building Python
native modules and port C++ code in a easier and faster way than
dealing directly with Python C API.</li>

<li><b>SWIG wrapper generator</b> =&gt; SWIG can parse C++ headers and interface
files and generate C++ binding code to the native API of many
programming languages such as Python, Ruby, Java and so on.</li>

<li><b>Cython</b> =&gt; Python-like language that compile to C code (generate
C-code). The disadvantage is the tight coupling to the Python API.</li>
</ul>

<p>
Further documentation and reading: 
</p>

<p>
Documentation: 
</p>

<ul class="org-ul">
<li><a href="https://docs.python.org/3/howto/cporting.html">Porting Extension Modules to Python 3 — Python 3.7.2 documentation</a></li>
<li><a href="https://pythonextensionpatterns.readthedocs.io/en/latest/parsing_arguments.html">Parsing Python Arguments — Python Extension Patterns 0.1.0 documentation</a></li>
<li><a href="http://docs.activestate.com/activepython/3.6/python/c-api/arg.html">ActivePython 3.6.6 Documentation</a></li>
<li><a href="https://docs.python.org/3/extending/index.html">Extending and Embedding the Python Interpreter — Python 3.7.2 documentation</a></li>
</ul>

<p>
General:
</p>

<ul class="org-ul">
<li><a href="https://docs.python.org/3/c-api/structures.html">Common Object Structures — Python 3.7.2 documentation</a></li>

<li><a href="https://docs.scipy.org/doc/numpy/reference/c-api.types-and-structures.html">Python Types and C-Structures — NumPy v1.15 Manual</a></li>

<li><a href="https://docs.python.org/2.3/api/stringObjects.html">7.3.1 String Objects</a></li>

<li><a href="https://docs.python.org/2/c-api/code.html">Code Objects — Python 2.7.15 documentation</a></li>

<li><a href="https://docs.python.org/2/c-api/veryhigh.html#c.PyRun_SimpleFileExFlags">The Very High Level Layer — Python 2.7.15 documentation</a></li>

<li><a href="https://stackoverflow.com/questions/3789881/create-and-call-python-function-from-string-via-c-api">Create and call python function from string via C API - Stack Overflow</a></li>

<li><a href="https://www6.software.ibm.com/developerworks/education/l-pythonscript/l-pythonscript-ltr.pdf">Embed Python scripting in C applications</a></li>

<li><a href="https://stackoverflow.com/questions/4922365/python-c-api-pyeval-callfunction">Python C API: PyEval_CallFunction? - Stack Overflow</a></li>

<li><a href="http://effbot.org/pyfaq/how-do-i-call-an-object-s-method-from-c.htm">How do I call an object's method from C?</a></li>
</ul>

<p>
Creating a native Python module: 
</p>
<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/visualstudio/python/working-with-c-cpp-python-in-visual-studio?view=vs-2017">Write C++ extensions for Python - Visual Studio | Microsoft Docs</a></li>
<li><a href="http://yizhang82.me/python-interop-capi">Calling C functions from Python - part 2 - writing CPython extensions using Python/C API | yizhang82’s blog</a></li>
</ul>

<p>
Python (CPython) debugging with GDB:
</p>
<ul class="org-ul">
<li><a href="https://devguide.python.org/gdb/">22. gdb Support — Python Developer's Guide</a></li>
<li><a href="https://docs.microsoft.com/en-us/visualstudio/python/debugging-mixed-mode-c-cpp-python-in-visual-studio?view=vs-2017">Mixed-mode debugging for Python - Visual Studio | Microsoft Docs</a></li>
</ul>

<p>
Reverse engineering: 
</p>
<ul class="org-ul">
<li><a href="https://recon.cx/2008/a/aaron_portnoy-ali_rizvi_santiago/slides.pdf">Reverse Engineering Dynamic Languages - A Focus on Python</a></li>
</ul>
</div>
</div>

<div id="outline-container-org56a9b6e" class="outline-4">
<h4 id="org56a9b6e"><span class="section-number-4">1.5.2</span> Module Code</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
<b>Module Source:</b>
</p>

<ul class="org-ul">
<li>File: <a href="src/dlls/mymodule.cpp">file:src/dlls/mymodule.cpp</a></li>
<li>Gist: <a href="https://gist.github.com/caiorss/bc7dc373d87b828029eb0e0ec048d91e">mymodule.cpp</a></li>
</ul>

<p>
<b>Compilation:</b>
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">GCC - GNU C/C++ compiler </span>
$ g++ mymodule.cpp -o <span class="org-keyword">mymodule.so</span> -g -std=c++1z -fPIC -shared -I/usr/include/python3.6m  

<span class="org-comment-delimiter"># </span><span class="org-comment">Clang LLVM </span>
$ clang++ mymodule.cpp -o <span class="org-keyword">mymodule.so</span> -g -std=c++1z -fPIC -shared -I/usr/include/python3.6m  
</pre>
</div>

<p>
Header files: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">/// </span><span class="org-comment">C-API header to Python Native Interface API, similar to Java JNI</span>
<span class="org-comment-delimiter">/// </span><span class="org-comment">(Java Native Interface)</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">Python.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#ifdef</span> _WIN32
<span class="org-preprocessor">  #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">process.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">Exports _getpid()</span>
<span class="org-preprocessor">#else</span>
<span class="org-preprocessor">  #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">unistd.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Exports getpid()</span>
<span class="org-preprocessor">#endif</span> 
</pre>
</div>


<p>
Global object for DLL initialization (optional): 
</p>

<ul class="org-ul">
<li>The global object dllinit_hook is used for logging to stdout when
the DLL is loaded or unloaded by the python process.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">DLLInitialization</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-function-name">DLLInitialization</span><span class="org-rainbow-delimiters-depth-2">(){</span>
         <span class="org-type">int</span> <span class="org-variable-name">pid</span>;
<span class="org-preprocessor">         #ifdef</span> _WIN32
            pid = _getpid<span class="org-rainbow-delimiters-depth-3">()</span>;
<span class="org-preprocessor">         #else</span>
            pid = getpid<span class="org-rainbow-delimiters-depth-3">()</span>;       
<span class="org-preprocessor">         #endif</span> 
         <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [TRACE] Python module DLL loaded by process PID = &lt;"</span>
                           &lt;&lt; pid &lt;&lt; <span class="org-string">"&gt; "</span>
                           &lt;&lt; <span class="org-constant">std</span>::endl;
         <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [TRACE] Attach the debugger with: $ gdb -pid="</span> &lt;&lt; pid &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     ~<span class="org-function-name">DLLInitialization</span><span class="org-rainbow-delimiters-depth-2">(){</span>
         <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [TRACE] DLL native DLL unloaded OK."</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-rainbow-delimiters-depth-2">}</span>  
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">DLLInitialization</span> <span class="org-variable-name">dllinit_hook</span>;
</pre>
</div>

<p>
Exposed functions declarations: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">PyObject</span>*
<span class="org-function-name">exposedFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">PyObject</span>* <span class="org-variable-name">self</span>, <span class="org-type">PyObject</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">PyObject</span>* <span class="org-function-name">testArguments</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">PyObject</span>* <span class="org-variable-name">self</span>, <span class="org-type">PyObject</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-function-name">printRange</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">PyObject</span>* <span class="org-variable-name">self</span>, <span class="org-type">PyObject</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">PyObject</span>*;
<span class="org-keyword">auto</span> <span class="org-function-name">taylorSeriesExp</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">PyObject</span>* <span class="org-variable-name">self</span>, <span class="org-type">PyObject</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">PyObject</span>*;
<span class="org-type">PyObject</span>* <span class="org-function-name">tabulateFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">PyObject</span>* <span class="org-variable-name">self</span>, <span class="org-type">PyObject</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Table of exported functions to the Python module: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">static</span> <span class="org-type">PyMethodDef</span> <span class="org-variable-name">ModuleFunctions</span> <span class="org-rainbow-delimiters-depth-1">[]</span> =
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-string">"exposedFunction"</span>, exposedFunction, METH_VARARGS,
       <span class="org-string">"Documentation or docstring of function exposedFunction1."</span> <span class="org-rainbow-delimiters-depth-2">}</span>

     ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"testArguments"</span>, testArguments, METH_VARARGS,
       <span class="org-string">"Test python arguments: Signature testArguments(int, float, double, const char*)"</span><span class="org-rainbow-delimiters-depth-2">}</span>

     <span class="org-comment-delimiter">// </span><span class="org-comment">Function without docstring: printRange(int i, double x)</span>
     ,<span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-string">"printRange"</span>, printRange, METH_VARARGS, <span class="org-constant">nullptr</span> <span class="org-rainbow-delimiters-depth-2">}</span>

     ,<span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-string">"taylorSeriesExp"</span>, &amp;taylorSeriesExp, METH_VARARGS,
        <span class="org-string">"taylorSeriesExp(double x, size_t maxiter, double tol) -&gt; double"</span>
        <span class="org-string">"\n Computes exponential of a given value with taylor serie approximation."</span>
        <span class="org-string">"\n Formula reference:  https://www.mathsisfun.com/algebra/taylor-series.html"</span>
     <span class="org-rainbow-delimiters-depth-2">}</span>
     ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"tabulateFunction"</span>, tabulateFunction, METH_VARARGS,
         <span class="org-string">"Tabulate some mathematical function or callable object"</span><span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Sentinel value used to indicate the end of function listing.</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">All function listing must end with this value.</span>
     ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">nullptr</span>, <span class="org-constant">nullptr</span>, 0, <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">}</span>                                    
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Module definition: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/* </span><span class="org-comment">Module definition */</span>
<span class="org-keyword">static</span> <span class="org-keyword">struct</span> <span class="org-type">PyModuleDef</span> <span class="org-variable-name">ModuleObject</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    PyModuleDef_HEAD_INIT,
   <span class="org-comment-delimiter">// </span><span class="org-comment">Module name as string </span>
   <span class="org-string">"mymodule"</span>,
   <span class="org-comment-delimiter">// </span><span class="org-comment">Module documentation (docstring)</span>
   <span class="org-string">"A sample C++ native-code module for python3."</span>,
   -1,
   <span class="org-comment-delimiter">// </span><span class="org-comment">Functions exposed to the module </span>
   ModuleFunctions
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<p>
Module initialization function: 
</p>

<ul class="org-ul">
<li>Note: This function must contain the name in the format
<code>PyInit_&lt;MODULE NAME&gt;</code> where module name is the same name as the
module file name &lt;MODULE NAME&gt;.so (Linux) or &lt;MODULE NAME&gt;.pyd on
Windows.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Module Initialization function: must have this name schema</span>
<span class="org-comment"> *  PyInit_&lt;ModuleName&gt; where ModuleName is the same base name of the </span>
<span class="org-comment"> *  shared library ModuleName.so (on Linux) or ModuleName.pyd (on Windows)</span>
<span class="org-comment"> */</span>
<span class="org-type">PyMODINIT_FUNC</span> <span class="org-function-name">PyInit_mymodule</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   Py_Initialize<span class="org-rainbow-delimiters-depth-2">()</span>;
   <span class="org-type">PyObject</span>* <span class="org-variable-name">pModule</span> = PyModule_Create<span class="org-rainbow-delimiters-depth-2">(</span>&amp;ModuleDefinitions<span class="org-rainbow-delimiters-depth-2">)</span>;
   PyModule_AddObject<span class="org-rainbow-delimiters-depth-2">(</span>pModule, <span class="org-string">"version"</span>, Py_BuildValue<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"s"</span>, <span class="org-string">"version 0.1-Alpha"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">return</span> pModule;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Module Functions Implementations</b>
</p>

<p>
All functions exposed to the Python C-API must have the following
signature:  
</p>

<p>
Notes:
</p>

<ul class="org-ul">
<li>The function takes always two arguments self, and args (tuple
object containing arguments passed to the function)</li>
<li>The exposed function always return a Python object.</li>
<li>In Python everything are objects: integers, double, classes,
functions and so on.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">PyExposedFunction</span> = PyObject* <span class="org-rainbow-delimiters-depth-1">(</span>*<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">PyObject</span>* <span class="org-variable-name">self</span>, <span class="org-type">PyObject</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
<b>Function: exposedFunction</b>
</p>

<ul class="org-ul">
<li>Function that takes a void argument and returns nothing.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">PyObject</span>*
<span class="org-function-name">exposedFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">PyObject</span>* <span class="org-variable-name">self</span>, <span class="org-type">PyObject</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt;&gt; Hello word Python from C++ side."</span> &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-comment-delimiter">// </span><span class="org-comment">All python functions that returns anything</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">should end with this macro </span>
     Py_RETURN_NONE;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Function: testArguments</b>
</p>

<ul class="org-ul">
<li>Function that takes many arguments used to demonstrate how to
extract tuple arguments.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">PyObject</span>* <span class="org-function-name">testArguments</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">PyObject</span>* <span class="org-variable-name">self</span>, <span class="org-type">PyObject</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-type">int</span>         <span class="org-variable-name">abool</span>;
      <span class="org-type">int</span>         <span class="org-variable-name">aint</span>;
      <span class="org-type">float</span>       <span class="org-variable-name">afloat</span>;
      <span class="org-type">double</span>      <span class="org-variable-name">adouble</span>;
      <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">aword</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">Parse function arguments </span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>PyArg_ParseTuple<span class="org-rainbow-delimiters-depth-3">(</span>args, <span class="org-string">"pifds"</span>, &amp;abool, &amp;aint, &amp;afloat, &amp;adouble, &amp;aword<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
          <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;

      <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" Function: ["</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="org-string">"]"</span> 
                &lt;&lt; <span class="org-string">" ==&gt; Number of arguments = "</span> &lt;&lt; PyTuple_GET_SIZE<span class="org-rainbow-delimiters-depth-2">(</span>args<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;

      <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">str</span> = aword;
      str = <span class="org-string">"'Received string = "</span> + str + <span class="org-string">"'"</span>;

      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Received Python Arguments "</span> &lt;&lt; <span class="org-string">"\n"</span>;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"abool[bool] = "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-2">)</span> abool &lt;&lt; <span class="org-string">"\n"</span>
                        &lt;&lt; <span class="org-string">" abool[int] = "</span> &lt;&lt; abool &lt;&lt; <span class="org-string">"\n"</span>
                        &lt;&lt; <span class="org-string">"      aint  = "</span> &lt;&lt; aint &lt;&lt; <span class="org-string">"\n"</span>
                        &lt;&lt; <span class="org-string">"     afloat = "</span> &lt;&lt; afloat &lt;&lt; <span class="org-string">"\n"</span>
                        &lt;&lt; <span class="org-string">"    adouble = "</span> &lt;&lt; adouble &lt;&lt; <span class="org-string">"\n"</span>
                        &lt;&lt; <span class="org-string">"    aword   = "</span> &lt;&lt; str &lt;&lt; <span class="org-string">"\n"</span>
                        &lt;&lt; <span class="org-string">"\n"</span>;        
      <span class="org-keyword">return</span> Py_BuildValue<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"s"</span>, str.data<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Function PyArg_ParseTuple:
</p>

<ul class="org-ul">
<li>The function PyArg_ParseTuple is used for extracting function
arguments from the tuple object (args).</li>

<li>The letters in the string parameter "pifds" means:
<ul class="org-ul">
<li>p =&gt; Extract first argument from tuple object as boolean (integer 0 or 1)</li>
<li>i =&gt; Extract second argument from tuple object as integer</li>
<li>f =&gt; Extract third argument as float (float point 32 bits)</li>
<li>d =&gt; Extract fourth argument as double (float point 64 bits)</li>
<li>s =&gt; Extract fith argument as string.</li>
</ul></li>

<li>If the function fails, it must return null which causes a runtime
error on Python side. It should never throw an exception.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span>         <span class="org-variable-name">abool</span>;
<span class="org-type">int</span>         <span class="org-variable-name">aint</span>;
<span class="org-type">float</span>       <span class="org-variable-name">afloat</span>;
<span class="org-type">double</span>      <span class="org-variable-name">adouble</span>;
<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">aword</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Parse function arguments </span>
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-negation-char">!</span>PyArg_ParseTuple<span class="org-rainbow-delimiters-depth-2">(</span>args, <span class="org-string">"pifds"</span>, &amp;abool, &amp;aint, &amp;afloat, &amp;adouble, &amp;aword<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
</pre>
</div>

<p>
Function Py_BuildValue("s", str.data());
</p>

<ul class="org-ul">
<li>This function is used for building return values to the python
side. It can return one or more values as tuple.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Return string </span>
<span class="org-keyword">return</span> Py_BuildValue<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"s"</span>, str.data<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Return integer </span>
<span class="org-keyword">return</span> Py_BuildValue<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"i"</span>, 1000<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Return float  </span>
<span class="org-keyword">return</span> Py_BuildValue<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"f"</span>, 3.465<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Return double   </span>
<span class="org-keyword">return</span> Py_BuildValue<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"d"</span>, 140.346<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Function: printRange</b>
</p>

<ul class="org-ul">
<li>Pseudo-Python signature: printRange(int n, float x) =&gt; void</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-function-name">printRange</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">PyObject</span>* <span class="org-variable-name">self</span>, <span class="org-type">PyObject</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">PyObject</span>*
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" =&gt;&gt; Printing numeric range "</span> &lt;&lt; <span class="org-string">"\n"</span>;    
    <span class="org-type">int</span>    <span class="org-variable-name">n</span>;
    <span class="org-type">float</span>  <span class="org-variable-name">x</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Extract function argument from tuple argument object</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">"if" =&gt; i - Extract integer</span>
    <span class="org-comment-delimiter">//      </span><span class="org-comment">=&gt; f - Extract float (IEEE754 32 bits float point)</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>PyArg_ParseTuple<span class="org-rainbow-delimiters-depth-3">(</span>args, <span class="org-string">"if"</span>, &amp;n, &amp;x<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">){</span>
        PyErr_SetString<span class="org-rainbow-delimiters-depth-3">(</span>PyExc_RuntimeError, <span class="org-string">"Invalid argument"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Always return null on failure </span>
        <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>; 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>n &lt;= 0<span class="org-rainbow-delimiters-depth-2">){</span>
        PyErr_SetString<span class="org-rainbow-delimiters-depth-3">(</span> PyExc_RuntimeError
                        ,<span class="org-string">"Invalid argument: n supposed to be greater than zero."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>   

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">k</span> = 0; k &lt; n; k++<span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" k["</span> &lt;&lt; k &lt;&lt; <span class="org-string">"] = "</span> &lt;&lt; 3 * k + x &lt;&lt; <span class="org-string">"\n"</span>;  
    Py_RETURN_NONE;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
<b>Function: taylorSeriesExp</b>
</p>

<ul class="org-ul">
<li>This function computes the exponential function approximation using its taylor
series expansion. Formula at: <a href="https://www.mathsisfun.com/algebra/taylor-series.html">taylor series</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-function-name">taylorSeriesExp</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">PyObject</span>* <span class="org-variable-name">self</span>, <span class="org-type">PyObject</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">PyObject</span>*
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-type">double</span> <span class="org-variable-name">x</span>;
     <span class="org-type">size_t</span> <span class="org-variable-name">maxiter</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Maximum number of iterations </span>
     <span class="org-type">double</span> <span class="org-variable-name">tol</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">Tolerance</span>

     <span class="org-comment-delimiter">// </span><span class="org-comment">Parse function arguments </span>
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>PyArg_ParseTuple<span class="org-rainbow-delimiters-depth-3">(</span>args, <span class="org-string">"did"</span>, &amp;x, &amp;maxiter, &amp;tol<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
             <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;

     <span class="org-comment-delimiter">// </span><span class="org-comment">Validate function arguments</span>

     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>tol &lt;= 0 || tol &gt; 1.0<span class="org-rainbow-delimiters-depth-2">){</span>
             PyErr_SetString<span class="org-rainbow-delimiters-depth-3">(</span> PyExc_RuntimeError
                            ,<span class="org-string">"Invalid tolerance, expected in range (0, 1]"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
             <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>

     <span class="org-comment-delimiter">// </span><span class="org-comment">Compute exponential taylor series available at</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">https://www.mathsisfun.com/algebra/taylor-series.html</span>
     <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">factorial</span> = 1;
     <span class="org-type">double</span>        <span class="org-variable-name">xpower</span>    = 1.0;
     <span class="org-type">double</span>        <span class="org-variable-name">sum</span>       = 0.0;
     <span class="org-type">double</span>        <span class="org-variable-name">term</span>      = 0.0;
     <span class="org-type">size_t</span>        <span class="org-variable-name">idx</span>       = 1;
     <span class="org-keyword">do</span><span class="org-rainbow-delimiters-depth-2">{</span>
          term      = xpower / factorial;
          sum       = sum + term;
          xpower    = xpower * x ;
          factorial = factorial * idx;      
          idx++;
     <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span>idx &lt;= maxiter &amp;&amp; <span class="org-constant">std</span>::abs<span class="org-rainbow-delimiters-depth-3">(</span>term<span class="org-rainbow-delimiters-depth-3">)</span> &gt; <span class="org-constant">std</span>::abs<span class="org-rainbow-delimiters-depth-3">(</span>sum<span class="org-rainbow-delimiters-depth-3">)</span> * tol <span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-comment-delimiter">// </span><span class="org-comment">Return float point constnat NAN (Not a Number)</span>
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>idx &gt;= maxiter<span class="org-rainbow-delimiters-depth-2">){</span>
             <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [ERROR] Series does not converge."</span> &lt;&lt; <span class="org-string">"\n"</span>;
             <span class="org-keyword">return</span> Py_BuildValue<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"d"</span>, NAN<span class="org-rainbow-delimiters-depth-3">)</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-keyword">return</span> Py_BuildValue<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"d"</span>, sum<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Function: tabulateFunction</b> 
</p>

<ul class="org-ul">
<li>This function takes a callable object (callback) which can be a
function, lambda function, callable object (object with method <code>__call__</code>) and so on.</li>
</ul>

<p>
Pseudo Python method signature using C++ notation: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">Callback</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;
<span class="org-type">void</span> <span class="org-function-name">tabulateFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Callback</span> <span class="org-variable-name">callback</span>, <span class="org-type">double</span> <span class="org-variable-name">xmin</span>, <span class="org-type">double</span> <span class="org-variable-name">xmax</span>, <span class="org-type">double</span> <span class="org-variable-name">step</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Function code: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">PyObject</span>* <span class="org-function-name">tabulateFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">PyObject</span>* <span class="org-variable-name">self</span>, <span class="org-type">PyObject</span>* <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-type">PyObject</span>* <span class="org-variable-name">pObj</span> = <span class="org-constant">nullptr</span>;
     <span class="org-type">double</span> <span class="org-variable-name">xmin</span>, <span class="org-variable-name">xmax</span>, <span class="org-variable-name">xstep</span>;

     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>PyArg_ParseTuple<span class="org-rainbow-delimiters-depth-3">(</span>args, <span class="org-string">"Oddd"</span>, &amp;pObj, &amp;xmin, &amp;xmax, &amp;xstep<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
          <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>pObj == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
          PyErr_SetString<span class="org-rainbow-delimiters-depth-3">(</span>PyExc_RuntimeError, <span class="org-string">"Error: invalid None object."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
          <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-type">PyObject</span>* <span class="org-variable-name">pArgs</span>  = <span class="org-constant">nullptr</span>;
     <span class="org-type">PyObject</span>* <span class="org-variable-name">pResult</span> = <span class="org-constant">nullptr</span>;
     <span class="org-type">double</span> <span class="org-variable-name">y</span> = 0.0;

     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>4<span class="org-rainbow-delimiters-depth-2">)</span>;

     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Tabulating range: "</span>
               &lt;&lt; <span class="org-string">" ; xmin = "</span> &lt;&lt; xmin
               &lt;&lt; <span class="org-string">" ; xmax = "</span> &lt;&lt; xmax
               &lt;&lt; <span class="org-string">" ; step = "</span> &lt;&lt; xstep
               &lt;&lt; <span class="org-string">"\n"</span>;

     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span> = xmin; x &lt;= xmax; x += xstep <span class="org-rainbow-delimiters-depth-2">)</span>
     <span class="org-rainbow-delimiters-depth-2">{</span>
          pArgs  = Py_BuildValue<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"(d)"</span>, x<span class="org-rainbow-delimiters-depth-3">)</span>;
          pResult = PyEval_CallObject<span class="org-rainbow-delimiters-depth-3">(</span>pObj, pArgs<span class="org-rainbow-delimiters-depth-3">)</span>;
          y = PyFloat_AsDouble<span class="org-rainbow-delimiters-depth-3">(</span>pResult<span class="org-rainbow-delimiters-depth-3">)</span>;
          <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>PyErr_Occurred<span class="org-rainbow-delimiters-depth-4">()</span> != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-3">){</span>
                  PyErr_SetString<span class="org-rainbow-delimiters-depth-4">(</span>PyExc_RuntimeError, <span class="org-string">"Error: Invalid float point."</span><span class="org-rainbow-delimiters-depth-4">)</span>;
                  <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
          <span class="org-rainbow-delimiters-depth-3">}</span>
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>8<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>10<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; y  &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     Py_RETURN_NONE;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Extract python callable object (callback) pObj and the parameters
xmin, xmax and xstep: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">PyObject</span>* <span class="org-variable-name">pObj</span> = <span class="org-constant">nullptr</span>;
<span class="org-type">double</span> <span class="org-variable-name">xmin</span>, <span class="org-variable-name">xmax</span>, <span class="org-variable-name">xstep</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Extract parameters </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">O =&gt; pObj </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">d =&gt; xmin </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">d =&gt; xmax </span>
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-negation-char">!</span>PyArg_ParseTuple<span class="org-rainbow-delimiters-depth-2">(</span>args, <span class="org-string">"Oddd"</span>, &amp;pObj, &amp;xmin, &amp;xmax, &amp;xstep<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
     <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
</pre>
</div>

<p>
Annotated code block in the for-loop: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Argument (tuple object) of callable object </span>
pArgs  = Py_BuildValue<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"(d)"</span>, x<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Call callable object (method __call__)</span>
pResult = PyEval_CallObject<span class="org-rainbow-delimiters-depth-1">(</span>pObj, pArgs<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Try extracting result as double </span>
y = PyFloat_AsDouble<span class="org-rainbow-delimiters-depth-1">(</span>pResult<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Check whether any error has happened and abort the operation in this case. </span>
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>PyErr_Occurred<span class="org-rainbow-delimiters-depth-2">()</span> != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">){</span>
     PyErr_SetString<span class="org-rainbow-delimiters-depth-2">(</span>PyExc_RuntimeError, <span class="org-string">"Error: Invalid float point."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Display table row </span>
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-1">(</span>8<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; y  &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org18e4d25" class="outline-4">
<h4 id="org18e4d25"><span class="section-number-4">1.5.3</span> Loading the native module</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
Compile the native module: <a href="https://gist.github.com/caiorss/bc7dc373d87b828029eb0e0ec048d91e">mymodule.cpp</a> =&gt; Generate file mymodule.so 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ mymodule.cpp -o <span class="org-keyword">mymodule.so</span> -g -std=c++1z -fPIC -shared -I/usr/include/python3.6m  
</pre>
</div>

<p>
Check generated file: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ file mymodule.so 

$ du -h mymodule.so 
136K    mymodule.so
136K    total
</pre>
</div>

<p>
View symbols: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ nm  mymodule.so 
0000000000209518 B __bss_start
0000000000005500 t __clang_call_terminate
0000000000209518 b completed.7347
                 U __cxa_atexit@@GLIBC_2.2.5
                 U __cxa_begin_catch@@CXXABI_1.3
                 U __cxa_call_unexpected@@CXXABI_1.3
                 U __cxa_end_catch@@CXXABI_1.3
                 w __cxa_finalize@@GLIBC_2.2.5
                 U __cxa_rethrow@@CXXABI_1.3
0000000000004160 t __cxx_global_var_initmymodule.cpp_
00000000000041a0 t __cxx_global_var_initmymodule.cpp_.1
00000000000041f0 t deregister_tm_clones
000000000020951a B dllinit_hook
.. ... ... ... ... ... ... ... 
</pre>
</div>

<p>
Load module in Python 3 REPL:
</p>

<div class="org-src-container">
<pre class="src src-python">$ python3
Python 3.7.1 (default, Dec 14 2018, 19:28:38) 
[GCC 7.3.0] :: Anaconda, Inc. on linux
Type <span class="org-string">"help"</span>, <span class="org-string">"copyright"</span>, <span class="org-string">"credits"</span> <span class="org-keyword">or</span> <span class="org-string">"license"</span> <span class="org-keyword">for</span> more information.
&gt;&gt;&gt; 
&gt;&gt;&gt; <span class="org-keyword">import</span> mymodule <span class="org-keyword">as</span> a
 [TRACE] Python module DLL loaded by process <span class="org-variable-name">PID</span> = &lt;5236&gt; 
 [TRACE] Attach the debugger <span class="org-keyword">with</span>: $ gdb -<span class="org-variable-name">pid</span>=5236
&gt;&gt;&gt; 
&gt;&gt;&gt; 
</pre>
</div>

<p>
Module Docstring (documentation): 
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-builtin">help</span>(a)
Help on module mymodule:

NAME
    mymodule - A sample C++ native-code module <span class="org-keyword">for</span> python3.

FUNCTIONS
    exposedFunction(...)
        Documentation <span class="org-keyword">or</span> docstring of function exposedFunction1.

    printRange(...)

    tabulateFunction(...)
        Tabulate some mathematical function <span class="org-keyword">or</span> <span class="org-builtin">callable</span> <span class="org-builtin">object</span>

    taylorSeriesExp(...)
        taylorSeriesExp(double x, size_t maxiter, double tol) -&gt; double
        Computes exponential of a given value <span class="org-keyword">with</span> taylor serie approximation.
        Formula reference:  https://www.mathsisfun.com/algebra/taylor-series.html

    testArguments(...)
        Test python arguments: Signature testArguments(<span class="org-builtin">int</span>, <span class="org-builtin">float</span>, double, const char*)

DATA
    <span class="org-variable-name">version</span> = <span class="org-string">'version 0.1-Alpha'</span>

FILE
    /home/archbox/Documents/projects/cpp-programming.cpp/src/dlls/mymodule.so
</pre>
</div>

<p>
Module version: 
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; a.version
<span class="org-doc">'version 0.1-Alpha'</span>
&gt;&gt;&gt; 
</pre>
</div>

<p>
Call function exposedFunction()
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; a.exposedFunction()
 =&gt;&gt; Hello word Python <span class="org-keyword">from</span> C++ side.
&gt;&gt;&gt; 
</pre>
</div>

<p>
Call function testArguments:
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-variable-name">s1</span> = a.testArguments(<span class="org-constant">False</span>, 100, 10.9361, 0.344, <span class="org-string">"from Python to C++"</span>)
 Function: [testArguments] ==&gt; Number of <span class="org-variable-name">arguments</span> = 5
 Received Python Arguments 
<span class="org-variable-name">abool</span>[<span class="org-builtin">bool</span>] = false
 <span class="org-variable-name">abool</span>[<span class="org-builtin">int</span>] = 0
      <span class="org-variable-name">aint</span>  = 100
     <span class="org-variable-name">afloat</span> = 10.9361
    <span class="org-variable-name">adouble</span> = 0.344
    <span class="org-variable-name">aword</span>   = <span class="org-string">'Received string = from Python to C++'</span>

&gt;&gt;&gt; s1
<span class="org-string">"'Received string = from Python to C++'"</span>
&gt;&gt;&gt; 

&gt;&gt;&gt; 
&gt;&gt;&gt; <span class="org-variable-name">s2</span> = a.testArguments(<span class="org-constant">True</span>, 90, -0.56e6, 9.344e5, <span class="org-string">"something else more"</span>)
 Function: [testArguments] ==&gt; Number of <span class="org-variable-name">arguments</span> = 5
 Received Python Arguments 
<span class="org-variable-name">abool</span>[<span class="org-builtin">bool</span>] = true
 <span class="org-variable-name">abool</span>[<span class="org-builtin">int</span>] = 1
      <span class="org-variable-name">aint</span>  = 90
     <span class="org-variable-name">afloat</span> = -560000
    <span class="org-variable-name">adouble</span> = 934400
    <span class="org-variable-name">aword</span>   = <span class="org-string">'Received string = something else more'</span>

&gt;&gt;&gt; s2
<span class="org-string">"'Received string = something else more'"</span>
</pre>
</div>

<p>
Call function printRange()
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; a.printRange(5, 4.5)
 =&gt;&gt; Printing numeric <span class="org-builtin">range</span> 
 <span class="org-variable-name">k</span>[0] = 4.5
 <span class="org-variable-name">k</span>[1] = 7.5
 <span class="org-variable-name">k</span>[2] = 10.5
 <span class="org-variable-name">k</span>[3] = 13.5
 <span class="org-variable-name">k</span>[4] = 16.5
&gt;&gt;&gt; 
&gt;&gt;&gt; a.printRange(-5, 4.5)
 =&gt;&gt; Printing numeric <span class="org-builtin">range</span> 
Traceback (most recent call last):
  File <span class="org-string">"&lt;stdin&gt;"</span>, line 1, <span class="org-keyword">in</span> &lt;module&gt;
<span class="org-function-name">RuntimeError</span>: Invalid argument: n supposed to be greater than zero.
&gt;&gt;&gt; 
&gt;&gt;&gt; a.printRange(0, 4.5)
 =&gt;&gt; Printing numeric <span class="org-builtin">range</span> 
Traceback (most recent call last):
  File <span class="org-string">"&lt;stdin&gt;"</span>, line 1, <span class="org-keyword">in</span> &lt;module&gt;
<span class="org-function-name">RuntimeError</span>: Invalid argument: n supposed to be greater than zero.
&gt;&gt;&gt; 
&gt;&gt;&gt; 
</pre>
</div>

<p>
Call function taylorSerieExp: 
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-builtin">help</span>(a.taylorSeriesExp)
Help on built-<span class="org-keyword">in</span> function taylorSeriesExp <span class="org-keyword">in</span> module mymodule:

taylorSeriesExp(...)
    taylorSeriesExp(double x, size_t maxiter, double tol) -&gt; double
    Computes exponential of a given value <span class="org-keyword">with</span> taylor serie approximation.
    Formula reference:  https://www.mathsisfun.com/algebra/taylor-series.html

&gt;&gt;&gt; <span class="org-keyword">import</span> math

<span class="org-comment-delimiter"># </span><span class="org-comment">Exact value </span>
&gt;&gt;&gt; math.exp(3.5)
33.11545195869231

<span class="org-comment-delimiter"># </span><span class="org-comment">Approximation </span>
&gt;&gt;&gt; a.taylorSeriesExp(3.5, 10, 0.001)
 [ERROR] Series does <span class="org-keyword">not</span> converge.
nan
&gt;&gt;&gt; a.taylorSeriesExp(3.5, 100, 0.001)
33.10588185071678
&gt;&gt;&gt; 

<span class="org-comment-delimiter"># </span><span class="org-comment">Exact value </span>
&gt;&gt;&gt; math.exp(5.0)
148.4131591025766

<span class="org-comment-delimiter"># </span><span class="org-comment">Approximation </span>
&gt;&gt;&gt; a.taylorSeriesExp(5.0, 100, 0.001)
148.37958007973663

&gt;&gt;&gt; a.taylorSeriesExp(5.0, 100, 0.0001)
148.41021027504306
&gt;&gt;&gt; 
</pre>
</div>

<p>
Call function: tabulateFunction which takes a callable object as
argumet. 
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-builtin">help</span>(a.tabulateFunction)
Help on built-<span class="org-keyword">in</span> function tabulateFunction <span class="org-keyword">in</span> module mymodule:

tabulateFunction(...)
    Tabulate some mathematical function <span class="org-keyword">or</span> <span class="org-builtin">callable</span> <span class="org-builtin">object</span>
</pre>
</div>

<p>
Pass ordinary functions: 
</p>
<ul class="org-ul">
<li>Note: Python ordinary functions are objects with <code>__call__</code> method:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">import</span> <span class="org-variable-name">math</span> 

&gt;&gt;&gt; math.sqrt.__call__<span class="org-rainbow-delimiters-depth-1">(</span>25<span class="org-rainbow-delimiters-depth-1">)</span>
5.0

&gt;&gt;&gt; math.sqrt.__call__<span class="org-rainbow-delimiters-depth-1">(</span>125<span class="org-rainbow-delimiters-depth-1">)</span>
11.180339887498949
&gt;&gt;&gt; 

&gt;&gt;&gt; a.tabulateFunction<span class="org-rainbow-delimiters-depth-1">(</span>math.exp, -5.0, 5.0, 1.0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Tabulating</span> <span class="org-variable-name">range</span>:  ; xmin = -5.0000 ; xmax = 5.0000 ; step = 1.0000
 -5.0000    0.0067
 -4.0000    0.0183
 -3.0000    0.0498
 -2.0000    0.1353
 -1.0000    0.3679
  0.0000    1.0000
  1.0000    2.7183
  2.0000    7.3891
  3.0000   20.0855
  4.0000   54.5982
  5.0000  148.4132
&gt;&gt;&gt; 

&gt;&gt;&gt; a.tabulateFunction<span class="org-rainbow-delimiters-depth-1">(</span>math.sqrt, 0.0, 25.0, 5.0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Tabulating</span> <span class="org-variable-name">range</span>:  ; xmin = 0.0000 ; xmax = 25.0000 ; step = 5.0000
  0.0000    0.0000
  5.0000    2.2361
 10.0000    3.1623
 15.0000    3.8730
 20.0000    4.4721
 25.0000    5.0000
</pre>
</div>

<p>
Pass lambda functions: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt;&gt; a.tabulateFunction<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">lambda</span> <span class="org-variable-name">x</span>: x, 0.0, 25.0, 4.0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Tabulating</span> <span class="org-variable-name">range</span>:  ; xmin = 0.0000 ; xmax = 25.0000 ; step = 4.0000
  0.0000    0.0000
  4.0000    4.0000
  8.0000    8.0000
 12.0000   12.0000
 16.0000   16.0000
 20.0000   20.0000
 24.0000   24.0000
&gt;&gt;&gt; 

&gt;&gt;&gt; a.tabulateFunction<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">lambda</span> <span class="org-variable-name">x</span>: 3 * x + 5, 0.0, 25.0, 4.0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Tabulating</span> <span class="org-variable-name">range</span>:  ; xmin = 0.0000 ; xmax = 25.0000 ; step = 4.0000
  0.0000    5.0000
  4.0000   17.0000
  8.0000   29.0000
 12.0000   41.0000
 16.0000   53.0000
 20.0000   65.0000
 24.0000   77.0000
</pre>
</div>

<p>
Class LinearFun: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">LinearFun</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, a, b):
        <span class="org-keyword">self</span>.a = a
        <span class="org-keyword">self</span>.b = b
    <span class="org-keyword">def</span> <span class="org-function-name">__call__</span>(<span class="org-keyword">self</span>, x):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.a * x + <span class="org-keyword">self</span>.b
    <span class="org-keyword">def</span> <span class="org-function-name">eval</span>(<span class="org-keyword">self</span>, x):
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>.a * x + <span class="org-keyword">self</span>.b
</pre>
</div>

<p>
Pass a callable object: 
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span class="org-variable-name">lfun</span> = LinearFun(5, 4)
&gt;&gt;&gt; lfun(3)
19
&gt;&gt;&gt; lfun(6)
34
&gt;&gt;&gt; lfun.<span class="org-builtin">eval</span>(3)
19
&gt;&gt;&gt; lfun.<span class="org-builtin">eval</span>(6)
34

&gt;&gt;&gt; a.tabulateFunction(lfun, 0.0, 25.0, 4.0)
Tabulating <span class="org-builtin">range</span>:  ; <span class="org-variable-name">xmin</span> = 0.0000 ; <span class="org-variable-name">xmax</span> = 25.0000 ; <span class="org-variable-name">step</span> = 4.0000
  0.0000    4.0000
  4.0000   24.0000
  8.0000   44.0000
 12.0000   64.0000
 16.0000   84.0000
 20.0000  104.0000
 24.0000  124.0000
&gt;&gt;&gt; 
&gt;&gt;&gt; 

&gt;&gt;&gt; a.tabulateFunction(lfun.<span class="org-builtin">eval</span>, 0.0, 25.0, 4.0)
Tabulating <span class="org-builtin">range</span>:  ; <span class="org-variable-name">xmin</span> = 0.0000 ; <span class="org-variable-name">xmax</span> = 25.0000 ; <span class="org-variable-name">step</span> = 4.0000
  0.0000    4.0000
  4.0000   24.0000
  8.0000   44.0000
 12.0000   64.0000
 16.0000   84.0000
 20.0000  104.0000
 24.0000  124.0000

&gt;&gt;&gt; lfun.a 
5
&gt;&gt;&gt; <span class="org-variable-name">lfun.a</span>  = 0
&gt;&gt;&gt; 
&gt;&gt;&gt; a.tabulateFunction(lfun.<span class="org-builtin">eval</span>, 0.0, 25.0, 4.0)
Tabulating <span class="org-builtin">range</span>:  ; <span class="org-variable-name">xmin</span> = 0.0000 ; <span class="org-variable-name">xmax</span> = 25.0000 ; <span class="org-variable-name">step</span> = 4.0000
  0.0000    4.0000
  4.0000    4.0000
  8.0000    4.0000
 12.0000    4.0000
 16.0000    4.0000
 20.0000    4.0000
 24.0000    4.0000
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-03-05 Tue 01:20</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
