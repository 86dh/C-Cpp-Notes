<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-12-16 Sun 23:30 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shared Libraries - Binary Components</title>
<meta name="generator" content="Org mode" />
<meta name="description" content="cpp c++ code examples, demonstrations, design pattern and integration."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<link href="theme/org-nav-theme.css" rel="stylesheet">
<script src="theme/org-nav-theme.js"></script>
<link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Shared Libraries - Binary Components</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2357844">1. Shared Libraries - Binary Components</a>
<ul>
<li><a href="#org3862c41">1.1. Overview</a></li>
<li><a href="#orge74e65c">1.2. Example 1 - Shared Library libtest.dll - DLLs on Windows</a>
<ul>
<li><a href="#orge4f29fb">1.2.1. Overview</a></li>
<li><a href="#org1918479">1.2.2. Header macros</a></li>
<li><a href="#orge7aa1b9">1.2.3. Namespace Linalg</a></li>
<li><a href="#orgf9a9a38">1.2.4. C-interface of Namespace Linalg</a></li>
<li><a href="#org3087a08">1.2.5. Non-polymorphic Class - SampleClass</a></li>
<li><a href="#orga8aa558">1.2.6. C-interface for SampleClass</a></li>
<li><a href="#org9cdbf21">1.2.7. Polymorphic class InterfaceClass</a></li>
<li><a href="#orgbd82f75">1.2.8. DLL startup function DLLMain</a></li>
<li><a href="#orge33c919">1.2.9. DLL entry point for run32dll.exe</a></li>
<li><a href="#org91a7c35">1.2.10. C++ Client program - client1.cpp</a></li>
</ul>
</li>
<li><a href="#org7e05b65">1.3. <span class="todo TODO">TODO</span> Shared Libraries on Linux</a></li>
</ul>
</li>
</ul>
</div>
</div>
<ul class="org-ul">
<li><a href='index.html'>Index</a></li>
</ul>

<div id="outline-container-org2357844" class="outline-2">
<h2 id="org2357844"><span class="section-number-2">1</span> Shared Libraries - Binary Components</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org3862c41" class="outline-3">
<h3 id="org3862c41"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Shared libraries are compiled object-code exporting functions, data
structures and classes which can be used by many different
programs. They provide many benefits such as: faster compilation time;
less disk space usage since each program using the library do not
need a copy of the library source code or its compiled-code; ability
to update the library and provide security fixes to client
applications without recompilation, just by replacing the library
file. 
</p>

<p>
On Windows, shared libraries are called DLLs which stands for Dynamic
Linked Libraries, on Unix-like operating systems such as Linux, BSD
and MacOSX, they are called SO - shared objects or DSO - dynamic
shared objects. 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Comparison of shared libraries across different operating systems</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Operating</th>
<th scope="col" class="org-left">Long Name</th>
<th scope="col" class="org-left">Short name</th>
<th scope="col" class="org-left">File</th>
<th scope="col" class="org-left">Binary Format</th>
</tr>

<tr>
<th scope="col" class="org-left">System</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Extension</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Windows</td>
<td class="org-left">Dynamic Linked Library</td>
<td class="org-left">DLL</td>
<td class="org-left">.dll</td>
<td class="org-left">PE32/PE64 - Portable Executable</td>
</tr>

<tr>
<td class="org-left">Linux</td>
<td class="org-left">(Dynamic) Shared Object</td>
<td class="org-left">DSO or SO</td>
<td class="org-left">.so</td>
<td class="org-left">ELF or ELF64 (for 64 bits processors)</td>
</tr>

<tr>
<td class="org-left">BSD</td>
<td class="org-left">(Dynamic) Shared Object</td>
<td class="org-left">DSO or SO</td>
<td class="org-left">.so</td>
<td class="org-left">ELF or ELF64</td>
</tr>

<tr>
<td class="org-left">MacOSX</td>
<td class="org-left">-</td>
<td class="org-left">dylib</td>
<td class="org-left">.dylib or .so</td>
<td class="org-left">MachO</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Shared libraries are similar to executables, however they do not
have the main() function entry point.</li>
</ul>

<p>
In addition to C and C++, shared libraries, containing functions with
C-linkage, can also be used as binary components (libraries) and be
consumed from higher level programming languages such as Python, Ruby,
Java or C# through some foreign-function interface. In Python
C-functions can be imported from shared libraries using the <a href="https://docs.python.org/3/library/ctypes.html">cytpes</a>
library; in C# C-functions can be consumed using the P-invoke API and
in Java it is possible to use C-functions from shared libraries using
the JNI (Java Native Interface) or JNA, which is easier to use.
</p>

<p>
Note: 
</p>
<ul class="org-ul">
<li>Shared libraries are specific to a particular operating system and
are not part of C++ standard.</li>
</ul>
</div>
</div>

<div id="outline-container-orge74e65c" class="outline-3">
<h3 id="orge74e65c"><span class="section-number-3">1.2</span> Example 1 - Shared Library libtest.dll - DLLs on Windows</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orge4f29fb" class="outline-4">
<h4 id="orge4f29fb"><span class="section-number-4">1.2.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
<b>Source:</b>
</p>

<p>
Shared library Source Code
</p>

<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/testlib.cpp">file:src/dlls/example-windows1/testlib.cpp</a></li>
<li>File: <a href="src/dlls/example-windows1/testlib.hpp">file:src/dlls/example-windows1/testlib.hpp</a></li>
</ul>

<p>
Sample Client C++ Program:
</p>

<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/client1.cpp">file:src/dlls/example-windows1/client1.cpp</a></li>
</ul>

<p>
GIST - Better for online view: 
</p>

<ul class="org-ul">
<li><a href="https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71">Gisthub</a></li>
</ul>

<p>
<b>Compile the DLL libtest.dll and client program with MSVC</b> 
</p>

<p>
Shared Library 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ cl.exe testlib.cpp /EHsc /LD /nologo user32.lib
</pre>
</div>

<p>
C++ Client program (client code)
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ cl.exe /EHsc client.cpp /Fe:out.exe testlib.lib &amp;&amp; out.exe
</pre>
</div>

<p>
<b>Compile the DLL libtest.dll and client program with Mingw/GCC</b> 
</p>

<p>
Shared Library 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ testlib.cpp -o <span class="org-keyword">testlib.dll</span> -g -shared -std=c++14 -Wall
</pre>
</div>

<p>
C++ Client program 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ client.cpp -o <span class="org-keyword">client.exe</span> -g -std=c++14 testlib.dll -Wall
</pre>
</div>
</div>
</div>

<div id="outline-container-org1918479" class="outline-4">
<h4 id="org1918479"><span class="section-number-4">1.2.2</span> Header macros</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Sources:
</p>
<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/testlib.cpp">file:src/dlls/example-windows1/testlib.cpp</a></li>
<li>File: <a href="src/dlls/example-windows1/testlib.hpp">file:src/dlls/example-windows1/testlib.hpp</a></li>
</ul>

<p>
<b>teslib.hpp / Heade File - Macros</b>
</p>

<p>
The header files uses the following macros to reduce the boilerplate
necessary to export the library functions and classes. 
</p>

<ul class="org-ul">
<li>file: libstes.hpp =&gt; Macros for exporting functions and classes.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> _WIN32
  <span class="org-comment-delimiter">// </span><span class="org-comment">If not compiled for Windows, remove declspec directive.</span>
<span class="org-preprocessor">  #define</span> <span class="org-function-name">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">param</span><span class="org-rainbow-delimiters-depth-1">)</span>  
<span class="org-preprocessor">#endif</span> 

<span class="org-preprocessor">#define</span> <span class="org-variable-name">EXPORT_CPP</span>  <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-preprocessor">#ifdef</span> __cplusplus
  <span class="org-comment-delimiter">// </span><span class="org-comment">Indicat that a given symbol/function has C-linkage and</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">does not have name mangling. </span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">EXPORT_C</span> <span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">#else</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If a C-compiler uses this header, remove 'extern "C"'</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">EXPORT_C</span>  <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">#endif</span> 
</pre>
</div>
</div>
</div>

<div id="outline-container-orge7aa1b9" class="outline-4">
<h4 id="orge7aa1b9"><span class="section-number-4">1.2.3</span> Namespace Linalg</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
<b>Functions of Namespace Linalg</b> 
</p>

<p>
Namespace containing sample linear algebra functions, the function norm
computes an Euclidean norm of a N-dimension vector, the function
linTransform computes a linear transformation performing the
computation v[i] * a + b for each vector element. 
</p>

<p>
On Windows, all DLL symbols, such as functions, variables and clases,
are private by default, they are not exported by default as happens in
Unix-like OSes shared libraries. Therefore, in order to a function be
exported in a Windows shared library, it is necessary to use the MSVC or visual C++
compiler extension <code>__declspec(dllexport)</code> before the function declaration.
</p>

<ul class="org-ul">
<li>Interface =&gt; File: <b>testlib.hpp</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">The macro __cplusplus is used for allowing this </span>
<span class="org-comment"> * header to be used from 'C'. If a C compiler is used</span>
<span class="org-comment"> * all definitions inside this #ifdef are discarded.</span>
<span class="org-comment"> */</span>
<span class="org-preprocessor">#ifdef</span> __cplusplus
<span class="org-keyword">namespace</span> <span class="org-constant">Linalg</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        EXPORT_CPP <span class="org-type">double</span> <span class="org-function-name">norm</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        EXPORT_CPP <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">linTransform</span><span class="org-rainbow-delimiters-depth-2">(</span>
                <span class="org-type">double</span> <span class="org-variable-name">a</span>,
                <span class="org-type">double</span> <span class="org-variable-name">b</span>,
                <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span>
                <span class="org-rainbow-delimiters-depth-2">)</span>;

        EXPORT_CPP
        <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp;
        <span class="org-function-name">printVector</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">)</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-preprocessor">#endif</span> 
</pre>
</div>

<p>
The macro <code>EXPORT_CPP</code> expands to: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">EXPORT_CPP <span class="org-type">double</span> <span class="org-function-name">norm</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Macro EXPORT_CPP expansion </span>
<span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">double</span> <span class="org-function-name">norm</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
The compiler directives <b>#ifdef __cplusplus &#x2026; #endif</b> are used for
disabling this code block when the header is used by a C-compiler as
the C-language does not support classes, namespaces and many other C++
features. 
</p>

<ul class="org-ul">
<li>Implementation =&gt; file: <b>testlib.cpp</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Linear algebra tools </span>
<span class="org-keyword">namespace</span> <span class="org-constant">Linalg</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-2">(</span>dllexport<span class="org-rainbow-delimiters-depth-2">)</span>
     <span class="org-type">double</span> <span class="org-function-name">norm</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-type">double</span> <span class="org-variable-name">sum</span> = 0.0;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span> : xs<span class="org-rainbow-delimiters-depth-3">)</span> sum += x * x;
            <span class="org-keyword">return</span> <span class="org-constant">std</span>::sqrt<span class="org-rainbow-delimiters-depth-3">(</span>sum<span class="org-rainbow-delimiters-depth-3">)</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>

      <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-2">(</span>dllexport<span class="org-rainbow-delimiters-depth-2">)</span>
     <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
     <span class="org-function-name">linTransform</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-2">){</span>
         <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">out</span><span class="org-rainbow-delimiters-depth-3">(</span>xs.size<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
         ... ... .... 
     <span class="org-rainbow-delimiters-depth-2">}</span>

    ... ... 
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf9a9a38" class="outline-4">
<h4 id="orgf9a9a38"><span class="section-number-4">1.2.4</span> C-interface of Namespace Linalg</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
<b>C-interface of Namespace Linalg</b> 
</p>

<p>
A C-interface is necessary for ensuring that the DLL can be called
from a C-program or a foreign function interface of a higher level
language. 
</p>

<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Function declaration.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">======= C-interface for Linalg namespace =========//</span>
<span class="org-comment-delimiter">/* </span><span class="org-comment">----- C-Wrappers for Linalg namespace ---- */</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Handle or opaque pointer for std::vector&lt;double&gt; */</span>
<span class="org-keyword">typedef</span> <span class="org-type">void</span>* <span class="org-type">hVectorD</span>;

<span class="org-keyword">extern</span> <span class="org-string">"C"</span>  <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">double</span> <span class="org-function-name">testlib_vectorD_Linalg_norm</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">extern</span> <span class="org-string">"C"</span>  <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">void</span> <span class="org-function-name">testlib_vectorD_Linalg_printVector</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>, <span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
The <b>extern "C"</b> statements are necessary to compile the functions with
<span class="underline">C-linkage</span>, it means without <span class="underline">name mangling</span> (aka name decoration). In
every C program, the function symbols are generally the same as their
names. However, as C++ supports templates and function overloading,
many functions can have the same, with different type signatures,
C++ compiler mangles or decorates function names with a different
schema to make the symbol unique. 
</p>

<p>
Functions with C-linkage, can only use C-compatible types or PODs
types (Plain Old Data). Therefore, they cannot use STL container,
std::vector, std::string and so on. 
</p>

<p>
The statement <code>__declspec(dllexport)</code> is necessary to make annotated
functions' symbols visible. On Unix-like systems and Linux, it is not
necessary as it is MSVC (cl.exe) compiler extension. 
</p>


<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; C-interface function implementations.</li>
</ul>

<p>
The type synonym hVectorD is handle or a opaque poiter for the type
std::vector&lt;double&gt;. It is a workaround, to pass std::vector&lt;double&gt;
accross a DLL functions with C-linkage and use std::vector&lt;double&gt;
from C programs or foreign function interfaces. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Handler for double vector </span>
<span class="org-keyword">using</span> <span class="org-type">hVectorD</span> = <span class="org-type">void</span>*;
<span class="org-keyword">using</span> <span class="org-type">pVectorD</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>*;

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for vector&lt;double&gt; constructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">hVectorD</span>
<span class="org-function-name">testlib_vectorD_make0</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>n, x<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
  ... ... ...     ... ... ...     ... ... ... 

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for vector&lt;double&gt; destructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">void</span>
<span class="org-function-name">testlib_vectorD_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-keyword">delete</span> <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">pVectorD</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>hv<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapepr for Linalg::norm function */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">double</span>
<span class="org-function-name">testlib_vectorD_Linalg_norm</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">return</span> <span class="org-constant">Linalg</span>::norm<span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">pVectorD</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>hv<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
  ... ... ...     ... ... ...     ... ... ... 

</pre>
</div>
</div>
</div>





<div id="outline-container-org3087a08" class="outline-4">
<h4 id="org3087a08"><span class="section-number-4">1.2.5</span> Non-polymorphic Class - SampleClass</h4>
<div class="outline-text-4" id="text-1-2-5">
<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Class declaration.</li>
</ul>

<p>
In order to a class be exported in a Windows' shared library, it
requires the annotation <code>__declspec(dllexport)</code>.
</p>

<p>
Note: It will not be possible to compiled client program using this
class with a compiler different from the used to build the shared
library libtest.dll. It happens because, the C++ ABI - Application
Binary Interface is not the same accross different compilers. If the
DLL is compiled with MSVC, the only way to use this class from a
program compiled using MingW or even a different version of MSVC is
by using a C-interface (functions with C-linkage) and opaque
pointers (void* pointers). 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">======= Non-polymorphic class exported by DLL =========//</span>
<span class="org-preprocessor">#ifdef</span> __cplusplus
<span class="org-comment-delimiter">// </span><span class="org-comment">Non-polymorphic class </span>
<span class="org-keyword">class</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">SampleClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-variable-name">SampleClass</span><span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-variable-name">SampleClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; name<span class="org-rainbow-delimiters-depth-2">)</span>;   
        ~<span class="org-variable-name">SampleClass</span><span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
        <span class="org-type">int</span> <span class="org-variable-name">get</span><span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-type">void</span> <span class="org-variable-name">set</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> n<span class="org-rainbow-delimiters-depth-2">)</span>;    
<span class="org-function-name">private</span>:
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
        <span class="org-type">int</span> <span class="org-variable-name">m_counter</span>;  
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-preprocessor">#endif</span> 
</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; Class implementation.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">SampleClass</span>::SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>
   : m_name<span class="org-rainbow-delimiters-depth-1">(</span>name<span class="org-rainbow-delimiters-depth-1">)</span>, m_counter<span class="org-rainbow-delimiters-depth-1">(</span>0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Instance created with name = "</span> &lt;&lt; m_name &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">/** </span><span class="org-comment">Delegated constructor on right-hand-side */</span>
<span class="org-function-name">SampleClass</span>::SampleClass<span class="org-rainbow-delimiters-depth-1">()</span>: SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"unnamed"</span><span class="org-rainbow-delimiters-depth-1">){}</span>   

<span class="org-function-name">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"SampleClass =&gt; name = "</span><span class="org-rainbow-delimiters-depth-2">)</span> + m_name +  <span class="org-string">" deleted"</span>;
    DbgTrace<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::string <span class="org-constant">SampleClass</span>::getName<span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> m_name;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">int</span> <span class="org-constant">SampleClass</span>::<span class="org-constant">SampleClass</span>::<span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-1">(){</span>        
    <span class="org-keyword">return</span> m_counter;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">void</span> <span class="org-constant">SampleClass</span>::<span class="org-function-name">set</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Counter set to value = "</span> &lt;&lt; n &lt;&lt; <span class="org-constant">std</span>::endl;
    m_counter = n;
<span class="org-rainbow-delimiters-depth-1">}</span>   
</pre>
</div>
</div>
</div>

<div id="outline-container-orga8aa558" class="outline-4">
<h4 id="orga8aa558"><span class="section-number-4">1.2.6</span> C-interface for SampleClass</h4>
<div class="outline-text-4" id="text-1-2-6">
<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Functions declarations.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/* </span><span class="org-comment">----- C-Wrappers for SampleClass namespace ---- */</span>
<span class="org-keyword">using</span> <span class="org-type">hSampleClass</span> = <span class="org-type">void</span>*;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Nullable constructor zero-arg constructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">hSampleClass</span>
<span class="org-function-name">testlib_SampleClass_make0</span><span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Other constructor */</span>
EXPORT_C <span class="org-type">hSampleClass</span> <span class="org-function-name">testlib_SampleClass_make1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Destructor */</span>
EXPORT_C
<span class="org-type">void</span>
<span class="org-function-name">testlib_SampleClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Wrapper for get method */</span>
EXPORT_C
<span class="org-type">int</span>
<span class="org-function-name">testlib_SampleClass_get</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Wrapper for set method */</span>
EXPORT_C
<span class="org-type">void</span>
<span class="org-function-name">testlib_SampleClass_set</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">EXPORT_C</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>*
testlib_SampleClass_getName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">)</span>;

</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; Functions implementation.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">hSampleClass</span> = <span class="org-type">void</span>*;

<span class="org-comment-delimiter">/** </span><span class="org-comment">Nullable constructor zero-arg constructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">hSampleClass</span>
<span class="org-function-name">testlib_SampleClass_make0</span><span class="org-rainbow-delimiters-depth-1">(){</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">SampleClass</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Other constructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">hSampleClass</span>
<span class="org-function-name">testlib_SampleClass_make1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">SampleClass</span><span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Destructor */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">void</span>
<span class="org-function-name">testlib_SampleClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">delete</span> <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">SampleClass</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>hnd<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Wrapper for get method */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">int</span>
<span class="org-function-name">testlib_SampleClass_get</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hSampleClass</span> <span class="org-variable-name">hnd</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">SampleClass</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>hnd<span class="org-rainbow-delimiters-depth-2">)</span>-&gt;get<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9cdbf21" class="outline-4">
<h4 id="org9cdbf21"><span class="section-number-4">1.2.7</span> Polymorphic class InterfaceClass</h4>
<div class="outline-text-4" id="text-1-2-7">
<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; Class declaration.</li>
</ul>

<p>
As the name implies, this class is an interface class, which is a
class containing only pure virtual functions (abstract methods). As a
result, it is declared only in the header file and cannot be
instatiated directly. 
</p>

<p>
This class uses only C-types to be binary compatible with different
compilers, if it used STL containers such as string or any other
non-compatible C-type, it would not be possible to compile a C++
program using Mingw/GCC against this DLL built with MSVC.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Polymorphic Interface class binary compatible across different</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">compilers as it does not use any STL container on the interface.</span>
<span class="org-preprocessor">#ifdef</span> __cplusplus
<span class="org-keyword">struct</span> <span class="org-type">InterfaceClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">/* </span><span class="org-comment">Returns class unique ID */</span>
        <span class="org-keyword">virtual</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = 0;
        <span class="org-comment-delimiter">/** </span><span class="org-comment">Set class internal state */</span>
        <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
        <span class="org-keyword">virtual</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> = 0;

        <span class="org-comment-delimiter">/** </span><span class="org-comment">Virtual constructor */</span>
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">InterfaceClass</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">virtual ~InterfaceClass();</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-preprocessor">#else</span>
<span class="org-preprocessor">  #define</span> <span class="org-variable-name">InterfaceClass</span> <span class="org-type">void</span> 
<span class="org-preprocessor">#endif</span> 
</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; class ImplementationA of interface InterfaceClass.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">ImplementationA</span>: <span class="org-keyword">public</span> <span class="org-type">InterfaceClass</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
<span class="org-function-name">public</span>:
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span> = <span class="org-string">"ImplementationA"</span>;

    <span class="org-function-name">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">()</span>: m_name<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Unammed-A"</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-function-name">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>
       : m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span> 
    ~<span class="org-function-name">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">(){</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] ImplementationA deleted =&gt; name = "</span>
                   &lt;&lt; m_name
                   &lt;&lt; <span class="org-string">" ; type = "</span> &lt;&lt; class_id
                   &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>     
        <span class="org-keyword">return</span> class_id;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        m_name = name;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> m_name.c_str<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; class ImplementationB of interface InterfaceClass.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">ImplementationB</span>: <span class="org-keyword">public</span> <span class="org-type">InterfaceClass</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
<span class="org-function-name">public</span>:
    <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span> = <span class="org-string">"ImplementationB"</span>;

    <span class="org-function-name">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">()</span>: m_name<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Unammed-B"</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-function-name">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>
       : m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span> 
    ~<span class="org-function-name">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] ImplementationB deleted =&gt; name = "</span>
                  &lt;&lt; m_name
                  &lt;&lt; <span class="org-string">" ; type = "</span> &lt;&lt; class_id
                  &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>     
            <span class="org-keyword">return</span> class_id;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
            m_name = name;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
            <span class="org-keyword">return</span> m_name.c_str<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.hpp</b> =&gt; C-interface and factory function to load
implementations from the DLL.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Factory function */</span>
EXPORT_C <span class="org-type">InterfaceClass</span>* <span class="org-function-name">teslib_InterfaceClass_factory</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for destructor */</span>
EXPORT_C <span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">C-wrapper for getID method */</span>
<span class="org-type">EXPORT_C</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">EXPORT_C</span> <span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_setName</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">EXPORT_C</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; C-interfaces and factory functions
definitions.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">EXPORT_C <span class="org-type">InterfaceClass</span>*
<span class="org-function-name">teslib_InterfaceClass_factory</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">class_id</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">s</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span>class_id<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>s == <span class="org-string">"ImplementationA"</span><span class="org-rainbow-delimiters-depth-2">)</span>
            <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">ImplementationA</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>s == <span class="org-string">"ImplementationB"</span><span class="org-rainbow-delimiters-depth-2">)</span>
            <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">ImplementationB</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

EXPORT_C <span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">delete</span> hinst;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">EXPORT_C</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> hinst-&gt;getID<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">EXPORT_C</span>
<span class="org-type">void</span> <span class="org-function-name">testlib_InterfaceClass_setName</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    hinst-&gt;setName<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">EXPORT_C</span>
<span class="org-keyword">const</span> <span class="org-type">char</span>* testlib_InterfaceClass_getName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinst</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">return</span> hinst-&gt;getName<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbd82f75" class="outline-4">
<h4 id="orgbd82f75"><span class="section-number-4">1.2.8</span> DLL startup function DLLMain</h4>
<div class="outline-text-4" id="text-1-2-8">
<p>
When a Windows shared library is loaded at compile-time or at runtime
by some process, the function DLLMain is always invoked, it is similar
to the function main() from an executable. 
</p>

<p>
Note: logging statements with printf, std::cout, std::cerr will not
printed if the DLL is loaded by some non-console program, a program
compiled to the <span class="underline">window subsystem</span>. Therefore, the easiest way to log is
to use the OutputDebugString function which output can viewed by the
DebugView sysinternal tool. 
</p>


<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; DLL main function.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">- DLL Entry point - main function of DLL which is executed when</span>
<span class="org-comment">    the DLL is loaded by some process.</span>
<span class="org-comment"> */</span>
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
BOOL <span class="org-type">APIENTRY</span> <span class="org-function-name">DllMain</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">HINSTANCE</span> <span class="org-variable-name">hInst</span>, <span class="org-type">DWORD</span> <span class="org-variable-name">reason</span>, <span class="org-type">LPVOID</span> <span class="org-variable-name">lpReserved</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">text</span> =
           <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"DLL Loaded into the process =&gt; PID = "</span><span class="org-rainbow-delimiters-depth-2">)</span>
           + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-2">(</span>::GetCurrentProcessId<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   WindbgTrace<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;
   DbgTrace<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>;      
    <span class="org-keyword">switch</span> <span class="org-rainbow-delimiters-depth-2">(</span>reason<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">case</span> DLL_PROCESS_ATTACH:
        WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL attached to process"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL attached to process."</span><span class="org-rainbow-delimiters-depth-3">)</span>;           
      <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> DLL_PROCESS_DETACH:
        WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"=&gt; DLL detached."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"=&gt; DLL attached"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
      <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> DLL_THREAD_ATTACH:
        WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL attached to thread"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL detached to thread."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> DLL_THREAD_DETACH:
        WindbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL detached from thread"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        DbgTrace<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"DLL detached from thread."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
      <span class="org-keyword">break</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-keyword">return</span> TRUE;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Another more portable way to peform some way action when the DLL is
loaded by a process or unloaded is to use a static object. The startup
task is executed int the object's constructor and the finalization
task, which happens when the process ends, is executed at object's
destructor. 
</p>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b> =&gt; Static Object for replacing DLLMain</li>
</ul>

<p>
The class _StaticObject and a static instance of it is defined within
an anonymous namespace to make them private to the compilation unit
testlib.cpp and not allow them to be used from anywhere else. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Class private to this compilation unit - cannot be accessed from</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">any other file</span>
<span class="org-keyword">namespace</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">class</span> <span class="org-type">_StaticObject</span><span class="org-rainbow-delimiters-depth-2">{</span>     
   <span class="org-keyword">public</span>:
       <span class="org-keyword">using</span> <span class="org-type">Action</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>;
       <span class="org-type">Action</span> <span class="org-variable-name">m_end</span>;

       <span class="org-function-name">_StaticObject</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Action</span> <span class="org-variable-name">init</span>, <span class="org-type">Action</span> <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-3">)</span>
               :  m_end<span class="org-rainbow-delimiters-depth-3">(</span>end<span class="org-rainbow-delimiters-depth-3">)</span>
       <span class="org-rainbow-delimiters-depth-3">{</span>
               init<span class="org-rainbow-delimiters-depth-4">()</span>;
       <span class="org-rainbow-delimiters-depth-3">}</span>
       ~<span class="org-function-name">_StaticObject</span><span class="org-rainbow-delimiters-depth-3">(){</span> m_end<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
   <span class="org-rainbow-delimiters-depth-2">}</span>;

   <span class="org-comment-delimiter">// </span><span class="org-comment">Static object for replacing DLLMain </span>
   <span class="org-keyword">auto</span> <span class="org-variable-name">initDLL</span> = _StaticObject<span class="org-rainbow-delimiters-depth-2">(</span>
      <span class="org-rainbow-delimiters-depth-3">[]{</span>
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [StaticObject] =&gt; Initialize DLL"</span>
                       &lt;&lt; <span class="org-constant">std</span>::endl;                        
      <span class="org-rainbow-delimiters-depth-3">}</span>,
      <span class="org-rainbow-delimiters-depth-3">[]{</span>   
           <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [StaticObject] =&gt; Shutdown DLL"</span>
                     &lt;&lt; <span class="org-constant">std</span>::endl;                              
      <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orge33c919" class="outline-4">
<h4 id="orge33c919"><span class="section-number-4">1.2.9</span> DLL entry point for run32dll.exe</h4>
<div class="outline-text-4" id="text-1-2-9">
<p>
This function is a DLL entry point for the Windows program
rundll32.exe which can execute this function with: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ rundll32.exe testlib.dll,entryPoint1
$ rundll32.exe testlib.dll,entryPoint1 arg0 arg1 <span class="org-type">arg2</span> ... <span class="org-variable-name">argn</span> 
</pre>
</div>

<p>
When the DLL testlib.dll is run with run32dll calling the function
entryPoint1, it will display a message box. 
</p>

<p>
Note: It is an optional function which could be used for installing
the DLL in the system or creating some entry in Windows' registry. 
</p>

<ul class="org-ul">
<li>File: <b>testlib.cpp</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-keyword">__declspec</span><span class="org-rainbow-delimiters-depth-1">(</span>dllexport<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">void</span> <span class="org-function-name">entryPoint1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">HWND</span> <span class="org-variable-name">hwn</span>, <span class="org-type">HINSTANCE</span> <span class="org-variable-name">hinst</span>, <span class="org-type">LPSTR</span> <span class="org-variable-name">cmdLine</span>, <span class="org-type">int</span> <span class="org-variable-name">nCmdShow</span><span class="org-rainbow-delimiters-depth-1">){</span>  
     DbgDisp<span class="org-rainbow-delimiters-depth-2">(</span>cmdLine<span class="org-rainbow-delimiters-depth-2">)</span>;
     OutputDebugString<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Rudll32 called entryPoint1()"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     MessageBoxA<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">NULL</span>, <span class="org-string">"DLL ENTRY POINT"</span>, <span class="org-string">"Entry point 1"</span>, 0<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org91a7c35" class="outline-4">
<h4 id="org91a7c35"><span class="section-number-4">1.2.10</span> C++ Client program - client1.cpp</h4>
<div class="outline-text-4" id="text-1-2-10">
<ul class="org-ul">
<li>File: <a href="src/dlls/example-windows1/client1.cpp">file:src/dlls/example-windows1/client1.cpp</a></li>
</ul>

<p>
<b>File client1.cpp</b>
</p>

<p>
Includes: 
</p>

<ul class="org-ul">
<li>Note: (#include "testlib.hpp") a header file between quotes,
indicates to the compiler that the header is in the same directory
as the source file client1.cpp.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">ostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string">"testlib.hpp"</span>
</pre>
</div>

<p>
Declaration of functions with C-linkages not declarated in the header
testlib.hpp
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-type">hVectorD</span> <span class="org-function-name">testlib_vectorD_make0</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-type">hVectorD</span> <span class="org-function-name">testlib_vectorD_make1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">double</span> <span class="org-variable-name">array</span> <span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">extern</span> <span class="org-string">"C"</span> <span class="org-type">void</span> <span class="org-function-name">testlib_vectorD_delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">hVectorD</span> <span class="org-variable-name">hv</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Main function - Experiment 1 and Experiment 2:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> DISABLE
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n=== EXPERIMENT 1 ===&gt; Import C++ functions from DLL"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

DbgTrace<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Main process starts here."</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> xs<span class="org-rainbow-delimiters-depth-1">{</span>1.0, 2.0, 3.0, 4.0, 5.0<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; Linalg::norm(xs) "</span> &lt;&lt; <span class="org-constant">Linalg</span>::norm<span class="org-rainbow-delimiters-depth-1">(</span>xs<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"=&gt; xs = "</span>; <span class="org-constant">Linalg</span>::printVector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cout, xs<span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"=== EXPERIMENT 2 ===&gt; Import class from DLL"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-keyword">auto</span> <span class="org-variable-name">cls</span> = SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Dummy"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
cls.set<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"cls.getName() = "</span> &lt;&lt; cls.getName<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"    cls.get() = "</span> &lt;&lt; cls.get<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-preprocessor">#endif</span> <span class="org-comment-delimiter">// </span><span class="org-comment">-- eof DISABLE flag</span>
</pre>
</div>

<p>
Main Function - Experiment 3 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">//</span><span class="org-comment">=========&gt;&gt; Load functions and classes using C-interface ==============//</span>

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n== EPERIMENT 3 ===&gt; Import C-functions from DLL - C-interface"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-type">double</span> <span class="org-variable-name">arr</span> <span class="org-rainbow-delimiters-depth-1">[]</span> = <span class="org-rainbow-delimiters-depth-1">{</span>1, 2, 3, 4, 5<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">hVectorD</span> <span class="org-variable-name">v1</span> = testlib_vectorD_make1<span class="org-rainbow-delimiters-depth-1">(</span>5, arr<span class="org-rainbow-delimiters-depth-1">)</span>;
testlib_vectorD_Linalg_printVector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"v1"</span>, v1<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"norm(v1) = "</span> &lt;&lt; testlib_vectorD_Linalg_norm<span class="org-rainbow-delimiters-depth-1">(</span>v1<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;

testlib_vectorD_delete<span class="org-rainbow-delimiters-depth-1">(</span>v1<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Main Functions - Experiment 4 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n== EPERIMENT 4 ===&gt; Non-polymorphic class with C-interface "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-type">hSampleClass</span> <span class="org-variable-name">hcls</span> = testlib_SampleClass_make1<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"[EXPERIMENT4]ClassHandle-OOP-C-API"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"[EXPERIMENT 4] hcls.getName() = "</span> &lt;&lt; testlib_SampleClass_getName<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
testlib_SampleClass_set<span class="org-rainbow-delimiters-depth-1">(</span>hcls, 100<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"[EXPERIMENT 4] hcls.get()     = "</span> &lt;&lt; testlib_SampleClass_get<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
testlib_SampleClass_set<span class="org-rainbow-delimiters-depth-1">(</span>hcls, 200<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"[EXPERIMENT 4] hcls.get()     = "</span> &lt;&lt; testlib_SampleClass_get<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;

testlib_SampleClass_delete<span class="org-rainbow-delimiters-depth-1">(</span>hcls<span class="org-rainbow-delimiters-depth-1">)</span>;   
</pre>
</div>

<p>
Main Functions - Experiment 5 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n== EPERIMENT 5 ===&gt; Load polymorphic classes from DLL "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinstA</span> = teslib_InterfaceClass_factory<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ImplementationA"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">InterfaceClass</span>* <span class="org-variable-name">hinstB</span> = teslib_InterfaceClass_factory<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ImplementationB"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstA-&gt;getID() = "</span> &lt;&lt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstA-&gt;getID() = "</span> &lt;&lt; hinstB-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
hinstA-&gt;setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ClassA-implA"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
hinstB-&gt;setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ClassB-implB"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstA-&gt;getName() = "</span> &lt;&lt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; hinstB-&gt;getName() = "</span> &lt;&lt; hinstB-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-comment-delimiter">// </span><span class="org-comment">Note: If delete is used directly to delete hinstA and hinstB,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">a segmentatin fault will happen whenc compiling with Mingw/GCC</span>
testlib_InterfaceClass_delete<span class="org-rainbow-delimiters-depth-1">(</span>hinstA<span class="org-rainbow-delimiters-depth-1">)</span>;
testlib_InterfaceClass_delete<span class="org-rainbow-delimiters-depth-1">(</span>hinstB<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] After deleting instances"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

DbgTrace<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Program ended OK."</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Compile and run client code with MSVC</b>
</p>

<p>
Note: Both the DLL and the client code are compiled with MSVC-2017 64
bits target.
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cl.exe /EHsc client.cpp /nologo /Fe:client1.exe testlib.lib &amp;&amp; client1.exe

<span class="org-comment-delimiter"># </span><span class="org-comment">Output: </span>
client.cpp
   Creating library client1.lib and object client1.exp
 [StaticObject] =&gt; Initialize DLL
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the process =&gt; PID = 1112
<span class="org-function-name">testlib.cpp</span>:45: &lt;DllMain&gt; DLL attached to process.

=== EXPERIMENT 1 ===&gt; Import C++ functions from DLL
<span class="org-function-name">client.cpp</span>:33: &lt;main&gt; Main process starts here.
 =&gt; Linalg::norm(xs) 7.4162
=&gt; xs = [5]( 1, 2, 3, 4, 5,  )
=== EXPERIMENT 2 ===&gt; Import class from DLL
 Instance created with name = Dummy
 Counter set to value = 100
<span class="org-function-name">cls.getName</span>() = Dummy
    cls.get() = 100

== EPERIMENT 3 ===&gt; Import C-functions from DLL - C-interface
v1 = [5]( 1, 2, 3, 4, 5,  )
<span class="org-function-name">norm</span>(v1) = 7.4162

== EPERIMENT 4 ===&gt; Non-polymorphic class with C-interface 
 Instance created with name = [EXPERIMENT4]ClassHandle-OOP-C-API
[EXPERIMENT 4] hcls.getName() = [EXPERIMENT4]ClassHandle-OOP-C-API
 Counter set to value = 100
[EXPERIMENT 4] hcls.get()     = 100
 Counter set to value = 200
[EXPERIMENT 4] hcls.get()     = 200
<span class="org-function-name">testlib.cpp</span>:159: &lt;SampleClass::~SampleClass&gt; SampleClass =&gt; name = [EXPERIMENT4]ClassHandle-OOP-C-API deleted

== EPERIMENT 5 ===&gt; Load polymorphic classes from DLL 
 =&gt; hinstA-&gt;getID() = ImplementationA
 =&gt; hinstA-&gt;getID() = ImplementationB
 =&gt; hinstA-&gt;getName() = ImplementationA
 =&gt; hinstB-&gt;getName() = ImplementationB
 [INFO] ImplementationA deleted =&gt; name = ClassA-implA ; <span class="org-builtin">type</span> = ImplementationA
 [INFO] ImplementationB deleted =&gt; name = ClassB-implB ; <span class="org-builtin">type</span> = ImplementationB
 [INFO] After deleting instances
<span class="org-function-name">client.cpp</span>:87: &lt;main&gt; Program ended OK.
<span class="org-function-name">testlib.cpp</span>:159: &lt;SampleClass::~SampleClass&gt; SampleClass =&gt; name = Dummy deleted
<span class="org-function-name">testlib.cpp</span>:39: &lt;DllMain&gt; DLL Loaded into the process =&gt; PID = 1112
<span class="org-function-name">testlib.cpp</span>:49: &lt;DllMain&gt; =&gt; DLL attached
 [StaticObject] =&gt; Shutdown DLL

</pre>
</div>

<p>
<b>[FAILURE] ABI - Issue - Compile with Mingw client1.cpp against testlib.dll built with MSVC</b>
</p>

<p>
The client code is compiled with Mingw and the library was built with
MSVC-2017 for 64 bits target.
</p>

<p>
Build and run client [FAILURE]:
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ client1.cpp -g -o <span class="org-keyword">client1-gcc.exe</span> -std=c++14 testlib.dll  &amp;&amp; client1-gcc.exe
<span class="org-function-name">C</span>:\Users\archbox\AppData\Local\Temp\cckNg9eZ.o: In function `main<span class="org-warning">'</span>:
<span class="org-function-name">client1.cpp</span>:35: undefined reference to `<span class="org-constant">Linalg</span>::norm<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:36: undefined reference to `<span class="org-constant">Linalg</span>::printVector<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp;, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:39: undefined reference to `<span class="org-constant">SampleClass</span>::SampleClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">__cxx11</span>::<span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span>, <span class="org-constant">std</span>::<span class="org-type">char_traits</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:40: undefined reference to `<span class="org-constant">SampleClass</span>::set<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:41: undefined reference to `<span class="org-constant">SampleClass</span>::getName<span class="org-rainbow-delimiters-depth-1">[</span>abi:cxx11<span class="org-rainbow-delimiters-depth-1">]()</span> <span class="org-keyword">const</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:42: undefined reference to `<span class="org-constant">SampleClass</span>::get<span class="org-rainbow-delimiters-depth-1">()</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:39: undefined reference to `<span class="org-constant">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">()</span><span class="org-warning">'</span>
<span class="org-function-name">client1.cpp</span>:39: undefined reference to `<span class="org-constant">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">()</span><span class="org-warning">'</span>
<span class="org-function-name">collect2.exe</span>: error: ld returned 1 exit status
Compilation <span class="org-compilation-error">exited abnormally</span> with code <span class="org-compilation-error">1</span> at Sun Dec 16 17:41:47
</pre>
</div>

<p>
The compilation fails because C++ does not have a standard and stable
ABI - Application Binary Interface, as a result, it is not possible to
use an object-code (here - any type of compiled code) built by a
different compiler than the current one. The ABI comprises the name
mangling schema or name decoration schema which is compiler-dependent,
padding, class memory layout and so on. In addition to ABI issues, the
STL - Standard Template Library implementations may not be compatible
and also not be the same across different compilers. 
</p>

<p>
The only way to ensure that a DLL can work with all possible compilers
is to use a functions with C-linkage (extern "C") with opaque pointers
(void*) for passing around classes and wrapped STL containers. Classes
can be used by different compilers, only if they are interface classes
(classes with only pure virtual functions) containing only
C-compatible types in the declaration. 
</p>


<p>
<b>Compile with Mingw client1.cpp against testlib.dll built with MSVC</b>
</p>

<p>
The compilation works when compiling with the custom flag -DDISABLE.
The directive <span class="underline">#ifndef DISABLE &#x2026; #endif</span> removes all usages of the
namespace Linalg and the class SampleClass. This flag makes main the
function use only functions with C-linkage and the interface class
InterfaceClass.
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ client.cpp -g -o <span class="org-keyword">client-gcc.exe</span> -std=c++14 testlib.dll -DDISABLE   &amp;&amp; client-gcc.exe

   <span class="org-rainbow-delimiters-depth-1">[</span>StaticObject<span class="org-rainbow-delimiters-depth-1">]</span> =&gt; Initialize DLL
  testlib.cpp:39: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> DLL Loaded into the process =&gt; PID = 5724
  testlib.cpp:45: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> DLL attached to process.

  == EPERIMENT 3 ===&gt; Import C-functions from DLL - C-interface
  v1 = <span class="org-rainbow-delimiters-depth-1">[</span>5<span class="org-rainbow-delimiters-depth-1">](</span> 1, 2, 3, 4, 5,  <span class="org-rainbow-delimiters-depth-1">)</span>
  norm<span class="org-rainbow-delimiters-depth-1">(</span>v1<span class="org-rainbow-delimiters-depth-1">)</span> = 7.4162

  == EPERIMENT 4 ===&gt; Non-polymorphic <span class="org-keyword">class</span> with C-interface 
   Instance created with name = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">EXPERIMENT4</span><span class="org-rainbow-delimiters-depth-1">]</span>ClassHandle-OOP-C-API
  <span class="org-rainbow-delimiters-depth-1">[</span>EXPERIMENT 4<span class="org-rainbow-delimiters-depth-1">]</span> hcls.getName<span class="org-rainbow-delimiters-depth-1">()</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">EXPERIMENT4</span><span class="org-rainbow-delimiters-depth-1">]</span>ClassHandle-OOP-C-API
   Counter set to value = 100
  <span class="org-rainbow-delimiters-depth-1">[</span>EXPERIMENT 4<span class="org-rainbow-delimiters-depth-1">]</span> hcls.get<span class="org-rainbow-delimiters-depth-1">()</span>     = 100
   Counter set to value = 200
  <span class="org-rainbow-delimiters-depth-1">[</span>EXPERIMENT 4<span class="org-rainbow-delimiters-depth-1">]</span> hcls.get<span class="org-rainbow-delimiters-depth-1">()</span>     = 200
  testlib.cpp:159: <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">SampleClass</span>::~SampleClass<span class="org-rainbow-delimiters-depth-1">&gt;</span> SampleClass =&gt; name = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">EXPERIMENT4</span><span class="org-rainbow-delimiters-depth-1">]</span>ClassHandle-OOP-C-API deleted

  == EPERIMENT 5 ===&gt; Load polymorphic classes from DLL 
   =&gt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationA
   =&gt; hinstA-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationB
   =&gt; hinstA-&gt;getName<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationA
   =&gt; hinstB-&gt;getName<span class="org-rainbow-delimiters-depth-1">()</span> = ImplementationB
   <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> ImplementationA deleted =&gt; name = ClassA-implA ; type = ImplementationA
   <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> ImplementationB deleted =&gt; name = ClassB-implB ; type = ImplementationB
   <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> After deleting instances
  client.cpp:87: <span class="org-rainbow-delimiters-depth-1">&lt;</span>main<span class="org-rainbow-delimiters-depth-1">&gt;</span> Program ended OK.
  testlib.cpp:39: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> DLL Loaded into the process =&gt; PID = 5724
  testlib.cpp:49: <span class="org-rainbow-delimiters-depth-1">&lt;</span>DllMain<span class="org-rainbow-delimiters-depth-1">&gt;</span> =&gt; DLL attached
   <span class="org-rainbow-delimiters-depth-1">[</span>StaticObject<span class="org-rainbow-delimiters-depth-1">]</span> =&gt; Shutdown DLL
</pre>
</div>
</div>
</div>
</div>








<div id="outline-container-org7e05b65" class="outline-3">
<h3 id="org7e05b65"><span class="section-number-3">1.3</span> <span class="todo TODO">TODO</span> Shared Libraries on Linux</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2018-12-16 Sun 23:30</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
