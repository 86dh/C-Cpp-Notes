<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-12-23 Mon 19:16 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CPP / C++ Notes</title>
<meta name="generator" content="Org mode" />
<meta name="description" content="cpp c++ code examples, demonstrations, design pattern and integration."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<link href="theme/org-nav-theme.css" rel="stylesheet">
<script src="theme/org-nav-theme.js"></script>
<link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CPP / C++ Notes</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf7daed0">1. Understanding C++</a>
<ul>
<li><a href="#orgb103d15">1.1. Features</a>
<ul>
<li><a href="#org007556f">1.1.1. C++ Benefits and Costs</a></li>
<li><a href="#orgc19e80a">1.1.2. C++ Language features</a></li>
<li><a href="#org3ec0d12">1.1.3. C++ New Features and Standards</a></li>
</ul>
</li>
<li><a href="#orgdb08586">1.2. C++ Comparison and Alternatives</a>
<ul>
<li><a href="#orgb280fd7">1.2.1. C++ Comparison with Java and C#</a></li>
<li><a href="#org7514fe2">1.2.2. Comparison C X C++(CPP)</a></li>
</ul>
</li>
<li><a href="#orgccb21ae">1.3. Minimal C++ Programs</a>
<ul>
<li><a href="#orgc196bd2">1.3.1. Simple minimal C++ program</a></li>
<li><a href="#orgb0ab91e">1.3.2. Variations of main function</a></li>
</ul>
</li>
<li><a href="#org10ffac9">1.4. Simple Variable Definition and Initialization</a></li>
<li><a href="#orgdbdbdd8">1.5. Literals and C++14  Literals</a></li>
<li><a href="#orgd0f862d">1.6. Control Structures</a>
<ul>
<li><a href="#org4d277ca">1.6.1. ternary operator - question mark (?)</a></li>
<li><a href="#orgdfbf49a">1.6.2. if-else</a></li>
<li><a href="#org7ee5808">1.6.3. switch case</a></li>
<li><a href="#org0d4df04">1.6.4. for loop</a></li>
<li><a href="#org622d0c4">1.6.5. while loop</a></li>
<li><a href="#org1a85ef4">1.6.6. do - while loop</a></li>
</ul>
</li>
<li><a href="#org75131e5">1.7. Basic Console IO</a>
<ul>
<li><a href="#org5d4e0e3">1.7.1. Overview</a></li>
<li><a href="#org7953563">1.7.2. Example - Old C-IO functions</a></li>
<li><a href="#org105e128">1.7.3. Example - Reading from Console</a></li>
<li><a href="#orga4323bc">1.7.4. Basic IO program</a></li>
</ul>
</li>
<li><a href="#org5bdb301">1.8. <span class="todo TODO">TODO</span> Functions/Procedures</a>
<ul>
<li><a href="#org19f85d5">1.8.1. Overview</a></li>
<li><a href="#orgee94f32">1.8.2. Simple function with all possible declarations</a></li>
<li><a href="#org35e6ff4">1.8.3. Functions with default parameters</a></li>
<li><a href="#org109c752">1.8.4. Function overload</a></li>
<li><a href="#org5717db9">1.8.5. Functions with static variables - stateful functions</a></li>
</ul>
</li>
<li><a href="#org808462e">1.9. String Manipulation</a>
<ul>
<li><a href="#org46c3d26">1.9.1. Class std::string</a></li>
<li><a href="#org040f949">1.9.2. Concatenate string literals</a></li>
<li><a href="#org055b819">1.9.3. C++14 String literals and C++11 Raw string literals</a></li>
<li><a href="#org662e94e">1.9.4. Numerical Parsers Functions (C++11)</a></li>
<li><a href="#org7c44faf">1.9.5. Function to_string (C++11)</a></li>
<li><a href="#org963ec1a">1.9.6. Printing to string with std::stringstream</a></li>
<li><a href="#orgc850375">1.9.7. <span class="todo TODO">TODO</span> Parsing strings with std::stringstream</a></li>
<li><a href="#orgf44c3b6">1.9.8. Transform string to uppercase or lowercase</a></li>
<li><a href="#org8a0e132">1.9.9. Check whether a string contains substring</a></li>
<li><a href="#org8b503d4">1.9.10. Search and replace</a></li>
<li><a href="#orga0497e8">1.9.11. Character Testing</a></li>
<li><a href="#org0035a84">1.9.12. Split string by delimiter</a></li>
<li><a href="#org36a6bfa">1.9.13. Extract quoted string (C++14)</a></li>
<li><a href="#orgbcb2d4b">1.9.14. Parse comma separated value - CSV row</a></li>
<li><a href="#org760daf5">1.9.15. C++11 Regular Expressions Regex</a></li>
</ul>
</li>
<li><a href="#org7730dc5">1.10. C++11 - Uniform Initialization</a></li>
<li><a href="#orgc268dd7">1.11. Iterator based loops and for-range based loops</a>
<ul>
<li><a href="#orgb51ccfb">1.11.1. Iterator based loop</a></li>
<li><a href="#orgf27af6e">1.11.2. For-range based loops</a></li>
</ul>
</li>
<li><a href="#orgc14b915">1.12. C++11 - Scoped Enum</a></li>
<li><a href="#orga841f0b">1.13. Functor Function-Object and higher order functions</a></li>
<li><a href="#org9b101be">1.14. Lambda Expressions</a>
<ul>
<li><a href="#org0d4fc14">1.14.1. Overview</a></li>
<li><a href="#org4ef5110">1.14.2. <span class="todo TODO">TODO</span> Basic Examples</a></li>
<li><a href="#org6567c48">1.14.3. Lambdas in Deep</a></li>
<li><a href="#orgf6af1e6">1.14.4. Stateful lambdas</a></li>
<li><a href="#org4585d7f">1.14.5. Self-executable lambda for complex initialization</a></li>
<li><a href="#org94d906c">1.14.6. Universal function adapter - std::bind</a></li>
</ul>
</li>
<li><a href="#org1d65aae">1.15. OOP Simple Class</a></li>
<li><a href="#org42d1277">1.16. Conversion Constructor X Explicit Constructor - explicit keyword</a></li>
<li><a href="#orgbfc524d">1.17. OOP Value Semantics X Reference Semantics</a></li>
<li><a href="#org6a97349">1.18. <span class="todo TODO">TODO</span> Memory Allocation - Stack X Heap</a>
<ul>
<li><a href="#org2001048">1.18.1. Program/Process memory</a></li>
<li><a href="#orgae8eb38">1.18.2. stack Allocation - Automatic Variables</a></li>
<li><a href="#org0f44fb5">1.18.3. Dynamic/Heap Allocation</a></li>
<li><a href="#org941d117">1.18.4. Limits of stack and heap allocation</a></li>
<li><a href="#orgd51a1a0">1.18.5. New and delete overloading functions</a></li>
<li><a href="#org14becc7">1.18.6. Placement new and delete operators</a></li>
<li><a href="#org633fffa">1.18.7. References and further reading</a></li>
</ul>
</li>
<li><a href="#org40c9378">1.19. OOP Object Lifecycle</a></li>
<li><a href="#orgfbcead6">1.20. OOP Polymorphism and Inheritance</a>
<ul>
<li><a href="#org4e075d8">1.20.1. Overview</a></li>
<li><a href="#org361232b">1.20.2. OOP - Dynamic Polymorphism in deep</a></li>
<li><a href="#org45de873">1.20.3. Dynamic Polymorphism example - code</a></li>
<li><a href="#orgfd8fbe5">1.20.4. STL containers and polymorphism</a></li>
</ul>
</li>
<li><a href="#org1ac1668">1.21. OOP Operator Overloading</a>
<ul>
<li><a href="#org581343c">1.21.1. Overview</a></li>
<li><a href="#org59afa67">1.21.2. Example: Arithmetic member function operator overloading</a></li>
<li><a href="#orgb2826d8">1.21.3. Example: Arithmetic free-function function operator overloading</a></li>
<li><a href="#org925574b">1.21.4. Example: Arithmetic friend function operator overloading</a></li>
<li><a href="#orgbddae68">1.21.5. Example: Insertion &lt;&lt; and extraction &gt;&gt; operator overload</a></li>
<li><a href="#org95a928c">1.21.6. Member function operator overloading reference card</a></li>
<li><a href="#org2c3722e">1.21.7. Free function operator overloading tables reference card</a></li>
<li><a href="#org34962a0">1.21.8. References</a></li>
</ul>
</li>
<li><a href="#org740023d">1.22. <span class="todo TODO">TODO</span> OOP Multiple Inheritance</a>
<ul>
<li><a href="#org3e7962f">1.22.1. Ambiguity resolution</a></li>
<li><a href="#org1c39f55">1.22.2. <span class="todo TODO">TODO</span> OOP Diamond problem</a></li>
<li><a href="#orgceeba86">1.22.3. References and further reading:</a></li>
</ul>
</li>
<li><a href="#org8c71d55">1.23. Type Casting / Type Conversion</a>
<ul>
<li><a href="#orga0af697">1.23.1. Overview</a></li>
<li><a href="#org34b357a">1.23.2. Example: Old C-Style Casting:</a></li>
<li><a href="#orge4672cd">1.23.3. Example: Static Casting</a></li>
<li><a href="#orgc58bb2c">1.23.4. Example: Reinterpret Cast</a></li>
<li><a href="#org9d7d130">1.23.5. Example: Const cast</a></li>
<li><a href="#org0b9b6cc">1.23.6. References and further reading</a></li>
</ul>
</li>
<li><a href="#org2d816f4">1.24. OOP RTTI - Runtime Type Identification</a>
<ul>
<li><a href="#org7afbe8c">1.24.1. Overview</a></li>
<li><a href="#org825861e">1.24.2. Operator typeid</a></li>
<li><a href="#org9ec8323">1.24.3. Operator dynamic_cast</a></li>
</ul>
</li>
<li><a href="#org4c34af7">1.25. Friend Functions</a></li>
<li><a href="#org91a2428">1.26. Namespaces</a>
<ul>
<li><a href="#org5fa6a02">1.26.1. Summary</a></li>
<li><a href="#orgb0f6195">1.26.2. Examples</a></li>
</ul>
</li>
<li><a href="#org9943de4">1.27. Move Semantics</a>
<ul>
<li><a href="#org79623aa">1.27.1. r-value and l-values</a></li>
<li><a href="#org2fa4e6e">1.27.2. r-value references and r-value references</a></li>
<li><a href="#org0e3c57e">1.27.3. Move-semantics member functions</a></li>
<li><a href="#orgdaa4b1a">1.27.4. Signature of copy and move member functions</a></li>
<li><a href="#org1ac0de0">1.27.5. Example: Move Semantics Member Functions</a></li>
<li><a href="#orge8fbc9d">1.27.6. Move Semantics References from C++ standard</a></li>
<li><a href="#org542b631">1.27.7. References and further reading</a></li>
</ul>
</li>
<li><a href="#org26b3ed6">1.28. Smart Pointers</a>
<ul>
<li><a href="#org8a0de53">1.28.1. Problems of Raw Pointer</a></li>
<li><a href="#orgff38e91">1.28.2. Smart Pointers from standard library</a></li>
<li><a href="#org1e2eab2">1.28.3. Other Smart Pointer Implementations</a></li>
<li><a href="#orgc5af499">1.28.4. Documentation Links</a></li>
<li><a href="#org6779604">1.28.5. std::unique_ptr</a></li>
<li><a href="#org89b1e3a">1.28.6. std::shared_ptr</a></li>
<li><a href="#orgfc61e65">1.28.7. Best practices and things to avoid for std::shared_ptr</a></li>
<li><a href="#org4a524ce">1.28.8. Example: unique_ptr</a></li>
<li><a href="#org3a20d1b">1.28.9. Example: shared_ptr</a></li>
<li><a href="#orge87ae92">1.28.10. Selected Codebases with std::shared_ptr</a></li>
<li><a href="#org0adfd12">1.28.11. Additional Reading</a></li>
</ul>
</li>
<li><a href="#orge5141a3">1.29. Exceptions and Error Handling</a>
<ul>
<li><a href="#org3745848">1.29.1. Overview</a></li>
<li><a href="#org160e385">1.29.2. Exception Basics</a></li>
<li><a href="#org1a88d90">1.29.3. Types of Program termination</a></li>
<li><a href="#org2a699fc">1.29.4. Overriding std::terminate handler</a></li>
<li><a href="#orgf5d0cdb">1.29.5. Custom Exceptions</a></li>
<li><a href="#orgbdcb8fb">1.29.6. Example - code</a></li>
<li><a href="#org6f5a4fa">1.29.7. Exception Safety Guarantees</a></li>
</ul>
</li>
<li><a href="#org442c4a5">1.30. C++11 Tuples</a>
<ul>
<li><a href="#orgfb08d45">1.30.1. Overview</a></li>
<li><a href="#orgcee4001">1.30.2. Function std::make_tuple</a></li>
<li><a href="#orgf0ad25a">1.30.3. Example in Cling REPL</a></li>
<li><a href="#orgfa81bf2">1.30.4. Example - sample source code</a></li>
</ul>
</li>
<li><a href="#org6a29c10">1.31. Handling Signals</a>
<ul>
<li><a href="#org5692af2">1.31.1. Oveview</a></li>
<li><a href="#org6dfeebc">1.31.2. Example</a></li>
</ul>
</li>
<li><a href="#org7bd6a17">1.32. Pointer to Function or Function Pointer</a>
<ul>
<li><a href="#orgb9d522a">1.32.1. Overview</a></li>
<li><a href="#org3f38faa">1.32.2. Function Pointer Declaration</a></li>
<li><a href="#org401281c">1.32.3. Function Pointer Callbacks</a></li>
</ul>
</li>
<li><a href="#org6c75160">1.33. Pointer to Class Member Function</a></li>
<li><a href="#orgbb261b1">1.34. Pointer to Class Member Variable</a>
<ul>
<li><a href="#orgada1dc0">1.34.1. Summary</a></li>
<li><a href="#orgf75621b">1.34.2. Example</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgf7daed0" class="outline-2">
<h2 id="orgf7daed0"><span class="section-number-2">1</span> Understanding C++</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgb103d15" class="outline-3">
<h3 id="orgb103d15"><span class="section-number-3">1.1</span> Features</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org007556f" class="outline-4">
<h4 id="org007556f"><span class="section-number-4">1.1.1</span> C++ Benefits and Costs</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
Some C++ compelling features which sets it apart from most
programming languages are: 
</p>

<p>
<b>Advatanges</b>:
</p>

<ul class="org-ul">
<li>Compilation to native code - makes the code faster as it does not
need to be interpreted and easier to deploye as the number of
dependencies are minimized. Another advantage of native code is the
obfuscation for free what makes it hard and more costly to reverse
engineer.</li>

<li>High Performance and zero-cost abstractions.</li>

<li>Hardware portability and compiler availability for many processor
and hardware architechtures. C++ has the widest range of processor
support, so it can run on mainstream x86, desktop processors;
mobile phone ARM-based CPUs; GPUs; embedded processors and
microcontrollers.</li>

<li>Direct access to the operating system C-API and system calls.</li>

<li>Interoperability with C libraries.</li>

<li>Direct Access to Memory which is important on embedded systems for
accessing memory-mapped IO devices.</li>

<li><b>Perfomance-oriented language:</b> C++ has many features which can help
get the maximum performance as possible from the hardware:
<ul class="org-ul">
<li>Native Code Compilation</li>
<li>Strong static typing</li>
<li>Compiler optimizations</li>
<li>Inline functions</li>
<li>Templates</li>
<li>Pointers</li>
<li>Lack of garbage collector</li>
<li>Custom-allocators</li>
<li>Lots of optimized standard data structures (STL containers)</li>
<li>Inline-assembly -&gt; The inline-assembly support is compiler
specific and not required by the standard. Assembly is also
processor-specific and not portable.</li>
<li>Insider knowledge of compiler makers about the operating system
and the processor architechture.</li>
</ul></li>
</ul>

<p>
<b>Disadvantages:</b>
</p>

<ul class="org-ul">
<li>Language complexity</li>

<li>Tooling
<ul class="org-ul">
<li>Due to the C++ complexity, it is hard to parse C++ code and
consequently build code assintance tools such as refactoring
tools, IDEs, linters, code generators and so on. This shortcoming
is being addressed by Clang/LLVM tools that provide libraries for
parsing C++ code.</li>
</ul></li>

<li>Slow compile-time</li>

<li>Compiler's cryptic error messages.</li>

<li>Lack of garbage collector. While the lack of this feature can help
to achieve better performance and efficiency, it requires manual
memory management which can be error prone and lead to memory
leaks. However, smart pointers and the RAAI technique can help to
solve this issue.</li>

<li>Lack of a comprehensive standard library.
<ul class="org-ul">
<li>The standard library still lacks lots of libraries that other
programming languages take for granted such as CSV parsers, XML
parsers, database drivers, graphical user interfaces and so on.</li>
</ul></li>

<li>ABI - Application Binary Interface Issues - due the
non-standardized ABI, it is almost impossible to link object-code
(aka compiled code) compiled with different compilers. This is why,
unlike Java and C#,  there is almost no pre-compiled libraries for
C++ what makes the binary reuse hard.</li>

<li>Lack of agreed package manager.
<ul class="org-ul">
<li>While there are many C++ package, there still no standard one
yet. Due to ABI issues, C++ package managers only provide
packages in source format andd don't provide precompiled packages
as shared libraries or static libraries as Java package manager
do.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgc19e80a" class="outline-4">
<h4 id="orgc19e80a"><span class="section-number-4">1.1.2</span> C++ Language features</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
C++ Supported Paradigms: 
</p>

<ul class="org-ul">
<li><span class="underline">Imperative / Procedural</span> as C and Pascal</li>

<li><span class="underline">Object Oriented</span></li>

<li><span class="underline">Functional Programmign</span> since C++11 with the introduction type
deduction (auto keyword) and lambda functions.</li>

<li><span class="underline">Generic Programming</span> - Template metaprogramming, a combination of
statically typed duck-typing and lisp-like metaprogramming that
allows efficient code generation at compile-time.</li>
</ul>

<p>
Other Features: 
</p>

<ul class="org-ul">
<li>Automatic memory management.</li>
<li>No garbage collector.</li>
<li>Low level access to system and operating system services or API in
a similar way to C.</li>
</ul>
</div>
</div>

<div id="outline-container-org3ec0d12" class="outline-4">
<h4 id="org3ec0d12"><span class="section-number-4">1.1.3</span> C++ New Features and Standards</h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li><b>C++98</b> - <b>ISO/IEC 14882:1998</b>
<ul class="org-ul">
<li>Old C++ standard.</li>
</ul></li>
</ul>


<ul class="org-ul">
<li><b>C++03</b> - <b>ISO/IEC 14882:2003</b></li>
</ul>


<ul class="org-ul">
<li><b>C++11</b> - <b>ISO/IEC 14882:2011</b>
<ul class="org-ul">
<li>C++11 Working Draft  <a href="http://wg21.link/n3242">http://wg21.link/n3242</a></li>
<li>See:
<ul class="org-ul">
<li><a href="https://isocpp.org/wiki/faq/cpp11-language#auto">C++11 Language Extensions — General Features, C++ FAQ</a></li>
<li><a href="http://www.windowscpp.com/CPP11FAQ.htm">http://www.windowscpp.com/CPP11FAQ.htm</a></li>
</ul></li>
<li>Features which supports Functional Programming
<ul class="org-ul">
<li>auto keyworkd for type deduction (aka type inference)
<ul class="org-ul">
<li>Which relieves the developer from writing all types and
simplifies the code.</li>
</ul></li>
<li>Lambda functions and std::function
<ul class="org-ul">
<li>Introduces the functional programming paradigm in C++ allowing
users to write higher-order functions and reusable algorithms.</li>
</ul></li>
<li>Tuples
<ul class="org-ul">
<li>allows returning multiple values</li>
</ul></li>
<li>Move Semantics:
<ul class="org-ul">
<li>Transfer resource ownership from temporary objects. This
feature removes the runtime overhead of temporary objects and
also allows to return containers such as vectors, string and
etc from functions without runtime overhed or deep copy.</li>
</ul></li>
</ul></li>
<li>Library Support
<ul class="org-ul">
<li>Smart Pointers =&gt; <code>unique_ptr</code> and <code>shared_ptr</code>
<ul class="org-ul">
<li>Provides memory and resource management making the programs
less prone to memory or resource leaks. Those pointers
implments the RAII (Resource Acquisition is Initialization)
idiom which takes advantage of C++ deterministic destructor for
releasing resources no longer needed.</li>
</ul></li>
<li>Regex</li>
<li>Cross-platform concurrency features.
<ul class="org-ul">
<li>Example: threads, monitors and locks which works on all
supported platforms and operating systems.</li>
</ul></li>
</ul></li>
<li>Misc
<ul class="org-ul">
<li>nullpr - type-safe null pointer</li>
<li>Ranged-based loop</li>
</ul></li>
<li>Compile-time metaprogramming features
<ul class="org-ul">
<li>Variadic Templates</li>
<li>Contexpr
<ul class="org-ul">
<li>Allows compile-time computations such as computing
random numbers, encrypting string at runtime or generating
look-up tables.</li>
</ul></li>
<li>Static assert</li>
<li>String literals</li>
<li>User-defined literals</li>
</ul></li>
</ul></li>
</ul>


<ul class="org-ul">
<li><b>C++14</b> - <b>ISO/IEC 14882:2014</b>
<ul class="org-ul">
<li>C++14 Working Draft - <a href="http://wg21.link/n4296">http://wg21.link/n4296</a></li>
<li>See: <a href="https://isocpp.org/wiki/faq/cpp14-language">C++14 Language Extensions, C++ FAQ</a></li>
<li><span class="underline">Binary Literals</span>: int x = 0b1001001 -&gt; This feature is useful for
embedded systems and dealing with bitmasks and hardware
registers.</li>
<li><span class="underline">Digit Separators</span> - allows to write the number pi = 3.1415927 as pi = 3.141'592'7</li>
<li><span class="underline">Generalized return type deduction</span>.</li>
<li>decltype(auto)</li>
<li>Genric Lambda - Now it is possible to use the keyword auto for
deducing or infering the type of lambda arguments.</li>
<li>Variable Templates</li>
<li><span class="underline">Extended Constexpr</span> - contexpr functions can have loops, mutating
variables and don't need to be recursive as it was before,
consequently constexpr is able to peform more complex
compile-time computations.</li>
<li>[ [ deprecated ] ] attribute -&gt; enables annotating an entity as
deprecated and prints a compilation warn if a deprecated entity
is used.</li>
</ul></li>
</ul>


<ul class="org-ul">
<li><b>C++17</b> - <b>ISO/IEC 14882:2017</b>
<ul class="org-ul">
<li>C++17 Working Draft - <a href="http://wg21.link/n4659">http://wg21.link/n4659</a></li>
<li>See:
<ul class="org-ul">
<li><a href="http://www.cppstd17.com/">http://www.cppstd17.com/</a></li>
<li><a href="https://isocpp.org/wiki/faq/cpp17-language">https://isocpp.org/wiki/faq/cpp17-language</a></li>
<li><a href="https://www.infoworld.com/article/3044727/application-development/qa-bjarne-stroustrup-previews-c-17.html">Q&amp;A: Bjarne Stroustrup previews C++ 17 | InfoWorld</a></li>
</ul></li>
<li>std::any</li>
<li>std::variant</li>
<li>std::optional</li>
<li>std::string_view - Paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3921.html">ISO/IEC JTC1 SC22 WG21 N3921</a></li>
<li>std::file_system - Paper: <a href="https://isocpp.org/files/papers/P0218r1.html">P0218R1</a></li>
<li>Structured bindings - key, value decomposition - Paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0217r3.html">P0217R3</a></li>
<li>Constexpr if - Paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0292r2.html">P0292R2</a></li>
<li>Init statements for if and switch - Paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r1.html">P0305R1</a></li>
<li>Folding Expressions - Paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4295.html">N4295</a></li>
<li>Parallel algorithms</li>
<li>Nested namespaces - Paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4230.html">N4230</a></li>
<li>Inline Variables - Paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf">P0386R</a></li>
<li>&#x2026; and much more &#x2026;!!</li>
</ul></li>

<li><b>C++20</b> - Coming soon.</li>
</ul>

<p>
Compiler Support:
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/compiler_support">C++ compiler support - cppreference.com</a></li>
<li><a href="https://www.gnu.org/software/gcc/projects/cxx-status.html">C++ Standards Support in GCC - GNU Project - Free Software Foundation (FSF)</a></li>
<li><a href="https://software.intel.com/en-us/articles/c17-features-supported-by-intel-c-compiler">C++17 Features Supported by Intel® C++ Compiler | Intel® Software</a></li>
<li><a href="https://docs.microsoft.com/en-us/cpp/visual-cpp-language-conformance?view=vs-2017">Visual C++ Language Conformance | Microsoft Docs</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgdb08586" class="outline-3">
<h3 id="orgdb08586"><span class="section-number-3">1.2</span> C++ Comparison and Alternatives</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orgb280fd7" class="outline-4">
<h4 id="orgb280fd7"><span class="section-number-4">1.2.1</span> C++ Comparison with Java and C#</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
General overview: Unlike most object oriented languages such as Java
and C#, C++ doesn't have a class hierarchy, single inheritance,
garbage collection and a comprehensive standard library. However in
some situations, C++ benefits such as direct access to the operating
system, memory, system calls and low level; interoperability with C
libraries; and above all, high performance computing may offset the
language complexity costs.
</p>

<p>
This table shows a comparison between C++ and mainstreams object
oriented programming languages like Java and C#.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Comparison C++ X Mainstream high level programming languages (C#, Java, Python &#x2026;)</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Feature</th>
<th scope="col" class="org-left">C++</th>
<th scope="col" class="org-left">Java</th>
<th scope="col" class="org-left">C# - .NET</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Native Code</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">JIT - Just-In-Time Compilation</td>
<td class="org-left">No  - No needed, since C++ is native.</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Virtual Machine</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Garbage Collection</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Memory Management</td>
<td class="org-left">semi-automatic</td>
<td class="org-left">auto</td>
<td class="org-left">auto</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>Object Oriented Features</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">OOP - Object Oriented</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Class Hierarchy</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Reflection</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Single Inheritance</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Multiple Inheritance</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Properties</td>
<td class="org-left">No</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Inner classes, aka nested classes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Anonymous classes</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Operator Overloading</td>
<td class="org-left">Yes</td>
<td class="org-left">Not</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Marshalling</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Conditional Compilation - preprocessor</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Lambda functions</td>
<td class="org-left">Yes  - since C++11</td>
<td class="org-left">Yes - since Java 8</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Generics</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">*Template metaprogramming</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Dependency, package manager</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>Standard Library Features</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Broad Cross Platform Support</td>
<td class="org-left">No - Provided by boost library.</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">GUI toolkit in standard library</td>
<td class="org-left">No</td>
<td class="org-left">Yes - Swing, JavaFX</td>
<td class="org-left">Yes - WinForms, WPF</td>
</tr>

<tr>
<td class="org-left">Collection Library</td>
<td class="org-left">Yes - STL.</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Sockets</td>
<td class="org-left">No - Provided Boost library.</td>
<td class="org-left">No</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Threads</td>
<td class="org-left">Yes. Since, C++11</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">File System</td>
<td class="org-left">C++ 11 -&gt; No, C++17 -&gt; Yes.</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
<b>Notes and observations:</b>
</p>

<ul class="org-ul">
<li><span class="underline">Class Hierarchy</span> =&gt; In Java, every object inherits from the root
class java.lang.Object. Objects can be cased from its Class or to
'Object'. It also allows put multiple unrelated java objects in the
same container. C# too has a root class System.Object from which
all classes inherits:
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html">Object (Java Platform SE 7 )</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.-ctor?view=netframework-4.7.2#System_Object__ctor">Object Constructor (System) | Microsoft Docs</a></li>
<li><a href="https://en.wikibooks.org/wiki/Java_Programming/Generics">Generics - Wikibooks, open books for an open world</a></li>
</ul></li>

<li><span class="underline">Virtual Machine</span> =&gt; The <a href="https://en.wikipedia.org/wiki/C%2B%2B/CLI">C++/CLI</a> implementation, also known as
Managed C++ runs in the .NET virtual machine and has garbarge
collector. But this implementation is only supported on Windows.</li>

<li><span class="underline">C++ DO have package managers</span> such as <a href="https://conan.io/">Conan</a>, <a href="http://www.buckaroo.pm/">Buckaroo</a> and <a href="https://docs.microsoft.com/en-us/cpp/vcpkg?view=vs-2017">Vcpkg</a>. But
they are not standard and not widely adopted. In addition, C++
package managers generally don't provide pre-compiled packages as
Java and C# / .NET. Actually, due to non standard ABI - Application
Binary Interface issues, they only provide source packages that are
compiled locally. As far it is known, the C++ package managers also
don't provide a way to install C-shared libraries dependencies
locally such as GNU-scientific library, Opengl, OpenCV, Gtk,
Blas-Lapack shared libraries and so on.</li>
</ul>


<p>
<b>Main Differences between C++ and other languages</b>
</p>

<ul class="org-ul">
<li><span class="underline">Value Semantics</span>
<ul class="org-ul">
<li>Classes are trated as primitive types by default.</li>
</ul></li>

<li><span class="underline">Stack or Heap Allocation</span>
<ul class="org-ul">
<li>Objects can be allocated on the stack and on the heap.</li>
</ul></li>

<li><span class="underline">No Garbage Collection</span>
<ul class="org-ul">
<li>Although, there is no garbage collection, the memory management
can be performed in semi-automatic way by using smart pointers
from C++11 unique_ptr or shared_ptr. The shared_ptr can emulate
garbage collectors as it uses an internal reference counter.</li>
</ul></li>

<li><span class="underline">Deterministic Destructor</span>
<ul class="org-ul">
<li>The destructor method is always called when an object goes out of
scope or an exception happens.</li>
</ul></li>

<li><span class="underline">Many types of constructors</span>
<ul class="org-ul">
<li>C++ has the default constructor, copy constructor and move
constructor.</li>
</ul></li>

<li><span class="underline">Many types of inheritance</span>
<ul class="org-ul">
<li>public, protected, private and virtual inheritance.</li>
</ul></li>

<li><span class="underline">Template Metaprogramming / Generic Programming</span>
<ul class="org-ul">
<li>Which allows generics and type-safe code generation with zero
rutime overhead.</li>
</ul></li>

<li><span class="underline">Pointers</span>
<ul class="org-ul">
<li>Most languages doesn't provide access to pointers and calling C-libraries directly.</li>
</ul></li>

<li><span class="underline">Minimal standard library</span>
<ul class="org-ul">
<li>Lacks many things other languages have for granted such as
database drivers, sockets, SSL/TSL, file system, user interfaces
and so on. Note: only on C++17 that C++ has file system access
derived from Boost.FileSystem the standard library.</li>
</ul></li>
</ul>

<p>
<b>C++ Terminology</b> 
</p>

<p>
C++ has a different terminology from mainstream programming languages
which is shown in the following table.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> C++ terminology simplification</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">C++</th>
<th scope="col" class="org-left">Other OOP Languages</th>
<th scope="col" class="org-left">Comment</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">i.e: Java, Python, &#x2026;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Class</td>
<td class="org-left">Class</td>
<td class="org-left">C++ class' fields and methods are private by default.</td>
</tr>

<tr>
<td class="org-left">Struct</td>
<td class="org-left">Class</td>
<td class="org-left">A C++ is the same as a Class, but fields and methods are public by default.</td>
</tr>

<tr>
<td class="org-left">Class or Struct</td>
<td class="org-left">Abstract Class</td>
<td class="org-left">A C++ abstract class have at least one <span class="underline">virtual function</span>.</td>
</tr>

<tr>
<td class="org-left">Class or Struct</td>
<td class="org-left">Interface</td>
<td class="org-left">A C++ interface is a class signature with only pure virtual functions (abstract methods.)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Member Function</td>
<td class="org-left">Instance methods</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Static Member Function</td>
<td class="org-left">Static method</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Virtual Functions</td>
<td class="org-left">-</td>
<td class="org-left">Only methods annoted with virtual  can overriden by subclasses</td>
</tr>

<tr>
<td class="org-left">Non Virtual Functions</td>
<td class="org-left">-</td>
<td class="org-left">Methods without <span class="underline">virtual</span> annotation cannot be overriden by subclasses.</td>
</tr>

<tr>
<td class="org-left">Pure Virtual Function</td>
<td class="org-left">Abstract method (method without implementation)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">STL Containers</td>
<td class="org-left">Collection library - Lists, Maps, Tuples &#x2026;</td>
<td class="org-left">C++ name its collections as containters</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>


<p>
<b>Java X C++ Collections Comparison</b>
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Java</th>
<th scope="col" class="org-left">C++</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">java.util.ArrayList</td>
<td class="org-left">std::vector</td>
</tr>

<tr>
<td class="org-left">java.util.LinkedList</td>
<td class="org-left">std::list</td>
</tr>

<tr>
<td class="org-left">java.util.Stack</td>
<td class="org-left">std::stack</td>
</tr>

<tr>
<td class="org-left">java.util.Queue</td>
<td class="org-left">std::queue</td>
</tr>

<tr>
<td class="org-left">java.util.Deque</td>
<td class="org-left">std::deque</td>
</tr>

<tr>
<td class="org-left">java.util.TreeSet</td>
<td class="org-left">std::set</td>
</tr>

<tr>
<td class="org-left">java.util.HashSet</td>
<td class="org-left">std::unordered_set</td>
</tr>

<tr>
<td class="org-left">java.util.TreeMap</td>
<td class="org-left">std::map</td>
</tr>

<tr>
<td class="org-left">java.util.HashMap</td>
<td class="org-left">std::unordered_map</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>


<p>
See: 
</p>
<ul class="org-ul">
<li><a href='C++ - CPP Programming/CppFor Java Programmers - Hans Dulimatra.pdf'>CppFor Java Programmers - Hans Dulimatra.pdf</a></li>
<li><a href="https://en.wikiversity.org/wiki/Java_Collections_Overview">Java Collections Overview - Wikiversity</a></li>
</ul>
</div>
</div>

<div id="outline-container-org7514fe2" class="outline-4">
<h4 id="org7514fe2"><span class="section-number-4">1.2.2</span> Comparison C X C++(CPP)</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
One of the most compelling advantages of C++ is the compatibility with
C programming language and the ability to interoperate with C code and
C shared libraries. The interoperability with C is necessary as it is
the fundamental language of system programming which most operating
systems, programming languages and domain-specific shared libraries
such as GSL (GNU Scientific Library) or OpengGL are implemented. In
addition, most operating system APIs and services are available or
exposed in C.
</p>

<p>
While previous knowledge of C is not required for learning C++, it is
still necessary to know at least how to read C code in order to access
it from C++ or to create high level C++ wrappers to it. 
</p>

<p>
Note: C++ is not C with classes, it is complete different language,
however it inherits many concepts from C and supports a subset from C
and it is even possible to compile many C code with a C++ compiler.
</p>

<p>
Some applications implemented in C:
</p>

<ul class="org-ul">
<li>Linux Kernel</li>
<li>Free BSD operating system</li>
<li>Windows API - Win32</li>
<li>U-nix sockets API.</li>
<li>OpenGL</li>
<li>Gtk GUI Toolkit</li>
<li>X-Windows System</li>
<li>Python Programming Language (CPython Interpreter)</li>
<li>Ruby Programming Language</li>
<li>Lua Programming Language</li>
</ul>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Feature</th>
<th scope="col" class="org-left">C++ / CPP - C Plus Plus</th>
<th scope="col" class="org-left">C</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Creator</td>
<td class="org-left">Bjarne Stroustrup</td>
<td class="org-left">Dennis Ritchie</td>
</tr>

<tr>
<td class="org-left">Paradigms</td>
<td class="org-left">Imperative, Object Orientated, Gneric / Meta programming and Functional</td>
<td class="org-left">Procedural / Imperative</td>
</tr>

<tr>
<td class="org-left">Some use cases</td>
<td class="org-left">High Performance Computing, Embedded Systems, Games, &#x2026;</td>
<td class="org-left">System programming and embedded systems &#x2026;</td>
</tr>

<tr>
<td class="org-left">Standard ABI</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left">Collection Library (Containers)</td>
<td class="org-left">Yes - STL (standard) and others.</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Garbage Collector</td>
<td class="org-left">No</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Memory Management</td>
<td class="org-left">Manual and Semi automatic (provided by smart pointers.)</td>
<td class="org-left">Manual</td>
</tr>

<tr>
<td class="org-left">Error Handling Mechanism</td>
<td class="org-left">Function return values, global flags and exceptions.</td>
<td class="org-left">Function return values and  global flags such as errno</td>
</tr>

<tr>
<td class="org-left">Exceptions</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">Namespaces</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">File Extensions</td>
<td class="org-left">.cpp (c++ source code) and .hpp (c++ header file).</td>
<td class="org-left">.c (C-source code) and .h (header file)</td>
</tr>

<tr>
<td class="org-left">Metaprogramming facilities</td>
<td class="org-left">Macros + Templates + Inline Functions + Contexptr</td>
<td class="org-left">Macros</td>
</tr>

<tr>
<td class="org-left">String Manipulation</td>
<td class="org-left">std::string</td>
<td class="org-left">C doesn't have string types, just array of characters.</td>
</tr>

<tr>
<td class="org-left">Direct Access to Memory</td>
<td class="org-left">yes - using <code>reinterpret_cast</code> or C-style casting.</td>
<td class="org-left">yes - using C-style casting.</td>
</tr>

<tr>
<td class="org-left">Run barebones without OS</td>
<td class="org-left">yes</td>
<td class="org-left">yes - C has more compillers for embedded devices than C++.</td>
</tr>

<tr>
<td class="org-left">Threads in standard library</td>
<td class="org-left">Yes - since C++11</td>
<td class="org-left">No - It is platform dependent.</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Direct Access to Memory:
<ul class="org-ul">
<li>Note: It means direct access to a memory location given by its
address. This feature is used for accessing <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory mapped IO</a> in
embedded systems and low level system programming.</li>
</ul></li>
</ul>

<p>
<b>File Extensions</b>
</p>

<ul class="org-ul">
<li>Source Files
<ul class="org-ul">
<li>*.cpp - C++ source files.</li>
<li>*.hpp - C++ header files.</li>
<li>*.o   - Object Code</li>
</ul></li>

<li>Windows
<ul class="org-ul">
<li>*.exe - PE32 - Windows Executable</li>
<li>*.dll - Windows Shared Library</li>
</ul></li>

<li>Unix (Linux, BSD &#x2026;)
<ul class="org-ul">
<li>(No extension or *.bin) - ELF - Unix Executable</li>
<li>*.so - Unix Shared Library</li>
</ul></li>
</ul>

<p>
<b>Primitive Data Types</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">stdint.h type</th>
<th scope="col" class="org-right">Size (Bytes)</th>
<th scope="col" class="org-right">Size (Bits)</th>
<th scope="col" class="org-left">Range</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bool</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">8</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Boolean 0 (false) or 1 (true)</td>
</tr>

<tr>
<td class="org-left">char</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">8</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Ascii character</td>
</tr>

<tr>
<td class="org-left">unsigned char</td>
<td class="org-left">uint8_t</td>
<td class="org-right">1</td>
<td class="org-right">8</td>
<td class="org-left">0 to 255</td>
<td class="org-left">1 byte integer</td>
</tr>

<tr>
<td class="org-left">signed char</td>
<td class="org-left">int8_t</td>
<td class="org-right">1</td>
<td class="org-right">8</td>
<td class="org-left">-128 to 127</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">short</td>
<td class="org-left">int16_t</td>
<td class="org-right">2</td>
<td class="org-right">16</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">16 bits signed integer</td>
</tr>

<tr>
<td class="org-left">unsigned short</td>
<td class="org-left">uint16_t</td>
<td class="org-right">2</td>
<td class="org-right">16</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">int</td>
<td class="org-left">int32_t</td>
<td class="org-right">4</td>
<td class="org-right">32</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">32 bits signed integer</td>
</tr>

<tr>
<td class="org-left">unsigned int</td>
<td class="org-left">uint32_t</td>
<td class="org-right">4</td>
<td class="org-right">32</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">32 bits unsigned integer</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">4</td>
<td class="org-right">32</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">32 bits IEEE 754 single-precision float point number</td>
</tr>

<tr>
<td class="org-left">double</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">8</td>
<td class="org-right">64</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">64 bits IEEE 754 double-precision float point Number</td>
</tr>

<tr>
<td class="org-left">long double</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">10</td>
<td class="org-right">80</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Extended precision non-IEEE float point number</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>


<ul class="org-ul">
<li>Note: The type char can be understood as an 8-bits integer.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgccb21ae" class="outline-3">
<h3 id="orgccb21ae"><span class="section-number-3">1.3</span> Minimal C++ Programs</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-orgc196bd2" class="outline-4">
<h4 id="orgc196bd2"><span class="section-number-4">1.3.1</span> Simple minimal C++ program</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>File: <a href="src/minimal-program1.cpp">file:src/minimal-program1.cpp</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Hello world user"</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Enter your name: "</span>;
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>;
    <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cin, name<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Be welcome to C++ land: "</span> &lt;&lt; name &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Wait user type a single character</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">"Type RETURN to exit"</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Read a character from standard input (console)</span>
    <span class="org-constant">std</span>::cin.get<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Status code</span>
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Note: The following code is necessary to allow inspecting the program
output on Windows after the user click at it. This code prevents the
program from exiting immediately by asking the user to type Return key
to proceed. It is not necessary on Linux or any other U*nix-like
operating system such as Mac OSX or BSD.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">"Type RETURN to exit"</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Read a character from standard input (console)</span>
<span class="org-function-name">std</span>::cin.get<span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<p>
The main() function returns 0 (zero) as <span class="underline">status code</span> for indicating
that the program was terminated gracefully or any value other than
zero indicate that program was terminated with failure.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">return</span> 0;
</pre>
</div>

<p>
The main function could aso return: 
</p>

<ul class="org-ul">
<li>To indicate success. Same as returning (0).</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Same as 0 </span>
<span class="org-keyword">return</span> EXIT_SUCCESS; 
</pre>
</div>

<ul class="org-ul">
<li>To indicate failure. Same as returning (1)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">return</span> EXIT_FAILURE;
</pre>
</div>


<p>
<b>Compiling and running:</b>
</p>

<ul class="org-ul">
<li>Compilation flags: 
<ul class="org-ul">
<li>-o &lt;filename&gt;
<ul class="org-ul">
<li>=&gt; Sets the name of the executable generated by the
compiler. If executable name is not set, the compiler will
generate the file a.out on *Nix like systems (Linux, MacOSX,
FreeBSD and etc.) or a.exe on Windows.</li>
</ul></li>
<li>-std=c++14
<ul class="org-ul">
<li>=&gt; Enable C++14 Features. It could also be -std=c++11 (for
C++11 features), -std=c++1z (for C++17 features)</li>
</ul></li>
<li>-g
<ul class="org-ul">
<li>=&gt; Generate debug symbols</li>
</ul></li>
<li>-Wall
<ul class="org-ul">
<li>Increase verbosity level.</li>
</ul></li>
</ul></li>

<li>Compiling with Clang
<ul class="org-ul">
<li>=&gt; Clang compiler provides better error diagnosing and more
user friendly debug messages than other compilers.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">$ clang++ minimal-program1.cpp -o <span class="org-keyword">minimal-program1.bin</span> -g -std=c++14 -Wall 
</pre>
</div>

<ul class="org-ul">
<li>Compiling with GCC</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ minimal-program1.cpp -o <span class="org-keyword">minimal-program1.bin</span> -g -std=c++14 -Wall  
</pre>
</div>

<ul class="org-ul">
<li>Compiling on Windows with Mingw (GCC for Windows) 
<ul class="org-ul">
<li>On Windows, the executable can be run by just clicking on it.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">$ g++ minimal-program1.cpp -o <span class="org-keyword">minimal-program1.exe</span> -g -std=c++14 -Wall 
<span class="org-comment-delimiter">// </span><span class="org-comment">On Console (cmd.exe)</span>
$ minimal-program1.exe 
<span class="org-comment-delimiter">// </span><span class="org-comment">Or </span>
</pre>
</div>

<p>
The compilation produces a <b>native executable</b> with: 
</p>

<ul class="org-ul">
<li>Specific <span class="underline">binary format</span> required by operating system. On Linux,
Android and BSD variants this format is <span class="underline">ELF</span> (Executable Linkable
Format); on Windows, this binary format is <span class="underline">PE32</span> or <span class="underline">PE64</span> (Portable
Executable) and on MacOSX this format is <span class="underline">MachO</span>.</li>

<li><span class="underline">Specifc machine code</span> (Instruction set) for the processor
architecture the program was compiled. The most common processor
architecture used in servers and desktop computers are Intel-x86
and Amd-x86-x64. For consumer mobile devices, the most common
processors are the <span class="underline">ARM-based processors</span> that are used in many
Android-based phones, IPhone, IPad and etc.</li>

<li>Specific <span class="underline">system-calls</span> and library calls for the operating system the
program was compiled for.</li>

<li>Additional Notes:

<ul class="org-ul">
<li>A compiled C++ program generally cannot be run in other operating
because different operating systems have different binary
executable formats, different systems calls and core libraries.</li>

<li>The Wine project allows running programs compiled on Windows on
U-nix like operating systems, including Linux, BSD and MacOSX by
translating the PE32 binary format and the Windows system-calls
to the host OS system call.</li>

<li>C++ programs can also be compiled to run <a href="https://en.wikipedia.org/wiki/Bare_machine">bare metal</a>, it means
without any operating system. This type of compilation is widely
used for embedded systems, microcontrollers, firmwares, BIOs,
operating systems and so on.</li>
</ul></li>
</ul>

<p>
<b>Running:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ ./minimal-program1.bin 
Hello world user
Enter your name: Somebody <span class="org-keyword">else</span>
Be welcome to C++ land: Somebody <span class="org-keyword">else</span>

Type RETURN to exit
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb0ab91e" class="outline-4">
<h4 id="orgb0ab91e"><span class="section-number-4">1.3.2</span> Variations of main function</h4>
<div class="outline-text-4" id="text-1-3-2">
</div>
<ol class="org-ol">
<li><a id="org1a1bb3a"></a>Overview<br />
<div class="outline-text-5" id="text-1-3-2-1">
<p>
The main function can have the following variations: 
</p>

<ul class="org-ul">
<li>Simple main function.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<ul class="org-ul">
<li>Main function with command line arguments</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> **<span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>Main function with command line arguments and environment
variables.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> **<span class="org-variable-name">argv</span>, <span class="org-type">char</span> **<span class="org-variable-name">environ</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>
</div>
</li>
<li><a id="org801a34c"></a>Example: Minimal program with command line arguments<br />
<div class="outline-text-5" id="text-1-3-2-2">
<p>
Exmaple: Command line arguments. 
</p>

<ul class="org-ul">
<li>File: <a href="src/minimal-program2.cpp">file:src/minimal-program2.cpp</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> **<span class="org-variable-name">argv</span>, <span class="org-type">char</span> **<span class="org-variable-name">environ</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>argc &lt; 2<span class="org-rainbow-delimiters-depth-2">){</span>
       <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error: invalid command line argument. Expected -args or -env "</span>
                 &lt;&lt; <span class="org-string">"\n"</span>;
       <span class="org-comment-delimiter">// </span><span class="org-comment">Exit  immediately (return 1)</span>
       <span class="org-keyword">return</span> EXIT_FAILURE; 
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-3">(</span>argv<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span> == <span class="org-string">"-args"</span><span class="org-rainbow-delimiters-depth-2">){</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Number of command line arguments = "</span> &lt;&lt; argc &lt;&lt; <span class="org-string">"\n"</span>;
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"argv[0] = "</span> &lt;&lt; argv<span class="org-rainbow-delimiters-depth-3">[</span>0<span class="org-rainbow-delimiters-depth-3">]</span> &lt;&lt; <span class="org-string">"\n"</span>;
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Showing command line arguments:"</span> &lt;&lt; <span class="org-string">"\n"</span>;
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"+-----------------------------+"</span> &lt;&lt; <span class="org-string">"\n"</span>;
       <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; argc; i++<span class="org-rainbow-delimiters-depth-3">)</span>
               <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"argv["</span> &lt;&lt; i &lt;&lt; <span class="org-string">"] = "</span> &lt;&lt; argv<span class="org-rainbow-delimiters-depth-3">[</span>i<span class="org-rainbow-delimiters-depth-3">]</span> &lt;&lt; <span class="org-string">"\n"</span>;      
       <span class="org-keyword">return</span> EXIT_SUCCESS;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-3">(</span>argv<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span> == <span class="org-string">"-env"</span><span class="org-rainbow-delimiters-depth-2">){</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Show environment variables"</span> &lt;&lt; <span class="org-string">"\n"</span>;
       <span class="org-type">char</span>** <span class="org-variable-name">env</span> = environ;
       <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-rainbow-delimiters-depth-4">(</span>env++<span class="org-rainbow-delimiters-depth-4">)</span> != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-3">)</span>
               <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; env = "</span> &lt;&lt; *env &lt;&lt; <span class="org-string">"\n"</span>;
       <span class="org-keyword">return</span> EXIT_SUCCESS;

    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error: invalid argument &lt;"</span> &lt;&lt;  argv<span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; <span class="org-string">"&gt; "</span> &lt;&lt;<span class="org-string">"\n"</span>;     
    <span class="org-comment-delimiter">// </span><span class="org-comment">return 1</span>
    <span class="org-keyword">return</span> EXIT_FAILURE;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Compiling: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ minimal-program2.cpp -o <span class="org-keyword">minimal-program2.bin</span> -g -std=c++1z -Wall
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-text">$ ./minimal-program2.bin 
Error: invalid command line argument. Expected -args or -env 

$ ./minimal-program2.bin -args opt1 opt2 key=value
Number of command line arguments = 5
argv[0] = ./minimal-program2.bin

Showing command line arguments:
+-----------------------------+
argv[0] = ./minimal-program2.bin
argv[1] = -args
argv[2] = opt1
argv[3] = opt2
argv[4] = key=value

$ ./minimal-program2.bin sadsad
Error: invalid argument &lt;sadsad&gt; 

$ ./minimal-program2.bin -env
Show environment variables
 =&gt; env = LD_LIBRARY_PATH=:/home/archbox/opt/root/lib:/home/archbox/opt...
 =&gt; env = XDG_MENU_PREFIX=gnome-
 =&gt; env = MODULES_RUN_QUARANTINE=LD_LIBRARY_PATH
 =&gt; env = LANG=en_CA.UTF-8
 =&gt; env = GDM_LANG=en_CA.UTF-8
 =&gt; env = HISTCONTROL=ignoredups
 =&gt; env = DISPLAY=:0
 =&gt; env = HOSTNAME=localhost.localdomain
 =&gt; env = OLDPWD=/home/archbox/Documents/projects/learn.cpp
 =&gt; env = GNOME_SHELL_SESSION_MODE=classic
 ... ... ... 
 =&gt; env = MODULES_CMD=/usr/share/Modules/libexec/modulecmd.tcl
 =&gt; env = USER=archbox
 =&gt; env = ENV=/usr/share/Modules/init/profile.sh
 =&gt; env = PAGER=cat
 =&gt; env = DESKTOP_SESSION=gnome-classic
 ... ... ... 
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org10ffac9" class="outline-3">
<h3 id="org10ffac9"><span class="section-number-3">1.4</span> Simple Variable Definition and Initialization</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Simple variable definition: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">int</span> i;
&gt;&gt; <span class="org-type">int</span> ix = 200;

&gt;&gt; i
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0

&gt;&gt; ix
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 200
&gt;&gt; 

&gt;&gt; <span class="org-keyword">const</span> <span class="org-type">char</span> * s1  = <span class="org-string">" refresh memory about C++"</span> ;
&gt;&gt; s1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">" refresh memory about C++"</span>

&gt;&gt; <span class="org-type">char</span> s2 <span class="org-rainbow-delimiters-depth-1">[]</span>  = <span class="org-string">" refresh memory about C++"</span> ;
&gt;&gt; s2
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span> <span class="org-rainbow-delimiters-depth-2">[</span>26<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">" refresh memory about C++"</span>
&gt;&gt; 
</pre>
</div>

<p>
Multiple variable default initialization in same line: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">z</span>;

&gt;&gt; x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000
&gt;&gt; y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000
&gt;&gt; z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000
</pre>
</div>

<p>
Multiple variables initialization at same line: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">double</span> <span class="org-variable-name">xx</span> = 3.1515, <span class="org-variable-name">yy</span> = 3 * xx + 3.0, <span class="org-variable-name">zz</span> = xx * 2 + yy;

&gt;&gt; xx
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 3.1515000
&gt;&gt; yy
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 12.454500
&gt;&gt; zz
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 18.757500
&gt;&gt; 

<span class="org-type">double</span> xa<span class="org-rainbow-delimiters-depth-1">{</span>3.1515<span class="org-rainbow-delimiters-depth-1">}</span>, ya<span class="org-rainbow-delimiters-depth-1">{</span>3 * xa + 3.0<span class="org-rainbow-delimiters-depth-1">}</span>, za<span class="org-rainbow-delimiters-depth-1">{</span>xa * 2 + ya<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; xa
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 3.1515000
&gt;&gt; ya
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 12.454500
&gt;&gt; za
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 18.757500
&gt;&gt; 
</pre>
</div>

<p>
Multiple initialization with assignment: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">z</span>;
&gt;&gt; x = y = z = 3.0;
&gt;&gt; x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 3.0000000
&gt;&gt; y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 3.0000000
&gt;&gt; z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 3.0000000
&gt;&gt; 

<span class="org-function-name">std</span>::string s1, s2, s3;

&gt;&gt; s1 = s2 = s3 = <span class="org-string">"remember c++"</span>;
&gt;&gt; s1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"remember c++"</span>
&gt;&gt; s2
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"remember c++"</span>
&gt;&gt; s2
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"remember c++"</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdbdbdd8" class="outline-3">
<h3 id="orgdbdbdd8"><span class="section-number-3">1.5</span> Literals and C++14  Literals</h3>
<div class="outline-text-3" id="text-1-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Literal Description</th>
<th scope="col" class="org-left">Example</th>
<th scope="col" class="org-left">Since</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Integer</td>
<td class="org-left">12905134</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Integer separated by single quote</td>
<td class="org-left">1'290'5134</td>
<td class="org-left">C++14</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Unsigned integer 10</td>
<td class="org-left">12905134U</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Unsigned integer separated by single quote</td>
<td class="org-left">1'290'5134U</td>
<td class="org-left">C++14</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Integer in hexadecimal base (base 16)</td>
<td class="org-left">0xFF4A5A</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Integer in hexadecimal base separate by single quote (')</td>
<td class="org-left">0xFF'4A'5A</td>
<td class="org-left">C++14</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Integer in binary (base 2) format (0xF1 = 241)</td>
<td class="org-left">0b11110001</td>
<td class="org-left">C++14</td>
</tr>

<tr>
<td class="org-left">Integer in binary format separated by single quote</td>
<td class="org-left">0b1111'0001</td>
<td class="org-left">C++14</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Float point double precision (double)</td>
<td class="org-left">15'55'100.91'51'61</td>
<td class="org-left">C++14</td>
</tr>

<tr>
<td class="org-left">Float point double precision (double)</td>
<td class="org-left">1555'100.915161</td>
<td class="org-left">C++14</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Character literal</td>
<td class="org-left">'X'</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Non printable character literal (LF Line Feed 0x0D)</td>
<td class="org-left">'<code>\x0D'</code></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Literal Formats added in C++14 
</p>

<ul class="org-ul">
<li>Binary Literals =&gt; More convenient for low level, device drivers,
embedded systems and so on. 

<ul class="org-ul">
<li>0b11110001 = 0xF1 = 241</li>
</ul></li>

<li>Numeric Literals separated by single quote:

<ul class="org-ul">
<li>1000'000,000 =&gt; 1 billion</li>
<li>0b1111'0001 =  0b11110001</li>
<li>0xF'FAA'BBAC</li>
</ul></li>
</ul>

<p>
Examples: 
</p>

<ul class="org-ul">
<li>Character (char)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-comment-delimiter">// </span><span class="org-comment">Character literal</span>
<span class="org-type">char</span> <span class="org-variable-name">ch1</span> = <span class="org-string">'X'</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Non printable character literal - hexadecimal value 0xD which is the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">same as new line character  Unix LF Line Feed</span>
<span class="org-type">char</span> <span class="org-variable-name">ch2</span> = <span class="org-warning">'</span>\x0D<span class="org-warning">'</span>;
</pre>
</div>

<ul class="org-ul">
<li>Signed Integer (trivial)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">n</span> = 200;
</pre>
</div>

<ul class="org-ul">
<li>Integer hexadecimal literal (0xFF = 255 decimal)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">x</span> = 0xFF;
</pre>
</div>

<ul class="org-ul">
<li>Unsigned Integer Literals (suffix U) - always positive literals.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">ux1</span> = 1000U;
<span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">ux2</span> = 0xFFABU;
</pre>
</div>

<ul class="org-ul">
<li>Unsigned long literals (suffix UL) - always positive literals.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">ux3</span> = 0xFFABUL;
<span class="org-keyword">auto</span> <span class="org-variable-name">ux4</span> = 0xFFABUL;
assert<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">typeid</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-3">(</span>ux4<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> == <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-2">)</span> &amp;&amp; <span class="org-string">"Types should be equal"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>Integer separated by single quote:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Since C++14</span>
<span class="org-type">uint32_t</span> <span class="org-variable-name">register_config</span> = 0xF'AAB'987A;

<span class="org-comment-delimiter">// </span><span class="org-comment">Binary literal (Number in base 2) - Since C++14</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">0b10001001 = 0x89 = 8 * 16 + 9 * 16^0 = 137</span>
<span class="org-type">uint8_t</span> <span class="org-variable-name">gpioA_config</span> = 0b10001001;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" gpioA_config = "</span> &lt;&lt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>gpioA_config<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-comment-delimiter">// </span><span class="org-comment">Binary literal with single quote separator</span>
<span class="org-type">int</span> <span class="org-variable-name">gpioB_config</span> = 0b1000'1001;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" gpioB_config = "</span> &lt;&lt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>gpioB_config<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-comment-delimiter">// </span><span class="org-comment">Number literal with single quote separator (')</span>
<span class="org-type">long</span> <span class="org-variable-name">quantity</span> = 100'000'000;
</pre>
</div>

<ul class="org-ul">
<li>IEEE754 Single Precision Literals - 32 bits (suffix .f)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">float</span> <span class="org-variable-name">flt32A</span> = 100.23f;

<span class="org-type">float</span> <span class="org-variable-name">flt32B</span> = 100.23E5f; <span class="org-comment-delimiter">// </span><span class="org-comment">100.23 * 10^5</span>

<span class="org-type">float</span> <span class="org-variable-name">flt32C</span> = .001114465111f; 

<span class="org-type">float</span> <span class="org-variable-name">flt32D</span> = 0.001114465111E6f; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Separated by single quote (C++14)</span>
<span class="org-type">float</span> <span class="org-variable-name">flt32E</span> = 1555'100.9151f;

<span class="org-comment-delimiter">// </span><span class="org-comment">Separated by single quote (C++14)</span>
<span class="org-type">float</span> <span class="org-variable-name">flt32F</span> = 15'55'100.91'51'61f;
</pre>
</div>

<ul class="org-ul">
<li>IEEE754 Double Precision Literals - 64 bits (default float point literal)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">double</span> <span class="org-variable-name">flt64A</span> = -1120.4;

<span class="org-type">double</span> <span class="org-variable-name">flt64A</span> = -20.4E3;

<span class="org-comment-delimiter">// </span><span class="org-comment">Separated by single quote </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Separated by single quote (C++14)</span>
<span class="org-type">double</span> <span class="org-variable-name">flt32F</span> = 15'55'100.91'51'61;
</pre>
</div>

<ul class="org-ul">
<li>String Literal</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">str1</span> = <span class="org-string">"Hello world C++"</span>;
<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">str2</span> = <span class="org-string">"Hello \n \xFD \xF7 world C++"</span>;
 <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">windows_path</span> = <span class="org-string">"C:\\User\\Dummy\\Path"</span>;
</pre>
</div>

<ul class="org-ul">
<li>Raw String Literal R(" &#x2026; ")
<ul class="org-ul">
<li>Supports multiline and characters that are used for escaping
sequence such as backward slash (\) that needs to be escaped and
written as (\\).</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">   <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">windows_path</span> = R<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"C:\Uses\Dummy\Path"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

   <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">regex</span> = R<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"^\d+\w+"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

   <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">script_source</span> = R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">    for(i = 0 to 10) do {</span>
<span class="org-string">      println(i * 3)</span>
<span class="org-string">    }</span>

<span class="org-string">    list_files(C:\Users\data\path)</span>
<span class="org-string">)</span><span class="org-default">"</span>;
</pre>
</div>
</div>
</div>


<div id="outline-container-orgd0f862d" class="outline-3">
<h3 id="orgd0f862d"><span class="section-number-3">1.6</span> Control Structures</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org4d277ca" class="outline-4">
<h4 id="org4d277ca"><span class="section-number-4">1.6.1</span> ternary operator - question mark (?)</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
Unlike the if-else statement, the ternary operator (?) or question
mark operator, can solve return a value, although it cannot have
complex statements like if-else. In functional languages like Lisp,
Scala or Haskell, the if-else operator always is evaluated and returns
</p>

<p>
Limitation: The ternary operator cannot have complex statements like
if-else.
</p>

<p>
Syntax:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-rainbow-delimiters-depth-1">{</span>VARIABLE<span class="org-rainbow-delimiters-depth-1">}</span> = <span class="org-rainbow-delimiters-depth-1">{</span>CONDITION<span class="org-rainbow-delimiters-depth-1">}</span> ? <span class="org-rainbow-delimiters-depth-1">{</span>RETURN-IF-TRUE<span class="org-rainbow-delimiters-depth-1">}</span> : <span class="org-rainbow-delimiters-depth-1">{</span>RETURN-IF-FASLE<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Example:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">true</span> ? <span class="org-string">"true"</span> : <span class="org-string">"false"</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"true"</span>
&gt;&gt; <span class="org-constant">false</span> ? <span class="org-string">"true"</span> : <span class="org-string">"false"</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"false"</span>

&gt;&gt; <span class="org-type">int</span> x;
&gt;&gt; x = <span class="org-constant">true</span> ? 10 : 25
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
&gt;&gt; x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10

&gt;&gt; x = <span class="org-constant">false</span> ? 10 : 25
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 25
&gt;&gt;
&gt;&gt;

&gt;&gt; <span class="org-constant">std</span>::string s;
&gt;&gt; x = 10;
&gt;&gt; s = <span class="org-rainbow-delimiters-depth-1">(</span>x &lt; 15<span class="org-rainbow-delimiters-depth-1">)</span> ? <span class="org-string">"true"</span> : <span class="org-string">"false"</span>
<span class="org-string">"true"</span>

&gt;&gt; x = 100;
&gt;&gt; s = <span class="org-rainbow-delimiters-depth-1">(</span>x &lt; 15<span class="org-rainbow-delimiters-depth-1">)</span> ? <span class="org-string">"true"</span> : <span class="org-string">"false"</span>
<span class="org-string">"false"</span>
&gt;&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdfbf49a" class="outline-4">
<h4 id="orgdfbf49a"><span class="section-number-4">1.6.2</span> if-else</h4>
<div class="outline-text-4" id="text-1-6-2">
</div>
<ol class="org-ol">
<li><a id="orgde85b93"></a>True and false<br />
<div class="outline-text-5" id="text-1-6-2-1">
<p>
In C++, everything equal to zero is false and everything other than
zero is true.
</p>

<ul class="org-ul">
<li>Booleans</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">bool</span> flag;

<span class="org-comment-delimiter">// </span><span class="org-comment">Size - 1 byte</span>
&gt;&gt; <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 1

&gt;&gt; flag = <span class="org-constant">false</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Booleans are actually numbers</span>
&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"flag = "</span> &lt;&lt; flag &lt;&lt; <span class="org-string">"\n"</span>;
flag = 0

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"flag = "</span> &lt;&lt; <span class="org-constant">std</span>::boolalpha &lt;&lt; flag &lt;&lt; <span class="org-string">"\n"</span>;
flag = <span class="org-constant">false</span>
&gt;&gt;

&gt;&gt; flag = <span class="org-constant">true</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">True</span>
&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"flag = "</span> &lt;&lt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>flag<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
flag = 1
&gt;&gt;

</pre>
</div>

<ul class="org-ul">
<li>Booleans - If-else</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">bool</span> flag;

&gt;&gt; flag = <span class="org-constant">false</span>;
&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>flag<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; False

&gt;&gt; flag  = <span class="org-constant">true</span>;
&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>flag<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; True
&gt;&gt;
</pre>
</div>

<ul class="org-ul">
<li>Char</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">char</span> <span class="org-variable-name">x</span>;

&gt;&gt; x = <span class="org-string">'\0'</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Null character</span>
&gt;&gt;  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; False

&gt;&gt; x = 0x00; <span class="org-comment-delimiter">// </span><span class="org-comment">Ascii code of null character</span>
&gt;&gt;  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; False

&gt;&gt; x = <span class="org-string">'a'</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'a'</span>
&gt;&gt;  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; True
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Integers:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">n</span> = 10;

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; True
&gt;&gt;

&gt;&gt; n = 0;
&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; False
&gt;&gt;
</pre>
</div>

<ul class="org-ul">
<li>Double:
<ul class="org-ul">
<li>Note: Float pointers should never be tested by comparison.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">double</span> num;

&gt;&gt; num = 12.3;
&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>num<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; True

&gt;&gt; num = 0.0;
&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>num<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; False
</pre>
</div>

<ul class="org-ul">
<li>Pointers:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">double</span>* ptr;

&gt;&gt; ptr = <span class="org-constant">nullptr</span>;
&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; False

&gt;&gt; <span class="org-type">double</span> m;
&gt;&gt; ptr = &amp;m
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f14ccfce020

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; True
&gt;&gt;

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; False

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">NULL</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; True"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; False"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; False
</pre>
</div>
</div>
</li>

<li><a id="orgfae7173"></a>Returning value from if-else statements (C++11)<br />
<div class="outline-text-5" id="text-1-6-2-2">
<p>
The C++ if-else statement cannot return a value or be evaluated to a
value as the if-else statement in Lisp, Scheme, Scala, Haskell and
other functional languages. Despite that the ternary operator (?) can
be evaluated to some value, it cannot contain complex expressions as
if-else statements.
</p>

<p>
<b>if-else in Scala</b>
</p>

<div class="org-src-container">
<pre class="src src-scala">
<span class="org-comment-delimiter">// </span><span class="org-comment">========&gt;&gt;&gt; EXPERIMENT 1 ==============//</span>
<span class="org-keyword">var</span> <span class="org-scala-font-lockXvar">x</span><span class="org-keyword">:</span> <span class="org-type">Double</span> <span class="org-keyword">=</span> <span class="org-constant">0.0</span>;
<span class="org-keyword">var</span> <span class="org-scala-font-lockXvar">n</span> <span class="org-keyword">=</span> <span class="org-constant">10</span>;

scala&gt; x <span class="org-keyword">=</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>n &gt; <span class="org-constant">100</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">256.0</span> <span class="org-keyword">else</span> <span class="org-constant">300.0</span>
<span class="org-function-name">x</span><span class="org-keyword">:</span> <span class="org-type">Double</span> <span class="org-keyword">=</span> <span class="org-constant">300.0</span>

scala&gt; n <span class="org-keyword">=</span> <span class="org-constant">200</span>
<span class="org-function-name">n</span><span class="org-keyword">:</span> <span class="org-type">Int</span> <span class="org-keyword">=</span> <span class="org-constant">200</span>

scala&gt; x <span class="org-keyword">=</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>n &gt; <span class="org-constant">100</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">256.0</span> <span class="org-keyword">else</span> <span class="org-constant">300.0</span>
<span class="org-function-name">x</span><span class="org-keyword">:</span> <span class="org-type">Double</span> <span class="org-keyword">=</span> <span class="org-constant">256.0</span>


<span class="org-comment-delimiter">// </span><span class="org-comment">========&gt;&gt;&gt; EXPERIMENT 2 ==============//</span>

n <span class="org-keyword">=</span> <span class="org-constant">50</span>
scala&gt; x <span class="org-keyword">=</span>  <span class="org-constant">400</span> + <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>n &gt; <span class="org-constant">100</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> println<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Return 256.0"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-constant">256</span>  <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-2">{</span> println<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Return 300.0"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-constant">300.0</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-constant">Return</span> <span class="org-constant">300.0</span>
<span class="org-function-name">x</span><span class="org-keyword">:</span> <span class="org-type">Double</span> <span class="org-keyword">=</span> <span class="org-constant">700.0</span>

scala&gt; x <span class="org-keyword">=</span>  <span class="org-constant">400</span> + <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>n &gt; <span class="org-constant">100</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> println<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Return 256.0"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-constant">256</span>  <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-2">{</span> println<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Return 300.0"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-constant">300.0</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-constant">Return</span> <span class="org-constant">256.0</span>
<span class="org-function-name">x</span><span class="org-keyword">:</span> <span class="org-type">Double</span> <span class="org-keyword">=</span> <span class="org-constant">656.0</span>

</pre>
</div>

<p>
<b>if-else in C++</b>
</p>

<p>
Desired functionality, however the following code doesn't work.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">double</span> x;
&gt;&gt; <span class="org-type">int</span> n;
&gt;&gt; 
&gt;&gt; n = 10;

<span class="org-comment-delimiter">// </span><span class="org-comment">Compilation error! It doesn't work in C++ </span>
&gt;&gt; x = <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>n &gt; 100<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 
         <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Return 256"</span><span class="org-rainbow-delimiters-depth-2">)</span>;  
         <span class="org-keyword">return</span> 256.0;<span class="org-rainbow-delimiters-depth-1">}</span> 
      <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> 
         <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Return 300.0"</span><span class="org-rainbow-delimiters-depth-2">)</span>; 
         <span class="org-keyword">return</span> 300.0; 
      <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">ROOT_prompt_4</span>:1:5: error: expected expression
x = <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>n &gt; 100<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Return 256"</span><span class="org-rainbow-delimiters-depth-2">)</span>;  <span class="org-keyword">return</span> 256.0;<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::pu...
    ^
&gt;&gt; 
</pre>
</div>

<p>
It could also be as shown in the following code, however, it requires
modifying the variable x in more than one place. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">double</span> <span class="org-variable-name">x</span>;
<span class="org-type">int</span> <span class="org-variable-name">n</span>; 

n = 200;

<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>n &gt; 100<span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Return 256"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  x = 256.0;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Return 300"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  x = 300.0 
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Solution: Wrap the if-else statement into a self-executing lambda
expression. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">T</span> <span class="org-variable-name">result</span>;

result = <span class="org-rainbow-delimiters-depth-1">[</span>&amp;<span class="org-rainbow-delimiters-depth-1">](){</span>
              <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>CONDITION<span class="org-rainbow-delimiters-depth-2">){</span>
                 <span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">COMPTATIONS</span>...<span class="org-variable-name">FALSE</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>;
                 <span class="org-keyword">return</span> VALUE-TRUE;
              <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                 <span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">COMPTATIONS</span>...<span class="org-variable-name">ELSE</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>;
                 <span class="org-keyword">return</span> VALUE-FALSE;
              <span class="org-rainbow-delimiters-depth-2">}</span>          
          <span class="org-rainbow-delimiters-depth-1">}()</span>;
</pre>
</div>

<p>
An alternative way is to wrap the if-else statement into a
function. The advantage of this solution is that the computation can
be reused in multiple different places in the code.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">T1</span> <span class="org-variable-name">input1</span>;
<span class="org-type">T2</span> <span class="org-variable-name">input2</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">The computation is wrapped into a lambda function (thunk)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">,depends on inputs input1, input2, ... as inputs.</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">computation</span> = <span class="org-rainbow-delimiters-depth-1">[</span>&amp;<span class="org-rainbow-delimiters-depth-1">](){</span>
               <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>CONDITION<span class="org-rainbow-delimiters-depth-3">(</span>input1, input2 ...<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">){</span>
                   <span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">COMPTATIONS</span>...<span class="org-variable-name">FALSE</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>;
                   <span class="org-keyword">return</span> VALUE-TRUE;
                <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                   <span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">COMPTATIONS</span>...<span class="org-variable-name">ELSE</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>;
                    <span class="org-keyword">return</span> VALUE-FALSE;
                <span class="org-rainbow-delimiters-depth-2">}</span>            
           <span class="org-rainbow-delimiters-depth-1">}</span>;

input1 = value1A;
input2 = value1B;
<span class="org-type">Result</span> <span class="org-variable-name">result1</span> = computation<span class="org-rainbow-delimiters-depth-1">()</span>;

input1 = value1B;
input2 = value1B;
<span class="org-type">Result</span> <span class="org-variable-name">result2</span> = computation<span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">double</span> <span class="org-variable-name">x</span>;
<span class="org-type">int</span> <span class="org-variable-name">n</span>;

n = 50;

&gt;&gt; x = <span class="org-rainbow-delimiters-depth-1">[</span>&amp;<span class="org-rainbow-delimiters-depth-1">](){</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>n &gt; 100<span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-rainbow-delimiters-depth-2">{</span>
               <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [LOG] Return 256"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
               <span class="org-keyword">return</span> 256.0;
        <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
               <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [LOG] Return 300.0"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
               <span class="org-keyword">return</span> 300.0;
        <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}()</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Return 300.0

&gt;&gt; x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 300.00000
&gt;&gt; 

n = 400;

&gt;&gt; x = <span class="org-rainbow-delimiters-depth-1">[</span>&amp;<span class="org-rainbow-delimiters-depth-1">](){</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>n &gt; 100<span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [LOG] Return 256"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-keyword">return</span> 256.0;
        <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
                <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [LOG] Return 300.0"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-keyword">return</span> 300.0;
        <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}()</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Return 256

</pre>
</div>

<p>
Further Reading: 
</p>

<ul class="org-ul">
<li><a href="https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/">Complex initialization for a const variable | Sutter’s Mill</a></li>
<li><a href="https://www.reddit.com/r/cpp/comments/62k8b0/lambda_initialization_trick_add_syntactic_sugar/">Lambda initialization trick, add syntactic sugar? : cpp</a></li>
<li><a href="https://stackoverflow.com/questions/15581662/is-it-possible-to-initialize-static-variable-with-lambda">c++ - is it possible to initialize static variable with lambda? - Stack Overflow</a></li>
</ul>
</div>
</li>
</ol>
</div>

<div id="outline-container-org7ee5808" class="outline-4">
<h4 id="org7ee5808"><span class="section-number-4">1.6.3</span> switch case</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
Swich case statements can only be used with numbers, characters or
Enums. They cannot be used for processing strings or classes.
</p>

<p>
<b>Example 1</b>: Print month based on its number.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">printMonth1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">nl</span> = <span class="org-string">'\n'</span>;
     <span class="org-keyword">switch</span><span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-keyword">case</span> 1:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"JAN"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 2:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"FEB"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 3:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"MAR"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 4:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"APR"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;           
        <span class="org-keyword">case</span> 5:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"MAY"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 6:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"JUN"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 7:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"JUL"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 8:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"AUG"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 9:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"SEP"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 10: <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"OCT"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 11: <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"NOV"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 12: <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"DEC"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">default</span>: <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Error: invalid month."</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; printMonth1<span class="org-rainbow-delimiters-depth-1">(</span>1<span class="org-rainbow-delimiters-depth-1">)</span>
JAN
&gt;&gt; printMonth1<span class="org-rainbow-delimiters-depth-1">(</span>2<span class="org-rainbow-delimiters-depth-1">)</span>
FEB
&gt;&gt; printMonth1<span class="org-rainbow-delimiters-depth-1">(</span>12<span class="org-rainbow-delimiters-depth-1">)</span>
DEC
&gt;&gt; printMonth1<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">Error</span>: invalid month.
&gt;&gt; printMonth1<span class="org-rainbow-delimiters-depth-1">(</span>-1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">Error</span>: invalid month.
&gt;&gt; 
</pre>
</div>

<p>
or 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">printMonth2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span> <span class="org-variable-name">nl</span> = <span class="org-string">'\n'</span>;
     <span class="org-keyword">switch</span><span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-keyword">case</span> 1:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"JAN"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 2:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"FEB"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 3:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"MAR"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 4:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"APR"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;           
        <span class="org-keyword">case</span> 5:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"MAY"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 6:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"JUN"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 7:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"JUL"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 8:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"AUG"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 9:  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"SEP"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 10: <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"OCT"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 11: <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"NOV"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 12: <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"DEC"</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Error: invalid month."</span> &lt;&lt; nl; <span class="org-keyword">break</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Example 2</b> : Return month name as a string based on month number.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">std::string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-function-name">std</span>::string getMonth<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">switch</span><span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">){</span>
         <span class="org-keyword">case</span> 1:  <span class="org-keyword">return</span> <span class="org-string">"JAN"</span>;
         <span class="org-keyword">case</span> 2:  <span class="org-keyword">return</span> <span class="org-string">"FEB"</span>;
         <span class="org-keyword">case</span> 3:  <span class="org-keyword">return</span> <span class="org-string">"MAR"</span>;
         <span class="org-keyword">case</span> 4:  <span class="org-keyword">return</span> <span class="org-string">"APR"</span>;
         <span class="org-keyword">case</span> 5:  <span class="org-keyword">return</span> <span class="org-string">"MAY"</span>;
         <span class="org-keyword">case</span> 6:  <span class="org-keyword">return</span> <span class="org-string">"JUN"</span>;
         <span class="org-keyword">case</span> 7:  <span class="org-keyword">return</span> <span class="org-string">"JUL"</span>;
         <span class="org-keyword">case</span> 8:  <span class="org-keyword">return</span> <span class="org-string">"AUG"</span>;
         <span class="org-keyword">case</span> 9:  <span class="org-keyword">return</span> <span class="org-string">"SEP"</span>;
         <span class="org-keyword">case</span> 10: <span class="org-keyword">return</span> <span class="org-string">"OCT"</span>;
         <span class="org-keyword">case</span> 11: <span class="org-keyword">return</span> <span class="org-string">"NOV"</span>;
         <span class="org-keyword">case</span> 12: <span class="org-keyword">return</span> <span class="org-string">"DEC"</span>;
         <span class="org-keyword">default</span>:
                 <span class="org-keyword">throw</span> <span class="org-constant">std</span>::domain_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Error: invalid month"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Test code: 
</p>

<ul class="org-ul">
<li>Online compiler: <a href="https://rextester.com/TKA23321">https://rextester.com/TKA23321</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::string month;    
month = getMonth<span class="org-rainbow-delimiters-depth-1">(</span>1<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"Month = "</span> &lt;&lt; month &lt;&lt; <span class="org-string">"\n"</span>;     
month = getMonth<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"Month = "</span> &lt;&lt; month &lt;&lt; <span class="org-string">"\n"</span>;    

<span class="org-keyword">try</span><span class="org-rainbow-delimiters-depth-1">{</span>
    month = getMonth<span class="org-rainbow-delimiters-depth-2">(</span>100<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Month = "</span> &lt;&lt; month &lt;&lt; <span class="org-string">"\n"</span>;    
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">domain_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"An error has happened = "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">Month = JAN
Month = APR
An error has happened = Error: invalid month
</pre>
</div>

<p>
<b>Example 3</b>: Switch-case for string input. 
</p>

<p>
As switch-case control structure cannot be used with std::string
input, the best approach is to use if-else statements, if-statements
with early return or hash tables.
</p>

<ul class="org-ul">
<li>Solution 1: If statements with early return.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">getDayOfWeekNum</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">weekDay</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>weekDay == <span class="org-string">"Sun"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">return</span> 1;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>weekDay == <span class="org-string">"Mon"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">return</span> 2;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>weekDay == <span class="org-string">"Tue"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">return</span> 3;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>weekDay == <span class="org-string">"Wed"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">return</span> 4;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>weekDay == <span class="org-string">"Thu"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">return</span> 5;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>weekDay == <span class="org-string">"Fri"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">return</span> 6;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>weekDay == <span class="org-string">"Sat"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">return</span> 7;
    <span class="org-keyword">return</span> -1;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; getDayOfWeekNum<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Sun"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 1
&gt;&gt; getDayOfWeekNum<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Tue"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 3
&gt;&gt; getDayOfWeekNum<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Fri"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 6
&gt;&gt; getDayOfWeekNum<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> -1
&gt;&gt; getDayOfWeekNum<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Error"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> -1
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Solution 2: A hash table or dictionary.</li>
</ul>

<p>
Note: <i>Static variables inside functions are initialized only once and
retains their current state</i> between function calls. They are similar
to global variables, but static variables are only visible inside the
function they are defined.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">map</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">getDayOfWeekNum2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">weekDay</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-variable-name">week_table</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"Sun"</span>, 1<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"Mon"</span>, 2<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"Tue"</span>, 3<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"Wed"</span>, 4<span class="org-rainbow-delimiters-depth-3">}</span>,
       <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"Thu"</span>, 5<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"Fri"</span>, 6<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"Sat"</span>, 7<span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>week_table.find<span class="org-rainbow-delimiters-depth-3">(</span>weekDay<span class="org-rainbow-delimiters-depth-3">)</span> != week_table.end<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-keyword">return</span> week_table<span class="org-rainbow-delimiters-depth-2">[</span>weekDay<span class="org-rainbow-delimiters-depth-2">]</span>;  
    <span class="org-keyword">return</span> -1;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; getDayOfWeekNum2<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Sun"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 1
&gt;&gt; getDayOfWeekNum2<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Mon"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 2
&gt;&gt; getDayOfWeekNum2<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Monasd"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> -1
&gt;&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-org0d4df04" class="outline-4">
<h4 id="org0d4df04"><span class="section-number-4">1.6.4</span> for loop</h4>
<div class="outline-text-4" id="text-1-6-4">
<ul class="org-ul">
<li>Basic for-loop</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span> = 0; x &lt; 5; x++<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-1">}</span>
 x = 0
 x = 1
 x = 2
 x = 3
 x = 4

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span> = -10.0; x &lt;= 10.0; x += 2.5<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-1">}</span>
 x = -10
 x = -7.5
 x = -5
 x = -2.5
 x = 0
 x = 2.5
 x = 5
 x = 7.5
 x = 10
&gt;&gt;

</pre>
</div>

<ul class="org-ul">
<li>Infinity loop</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span>;;<span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" It is an infinity loop"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 It is an infinity loop
 It is an infinity loop
 It is an infinity loop
 It is an <span class="org-type">infinity</span> <span class="org-variable-name">loop</span>
 .,.. ... ... ...
</pre>
</div>
</div>
</div>

<div id="outline-container-org622d0c4" class="outline-4">
<h4 id="org622d0c4"><span class="section-number-4">1.6.5</span> while loop</h4>
<div class="outline-text-4" id="text-1-6-5">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdio</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

&gt;&gt; n = 0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0

&gt;&gt; <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span>n &lt; 5<span class="org-rainbow-delimiters-depth-1">){</span>  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"n = "</span> &lt;&lt; n++ &lt;&lt; <span class="org-string">"\n"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
n = 0
n = 1
n = 2
n = 3
n = 4

&gt;&gt; <span class="org-type">int</span> j = 0;
&gt;&gt; <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span>j++ &lt; 5<span class="org-rainbow-delimiters-depth-1">){</span>  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"j = "</span> &lt;&lt; j &lt;&lt; <span class="org-string">"\n"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
j = 1
j = 2
j = 3
j = 4
j = 5
&gt;&gt; j = 0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0

&gt;&gt; <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span>++j &lt; 5<span class="org-rainbow-delimiters-depth-1">){</span>  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"j = "</span> &lt;&lt; j &lt;&lt; <span class="org-string">"\n"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
j = 1
j = 2
j = 3
j = 4
&gt;&gt;
</pre>
</div>

<p>
Infinity lop:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" It is an infinity loop"</span> &lt;&lt; <span class="org-string">"\n"</span>;<span class="org-rainbow-delimiters-depth-1">}</span>
It is an infinity loop
It is an infinity loop
It is an <span class="org-type">infinity</span> <span class="org-variable-name">loop</span>
... ... ... ..
</pre>
</div>
</div>
</div>

<div id="outline-container-org1a85ef4" class="outline-4">
<h4 id="org1a85ef4"><span class="section-number-4">1.6.6</span> do - while loop</h4>
<div class="outline-text-4" id="text-1-6-6">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">z</span> = -10;

<span class="org-comment-delimiter">// </span><span class="org-comment">Single line</span>
&gt;&gt; <span class="org-keyword">do</span><span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" z = "</span> &lt;&lt; z &lt;&lt; <span class="org-string">"\n"</span>; z++; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span>z &lt; 0<span class="org-rainbow-delimiters-depth-1">)</span>
 z = -10
 z = -9
 z = -8
 z = -7
 z = -6
 z = -5
 z = -4
 z = -3
 z = -2
 z = -1
&gt;&gt;

<span class="org-comment-delimiter">// </span><span class="org-comment">Multiple Lines</span>
<span class="org-keyword">do</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" z = "</span> &lt;&lt; z &lt;&lt; <span class="org-string">"\n"</span>;
    z++;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span>z &lt; 0<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org75131e5" class="outline-3">
<h3 id="org75131e5"><span class="section-number-3">1.7</span> Basic Console IO</h3>
<div class="outline-text-3" id="text-1-7">
</div>
<div id="outline-container-org5d4e0e3" class="outline-4">
<h4 id="org5d4e0e3"><span class="section-number-4">1.7.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
C++ input/output system is object oriented which means that it is
possible to write input-agnostic or output-agnostic code which can be
reused without any rewritten for reading data from console, file,
string and other end-points.
</p>

<p>
C++ Has the following global objects for performing IO. 
</p>

<ul class="org-ul">
<li><b>std::cout</b> 
<ul class="org-ul">
<li>(stdout) Standard output stream used for displaying program output.</li>
</ul></li>

<li><b>std::cerr</b> 
<ul class="org-ul">
<li>(stderr) Stadnard error output stream used for displaying program
error and logging output. It prints by default to the
console. The output of the stream std::cerr (stderr) can be separated from
std::cout (stdout) output by redirecting the stederr output to a
log file or discarding it.</li>
</ul></li>

<li><b>std::clog</b>
<ul class="org-ul">
<li>(stderr) =&gt; Standard logging output stream.</li>
</ul></li>

<li><b>std::cin</b>  =&gt; Basic Input stream or stdin. Used for reading data
from console.</li>
</ul>

<p>
Operators: 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Parent class</th>
<th scope="col" class="org-left">Derived Classes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Insertion Operator</td>
<td class="org-left">&lt;&lt;</td>
<td class="org-left">std::ostream / Output</td>
<td class="org-left">std::cout, std::cerr, std::ofstream</td>
</tr>

<tr>
<td class="org-left">Extraction Operator</td>
<td class="org-left">&gt;&gt;</td>
<td class="org-left">std::istream / Input</td>
<td class="org-left">std::cin, std::ifstream, std::sstringstream</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org7953563" class="outline-4">
<h4 id="org7953563"><span class="section-number-4">1.7.2</span> Example - Old C-IO functions</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
Sometimes the old C-IO functions such as printf, puts and perror may
be convenient due to its simplicity and less verbosity.
</p>

<ul class="org-ul">
<li>Header: <a href="https://en.cppreference.com/w/cpp/header/cstdio">&lt;cstdio&gt;</a></li>
</ul>

<p>
Functions puts, perror 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">C++ header equivalent to C &lt;stdio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdio</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Print to STDOUT (cout)</span>
&gt;&gt; <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" =&gt; System programming."</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 =&gt; System programming.

<span class="org-comment-delimiter">// </span><span class="org-comment">Print to STDERR (cerr)</span>
&gt;&gt; <span class="org-constant">std</span>::perror<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" =&gt; Print error and logging to stderr."</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 =&gt; Print error <span class="org-keyword">and</span> logging to stderr.: No such file <span class="org-keyword">or</span> directory


<span class="org-comment-delimiter">// </span><span class="org-comment">Write to file (disk file, or pseudo-files such as stderr or stdout)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">U-nix where C comes from see everything as files. </span>

&gt;&gt; <span class="org-constant">std</span>::fputs<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Hello world\n"</span>, stdout<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">Hello</span> <span class="org-variable-name">world</span>
&gt;&gt; <span class="org-constant">std</span>::fputs<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Hello world\n"</span>, stderr<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">Hello</span> <span class="org-variable-name">world</span>
&gt;&gt; 

</pre>
</div>

<p>
Functions puts, perror and fputs with C++ strings 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string text;
&gt;&gt; text = <span class="org-string">"Hello world C-IO facilities\n"</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Failure =&gt; Cannot print C++ string, only const char </span>
&gt;&gt; <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span>text<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">ROOT_prompt_5</span>:1:11: error: no viable conversion from <span class="org-warning">'</span><span class="org-constant">std</span>::string<span class="org-warning">'</span> ...

&gt;&gt; <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span>text.c_str<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Hello <span class="org-type">world</span> <span class="org-function-name">C</span>-IO facilities

&gt;&gt; <span class="org-constant">std</span>::perror<span class="org-rainbow-delimiters-depth-1">(</span>text.c_str<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
Hello <span class="org-type">world</span> <span class="org-variable-name">C</span>-IO facilities

</pre>
</div>

<p>
Old C-printf and fprintf 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdio</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

&gt;&gt; <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"The value of pi is equal to: %.4f\n"</span>, M_PI<span class="org-rainbow-delimiters-depth-1">)</span>;
The value of pi is <span class="org-type">equal</span> <span class="org-variable-name">to</span>: 3.1416

&gt;&gt; <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"The value of pi is equal to: %.5f\n"</span>, M_PI<span class="org-rainbow-delimiters-depth-1">)</span>;
The value of pi is <span class="org-type">equal</span> <span class="org-variable-name">to</span>: 3.14159
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-1">(</span>stdout, <span class="org-string">"The value of pi is equal to: %.5f\n"</span>, M_PI<span class="org-rainbow-delimiters-depth-1">)</span>;
The value of pi is <span class="org-type">equal</span> <span class="org-variable-name">to</span>: 3.14159
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-1">(</span>stderr, <span class="org-string">"The value of pi is equal to: %.5f\n"</span>, M_PI<span class="org-rainbow-delimiters-depth-1">)</span>;
The value of pi is <span class="org-type">equal</span> <span class="org-variable-name">to</span>: 3.14159
&gt;&gt; 

<span class="org-function-name">std</span>:string userName = <span class="org-string">"Julius Caesar"</span>;
<span class="org-type">int</span> <span class="org-variable-name">points</span> = 200;

&gt;&gt; <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" =&gt; User = '%s' ; Points = %d\n"</span>, userName.c_str<span class="org-rainbow-delimiters-depth-2">()</span>, points<span class="org-rainbow-delimiters-depth-1">)</span>;
 =&gt; User = <span class="org-warning">'</span>Julius Caesar<span class="org-warning">'</span> ; Points = 200

&gt;&gt; <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-1">(</span>stdout, <span class="org-string">" =&gt; User = '%s' ; Points = %d\n"</span>, userName.c_str<span class="org-rainbow-delimiters-depth-2">()</span>, points<span class="org-rainbow-delimiters-depth-1">)</span> 
 =&gt; User = <span class="org-warning">'</span>Julius Caesar<span class="org-warning">'</span> ; Points = 200

&gt;&gt; <span class="org-constant">std</span>::fprintf<span class="org-rainbow-delimiters-depth-1">(</span>stderr, <span class="org-string">" =&gt; User = '%s' ; Points = %d\n"</span>, userName.c_str<span class="org-rainbow-delimiters-depth-2">()</span>, points<span class="org-rainbow-delimiters-depth-1">)</span> 
 =&gt; User = <span class="org-warning">'</span>Julius Caesar<span class="org-warning">'</span> ; Points = 200
&gt;&gt; 
</pre>
</div>

<p>
Printf is not type safe: 
</p>

<ul class="org-ul">
<li>It is easy to get a segmentation fault and runtime crash if the
printf arguments are not correct. Another problem is that the
compiler cannot give any help to catch this bug.</li>
<li>See:
<ul class="org-ul">
<li><a href="http://www.zverovich.net/2015/02/26/comparison-of-cppformat-and-printf.html">Comparison of C++ Format and C library's printf</a></li>
<li><a href="https://stackoverflow.com/questions/17789396/how-cout-is-more-typesafe-than-printf">c++ - How cout is more typesafe than printf() - Stack Overflow</a></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>:string userName = <span class="org-string">"Julius Caesar"</span>;
<span class="org-type">int</span> <span class="org-variable-name">points</span> = 200;

&gt;&gt; <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"User = '%s' ; Points = %d\n"</span>, points, userName.c_str<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
*** Break *** segmentation violation

<span class="org-comment-delimiter">// </span><span class="org-comment">Expected "c-string" (const char*) but provided int</span>
&gt;&gt; <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"%s\n"</span>, 100<span class="org-rainbow-delimiters-depth-1">)</span>;
*** Break *** segmentation violation
</pre>
</div>
</div>
</div>

<div id="outline-container-org105e128" class="outline-4">
<h4 id="org105e128"><span class="section-number-4">1.7.3</span> Example - Reading from Console</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
<b>Reading a single variable from console (stdin):</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

&gt;&gt; <span class="org-type">double</span> x;
&gt;&gt; <span class="org-constant">std</span>::cin &gt;&gt; x;
342.34
&gt;&gt; x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 342.34000
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Enter x: "</span>; <span class="org-constant">std</span>::cin &gt;&gt; x; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-type">Enter</span> <span class="org-variable-name">x</span>: 100
 =&gt; x = 100
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::string user;
&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Name: "</span>; <span class="org-constant">std</span>::cin &gt;&gt; user; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; user is = "</span> &lt;&lt; user &lt;&lt;Name: Julius Caesar
 =&gt; user is = Julius
&gt;&gt; 
</pre>
</div>

<p>
<b>Read line as string</b>
</p>

<p>
The statement <span class="underline">std::cin &gt;&gt; stringVariable</span> can only read a single word
and will ignore remaining words separated by space. In order to read
the entire line until the new line delimiter is found, it is necessary
to used the C++ function std::getline. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string some_line;

<span class="org-comment-delimiter">// </span><span class="org-comment">User types something and then hit RETURN when he is done.</span>
&gt;&gt; <span class="org-constant">std</span>::cin &gt;&gt; some_line;
some message <span class="org-type">to</span> <span class="org-function-name">compute</span>     

<span class="org-comment-delimiter">// </span><span class="org-comment">The remaining words were ignored. </span>
&gt;&gt; some_line
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"some"</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">User types something and then hit RETURN when he is done.</span>
&gt;&gt; <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cin, some_line<span class="org-rainbow-delimiters-depth-1">)</span>; 
 C++ is an old cool programming language.

&gt;&gt; some_line
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">" C++ is an old cool programming language."</span>
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" COMMAND =&gt; "</span> ; <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cin, some_line<span class="org-rainbow-delimiters-depth-1">)</span>;
 COMMAND =&gt; go to position 200 300

&gt;&gt; some_line
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"go to position 200 300"</span>
&gt;&gt; 

</pre>
</div>

<p>
<b>Read multiple lines until user sends EOF</b>
</p>

<p>
This code reads multiple lines from console untile the user sends the
EOF (End Of Signal) by typing Ctrl + D on U-nix (OSX, Linux, BSD) or
Ctrl + Z on Windows.
</p>

<ul class="org-ul">
<li>Read multiple lines example 1.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::string line;

<span class="org-comment-delimiter">// </span><span class="org-comment">Read lines until user types something invalid or sends EOF </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Ctlr + Z on Windows, Ctrl + D on U-nix (Linux, BSD, OSX ...)</span>
<span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cin, line<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">){</span> 
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"You typed = "</span> &lt;&lt; line &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

 Caesar cypher
<span class="org-type">You</span> <span class="org-variable-name">typed</span> =  Caesar cypher
 Hardening encryption 
You typed =  Hardening encryption
 Digital Signal Processors
You typed =  Digital Signal Processors
  ASICS <span class="org-keyword">and</span> FPGAs custom hardware
You typed =   ASICS <span class="org-keyword">and</span> FPGAs custom hardware
&gt;&gt; 
&gt;&gt; 

</pre>
</div>

<ul class="org-ul">
<li>Read multiple lines example 2.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">runREPL</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">line</span>;
  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cin.fail<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">){</span>
    <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [INFO] Input stream failure "</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cin.clear<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-constant">std</span>::cin.ignore<span class="org-rainbow-delimiters-depth-3">()</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" CMD=&gt; "</span> &lt;&lt; <span class="org-constant">std</span>::flush<span class="org-rainbow-delimiters-depth-3">)</span>, <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::cin, line<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" + Typed command was = "</span> &lt;&lt; line &lt;&lt; <span class="org-string">"\n"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" === Finish REPL session. OK ==="</span> &lt;&lt; <span class="org-string">"\n"</span>;
  <span class="org-constant">std</span>::cin.clear<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-txt">&gt;&gt; runREPL()
 CMD=&gt; Testing C++ on ROOT REPL.
 + Typed command was = Testing C++ on ROOT REPL.
 CMD=&gt; Clang is the best compiler out there
 + Typed command was = Clang is the best compiler out there
 CMD=&gt; Clang has the best and less cryptic error messages
 + Typed command was = Clang has the best and less cryptic error messages
 CMD=&gt;   
 === Finish REPL session. OK ===
&gt;&gt; 
</pre>
</div>

<p>
<b>Read multiple variables from console (stdin):</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-type">int</span>         <span class="org-variable-name">id</span>, <span class="org-variable-name">quantity</span>;
<span class="org-type">double</span>      <span class="org-variable-name">price</span>;
<span class="org-function-name">std</span>::string name;

<span class="org-comment-delimiter">// </span><span class="org-comment">Read from console</span>
&gt;&gt; <span class="org-constant">std</span>::cin &gt;&gt; id &gt;&gt; name &gt;&gt; quantity &gt;&gt; price ;
2351 Cooking-oil 20 3.12

&gt;&gt; id
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 2351
&gt;&gt; quantity
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 20
&gt;&gt; name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Cooking-oil"</span>
&gt;&gt; price
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 3.1200000
&gt;&gt; 
</pre>
</div>

<p>
<b>Reading structured data from console:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">struct</span> <span class="org-type">Product</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">id</span>;
    <span class="org-constant">std</span>::<span class="org-type">string</span>   <span class="org-variable-name">name</span>;     
    <span class="org-type">double</span>        <span class="org-variable-name">price</span>;
    <span class="org-type">unsigned</span> <span class="org-type">int</span>  <span class="org-variable-name">quantity</span>;
    <span class="org-function-name">Product</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Or it could also be:</span>
<span class="org-keyword">class</span> <span class="org-type">Product</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">id</span>;
    <span class="org-constant">std</span>::<span class="org-type">string</span>   <span class="org-variable-name">name</span>;     
    <span class="org-type">double</span>        <span class="org-variable-name">price</span>;
    <span class="org-type">unsigned</span> <span class="org-type">int</span>  <span class="org-variable-name">quantity</span>;
    <span class="org-function-name">Product</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">Product</span> <span class="org-function-name">readProductFromConsole</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-type">Product</span> <span class="org-variable-name">p</span>;
    <span class="org-constant">std</span>::cin &gt;&gt; p.id &gt;&gt; p.name &gt;&gt; p.price &gt;&gt; p.quantity;
    <span class="org-keyword">return</span> p;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Type Alias   </span>
<span class="org-keyword">using</span> <span class="org-type">Inventory</span> = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Product</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-type">Inventory</span> <span class="org-function-name">readInventory</span><span class="org-rainbow-delimiters-depth-1">(){</span>
   <span class="org-type">Inventory</span> <span class="org-variable-name">inv</span>;
   <span class="org-constant">std</span>::cin.clear<span class="org-rainbow-delimiters-depth-2">()</span>;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Enter product ID, product Name, product Price, product Quantity."</span> &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Type CTRL+D on U-nix or CTRL+Z on Windows when you are done."</span> &lt;&lt; <span class="org-string">"\n"</span>;     
   <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cin.good<span class="org-rainbow-delimiters-depth-3">()</span> &amp;&amp; <span class="org-negation-char">!</span><span class="org-constant">std</span>::cin.eof<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">){</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; "</span>;
       inv.push_back<span class="org-rainbow-delimiters-depth-3">(</span>readProductFromConsole<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">return</span> inv;
<span class="org-rainbow-delimiters-depth-1">}</span>                                                                          
</pre>
</div>

<ul class="org-ul">
<li>Reading a single object / record:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">User types "2000 Sugar 1.45 9000" and then types RETURN when he is done.</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">------------------------------------------</span>
&gt;&gt; <span class="org-keyword">auto</span> x = readProductFromConsole<span class="org-rainbow-delimiters-depth-1">()</span>
2000 Sugar 1.45 9000
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Product</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f16eb8fc010

&gt;&gt; x.id
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 2000

&gt;&gt; x.name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Sugar"</span>

&gt;&gt; x.price
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 1.4500000

&gt;&gt; x.quantity
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 9000
</pre>
</div>

<ul class="org-ul">
<li>Reading multiple data:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> inventory = readInventory<span class="org-rainbow-delimiters-depth-1">()</span>
Enter <span class="org-type">product</span> <span class="org-variable-name">ID</span>, <span class="org-variable-name">product</span> Name, <span class="org-variable-name">product</span> Price, <span class="org-variable-name">product</span> Quantity.
Type CTRL+D on U-nix <span class="org-keyword">or</span> CTRL+Z on Windows when you are done.
 =&gt; 803 Cooking-oil 10.23 200
 =&gt; 2001 Sugar 2.40 500
 =&gt; 9134 Car-battery 50.0 6000
 =&gt; 8023 Milk 4.50 300 
</pre>
</div>

<ul class="org-ul">
<li>Print inventory value:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-comment-delimiter">// </span><span class="org-comment">Print inventory data: </span>
 <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">prod</span>: inventory<span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-type">double</span> <span class="org-variable-name">value</span> = prod.quantity * prod.price;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Id       = "</span> &lt;&lt; prod.id       &lt;&lt; <span class="org-string">"\n"</span>
               &lt;&lt; <span class="org-string">"Name     = "</span> &lt;&lt; prod.name     &lt;&lt; <span class="org-string">"\n"</span>
               &lt;&lt; <span class="org-string">"Quantity = "</span> &lt;&lt; prod.quantity &lt;&lt; <span class="org-string">"\n"</span>        
               &lt;&lt; <span class="org-string">"Price    = "</span> &lt;&lt; prod.price    &lt;&lt; <span class="org-string">"\n"</span>
               &lt;&lt; <span class="org-string">"Value    = "</span> &lt;&lt; value         &lt;&lt; <span class="org-string">"\n"</span>
               &lt;&lt; <span class="org-string">"----------------------------"</span> &lt;&lt; <span class="org-string">"\n"</span>;
 <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-comment-delimiter">//</span><span class="org-comment">--------- Output -------------</span>
 Id       = 803
 Name     = Cooking-oil
 Quantity = 200
 Price    = 10.23
 Value    = 2046
 ----------------------------
 Id       = 2001
 Name     = Sugar
 Quantity = 500
 Price    = 2.4
 Value    = 1200
 ----------------------------
... ... .... 
</pre>
</div>
</div>
</div>

<div id="outline-container-orga4323bc" class="outline-4">
<h4 id="orga4323bc"><span class="section-number-4">1.7.4</span> Basic IO program</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
<b>Example</b>
</p>

<p>
File: <a href="src/basic-io.cpp">file:src/basic-io.cpp</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span> 
    <span class="org-comment-delimiter">// </span><span class="org-comment">Everything is initialized as zero</span>
    <span class="org-type">double</span> <span class="org-variable-name">price</span>, <span class="org-variable-name">sum</span>, <span class="org-variable-name">min</span>, <span class="org-variable-name">max</span>;
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">dataset</span>;
    sum = 0.0;
    min = 1e10;
    max = -1e10;        

    <span class="org-comment-delimiter">// </span><span class="org-comment">Print float point numbers with 2 decimal places and fixed notation </span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::fixed;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Enter the prices and type CTRL+D you are done."</span> &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Execute this code block while there is any error on the stream.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">It means, the user did not type any bad input or</span>
    <span class="org-comment-delimiter">//  </span><span class="org-comment">CTRL + D (Send EOF End of File - signal)</span>
    <span class="org-type">int</span> <span class="org-variable-name">n</span> = 0;
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cin.good<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">){</span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">(i++) Post increment i, increment variable i after it is print.</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; price["</span> &lt;&lt; n++ &lt;&lt; <span class="org-string">"] = "</span>;
       <span class="org-comment-delimiter">// </span><span class="org-comment">Read the price from stdin (standard input or console). </span>
       <span class="org-constant">std</span>::cin &gt;&gt; price;
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-negation-char">!</span><span class="org-constant">std</span>::cin.good<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span>
          <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [LOG] "</span> &lt;&lt; <span class="org-string">"User typed invalid input. Exit loop."</span> &lt;&lt; <span class="org-string">"\n"</span>;
          <span class="org-comment-delimiter">// </span><span class="org-comment">Force exiting the loop </span>
          <span class="org-keyword">break</span>;
       <span class="org-rainbow-delimiters-depth-3">}</span>
       sum += price;
        dataset.push_back<span class="org-rainbow-delimiters-depth-3">(</span>price<span class="org-rainbow-delimiters-depth-3">)</span>;
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>price &gt; max<span class="org-rainbow-delimiters-depth-3">)</span>
          max = price;
       <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>price &lt; min<span class="org-rainbow-delimiters-depth-3">)</span>
          min = price;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Clear stream error flag </span>
    <span class="org-constant">std</span>::cin.clear<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Sum  = "</span> &lt;&lt; sum       &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Mean = "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span>sum / n<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Min  = "</span> &lt;&lt; min       &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Max  = "</span> &lt;&lt; max       &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Dataset = [ "</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; dataset.size<span class="org-rainbow-delimiters-depth-3">()</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span> &lt;&lt; dataset<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> ;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"] \n"</span>;

<span class="org-preprocessor">    #ifdef</span> _WIN32 
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">"Type RETURN to quit."</span> &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::cin.clear<span class="org-rainbow-delimiters-depth-2">()</span>; 
     <span class="org-constant">std</span>::cin.ignore<span class="org-rainbow-delimiters-depth-2">(</span>10, <span class="org-string">'\n'</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-comment-delimiter">// </span><span class="org-comment">Wait for single character </span>
     <span class="org-constant">std</span>::cin.get<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-preprocessor">    #endif</span>      
    <span class="org-keyword">return</span> EXIT_SUCCESS;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Compiling:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ basic-io.cpp -o <span class="org-keyword">basic-io.bin</span> -g -std=c++1z -Wall -Wextra
<span class="org-comment-delimiter"># </span><span class="org-comment">OR </span>
$ clang++ basic-io.cpp -o <span class="org-keyword">basic-io.bin</span> -g -std=c++1z -Wall -Wextra &amp;&amp; ./basic-io.bin 
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-txt">$ ./basic-io.bin 
Enter the prices and type CTRL+D you are done.
 =&gt; price[0] = 20 
 =&gt; price[1] = 21.35
 =&gt; price[2] = 51.2
 =&gt; price[3] = 40.23
 =&gt; price[4] = 60.243
 =&gt; price[5] = 78
 =&gt; price[6] =  [LOG] User typed invalid input. Exit loop.
Sum  = 271.02
Mean = 38.72
Min  = 20.00
Max  = 78.00
Dataset = [  20.00 21.35 51.20 40.23 60.24 78.00] 

$ echo "30.12 40.23 100.34 90.23 52.0" | ./basic-io.bin 
Enter the prices and type CTRL+D you are done.
 =&gt; price[0] =  =&gt; price[1] =  =&gt; price[2] =  =&gt; price[3] =  =&gt; price[4] =  =&gt; price[5] =  [LOG] User typed invalid input. Exit loop.
Sum  = 312.92
Mean = 52.15
Min  = 30.12
Max  = 100.34
Dataset = [  30.12 40.23 100.34 90.23 52.00] 
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org5bdb301" class="outline-3">
<h3 id="org5bdb301"><span class="section-number-3">1.8</span> <span class="todo TODO">TODO</span> Functions/Procedures</h3>
<div class="outline-text-3" id="text-1-8">
</div>
<div id="outline-container-org19f85d5" class="outline-4">
<h4 id="org19f85d5"><span class="section-number-4">1.8.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
C++ Functions has the following features: 
</p>

<ul class="org-ul">
<li><span class="underline">Overload</span>
<ul class="org-ul">
<li>Unlike in C, in C++, it is possible to define multiple functions
implementation sharing the same name, although with the same type
signature.</li>
</ul></li>

<li><span class="underline">Default Parameters</span>
<ul class="org-ul">
<li>C++ functions can have default parameters.</li>
</ul></li>

<li><span class="underline">C++11 auto syntax</span></li>

<li><span class="underline">C++14 return type deduction</span></li>
</ul>
</div>
</div>
<div id="outline-container-orgee94f32" class="outline-4">
<h4 id="orgee94f32"><span class="section-number-4">1.8.2</span> Simple function with all possible declarations</h4>
<div class="outline-text-4" id="text-1-8-2">
<p>
<b>Example - Simple function =&gt; all possible declaration</b>
</p>

<p>
Simple function which returns anything: 
</p>

<ul class="org-ul">
<li>Alternative syntax 1:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">someFunction</span><span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"I am a C++ free function"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Alternative syntax 2:
<ul class="org-ul">
<li>Note: The early return statement can be used for doing early
return and avoiding many nested if-else statements.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">someFunction</span><span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"I am a C++ free function"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Alternative syntax 3:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">someFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"I am a C++ free function"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-comment-delimiter">// </span><span class="org-comment">return;       </span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Alternative syntax 4 (C++11):</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-function-name">someFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"I am a C++ free function"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span>;       
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Alternative syntax 5 (C++14) - uses type deduction (aka type
inference) for return type.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-function-name">someFunction</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"I am a C++ free function"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span>;       
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org35e6ff4" class="outline-4">
<h4 id="org35e6ff4"><span class="section-number-4">1.8.3</span> Functions with default parameters</h4>
<div class="outline-text-4" id="text-1-8-3">
<ul class="org-ul">
<li>Syntax 1:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-type">double</span> <span class="org-function-name">someFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span> = 4, <span class="org-type">double</span> <span class="org-variable-name">z</span> = 3.5 <span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  x = "</span>  &lt;&lt; x
              &lt;&lt; <span class="org-string">" ; n = "</span> &lt;&lt; n
              &lt;&lt; <span class="org-string">" ; z = "</span> &lt;&lt; z
              &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-keyword">return</span> x * n + 4.0 * z;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">OR: </span>
<span class="org-type">double</span> 
<span class="org-function-name">someFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span> = 4, <span class="org-type">double</span> <span class="org-variable-name">z</span> = 3.5 <span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  x = "</span>  &lt;&lt; x
              &lt;&lt; <span class="org-string">" ; n = "</span> &lt;&lt; n
              &lt;&lt; <span class="org-string">" ; z = "</span> &lt;&lt; z
              &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-keyword">return</span> x * n + 4.0 * z;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Testing: Cling REPL:</span>

&gt;&gt; someFunction<span class="org-rainbow-delimiters-depth-1">(</span>3.0<span class="org-rainbow-delimiters-depth-1">)</span>
  x = 3 ; n = 4 ; z = 3.5
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 26.000000
&gt;&gt; 
&gt;&gt; someFunction<span class="org-rainbow-delimiters-depth-1">(</span>3.0, 10, 5<span class="org-rainbow-delimiters-depth-1">)</span>
  x = 3 ; n = 10 ; z = 5
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 50.000000
&gt;&gt; 
&gt;&gt; someFunction<span class="org-rainbow-delimiters-depth-1">(</span>4.0<span class="org-rainbow-delimiters-depth-1">)</span>
  x = 4 ; n = 4 ; z = 3.5
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 30.000000
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Syntax 2 (C++11). In C++14, the return type can be omitted.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-function-name">someFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span> = 4, <span class="org-type">double</span> <span class="org-variable-name">z</span> = 3.5<span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">double</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  x = "</span>  &lt;&lt; x
              &lt;&lt; <span class="org-string">" ; n = "</span> &lt;&lt; n
              &lt;&lt; <span class="org-string">" ; z = "</span> &lt;&lt; z
              &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-keyword">return</span> x * n + 4.0 * z;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; someFunction<span class="org-rainbow-delimiters-depth-1">(</span>3.0<span class="org-rainbow-delimiters-depth-1">)</span>
  x = 3 ; n = 4 ; z = 3.5
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 26.000000

&gt;&gt; someFunction<span class="org-rainbow-delimiters-depth-1">(</span>4.0<span class="org-rainbow-delimiters-depth-1">)</span>
  x = 4 ; n = 4 ; z = 3.5
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 30.000000

&gt;&gt; someFunction<span class="org-rainbow-delimiters-depth-1">(</span>4.0, 10, 5<span class="org-rainbow-delimiters-depth-1">)</span>
  x = 4 ; n = 10 ; z = 5
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 60.000000
&gt;&gt; 

</pre>
</div>
</div>
</div>
<div id="outline-container-org109c752" class="outline-4">
<h4 id="org109c752"><span class="section-number-4">1.8.4</span> Function overload</h4>
<div class="outline-text-4" id="text-1-8-4">
<p>
Functions can be overloaded as long as they have unique type signature
and the same return type.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-1">(){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Call Version0."</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Call Version1 with =&gt;"</span> &lt;&lt; <span class="org-string">" x [int] = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Call Version2 with =&gt;"</span> &lt;&lt; <span class="org-string">" x [double] = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">str</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Call Version2 with =&gt;"</span> &lt;&lt; <span class="org-string">" x [const char*] = "</span> &lt;&lt; str &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">z</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Call Version4 with =&gt;"</span>
               &lt;&lt; <span class="org-string">" x [int] = "</span> &lt;&lt; x
               &lt;&lt; <span class="org-string">" z [double] = "</span> &lt;&lt; z
               &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">z</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">str</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Call Version5 with =&gt;"</span>
               &lt;&lt; <span class="org-string">" x [int] = "</span> &lt;&lt; x
               &lt;&lt; <span class="org-string">" z [double] = "</span> &lt;&lt; z
               &lt;&lt; <span class="org-string">" std [const char*] = "</span> &lt;&lt; str
               &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .L script.C

&gt;&gt; show<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Call</span> <span class="org-variable-name">Version0</span>.

&gt;&gt; show<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Call</span> <span class="org-type">Version1</span> <span class="org-variable-name">with</span> =&gt; x <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">]</span> = 10

&gt;&gt; show<span class="org-rainbow-delimiters-depth-1">(</span>3.1415<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Call</span> <span class="org-type">Version2</span> <span class="org-variable-name">with</span> =&gt; x <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">]</span> = 3.1415

&gt;&gt; show<span class="org-rainbow-delimiters-depth-1">(</span>100, 3.1415<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Call</span> <span class="org-type">Version4</span> <span class="org-variable-name">with</span> =&gt; x <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">]</span> = 100 z <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">]</span> = 3.1415

&gt;&gt; show<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Function overload"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Call</span> <span class="org-type">Version2</span> <span class="org-variable-name">with</span> =&gt; x <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-1">]</span> = Function overload

&gt;&gt; show<span class="org-rainbow-delimiters-depth-1">(</span>100, 3.1415, <span class="org-string">"overload"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Call</span> <span class="org-type">Version5</span> <span class="org-variable-name">with</span> =&gt; x <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">]</span> = 100 z <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">]</span> = 3.1415 std <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-1">]</span> = overload
&gt;&gt; 

</pre>
</div>
</div>
</div>
<div id="outline-container-org5717db9" class="outline-4">
<h4 id="org5717db9"><span class="section-number-4">1.8.5</span> Functions with static variables - stateful functions</h4>
<div class="outline-text-4" id="text-1-8-5">
<p>
Variables inside of functions annotated with "static" keyword are
similar to global variables (global static variables), they are
initialized after the first function invocation and keeps their state
during successive function invocations. 
</p>

<p>
Features: 
</p>
<ul class="org-ul">
<li>Initialized until first function invocation.</li>
<li>Lifetime: Entire program runtime, just like global variables, they
are destroyed when the program execution ends.</li>
<li>Once initialized, keeps their state during function calls.</li>
<li>Stored in the program's and process' data segment.</li>
</ul>

<p>
Use cases: 
</p>
<ul class="org-ul">
<li>Lazy-initialization in singleton design-patterns.</li>
<li>Create stateful functions.</li>
<li>Solve the static initialization order fiasco
<ul class="org-ul">
<li>See:</li>
<li><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/static-init-order-on-first-use.html">How do I prevent the "static initialization order fiasco"?, C++ FAQ</a></li>
<li><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/construct-on-first-use-v2.html">Why doesn't the construct-on-first-use idiom use a static object instead of a static pointer?, C++ FAQ</a></li>
</ul></li>
</ul>

<p>
Example: 
</p>

<ul class="org-ul">
<li>Counter function with automatic variable (stack-allocated).</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">counterAuto</span><span class="org-rainbow-delimiters-depth-1">(){</span>
   <span class="org-type">int</span> <span class="org-variable-name">x</span> = 0;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"counter = "</span> &lt;&lt; x++ &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; counterAuto<span class="org-rainbow-delimiters-depth-1">()</span>
counter = 0
&gt;&gt; counterAuto<span class="org-rainbow-delimiters-depth-1">()</span>
counter = 0
&gt;&gt; counterAuto<span class="org-rainbow-delimiters-depth-1">()</span>
counter = 0
&gt;&gt; counterAuto<span class="org-rainbow-delimiters-depth-1">()</span>
counter = 0
</pre>
</div>

<ul class="org-ul">
<li>counter function with static variable.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">counterStatic</span><span class="org-rainbow-delimiters-depth-1">(){</span>
   <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">x</span> = 0;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"counter = "</span> &lt;&lt; x++ &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; counterStatic<span class="org-rainbow-delimiters-depth-1">()</span>
counter = 0
&gt;&gt; counterStatic<span class="org-rainbow-delimiters-depth-1">()</span>
counter = 1
&gt;&gt; counterStatic<span class="org-rainbow-delimiters-depth-1">()</span>
counter = 2
&gt;&gt; counterStatic<span class="org-rainbow-delimiters-depth-1">()</span>
counter = 3
&gt;&gt; counterStatic<span class="org-rainbow-delimiters-depth-1">()</span>
counter = 4
&gt;&gt; 
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org808462e" class="outline-3">
<h3 id="org808462e"><span class="section-number-3">1.9</span> String Manipulation</h3>
<div class="outline-text-3" id="text-1-9">
</div>
<div id="outline-container-org46c3d26" class="outline-4">
<h4 id="org46c3d26"><span class="section-number-4">1.9.1</span> Class std::string</h4>
<div class="outline-text-4" id="text-1-9-1">
<p>
In C++, it is better to use std::string than the old "C-string" 
(const char*) since the class std::string is easier and safer to use
than the old C-string class. In addition, std::string can grow or
shrink at runtime automatically taking care of memory allocation.
</p>

<p>
Header: 
</p>
<ul class="org-ul">
<li>&lt;string&gt;</li>
</ul>

<p>
Documentation: 
</p>
<ul class="org-ul">
<li><a href="http://www.cplusplus.com/reference/string/">&lt;string&gt; - C++ Reference</a></li>
<li><a href="http://www.cplusplus.com/reference/string/string/">string - C++ Reference</a></li>
<li><a href="http://www.cplusplus.com/reference/string/wstring/">wstring - C++ Reference</a></li>
</ul>

<p>
Intialization: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Create an empty string </span>
&gt;&gt; <span class="org-constant">std</span>::string s1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">""</span>
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::string s2<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"I am a C++ std::string"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"I am a C++ std::string"</span>
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::string s3 = <span class="org-string">"C++ CPP 20 is coming soon!!"</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"C++ CPP 20 is coming soon!!"</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* msg = <span class="org-string">"C++ strings"</span>;
&gt;&gt; <span class="org-constant">std</span>::string s4 <span class="org-rainbow-delimiters-depth-1">{</span>msg<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"C++ strings"</span>
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::string s5<span class="org-rainbow-delimiters-depth-1">(</span>10, <span class="org-string">'-'</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"----------"</span>
&gt;&gt;
</pre>
</div>

<p>
String size: 
</p>

<p>
&#x2013; <a href="http://www.cplusplus.com/reference/string/string/size/">string::size - C++ Reference</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string sx = <span class="org-string">"high performance computing - finite element methods"</span>;

&gt;&gt; sx.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 51

&gt;&gt; sx.length<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 51
&gt;&gt; 
</pre>
</div>

<p>
String concatenation: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string s;
&gt;&gt; s
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">""</span>

&gt;&gt; s = s + <span class="org-string">" string "</span> + <span class="org-string">" C++ "</span> + <span class="org-string">" Move "</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">__cxx11</span>::<span class="org-type">basic_string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">" string  C++  Move "</span>

&gt;&gt; s
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">" string  C++  Move "</span>
&gt;&gt; s += <span class="org-string">" C "</span> + <span class="org-string">" Assembly "</span> + <span class="org-string">" HEX "</span>

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"s = '"</span> &lt;&lt; s &lt;&lt; <span class="org-string">"'"</span> &lt;&lt; <span class="org-string">"\n"</span>;
s = <span class="org-warning">'</span> string  C++  Move  C <span class="org-warning">'</span>
&gt;&gt; 
</pre>
</div>

<p>
String concatenation with append: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string s;
&gt;&gt; s
<span class="org-string">""</span>
&gt;&gt; s.append<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"hello"</span>
&gt;&gt; s.append<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" c++ "</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"hello c++ "</span>
&gt;&gt; s.append<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" std::string "</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"hello c++  std::string "</span>
&gt;&gt; s
<span class="org-string">"hello c++  std::string "</span>
&gt;&gt; 
</pre>
</div>

<p>
Clear string: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string ss1 = <span class="org-string">"I am some string"</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"I am some string"</span>

&gt;&gt; ss1.clear<span class="org-rainbow-delimiters-depth-1">()</span>

&gt;&gt; ss1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">""</span>

&gt;&gt; ss1.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; 
</pre>
</div>

<p>
Substring: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string str = <span class="org-string">"Early computers were designed for number crunching."</span>;

&gt;&gt; str.substr<span class="org-rainbow-delimiters-depth-1">(</span>0, 10<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"Early comp"</span>

&gt;&gt; str.substr<span class="org-rainbow-delimiters-depth-1">(</span>0, 15<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"Early computers"</span>

&gt;&gt; str.substr<span class="org-rainbow-delimiters-depth-1">(</span>20, str.length<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">" designed for number crunching."</span>
</pre>
</div>

<p>
String comparison: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string pass;
&gt;&gt; pass
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">""</span>
&gt;&gt;
&gt;&gt; pass == <span class="org-string">"access"</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; pass = <span class="org-string">"access"</span>
<span class="org-string">"access"</span>
&gt;&gt; pass == <span class="org-string">"access"</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span><span class="org-rainbow-delimiters-depth-1">)</span> == <span class="org-string">"world"</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span><span class="org-rainbow-delimiters-depth-1">)</span> == <span class="org-string">"hello"</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt;  

<span class="org-type">void</span> checkPassword<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">passwd</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>passwd == <span class="org-string">"87afx"</span><span class="org-rainbow-delimiters-depth-2">)</span>
           <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Access granted. OK."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">else</span>
           <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Access denied. FAILURE."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; checkPassword<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"aa"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Access</span> <span class="org-variable-name">denied</span>. FAILURE.
&gt;&gt; checkPassword<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Access</span> <span class="org-variable-name">denied</span>. FAILURE.
&gt;&gt; checkPassword<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"87afx"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Access</span> <span class="org-variable-name">granted</span>. OK.
&gt;&gt; 
</pre>
</div>

<p>
Reverse string: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string ssa = <span class="org-string">"hello world string"</span>;
&gt;&gt; ssa
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"hello world string"</span>

&gt;&gt; <span class="org-constant">std</span>::reverse<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::begin<span class="org-rainbow-delimiters-depth-2">(</span>ssa<span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-constant">std</span>::end<span class="org-rainbow-delimiters-depth-2">(</span>ssa<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; ssa
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"gnirts dlrow olleh"</span>

&gt;&gt; <span class="org-constant">std</span>::reverse<span class="org-rainbow-delimiters-depth-1">(</span>ssa.begin<span class="org-rainbow-delimiters-depth-2">()</span>, ssa.end<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; ssa
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"hello world string"</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-org040f949" class="outline-4">
<h4 id="org040f949"><span class="section-number-4">1.9.2</span> Concatenate string literals</h4>
<div class="outline-text-4" id="text-1-9-2">
<p>
Example: concatenate string literas and pass the to the function
perror of signature:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-constant">std</span>::<span class="org-function-name">perror</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Trial:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">s1</span> = <span class="org-string">" world "</span>;
<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">s2</span> = <span class="org-string">" C++ "</span>;
<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">s3</span> = <span class="org-string">" strings "</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Compilation error:</span>
&gt;&gt; <span class="org-constant">std</span>::perror<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-string">" literal1 "</span> + <span class="org-string">"literal 2"</span> + s1 + s2 + s3<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">ROOT_prompt_4</span>:1:27: error: invalid operands to binary expression <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">'</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-warning">'</span> <span class="org-keyword">and</span> <span class="org-warning">'</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">std</span>::perror<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-string">" literal1 "</span> + <span class="org-string">"literal 2"</span> + s1 + s2 + s3<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Solution: Wrap the first argument into an std::string. The method
.data() from the std::string class returns a pointer of type (const
char*) or a C-null terminated character array.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string text = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" literal1 "</span><span class="org-rainbow-delimiters-depth-1">)</span> + <span class="org-string">"literal 2"</span> + s1 + s2 + s3;
&gt;&gt; text
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">" literal1 literal 2 world  C++  strings "</span>
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::perror<span class="org-rainbow-delimiters-depth-1">(</span>text.data<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-type">literal1</span> <span class="org-variable-name">literal</span> 2 world  C++  strings : No such file <span class="org-keyword">or</span> directory
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org055b819" class="outline-4">
<h4 id="org055b819"><span class="section-number-4">1.9.3</span> C++14 String literals and C++11 Raw string literals</h4>
<div class="outline-text-4" id="text-1-9-3">
<p>
<b>C++14 String literals</b> 
</p>

<p>
In C++, it is not possible to concatenate or compare string literals
directly using only operators without any function such as
strcmp. Example CLING REPL:
</p>

<p>
Documentation: <a href="https://en.cppreference.com/w/cpp/string/basic_string/operator%22%22s">operator""s - cppreference.com</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ ~/opt/cling_2018-09-16_fedora27/bin/cling -std=c++17

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ <span class="org-constant">std</span>::string s = <span class="org-string">"concatenate "</span> + <span class="org-string">"string"</span>
<span class="org-function-name">input_line_8</span>:2:33: error: invalid operands to binary expression <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">'</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-warning">'</span> <span class="org-keyword">and</span> <span class="org-warning">'</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">s</span> = <span class="org-string">"concatenate "</span> + <span class="org-string">"string"</span>
                 ~~~~~~~~~~~~~~ ^ ~~~~~~~~
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">cling</span><span class="org-rainbow-delimiters-depth-1">]</span>$ 

<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ <span class="org-string">"hello"</span> == <span class="org-string">"hello"</span>
<span class="org-function-name">input_line_15</span>:2:10: warning: result of comparison against a string literal is unspecified
      <span class="org-rainbow-delimiters-depth-1">(</span>use <span class="org-type">strncmp</span> <span class="org-variable-name">instead</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>-Wstring-compare<span class="org-rainbow-delimiters-depth-1">]</span>
 <span class="org-string">"hello"</span> == <span class="org-string">"hello"</span>
 ~~~~~~~ ^
</pre>
</div>

<p>
C++14 provides string literal suffix operator (s) which can simplify
string concatenation and comparison: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ ~/opt/cling_2018-09-16_fedora27/bin/cling -std=c++17
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">string_literals</span>;

<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">cling</span><span class="org-rainbow-delimiters-depth-1">]</span>$ <span class="org-keyword">auto</span> a_std_string = <span class="org-string">"this is an std::string object"</span>s
<span class="org-string">"this is an std::string object"</span>

<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span>a_std_string<span class="org-rainbow-delimiters-depth-1">)</span> == <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Instead of: </span>
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ s = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"concatenate "</span><span class="org-rainbow-delimiters-depth-1">)</span> + <span class="org-string">"string"</span>
<span class="org-string">"concatenate string"</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">The string literal operator (s) makes this code shorter:</span>
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ <span class="org-keyword">auto</span> s2 = <span class="org-string">"concatenate "</span>s + <span class="org-string">"string"</span>
<span class="org-string">"concatenate string"</span>
</pre>
</div>

<p>
String literal comparison can be peformed in two ways, one is using
the function strcmp and other one is by wrapping the first literal
with the constructor std::string(const char*). The last form of
comparison can be simplified using the suffix operator (s):
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstring</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">str1</span> = <span class="org-string">"c++ ASM"</span>;
<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">str2</span> = <span class="org-string">"Fortran"</span>;

<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">cling</span><span class="org-rainbow-delimiters-depth-1">]</span>$ <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"c++ ASM"</span><span class="org-rainbow-delimiters-depth-1">)</span> == str1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>

<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"c++ ASM"</span><span class="org-rainbow-delimiters-depth-1">)</span> == str2
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">=== Shorter alternative ===========//</span>
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ <span class="org-string">"c++ ASM"</span>s == str1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ <span class="org-string">"c++ ASM"</span>s == str2
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ 
</pre>
</div>

<p>
<b>C++11 Raw string literals</b>
</p>

<p>
Raw string literals allows writing multi line strings, regular
expressions (regex) without boilerplate and not escaped strings with
backward slashes such as Windows paths.
</p>

<p>
Form: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">R<span class="org-default">"</span><span class="org-string">(&lt;some string ...&gt;)</span><span class="org-default">"</span>
</pre>
</div>

<p>
Example: 
</p>

<ul class="org-ul">
<li>file: string-literal.cpp</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;
       <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-constant">std</span>::boolalpha;

       <span class="org-comment-delimiter">// </span><span class="org-comment">Raw string literals does not need escaping. </span>
       <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">raw1</span> = R<span class="org-default">"</span><span class="org-string">(C:\Users\nobody\tests\path)</span><span class="org-default">"</span>;  

       <span class="org-keyword">auto</span> <span class="org-variable-name">raw2</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span>R<span class="org-default">"</span><span class="org-string">(C:\Users\nobody\tests\path)</span><span class="org-default">"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

       <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">raw3</span> = R<span class="org-default">"</span><span class="org-string">(</span>
<span class="org-string">  This is a multiline </span>
<span class="org-string">  string</span>
<span class="org-string">  path = C:\Users\somebody\else\docs</span>
<span class="org-string">\n  New line char - LF (Line Feed - LF)   </span>
<span class="org-string">\r  New line char - CR (Carriage Return)</span>
<span class="org-string">\t  Tab char</span>
<span class="org-string">\b  Backspace character </span>
<span class="org-string">       )</span><span class="org-default">"</span>;
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"raw 1 = "</span> &lt;&lt; raw1 &lt;&lt; <span class="org-constant">std</span>::endl;        
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"raw 2 = "</span>  &lt;&lt; raw2 &lt;&lt; <span class="org-constant">std</span>::endl;
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"raw 3 = "</span> &lt;&lt; raw3 &lt;&lt; <span class="org-constant">std</span>::endl;
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"typeid(raw2) == typeid(std::string) ? "</span>
                         &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-3">(</span>raw2<span class="org-rainbow-delimiters-depth-3">)</span> == <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
                         &lt;&lt; <span class="org-constant">std</span>::endl;

       <span class="org-keyword">return</span> EXIT_SUCCESS;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ -std=c++1z -g -Wall -Wextra cpp14-string-literals.cpp -o <span class="org-keyword">cpp14-string-literals.bin</span> 
$ ./cpp14-string-literals.bin

raw 1 = C:\Users\nobody\tests\path
raw 2 = C:\Users\nobody\tests\path
raw 3 = 
   This is a multiline 
   string
   path = C:\Users\somebody\else\docs
 \n  New line char - LF (Line Feed - LF)   
 \r  New line char - CR (Carriage Return)
 \t  Tab char
 \b  Backspace character 

<span class="org-function-name">typeid</span>(raw2) == typeid(std::string) ? true

</pre>
</div>

<p>
Without the raw string literal operator the Windows path raw1 would
have to be written in following way. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::string raw1 = <span class="org-string">"C:\\Users\\nobody\\tests\\path"</span>;    
</pre>
</div>
</div>
</div>

<div id="outline-container-org662e94e" class="outline-4">
<h4 id="org662e94e"><span class="section-number-4">1.9.4</span> Numerical Parsers Functions (C++11)</h4>
<div class="outline-text-4" id="text-1-9-4">
<p>
Header: &lt;string&gt; 
</p>

<p>
Documentation: 
</p>
<ul class="org-ul">
<li><a href="http://www.cplusplus.com/reference/string/">&lt;string&gt; - C++ Reference</a></li>
</ul>

<p>
Functions: 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Functions</th>
<th scope="col" class="org-left">Convert to:</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">stoi</td>
<td class="org-left">string to integer</td>
</tr>

<tr>
<td class="org-left">stol</td>
<td class="org-left">Convert string to long int</td>
</tr>

<tr>
<td class="org-left">stoul</td>
<td class="org-left">Convert string to unsigned integer</td>
</tr>

<tr>
<td class="org-left">stoll</td>
<td class="org-left">string to long long</td>
</tr>

<tr>
<td class="org-left">stoull</td>
<td class="org-left">unsigned long long</td>
</tr>

<tr>
<td class="org-left">stof</td>
<td class="org-left">Convert string to float</td>
</tr>

<tr>
<td class="org-left">stod</td>
<td class="org-left">Convert string to double</td>
</tr>

<tr>
<td class="org-left">stold</td>
<td class="org-left">Convert string to long double</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><b>std::stoi</b>
<ul class="org-ul">
<li>Convert a string to integer and throws an exception, if the
operation is not successful.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string s = <span class="org-string">"200"</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"200"</span>

&gt;&gt; <span class="org-constant">std</span>::stoi<span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 200
&gt;&gt; s = <span class="org-string">"-400"</span>
<span class="org-string">"-400"</span>

&gt;&gt; s = <span class="org-string">"-400"</span>;
&gt;&gt; <span class="org-constant">std</span>::stoi<span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> -400

<span class="org-comment-delimiter">// </span><span class="org-comment">Throws exception </span>
&gt;&gt; s = <span class="org-string">"aaabb -400"</span>;
&gt;&gt; <span class="org-constant">std</span>::stoi<span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Error</span> <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: <span class="org-constant">std</span>::invalid_argument caught: stoi
&gt;&gt; 

<span class="org-comment-delimiter">//  </span><span class="org-comment">Read hexadecimal number </span>
&gt;&gt; s = <span class="org-string">"0xFFAB"</span>;
&gt;&gt; <span class="org-constant">std</span>::stoi<span class="org-rainbow-delimiters-depth-1">(</span>s, <span class="org-constant">nullptr</span>, 16<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 65451
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::stoi<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0xFF"</span>, <span class="org-constant">nullptr</span>, 16<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 255
&gt;&gt; <span class="org-constant">std</span>::stoi<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0xFFFF"</span>, <span class="org-constant">nullptr</span>, 16<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 65535
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li><b>std::stod</b>
<ul class="org-ul">
<li>Convert a string to double. (double precision float point from  IEEE754)</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string s = <span class="org-string">"21.4e3"</span>;
&gt;&gt; <span class="org-constant">std</span>::stod<span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 21400.000

&gt;&gt; s = <span class="org-string">"  .4e-6"</span>;
&gt;&gt; <span class="org-constant">std</span>::stod<span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 4.0000000e-07
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Throw exception and terminates program, if the exception is not caught.</span>
&gt;&gt; s = <span class="org-string">"failure case  .4e-6"</span>;
&gt;&gt; <span class="org-constant">std</span>::stod<span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Error</span> <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: <span class="org-constant">std</span>::invalid_argument caught: stod
&gt;&gt; 

&gt;&gt; s = <span class="org-string">"NAN"</span>;
&gt;&gt; <span class="org-constant">std</span>::stod<span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> nan
&gt;&gt; s = <span class="org-string">"INFINITY"</span>;
&gt;&gt; <span class="org-constant">std</span>::stod<span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> inf
&gt;&gt; s = <span class="org-string">"-INFINITY"</span>;
&gt;&gt; <span class="org-constant">std</span>::stod<span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -inf
&gt;&gt; 
&gt;&gt; s = <span class="org-string">"3.1415"</span>;
&gt;&gt; <span class="org-constant">std</span>::stod<span class="org-rainbow-delimiters-depth-1">(</span>s<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 3.1415000
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::stod<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"1.23e3"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 1230.0000
&gt;&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-org7c44faf" class="outline-4">
<h4 id="org7c44faf"><span class="section-number-4">1.9.5</span> Function to_string (C++11)</h4>
<div class="outline-text-4" id="text-1-9-5">
<p>
Note: This function is useful for concatenating numbers and string.
</p>

<p>
Documentation: 
</p>

<ul class="org-ul">
<li><a href="http://www.cplusplus.com/reference/string/to_string/">to_string - C++ Reference</a></li>
</ul>

<p>
Overloads: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">tring</span> <span class="org-function-name">to_string</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">val</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">string</span> <span class="org-function-name">to_string</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">long</span> <span class="org-variable-name">val</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">string</span> <span class="org-function-name">to_string</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">long</span> <span class="org-type">long</span> <span class="org-variable-name">val</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">string</span> <span class="org-function-name">to_string</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-variable-name">val</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">string</span> <span class="org-function-name">to_string</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">val</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">string</span> <span class="org-function-name">to_string</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span> <span class="org-variable-name">val</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">string</span> <span class="org-function-name">to_string</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">float</span> <span class="org-variable-name">val</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">string</span> <span class="org-function-name">to_string</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">val</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">string</span> <span class="org-function-name">to_string</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">long</span> <span class="org-type">double</span> <span class="org-variable-name">val</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string s;
&gt;&gt; 
&gt;&gt; <span class="org-type">double</span> x = 3.1415;

&gt;&gt; s = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"The value of x = "</span><span class="org-rainbow-delimiters-depth-1">)</span> + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-1">(</span>x<span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-string">"The value of x = 3.141500"</span>
&gt;&gt; 

&gt;&gt; s.clear<span class="org-rainbow-delimiters-depth-1">()</span>
&gt;&gt; <span class="org-type">int</span> n = 100;
&gt;&gt; s = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"The value of n (integer) = "</span><span class="org-rainbow-delimiters-depth-1">)</span> + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-1">(</span>n<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"The value of n (integer) = 100"</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org963ec1a" class="outline-4">
<h4 id="org963ec1a"><span class="section-number-4">1.9.6</span> Printing to string with std::stringstream</h4>
<div class="outline-text-4" id="text-1-9-6">
<p>
Header:  <a href="http://www.cplusplus.com/reference/sstream/">&lt;sstream&gt;</a>
</p>

<p>
Other useful headers: 
</p>
<ul class="org-ul">
<li><a href="http://www.cplusplus.com/reference/iomanip/">&lt;iomanip&gt;</a> - Stream manipulators, std::setw, std::setprecision and so on.</li>
<li><a href="http://www.cplusplus.com/reference/ostream/">&lt;ostream&gt;</a> - Class std::ostream, generic output.</li>
</ul>

<p>
Documentation: 
</p>
<ul class="org-ul">
<li><a href="http://www.cplusplus.com/reference/sstream/">&lt;sstream&gt; - C++ Reference</a></li>
<li><a href="http://www.cplusplus.com/reference/sstream/stringstream/">stringstream - C++ Reference</a></li>
</ul>

<p>
The class std::stringstream is a better option for concatenating
strings or printing to string. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

&gt;&gt; <span class="org-constant">std</span>::stringstream ss;
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::stringstream ss;
&gt;&gt; ss &lt;&lt; <span class="org-string">"Hello world"</span> &lt;&lt; <span class="org-string">"\n"</span>;
&gt;&gt; ss &lt;&lt; <span class="org-string">"PI = "</span> &lt;&lt; M_PI &lt;&lt; <span class="org-string">"\n"</span>;
&gt;&gt; ss &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-1">(</span>3<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"g = "</span> &lt;&lt; 9.81723 &lt;&lt; <span class="org-string">"\n"</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Get std::string from ss</span>
&gt;&gt; ss.str<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-string">"Hello world</span>
<span class="org-string">PI = 3.14159</span>
<span class="org-string">g = 9.817</span>
<span class="org-string">"</span>
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::string s_copy = ss.str<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-warning">"</span><span class="org-string">Hello world</span>
<span class="org-string">PI = 3.14159</span>
<span class="org-string">g = 9.817</span>
<span class="org-string">"</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Clear string stream </span>
&gt;&gt; ss.str<span class="org-rainbow-delimiters-depth-1">()</span>; ss.str<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>;
&gt;&gt; ss.str<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-string">""</span>
&gt;&gt; 
</pre>
</div>

<p>
 <b>Example:</b> Polymorphic function which can print to stdout (cout), stderr
(cerr) or to string.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">printReport</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-1">){</span>
  os &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
  os &lt;&lt; <span class="org-constant">std</span>::fixed;
  os &lt;&lt; <span class="org-constant">std</span>::boolalpha;
  <span class="org-type">char</span> <span class="org-variable-name">nl</span> = <span class="org-string">'\n'</span>;
  os &lt;&lt; <span class="org-string">"Report Data"</span> &lt;&lt; nl
     &lt;&lt; <span class="org-string">" x = "</span> &lt;&lt; 23.123 &lt;&lt; nl
     &lt;&lt; <span class="org-string">" d = "</span> &lt;&lt; <span class="org-constant">true</span>   &lt;&lt; nl
     &lt;&lt; <span class="org-string">" z = "</span> &lt;&lt; M_PI   &lt;&lt; nl;
  os.flush<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Print to stdout and stderr: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Print to stdout (Standard output)</span>
&gt;&gt; printReport<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cout<span class="org-rainbow-delimiters-depth-1">)</span>
Report <span class="org-type">Data</span>
 <span class="org-variable-name">x</span> = 23.123
 d = <span class="org-constant">true</span>
 z = 3.142

<span class="org-comment-delimiter">// </span><span class="org-comment">Print to stderr (Standard error output)</span>
&gt;&gt; printReport<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cerr<span class="org-rainbow-delimiters-depth-1">)</span>
Report <span class="org-type">Data</span>
 <span class="org-variable-name">x</span> = 23.123
 d = <span class="org-constant">true</span>
 z = 3.142
&gt;&gt; 
</pre>
</div>

<p>
Print to string stream: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Print to string stream </span>
&gt;&gt; <span class="org-constant">std</span>::stringstream ss;
&gt;&gt; printReport<span class="org-rainbow-delimiters-depth-1">(</span>ss<span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; ss.str<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-warning">"</span><span class="org-string">Report Data</span>
<span class="org-string"> x = 23.123</span>
<span class="org-string"> d = true</span>
<span class="org-string"> z = 3.142</span>
<span class="org-string">"</span>

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; ss.str<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-string">'\n'</span>;
Report <span class="org-type">Data</span>
 <span class="org-variable-name">x</span> = 23.123
 d = <span class="org-constant">true</span>
 z = 3.142

&gt;&gt; printReport<span class="org-rainbow-delimiters-depth-1">(</span>ss<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; ss.str<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-string">'\n'</span>;
Report <span class="org-type">Data</span>
 <span class="org-variable-name">x</span> = 23.123
 d = <span class="org-constant">true</span>
 z = 3.142
Report Data
 x = 23.123
 d = <span class="org-constant">true</span>
 z = 3.142
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc850375" class="outline-4">
<h4 id="orgc850375"><span class="section-number-4">1.9.7</span> <span class="todo TODO">TODO</span> Parsing strings with std::stringstream</h4>
<div class="outline-text-4" id="text-1-9-7">
<p>
Header: &lt;sstream&gt;
</p>

<p>
Documentation: 
</p>
<ul class="org-ul">
<li><a href="http://www.cplusplus.com/reference/sstream/">&lt;sstream&gt; - C++ Reference</a></li>
<li><a href="http://www.cplusplus.com/reference/sstream/stringstream/">stringstream - C++ Reference</a></li>
</ul>

<p>
<b>Example 1:</b> Parse integers from string. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-function-name">std</span>::string data = <span class="org-string">" 200 400  50.232 100 200 440"</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">ss</span> = <span class="org-constant">std</span>::stringstream<span class="org-rainbow-delimiters-depth-1">{</span>data<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">double</span> <span class="org-variable-name">x</span>;

<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0;
<span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-negation-char">!</span>ss.eof<span class="org-rainbow-delimiters-depth-2">()</span> &amp;&amp; <span class="org-negation-char">!</span>ss.fail<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">){</span>
   ss &gt;&gt; x;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"x["</span> &lt;&lt; i &lt;&lt; <span class="org-string">"] = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
   i++;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">x[0] = 200
x[1] = 400
x[2] = 50.232
x[3] = 100
x[4] = 200
x[5] = 440
</pre>
</div>

<p>
<b>Example 2:</b> Extract all unique words from a given line: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-function-name">std</span>::string line;
line =  <span class="org-string">"hex binary data always key hard narrow path bug hex"</span>;
line += <span class="org-string">" binary data path words key"</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">words</span> = <span class="org-constant">std</span>::<span class="org-type">set</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;{}</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">ss</span> = <span class="org-constant">std</span>::stringstream<span class="org-rainbow-delimiters-depth-1">{</span>line<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-function-name">std</span>::string w;
<span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-negation-char">!</span>ss.eof<span class="org-rainbow-delimiters-depth-2">()</span> &amp;&amp; ss.good<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">){</span>
  ss &gt;&gt; w;
  words.insert<span class="org-rainbow-delimiters-depth-2">(</span>w<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; line
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"hex binary data ... binary data path words key"</span>
&gt;&gt; 

&gt;&gt; words
<span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"always"</span>, <span class="org-string">"binary"</span>, <span class="org-string">"bug"</span>, <span class="org-string">"data"</span>, <span class="org-string">"hard"</span>, <span class="org-string">"hex"</span>, <span class="org-string">"key"</span>, <span class="org-string">"narrow"</span>, <span class="org-string">"path"</span>, <span class="org-string">"words"</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">w</span>: words<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; w &lt;&lt; <span class="org-string">"\n"</span>;<span class="org-rainbow-delimiters-depth-1">}</span>
always
binary
bug
data
hard
hex
key
narrow
<span class="org-type">path</span>
<span class="org-variable-name">words</span>
&gt;&gt; 
</pre>
</div>

<p>
<b>Example 3:</b> Extract lines from string. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::string text;
text += <span class="org-string">"C++ =&gt; FEM -&gt; Finite Element Methods\n"</span>;
text += <span class="org-string">"C++ =&gt; High Performance Computing\n"</span>;
text += <span class="org-string">"C++ =&gt; Monte Carlo Simulations\n"</span>;

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; text &lt;&lt; <span class="org-string">"\n"</span>;
C++ =&gt; FEM -&gt; Finite Element Methods
C++ =&gt; High Performance Computing
C++ =&gt; Monte Carlo Simulations

<span class="org-function-name">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> lines;
<span class="org-function-name">std</span>::string line;
<span class="org-comment-delimiter">// </span><span class="org-comment">Input Stream                                                                </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">is</span> = <span class="org-constant">std</span>::stringstream <span class="org-rainbow-delimiters-depth-1">{</span>text<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-2">(</span>is, line<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> lines.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span>line<span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; lines
<span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"C++ =&gt; FEM -&gt; Finite Element Methods"</span>, <span class="org-string">"C++ =&gt; High Performance Computing"</span>, <span class="org-string">"C++ =&gt; Monte Carlo Simulations"</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">lin</span>: lines<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" + line = "</span> &lt;&lt; lin &lt;&lt; <span class="org-string">"\n"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 + line = C++ =&gt; FEM -&gt; Finite Element Methods
 + line = C++ =&gt; High Performance Computing
 + line = C++ =&gt; Monte Carlo Simulations
&gt;&gt; 
</pre>
</div>

<p>
Or, putting it all together: 
</p>

<ul class="org-ul">
<li>Version: read lines from string</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Requires: &lt;string&gt; &lt;sstream&gt; and &lt;iostream&gt;                                 </span>
<span class="org-keyword">auto</span> <span class="org-function-name">splitLines1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">text</span><span class="org-rainbow-delimiters-depth-1">)</span>
  -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">lines</span> = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;{}</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">line</span>  = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">is</span>    = <span class="org-constant">std</span>::stringstream<span class="org-rainbow-delimiters-depth-2">{</span>text<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-3">(</span>is, line<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
    lines.emplace_back<span class="org-rainbow-delimiters-depth-2">(</span>line<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> lines;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::string text;
text += <span class="org-string">"=&gt; FEM -&gt; Finite Element Methods\n"</span>;
text += <span class="org-string">"=&gt; High Performance Computing\n"</span>;
text += <span class="org-string">"=&gt; Monte Carlo Simulations\n"</span>;
text += <span class="org-string">"=&gt; Global Markets Trends\n"</span>;
text += <span class="org-string">"=&gt; Growth forecast survery.\n"</span>;

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">lin</span>: splitLines1<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" +=&gt; "</span> &lt;&lt; lin &lt;&lt; <span class="org-string">"\n"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 +=&gt; =&gt; FEM -&gt; Finite Element Methods
 +=&gt; =&gt; High Performance Computing
 +=&gt; =&gt; Monte Carlo Simulations
 +=&gt; =&gt; Global Markets Trends
 +=&gt; =&gt; Growth forecast survery.
&gt;&gt; 
</pre>
</div>

<p>
<b>Example 4:</b> Extract lines from input stream. 
</p>

<ul class="org-ul">
<li>Read lines from input stream - this second version can read from
any sublcass of std::istream, thus, it can also get lines from
files and starndard input stream std::cin (console or stdin).</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Read all lines from stram to container Requires: &lt;string&gt; &lt;sstream&gt;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">and &lt;iostream&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">splitLines2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span>&amp; <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [INFO] L-value reference."</span>
  <span class="org-keyword">auto</span> lines = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;{}</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">line</span>  = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-3">(</span>is, line<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
    lines.emplace_back<span class="org-rainbow-delimiters-depth-2">(</span>line<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> lines;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Overload to work with temporary objects (R-values)</span>
<span class="org-keyword">auto</span> <span class="org-function-name">splitLines2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span>&amp;&amp; <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [INFO] R-value reference."</span>
  <span class="org-keyword">auto</span> lines = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;{}</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">line</span>  = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-3">(</span>is, line<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
    lines.emplace_back<span class="org-rainbow-delimiters-depth-2">(</span>line<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> lines;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Running: 
</p>

<ul class="org-ul">
<li>Read lines from string</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::string text;
text += <span class="org-string">"=&gt; FEM -&gt; Finite Element Methods\n"</span>;
text += <span class="org-string">"=&gt; High Performance Computing\n"</span>;
text += <span class="org-string">"=&gt; Monte Carlo Simulations\n"</span>;
text += <span class="org-string">"=&gt; Global Markets Trends\n"</span>;
text += <span class="org-string">"=&gt; Growth forecast survery.\n"</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">ss</span> = <span class="org-constant">std</span>::stringstream<span class="org-rainbow-delimiters-depth-1">(</span>text<span class="org-rainbow-delimiters-depth-1">)</span> ;

<span class="org-comment-delimiter">// </span><span class="org-comment">Read from an L-value (object bounded to a memory location)</span>
&gt;&gt; <span class="org-keyword">auto</span> ss = <span class="org-constant">std</span>::stringstream<span class="org-rainbow-delimiters-depth-1">(</span>text<span class="org-rainbow-delimiters-depth-1">)</span> ;
&gt;&gt; <span class="org-keyword">auto</span> lines = splitLines2<span class="org-rainbow-delimiters-depth-1">(</span>ss<span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> L-value reference.

&gt;&gt; lines2
<span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"=&gt; FEM -&gt; Finite Element Methods"</span>, <span class="org-string">"=&gt; High Performance Computing"</span>, ...<span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Read from an R-value (temporary object)</span>
&gt;&gt; <span class="org-keyword">auto</span> lines = splitLines2<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::stringstream<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> R-value reference.
&gt;&gt; lines
 <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"=&gt; FEM -&gt; Finite Element Methods"</span>, <span class="org-string">"=&gt; High Performance Computing"</span>, ...<span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Read lines from file</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Read lines from file: </span>
&gt;&gt; res = splitLines2<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::ifstream<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"/etc/protocols"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> R-value reference.

&gt;&gt; res.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 162
&gt;&gt; 

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">lin</span>: res<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" + line = "</span> &lt;&lt; lin &lt;&lt; <span class="org-string">"\n"</span>;<span class="org-rainbow-delimiters-depth-1">}</span>
 + line = # /etc/protocols:
 + line = # $Id: protocols,v 1.12 2016/07/08 12:27 ovasik Exp $
 + line = #
 + line = # Internet <span class="org-rainbow-delimiters-depth-1">(</span>IP<span class="org-rainbow-delimiters-depth-1">)</span> protocols
 + line = #
 + line = # from: @<span class="org-rainbow-delimiters-depth-1">(</span>#<span class="org-rainbow-delimiters-depth-1">)</span>protocols 5.1 <span class="org-rainbow-delimiters-depth-1">(</span>Berkeley<span class="org-rainbow-delimiters-depth-1">)</span> 4/17/89
 + line = #
 + line = # Updated <span class="org-keyword">for</span> NetBSD based on RFC 1340, <span class="org-type">Assigned</span> <span class="org-function-name">Numbers</span> <span class="org-rainbow-delimiters-depth-1">(</span>July 1992<span class="org-rainbow-delimiters-depth-1">)</span>.
 + line = # Last IANA update included dated 2011-05-03
 + line = #
   ... ... ... ... .... 
</pre>
</div>

<ul class="org-ul">
<li>Read lines from console</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Types many line and then  CTRL + D (Send EOF - End Of File) when you are done.</span>
&gt;&gt; <span class="org-keyword">auto</span> res2 = splitLines2<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cin<span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> L-value reference.
hello world
c++ C++11 is awesome
C++17 is amazing
C++20 RULEZ<span class="org-negation-char">!</span> High peformance technical computing
  Monte Carlo Methods
  High Energy Physics
  Electronic Engineering - Embedded Processors    
&gt;&gt; 

&gt;&gt; res2
 <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"hello world"</span>, <span class="org-string">"c++ C++11 is awesome"</span>, <span class="org-string">"C++17 is amazing"</span>, ...<span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">auto</span> res2copy = <span class="org-constant">std</span>::vector<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span>res2.begin<span class="org-rainbow-delimiters-depth-2">()</span>, res2.end<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"hello world"</span>, <span class="org-string">"c++ C++11 is awesome"</span>, <span class="org-string">"C++17 is amazing"</span>, ...<span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">lin</span>: res2<span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [+] line = "</span> &lt;&lt; lin &lt;&lt; <span class="org-string">"\n"</span>;<span class="org-rainbow-delimiters-depth-1">}</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>+<span class="org-rainbow-delimiters-depth-1">]</span> line = hello world
 <span class="org-rainbow-delimiters-depth-1">[</span>+<span class="org-rainbow-delimiters-depth-1">]</span> line = c++ C++11 is awesome
 <span class="org-rainbow-delimiters-depth-1">[</span>+<span class="org-rainbow-delimiters-depth-1">]</span> line = C++17 is amazing
 <span class="org-rainbow-delimiters-depth-1">[</span>+<span class="org-rainbow-delimiters-depth-1">]</span> line = C++20 RULEZ<span class="org-negation-char">!</span> High peformance technical computing
 <span class="org-rainbow-delimiters-depth-1">[</span>+<span class="org-rainbow-delimiters-depth-1">]</span> line =   Monte Carlo Methods
 <span class="org-rainbow-delimiters-depth-1">[</span>+<span class="org-rainbow-delimiters-depth-1">]</span> line =   High Energy Physics
 <span class="org-rainbow-delimiters-depth-1">[</span>+<span class="org-rainbow-delimiters-depth-1">]</span> line =   Electronic Engineering - Embedded Processors
&gt;&gt; 

</pre>
</div>
</div>
</div>

<div id="outline-container-orgf44c3b6" class="outline-4">
<h4 id="orgf44c3b6"><span class="section-number-4">1.9.8</span> Transform string to uppercase or lowercase</h4>
<div class="outline-text-4" id="text-1-9-8">
<p>
Headers: 
</p>
<ul class="org-ul">
<li>&lt;string&gt;</li>
<li>&lt;cstring&gt;</li>
<li>&lt;algorithm&gt;</li>
</ul>

<p>
Convert string to upper case:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string text = <span class="org-string">"c++ is suitable for system programming"</span>;
&gt;&gt; 
<span class="org-function-name">std</span>::transform<span class="org-rainbow-delimiters-depth-1">(</span> text.begin<span class="org-rainbow-delimiters-depth-2">()</span>,
                text.end<span class="org-rainbow-delimiters-depth-2">()</span>,
                text.begin<span class="org-rainbow-delimiters-depth-2">()</span>,
                <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">char</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::toupper<span class="org-rainbow-delimiters-depth-3">(</span>x<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
                <span class="org-rainbow-delimiters-depth-1">)</span>;
&gt;&gt; text
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"C++ IS SUITABLE FOR SYSTEM PROGRAMMING"</span>
&gt;&gt;

<span class="org-keyword">auto</span> toUpper<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">text</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::string <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">out</span> = text;
  <span class="org-constant">std</span>::transform<span class="org-rainbow-delimiters-depth-2">(</span> out.begin<span class="org-rainbow-delimiters-depth-3">()</span>,
                  out.end<span class="org-rainbow-delimiters-depth-3">()</span>,
                  out.begin<span class="org-rainbow-delimiters-depth-3">()</span>,
                  <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">char</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::toupper<span class="org-rainbow-delimiters-depth-4">(</span>x<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
                  <span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> out;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; toUpper<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"c++ system programming embedded high performance"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"C++ SYSTEM PROGRAMMING EMBEDDED HIGH PERFORMANCE"</span>
&gt;&gt; 
</pre>
</div>

<p>
Convert string to lower case:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::string text = <span class="org-string">"c++ IS Suitable foR System proGramMing"</span>;
<span class="org-function-name">std</span>::transform<span class="org-rainbow-delimiters-depth-1">(</span> text.begin<span class="org-rainbow-delimiters-depth-2">()</span>,
                text.end<span class="org-rainbow-delimiters-depth-2">()</span>,
                text.begin<span class="org-rainbow-delimiters-depth-2">()</span>,
                <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">char</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::tolower<span class="org-rainbow-delimiters-depth-3">(</span>x<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
                <span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; text
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"c++ is suitable for system programming"</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a0e132" class="outline-4">
<h4 id="org8a0e132"><span class="section-number-4">1.9.9</span> Check whether a string contains substring</h4>
<div class="outline-text-4" id="text-1-9-9">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">bool</span> <span class="org-function-name">containsStr</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">str</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">substr</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">return</span> str.find<span class="org-rainbow-delimiters-depth-2">(</span>substr<span class="org-rainbow-delimiters-depth-2">)</span> != <span class="org-constant">std</span>::<span class="org-constant">string</span>::npos;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; containsStr<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"cpp plus plus cee c++ 34"</span>, <span class="org-string">"c++"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; containsStr<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"cpp plus plus cee c++ 34"</span>, <span class="org-string">"cpp11"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; containsStr<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"cpp plus plus cee c++ 34"</span>, <span class="org-string">"cee"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org8b503d4" class="outline-4">
<h4 id="org8b503d4"><span class="section-number-4">1.9.10</span> Search and replace</h4>
<div class="outline-text-4" id="text-1-9-10">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-function-name">replaceStr</span><span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">text</span>,                              
                 <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">rep</span>,                                
                 <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">subst</span>                               
              <span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-1">{</span>                                                     
  <span class="org-comment-delimiter">// </span><span class="org-comment">Copy paraemter text (Invoke copy constructor)                             </span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">out</span> = text;                                                      
  <span class="org-comment-delimiter">// </span><span class="org-comment">Find position of character matching the string                            </span>
  <span class="org-type">size_t</span> <span class="org-variable-name">i</span> = out.find<span class="org-rainbow-delimiters-depth-2">(</span>rep<span class="org-rainbow-delimiters-depth-2">)</span>;                                                    
  <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span>i != <span class="org-constant">std</span>::<span class="org-constant">string</span>::npos<span class="org-rainbow-delimiters-depth-2">){</span>                                               
    out.replace<span class="org-rainbow-delimiters-depth-3">(</span>i, rep.size<span class="org-rainbow-delimiters-depth-4">()</span>, subst<span class="org-rainbow-delimiters-depth-3">)</span>;                                         
    i = out.find<span class="org-rainbow-delimiters-depth-3">(</span>rep, i<span class="org-rainbow-delimiters-depth-3">)</span>;                                                      
  <span class="org-rainbow-delimiters-depth-2">}</span>                                                                            
  <span class="org-keyword">return</span> out;                                                                  
<span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; replaceStr<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" c++11 high c++future c++15 peformance cpp c++17"</span>, <span class="org-string">"c++"</span>, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">" 11 high future 15 peformance cpp 17"</span>

&gt;&gt; replaceStr<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" c++11 high c++future c++15 peformance cpp c++17"</span>, <span class="org-string">"c++"</span>, <span class="org-string">"DLang"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">" DLang11 high DLangfuture DLang15 peformance cpp DLang17"</span>
&gt;&gt; 

&gt;&gt; replaceStr<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" c++11 high c++future c++15 peformance cpp c++17"</span>, <span class="org-string">"c++"</span>, <span class="org-string">"CXX"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">" CXX11 high CXXfuture CXX15 peformance cpp CXX17"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga0497e8" class="outline-4">
<h4 id="orga0497e8"><span class="section-number-4">1.9.11</span> Character Testing</h4>
<div class="outline-text-4" id="text-1-9-11">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Return</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">int isalphanum(int)</td>
<td class="org-left">Non-zero if input is letter or digit</td>
</tr>

<tr>
<td class="org-left">int isalpha(int)</td>
<td class="org-left">Non-zero if input is letter</td>
</tr>

<tr>
<td class="org-left">int iscntr(int)</td>
<td class="org-left">Non-zero if input is control character</td>
</tr>

<tr>
<td class="org-left">int isdigit(int)</td>
<td class="org-left">Non-zero if input is digit</td>
</tr>

<tr>
<td class="org-left">int isgraph(int)</td>
<td class="org-left">Non-zero if input is not whitespace printable character</td>
</tr>

<tr>
<td class="org-left">int isprint(int)</td>
<td class="org-left">&#x2026; if input is printable character</td>
</tr>

<tr>
<td class="org-left">int ispunct(int)</td>
<td class="org-left">&#x2026; if input is neither alphanumeric nor whitespace</td>
</tr>

<tr>
<td class="org-left">int isspace(int)</td>
<td class="org-left">&#x2026; if input is whitespace</td>
</tr>

<tr>
<td class="org-left">int isxdigit(int)</td>
<td class="org-left">&#x2026; if input is hexadecimal digit</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Check whether string is number:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">algorithm</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">bool</span> <span class="org-function-name">isNumber</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">str</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>str == <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  <span class="org-keyword">return</span> <span class="org-constant">std</span>::all_of<span class="org-rainbow-delimiters-depth-2">(</span>
             str.begin<span class="org-rainbow-delimiters-depth-3">()</span>,
             str.end<span class="org-rainbow-delimiters-depth-3">()</span>,
             <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">char</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span>
               <span class="org-keyword">return</span> <span class="org-constant">std</span>::isdigit<span class="org-rainbow-delimiters-depth-4">(</span>x<span class="org-rainbow-delimiters-depth-4">)</span>;
             <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; isNumber<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"1213"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; isNumber<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"12x13"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; isNumber<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Check whether string is an hexadecimal number</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">bool</span> <span class="org-function-name">isNumberHex</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">str</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>str == <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>;
   <span class="org-keyword">return</span> <span class="org-constant">std</span>::all_of<span class="org-rainbow-delimiters-depth-2">(</span>
              str.begin<span class="org-rainbow-delimiters-depth-3">()</span>,
              str.end<span class="org-rainbow-delimiters-depth-3">()</span>,
              <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">char</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span>
                <span class="org-keyword">return</span> <span class="org-constant">std</span>::isxdigit<span class="org-rainbow-delimiters-depth-4">(</span>x<span class="org-rainbow-delimiters-depth-4">)</span>;
              <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
 <span class="org-rainbow-delimiters-depth-1">}</span>

 &gt;&gt; isNumberHex<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0fabcd92813"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
 &gt;&gt; 
 &gt;&gt; isNumberHex<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0fxabcd92813"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
 &gt;&gt; isNumberHex<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
 &gt;&gt; isNumberHex<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"ff"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
 &gt;&gt; isNumberHex<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"0xff"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
</pre>
</div>

<ul class="org-ul">
<li>Check whether string contains only letters</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">bool</span> <span class="org-function-name">isAlphaOnly</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">str</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>str == <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  <span class="org-keyword">return</span> <span class="org-constant">std</span>::all_of<span class="org-rainbow-delimiters-depth-2">(</span>
             str.begin<span class="org-rainbow-delimiters-depth-3">()</span>,
             str.end<span class="org-rainbow-delimiters-depth-3">()</span>,
             <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">char</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">){</span>
               <span class="org-keyword">return</span> <span class="org-constant">std</span>::isalpha<span class="org-rainbow-delimiters-depth-4">(</span>x<span class="org-rainbow-delimiters-depth-4">)</span>;
             <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; isAlphaOnly<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"helloworld"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; isAlphaOnly<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello54world"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; isAlphaOnly<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; isAlphaOnly<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"w"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; isAlphaOnly<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"sa.ds-a"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org0035a84" class="outline-4">
<h4 id="org0035a84"><span class="section-number-4">1.9.12</span> Split string by delimiter</h4>
<div class="outline-text-4" id="text-1-9-12">
<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string t = <span class="org-string">"key =  value"</span>;
&gt;&gt; size_t i = t.find<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"="</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 4

&gt;&gt; t.substr<span class="org-rainbow-delimiters-depth-1">(</span>0, i<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"key "</span>
&gt;&gt; 
&gt;&gt; t.substr<span class="org-rainbow-delimiters-depth-1">(</span>i, t.size<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"=  value"</span>
&gt;&gt; t.substr<span class="org-rainbow-delimiters-depth-1">(</span>i + 1, t.size<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"  value"</span>
&gt;&gt; 
</pre>
</div>

<p>
Encapsulating into a function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">auto</span> <span class="org-function-name">splitString</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">str</span>,
                 <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">delim</span>
                 <span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">xs</span>;
  <span class="org-type">size_t</span> <span class="org-variable-name">i</span> = str.find<span class="org-rainbow-delimiters-depth-2">(</span>delim<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>i == <span class="org-constant">std</span>::<span class="org-constant">string</span>::npos<span class="org-rainbow-delimiters-depth-2">){</span>
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">""</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">return</span> xs;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  xs.push_back<span class="org-rainbow-delimiters-depth-2">(</span>str.substr<span class="org-rainbow-delimiters-depth-3">(</span>0,    i<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  xs.push_back<span class="org-rainbow-delimiters-depth-2">(</span>str.substr<span class="org-rainbow-delimiters-depth-3">(</span>i + 1, str.size<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> xs;
<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; splitString<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"key value"</span>, <span class="org-string">"="</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">""</span>, <span class="org-string">""</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; splitString<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"key = value"</span>, <span class="org-string">"="</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"key "</span>, <span class="org-string">" value"</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; splitString<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"key  va=lue"</span>, <span class="org-string">"="</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"key  va"</span>, <span class="org-string">"lue"</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; splitString<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"key  value="</span>, <span class="org-string">"="</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"key  value"</span>, <span class="org-string">""</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; splitString<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">""</span>, <span class="org-string">"="</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">""</span>, <span class="org-string">""</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; splitString<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"key  value="</span>, <span class="org-string">""</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">""</span>, <span class="org-string">"ey  value="</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org36a6bfa" class="outline-4">
<h4 id="org36a6bfa"><span class="section-number-4">1.9.13</span> Extract quoted string (C++14)</h4>
<div class="outline-text-4" id="text-1-9-13">
<p>
Documentation: <a href="https://en.cppreference.com/w/cpp/io/manip/quoted">std::quoted - cppreference.com</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">std::quoted in C++14</span>

<span class="org-function-name">std</span>::string s = <span class="org-string">" 200 key value \" aquoted string \"  \"next quote\""</span>;
<span class="org-function-name">std</span>::stringstream ss<span class="org-rainbow-delimiters-depth-1">{</span>s<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">std</span>::string out;

<span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-negation-char">!</span>ss.eof<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">){</span>
  ss &gt;&gt; <span class="org-constant">std</span>::quoted<span class="org-rainbow-delimiters-depth-2">(</span>out<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"word = "</span> &lt;&lt; out &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">word = 200
word = key
word = value
word =  aquoted string 
word = next quote
word = next quote
</pre>
</div>

<p>
Hand-rolled quoted string parser: 
</p>

<ul class="org-ul">
<li>Useful if C++14 is not avaiable.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Requires headers: &lt;string&gt; and &lt;sstream&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">readQuoted</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span>&amp; <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-type">char</span> <span class="org-variable-name">ch</span>;
     <span class="org-constant">std</span>::<span class="org-type">ostringstream</span> <span class="org-variable-name">so</span>;
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>is.eof<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">return</span> <span class="org-string">""</span>;
     <span class="org-comment-delimiter">// </span><span class="org-comment">Find first quote:</span>
     <span class="org-comment-delimiter">//</span><span class="org-comment">-------------------------------------</span>
     <span class="org-keyword">do</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        ch = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>is.get<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span>is.good<span class="org-rainbow-delimiters-depth-3">()</span> &amp;&amp; <span class="org-negation-char">!</span>is.eof<span class="org-rainbow-delimiters-depth-3">()</span> &amp;&amp; <span class="org-constant">std</span>::isspace<span class="org-rainbow-delimiters-depth-3">(</span>ch<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;   
     <span class="org-comment-delimiter">//</span><span class="org-comment">std::cout &lt;&lt; "ch = " &lt;&lt; ch  &lt;&lt; "\n"; </span>
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>ch != <span class="org-string">'\"'</span><span class="org-rainbow-delimiters-depth-2">){</span>
        so &lt;&lt; ch;
        <span class="org-keyword">do</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            ch = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>is.get<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span>;
            so &lt;&lt; ch;
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span>is.good<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span>is.eof<span class="org-rainbow-delimiters-depth-4">()</span> &amp;&amp; <span class="org-negation-char">!</span><span class="org-constant">std</span>::isspace<span class="org-rainbow-delimiters-depth-4">(</span>ch<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>is.eof<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-keyword">return</span> <span class="org-string">""</span>;
        <span class="org-keyword">return</span> so.str<span class="org-rainbow-delimiters-depth-3">()</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-comment-delimiter">//</span><span class="org-comment">std::cout &lt;&lt; "ch = " &lt;&lt; ch  &lt;&lt; "\n"; </span>
     <span class="org-keyword">do</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        ch = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>is.get<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>ch != <span class="org-string">'\"'</span><span class="org-rainbow-delimiters-depth-3">)</span> so &lt;&lt; ch;
     <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span>is.good<span class="org-rainbow-delimiters-depth-3">()</span> &amp;&amp; <span class="org-negation-char">!</span>is.eof<span class="org-rainbow-delimiters-depth-3">()</span> &amp;&amp; ch != <span class="org-string">'\"'</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>is.eof<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Did not find a matching quote.</span>
        <span class="org-keyword">return</span> <span class="org-string">""</span>;
     <span class="org-comment-delimiter">//</span><span class="org-comment">std::cout &lt;&lt; "ch = " &lt;&lt; ch  &lt;&lt; "\n";</span>
     <span class="org-keyword">return</span> so.str<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::string s = <span class="org-string">"  \" 200 99 888 quoted - string \" KEY \" VALUE PAIR \"  100 \" Sao Paulo City\" 4500 key "</span>;
<span class="org-function-name">std</span>::stringstream ss<span class="org-rainbow-delimiters-depth-1">{</span>s<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt;&gt; <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span>ss.good<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"quoted = "</span> &lt;&lt; readQuoted<span class="org-rainbow-delimiters-depth-1">(</span>ss<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
quoted =  200 99 888 quoted - string 
quoted = KEY 
quoted =  VALUE PAIR 
quoted = 100 
quoted =  Sao Paulo City
quoted = 4500 
quoted = key 
quoted = 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbcb2d4b" class="outline-4">
<h4 id="orgbcb2d4b"><span class="section-number-4">1.9.14</span> Parse comma separated value - CSV row</h4>
<div class="outline-text-4" id="text-1-9-14">
<p>
Note: the following CSV parser functions fails for heterogeneous data
or when there are quotes characters. It is better to use a proper CSV
parser library as CSV is not a standardized data exchange format and
has lots of tricky edge cases.
</p>

<ul class="org-ul">
<li>Example: Simple CSV line parser.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> parseCSVRow<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">line</span>, <span class="org-type">char</span> <span class="org-variable-name">delim</span> = <span class="org-string">','</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">out</span>   = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;{}</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">token</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">ss</span>    = <span class="org-constant">std</span>::stringstream<span class="org-rainbow-delimiters-depth-2">{</span>line<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-3">(</span>ss, token, delim<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">){</span>
    out.push_back<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::stod<span class="org-rainbow-delimiters-depth-4">(</span>token<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">return</span> out;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::string raw_data = <span class="org-string">"100,   200,  400, -100.23, 60.23, 90.32"</span>;

&gt;&gt; parseCSVRow<span class="org-rainbow-delimiters-depth-1">(</span>raw_data<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 100.00000, 200.00000, 400.00000, -100.23000, 60.230000, 90.320000 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; <span class="org-keyword">auto</span> xs = parseCSVRow<span class="org-rainbow-delimiters-depth-1">(</span>raw_data<span class="org-rainbow-delimiters-depth-1">)</span>;
&gt;&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.00000
&gt;&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 200.00000
&gt;&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 400.00000
&gt;&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -100.23000
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Example: Generic CSV line Parser.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Type</span> = <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Type</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-function-name">parseCSVRowGeneric</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">line</span>,
                                     <span class="org-type">char</span> <span class="org-variable-name">delim</span> = <span class="org-string">','</span>
                                     <span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-keyword">auto</span> <span class="org-variable-name">out</span>   = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Type</span><span class="org-rainbow-delimiters-depth-2">&gt;{}</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">token</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">ss</span>    = <span class="org-constant">std</span>::stringstream<span class="org-rainbow-delimiters-depth-2">{</span>line<span class="org-rainbow-delimiters-depth-2">}</span>;
  <span class="org-keyword">auto</span> <span class="org-variable-name">is</span>    = <span class="org-constant">std</span>::stringstream<span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-type">Type</span> <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
  <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-3">(</span>ss, token, delim<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">){</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Clear error flags                                                                                                                              </span>
    is.clear<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Set is stream value to token                                                                                                                   </span>
    is.str<span class="org-rainbow-delimiters-depth-3">(</span>token<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Extract from 'is' stream                                                                                                                       </span>
    is &gt;&gt; value;
    out.push_back<span class="org-rainbow-delimiters-depth-3">(</span>value<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">return</span> out;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Test data</span>
<span class="org-function-name">std</span>::string lineB = <span class="org-string">"2002.23, 434.34, 90.23, -23.23, 1e3"</span>;
<span class="org-function-name">std</span>::string lineC = <span class="org-string">"100; 200; 300; 150; 500; 600"</span>;
<span class="org-function-name">std</span>::string lineD = <span class="org-string">"Apple: oranges : juice beans : rice"</span>;

&gt;&gt; parseCSVRowGeneric<span class="org-rainbow-delimiters-depth-1">(</span>lineB<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 2002.2300, 434.34000, 90.230000, -23.230000, 1000.0000 <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; parseCSVRowGeneric<span class="org-rainbow-delimiters-depth-1">&lt;&gt;(</span>lineB<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 2002.2300, 434.34000, 90.230000, -23.230000, 1000.0000 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; parseCSVRowGeneric<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>lineB, <span class="org-string">','</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 2002.2300, 434.34000, 90.230000, -23.230000, 1000.0000 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; parseCSVRowGeneric<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>lineC, <span class="org-string">';'</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 100, 200, 300, 150, 500, 600 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; parseCSVRowGeneric<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;(</span>lineD, <span class="org-string">':'</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"Apple"</span>, <span class="org-string">"oranges"</span>, <span class="org-string">"juice"</span>, <span class="org-string">"rice"</span> <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org760daf5" class="outline-4">
<h4 id="org760daf5"><span class="section-number-4">1.9.15</span> C++11 Regular Expressions Regex</h4>
<div class="outline-text-4" id="text-1-9-15">
</div>
<ol class="org-ol">
<li><a id="org2c3f5d9"></a>Overview<br />
<div class="outline-text-5" id="text-1-9-15-1">
<p>
C++11 STL provides a regular expression library with ECMAScript
(Javascript) engine. It makes easier to use regular expressions
without third-party libraries.
</p>

<p>
<b>Documentation:</b>
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/regex">Regular expressions library - cppreference.com</a></li>
<li><a href="http://www.cplusplus.com/reference/regex/">&lt;regex&gt; - C++ Reference</a></li>
<li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/regex?view=vs-2017">&lt;regex&gt; | Microsoft Docs</a></li>
<li><a href="https://www.boost.org/doc/libs/1_69_0/libs/regex/doc/html/index.html">Boost.Regex</a> - predecessor of the STL regex library, so it is a
practical documentation of the current STL &lt;regex&gt; library.</li>
</ul>

<p>
<b>ECMAScript Regex Syntax</b>
</p>

<ul class="org-ul">
<li><a href="http://www.cplusplus.com/reference/regex/ECMAScript/">ECMAScript syntax - C++ Reference</a></li>
<li><a href="https://en.cppreference.com/w/cpp/regex/ecmascript">Modified ECMAScript regular expression grammar - cppreference.com</a></li>
<li><a href="https://o7planning.org/en/12219/ecmascript-regular-expressions-tutorial">ECMAScript / Javascript Regular Expressions Tutorial</a></li>
</ul>

<p>
<b>Engines</b>
</p>

<p>
Regular expression grammars supported by the C++11 regex library: 
</p>

<ul class="org-ul">
<li>ECMAScript ("JavaScript" is an <a href="https://news.ycombinator.com/item?id=8344049">Oracle inc.</a> trademark) - default regex engine</li>
<li>basic</li>
<li>extended</li>
<li>awk</li>
<li>grep</li>
<li>egrep</li>
</ul>

<p>
<b>Classes:</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Class</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="https://en.cppreference.com/w/cpp/regex/basic_regex">std::regex</a></td>
<td class="org-left">Regular expression object. It is the same as  <a href="https://en.cppreference.com/w/cpp/regex/basic_regex">std::basic_regex</a></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>Regex Matching</b></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><a href="https://en.cppreference.com/w/cpp/regex/match_results">std::match</a></td>
<td class="org-left">Regex matching results. It is  the same as  <a href="https://en.cppreference.com/w/cpp/regex/match_results">std::match_results</a></td>
</tr>

<tr>
<td class="org-left">std::smatch</td>
<td class="org-left">std::match_results&lt;std::string::const_iterator&gt;</td>
</tr>

<tr>
<td class="org-left">std::cmatch</td>
<td class="org-left"><code>std::match_results&lt;const char*&gt;</code></td>
</tr>

<tr>
<td class="org-left">std::wcmatch</td>
<td class="org-left"><code>std::match_results&lt;const wchar_t*&gt;</code></td>
</tr>

<tr>
<td class="org-left">std::wsmatch</td>
<td class="org-left"><code>std::match_results&lt;std::wstring::const_iterator&gt;</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>Iterators</b></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><a href="https://en.cppreference.com/w/cpp/regex/regex_iterator">std::regex_iterator</a>&lt;T&gt;</td>
<td class="org-left">Regex iterator object - provides access to regex matches.</td>
</tr>

<tr>
<td class="org-left">cregex_iterator</td>
<td class="org-left"><code>regex_iterator&lt;const char*&gt;</code> - Specialization for type <span class="underline">const char*</span></td>
</tr>

<tr>
<td class="org-left">wcregex_iterator</td>
<td class="org-left"><code>regex_iterator&lt;const wchar_t*&gt;</code> - Specialization for type <span class="underline">const wchar_t*</span></td>
</tr>

<tr>
<td class="org-left">sregex_iterator</td>
<td class="org-left"><code>regex_iterator&lt;std::string::const_iterator&gt;</code></td>
</tr>

<tr>
<td class="org-left">wsregex_iterator</td>
<td class="org-left">regex_iterator&lt;std::wstring::const_iterator&gt;</td>
</tr>
</tbody>
</table>

<p>
<b>Online REGEX Testers</b> 
</p>

<ul class="org-ul">
<li><a href="https://myregextester.com/index.php#resultstab">Myregextester.com</a></li>

<li><a href="https://regexr.com/">RegExr: Learn, Build, &amp; Test RegEx</a></li>

<li><a href="https://regex101.com/">https://regex101.com/</a></li>
</ul>
</div>
</li>

<li><a id="org1dad5f0"></a>Example<br />
<div class="outline-text-5" id="text-1-9-15-2">
<ul class="org-ul">
<li>File: <a href="src/regex1.cpp">file:src/regex1.cpp</a></li>
<li>Online Compiler: <a href="https://rextester.com/RKT35657">https://rextester.com/RKT35657</a></li>
</ul>

<p>
Compile and run:  
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ regex1.cpp -o <span class="org-keyword">regex1.bin</span> -std=c++1z -O0 -Wall &amp;&amp; ./regex1.bin
$ g++ regex1.cpp -o <span class="org-keyword">regex1.bin</span> -std=c++1z -O0 -Wall &amp;&amp; ./regex1.bin

<span class="org-comment-delimiter"># </span><span class="org-comment">Compilation is slow: it takes 2 seconds [Non optimized]!!</span>
$ time clang++ regex1.cpp -o <span class="org-keyword">regex1.bin</span> -std=c++1z -O0 -Wall
real    0m2.356s
user    0m2.200s
sys     0m0.112s

<span class="org-comment-delimiter"># </span><span class="org-comment">Compilation time is even slower when optimized!! 6 seconds to build!</span>
$ time clang++ regex1.cpp -o <span class="org-keyword">regex1.bin</span> -std=c++1z -O3 -Wall
real    0m6.027s
user    0m5.584s
sys     0m0.107s
</pre>
</div>

<p>
<b>Macro DBG_DISP for displaying expressions:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#define</span> <span class="org-function-name">DBG_DISP</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">expr</span><span class="org-rainbow-delimiters-depth-1">)</span>  <span class="org-constant">std</span>::cerr &lt;&lt; __FILE__ &lt;&lt; <span class="org-string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="org-string">":"</span> \
        &lt;&lt; <span class="org-string">" ; "</span> &lt;&lt;  #expr &lt;&lt; <span class="org-string">" = "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-1">(</span>expr<span class="org-rainbow-delimiters-depth-1">)</span>  &lt;&lt;  <span class="org-constant">std</span>::endl
</pre>
</div>

<p>
<b>Headers</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">regex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
</pre>
</div>

<p>
<b>Experiment 1: Match entire string</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ======== EXPERIMENT 1 === Match entire string ====="</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::regex numRegex<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\\d+"</span><span class="org-rainbow-delimiters-depth-1">)</span>;        
DBG_DISP<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::regex_match<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"3423"</span>, numRegex<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
DBG_DISP<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::regex_match<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"AAB786"</span>, numRegex<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
DBG_DISP<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::regex_match<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"  9745"</span>, numRegex<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
DBG_DISP<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::regex_match<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" 634 "</span>, numRegex<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text"> ======== EXPERIMENT 1 === Match entire string =====
regex1.cpp:17: ; std::regex_match("3423", numRegex) = true
regex1.cpp:18: ; std::regex_match("AAB786", numRegex) = false
regex1.cpp:19: ; std::regex_match("  9745", numRegex) = false
regex1.cpp:20: ; std::regex_match(" 634 ", numRegex) = false
</pre>
</div>

<p>
<b>Experiment 2: Check whether text has regex</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ======== EXPERIMENT 2 === Check whether text has regex ====="</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::regex variable<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\\s?[a-zA-Z][a-zA-Z|\\d]*\\b"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
DBG_DISP<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::regex_search<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"3423"</span>, variable<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
DBG_DISP<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::regex_search<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"dot.com\\ -buble hello variable4561 "</span>, variable<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
DBG_DISP<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::regex_search<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"  -dot.com.buble.burst "</span>, variable<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text"> ======== EXPERIMENT 2 === Check whether text has regex =====
regex1.cpp:25: ; std::regex_search("3423", variable) = false
regex1.cpp:26: ; std::regex_search("dot.com\\ -buble hello variable4561 ", variable) = true
regex1.cpp:27: ; std::regex_search("  -dot.com.buble.burst ", variable) = true
</pre>
</div>

<p>
<b>Experiment 3: Extract text</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ======== EXPERIMENT 3 === Extract text ====="</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::regex phoneRe<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"phone:\\s*(\\d{8})\\s*$"</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-function-name">std</span>::string line;
<span class="org-function-name">std</span>::smatch result;

line = <span class="org-string">"phone:85619751"</span>;
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::regex_search<span class="org-rainbow-delimiters-depth-2">(</span>line, result, phoneRe<span class="org-rainbow-delimiters-depth-2">)</span> &amp;&amp; result.size<span class="org-rainbow-delimiters-depth-2">()</span> &gt; 1<span class="org-rainbow-delimiters-depth-1">)</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Result1 = "</span> &lt;&lt; result.str<span class="org-rainbow-delimiters-depth-1">(</span>1<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-keyword">else</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Result1 = &lt;&lt;NOT MATCH&gt;&gt;"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

line = <span class="org-string">"phone:  65658741  "</span>;
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::regex_search<span class="org-rainbow-delimiters-depth-2">(</span>line, result, phoneRe<span class="org-rainbow-delimiters-depth-2">)</span> &amp;&amp; result.size<span class="org-rainbow-delimiters-depth-2">()</span> &gt; 1<span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Result2 = "</span> &lt;&lt; result.str<span class="org-rainbow-delimiters-depth-1">(</span>1<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-keyword">else</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Result2 = &lt;&lt;NOT MATCH&gt;&gt;"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

line = <span class="org-string">"phone:  756596213434"</span>;
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::regex_search<span class="org-rainbow-delimiters-depth-2">(</span>line, result, phoneRe<span class="org-rainbow-delimiters-depth-2">)</span> &amp;&amp; result.size<span class="org-rainbow-delimiters-depth-2">()</span> &gt; 1<span class="org-rainbow-delimiters-depth-1">)</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Result3 = "</span> &lt;&lt; result.str<span class="org-rainbow-delimiters-depth-1">(</span>1<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-keyword">else</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Result3 = &lt;&lt;NOT MATCH&gt;&gt;"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

line = <span class="org-string">"phone:  ABBX621"</span>;
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::regex_search<span class="org-rainbow-delimiters-depth-2">(</span>line, result, phoneRe<span class="org-rainbow-delimiters-depth-2">)</span> &amp;&amp; result.size<span class="org-rainbow-delimiters-depth-2">()</span> &gt; 1<span class="org-rainbow-delimiters-depth-1">)</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Result4 = "</span> &lt;&lt; result.str<span class="org-rainbow-delimiters-depth-1">(</span>1<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-keyword">else</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Result4 = &lt;&lt;NOT MATCH&gt;&gt;"</span> &lt;&lt; <span class="org-constant">std</span>::endl;     
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text"> ======== EXPERIMENT 3 === Extract text =====
Result1 = 85619751
Result2 = 65658741
Result3 = &lt;&lt;NOT MATCH&gt;&gt;
Result4 = &lt;&lt;NOT MATCH&gt;&gt;
</pre>
</div>

<p>
<b>Experiment 4-A: Finding all regex matches</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ======== EXPERIMENT 4-A === Finding all regex matches  ======"</span><span class="org-rainbow-delimiters-depth-1">)</span>;      
<span class="org-function-name">std</span>::regex nregex<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"[0-9]+\\b"</span>, <span class="org-constant">std</span>::<span class="org-constant">regex</span>::ECMAScript<span class="org-rainbow-delimiters-depth-1">)</span>; 
<span class="org-function-name">std</span>::string line = <span class="org-string">" 565 923 100 -934  AABB56 0835"</span>;
<span class="org-function-name">std</span>::sregex_iterator it_beg<span class="org-rainbow-delimiters-depth-1">(</span>line.begin<span class="org-rainbow-delimiters-depth-2">()</span>, line.end<span class="org-rainbow-delimiters-depth-2">()</span>, nregex<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::sregex_iterator it_end;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" Number of matches = "</span> &lt;&lt; <span class="org-constant">std</span>::distance<span class="org-rainbow-delimiters-depth-1">(</span>it_beg, it_end<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0;
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">it</span>  = it_beg; it != it_end; it++<span class="org-rainbow-delimiters-depth-1">){</span> 
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; x["</span> &lt;&lt; i++ &lt;&lt; <span class="org-string">"] = "</span> &lt;&lt; it-&gt;str<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">======== EXPERIMENT 4-A === Finding all regex matches  ======
Number of matches = 6
=&gt; x[0] = 565
=&gt; x[1] = 923
=&gt; x[2] = 100
=&gt; x[3] = 934
=&gt; x[4] = 56
=&gt; x[5] = 0835

</pre>
</div>

<p>
<b>Experiment 4-B: Finding all regex matches</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ======== EXPERIMENT 4-B === Finding all regex matches  ======"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Matches 4 letters followed by 3 digits</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">first capture group 4 letters set, second capture group: 3 digits set </span>
<span class="org-function-name">std</span>::regex re<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"([A-Z]{4})([0-9]{3})"</span><span class="org-rainbow-delimiters-depth-1">)</span>;  
<span class="org-function-name">std</span>::string line = <span class="org-string">" ABCD367 XYAZ561 baa 341 MNPQ456 "</span>;
<span class="org-function-name">std</span>::sregex_iterator begin<span class="org-rainbow-delimiters-depth-1">(</span>line.begin<span class="org-rainbow-delimiters-depth-2">()</span>, line.end<span class="org-rainbow-delimiters-depth-2">()</span>, re<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::sregex_iterator end;
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">it</span>  = begin; it != end; it++<span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" capture[0] = "</span>   &lt;&lt; it-&gt;str<span class="org-rainbow-delimiters-depth-1">()</span> 
              &lt;&lt; <span class="org-string">" ; capture[1] = "</span> &lt;&lt; it-&gt;str<span class="org-rainbow-delimiters-depth-1">(</span>1<span class="org-rainbow-delimiters-depth-1">)</span>
              &lt;&lt; <span class="org-string">" ; capture[2] = "</span> &lt;&lt; it-&gt;str<span class="org-rainbow-delimiters-depth-1">(</span>2<span class="org-rainbow-delimiters-depth-1">)</span>
              &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">======== EXPERIMENT 4-B === Finding all regex matches  ======
capture[0] = ABCD367 ; capture[1] = ABCD ; capture[2] = 367
capture[0] = XYAZ561 ; capture[1] = XYAZ ; capture[2] = 561
capture[0] = MNPQ456 ; capture[1] = MNPQ ; capture[2] = 456
</pre>
</div>

<p>
<b>Experiment 4-C: Finding all regex matches</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ======== EXPERIMENT 4-C === Finding all regex matches range-based loop ==="</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Matches 4 letters followed by 3 digits</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">first capture group 4 letters set, second capture group: 3 digits set </span>
<span class="org-function-name">std</span>::regex re<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"([A-Z]{4})([0-9]{3})"</span><span class="org-rainbow-delimiters-depth-1">)</span>;  
<span class="org-function-name">std</span>::string line = <span class="org-string">" ABCD367 XYAZ561 baa 341 MNPQ456 "</span>;
<span class="org-function-name">std</span>::smatch matches;
<span class="org-function-name">std</span>::regex_search<span class="org-rainbow-delimiters-depth-1">(</span>line, matches, re<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">m</span> : matches <span class="org-rainbow-delimiters-depth-1">)</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt;&gt;&gt; "</span>   &lt;&lt; m &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">======== EXPERIMENT 4-C === Finding all regex matches range-based loop ===
=&gt;&gt;&gt; ABCD367
=&gt;&gt;&gt; ABCD
=&gt;&gt;&gt; 367
</pre>
</div>

<p>
<b>Experiment 5: Replace all matches</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ======== EXPERIMENT 5 === Replace matches  ======"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Matches 4 letters followed by 3 digits</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">first capture group 4 letters set, second capture group: 3 digits set </span>
<span class="org-function-name">std</span>::regex re<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"([A-Z]{4})([0-9]{3})"</span><span class="org-rainbow-delimiters-depth-1">)</span>;  
<span class="org-function-name">std</span>::string line = <span class="org-string">" ABCD367 XYAZ561 baa 341 MNPQ456 "</span>;
<span class="org-function-name">std</span>::string out = <span class="org-constant">std</span>::regex_replace<span class="org-rainbow-delimiters-depth-1">(</span>line, re, <span class="org-string">"{$1=$2} - "</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" out = "</span> &lt;&lt; out &lt;&lt; <span class="org-constant">std</span>::endl;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">======== EXPERIMENT 5 === Replace matches  ======
out =  {ABCD=367} -  {XYAZ=561} -  baa 341 {MNPQ=456} -  
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org7730dc5" class="outline-3">
<h3 id="org7730dc5"><span class="section-number-3">1.10</span> C++11 - Uniform Initialization</h3>
<div class="outline-text-3" id="text-1-10">
<p>
The C++11 uniform initialization feature allows classes, STL
containers (collections) and primitives values to be initialized in a
uniform way similar to vectors and C-arrays. 
</p>

<ul class="org-ul">
<li>Uniform initialization of primitive types:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span>    <span class="org-variable-name">x</span> <span class="org-rainbow-delimiters-depth-1">{}</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">x = 0</span>
<span class="org-type">double</span> <span class="org-variable-name">fd</span> <span class="org-rainbow-delimiters-depth-1">{}</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">fd = 0.0</span>
<span class="org-type">float</span>  <span class="org-variable-name">ff</span> <span class="org-rainbow-delimiters-depth-1">{}</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">ff = 0.0f</span>
<span class="org-type">bool</span>   <span class="org-variable-name">flag</span><span class="org-rainbow-delimiters-depth-1">{}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">flag = false = 0 </span>
</pre>
</div>

<ul class="org-ul">
<li>Uniform initialization of C-arrays</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-1">[]</span> <span class="org-rainbow-delimiters-depth-1">{</span>10, 20, 30<span class="org-rainbow-delimiters-depth-1">}</span>;  <span class="org-comment-delimiter">//  </span><span class="org-comment">int xs[] =  {10, 20, 30};</span>
<span class="org-type">double</span> <span class="org-variable-name">ys</span><span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">{</span>1.0<span class="org-rainbow-delimiters-depth-1">}</span>;     <span class="org-comment-delimiter">//  </span><span class="org-comment">double ys[] = {1.0};</span>
</pre>
</div>

<ul class="org-ul">
<li>Uniform initialization of pointers</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">double</span>* <span class="org-variable-name">fdptr</span><span class="org-rainbow-delimiters-depth-1">{}</span> ; <span class="org-comment-delimiter">// </span><span class="org-comment">fdptr = nullptr </span>
</pre>
</div>

<ul class="org-ul">
<li>Uniform initialization of STL containers:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::string s <span class="org-rainbow-delimiters-depth-1">{}</span>;                <span class="org-comment-delimiter">// </span><span class="org-comment">s = ""</span>
<span class="org-function-name">std</span>::string s <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-1">}</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">s = "Hello World"</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Vectors </span>
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> xs <span class="org-rainbow-delimiters-depth-1">{}</span>;                      
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> ys <span class="org-rainbow-delimiters-depth-1">{</span>2.0, 3.0, 4.0, 5.0<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> zs <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"apple"</span>, <span class="org-string">"orange"</span>, <span class="org-string">"grape"</span>, <span class="org-string">"banana"</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Lists</span>
<span class="org-function-name">std</span>::<span class="org-type">list</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>   xs <span class="org-rainbow-delimiters-depth-1">{}</span>;
<span class="org-function-name">std</span>::<span class="org-type">list</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>   ys<span class="org-rainbow-delimiters-depth-1">{</span>2.0, 3.0, 4.0, 5.0<span class="org-rainbow-delimiters-depth-1">}</span>;   
<span class="org-comment-delimiter">// </span><span class="org-comment">Sets </span>
<span class="org-function-name">std</span>::<span class="org-type">set</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    xs<span class="org-rainbow-delimiters-depth-1">{}</span>;
<span class="org-function-name">std</span>::<span class="org-type">set</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    ys <span class="org-rainbow-delimiters-depth-1">{</span>3.0, 4.0, 3.0, 10.0<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Unordered set </span>
<span class="org-function-name">std</span>::<span class="org-type">unordered_set</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>    xs<span class="org-rainbow-delimiters-depth-1">{}</span>;
<span class="org-function-name">std</span>::<span class="org-type">unordered_set</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">string</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> zs <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"apple"</span>, <span class="org-string">"orange"</span>, <span class="org-string">"grape"</span>, <span class="org-string">"banana"</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Maps, aka hash map, aka dictionary, aka hash table </span>
<span class="org-function-name">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string,<span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> prices <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"orange"</span>, 10.0<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"grapes"</span>, 25.12<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"apple"</span>, 4.12<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Initialization of C-structus POD - Plain Old Data</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">Point3D</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">double</span> <span class="org-variable-name">x</span>;
    <span class="org-type">double</span> <span class="org-variable-name">y</span>;
    <span class="org-type">double</span> <span class="org-variable-name">z</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Before C++11</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">---------------------------</span>
<span class="org-type">Point3D</span> <span class="org-variable-name">pa</span>;
pa.x = 10.0;
pa.y = 20.0;
pa.z = 35.0;

<span class="org-comment-delimiter">// </span><span class="org-comment">After C++11</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">---------------------------</span>
<span class="org-type">Point3D</span> <span class="org-variable-name">pb</span> <span class="org-rainbow-delimiters-depth-1">{</span>10.0, 20.0, 35.0<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">Point3D</span> <span class="org-variable-name">pc</span> = <span class="org-rainbow-delimiters-depth-1">{</span>10.0, 20.0, 35.0<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">C++ Vector - way 1</span>
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Point3D</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-rainbow-delimiters-depth-2">{</span> 20.0, 15.0, 5.0<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span> 10.0, 25.0, 12.4<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span>-14.0, 0.32, 51.43<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">C++ Vector - way 2 </span>
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Point3D</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
      Point3D<span class="org-rainbow-delimiters-depth-2">{</span> 20.0, 15.0, 5.0<span class="org-rainbow-delimiters-depth-2">}</span>
     ,Point3D<span class="org-rainbow-delimiters-depth-2">{</span> 10.0, 25.0, 12.4<span class="org-rainbow-delimiters-depth-2">}</span>
     ,Point3D<span class="org-rainbow-delimiters-depth-2">{</span>-14.0, 0.32, 51.43<span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">C++ Map Containers </span>
<span class="org-function-name">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-type">Point3D</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> locations = <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"City 1"</span>,    <span class="org-rainbow-delimiters-depth-3">{</span> 20.0, 15.0, 5.0<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>
    ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Somewhere"</span>, <span class="org-rainbow-delimiters-depth-3">{</span> 10.0, 25.0, 12.4<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>
    ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Nowhere"</span>,   <span class="org-rainbow-delimiters-depth-3">{</span>-14.0, 0.32, 51.43<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>     
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">or in more pleasant notation </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">C++ Map Containers </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">locations2</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-type">Point3D</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"City 1"</span>,    <span class="org-rainbow-delimiters-depth-3">{</span> 20.0, 15.0, 5.0<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>
    ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Somewhere"</span>, <span class="org-rainbow-delimiters-depth-3">{</span> 10.0, 25.0, 12.4<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>
    ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Nowhere"</span>,   <span class="org-rainbow-delimiters-depth-3">{</span>-14.0, 0.32, 51.43<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>     
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">//</span><span class="org-comment">--- Functions -------//</span>

<span class="org-type">Point3D</span> <span class="org-function-name">makeOriginPoint</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">return Point3D{0.0, 0.0, 0.0};</span>
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{</span>0.0, 0.0, 0.0<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Classes: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>: 
    <span class="org-function-name">A</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span>, <span class="org-type">double</span> <span class="org-variable-name">z</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>:
        m_x<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>,
        m_y<span class="org-rainbow-delimiters-depth-2">(</span>y<span class="org-rainbow-delimiters-depth-2">)</span>,
        m_z<span class="org-rainbow-delimiters-depth-2">(</span>z<span class="org-rainbow-delimiters-depth-2">)</span>,
        m_name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>      
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">auto</span> <span class="org-function-name">getX</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> m_x;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">auto</span> <span class="org-function-name">getY</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">return</span> m_y;<span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">auto</span> <span class="org-function-name">getZ</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">return</span> m_z;<span class="org-rainbow-delimiters-depth-2">}</span> 
<span class="org-function-name">private</span>:
    <span class="org-type">double</span> <span class="org-variable-name">m_x</span>;
    <span class="org-type">double</span> <span class="org-variable-name">m_y</span>;
    <span class="org-type">double</span> <span class="org-variable-name">m_z</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">void</span> <span class="org-function-name">display</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">A</span>&amp; <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"A ("</span> &lt;&lt; a.getX<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">" "</span> &lt;&lt; a.getY<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; a.getZ<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">")"</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-type">A</span> <span class="org-variable-name">instance1</span> <span class="org-rainbow-delimiters-depth-2">{</span>10.0, 20.0, 15.0, <span class="org-string">"unknown binary blob"</span><span class="org-rainbow-delimiters-depth-2">}</span>;  
    display<span class="org-rainbow-delimiters-depth-2">(</span>instance1<span class="org-rainbow-delimiters-depth-2">)</span>;
    display<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">{</span>10.0, 20.0, 15.0, <span class="org-string">"unknown binary blob"</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
References: 
</p>

<ul class="org-ul">
<li><a href="http://scottmeyers.blogspot.com/2015/09/thoughts-on-vagaries-of-c-initialization.html">The View from Aristeia: Thoughts on the Vagaries of C++ Initialization</a></li>
<li><a href="https://www.codeguru.com/cpp/cpp/article.php/c19081/C-2011-Uniform-Initialization.htm">C++ 2011: Uniform Initialization</a></li>
<li><a href="https://mbevin.wordpress.com/2012/11/16/uniform-initialization/">Lesson #3: Uniform Initialization | Mike's C++11 Blog</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/133688/is-c11-uniform-initialization-a-replacement-for-the-old-style-syntax">c++ - Is C++11 Uniform Initialization a replacement for the old style syntax? - Software Engineering Stack Exchange</a></li>
<li></li>

<li></li>
</ul>
</div>
</div>
<div id="outline-container-orgc268dd7" class="outline-3">
<h3 id="orgc268dd7"><span class="section-number-3">1.11</span> Iterator based loops and for-range based loops</h3>
<div class="outline-text-3" id="text-1-11">
</div>
<div id="outline-container-orgb51ccfb" class="outline-4">
<h4 id="orgb51ccfb"><span class="section-number-4">1.11.1</span> Iterator based loop</h4>
<div class="outline-text-4" id="text-1-11-1">
<p>
Loop over a vector: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> xs <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"Hello"</span>, <span class="org-string">"world"</span>, <span class="org-string">"C++"</span>, <span class="org-string">"HPC"</span>, <span class="org-string">"awesome"</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">iterator</span> <span class="org-variable-name">it</span> = xs.begin<span class="org-rainbow-delimiters-depth-2">()</span>; it != xs.end<span class="org-rainbow-delimiters-depth-2">()</span>; ++it<span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"word = '"</span> &lt;&lt; *it &lt;&lt; <span class="org-string">"' size = "</span> &lt;&lt; it-&gt;size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Output: </span>
<span class="org-comment">   word = 'Hello' size = 5</span>
<span class="org-comment">   word = 'world' size = 5</span>
<span class="org-comment">   word = 'C++' size = 3</span>
<span class="org-comment">   word = 'HPC' size = 3</span>
<span class="org-comment">   word = 'awesome' size = 7</span>
<span class="org-comment">   &gt;&gt; </span>
<span class="org-comment"> */</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">=== OR =====//</span>

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = xs.begin<span class="org-rainbow-delimiters-depth-2">()</span>; it != xs.end<span class="org-rainbow-delimiters-depth-2">()</span>; ++it<span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"word = '"</span> &lt;&lt; *it &lt;&lt; <span class="org-string">"' size = "</span> &lt;&lt; it-&gt;size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Output: </span>
<span class="org-comment">        word = 'Hello' size = 5</span>
<span class="org-comment">        word = 'world' size = 5</span>
<span class="org-comment">        word = 'C++' size = 3</span>
<span class="org-comment">        word = 'HPC' size = 3</span>
<span class="org-comment">        word = 'awesome' size = 7</span>
<span class="org-comment"> */</span>
</pre>
</div>

<p>
Loop over a deque: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">ds</span> = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"Physics"</span>, <span class="org-string">"C++"</span>, <span class="org-string">"STL"</span>, <span class="org-string">"Math"</span>, <span class="org-string">"Algebra"</span>, <span class="org-string">"Electronics"</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">iterator</span> <span class="org-variable-name">it</span> = ds.begin<span class="org-rainbow-delimiters-depth-2">()</span>; it != ds.end<span class="org-rainbow-delimiters-depth-2">()</span>; ++it<span class="org-rainbow-delimiters-depth-1">){</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"word = '"</span> &lt;&lt; *it &lt;&lt; <span class="org-string">"' size = "</span> &lt;&lt; it-&gt;size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Or: </span>
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = ds.begin<span class="org-rainbow-delimiters-depth-2">()</span>; it != ds.end<span class="org-rainbow-delimiters-depth-2">()</span>; ++it<span class="org-rainbow-delimiters-depth-1">){</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"word = '"</span> &lt;&lt; *it &lt;&lt; <span class="org-string">"' size = "</span> &lt;&lt; it-&gt;size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Output: </span>
<span class="org-comment">   word = 'Physics' size = 7</span>
<span class="org-comment">   word = 'C++' size = 3</span>
<span class="org-comment">   word = 'STL' size = 3</span>
<span class="org-comment">   word = 'Math' size = 4</span>
<span class="org-comment">   word = 'Algebra' size = 7</span>
<span class="org-comment">   word = 'Electronics' size = 11</span>
<span class="org-comment"> */</span>

</pre>
</div>

<p>
Loop over a list: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Struct is a class with everything public </span>
<span class="org-keyword">struct</span> <span class="org-type">Waypoint</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>;
    <span class="org-type">double</span>      <span class="org-variable-name">lat</span>;
    <span class="org-type">double</span>      <span class="org-variable-name">lon</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">This constructor is necessary for storing this object</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">in STL collections/containers </span>
    <span class="org-function-name">Waypoint</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
    <span class="org-function-name">Waypoint</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-type">double</span> <span class="org-variable-name">lat</span>, <span class="org-type">double</span> <span class="org-variable-name">lon</span><span class="org-rainbow-delimiters-depth-2">)</span>:
            name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>, lat<span class="org-rainbow-delimiters-depth-2">(</span>lat<span class="org-rainbow-delimiters-depth-2">)</span>, lon<span class="org-rainbow-delimiters-depth-2">(</span>lon<span class="org-rainbow-delimiters-depth-2">){}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; <span class="org-keyword">auto</span> wp = Waypoint<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Paris"</span>, 48.23, 22.12<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; wp.name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Paris"</span>
&gt;&gt; wp.lat
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 48.230000
&gt;&gt; wp.lon
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 22.120000
&gt;&gt; 
&gt;&gt; 

<span class="org-keyword">auto</span> waypoints = <span class="org-constant">std</span>::<span class="org-type">list</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Waypoint</span><span class="org-rainbow-delimiters-depth-1">&gt;{}</span>;
waypoints.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Paris"</span>, 48.8566, 2.3522<span class="org-rainbow-delimiters-depth-1">)</span>;
waypoints.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Tokyo"</span>, 35.6895, 139.6917<span class="org-rainbow-delimiters-depth-1">)</span>;
waypoints.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Beijing"</span>, 39.9042, 116.4074<span class="org-rainbow-delimiters-depth-1">)</span>;
waypoints.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Cape Town"</span>, -33.9249, 18.4241<span class="org-rainbow-delimiters-depth-1">)</span>;
waypoints.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Buenos Aires"</span>, -34.6037, -58.3816<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-1">(</span>2<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = waypoints.begin<span class="org-rainbow-delimiters-depth-2">()</span>; it != waypoints.end<span class="org-rainbow-delimiters-depth-2">()</span>; ++it<span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::left  &lt;&lt; it-&gt;name
                          &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; it-&gt;lat
                          &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; it-&gt;lon
                          &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">Paris                    48.86           2.35
Tokyo                    35.69         139.69
Beijing                  39.90         116.41
Cape Town               -33.92          18.42
Buenos Aires            -34.60         -58.38
</pre>
</div>

<p>
Loop over a map:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">values</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
      <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"x"</span>,  2.1023<span class="org-rainbow-delimiters-depth-2">}</span>
     ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"y"</span>,  sqrt<span class="org-rainbow-delimiters-depth-3">(</span>2<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>
     ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"e"</span>,  exp<span class="org-rainbow-delimiters-depth-3">(</span>1<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>
     ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"pi"</span>, 3.1415<span class="org-rainbow-delimiters-depth-2">}</span>
     ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"3/4"</span>, 3.0 / 4.0<span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-1">(</span>2<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::string, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>::<span class="org-type">iterator</span> <span class="org-variable-name">it</span> = values.begin<span class="org-rainbow-delimiters-depth-2">()</span>; it != values.end<span class="org-rainbow-delimiters-depth-2">()</span>; it++<span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::left  &lt;&lt; it-&gt;first
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; it-&gt;second
                  &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">OR:</span>
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = values.begin<span class="org-rainbow-delimiters-depth-2">()</span>; it != values.end<span class="org-rainbow-delimiters-depth-2">()</span>; it++<span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::left  &lt;&lt; it-&gt;first
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; it-&gt;second
                  &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Output: </span>
<span class="org-comment">   3/4   0.75</span>
<span class="org-comment">   e     2.72</span>
<span class="org-comment">   pi    3.14</span>
<span class="org-comment">   x     2.10</span>
<span class="org-comment">   y     1.41</span>
<span class="org-comment"> */</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf27af6e" class="outline-4">
<h4 id="orgf27af6e"><span class="section-number-4">1.11.2</span> For-range based loops</h4>
<div class="outline-text-4" id="text-1-11-2">
<p>
C++11 and new standards allow to iterate over any STL container or
class with methods (member functions) .begin() or .end() using a
simpler and cleaner syntax than the old iterator loop syntax.
</p>

<p>
<b>Loop over literals</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Possible since C++11</span>
&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: <span class="org-rainbow-delimiters-depth-2">{</span>10, 20, 40, 50, 60<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-1">}</span>
 x = 10
 x = 20
 x = 40
 x = 50
 x = 60

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">word</span>: <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"C++"</span>, <span class="org-string">"C++11"</span>, <span class="org-string">"Real Time"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" word = "</span> &lt;&lt; word &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-1">}</span>
 word = C++
 word = C++11
 word = Real Time

 &gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">word</span>: <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"C++"</span>, <span class="org-string">"C++11"</span>, <span class="org-string">"Real Time"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" word = "</span>+ word
                  &lt;&lt; <span class="org-string">"  size = "</span> &lt;&lt; word.size<span class="org-rainbow-delimiters-depth-2">()</span>
                  &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-1">}</span>
 word = C++  size = 3
 word = C++11  size = 5
 word = Real Time  size = 9
</pre>
</div>


<p>
<b>Loop over a vector:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span> xs <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"Hello"</span>, <span class="org-string">"world"</span>, <span class="org-string">"C++"</span>, <span class="org-string">"HPC"</span>, <span class="org-string">"awesome"</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Use: const auto&amp;  to avoid uncessary copies, use auto&amp; if there is modification of x.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">The const keyword will generate a compiler error if there is </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">any attempt to modify the value of x. </span>
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: xs<span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"word = '"</span> &lt;&lt; x &lt;&lt; <span class="org-string">"' size = "</span> &lt;&lt; x.size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Output: </span>
<span class="org-comment">   word = 'Hello' size = 5</span>
<span class="org-comment">   word = 'world' size = 5</span>
<span class="org-comment">   word = 'C++' size = 3</span>
<span class="org-comment">   word = 'HPC' size = 3</span>
<span class="org-comment">   word = 'awesome' size = 7</span>
<span class="org-comment"> *---------------*/</span>

</pre>
</div>

<p>
<b>Loop over a list:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Struct is a class with everything public </span>
<span class="org-keyword">struct</span> <span class="org-type">Waypoint</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>;
        <span class="org-type">double</span>      <span class="org-variable-name">lat</span>;
        <span class="org-type">double</span>      <span class="org-variable-name">lon</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">This constructor is necessary for storing this object</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">in STL collections/containers </span>
        <span class="org-function-name">Waypoint</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
        <span class="org-function-name">Waypoint</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-type">double</span> <span class="org-variable-name">lat</span>, <span class="org-type">double</span> <span class="org-variable-name">lon</span><span class="org-rainbow-delimiters-depth-2">)</span>:
                name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>, lat<span class="org-rainbow-delimiters-depth-2">(</span>lat<span class="org-rainbow-delimiters-depth-2">)</span>, lon<span class="org-rainbow-delimiters-depth-2">(</span>lon<span class="org-rainbow-delimiters-depth-2">){}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">waypoints</span> = <span class="org-constant">std</span>::<span class="org-type">list</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Waypoint</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
       <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Paris"</span>, 48.8566, 2.3522<span class="org-rainbow-delimiters-depth-2">}</span>
      ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Tokyo"</span>, 35.6895, 139.6917<span class="org-rainbow-delimiters-depth-2">}</span>
      ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Beijing"</span>, 39.9042, 116.4074<span class="org-rainbow-delimiters-depth-2">}</span>
      ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Cape Town"</span>, -33.9249, 18.4241<span class="org-rainbow-delimiters-depth-2">}</span>
      ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"Buenos Aires"</span>, -34.6037, -58.3816<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-1">(</span>2<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">wp</span>: waypoints<span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::left  &lt;&lt; wp.name
                          &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; wp.lat
                          &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; wp.lon 
                          &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Ouput: 
</p>

<div class="org-src-container">
<pre class="src src-text">Paris                    48.86           2.35
Tokyo                    35.69         139.69
Beijing                  39.90         116.41
Cape Town               -33.92          18.42
Buenos Aires            -34.60         -58.38
</pre>
</div>

<p>
<b>Loop over a map</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">values</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
      <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"x"</span>,  2.1023<span class="org-rainbow-delimiters-depth-2">}</span>
     ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"y"</span>,  sqrt<span class="org-rainbow-delimiters-depth-3">(</span>2<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>
     ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"e"</span>,  exp<span class="org-rainbow-delimiters-depth-3">(</span>1<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>
     ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"pi"</span>, 3.1415<span class="org-rainbow-delimiters-depth-2">}</span>
     ,<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"3/4"</span>, 3.0 / 4.0<span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-1">(</span>3<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">p</span>: values<span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::left  &lt;&lt; p.first
                  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; p.second
                  &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">/** </span><span class="org-comment">Output: </span>
<span class="org-comment">   3/4  0.750</span>
<span class="org-comment">   e    2.718</span>
<span class="org-comment">   pi   3.142</span>
<span class="org-comment">   x    2.102</span>
<span class="org-comment">   y    1.414</span>
<span class="org-comment"> *==============*/</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc14b915" class="outline-3">
<h3 id="orgc14b915"><span class="section-number-3">1.12</span> C++11 - Scoped Enum</h3>
<div class="outline-text-3" id="text-1-12">
<p>
Scoped enumerations are a more type-safe alternative to the old
C-enums as it has several problems realated to namespace conflicts and
implicit conversions that can introduce bugs hard to catch and reason
about. 
</p>

<p>
Syntax: 
</p>

<ul class="org-ul">
<li>Simple scoped enum class</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">Color</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-variable-name">white</span>,
   <span class="org-variable-name">black</span>,
   <span class="org-variable-name">yellow</span>,
   <span class="org-variable-name">red</span>,
   <span class="org-variable-name">blue</span>,
<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; <span class="org-constant">Color</span>::white
<span class="org-rainbow-delimiters-depth-1">(</span>Color<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Color</span>::white<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; <span class="org-constant">Color</span>::blue
<span class="org-rainbow-delimiters-depth-1">(</span>Color<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Color</span>::blue<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; <span class="org-constant">Color</span>::yellow
<span class="org-rainbow-delimiters-depth-1">(</span>Color<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Color</span>::yellow<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 2
&gt;&gt; <span class="org-constant">Color</span>::red
<span class="org-rainbow-delimiters-depth-1">(</span>Color<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Color</span>::red<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 3
&gt;&gt; 

&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-constant">Color</span>::blue<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-constant">Color</span>::white<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-constant">Color</span>::yellow<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 2
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Scoped enum with hexadecimal error codes.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">ErrorCode</span>: <span class="org-constant">std</span>::<span class="org-type">uint32_t</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-variable-name">tankNotFilled</span> = 0xff,
   <span class="org-variable-name">missingSupply</span> = 0x2f,
   <span class="org-variable-name">lowBattery</span>    = 0x2a,
   <span class="org-variable-name">unknown</span>       = 0x24                                         
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Scoped enums with chars</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">ErrorCodeLetter</span>: <span class="org-type">char</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-variable-name">tankNotFilled</span> = <span class="org-string">'x'</span>,
   <span class="org-variable-name">missingSupply</span> = <span class="org-string">'y'</span>,
   <span class="org-variable-name">lowBattery</span>    = <span class="org-string">'a'</span>,
   <span class="org-variable-name">unknown</span>       = <span class="org-string">'k'</span>                                         
<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; <span class="org-constant">ErrorCodeLetter</span>::tankNotFilled
<span class="org-rainbow-delimiters-depth-1">(</span>ErrorCodeLetter<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">ErrorCodeLetter</span>::tankNotFilled<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> 120
&gt;&gt; <span class="org-constant">ErrorCodeLetter</span>::missingSupply
<span class="org-rainbow-delimiters-depth-1">(</span>ErrorCodeLetter<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">ErrorCodeLetter</span>::missingSupply<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> 121
&gt;&gt; <span class="org-constant">ErrorCodeLetter</span>::unknown
<span class="org-rainbow-delimiters-depth-1">(</span>ErrorCodeLetter<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">ErrorCodeLetter</span>::unknown<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> 107
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-constant">ErrorCodeLetter</span>::unknown<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'k'</span>
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-constant">ErrorCodeLetter</span>::missingSupply<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'y'</span>
&gt;&gt; 
</pre>
</div>


<p>
<b>More Exhaustive Example:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">MachineStatus</span>: <span class="org-constant">std</span>::<span class="org-type">uint32_t</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-variable-name">running</span> = 0xf5,
   <span class="org-variable-name">iddle</span>   = 0x2a,
   <span class="org-variable-name">waiting</span> = 0x35,
   <span class="org-variable-name">failure</span> = 0x24                                         
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Example: CERN's root shell. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">MachineStatus</span>::running
<span class="org-rainbow-delimiters-depth-1">(</span>MachineStatus<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">MachineStatus</span>::running<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 245
&gt;&gt; <span class="org-constant">MachineStatus</span>::iddle
<span class="org-rainbow-delimiters-depth-1">(</span>MachineStatus<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">MachineStatus</span>::iddle<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 42
&gt;&gt; <span class="org-constant">MachineStatus</span>::waiting
<span class="org-rainbow-delimiters-depth-1">(</span>MachineStatus<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">MachineStatus</span>::waiting<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 53
&gt;&gt; <span class="org-constant">MachineStatus</span>::failure
<span class="org-rainbow-delimiters-depth-1">(</span>MachineStatus<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">MachineStatus</span>::failure<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 36
&gt;&gt; 

&gt;&gt; <span class="org-keyword">auto</span> status = <span class="org-constant">MachineStatus</span>::running
<span class="org-rainbow-delimiters-depth-1">(</span>MachineStatus<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">MachineStatus</span>::running<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 245

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Machine status = "</span> &lt;&lt; <span class="org-constant">std</span>::hex &lt;&lt; <span class="org-string">"0x"</span> &lt;&lt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::uint32_t<span class="org-rainbow-delimiters-depth-1">&gt;(</span>status<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-type">Machine</span> <span class="org-variable-name">status</span> = 0xf5
&gt;&gt; 
&gt;&gt; 

&gt;&gt; status = <span class="org-constant">MachineStatus</span>::iddle 
<span class="org-rainbow-delimiters-depth-1">(</span>MachineStatus<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">MachineStatus</span>::iddle<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 42
&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Machine status = "</span> &lt;&lt; <span class="org-constant">std</span>::hex &lt;&lt; <span class="org-string">"0x"</span> &lt;&lt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::uint32_t<span class="org-rainbow-delimiters-depth-1">&gt;(</span>status<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-type">Machine</span> <span class="org-variable-name">status</span> = 0x2a
&gt;&gt; 

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>status == <span class="org-constant">MachineStatus</span>::iddle<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Machine is iddle"</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">Machine</span> <span class="org-type">is</span> <span class="org-variable-name">iddle</span>
&gt;&gt; 

&gt;&gt; status = <span class="org-constant">MachineStatus</span>::running
<span class="org-rainbow-delimiters-depth-1">(</span>MachineStatus<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">MachineStatus</span>::running<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 245
&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>status == <span class="org-constant">MachineStatus</span>::running<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Machine is running"</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">Machine</span> <span class="org-type">is</span> <span class="org-variable-name">running</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::uint32_t<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-constant">MachineStatus</span>::running<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 245
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::uint32_t<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-constant">MachineStatus</span>::iddle<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 42
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::uint32_t<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-constant">MachineStatus</span>::iddle<span class="org-rainbow-delimiters-depth-1">)</span> == 0x2a
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>MachineStatus<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x2a<span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">(</span>MachineStatus<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">MachineStatus</span>::iddle<span class="org-rainbow-delimiters-depth-1">)</span> : <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 42
&gt;&gt; 
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>MachineStatus<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x2a<span class="org-rainbow-delimiters-depth-1">)</span> == <span class="org-constant">MachineStatus</span>::iddle
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-orga841f0b" class="outline-3">
<h3 id="orga841f0b"><span class="section-number-3">1.13</span> Functor Function-Object and higher order functions</h3>
<div class="outline-text-3" id="text-1-13">
<p>
Functor is any object which behaves like a function and callable like
a function. Unlike C++ ordinary functions, functors can have internal
state and change its internal data as well.
</p>

<p>
Functors are implementing in C++ by overloading the function
application operator. 
</p>

<p>
The code in the file: <a href="src/cpp-functor.cpp">file:src/cpp-functor.cpp</a> shows an
exhaustive example about how to implement, use functors and implement
client code using dynamic polymorphism (aka subtyping or inheritance),
static polymorphism (aka template metaprogramming) and C++11's
function type <span class="underline">std::function</span>.
</p>

<p>
Example: 
</p>
<ul class="org-ul">
<li>File:            <a href="src/cpp-functor.cpp">file:src/cpp-functor.cpp</a></li>
<li>Online Compiler: <a href="http://rextester.com/VGE78113">http://rextester.com/VGE78113</a></li>

<li>Math functor interface class representing a general math function.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">IMathFunctor</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-comment-delimiter">// </span><span class="org-comment">Pure virtual function</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; const -&gt; Means that the function cannot change the object internal state.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; (= 0) -&gt; Means abstract member function or abstract method.</span>
        <span class="org-keyword">virtual</span> <span class="org-type">double</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> = 0;
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">IMathFunctor</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Linear Function "C++ functor." - function-object</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Linear Function "C++ functor." - function-object </span>
<span class="org-comment"> *   LinFun(x) = A * x + B</span>
<span class="org-comment"> */</span>
<span class="org-keyword">class</span> <span class="org-type">LinFun</span>: <span class="org-keyword">public</span> <span class="org-type">IMathFunctor</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
        <span class="org-comment-delimiter">// </span><span class="org-comment">Linear coefficient or line slope </span>
        <span class="org-type">double</span> <span class="org-variable-name">_a</span>; 
        <span class="org-type">double</span> <span class="org-variable-name">_b</span>;
<span class="org-function-name">public</span>:
        <span class="org-function-name">LinFun</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-2">)</span>: _a<span class="org-rainbow-delimiters-depth-2">(</span>a<span class="org-rainbow-delimiters-depth-2">)</span>, _b<span class="org-rainbow-delimiters-depth-2">(</span>b<span class="org-rainbow-delimiters-depth-2">){}</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">getA</span><span class="org-rainbow-delimiters-depth-2">()</span>             -&gt; <span class="org-type">double</span>   <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> _a;<span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">setA</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">)</span>         -&gt; <span class="org-type">void</span>     <span class="org-rainbow-delimiters-depth-2">{</span> _a = a; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">getB</span><span class="org-rainbow-delimiters-depth-2">()</span>             -&gt; <span class="org-type">double</span>   <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> _b;<span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">setB</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-2">)</span>         -&gt; <span class="org-type">void</span>     <span class="org-rainbow-delimiters-depth-2">{</span> _b = b; <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Function-call operator =&gt; Makes this object callable</span>
        <span class="org-comment-delimiter">//</span><span class="org-comment">------------------------------</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">double operator()(double x)  -&gt; double   { return _a * x + _b;}  </span>
        <span class="org-type">double</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> _a * x + _b;<span class="org-rainbow-delimiters-depth-2">}</span>    
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Function linear object - modelling a linear function 3 * x + 4.0 </span>
<span class="org-type">LinFun</span> <span class="org-variable-name">fun1</span><span class="org-rainbow-delimiters-depth-1">(</span>3.0, 4.0<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"a = "</span> &lt;&lt; fun1.getA<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-string">" ; b = "</span> &lt;&lt; fun1.getB<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; nl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"fun1(3.0) = "</span> &lt;&lt; fun1<span class="org-rainbow-delimiters-depth-1">(</span>3.0<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; nl;  
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"fun1(4.0) = "</span> &lt;&lt; fun1<span class="org-rainbow-delimiters-depth-1">(</span>4.0<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; nl;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">a = 3 ; b = 4
fun1(3.0) = 13
fun1(4.0) = 16
fun1(5.0) = 19
</pre>
</div>


<p>
Higher order functions (functions that calls or return functions) can
be implemented using dynamic polymorphis or inheritance; static
polymorphism, also known as template metaprogramming and using the
type std::function from C++11.
</p>


<ul class="org-ul">
<li><b>Higher order function using dynamic polymorphism</b>
(inheritance). This function only accepts implementations of
IMathFunctor and cannot worth with an arbitrary function-object,
ordinary functions or C++11 lambda function. Another drawback is
the runtime overhead of virtual function-calls.</li>
</ul>

<p>
Example:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">tabulateDynamic</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">IMathFunctor</span>&amp; <span class="org-variable-name">fun</span>, <span class="org-type">double</span> <span class="org-variable-name">start</span>, <span class="org-type">double</span> <span class="org-variable-name">stop</span>, <span class="org-type">double</span> <span class="org-variable-name">step</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span> = start; x &lt;= stop ; x += step<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; fun<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-cpp">tabulatDynamic<span class="org-rainbow-delimiters-depth-1">(</span>fun1, 0.0, 5.0, 1.0<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Sample Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">-----&gt; Tabulating fun1
    0.000     4.000
    1.000     7.000
    2.000    10.000
    3.000    13.000
    4.000    16.000
    5.000    19.000
</pre>
</div>

<ul class="org-ul">
<li><b>Higher order function using static polymorphism</b> - The advantage
of this function is that it can work with any callable object like
functors (function-objects), ordinary functions and C++11 lambda
functions. Another benefit is the lower runtime overhead than the
implementation using dynamic polymorphism. For this case, the
runtime cost of dynamic polymorphism is not significant, however it
can become noticeable on large scale computation or high
performance computations.</li>

<li>Example:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">tabulateStatic</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Function</span>&amp; <span class="org-variable-name">fun</span>, <span class="org-type">double</span> <span class="org-variable-name">start</span>, <span class="org-type">double</span> <span class="org-variable-name">stop</span>, <span class="org-type">double</span> <span class="org-variable-name">step</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span> = start; x &lt;= stop ; x += step<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; fun<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" -----&gt; Tabulating fun1"</span> &lt;&lt; nl;
tabulateStatic<span class="org-rainbow-delimiters-depth-1">(</span>fun1, 0.0, 5.0, 1.0<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" -----&gt; Tabulating fun2"</span> &lt;&lt; nl;
tabulateStatic<span class="org-rainbow-delimiters-depth-1">(</span>fun2, 0.0, 5.0, 1.0<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>


<ul class="org-ul">
<li><b>Higher order function using the C++11 type std::function</b> - The type
std::function provides type erasure and can work with any functor,
ordinary function and C++11 lambda functions, in addition it also
allows all those types of functions to be stored in STL containers.</li>
</ul>

<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">tabulateLambdaList</span><span class="org-rainbow-delimiters-depth-1">(</span>
      <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">funlist</span>
     ,<span class="org-type">double</span> <span class="org-variable-name">start</span>
     ,<span class="org-type">double</span> <span class="org-variable-name">stop</span>
     ,<span class="org-type">double</span> <span class="org-variable-name">step</span>
     <span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span> = start; x &lt;= stop ; x += step<span class="org-rainbow-delimiters-depth-2">){</span>
             <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>10<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; x;
             <span class="org-comment-delimiter">// </span><span class="org-comment">const auto&amp; is used for avoid uncessary copies </span>
             <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">fun</span>: funlist<span class="org-rainbow-delimiters-depth-3">)</span>
                     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>10<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; fun<span class="org-rainbow-delimiters-depth-3">(</span>x<span class="org-rainbow-delimiters-depth-3">)</span>;
             <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage:
</p>

<div class="org-src-container">
<pre class="src src-cpp">tabulateLambdaList<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">{</span>fun1, fun2, exp, ordinaryFunction<span class="org-rainbow-delimiters-depth-2">}</span>, 0.0, 5.0, 1.0<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Output:
</p>

<div class="org-src-container">
<pre class="src src-text">  x         fun1     fun2      exp      ordinaryFunction
0.000     4.000     4.000     1.000     0.000
1.000     7.000     9.000     2.718     3.000
2.000    10.000    18.000     7.389     6.000
3.000    13.000    31.000    20.086     9.000
4.000    16.000    48.000    54.598    12.000
5.000    19.000    69.000   148.413    15.000
</pre>
</div>

<p>
Compilation of <a href="src/cpp-functor.cpp">file:src/cpp-functor.cpp</a> 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ cpp-functor.cpp -o <span class="org-keyword">cpp-functor.bin</span> -g -std=c++11 -Wall -Wextra &amp;&amp;
</pre>
</div>

<p>
Complete program output of <a href="src/cpp-functor.cpp">file:src/cpp-functor.cpp</a> 
</p>

<div class="org-src-container">
<pre class="src src-sh">./cpp-functor.bin

a = 3 ; b = 4
<span class="org-function-name">fun1</span>(3.0) = 13
<span class="org-function-name">fun1</span>(4.0) = 16
<span class="org-function-name">fun1</span>(5.0) = 19
=======================
a = 2 ; b = 3 ; c = 4
<span class="org-function-name">fun2</span>(3.0) = 31
<span class="org-function-name">fun2</span>(4.0) = 48
<span class="org-function-name">fun2</span>(5.0) = 69
======= [1] Client Code using dynamic polymorphism  ================
 -----&gt; Tabulating fun1
     0.000     4.000
     1.000     7.000
     2.000    10.000
     3.000    13.000
     4.000    16.000
     5.000    19.000
 -----&gt; Tabulating fun2
     0.000     4.000
     1.000     9.000
     2.000    18.000
     3.000    31.000
     4.000    48.000
     5.000    69.000
======= [2] Client Code using dynamic polymorphism  ================
     0.000     4.000     4.000
     1.000     7.000     9.000
     2.000    10.000    18.000
     3.000    13.000    31.000
     4.000    16.000    48.000
     5.000    19.000    69.000
======= Client Code using static polymorphism (template)  ================
 -----&gt; Tabulating fun1
     0.000     4.000
     1.000     7.000
     2.000    10.000
     3.000    13.000
     4.000    16.000
     5.000    19.000
 -----&gt; Tabulating fun2
     0.000     4.000
     1.000     9.000
     2.000    18.000
     3.000    31.000
     4.000    48.000
     5.000    69.000
 -----&gt; Tabulating lambda <span class="org-keyword">function</span> <span class="org-function-name">f</span>(x) = x * x
     0.000     0.000
     1.000     1.000
     2.000     4.000
     3.000     9.000
     4.000    16.000
     5.000    25.000
 -----&gt; Tabulating ordinary <span class="org-keyword">function</span> <span class="org-function-name">f</span>(x) = 3 * x
     0.000     0.000
     1.000     3.000
     2.000     6.000
     3.000     9.000
     4.000    12.000
     5.000    15.000
 -----&gt; Tabulating ordinary <span class="org-keyword">function</span> <span class="org-function-name">f</span>(x) = exp(x)
     0.000     1.000
     1.000     2.718
     2.000     7.389
     3.000    20.086
     4.000    54.598
     5.000   148.413
======= Client Code using C++11 lambda std::<span class="org-keyword">function</span>  ================
     0.000     4.000     4.000     1.000     0.000
     1.000     7.000     9.000     2.718     3.000
     2.000    10.000    18.000     7.389     6.000
     3.000    13.000    31.000    20.086     9.000
     4.000    16.000    48.000    54.598    12.000
     5.000    19.000    69.000   148.413    15.000
</pre>
</div>
</div>
</div>

<div id="outline-container-org9b101be" class="outline-3">
<h3 id="org9b101be"><a id="ID-02be1a97-c100-44ce-ad76-63835818d406"></a><span class="section-number-3">1.14</span> Lambda Expressions</h3>
<div class="outline-text-3" id="text-1-14">
</div>
<div id="outline-container-org0d4fc14" class="outline-4">
<h4 id="org0d4fc14"><span class="section-number-4">1.14.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-14-1">
<p>
Lambda expressions, also known as lambda functions or lambda
abstractions, are ubiquitous in functional programming languages such
as Haskell, OCaml, Scala and Scheme. They were by introduced in a
theoretical way by Alonzo Church in the lambda calculus. Lisp was
first programming language to use lambda functions and now this
function programming feature has made its way into mainstream and has
arrived to C# (Cshap), Java 8 and C++11.
</p>

<p>
In C++, Lambda functions are not ordinary functions, actually, they
are special function-objects or "C++ functors". Lambda abstractions
can be passed as arguments to any function; returned from functions;
can have state and also they can be defined locally at the call-site
simplifying all the boilerplate code necessary to pass a function to
callbacks, event handlers and higher order functions.
</p>

<p>
Summary:
</p>

<ul class="org-ul">
<li>Lambda functions were introduced in C++11. Before C++11 lambdas
were available as Boost.Lambda.</li>

<li>Lambda functions can be:
<ul class="org-ul">
<li>returned from functions.</li>
<li>be passed as function parameters.</li>
<li>Can be stored in data structures.</li>
<li>Hold state and capture variables (closure).</li>
<li>Non-capturing lambdas can be converted to function pointers what
is useful with old C-APIs.</li>
</ul></li>

<li>Lambda turns C++11 is a <b>game changer</b> and turns C++ into an
quasi-functional programming language.</li>

<li>Practical Use Cases:
<ul class="org-ul">
<li>Callbacks</li>
<li>Higher order functions</li>
<li>Simplify design patterns</li>
<li>Asynchronous code</li>
<li>Create functions at runtime.</li>
</ul></li>
</ul>

<p>
<b>Main parts</b> 
</p>

<ul class="org-ul">
<li>Capture list between square brackets <code>[ ]</code></li>
<li>Argument list between parenthesis <code>()</code></li>
<li>Function body between curly braces <code>{}</code></li>
</ul>

<p>
Syntax: 
</p>

<div class="org-src-container">
<pre class="src src-text">[capture](parameters) -&gt; return-type {body}
</pre>
</div>

<p>
Some lambda functions: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">fn</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> n * 10; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Test in CERN's ROOT REPL</span>
&gt;&gt; <span class="org-keyword">auto</span> fn = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> n * 10; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>lambda<span class="org-rainbow-delimiters-depth-2">)</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f5e578f2010
&gt;&gt; 

&gt;&gt; <span class="org-keyword">auto</span> fn = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> n * 10; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>lambda<span class="org-rainbow-delimiters-depth-2">)</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f5e578f2010
&gt;&gt; 
</pre>
</div>


<p>
<b>Parts of a C++'s lambda expression:</b>  - (<a href="https://msdn.microsoft.com/en-us/library/dd293608.aspx">Microsoft Inc. Lambda C++</a>)
</p>

<ol class="org-ol">
<li>Capture clause - Specifies captured variables (closure).
<ul class="org-ul">
<li><code>[ ]</code> - Empty capture clause means that no variable from escope
is captured.</li>
<li><code>[x, y]</code>- The variables x and y are captured by value and the
the lambda body will get a copy of x and y. They cannot be
modified in the body of the lambda expression.</li>
<li><code>[&amp;x , y]</code> - The variable x is captured by reference and y by
value, therefore x can be modified in the body of the lambda
expression and y cannot.</li>
<li><code>[&amp;]</code> - Capture all variables used in the lambda's body by
reference.</li>
<li><code>[=]</code>- Captures all variables used in the body by value
(copy). The variables cannot be modifed as they are passed by
value.</li>
<li><code>[=, &amp;blob]</code>- The variable blob is captured by reference and all
other variables are captured by value (copy).</li>
<li><code>[this]</code> - Captures the "this" pointer of the enclosing class.</li>
</ul></li>

<li>Parameter list (Optional)- Parameters, aka arguments, of the lambda expression.</li>
<li>Mutable specification (optional)</li>
<li>exception-specification (optional)</li>
<li>trailing return type (optional)</li>
<li>lambda-body - The body can access variables such as:
<ul class="org-ul">
<li>Lambda parameters passed between parenthesis:  <code>(int x)</code></li>
<li>Captured variables from the enclosing scope.</li>
<li>Global variables.</li>
<li>Class data members if the lambda expression is defined inside a
class.</li>
</ul></li>
</ol>

<div class="org-src-container">
<pre class="src src-text">--
            (1)  (2)    (3)       (4)         (5)
               |    |         |            |           |
              ...  ....  .....+....  ...+....     ......
              [ ]  ( )  mutable  throw()  -&gt; int
              {                                                   
                // (6)                                              
                // Lambda body 
                int n = x + y;
                x = y;
                y  = n;
                return n;
              }
</pre>
</div>
</div>
</div>

<div id="outline-container-org4ef5110" class="outline-4">
<h4 id="org4ef5110"><span class="section-number-4">1.14.2</span> <span class="todo TODO">TODO</span> Basic Examples</h4>
<div class="outline-text-4" id="text-1-14-2">
<p>
<b>Proof-of-concept code</b> 
</p>

<ul class="org-ul">
<li>File: <a href="src/lambdaFun.cpp">file:src/lambdaFun.cpp</a></li>
<li>Online Compiler: <a href="http://rextester.com/SCQP30593">http://rextester.com/SCQP30593</a></li>
</ul>

<p>
Code Highlights:
</p>

<ul class="org-ul">
<li>Lambda function - lambda1</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Example (1)</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">lambda1</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">str</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Lambda1: : I got the value = "</span> &lt;&lt; str &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Alternative 1:</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">------------------------------</span>
<span class="org-function-name">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> lambda1A = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">str</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Lambda1: : I got the value = "</span> &lt;&lt; str &lt;&lt; endl;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Alternative 2:</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">------------------------------</span>
<span class="org-function-name">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">auto</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> lambda1B = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">str</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Lambda1: : I got the value = "</span> &lt;&lt; str &lt;&lt; endl;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Alternative 3:</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">------------------------------</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Type synonym </span>
<span class="org-keyword">using</span> <span class="org-type">FnAction</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Alternative type synonym: </span>
<span class="org-keyword">using</span> <span class="org-type">FnAction</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">auto</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-type">FnAction</span> <span class="org-variable-name">lambda1C</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">str</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Lambda1: : I got the value = "</span> &lt;&lt; str &lt;&lt; endl;
<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; lambda1<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello world"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">Lambda1</span>: : I got the value = hello world

&gt;&gt; lambda1<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hola mundo"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">Lambda1</span>: : I got the value = hola mundo

&gt;&gt; lambda1A<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"testing C++"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">Lambda1</span>: : I got the value = testing C++

&gt;&gt; lambda1B<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Running lambda1B"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">Lambda1</span>: : I got the value = Running lambda1B

&gt;&gt; lambda1C<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"I am lambda1C function"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">Lambda1</span>: : I got the value = I am lambda1C function
&gt;&gt;  
</pre>
</div>


<ul class="org-ul">
<li>Higher order function which returns a lambda function which takes
two ints as parameters returning an int. This function captures the
parameter m by value, it means that the parameter is copied in the
function body.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">As it is in the code.</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">----------------------------------------- </span>
<span class="org-function-name">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> makeFunction1<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>m<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> m * <span class="org-rainbow-delimiters-depth-3">(</span>x + y<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-keyword">auto</span> fn = makeFunction1<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7fb73017f010
&gt;&gt; fn<span class="org-rainbow-delimiters-depth-1">(</span>3, 5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 32
&gt;&gt; fn<span class="org-rainbow-delimiters-depth-1">(</span>4, 3<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 28
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Alternative 1:</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">-----------------------------------------</span>
<span class="org-keyword">auto</span> makeFunction1A<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>m<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> m * <span class="org-rainbow-delimiters-depth-3">(</span>x + y<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; fna<span class="org-rainbow-delimiters-depth-1">(</span>3, 5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 32
&gt;&gt; fna<span class="org-rainbow-delimiters-depth-1">(</span>4, 3<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 28
&gt;&gt; <span class="org-keyword">auto</span> fna6 = makeFunction1A<span class="org-rainbow-delimiters-depth-1">(</span>6<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f696d823030
&gt;&gt; fna6<span class="org-rainbow-delimiters-depth-1">(</span>3, 5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 48
&gt;&gt; fna6<span class="org-rainbow-delimiters-depth-1">(</span>4, 3<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 42
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Alternative 2:</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">-----------------------------------------</span>
<span class="org-keyword">auto</span> makeFunction1B<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">auto</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>m<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> m * <span class="org-rainbow-delimiters-depth-3">(</span>x + y<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Alternative 3:</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">-----------------------------------------</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">C++11 Type synonym</span>
<span class="org-keyword">using</span> <span class="org-type">BinaryIntFunctionA</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;
<span class="org-keyword">using</span> <span class="org-type">BinaryIntFunctionB</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">auto</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Prior to C++11 type synonym</span>
<span class="org-keyword">typedef</span> <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">auto</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">BinaryIntFunction</span>;

<span class="org-keyword">auto</span> <span class="org-function-name">makeFunction1C</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">BinaryIntFunctionB</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>m<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> m * <span class="org-rainbow-delimiters-depth-3">(</span>x + y<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-keyword">auto</span> fnc = makeFunction1C<span class="org-rainbow-delimiters-depth-1">(</span>8<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f696d823050
&gt;&gt; fnc<span class="org-rainbow-delimiters-depth-1">(</span>3, 5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 64
&gt;&gt; fnc<span class="org-rainbow-delimiters-depth-1">(</span>6, 7<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 104
&gt;&gt; 8 * <span class="org-rainbow-delimiters-depth-1">(</span>6 + 7<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 104
&gt;&gt; 
</pre>
</div>


<p>
Complete program output (<a href="src/lambdaFun.cpp">file:src/lambdaFun.cpp</a>) : 
</p>

<div class="org-src-container">
<pre class="src src-sh">g++ lamdaFun.cpp -o <span class="org-keyword">bin/lamdaFun.bin</span> &amp;&amp; bin/lamdaFun.bin

-----------------------------------------------------------------------------------------
&gt;&gt; Example(1) - Testing <span class="org-keyword">function</span> <span class="org-function-name">lambda1</span>
<span class="org-function-name">Lambda1</span>: : I got the value = Hello
<span class="org-function-name">Lambda1</span>: : I got the value = World

-----------------------------------------------------------------------------------------
&gt;&gt; Example(2) Testing <span class="org-keyword">function</span> <span class="org-function-name">lambda2</span>
Lambda 2 :: I got the value  = Japan
Lambda 2 :: I got the value  = Korea

-----------------------------------------------------------------------------------------
&gt;&gt; Example(3) Testing <span class="org-keyword">function</span> <span class="org-function-name">lambda3</span>
   - Lambda <span class="org-keyword">function</span> <span class="org-function-name">can</span> be defined and executed at the call-site
Lambda 3 :: I got the value = C++11 is awesome!

-----------------------------------------------------------------------------------------
&gt;&gt; Example(4) Testing <span class="org-keyword">function</span> <span class="org-function-name">sumLambda</span>
   - Lambda functions  can return values as any function.
<span class="org-function-name">sumLambda</span>(10.0, 25.34) = 35.34
<span class="org-function-name">sumLambda</span>(-10.23, 4.56) = -5.67

-----------------------------------------------------------------------------------------
&gt;&gt; Example(5) Testing <span class="org-keyword">function</span> <span class="org-function-name">lamdaCapture</span>
   - Lambda functions  can capture its environment (closures) and have state as <span class="org-string">"function objects"</span>
  x  = 5  c = 3
<span class="org-function-name">lamdaCapture</span>(2, 5)  = 32
  x  = 5  c = 4
  lamdaCapture(1, 2) =  16
  x  = 5  c = 5

-----------------------------------------------------------------------------------------
&gt;&gt; Example(6) Testing <span class="org-keyword">function</span> <span class="org-function-name">sumLambda</span>
   - Lambda functions  can play well with STL algorithms
Print all vector elements - Version 1
  v[0] = 1
  v[1] = 2
  v[2] = 3
  v[3] = 4
  v[4] = 5
  v[5] = 6
  v[6] = 7
  v[7] = 8
Print all vector element Version 2  - local state with <span class="org-string">'static'</span> keyword
  v[0] = 1
  v[1] = 2
  v[2] = 3
  v[3] = 4
  v[4] = 5
  v[5] = 6
  v[6] = 7
  v[7] = 8

-----------------------------------------------------------------------------------------
&gt;&gt; Example(7) 
   Playing with STL transform algorithm.
  Vector transformed =  
v  [0] = 4
v  [1] = 7
v  [2] = 10
v  [3] = 13
v  [4] = 16
v  [5] = 19
v  [6] = 22
v  [7] = 25

-----------------------------------------------------------------------------------------
&gt;&gt; Example(8) 
   Lambda functions can be returned from functions and be generated at run-time.
  mulSumBy2(2, 4) = 12
  mulSumBy2(3, 1) = 8
  mulSumBy5(2, 4) = 30
  mulSumBy5(9, 2) = 55

-----------------------------------------------------------------------------------------
&gt;&gt; Example(9) 
   Lambda functions can be returned from functions and have state.
  Running dummy <span class="org-keyword">function</span>
    (*) m = 2, n = 0, x = 1, y = 3, z = 8
  Running dummy <span class="org-keyword">function</span>
    (*) m = 2, n = 1, x = 2, y = 5, z = 15
  Running dummy <span class="org-keyword">function</span>
    (*) m = 3, n = 0, x = 1, y = 3, z = 12
  Running dummy <span class="org-keyword">function</span>
    (*) m = 3, n = 1, x = 2, y = 5, z = 22

-----------------------------------------------------------------------------------------
&gt;&gt; Example(10) 
   Lambda functions can return lambda functions!!
  addTo5(4) = 9
  addTo5(3) = 8
  addTo10(4) = 14
  addTo10(3) = 13

-----------------------------------------------------------------------------------------
&gt;&gt; Example(11) 
   Lambda functions can be passed as <span class="org-keyword">function</span> <span class="org-function-name">arguments</span>!
<span class="org-function-name">foldVector</span>(dataset2, 0, add) = 28
<span class="org-function-name">foldVector</span>(dataset2, 1, mul) = 5040

-----------------------------------------------------------------------------------------
&gt;&gt; Example(12) - Observer pattern
(observer 1) Temperature changed to 30.5 C
(observer 2) Sensor temperature changed to 30.5 C
(observer 1) Temperature changed to 20.5 C
(observer 2) Sensor temperature changed to 20.5 C

</pre>
</div>

<p>
<b>References</b>
</p>

<ul class="org-ul">
<li><b>Lambda Expressions in C++</b> -
<a href="https://msdn.microsoft.com/en-us/library/dd293608.aspx">https://msdn.microsoft.com/en-us/library/dd293608.aspx</a></li>

<li><b>Lambda expressions (since C++11)</b> -
<a href="http://en.cppreference.com/w/cpp/language/lambda">http://en.cppreference.com/w/cpp/language/lambda</a></li>

<li><b>C++ Core Guidelines: Function Objects and Lambdas</b> -
<a href="http://www.modernescpp.com/index.php/c-core-guidelines-function-objects-and-lambas">http://www.modernescpp.com/index.php/c-core-guidelines-function-objects-and-lambas</a></li>

<li><b>C++11/C++14 lambda functions - 2017</b> -
<a href="http://www.bogotobogo.com/cplusplus/C11/C11_lambda_functions_expressions.php">http://www.bogotobogo.com/cplusplus/C11/C11_lambda_functions_expressions.php</a></li>

<li><b>Lambda Functions in C++11 - the Definitive Guide</b> -
<a href="https://www.cprogramming.com/c++11/c++11-lambda-closures.html">https://www.cprogramming.com/c++11/c++11-lambda-closures.html</a></li>

<li><b>Fun with Lambdas: C++14 Style (part 1)</b> -
<a href="https://www.slideshare.net/SumantTambe/fun-with-lambdas-c14-style">https://www.slideshare.net/SumantTambe/fun-with-lambdas-c14-style</a></li>

<li><b>ICS 45C Fall 2016 - Notes and Examples: Functions and Lambdas</b> -
<a href="http://www.ics.uci.edu/~thornton/ics45c/Notes/FunctionsAndLambdas/">http://www.ics.uci.edu/~thornton/ics45c/Notes/FunctionsAndLambdas/</a></li>

<li><b>Creating Recursive Lambdas &#x2026; and returning them too!</b> -
<a href="http://cpptruths.blogspot.com.br/2013/10/creating-recursive-lambdas-and.html">http://cpptruths.blogspot.com.br/2013/10/creating-recursive-lambdas-and.html</a></li>
</ul>
</div>
</div>
<div id="outline-container-org6567c48" class="outline-4">
<h4 id="org6567c48"><span class="section-number-4">1.14.3</span> Lambdas in Deep</h4>
<div class="outline-text-4" id="text-1-14-3">
<p>
Define two test functions: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> add_10 = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> x + 10; <span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; <span class="org-keyword">auto</span> mul_3  = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> x * 3; <span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; add_10<span class="org-rainbow-delimiters-depth-1">(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15

&gt;&gt; mul_3<span class="org-rainbow-delimiters-depth-1">(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15
</pre>
</div>

<p>
The lambda objects add_10 and mul_3 can be called like functors
(callable objects) overloading the function-call operator. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; add_10.<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-1">()(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15

&gt;&gt; mul_3.<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-1">()(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15
&gt;&gt; 
</pre>
</div>

<p>
Define two functions fun_add_10 and fun_mul_3; 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">int</span> fun_add_10<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> n + 10; <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; <span class="org-type">int</span> fun_mul_3<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> n * 3; <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; fun_add_10<span class="org-rainbow-delimiters-depth-1">(</span>2<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 12

&gt;&gt; fun_add_10<span class="org-rainbow-delimiters-depth-1">(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15

&gt;&gt; fun_mul_3<span class="org-rainbow-delimiters-depth-1">(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15
</pre>
</div>

<p>
Both functions have the same type and can be reffered by the same
function-pointer: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-2">(</span>fun_add_10<span class="org-rainbow-delimiters-depth-2">)</span> == <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-2">(</span>fun_mul_3<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" =&gt; Function have same type"</span><span class="org-rainbow-delimiters-depth-1">)</span>; 
=&gt; Function have same type

&gt;&gt; <span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-1">(</span>* funptr<span class="org-rainbow-delimiters-depth-1">)(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> = <span class="org-constant">nullptr</span>;

&gt;&gt; funptr = fun_add_10;
&gt;&gt; funptr<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 14

&gt;&gt; funptr = fun_mul_3;
&gt;&gt; funptr<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 12
</pre>
</div>

<p>
Lambdas does not have the same type: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-2">(</span>add_10<span class="org-rainbow-delimiters-depth-2">)</span> != <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-2">(</span>mul_3<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" =&gt; Lambdas do not have the same type"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 =&gt; Lambdas <span class="org-keyword">do</span> <span class="org-keyword">not</span> have the same type

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;
&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"value = "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-2">(</span>add_10<span class="org-rainbow-delimiters-depth-2">)</span> != <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-2">(</span>mul_3<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
value = <span class="org-constant">true</span>
</pre>
</div>

<p>
Lambdas cannot be referred by the same pointer. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Take the address of the object add_10 </span>
&gt;&gt; <span class="org-keyword">auto</span> ptr = &amp;add_10;
&gt;&gt; ptr
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>lambda<span class="org-rainbow-delimiters-depth-2">)</span> *<span class="org-rainbow-delimiters-depth-1">)</span> @0x7ffed74b7368

<span class="org-comment-delimiter">// </span><span class="org-comment">Apply to a value </span>
&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>*ptr<span class="org-rainbow-delimiters-depth-1">)(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 14
&gt;&gt; 
&gt;&gt; ptr-&gt;<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-1">()(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 14

<span class="org-comment-delimiter">// </span><span class="org-comment">FAILURE!!! because both lambdas do not have the same type.  Attempt</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">to assing the address of mul_3 to the pointer to add_10.</span>
&gt;&gt; ptr = &amp;mul_3;
<span class="org-function-name">ROOT_prompt_76</span>:1:7: error: assigning to <span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">(</span>lambda <span class="org-type">at</span> <span class="org-variable-name">ROOT_prompt_0</span>:1:15<span class="org-rainbow-delimiters-depth-1">)</span> *<span class="org-warning">'</span> from incompatible type <span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">(</span>lambda
      <span class="org-type">at</span> <span class="org-variable-name">ROOT_prompt_2</span>:1:15<span class="org-rainbow-delimiters-depth-1">)</span> *<span class="org-warning">'</span>
ptr = &amp;mul_3;
      ^~~~~~
</pre>
</div>

<p>
Both objects are <b>add_10</b> and <b>mul_3</b> are instance of different anonymous
classes created by the compiler which overloads the function-call
operator member function. 
</p>

<p>
The lambda object <span class="underline">add_10</span> is equivalent to: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">_anonymous_lambda_class1</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
     <span class="org-type">int</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> n + 10; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">_anonymous_lambda_class1</span> <span class="org-variable-name">add_10</span>; 
</pre>
</div>

<p>
The lambda object <span class="underline">mul_3</span> is equivalent to: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">_anonymous_lambda_class2</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
     <span class="org-type">int</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> n * 3; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">_anonymous_lambda_class2</span> <span class="org-variable-name">mul_3</span>; 
</pre>
</div>


<p>
The following capturing lambda is equivalent to: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">----------- Capturing lambda -----------------// </span>
<span class="org-type">double</span> <span class="org-variable-name">x</span> = 10; 
<span class="org-function-name">std</span>::string name = <span class="org-string">"Somebody"</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">capture_lambda</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">x</span>, &amp;<span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">word</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">void</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" n = %d ; word = %s, x = %f ; name = %s"</span>, n, word, x, name.c_str<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">//</span><span class="org-comment">--- The capturing lambda (closure) is the same as --------// </span>
<span class="org-comment-delimiter">// </span>
<span class="org-keyword">class</span> <span class="org-type">_anonymous_lambda_class</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">double</span> <span class="org-variable-name">_x</span>;
   <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">_name</span>;  
<span class="org-function-name">public</span>:     
  <span class="org-function-name">_anonymous_lambda_class</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>: 
     _x<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>
   , _name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span> 
  <span class="org-rainbow-delimiters-depth-2">{</span> 
  <span class="org-rainbow-delimiters-depth-2">}</span>   

  <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">word</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> 
  <span class="org-rainbow-delimiters-depth-2">{</span>
     printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" n = %d ; word = %s, x = %f ; name = %s"</span>, n, word, x, name.c_str<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-function-name">capture_lambda</span><span class="org-rainbow-delimiters-depth-1">(</span>x, name<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>


<p>
<b>Passing lambdas as function parameters:</b>
</p>

<p>
Both lambda objects can be passed by using templated function like in
the following code. The function apply_function, accepts any function
pointer with type <span class="underline">int (*) (int)</span>, any callable object (functor) that
takes an integer and returns an integer and also lambdas that are also
callable objects.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">TFunc</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-type">void</span> <span class="org-function-name">apply_function</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">TFunc</span> <span class="org-variable-name">func</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span>    
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i<span class="org-rainbow-delimiters-depth-2">){</span>
       printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" i = %d\n"</span>, func<span class="org-rainbow-delimiters-depth-4">(</span>i<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Passing function pointers as parameter to the templated function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; apply_function<span class="org-rainbow-delimiters-depth-1">(</span>fun_add_10, 3<span class="org-rainbow-delimiters-depth-1">)</span>
 i = 10
 i = 11
 i = 12

&gt;&gt; apply_function<span class="org-rainbow-delimiters-depth-1">(</span>&amp;fun_add_10, 4<span class="org-rainbow-delimiters-depth-1">)</span>
 i = 10
 i = 11
 i = 12
 i = 13

&gt;&gt; apply_function<span class="org-rainbow-delimiters-depth-1">(</span>fun_mul_3, 3<span class="org-rainbow-delimiters-depth-1">)</span>
 i = 0
 i = 3
 i = 6
</pre>
</div>

<p>
Passing lambdas, aka lambda objects as parameters to the templated
function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Pass lambda object add_10 </span>
&gt;&gt; apply_function<span class="org-rainbow-delimiters-depth-1">(</span>add_10, 3<span class="org-rainbow-delimiters-depth-1">)</span>
 i = 10
 i = 11
 i = 12

<span class="org-comment-delimiter">// </span><span class="org-comment">Pass lambda object mul_3 as parameter </span>
&gt;&gt; apply_function<span class="org-rainbow-delimiters-depth-1">(</span>mul_3, 3<span class="org-rainbow-delimiters-depth-1">)</span>
 i = 0
 i = 3
 i = 6

&gt;&gt; apply_function<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 5 * x; <span class="org-rainbow-delimiters-depth-2">}</span>, 3<span class="org-rainbow-delimiters-depth-1">)</span>
 i = 0
 i = 5
 i = 10  
</pre>
</div>

<p>
Passign a functor to the templated function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">AFunctor</span><span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">int</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> 4 * x + 5; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; afc<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 21

&gt;&gt; afc.<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-1">()(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 21
&gt;&gt; 

&gt;&gt; apply_function<span class="org-rainbow-delimiters-depth-1">(</span>afc, 3<span class="org-rainbow-delimiters-depth-1">)</span>
 i = 5
 i = 9
 i = 13

&gt;&gt; apply_function<span class="org-rainbow-delimiters-depth-1">(</span>AFunctor<span class="org-rainbow-delimiters-depth-2">()</span>, 3<span class="org-rainbow-delimiters-depth-1">)</span>
 i = 5
 i = 9
 i = 13
</pre>
</div>


<p>
As a result: 
</p>

<ul class="org-ul">
<li>C++ <b>lambdas expressions are not functions</b>, as in most functional
languages such as Haskell, OCaml and so on. They are functors or
callable-objects instances of anonymous classes generated by the
compiler.</li>

<li>Lambda expressions with the same type parameters and same return
type do not have the same type and cannot be assigned to the same
variable or referred by the same pointer.</li>

<li>Lambdas can be passed as parameters by using templated
functions. In this case lambdas and functors are better than
passing function pointers as the both are most likely to be inlined
by the compiler removing the function-call overhead.</li>

<li>The only way to store lambdas in the same container or in an
std::vector container is by using type-erasure or type-erasure
containers such as <a href="https://en.cppreference.com/w/cpp/utility/functional/function">std::function</a>.</li>

<li>std::function&lt;int (int)&gt; is not the type of any of those lambda
functions.</li>
</ul>
</div>
</div>
<div id="outline-container-orgf6af1e6" class="outline-4">
<h4 id="orgf6af1e6"><span class="section-number-4">1.14.4</span> Stateful lambdas</h4>
<div class="outline-text-4" id="text-1-14-4">
<p>
The function-call operator member function operator()(args) of a
lambda object is annotated with <span class="underline">const</span>, therefore it cannot modify
captured parameters by value. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Compile-time error!! </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">incrementer</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-variable-name">n</span> = 1<span class="org-rainbow-delimiters-depth-1">]()</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> ++n; <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
The previous line is equivalent to: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">The previous line is the same as: </span>
<span class="org-keyword">class</span> <span class="org-type">__Anonymous_lambda_classA</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">n</span> = 1;
<span class="org-function-name">public</span>: 
    __Anonymous_lambda_class<span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Function-call operator annotated as const </span>
    <span class="org-type">int</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> 
    <span class="org-rainbow-delimiters-depth-2">{</span>  
       <span class="org-comment-delimiter">// </span><span class="org-comment">Value n cannot be modified!! </span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">Compiel-time error!!</span>
       <span class="org-keyword">return</span> ++n; 
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">__Anonymous_lambda_classA</span> <span class="org-variable-name">incrementer</span>;
</pre>
</div>

<p>
The <span class="underline">mutable</span> keyword allows variables captured by value to be modified
in the lambda expression.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Now it works</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">incrementer</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-variable-name">n</span> = 1<span class="org-rainbow-delimiters-depth-1">]()</span> <span class="org-keyword">mutable</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> ++n; <span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Could also be written as: </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">incrementer</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-variable-name">n</span> = 1<span class="org-rainbow-delimiters-depth-1">]()</span> <span class="org-keyword">mutable</span> -&gt; <span class="org-type">int</span> 
                  <span class="org-rainbow-delimiters-depth-1">{</span>  
                     <span class="org-keyword">return</span> ++n; 
                  <span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Could also be written as: </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">incrementer</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-variable-name">n</span> = 1<span class="org-rainbow-delimiters-depth-1">](</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">mutable</span> -&gt; <span class="org-type">int</span> 
                   <span class="org-rainbow-delimiters-depth-1">{</span> 
                     <span class="org-keyword">return</span> ++n; 
                   <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
The previous lambda expression 'incrementer' is equivalent to: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">The previous line is the same as: </span>
<span class="org-keyword">class</span> <span class="org-type">__Anonymous_lambda_classB</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">n</span> = 1;
<span class="org-function-name">public</span>: 
    __Anonymous_lambda_class<span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Function-call operator non cost </span>
    <span class="org-type">int</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">()</span>  
    <span class="org-rainbow-delimiters-depth-2">{</span>  
       <span class="org-keyword">return</span> ++n; 
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">__Anonymous_lambda_classB</span> <span class="org-variable-name">incrementer</span>;
</pre>
</div>

<p>
Test in Cling REPL: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">$ ~/opt/cling_2018-09-16_fedora27/bin/cling -std=c++1z
<span class="org-comment-delimiter">// </span><span class="org-comment">Now it works</span>
<span class="org-keyword">auto</span> incrementer = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-variable-name">n</span> = 1<span class="org-rainbow-delimiters-depth-1">]()</span> <span class="org-keyword">mutable</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> ++n; <span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">incrementerB</span> = incrementer;

<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">cling</span><span class="org-rainbow-delimiters-depth-1">]</span>$ incrementer<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 2
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ incrementer<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 3
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ incrementer<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ incrementer<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 5

<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ incrementerB<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 2
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ incrementerB<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 3
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ incrementerB<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 4

<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ inc<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 6
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ inc<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 7
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ inc<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 8
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ incrementer<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 6
<span class="org-rainbow-delimiters-depth-1">[</span>cling<span class="org-rainbow-delimiters-depth-1">]</span>$ 
</pre>
</div>

<p>
<b>Example: stateful lambda X captured variable</b> 
</p>

<p>
Sample code: main-stateful-lambda.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">n</span> = 10;
    <span class="org-keyword">auto</span> <span class="org-variable-name">func</span> = <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">n</span><span class="org-rainbow-delimiters-depth-2">]()</span> <span class="org-keyword">mutable</span> <span class="org-rainbow-delimiters-depth-2">{</span> n = n + 1; <span class="org-keyword">return</span> n; <span class="org-rainbow-delimiters-depth-2">}</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" func() = "</span> &lt;&lt; func<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" func() = "</span> &lt;&lt; func<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" func() = "</span> &lt;&lt; func<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" n = "</span> &lt;&lt; n &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-function-name">func</span>() = 11
<span class="org-function-name">func</span>() = 12
<span class="org-function-name">func</span>() = 13
n = 10
</pre>
</div>
</div>
</div>

<div id="outline-container-org4585d7f" class="outline-4">
<h4 id="org4585d7f"><span class="section-number-4">1.14.5</span> Self-executable lambda for complex initialization</h4>
<div class="outline-text-4" id="text-1-14-5">
<p>
Self-executable lambdas functions can also be used for performing
complex local or global static variables initialization.
</p>


<p>
<b>Example 1:</b> Initialization of global variables.
</p>

<ul class="org-ul">
<li>Online compiler: <a href="https://rextester.com/CHRT64707">https://rextester.com/CHRT64707</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cstdio</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">AClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-variable-name">y</span>, <span class="org-variable-name">z</span>; 
<span class="org-function-name">public</span>:
    <span class="org-function-name">AClass</span><span class="org-rainbow-delimiters-depth-2">()</span>: x<span class="org-rainbow-delimiters-depth-2">(</span>0<span class="org-rainbow-delimiters-depth-2">)</span>, y<span class="org-rainbow-delimiters-depth-2">(</span>0<span class="org-rainbow-delimiters-depth-2">)</span>, z<span class="org-rainbow-delimiters-depth-2">(</span>0<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>
    ~<span class="org-function-name">AClass</span><span class="org-rainbow-delimiters-depth-2">(){</span>
       <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Object deleted\n"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">setX</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">this</span>-&gt;x = x; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">setY</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">this</span>-&gt;y = y; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">setZ</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">z</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">this</span>-&gt;z = z; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-2">(){</span>
       <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"AClass{ x = %.3f ; y = %.3f ; z = %.3f}\n"</span>, x, y, z<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>   
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">AClass</span> <span class="org-variable-name">globalObject</span> =
    <span class="org-rainbow-delimiters-depth-1">[](){</span>
        <span class="org-type">AClass</span> <span class="org-variable-name">cls</span>;
        cls.setX<span class="org-rainbow-delimiters-depth-2">(</span>10.0<span class="org-rainbow-delimiters-depth-2">)</span>;
        cls.setY<span class="org-rainbow-delimiters-depth-2">(</span>20.0<span class="org-rainbow-delimiters-depth-2">)</span>;
        cls.setZ<span class="org-rainbow-delimiters-depth-2">(</span>15.0<span class="org-rainbow-delimiters-depth-2">)</span>;
        cls.show<span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-keyword">return</span> cls;
    <span class="org-rainbow-delimiters-depth-1">}()</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Program Initialized"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    globalObject.show<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Program end"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">$ clang++ init1.cpp -o init1.bin -g -std=c++1z -Wall -Wextra
$ ./init1.bin

AClass{ x = 10.000 ; y = 20.000 ; z = 15.000}
Program Initialized
AClass{ x = 10.000 ; y = 20.000 ; z = 15.000}
Program end
Object deleted
</pre>
</div>


<p>
<b>Example 2:</b> Initialization of function static variables.
</p>

<ul class="org-ul">
<li>Online compiler: <a href="https://rextester.com/RIGN6626">https://rextester.com/RIGN6626</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">map</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-type">int</span> <span class="org-function-name">getDayOfWeekNum2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">weekDay</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Type alias / synonym </span>
    <span class="org-keyword">using</span> <span class="org-type">WeekDayTable</span> = <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>;
    <span class="org-keyword">static</span> <span class="org-type">WeekDayTable</span> <span class="org-variable-name">week_table</span> =
             <span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Lambda function</span>
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [LOG] Initializing month table"</span> &lt;&lt; <span class="org-string">"\n"</span>;
                <span class="org-type">WeekDayTable</span> <span class="org-variable-name">tbl</span>;
                tbl<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">"Sun"</span><span class="org-rainbow-delimiters-depth-3">]</span> = 1;
                tbl<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">"Mon"</span><span class="org-rainbow-delimiters-depth-3">]</span> = 2;
                tbl<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">"Tue"</span><span class="org-rainbow-delimiters-depth-3">]</span> = 3;
                tbl<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">"Wed"</span><span class="org-rainbow-delimiters-depth-3">]</span> = 4;
                tbl<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">"Thu"</span><span class="org-rainbow-delimiters-depth-3">]</span> = 5;
                tbl<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">"Fri"</span><span class="org-rainbow-delimiters-depth-3">]</span> = 6;
                tbl<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">"Sat"</span><span class="org-rainbow-delimiters-depth-3">]</span> = 7;
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [LOG] Month table initialization end. OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
                <span class="org-keyword">return</span> tbl;
        <span class="org-rainbow-delimiters-depth-2">}()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>week_table.find<span class="org-rainbow-delimiters-depth-3">(</span>weekDay<span class="org-rainbow-delimiters-depth-3">)</span> != week_table.end<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-keyword">return</span> week_table<span class="org-rainbow-delimiters-depth-2">[</span>weekDay<span class="org-rainbow-delimiters-depth-2">]</span>;  
    <span class="org-keyword">return</span> -1;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getDayOfWeekNum2(Mon)   = "</span> &lt;&lt; getDayOfWeekNum2<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Mon"</span><span class="org-rainbow-delimiters-depth-2">)</span>   &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getDayOfWeekNum2(Tue)   = "</span> &lt;&lt; getDayOfWeekNum2<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Tue"</span><span class="org-rainbow-delimiters-depth-2">)</span>   &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getDayOfWeekNum2(Sat)   = "</span> &lt;&lt; getDayOfWeekNum2<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Sat"</span><span class="org-rainbow-delimiters-depth-2">)</span>   &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"getDayOfWeekNum2(ERROR) = "</span> &lt;&lt; getDayOfWeekNum2<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"ERROR"</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Output stderr (Program logging)
</p>

<div class="org-src-container">
<pre class="src src-txt">[LOG] Initializing month table
[LOG] Month table initialization end. OK.
</pre>
</div>

<p>
Output stdout (Program output) 
</p>

<div class="org-src-container">
<pre class="src src-txt">getDayOfWeekNum2(Mon)   = 2
getDayOfWeekNum2(Tue)   = 3
getDayOfWeekNum2(Sat)   = 7
getDayOfWeekNum2(ERROR) = -1
</pre>
</div>
</div>
</div>
<div id="outline-container-org94d906c" class="outline-4">
<h4 id="org94d906c"><span class="section-number-4">1.14.6</span> Universal function adapter - std::bind</h4>
<div class="outline-text-4" id="text-1-14-6">
</div>
<ol class="org-ol">
<li><a id="org3cc9915"></a>Overview<br />
<div class="outline-text-5" id="text-1-14-6-1">
<p>
The operator std::bind can simplify help simplifying turning ordinary
functions, instance methods (member functions) and static methods
(static member functions) into ordinary functions.
</p>

<p>
Example 1: Turn a function of signature: 
</p>
<ul class="org-ul">
<li>Input Signature:
<ul class="org-ul">
<li>double functionABC(double a, double c, double c)</li>
</ul></li>
<li>Target signature: 
<ul class="org-ul">
<li>function&lt;double (double)&gt;</li>
</ul></li>
</ul>

<p>
For the function functionABC
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">double</span> <span class="org-function-name">functionABC</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">c</span>, <span class="org-type">double</span> <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
The expression:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Type of fnFunOfA is std::function&lt;double (double)&gt;</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">fnFunOfA</span> = <span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-1">(</span>functionABC, _1, 10.0, 20.0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">It is the same as </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">fnFunOfA</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> functionABC<span class="org-rainbow-delimiters-depth-2">(</span>x, 10.0, 20.0<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">It also equivalent to </span>
<span class="org-function-name">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> fnFunOfA = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> functionABC<span class="org-rainbow-delimiters-depth-2">(</span>x, 10.0, 20.0<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
So, it follows that: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">fnFunOfB</span> = <span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-1">(</span>functionABC, 25.0 , _1, 20.0<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">It is equivalent to </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">fnFunOfB</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>functionABC, 25.0 , _1, 20.0<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
By using more lambda placeholders it is also possible to generate
multi variable functions: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">placeholders</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Import placeholders, _1, _2, _3 ...  </span>

<span class="org-comment-delimiter">//</span><span class="org-comment">----------------------------------//</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">fnFunOfAB</span> = <span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-1">(</span>functionABC, _1 , _2, 20.0<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Equivalent to </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">fnFunOfAB</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> functionABC<span class="org-rainbow-delimiters-depth-2">(</span> x , y, 20.0<span class="org-rainbow-delimiters-depth-2">)</span>;<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">//</span><span class="org-comment">----------------------------------//</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">fnFunOfAC</span> = <span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-1">(</span>functionABC, _1 , 10.0, _2<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Equivalent to </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">fnFunOfAC</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> functionABC<span class="org-rainbow-delimiters-depth-2">(</span> x , 10.0, y<span class="org-rainbow-delimiters-depth-2">)</span>;<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">//</span><span class="org-comment">----------------------------------//</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">fnFunOfABC</span> = <span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-1">(</span>functionABC, _1 , 10.0, _2<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Equivalent to </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">fnFunOfABC</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span>, <span class="org-type">double</span> <span class="org-variable-name">z</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> functionABC<span class="org-rainbow-delimiters-depth-2">(</span> x , y, z<span class="org-rainbow-delimiters-depth-2">)</span>;<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>


<p>
<b>Binding non-static methods (member function)</b>
</p>

<p>
For the following class:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">FunctionObject</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-type">double</span> <span class="org-variable-name">x</span>;
     <span class="org-type">double</span> <span class="org-variable-name">y</span>;
     <span class="org-function-name">FunctionObject</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">)</span>: x<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>, y<span class="org-rainbow-delimiters-depth-2">(</span>y<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;      
     <span class="org-type">double</span> <span class="org-keyword">operator</span> <span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">){</span>   
        <span class="org-keyword">return</span> a * a;
     <span class="org-rainbow-delimiters-depth-2">}</span>   
     <span class="org-type">double</span> <span class="org-keyword">operator</span> <span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span>, <span class="org-type">double</span> <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-2">){</span>
         <span class="org-keyword">return</span> a * x + b * y + c / <span class="org-rainbow-delimiters-depth-3">(</span>x + y<span class="org-rainbow-delimiters-depth-3">)</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-type">double</span> <span class="org-function-name">method1</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-2">){</span>
         <span class="org-keyword">return</span> <span class="org-keyword">this</span>-&gt;x * a  + <span class="org-keyword">this</span>-&gt;y / a;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-type">double</span> <span class="org-function-name">method2</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">b</span>, <span class="org-type">double</span> <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-2">){</span>
         <span class="org-keyword">return</span>  c * <span class="org-rainbow-delimiters-depth-3">(</span>a / x + b / y<span class="org-rainbow-delimiters-depth-3">)</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>       
 <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
It is possible to create lambda functions from those class methods
(member functions):
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">FunctionObject</span> <span class="org-variable-name">obj</span>;

<span class="org-comment-delimiter">//</span><span class="org-comment">-------------------------</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">method1LambdaA</span> = <span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">FunctionObject</span>::method1, fobj, _1<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Equivalent to: </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">method1LambdaA</span> = <span class="org-rainbow-delimiters-depth-1">[</span>&amp;<span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">](</span><span class="org-type">double</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">){</span><span class="org-keyword">return</span> obj.method1<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">//</span><span class="org-comment">-------------------------</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">method2LambdaAsFnOfAC</span> = <span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">FunctionObject</span>::method2, &amp;fobj, _1, 10.0, _2<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Equivalent to: </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">method2LambdaAsFnOfAC</span> = <span class="org-rainbow-delimiters-depth-1">[</span>&amp;<span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">](</span><span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-type">double</span> <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> obj.method2<span class="org-rainbow-delimiters-depth-2">(</span>a, 10.0, c<span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">//</span><span class="org-comment">-------------------------</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">functionOfObj</span> = <span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">FunctionObject</span>::method1, _1, 10.0<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Equivalent to: </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">functionOfobj</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">FunctionObject</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> obj.method1<span class="org-rainbow-delimiters-depth-2">(</span>obj, 10.0<span class="org-rainbow-delimiters-depth-2">)</span>;<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</div>
</li>

<li><a id="orge405089"></a><a id="ID-219c4de9-3e9e-446f-bdd5-1ae6e7d45b5b"></a>std::bind Example<br />
<div class="outline-text-5" id="text-1-14-6-2">
<p>
File: 
</p>
<ul class="org-ul">
<li><a href="src/lambda-bind.cpp">file:src/lambda-bind.cpp</a></li>
</ul>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ lambda-bind.cpp -o <span class="org-keyword">lambda-bind.bin</span> -g -std=c++11 -Wall -Wextra -ldl 
$ ./lambda-bind.bin

======== Test 1 ========
<span class="org-function-name">lambda-bind.cpp</span>:58: ; sum10(2.0) = 12
<span class="org-function-name">lambda-bind.cpp</span>:59: ; sum10(4.5) = 14.5
<span class="org-function-name">lambda-bind.cpp</span>:60: ; sum10(25.0) = 35
======== Test 2 ========
<span class="org-function-name">lambda-bind.cpp</span>:66: ; vectorLenAsFunctionOfX(4.0) = 27.2213
<span class="org-function-name">lambda-bind.cpp</span>:67: ; std::bind(vectorLength, _1, 10.0, 25.0)(4.0) = 27.2213
<span class="org-function-name">lambda-bind.cpp</span>:68: ; vectorLenAsFunctionOfX(10.0) = 28.7228
<span class="org-function-name">lambda-bind.cpp</span>:69: ; std::bind(vectorLength, _1, 10.0, 25.0)(10.0) = 28.7228
Tabulating - vectorLenAsFunctionOfX
     1.000    26.944
     2.000    27.000
     3.000    27.092
     4.000    27.221
     5.000    27.386
======== Test 3 ========
<span class="org-function-name">lambda-bind.cpp</span>:77: ; vectorLenAsFunctionOfY(14.0) = 30.348
<span class="org-function-name">lambda-bind.cpp</span>:78: ; vectorLenAsFunctionOfY(20.0) = 33.541
Tabulating - vectorLenAsFunctionOfY
     1.000    26.944
     2.000    27.000
     3.000    27.092
     4.000    27.221
     5.000    27.386
======== Test 4 ========
<span class="org-function-name">lambda-bind.cpp</span>:92: ; vectorLenAsFunctionOfYZ(3.0, 6.0) = 12.0416
<span class="org-function-name">lambda-bind.cpp</span>:93: ; vectorLenAsFunctionOfYZ(15.0, 26.0) = 31.6386
======== Test 5 ========
<span class="org-function-name">lambda-bind.cpp</span>:97: ; fobj(4.0) = 16
<span class="org-function-name">lambda-bind.cpp</span>:98: ; fobj(5.0) = 25
<span class="org-function-name">lambda-bind.cpp</span>:99: ; fobj(10.0) = 100
<span class="org-function-name">lambda-bind.cpp</span>:101: ; fobj(4.0, 10.0, 5.0) = 104.357
<span class="org-function-name">lambda-bind.cpp</span>:102: ; fobj(6.0, 8.0, 9.0) = 100.643
<span class="org-function-name">Running</span>: tabulate(0.0, 5.0, 1.0, fobj)
     0.000     0.000
     1.000     1.000
     2.000     4.000
     3.000     9.000
     4.000    16.000
     5.000    25.000
Turning class member <span class="org-keyword">function</span> <span class="org-function-name">into</span> lambda <span class="org-keyword">function</span> 
 Note: it is not possible (0.0, 5.0, 1.0, fobj.method1)
<span class="org-function-name">lambda-bind.cpp</span>:111: ; fobj.method1(10.0) = 60.8
<span class="org-function-name">lambda-bind.cpp</span>:112: ; method1LambdaA(10.0) = 60.8
<span class="org-function-name">lambda-bind.cpp</span>:113: ; fobj.method1(20.0) = 120.4
<span class="org-function-name">lambda-bind.cpp</span>:114: ; method1LambdaA(20.0) = 120.4
<span class="org-function-name">lambda-bind.cpp</span>:115: ; fobj.method1(30.0) = 180.267
<span class="org-function-name">lambda-bind.cpp</span>:116: ; method1LambdaA(30.0) = 180.267
Tabulating method1LambdaA
     0.000       inf
     1.000    14.000
     2.000    16.000
     3.000    20.667
     4.000    26.000
     5.000    31.600
Tabulating method1LambdaA using direct lambda
     0.000       inf
     1.000    14.000
     2.000    16.000
     3.000    20.667
     4.000    26.000
     5.000    31.600
======== Test 6 ========
<span class="org-function-name">lambda-bind.cpp</span>:129: ; method2LambdaAsFnOfA(5.0) = 41.6667
<span class="org-function-name">lambda-bind.cpp</span>:130: ; method2LambdaAsFnOfA(6.0) = 45
<span class="org-function-name">lambda-bind.cpp</span>:131: ; method2LambdaAsFnOfA(10.0) = 58.3333
<span class="org-function-name">lambda-bind.cpp</span>:136: ; fobj.method2(3.0, 10.0, 4.0) = 7
<span class="org-function-name">lambda-bind.cpp</span>:137: ; method2LambdaAsFnOfAC(3.0, 4.0) = 7
<span class="org-function-name">lambda-bind.cpp</span>:138: ; fobj.method2(15.0, 10.0, 14.0) = 52.5
<span class="org-function-name">lambda-bind.cpp</span>:139: ; method2LambdaAsFnOfAC(15.0, 14.0) = 52.5


</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org1d65aae" class="outline-3">
<h3 id="org1d65aae"><span class="section-number-3">1.15</span> OOP Simple Class</h3>
<div class="outline-text-3" id="text-1-15">
<ul class="org-ul">
<li>File: <a href="src/cppClasses1.cpp">file:src/cppClasses1.cpp</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;

<span class="org-keyword">class</span> <span class="org-type">Date</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
  <span class="org-type">int</span> <span class="org-variable-name">year</span>, <span class="org-variable-name">month</span>, <span class="org-variable-name">day</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">---- Public Class Members ----- //</span>

  <span class="org-type">void</span> <span class="org-function-name">showDate</span><span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-type">void</span> <span class="org-function-name">showDate2</span><span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-type">int</span>  <span class="org-function-name">getYear</span><span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-type">int</span>  <span class="org-function-name">getDay</span><span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-type">int</span>  <span class="org-function-name">getMonth</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-type">void</span> <span class="org-constant">Date</span>::<span class="org-function-name">showDate</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  cout &lt;&lt; <span class="org-string">"Date = "</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;year &lt;&lt; <span class="org-string">"-"</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;month &lt;&lt; <span class="org-string">"-"</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;day &lt;&lt; endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-constant">Date</span>::<span class="org-function-name">showDate2</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  cout &lt;&lt; <span class="org-string">"Date = "</span> &lt;&lt; year &lt;&lt; <span class="org-string">"-"</span> &lt;&lt; month &lt;&lt; <span class="org-string">"-"</span> &lt;&lt; day &lt;&lt; endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-constant">Date</span>::<span class="org-function-name">getYear</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  <span class="org-keyword">return</span> year;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-constant">Date</span>::<span class="org-function-name">getMonth</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  <span class="org-keyword">return</span> month;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-constant">Date</span>::<span class="org-function-name">getDay</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  <span class="org-keyword">return</span> day;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">Date</span> <span class="org-function-name">makeDate</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">y</span>, <span class="org-type">int</span> <span class="org-variable-name">m</span>, <span class="org-type">int</span> <span class="org-variable-name">d</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-type">Date</span> <span class="org-variable-name">date</span>;
  date.year  = y ;
  date.month = m ;
  date.day   = d ;
  <span class="org-keyword">return</span> date;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">printDate</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Date</span> <span class="org-variable-name">d</span><span class="org-rainbow-delimiters-depth-1">){</span>
  cout &lt;&lt; <span class="org-string">"Date is "</span> &lt;&lt; d.year &lt;&lt; <span class="org-string">"-"</span> &lt;&lt; d.month &lt;&lt; <span class="org-string">"-"</span> &lt;&lt; d.day &lt;&lt; endl;
<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  <span class="org-type">Date</span> <span class="org-variable-name">d</span>;
  d.day   = 10;
  d.month = 4;
  d.year  = 1998;

  cout &lt;&lt; <span class="org-string">"Date (YMD) is = "</span> &lt;&lt; d.year &lt;&lt; <span class="org-string">"-"</span> &lt;&lt; d.month &lt;&lt; <span class="org-string">"-"</span> &lt;&lt; d.day &lt;&lt; endl;
  d.showDate<span class="org-rainbow-delimiters-depth-2">()</span>;
  d.showDate2<span class="org-rainbow-delimiters-depth-2">()</span>;
  printDate<span class="org-rainbow-delimiters-depth-2">(</span>d<span class="org-rainbow-delimiters-depth-2">)</span>;

  cout &lt;&lt; <span class="org-string">"Year of date d is  = "</span> &lt;&lt; d.getYear<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="org-string">"Month of date d is = "</span> &lt;&lt; d.getMonth<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; endl;

  printDate<span class="org-rainbow-delimiters-depth-2">(</span>makeDate<span class="org-rainbow-delimiters-depth-3">(</span>1996, 8, 20<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;

  <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ cppClasses1.cpp -o <span class="org-keyword">cppClasses1.bin&amp;&amp;</span> ./cppClasses1.bin
<span class="org-function-name">Date</span> (YMD) is = 1998-4-10
Date = 1998-4-10
Date = 1998-4-10
Date is 1998-4-10
Year of date d is  = 1998
Month of date d is = 4
Date is 1996-8-20
</pre>
</div>
</div>
</div>

<div id="outline-container-org42d1277" class="outline-3">
<h3 id="org42d1277"><span class="section-number-3">1.16</span> Conversion Constructor X Explicit Constructor - explicit keyword</h3>
<div class="outline-text-3" id="text-1-16">
<p>
A converting constructor (aka conversion constructor or implicit
constructor) is any constructor member function callable with a single
argument not annotated with the <span class="underline">explicit</span> keyword. A converting
constructor allows implicit initialization by assignment or when
passing a parameter to a function. 
</p>

<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">TestClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">Constructor 1: Conversion constructor </span>
    <span class="org-function-name">TestClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>
       : m_x<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
         <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [LOG] Intialize m_x = %d\n"</span>, x<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Constructor 2: Conversion constructor </span>
    <span class="org-function-name">TestClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">char</span> <span class="org-variable-name">ch</span><span class="org-rainbow-delimiters-depth-2">)</span>
       : m_ch<span class="org-rainbow-delimiters-depth-2">(</span>ch<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
         <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [LOG] Intialize m_ch = %c\n"</span>, ch<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Constructor 3: Not conversion constructor / explicit constructor </span>
    <span class="org-keyword">explicit</span> <span class="org-function-name">TestClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">text</span><span class="org-rainbow-delimiters-depth-2">)</span>
       : m_text<span class="org-rainbow-delimiters-depth-2">(</span>text<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
         <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [LOG] Initialize m_text = %s\n"</span>, text.c_str<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Constructor 4: </span>
    <span class="org-function-name">TestClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">char</span> <span class="org-variable-name">ch</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
         <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"[LOG] Intialize m_x = %d - m_ch = %c\n"</span>, x, ch<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-2">(){</span>
         <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"[LOG] TestClass{ m_x = %d ; m_ch = '%c' ; m_text = '%s' }\n"</span>
         ,m_x, m_ch, m_text.c_str<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">--- Member variables ---- // </span>
    <span class="org-type">int</span>        <span class="org-variable-name">m_x</span>;
    <span class="org-type">char</span>       <span class="org-variable-name">m_ch</span>;
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_text</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<p>
Example: 
</p>

<ul class="org-ul">
<li>The constructors 1 and 2 not annotated with <span class="underline">explicit</span> allows
implicit initialization by assignment. While this behavior can be
useful, it can lead unintended type conversions. In order to avoid
the implicit conversion, it is necessary to annotate the member
function with explicit. After this modification, any attempt to
implicit conversion will yield a compilation error.</li>
</ul>

<p>
Testing conversion constructors:
</p>

<div class="org-src-container">
<pre class="src src-cpp">
&gt;&gt; TestClass cls1 = 100;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Intialize m_x = 100
&gt;&gt; 
&gt;&gt; TestClass cls2 = <span class="org-string">'k'</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Intialize m_ch = k

<span class="org-comment-delimiter">// </span><span class="org-comment">Show contents of cls1 and cls2 </span>
&gt;&gt; cls1.show<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">[</span>LOG<span class="org-rainbow-delimiters-depth-1">]</span> TestClass<span class="org-rainbow-delimiters-depth-1">{</span> m_x = 100 ; m_ch = <span class="org-warning">''</span> ; m_text = <span class="org-warning">''</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; cls2.show<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">[</span>LOG<span class="org-rainbow-delimiters-depth-1">]</span> TestClass<span class="org-rainbow-delimiters-depth-1">{</span> m_x = 0 ; m_ch = <span class="org-string">'k'</span> ; m_text = <span class="org-warning">''</span> <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; cls1 = 200;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Intialize m_x = 200
&gt;&gt; cls1 = 400;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Intialize m_x = 400
&gt;&gt; 
&gt;&gt; cls1.show<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">[</span>LOG<span class="org-rainbow-delimiters-depth-1">]</span> TestClass<span class="org-rainbow-delimiters-depth-1">{</span> m_x = 400 ; m_ch = <span class="org-string">'&#65533;'</span> ; m_text = <span class="org-warning">''</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

</pre>
</div>

<p>
Testing explicit constructor (constructor 3 annotated with explicit):
</p>

<ul class="org-ul">
<li>It will result in a compiation error.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Compilation error - because constructor was annotated with explicit.</span>
&gt;&gt; TestClass cls3 = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"binary data"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">ROOT_prompt_5</span>:1:11: error: no viable conversion from <span class="org-warning">'</span><span class="org-constant">std</span>::string<span class="org-warning">'</span> <span class="org-rainbow-delimiters-depth-1">(</span>aka <span class="org-warning">'</span><span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">)</span> to
      <span class="org-warning">'</span>TestClass<span class="org-warning">'</span>
TestClass cls3 = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"binary data"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
          ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~
<span class="org-function-name">input_line_15</span>:1:7: note: candidate constructor <span class="org-rainbow-delimiters-depth-1">(</span>the implicit <span class="org-type">copy</span> <span class="org-variable-name">constructor</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">not</span> viable: no known
      conversion from <span class="org-warning">'</span><span class="org-constant">std</span>::string<span class="org-warning">'</span> <span class="org-rainbow-delimiters-depth-1">(</span>aka <span class="org-warning">'</span><span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">)</span> to
      <span class="org-warning">'</span><span class="org-keyword">const</span> TestClass &amp;<span class="org-warning">'</span> <span class="org-keyword">for</span> 1st argument
</pre>
</div>

<p>
A constructor annoatated with explicit can only be initialized in the
following ways: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; TestClass cls3b<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"binary data"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Initialize m_text = binary data

&gt;&gt; TestClass cls3c<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"binary data"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Initialize m_text = binary data

&gt;&gt; <span class="org-keyword">auto</span> cls3d = TestClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"binary data"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Initialize m_text = binary data

&gt;&gt; <span class="org-keyword">auto</span> cls3e = TestClass<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"binary data"</span><span class="org-rainbow-delimiters-depth-1">}</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Initialize m_text = binary data
&gt;&gt; 
</pre>
</div>

<p>
Functions and implicit constructors: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">clientCode</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">TestClass</span>&amp; <span class="org-variable-name">cls</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" ==&gt; TestClass { m_x = %d ; m_ch = %c ; m_text = %s }\n"</span>,
    cls.m_x, cls.m_ch, cls.m_text.c_str<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; clientCode<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>LOG<span class="org-rainbow-delimiters-depth-1">]</span> Intialize m_x = 10
 ==&gt; TestClass <span class="org-rainbow-delimiters-depth-1">{</span> m_x = 10 ; m_ch = &#65533; ; m_text =  <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; clientCode<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>LOG<span class="org-rainbow-delimiters-depth-1">]</span> Intialize m_ch = x
 ==&gt; TestClass <span class="org-rainbow-delimiters-depth-1">{</span> m_x = 305009792 ; m_ch = x ; m_text =  <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

<span class="org-comment-delimiter">//</span><span class="org-comment">===========&gt;  Implicit Conversion doesn't happen! ==============//  </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">std::string cannot be implicit converted to TestClass since the </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">constructor is annoatated with 'explicit'. </span>
&gt;&gt; clientCode<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"helo world"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">ROOT_prompt_52</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>clientCode<span class="org-warning">'</span>
clientCode<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"helo world"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
^~~~~~~~~~
<span class="org-function-name">ROOT_prompt_45</span>:1:6: note: candidate function <span class="org-keyword">not</span> viable: no known conversion from <span class="org-warning">'</span><span class="org-constant">std</span>::string<span class="org-warning">'</span> <span class="org-rainbow-delimiters-depth-1">(</span>aka
      <span class="org-warning">'</span><span class="org-type">basic_string</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">)</span> to <span class="org-warning">'</span><span class="org-keyword">const</span> TestClass<span class="org-warning">'</span> <span class="org-keyword">for</span> 1st argument
<span class="org-type">void</span> clientCode<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">TestClass</span>&amp; <span class="org-variable-name">cls</span><span class="org-rainbow-delimiters-depth-1">){</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">In this case, the only way to perform the operation is by calling</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the constructor explicitly.</span>
&gt;&gt; clientCode<span class="org-rainbow-delimiters-depth-2">(</span>TestClass<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"helo world"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
 <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-2">]</span> Initialize m_text = helo world
 ==&gt; TestClass<span class="org-rainbow-delimiters-depth-2">{</span> m_x = 876161456 ; m_ch = <span class="org-string">'&#65533;'</span> ; m_text = <span class="org-warning">'</span>helo world<span class="org-warning">'</span> <span class="org-rainbow-delimiters-depth-2">}</span>
</pre>
</div>

<p>
Further reading: 
</p>
<ul class="org-ul">
<li><a href="http://doc.bccnsoft.com/docs/cppreference2015/en/cpp/language/implicit_cast.html">Implicit conversions - cppreference.com</a></li>
<li><a href="https://foonathan.net/blog/2017/10/11/explicit-assignment.html">foonathan::blog() - Write explicit constructors - but what about assignment?</a></li>
<li><a href="https://us7.proxysite.com/process.php?d=c+/jhdODjkv4sHHC7/RQPgWbtJ5O5I9zVZ9Cygk7QLQ6mLoQqx91dNnmQ5YkU1TwSjpU3PhqjvymyZ77PnD0M6esDzpuEm3res5tpzjq2r3VLz2s3shiyUONdvkj&amp;b=1">What is a converting constructor in C++ ? What is it for? - Stack Overflow</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/wwywka61.aspx">User-Defined Type Conversions (C++)</a></li>
<li><a href="https://akrzemi1.wordpress.com/2015/10/22/more-than-you-need/">More than you need | Andrzej's C++ blog</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/190716/is-relying-on-implicit-argument-conversion-considered-dangerous">c++ - Is relying on implicit argument conversion considered dangerous? - Software Engineering Stack Exchange</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgbfc524d" class="outline-3">
<h3 id="orgbfc524d"><span class="section-number-3">1.17</span> OOP Value Semantics X Reference Semantics</h3>
<div class="outline-text-3" id="text-1-17">
<p>
According to the - <a href="https://isocpp.org/wiki/faq/value-vs-ref-semantics">ISO C++</a>, value and reference semantics are defined
as: 
</p>

<blockquote>
<p>
With reference semantics, assignment is a pointer-copy (i.e., a
reference). Value (or “copy”) semantics mean assignment copies the
value, not just the pointer. C++ gives you the choice: use the
assignment operator to copy the value (copy/value semantics), or use
a pointer-copy to copy a pointer (reference semantics). C++ allows
you to override the assignment operator to do anything your heart
desires, however the default (and most common) choice is to copy the
value.
</p>
</blockquote>

<p>
<b>Definitions:</b>
</p>

<p>
<span class="underline">Reference Semantics</span>: Behavior where composite types are passed by
reference when assigned; passed as function or method parameters or
returned from functions. This is the default behavior of most object
oriented programming languages, except C++.
</p>

<p>
In Java, C#, Scala, Python and etc. Objects have reference semantics
by default. This example in Scala programming language shows how
<span class="underline">reference semantics</span> works in most languages.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span class="org-keyword">class</span> <span class="org-type">Foo</span><span class="org-rainbow-delimiters-depth-1">(</span>name<span class="org-keyword">:</span> <span class="org-type">String</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-scala-font-lockXprivate">private</span> <span class="org-keyword">var</span> <span class="org-scala-font-lockXvar">_name</span> <span class="org-keyword">=</span> name
  <span class="org-keyword">def</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-keyword">:</span> <span class="org-type">String</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">=</span>
    _name <span class="org-keyword">=</span> name
  <span class="org-keyword">def</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">=</span>
    name
  <span class="org-scala-font-lockXoverride">override</span> <span class="org-keyword">def</span> <span class="org-function-name">toString</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">=</span>
    s<span class="org-string">"Foo { name = </span><span class="org-variable-name">$name</span><span class="org-string"> }"</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

scala&gt; <span class="org-keyword">var</span> <span class="org-scala-font-lockXvar">x</span> <span class="org-keyword">=</span> <span class="org-constant">10</span>
<span class="org-function-name">x</span><span class="org-keyword">:</span> <span class="org-type">Int</span> <span class="org-keyword">=</span> <span class="org-constant">10</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Primitive types have value semantics: assignment of variables of</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">primitive types, creates a copy, so both variables can be modified</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">without changing each other.</span>
scala&gt; <span class="org-keyword">var</span> <span class="org-scala-font-lockXvar">y</span> <span class="org-keyword">=</span> x
<span class="org-function-name">y</span><span class="org-keyword">:</span> <span class="org-type">Int</span> <span class="org-keyword">=</span> <span class="org-constant">10</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">By modifying x, the value of y remains the same.</span>
scala&gt; x <span class="org-keyword">=</span> <span class="org-constant">25</span>
<span class="org-function-name">x</span><span class="org-keyword">:</span> <span class="org-type">Int</span> <span class="org-keyword">=</span> <span class="org-constant">25</span>

scala&gt; y
<span class="org-function-name">res5</span><span class="org-keyword">:</span> <span class="org-type">Int</span> <span class="org-keyword">=</span> <span class="org-constant">10</span>

scala&gt; 

<span class="org-comment-delimiter">//</span><span class="org-comment">===&gt; Composite and complexity types have reference semantics by default </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">in languages other than C++.</span>

scala&gt; <span class="org-keyword">val</span> <span class="org-variable-name">foo</span> <span class="org-keyword">=</span> <span class="org-keyword">new</span> <span class="org-type">Foo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"bar"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">foo</span><span class="org-keyword">:</span> <span class="org-type">Foo</span> <span class="org-keyword">=</span> <span class="org-constant">Foo</span> <span class="org-rainbow-delimiters-depth-1">{</span> name <span class="org-keyword">=</span> bar <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Assignment doesn't create a copy like assignment </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">of primitive type, actually the assignment creates </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">a reference to the object foo. As result, modifying </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">one of the objects, modifies the other.</span>
scala&gt; <span class="org-keyword">val</span> <span class="org-variable-name">bar</span> <span class="org-keyword">=</span> foo
<span class="org-function-name">bar</span><span class="org-keyword">:</span> <span class="org-type">Foo</span> <span class="org-keyword">=</span> <span class="org-constant">Foo</span> <span class="org-rainbow-delimiters-depth-1">{</span> name <span class="org-keyword">=</span> bar <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Modifying bar modifes foo. </span>
scala&gt; bar.setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"something"</span><span class="org-rainbow-delimiters-depth-1">)</span>

scala&gt; bar
<span class="org-function-name">res3</span><span class="org-keyword">:</span> <span class="org-type">Foo</span> <span class="org-keyword">=</span> <span class="org-constant">Foo</span> <span class="org-rainbow-delimiters-depth-1">{</span> name <span class="org-keyword">=</span> something <span class="org-rainbow-delimiters-depth-1">}</span>

scala&gt; foo
<span class="org-function-name">res4</span><span class="org-keyword">:</span> <span class="org-type">Foo</span> <span class="org-keyword">=</span> <span class="org-constant">Foo</span> <span class="org-rainbow-delimiters-depth-1">{</span> name <span class="org-keyword">=</span> something <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Passing as function parameter doesn't create a copy like in C++, </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">it passes the object by reference, so if the parameter is modified inside</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the function, the original object will be modified too. </span>
 <span class="org-keyword">def</span> <span class="org-function-name">setFooPrint</span><span class="org-rainbow-delimiters-depth-1">(</span>param<span class="org-keyword">:</span> <span class="org-type">Foo</span><span class="org-rainbow-delimiters-depth-1">){</span>
   param.setName<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"dummy name"</span><span class="org-rainbow-delimiters-depth-2">)</span>
   println<span class="org-rainbow-delimiters-depth-2">(</span>foo<span class="org-rainbow-delimiters-depth-2">)</span>
 <span class="org-rainbow-delimiters-depth-1">}</span>

 scala&gt; setFooPrint<span class="org-rainbow-delimiters-depth-1">(</span>foo<span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-constant">Foo</span> <span class="org-rainbow-delimiters-depth-1">{</span> name <span class="org-keyword">=</span> dummy name <span class="org-rainbow-delimiters-depth-1">}</span>

 scala&gt; foo
 res8<span class="org-keyword">:</span> <span class="org-type">Foo</span> <span class="org-keyword">=</span> <span class="org-constant">Foo</span> <span class="org-rainbow-delimiters-depth-1">{</span> name <span class="org-keyword">=</span> dummy name <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-comment-delimiter">// </span><span class="org-comment">Returning an object from a function doesn't create a copy as would happen </span>
 <span class="org-comment-delimiter">// </span><span class="org-comment">with primitive types.</span>
 <span class="org-keyword">def</span> <span class="org-function-name">modifyReturn</span><span class="org-rainbow-delimiters-depth-1">(</span>param<span class="org-keyword">:</span> <span class="org-type">Foo</span>, newName<span class="org-keyword">:</span> <span class="org-type">String</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">=</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   param.setName<span class="org-rainbow-delimiters-depth-2">(</span>newName<span class="org-rainbow-delimiters-depth-2">)</span>
   param
 <span class="org-rainbow-delimiters-depth-1">}</span>
 scala&gt; <span class="org-keyword">val</span> <span class="org-variable-name">foob</span> <span class="org-keyword">=</span> modifyReturn<span class="org-rainbow-delimiters-depth-1">(</span>foo, <span class="org-string">"Scala + C++ + JNI == HPC"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 foob<span class="org-keyword">:</span> <span class="org-type">Foo</span> <span class="org-keyword">=</span> <span class="org-constant">Foo</span> <span class="org-rainbow-delimiters-depth-1">{</span> name <span class="org-keyword">=</span> <span class="org-constant">Scala</span> + <span class="org-constant">C</span>++ + <span class="org-constant">JNI</span> == <span class="org-constant">HPC</span> <span class="org-rainbow-delimiters-depth-1">}</span>

 scala&gt; foo
 res9<span class="org-keyword">:</span> <span class="org-type">Foo</span> <span class="org-keyword">=</span> <span class="org-constant">Foo</span> <span class="org-rainbow-delimiters-depth-1">{</span> name <span class="org-keyword">=</span> <span class="org-constant">Scala</span> + <span class="org-constant">C</span>++ + <span class="org-constant">JNI</span> == <span class="org-constant">HPC</span> <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<span class="underline">Value Semantics</span>: Behavior where composite types such as instances of
classes are treated as primitive type such as booleans, integers or
float point numbers. In the value semantics, a copy is created when
variables are assigned; passed as parameters to functions or methods
and returned from functions. So modifying one of the variables doesn't
change the other. 
</p>

<p>
Unlike other languages, C++ uses value semantics by default, it means
that in operations such as assignment; returning objects from
functions and passing objects as parameters create a full copy of the
object, instead of creating a reference to the object as would happen
in most object oriented programming languages such as Java, C#,
Python, Ruby and etc. C++ also supports reference semantics, however
it is not the default behavior and unlike in the majority of
programming languages, requires explicit annotation to pass objects by
reference or create a reference to the object.
</p>

<p>
<b>Value Semantics in C++</b>
</p>

<p>
Example: demonstration of value semantics in C++ tested in the CERN's
C++ ROOT REPL:
</p>

<ul class="org-ul">
<li>Note: this code can be copied and pasted in the CERN's ROOT REPL.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Foo</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">_name</span>;
<span class="org-function-name">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Constructor </span>
  <span class="org-function-name">Foo</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>:<span class="org-function-name">_name</span><span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Copy constructor</span>
  <span class="org-comment-delimiter">//</span><span class="org-comment">--------------------------</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note: If it is not defined, the compiler, defines </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">a default copy constructor. It was created to demonstrate</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">when the copy constructor is invoked.</span>
  <span class="org-function-name">Foo</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Foo</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>
    _name = rhs._name;    
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Copy constructor invoked."</span> &lt;&lt; <span class="org-constant">std</span>::endl;    
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Copy assignment-operator</span>
  <span class="org-comment-delimiter">//</span><span class="org-comment">--------------------------</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note: It is similar to the copy constructor and</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">default assignment copy-assignment-operator is created</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">by the compiler if the user doesn't define it.</span>
  <span class="org-type">Foo</span> <span class="org-keyword">operator</span><span class="org-function-name">=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Foo</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>    
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Copy-assignment operator invoked."</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> Foo<span class="org-rainbow-delimiters-depth-3">(</span>rhs._name<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">setName</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">){</span>
    _name = name;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> _name;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-2">(){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Foo { name = "</span> &lt;&lt; _name &lt;&lt; <span class="org-string">" } "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">void</span> <span class="org-function-name">show2</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Foo { name = "</span> &lt;&lt; _name &lt;&lt; <span class="org-string">" } "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<p>
Assignment creates a copy, unlike in most OOP languages like Java, C#,
Python and so on. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; Foo foo<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"foo"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = foo <span class="org-rainbow-delimiters-depth-1">}</span> 

<span class="org-comment-delimiter">// </span><span class="org-comment">Assingment creates a copy, unlike in most OO languages</span>
&gt;&gt; Foo bar = foo; 
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.

<span class="org-comment-delimiter">// </span><span class="org-comment">Modifying one of the objects, doens't change the other. </span>
&gt;&gt; bar.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = foo <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; bar.setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"I am object bar"</span><span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; bar.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = I am object bar <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = foo <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">foo and bar objects aren't the same as they have </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">different memory locations. </span>
&gt;&gt; &amp;foo == &amp;bar
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt;
</pre>
</div>

<p>
Primitive and composite types are passed by value in C++, unlike in
most OOP languages. So, it means that a copy of the object is created.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">setFooPrint</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Foo</span> <span class="org-variable-name">param</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">){</span>
  param.setName<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>;
  param.show<span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" name = "</span> &lt;&lt; param.getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Modifying the function paramenter, doesn't modify the passed object.</span>
&gt;&gt; setFooPrint<span class="org-rainbow-delimiters-depth-1">(</span>foo, <span class="org-string">"dummy name"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = dummy name <span class="org-rainbow-delimiters-depth-1">}</span> 
 name = dummy name

&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = foo <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 
</pre>
</div>

<p>
Returning an object from function, creates a copy of the object
instead of returning a reference to it like in Java, Scala, Python and
most languages.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">Foo</span> <span class="org-function-name">modifyReturn</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Foo</span> <span class="org-variable-name">param</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">newName</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  param.setName<span class="org-rainbow-delimiters-depth-2">(</span>newName<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> param;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-keyword">auto</span> ret = modifyReturn<span class="org-rainbow-delimiters-depth-1">(</span>foo, <span class="org-string">"New name"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Foo</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f54f0288050

&gt;&gt; &amp;ret == &amp;foo
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>

&gt;&gt; ret.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = New name <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = foo <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

</pre>
</div>

<p>
Value semantics and STL 
</p>

<ul class="org-ul">
<li>Objects can be stored in STL containers by value, reference or by
pointers.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">Double ended queue collection </span>

&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Foo<span class="org-rainbow-delimiters-depth-1">&gt;</span> xs;

<span class="org-comment-delimiter">// </span><span class="org-comment">Temporary objects are created on the stack, </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">copied to the deque data structure and then </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">put on the collection. </span>
<span class="org-comment-delimiter">// </span>
&gt;&gt; xs.push_back<span class="org-rainbow-delimiters-depth-1">(</span>Foo<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"hello"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.
&gt;&gt; xs.push_back<span class="org-rainbow-delimiters-depth-1">(</span>Foo<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"world"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.
&gt;&gt; xs.push_back<span class="org-rainbow-delimiters-depth-1">(</span>Foo<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"value"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.
&gt;&gt; xs.push_back<span class="org-rainbow-delimiters-depth-1">(</span>Foo<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"semantics"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.
&gt;&gt; 

&gt;&gt; xs
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>Foo<span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> @0x1393820, @0x1393840, @0x1393860, @0x1393880 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; xs.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; 

&gt;&gt; xs.at<span class="org-rainbow-delimiters-depth-1">(</span>0<span class="org-rainbow-delimiters-depth-1">)</span>.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = hello <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; xs.at<span class="org-rainbow-delimiters-depth-1">(</span>0<span class="org-rainbow-delimiters-depth-1">)</span>.show2<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = hello <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 
&gt;&gt; xs.at<span class="org-rainbow-delimiters-depth-1">(</span>2<span class="org-rainbow-delimiters-depth-1">)</span>.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = value <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Error: invoke const reference method which is not annotated with 'const'</span>
&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: xs<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> x.show<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-function-name">ROOT_prompt_56</span>:1:26: error: member function <span class="org-warning">'</span>show<span class="org-warning">'</span> <span class="org-keyword">not</span> viable: 
<span class="org-warning">'</span><span class="org-keyword">this</span><span class="org-warning">'</span> argument has type <span class="org-warning">'</span><span class="org-keyword">const</span> Foo<span class="org-warning">'</span>, but <span class="org-type">function</span> <span class="org-function-name">is</span> <span class="org-keyword">not</span> marked <span class="org-keyword">const</span>
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: xs<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> x.show<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Works as show2() is annotated with 'const'</span>
&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: xs<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> x.show2<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = hello <span class="org-rainbow-delimiters-depth-1">}</span> 
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = world <span class="org-rainbow-delimiters-depth-1">}</span> 
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = value <span class="org-rainbow-delimiters-depth-1">}</span> 
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = semantics <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Watesful for-loop: performs uncessary copies which could slow down and inccur </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">on a significant performance overhead in case of a large object.</span>
&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span>: xs<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> x.show<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = hello <span class="org-rainbow-delimiters-depth-1">}</span> 
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = world <span class="org-rainbow-delimiters-depth-1">}</span> 
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = value <span class="org-rainbow-delimiters-depth-1">}</span> 
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy constructor invoked.
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = semantics <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">By using emplace_back - a copy is not created.</span>
&gt;&gt; <span class="org-keyword">auto</span> xs2 = deque<span class="org-rainbow-delimiters-depth-1">&lt;</span>Foo<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>Foo, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>Foo<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
&gt;&gt; 
&gt;&gt; xs2.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"hello"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; xs2.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"world"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; xs2.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"value"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; xs2.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"semantics"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; xs2
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>Foo, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>Foo<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> @0x411ff30, @0x411ff50, @0x411ff70, @0x411ff90 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: xs2<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> x.show2<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = hello <span class="org-rainbow-delimiters-depth-1">}</span> 
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = world <span class="org-rainbow-delimiters-depth-1">}</span> 
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = value <span class="org-rainbow-delimiters-depth-1">}</span> 
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = semantics <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 
</pre>
</div>

<p>
<b>Reference Semantics in C++</b>
</p>

<p>
Unlike in most programming languages where reference semantics for
complex types such as object is the default behavior, in C++ reference
semantics requires explicit annotation with reference operator (&amp;) or
passing objects by pointer. 
</p>

<p>
The default behavior of passing by value cause significant memory and
performance overhead. In order to avoid unnecessary copies, it is
preferable to pass objects by reference with operator (&amp;) or by const
reference when the object is not supposed to be modified by the
function the objects are passed to.
</p>

<ul class="org-ul">
<li>Create a reference in assignment operation instead of a copy.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = foo <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; Foo&amp; ref1 = foo;

&gt;&gt; ref1.setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"I am foo reference"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = I am foo reference <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">The reference has the same memory location of foo.</span>
&gt;&gt; &amp;foo == &amp;ref1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Passing a parameter by reference instead of passing it by
value. Note: that the copy constructor is not invoked when passing
by reference.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">setFooPrintRef</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Foo</span>&amp; <span class="org-variable-name">param</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">){</span>
  param.setName<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span>;
  param.show<span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" name = "</span> &lt;&lt; param.getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; setFooPrintRef<span class="org-rainbow-delimiters-depth-1">(</span>foo, <span class="org-string">"dummy name"</span><span class="org-rainbow-delimiters-depth-1">)</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = dummy name <span class="org-rainbow-delimiters-depth-1">}</span> 
 name = dummy name

&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = dummy name <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Returning objects from functions as references.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">Foo</span>&amp; <span class="org-function-name">modifyReturnRef</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Foo</span>&amp; <span class="org-variable-name">param</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">newName</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  param.setName<span class="org-rainbow-delimiters-depth-2">(</span>newName<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> param;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; foo.setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"unnamed"</span><span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; fooRefx.setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"I am foo reference"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = I am foo reference <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; &amp;foo == &amp;fooRefx
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">auto</span>&amp; fooRefAuto = modifyReturnRef<span class="org-rainbow-delimiters-depth-1">(</span>foo, <span class="org-string">"C++ type inference auto!"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Foo</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f54f0288010

&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = C++ type inference <span class="org-keyword">auto</span><span class="org-negation-char">!</span> <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; fooRefAuto.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = C++ type inference <span class="org-keyword">auto</span><span class="org-negation-char">!</span> <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; fooRefAuto.setName<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"C++17"</span><span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = C++17 <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

&gt;&gt; &amp;foo == &amp;fooRefAuto
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Const references cannot be modified as any attempt to change it
will result in a compile-time error.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; Foo foo<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"foo"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = foo <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; foo.getName<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"foo"</span>

&gt;&gt; <span class="org-keyword">const</span> Foo&amp; fooRefConst = modifyReturnRef<span class="org-rainbow-delimiters-depth-1">(</span>foo, <span class="org-string">"C++ constant ref."</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Foo</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7fbf2003c010

&gt;&gt; foo.show<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = C++ constant ref. <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; foo.getName<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"C++ constant ref."</span>
&gt;&gt; 

&gt;&gt; fooRefConst.show2<span class="org-rainbow-delimiters-depth-1">()</span>
Foo <span class="org-rainbow-delimiters-depth-1">{</span> name = C++ constant ref. <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Any attempt to call a method not annotated with const will result </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">in a compile-time error. </span>
&gt;&gt; fooRefConst.show<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-function-name">ROOT_prompt_52</span>:1:1: error: member function <span class="org-warning">'</span>show<span class="org-warning">'</span> <span class="org-keyword">not</span> viable: <span class="org-warning">'</span><span class="org-keyword">this</span><span class="org-warning">'</span> 
argument has type <span class="org-warning">'</span><span class="org-keyword">const</span> Foo<span class="org-warning">'</span>, but <span class="org-type">function</span> <span class="org-function-name">is</span> <span class="org-keyword">not</span> marked <span class="org-keyword">const</span>
fooRefConst.show<span class="org-rainbow-delimiters-depth-1">()</span>
^~~~~~~~~~~
<span class="org-function-name">ROOT_prompt_30</span>:1:6: note: <span class="org-warning">'</span>show<span class="org-warning">'</span> declared here
<span class="org-type">void</span> show<span class="org-rainbow-delimiters-depth-1">(){</span> 
</pre>
</div>

<p>
<b>Summary</b> 
</p>

<ul class="org-ul">
<li>Value Semantics X Reference Semantics
<ul class="org-ul">
<li><span class="underline">Value Semantics</span> -&gt; Objects are assigned, passed to functions and
return from functions as primitive types without being modified
as what is modified is a copy of the object. This is default
behavior of C++.

<ul class="org-ul">
<li>Object A = B; =&gt; (C++ Only) Creates object A as a copy of the object B.</li>

<li>Object A = B.copy() (C#, Java, Python &#x2026;) Creates object A as
copy of object B. As value-semantics is not the default
behavior in thoses languages, it is necessary to invoke some
deep copy method explicity.</li>
</ul></li>

<li><span class="underline">Reference Semantics</span> -&gt; Objects are passed by reference or
pointer; assigned by pointer and so on. Objects passed to
functions using reference semantics can modified. This is the
default behavior of Java, Python, C# and other programming
languages.

<ul class="org-ul">
<li>Object A = B; (C#, Java, Python &#x2026;) =&gt; The object A is
reference to object B. Any modification to A or B will modify
both as the refer to the same memory location.</li>

<li>Object&amp; A = B; (C++ only) =&gt; Creating a reference in C++
requires an explicit annotation with operator (&amp;) as it is
non-default behavior.</li>
</ul></li>
</ul></li>

<li>Most programming languages, except C++, use value-semantics for
primitive types and reference semantics for complex or composite
types such as classes due to performance reasons and avoid
uncessary copies.</li>

<li>C++ uses <span class="underline">values-semantics</span> by default for all types, unlike most
programming languages, when any primitive type or composite type such
as class when assigned, passed to functions or returned from 
functions, a copy is created and the original object is not
changed.</li>

<li><span class="underline">C++ supports both value and reference semantics</span> which is not
default for objects linke in Java, Python and other languages. The
reference semantics requires explicit annotation.</li>

<li>In order to avoid unncessary copies that can lead memory or
peformance overhead, it is preferable to use reference semantics.
In other words, large objects should be passed by reference, const
reference or pointer to functions or methods.</li>

<li>Move semantics optimizes return-by value avoiding unnecessary
copies. The copy overhead that happens when returning an object
from a function can be avoided by defining a move constructor (see
C++11's move semantics) which transfer resource ownership from the
object defined locally within the function body to the returned
object.</li>
</ul>

<p>
<b>Further Reading:</b>
</p>

<ul class="org-ul">
<li>ISO C++ - Reference and Value Semantics -
<a href="https://isocpp.org/wiki/faq/value-vs-ref-semantics">https://isocpp.org/wiki/faq/value-vs-ref-semantics</a>
<ul class="org-ul">
<li>Note: Provides a good and clear definition about what really is
value and reference semantics.</li>
</ul></li>

<li>Taligent Inc. 1995 - Reference and value semantics: C++ versus everything else
<ul class="org-ul">
<li><a href="https://root.cern.ch/TaligentDocs/TaligentOnline/DocumentRoot/1.0/Docs/books/WM/WM_85.html">https://root.cern.ch/TaligentDocs/TaligentOnline/DocumentRoot/1.0/Docs/books/WM/WM_85.html</a></li>
</ul></li>

<li>Andrezj's C++ blog - Value Semantics -
<a href="https://akrzemi1.wordpress.com/2012/02/03/value-semantics/">https://akrzemi1.wordpress.com/2012/02/03/value-semantics/</a></li>

<li>Value Semantics - Code of the danmed
<ul class="org-ul">
<li><a href="http://codeofthedamned.com/index.php/value-semantics">http://codeofthedamned.com/index.php/value-semantics</a></li>
</ul></li>

<li>What do ‘value semantics’ and ‘pointer semantics’ mean?
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/166033/what-do-value-semantics-and-pointer-semantics-mean">https://stackoverflow.com/questions/166033/what-do-value-semantics-and-pointer-semantics-mean</a></li>
</ul></li>

<li>MSDN - Value Types (Modern C++) -
<a href="https://msdn.microsoft.com/en-us/library/hh438479.aspx">https://msdn.microsoft.com/en-us/library/hh438479.aspx</a></li>

<li>My Precious Compile Time Bool (long introduction to Move
Semantics)
<ul class="org-ul">
<li><a href="https://medium.com/@gaussnoise/my-precious-compile-time-bool-long-introduction-to-move-semantics-c9ee73c370c7">https://medium.com/@gaussnoise/my-precious-compile-time-bool-long-introduction-to-move-semantics-c9ee73c370c7</a></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org6a97349" class="outline-3">
<h3 id="org6a97349"><span class="section-number-3">1.18</span> <span class="todo TODO">TODO</span> Memory Allocation - Stack X Heap</h3>
<div class="outline-text-3" id="text-1-18">
</div>
<div id="outline-container-org2001048" class="outline-4">
<h4 id="org2001048"><span class="section-number-4">1.18.1</span> Program/Process memory</h4>
<div class="outline-text-4" id="text-1-18-1">
<p>
The memory of a process or running program (compile object-code) can
be divided into the <span class="underline">segments</span>:
</p>

<ul class="org-ul">
<li><b>Code</b> (text segment):
<ul class="org-ul">
<li>Contains the program compiled as object-code. Generally, this
segment is read-only.</li>
</ul></li>

<li><b>Bss</b>:
<ul class="org-ul">
<li>Contains non-initialized global variables.</li>
</ul></li>

<li><b>Data</b>:
<ul class="org-ul">
<li>Contains intialized global variables.</li>
</ul></li>

<li><b>Stack</b> (aka Call-stack) or stack memory 
<ul class="org-ul">
<li>Contains function arguments and current function's <span class="underline">local variables</span>.</li>
<li>In C++, variables, objects and arrays are allocated on the stack
by default.</li>
<li>Variables: allocated at compile-time.</li>
<li>Stack-allocated variables are also called automatic variables.</li>
<li>Limit: Stack is limited, on Linux Kernel 8 kb (kbytes). Large
objects should not be allocated on the stack.</li>
<li>Memory management: Variables are automatically deleted when out
of scope.</li>
</ul></li>

<li><b>Heap</b> (dynamic memory or free-store)
<ul class="org-ul">
<li>Dynamically allocated variables or objects (variables allocated
with C++ new operator or C-malloc) are instatiated on the heap.</li>
<li>Example - heap-allocated array: <span class="underline">int* ptr = new int [10]</span>;</li>
<li>Variables: allocated at runtime.</li>
<li>Limit: The limit is the RAM memory or the virtual memory.</li>
<li>Memory management: Manual (C++ is not garbage collected), for
every statement with <span class="underline">new</span> operator, there must be a matching
delete operator releasing the allocated memory in order to avoid
memory leak.</li>
<li>Only accessible through pointers.</li>
</ul></li>
</ul>

<p>
Further reading: 
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Data_segment">Data segment - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Memory_segmentation">Memory segmentation - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Virtual_memory">Virtual memory - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/.bss">.bss - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Page_table">Page table - Wikipedia</a></li>
<li><a href="https://wiki.osdev.org/ELF">ELF - OSDev Wiki</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgae8eb38" class="outline-4">
<h4 id="orgae8eb38"><span class="section-number-4">1.18.2</span> stack Allocation - Automatic Variables</h4>
<div class="outline-text-4" id="text-1-18-2">
</div>
<ol class="org-ol">
<li><a id="org88ceb3e"></a>Overview<br />
<div class="outline-text-5" id="text-1-18-2-1">
<p>
In C++, variables, objects or arrays defined inside functions are
allocated on the stack by default. The memory allocated is
automatically released when they go out scope, thus there is no need
to worry about allocation in this case. 
</p>

<p>
Stack allocation features: 
</p>

<ul class="org-ul">
<li>Variables allocated on the stack are also called <span class="underline">automatic variables</span>.</li>

<li>The array size cannot be changed at runtime and it cannot grow or
shrink. Therefore, it is not possible to allocate an array in this way:
<ul class="org-ul">
<li><span class="underline">int n = 10; double array[n]</span>;</li>
</ul></li>

<li><span class="underline">The stack has limited size</span>, the Linux Kernel has an 8 Mbs stack,
as a result, large objects cannot be allocated in the stack. So, if
one tries to allocate an array: <span class="underline">int array[1000000000]</span>, it will cause
segmentation fault.

<ul class="org-ul">
<li>TL;DR: Large objects should be allocated on the heap or dynamic
memory.</li>
</ul></li>

<li>Primitive type variable, objects and arrays are automatically
released (aka deleted) when they go out of scope. In the case of
objects, their dectructors methods or member functions are always
called.</li>
</ul>
</div>
</li>
<li><a id="orga5e054b"></a>Example: Stack-allocated arrays<br />
<div class="outline-text-5" id="text-1-18-2-2">
<p>
Try to define/allocate a variable-size array. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">int</span> k = 4;

<span class="org-comment-delimiter">// </span><span class="org-comment">Error: It is impossible to allocate variable-size array on stack or</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">static memory (as global variable).</span>
&gt;&gt; <span class="org-type">double</span> arr_flt<span class="org-rainbow-delimiters-depth-1">[</span>k<span class="org-rainbow-delimiters-depth-1">]</span>;
<span class="org-function-name">ROOT_prompt_38</span>:1:8: error: variable length array 
declaration <span class="org-keyword">not</span> allowed at file scope

</pre>
</div>

<p>
Defining an stack-allocated array with size set by const variable. In
C++, it is preferable to use const variable instead of preprocessor
macros for defining consts.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">DO NOT: #define arra_size 3 </span>
&gt;&gt; <span class="org-keyword">const</span> size_t arr_size = 3;
&gt;&gt; <span class="org-type">double</span> arr_flt<span class="org-rainbow-delimiters-depth-1">[</span>arr_size<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">[</span>3<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 0.0000000, 0.0000000, 0.0000000 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 
</pre>
</div>


<p>
Defining an stack-allocated array, assuming that all statements are
executed inside a function.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Define array </span>
&gt;&gt; <span class="org-type">int</span> arr1<span class="org-rainbow-delimiters-depth-1">[</span>5<span class="org-rainbow-delimiters-depth-1">]</span>;

&gt;&gt; arr1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-2">[</span>5<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 0, 0, 0, 0, 0 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Set elements </span>
&gt;&gt; arr1<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = 10, arr1<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = 5; arr1<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = 6, arr1<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = 9, arr1<span class="org-rainbow-delimiters-depth-1">[</span>4<span class="org-rainbow-delimiters-depth-1">]</span> = 15;
&gt;&gt; 

&gt;&gt; arr1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-2">[</span>5<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 10, 5, 6, 9, 15 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Query elements </span>
&gt;&gt; arr1<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
&gt;&gt; arr1<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 6
&gt;&gt; arr1<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 9
&gt;&gt; 
</pre>
</div>

<p>
Loop over array: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 5; i++<span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" "</span> &lt;&lt; arr1<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; <span class="org-string">"\n"</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 10
 5
 6
 9
 15
&gt;&gt; 
</pre>
</div>

<p>
Array as a pointer: 
</p>

<ul class="org-ul">
<li>The array <span class="underline">arr1</span> is actually a pointer to its first element. This
array is a memory block of five consecutive allocated integers with
the same size.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">The array is actually a pointer to array[0] or the 0-th </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">first element of memory block.</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">-------------------------------------------------</span>
&gt;&gt; *arr1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
<span class="org-comment-delimiter">// </span><span class="org-comment">Second memory block </span>
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>arr1 + 1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 5
<span class="org-comment-delimiter">// </span><span class="org-comment">Third memory block </span>
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>arr1 + 2<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 6
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>arr1 + 3<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 9
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>arr1 + 4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15
&gt;&gt;

&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>&amp;arr1<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> + 0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>&amp;arr1<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> + 1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 5
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>&amp;arr1<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> + 2<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 6
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>&amp;arr1<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> + 3<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 9
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>&amp;arr1<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> + 4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15
&gt;&gt; 
</pre>
</div>

<p>
Many ways to manipulate the third element (index 2):
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>&amp;arr1<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> + 2<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 6
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>&amp;arr1<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> + 2<span class="org-rainbow-delimiters-depth-1">)</span> = 25
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 25
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>&amp;arr1<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span> + 2<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 25
&gt;&gt; arr1<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 25
&gt;&gt; 
</pre>
</div>

<p>
Passing arrays to functions: 
</p>

<ul class="org-ul">
<li>An array (C-arrays) is not aware of its size, thus this parameter
must be passed to functions alongside the array or pointer to
first element.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">printArray</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">size</span>, <span class="org-type">int</span> <span class="org-variable-name">xs</span> <span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; size; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; xs["</span> &lt;&lt; i &lt;&lt; <span class="org-string">"] = "</span> &lt;&lt; xs<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">printArray2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">size</span>, <span class="org-type">int</span>* <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; size; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; xs["</span> &lt;&lt; i &lt;&lt; <span class="org-string">"] = "</span> &lt;&lt; xs<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">printArray3</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">size</span>, <span class="org-type">int</span>* <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; size; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; xs["</span> &lt;&lt; i &lt;&lt; <span class="org-string">"] = "</span> &lt;&lt; *<span class="org-rainbow-delimiters-depth-2">(</span>xs + i<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; printArray<span class="org-rainbow-delimiters-depth-1">(</span>5, arr1<span class="org-rainbow-delimiters-depth-1">)</span>
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = 10
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = 5
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = 25
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = 9
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>4<span class="org-rainbow-delimiters-depth-1">]</span> = 15
&gt;&gt; 

&gt;&gt; printArray2<span class="org-rainbow-delimiters-depth-1">(</span>5, arr1<span class="org-rainbow-delimiters-depth-1">)</span>
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = 10
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = 5
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = 25
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = 9
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>4<span class="org-rainbow-delimiters-depth-1">]</span> = 15

&gt;&gt; printArray2<span class="org-rainbow-delimiters-depth-1">(</span>3, arr1<span class="org-rainbow-delimiters-depth-1">)</span>
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = 10
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = 5
 =&gt; xs<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = 25
&gt;&gt; 

</pre>
</div>
</div>
</li>
<li><a id="orgf9fa304"></a>Example: Stack-allocated objects<br />
<div class="outline-text-5" id="text-1-18-2-3">
<p>
Example: <b>Stack-allocated object.</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">SomeClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Internal state </span>
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">_id</span>; 
<span class="org-function-name">public</span>:
   <span class="org-comment-delimiter">// </span><span class="org-comment">Default constructor is created by the compiler</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">if not defined. </span>
   <span class="org-function-name">SomeClass</span><span class="org-rainbow-delimiters-depth-2">()</span>
     : _id<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"unnamed"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>

   <span class="org-function-name">SomeClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-2">)</span>
      : _id<span class="org-rainbow-delimiters-depth-2">(</span>id<span class="org-rainbow-delimiters-depth-2">)</span> 
   <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[LOG] Object created = &lt;"</span> &lt;&lt; _id &lt;&lt; <span class="org-string">"&gt; \n"</span>; 
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">(){</span> 
      <span class="org-keyword">return</span> _id;  
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-type">void</span> <span class="org-function-name">setID</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-2">){</span> 
      _id = id;  
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Copy-constructor is created by default by the compiler,</span>
   <span class="org-function-name">SomeClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">SomeClass</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[LOG] Copy-constructo Object copyed = &lt;"</span> &lt;&lt; rhs._id &lt;&lt; <span class="org-string">"&gt;\n"</span>;
     <span class="org-keyword">this</span>-&gt;_id = rhs._id;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Copy-assignment operator -</span>
   <span class="org-type">SomeClass</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">SomeClass</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[LOG] Copy-assign operator Object copyed = &lt;"</span> &lt;&lt; rhs._id &lt;&lt; <span class="org-string">"&gt;\n"</span>;
     <span class="org-keyword">this</span>-&gt;_id = rhs._id;
     <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>

   <span class="org-comment-delimiter">// </span><span class="org-comment">Destructor - is always generated by compiler</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">if not specified. </span>
   ~<span class="org-function-name">SomeClass</span><span class="org-rainbow-delimiters-depth-2">()</span>
   <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[LOG] I was deleted &lt;"</span> &lt;&lt; _id &lt;&lt; <span class="org-string">"&gt; "</span> &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Object - Allocated on stack or static memory</b>
</p>

<p>
Any object allocated on the stack (locally on the function) such as
the variable cls is automatically deleted when it goes out of scope. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Return reference.</span>
<span class="org-type">SomeClass</span>&amp; <span class="org-function-name">Function</span><span class="org-rainbow-delimiters-depth-1">(){</span>  
   <span class="org-type">SomeClass</span> <span class="org-variable-name">cls</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"object-1"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Object id = "</span> &lt;&lt; cls.getID<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-keyword">return</span> cls;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; SomeClass&amp; clsref = Function<span class="org-rainbow-delimiters-depth-1">()</span>

<span class="org-rainbow-delimiters-depth-1">[</span>LOG<span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>object-1<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
Object id = object-1
<span class="org-rainbow-delimiters-depth-1">[</span>LOG<span class="org-rainbow-delimiters-depth-1">]</span> I was deleted <span class="org-rainbow-delimiters-depth-1">&lt;</span>object-1<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">(</span>SomeClass &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7ffcbbe2eed0

<span class="org-comment-delimiter">// </span><span class="org-comment">DO NOT DO IT! Reference to deleted object</span>
&gt;&gt; clsref.getID<span class="org-rainbow-delimiters-depth-1">()</span>

 *** Break *** segmentation violation
</pre>
</div>

<p>
<b>Stack-allocated array of objects</b>
</p>

<ul class="org-ul">
<li>An array of objects is always intialized with default-constructor</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">  &gt;&gt; SomeClass arr1<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span>;
  <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-constructo Object copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>unnamed<span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-constructo Object copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>unnamed<span class="org-rainbow-delimiters-depth-1">&gt;</span>
  <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-constructo Object copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>unnamed<span class="org-rainbow-delimiters-depth-1">&gt;</span>
  &gt;&gt; 

&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"unnamed"</span>
&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"unnamed"</span>
&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"unnamed"</span>
&gt;&gt; 
&gt;&gt; 

</pre>
</div>

<ul class="org-ul">
<li>Intialized array</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Intialized array </span>
&gt;&gt; SomeClass arr2<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = <span class="org-rainbow-delimiters-depth-1">{</span> SomeClass<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"obj1"</span><span class="org-rainbow-delimiters-depth-2">)</span>, SomeClass<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"obj2"</span><span class="org-rainbow-delimiters-depth-2">)</span>, SomeClass<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"obj3"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>obj1<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>obj2<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>obj3<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-constructo Object copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>obj1<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-constructo Object copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>obj2<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-constructo Object copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>obj3<span class="org-rainbow-delimiters-depth-1">&gt;</span>

&gt;&gt; arr2<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"obj1"</span>
&gt;&gt; arr2<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"obj2"</span>
&gt;&gt; arr2<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"obj3"</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Uniform initialization </span>
&gt;&gt; SomeClass arr3<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"objA"</span><span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"objB"</span><span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"objC"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; SomeClass arr3<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"objA"</span><span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"objB"</span><span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"objC"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>objA<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>objB<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>objC<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-constructo Object copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>objA<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-constructo Object copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>objB<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-constructo Object copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>objC<span class="org-rainbow-delimiters-depth-1">&gt;</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Manipulating objects in array:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; arr1<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.setID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"O1"</span><span class="org-rainbow-delimiters-depth-1">)</span>, arr1<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.setID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"O2"</span><span class="org-rainbow-delimiters-depth-1">)</span>, arr1<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>.setID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"O3"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
&gt;&gt; arr1<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"O1"</span>
&gt;&gt; arr1<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"O2"</span>
&gt;&gt; arr1<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"O3"</span>
&gt;&gt;
</pre>
</div>

<ul class="org-ul">
<li>Loop over array elements:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">showArray</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">SomeClass</span> <span class="org-variable-name">xs</span> <span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"obj["</span> &lt;&lt; i &lt;&lt; <span class="org-string">"] = "</span> &lt;&lt; xs<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span>.getID<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">", "</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
  <span class="org-constant">std</span>::cout.flush<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; showArray<span class="org-rainbow-delimiters-depth-1">(</span>3, arr1<span class="org-rainbow-delimiters-depth-1">)</span>
obj<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = O1, obj<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = O2, obj<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = O3, 

&gt;&gt; showArray<span class="org-rainbow-delimiters-depth-1">(</span>3, arr2<span class="org-rainbow-delimiters-depth-1">)</span>
obj<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = obj1, obj<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = obj2, obj<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = obj3, 

&gt;&gt; showArray<span class="org-rainbow-delimiters-depth-1">(</span>3, arr3<span class="org-rainbow-delimiters-depth-1">)</span>
obj<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = objA, obj<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = objB, obj<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = objC, 
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Assign array elements:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; showArray<span class="org-rainbow-delimiters-depth-1">(</span>3, arr2<span class="org-rainbow-delimiters-depth-1">)</span>
obj<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = obj1, obj<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = obj2, obj<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = obj3, 
&gt;&gt; 

&gt;&gt; arr2<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = SomeClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"1st-object"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>1st-object<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-assign <span class="org-keyword">operator</span> <span class="org-type">Object</span> copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>1st-object<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>1st-object<span class="org-rainbow-delimiters-depth-1">&gt;</span> 

&gt;&gt; arr2<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"1st-object"</span>

&gt;&gt; arr2<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> =  <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"2nd-element"</span><span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Uniform initialization</span>
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>2nd-element<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-assign <span class="org-keyword">operator</span> <span class="org-type">Object</span> copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>2nd-element<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>2nd-element<span class="org-rainbow-delimiters-depth-1">&gt;</span> 

&gt;&gt; arr2<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"2nd-element"</span>
&gt;&gt; 

&gt;&gt; showArray<span class="org-rainbow-delimiters-depth-1">(</span>3, arr2<span class="org-rainbow-delimiters-depth-1">)</span>
obj<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = 1st-object, obj<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = 2nd-element, obj<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = obj3, 
</pre>
</div>

<ul class="org-ul">
<li>Defining an array inside a function:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">exampleFunction</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = 4;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Deleted when out of scope.</span>
  <span class="org-type">SomeClass</span> <span class="org-variable-name">xss</span> <span class="org-rainbow-delimiters-depth-2">[</span>n<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"C++98"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"C++11"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"C++17"</span><span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"C++20"</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span> ;
  showArray<span class="org-rainbow-delimiters-depth-2">(</span>n, xss<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; exampleFunction<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">[</span>LOG<span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>C++98<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>C++11<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>C++17<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>C++20<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
obj<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = C++98, obj<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = C++11, obj<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = C++17, obj<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = C++20, 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>C++20<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>C++17<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>C++11<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>C++98<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org0f44fb5" class="outline-4">
<h4 id="org0f44fb5"><span class="section-number-4">1.18.3</span> Dynamic/Heap Allocation</h4>
<div class="outline-text-4" id="text-1-18-3">
</div>
<ol class="org-ol">
<li><a id="orged946f1"></a>Overview<br />
<div class="outline-text-5" id="text-1-18-3-1">
<p>
<b>When dynamic allocation is needed</b>
</p>

<p>
Situation where dynamic allocation is needed: 
</p>

<ul class="org-ul">
<li>The number of elements to be allocated is not known in advance.</li>
<li>The array or data structure needs to allocate more memory on
demand.</li>
<li>Return an instance of a polymorphic class from a function. (Factory
function.)</li>
<li>Type erasure: any object allocated on the heap can have its pointer
casted to void* and then casted back to the object type.</li>
</ul>

<p>
Note: 
</p>

<ul class="org-ul">
<li>Using new and delete with raw pointers is error prone and not
safe. In C++ &gt;= C++11, it is safer and better to use RAII technique
through the usage of smart pointers.
<ul class="org-ul">
<li>SUMMARY: Use std::unique_ptr or std::shared_ptr instead of new
and delete.</li>
</ul></li>

<li>Dynamic allocation of arrays is often not needed as STL containers
already encapsulates the heap allocation and automatically
allocate new memory when a new element is added.
<ul class="org-ul">
<li>SUMMARY: Use std::vector, std::array, std::deque instead of
dynamically allocated arrays.</li>
</ul></li>
</ul>

<p>
Potential pitfalls: 
</p>

<ul class="org-ul">
<li>Dangling pointer</li>
<li>Null-pointer access</li>
<li>Wild pointers</li>
<li>Heap corruption</li>
<li>Ownership Semantics</li>
<li>Non deterministic allocation on embedded systems or real time
systems.</li>
</ul>

<p>
<b>Operators new and delete for a single element</b>
</p>

<p>
The following code shows the general usage of the operator new.
</p>

<p>
Allocation with exception: 
</p>

<ul class="org-ul">
<li>Note: The operator <span class="underline">new</span> always throws an exception bad_alloc if the
allocation fails.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">try</span><span class="org-rainbow-delimiters-depth-1">{</span>
 <span class="org-type">Type</span>* <span class="org-variable-name">object_pointer1</span> = <span class="org-keyword">new</span> <span class="org-type">Type</span>;
 <span class="org-comment-delimiter">//  </span><span class="org-comment">Intialized with constructor arguments</span>
 <span class="org-type">Type</span>* <span class="org-variable-name">object_pointer2</span> = <span class="org-keyword">new</span> <span class="org-type">Type</span><span class="org-rainbow-delimiters-depth-2">(</span>arg0, arg1, arg2 ...<span class="org-rainbow-delimiters-depth-2">)</span>;
 <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">bad_alloc</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error: failed to allocate memory."</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error = "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    exit<span class="org-rainbow-delimiters-depth-2">(</span>1<span class="org-rainbow-delimiters-depth-2">)</span>;
 <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Allocation without exception:
</p>

<ul class="org-ul">
<li>When the allocation fails, the operator returns a null pointer.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">Type</span>* <span class="org-variable-name">object_pointer1</span> = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span>nothrow<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">Type</span>;
<span class="org-comment-delimiter">//  </span><span class="org-comment">Intialized with constructor arguments</span>
<span class="org-type">Type</span>* <span class="org-variable-name">object_pointer2</span> = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span>nothrow<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">Type</span><span class="org-rainbow-delimiters-depth-1">(</span>arg0, arg1, arg2 ...<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-negation-char">!</span>object_pointer1<span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error: failed to allocate memory for obj1."</span> &lt;&lt; <span class="org-string">"\n"</span>;
   exit<span class="org-rainbow-delimiters-depth-2">(</span>1<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>object_pointer1 == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error: failed to allocate memory for obj1."</span> &lt;&lt; <span class="org-string">"\n"</span>;
   exit<span class="org-rainbow-delimiters-depth-2">(</span>1<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Deallocation: 
</p>

<ul class="org-ul">
<li>After the heap-allocated object is no longer needed, it is
necessary to release the allocated memory by using the delete
operator.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">delete</span> object_pointer1;
<span class="org-comment-delimiter">// </span><span class="org-comment">A good practice is to set the pointer to null</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">after the object is released.</span>
object_pointer1 = <span class="org-constant">nullptr</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Deleting a null pointer is always safe and does nothing.  </span>
<span class="org-keyword">delete</span> object_pointer1;
</pre>
</div>


<p>
<b>Operators new and delete for array allocation</b>
</p>

<p>
An array of elements of type Type can be allocated on the heap with:
</p>

<p>
Allocation with exception: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">SIZE</span> = 10;
<span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">Type</span>* <span class="org-variable-name">array_pointer</span> = <span class="org-keyword">new</span> <span class="org-type">Type</span> <span class="org-rainbow-delimiters-depth-2">[</span>SIZE<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">bad_alloc</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error: failed to allocate memory."</span> &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error = "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Allocation without exception: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">SIZE</span> = 10;
<span class="org-type">Type</span>* <span class="org-variable-name">array_pointer</span> = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span>nothrow<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">Type</span> <span class="org-rainbow-delimiters-depth-1">[</span>SIZE<span class="org-rainbow-delimiters-depth-1">]</span>;
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-negation-char">!</span>array_pointer<span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error: failed to allocate memory."</span> &lt;&lt; <span class="org-string">"\n"</span>;
  exit<span class="org-rainbow-delimiters-depth-2">(</span>1<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Or more explicitly</span>
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>array_pointer == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error: failed to allocate memory."</span> &lt;&lt; <span class="org-string">"\n"</span>;
  exit<span class="org-rainbow-delimiters-depth-2">(</span>1<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Deallocation: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">delete</span> <span class="org-rainbow-delimiters-depth-1">[]</span> array_pointer;
</pre>
</div>
</div>
</li>

<li><a id="org61375b3"></a>Heap allocation for primitive types<br />
<div class="outline-text-5" id="text-1-18-3-2">
<p>
Allocation of single value on the heap: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">double</span>* ptr = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span>nothrow<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">double</span>;

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptr != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"OK, proceed"</span> &lt;&lt; <span class="org-string">"\n"</span>;
OK, proceed
&gt;&gt; 

&gt;&gt; *ptr = 100.0;

&gt;&gt; *ptr
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.00000
&gt;&gt; 3.0 * *ptr
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 300.00000
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Always delete the pointer when the </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">allocated object is no longer needed.</span>
&gt;&gt; <span class="org-keyword">delete</span> ptr;

<span class="org-comment-delimiter">// </span><span class="org-comment">Always set the pointer to null </span>
&gt;&gt; ptr = <span class="org-constant">nullptr</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Deleting a null pointer is safe and does nothing.</span>
&gt;&gt; <span class="org-keyword">delete</span> ptr;
</pre>
</div>

<p>
Array allocation on the heap: 
</p>

<ul class="org-ul">
<li>Allocate array.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">size_t</span> <span class="org-variable-name">n</span> = 6;

<span class="org-comment-delimiter">// </span><span class="org-comment">Array of size 6</span>
<span class="org-type">int</span>* <span class="org-variable-name">arr</span> = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span>nothrow<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-1">[</span>n<span class="org-rainbow-delimiters-depth-1">]</span>;

&gt;&gt; arr
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x216cbf0

<span class="org-comment-delimiter">// </span><span class="org-comment">Not initialized, can have any value. </span>
&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 36003472
&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 1864399218
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Set array elements:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = 10;
&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = 0, arr<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = 15, arr<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = 20, arr<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = 90;
&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>4<span class="org-rainbow-delimiters-depth-1">]</span> = 4, arr<span class="org-rainbow-delimiters-depth-1">[</span>5<span class="org-rainbow-delimiters-depth-1">]</span> = 3;

&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 90
&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>5<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 3
&gt;&gt; 

</pre>
</div>

<ul class="org-ul">
<li>Access array elements with pointer offset.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Access with pointer + offset </span>
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>arr + 0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>arr + 1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 15
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>arr + 2<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 20
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>arr + 3<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 90
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>arr + 4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>arr + 5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 3
&gt;&gt; 

&gt;&gt; *<span class="org-rainbow-delimiters-depth-1">(</span>arr + 3<span class="org-rainbow-delimiters-depth-1">)</span> = 100;
&gt;&gt; arr<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 100
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Delete heap-allocated array.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">delete</span> <span class="org-rainbow-delimiters-depth-1">[]</span> arr;

<span class="org-comment-delimiter">// </span><span class="org-comment">Avoid dangling pointer</span>
&gt;&gt; arr = <span class="org-constant">nullptr</span>;
</pre>
</div>
</div>
</li>

<li><a id="org2d1ca89"></a>Heap allocation for objects<br />
<div class="outline-text-5" id="text-1-18-3-3">
<p>
Consider the following testing class: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">SomeClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Internal state </span>
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">_id</span>; 
<span class="org-function-name">public</span>:
   <span class="org-comment-delimiter">// </span><span class="org-comment">Default constructor is created by the compiler</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">if not defined. </span>
   <span class="org-function-name">SomeClass</span><span class="org-rainbow-delimiters-depth-2">()</span>
     : _id<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"unnamed"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[LOG] CTOR0 - Object created = &lt;"</span> &lt;&lt; _id &lt;&lt; <span class="org-string">"&gt; \n"</span>; 
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-function-name">SomeClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-2">)</span>
      : _id<span class="org-rainbow-delimiters-depth-2">(</span>id<span class="org-rainbow-delimiters-depth-2">)</span> 
   <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[LOG] Object created = &lt;"</span> &lt;&lt; _id &lt;&lt; <span class="org-string">"&gt; \n"</span>; 
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">(){</span> 
      <span class="org-keyword">return</span> _id;  
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-type">void</span> <span class="org-function-name">setID</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-2">){</span> 
      _id = id;  
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Copy-constructor is created by default by the compiler,</span>
   <span class="org-function-name">SomeClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">SomeClass</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[LOG] Copy-constructo Object copyed = &lt;"</span> &lt;&lt; rhs._id &lt;&lt; <span class="org-string">"&gt;\n"</span>;
     <span class="org-keyword">this</span>-&gt;_id = rhs._id;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Copy-assignment operator -</span>
   <span class="org-type">SomeClass</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">SomeClass</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[LOG] Copy-assign operator Object copyed = &lt;"</span> &lt;&lt; rhs._id &lt;&lt; <span class="org-string">"&gt;\n"</span>;
     <span class="org-keyword">this</span>-&gt;_id = rhs._id;
     <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>

   <span class="org-comment-delimiter">// </span><span class="org-comment">Destructor - is always generated by compiler</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">if not specified. </span>
   ~<span class="org-function-name">SomeClass</span><span class="org-rainbow-delimiters-depth-2">()</span>
   <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"[LOG] I was deleted &lt;"</span> &lt;&lt; _id &lt;&lt; <span class="org-string">"&gt; "</span> &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Creating a single object on the heap:</b>
</p>

<p>
Create object:
</p>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-comment-delimiter">// </span><span class="org-comment">SomeClass* heapPtr = new (nothrow) SomeClass</span>
&gt;&gt; SomeClass* heapPtr = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span>nothrow<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">SomeClass</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"heap-obj1"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">[</span>LOG<span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>heap-obj1<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">SomeClass</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x2c10fe0
&gt;&gt; 

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>heapPtr != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [LOG] Everything OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Everything OK.
&gt;&gt; 

&gt;&gt; heapPtr-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"heap-obj1"</span>
&gt;&gt; 
&gt;&gt; heapPtr-&gt;setID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Object100"</span><span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; heapPtr-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Object100"</span>
&gt;&gt; 
&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>*heapPtr<span class="org-rainbow-delimiters-depth-1">)</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Object100"</span>
&gt;&gt; 
</pre>
</div>

<p>
Delete object:
</p>

<ul class="org-ul">
<li>The delete operator always invokes destructor.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">delete</span> heapPtr;
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>Object100<span class="org-rainbow-delimiters-depth-1">&gt;</span> 

&gt;&gt; heapPtr = <span class="org-constant">nullptr</span>;
</pre>
</div>

<p>
<b>Creating an array of objects on the heap</b> 
</p>

<ul class="org-ul">
<li>Create array:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; SomeClass* p = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span>nothrow<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">SomeClass</span><span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span>;
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> CTOR0 - Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>unnamed<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> CTOR0 - Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>unnamed<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> CTOR0 - Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>unnamed<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
&gt;&gt; 

&gt;&gt; p<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"unnamed"</span>
&gt;&gt; p<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"unnamed"</span>
&gt;&gt; p<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"unnamed"</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Access elements</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-comment-delimiter">// </span><span class="org-comment">Comman operator.</span>
&gt;&gt; p<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.setID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"obj0"</span><span class="org-rainbow-delimiters-depth-1">)</span>, p<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.setID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"obj1"</span><span class="org-rainbow-delimiters-depth-1">)</span>, p<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>.setID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"obj2"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; p<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"obj0"</span>

&gt;&gt; p<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"obj1"</span>

&gt;&gt; p<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"obj2"</span>
&gt;&gt;

</pre>
</div>

<ul class="org-ul">
<li>Access elements by pointer offset
<ul class="org-ul">
<li>Note: It is possible because the array is a pointer to the first
allocated element. Thus, an array is not aware of its size that
must be remembered and passed as function argument alongside the
array.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Get ID of first element </span>
&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>p + 0<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"obj0"</span>
&gt;&gt; 
&gt;&gt; p-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"obj0"</span>

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>p + 1<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"obj1"</span>

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>p + 2<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"obj2"</span>

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>p + 0<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;setID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"elem-zero"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>p + 1<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;setID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"elem-one"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>p + 2<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;setID<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"elem-two"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>p + 0<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"elem-zero"</span>
&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>p + 1<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"elem-one"</span>
&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>p + 2<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"elem-two"</span>
</pre>
</div>

<ul class="org-ul">
<li>Array assignment</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; p<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = SomeClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"objA"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>objA<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-assign <span class="org-keyword">operator</span> <span class="org-type">Object</span> copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>objA<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>objA<span class="org-rainbow-delimiters-depth-1">&gt;</span> 

&gt;&gt; p<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"objA"</span>
&gt;&gt; 

&gt;&gt; p<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"ObjB"</span><span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Uniform initialization</span>
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created = <span class="org-rainbow-delimiters-depth-1">&lt;</span>ObjB<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy-assign <span class="org-keyword">operator</span> <span class="org-type">Object</span> copyed = <span class="org-rainbow-delimiters-depth-1">&lt;</span>ObjB<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>ObjB<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
&gt;&gt; 

&gt;&gt; p<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"ObjB"</span>
&gt;&gt; 

</pre>
</div>

<ul class="org-ul">
<li>Pass array to function:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">showArray</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">SomeClass</span> <span class="org-variable-name">xs</span> <span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"obj["</span> &lt;&lt; i &lt;&lt; <span class="org-string">"] = "</span> &lt;&lt; xs<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span>.getID<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">", "</span>;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n"</span>;
  <span class="org-constant">std</span>::cout.flush<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; showArray<span class="org-rainbow-delimiters-depth-1">(</span>3, p<span class="org-rainbow-delimiters-depth-1">)</span>
obj<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = objA, obj<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = ObjB, obj<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = elem-two, 
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Release memory by deleting the heap-allocated array.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">delete</span> <span class="org-rainbow-delimiters-depth-1">[]</span> p;
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>elem-two<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>ObjB<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> I was <span class="org-type">deleted</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span>objA<span class="org-rainbow-delimiters-depth-1">&gt;</span> 

&gt;&gt; p = <span class="org-constant">nullptr</span>;
&gt;&gt; 
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org941d117" class="outline-4">
<h4 id="org941d117"><span class="section-number-4">1.18.4</span> Limits of stack and heap allocation</h4>
<div class="outline-text-4" id="text-1-18-4">
<p>
This small program aims to test the limits of stack and heap
allocation by allowing the user to set the size of a float point array
and whether its allocation will happen on stack or heap using
pre-processor directives. 
</p>

<p>
File: <a href="src/stack-allocation-test.cpp">file:src/stack-allocation-test.cpp</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">File:   stack-allocation-test </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Brief:  Test limits of stack or heap allocation. </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Author: Caio Rodrigues</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">------------------------------------------------------</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> ARRAY_SIZE
<span class="org-preprocessor">   #define</span> <span class="org-variable-name">ARRAY_SIZE</span> 8000
<span class="org-preprocessor">#endif</span> 

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-type">size_t</span> <span class="org-variable-name">sizeKB</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>ARRAY_SIZE<span class="org-rainbow-delimiters-depth-2">)</span> * <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span> / 1024;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [LOG] Number of elements = "</span> &lt;&lt; ARRAY_SIZE &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [LOG] Array size in Kbytes = "</span> &lt;&lt; sizeKB &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-preprocessor">    #if</span> <span class="org-negation-char">!</span><span class="org-preprocessor">defined</span> HEAP || HEAP == 0
       <span class="org-comment-delimiter">// </span><span class="org-comment">===&gt; Stack allocation </span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [LOG] Stack allocation."</span> &lt;&lt; <span class="org-string">"\n"</span>;
       <span class="org-type">double</span> <span class="org-variable-name">array</span> <span class="org-rainbow-delimiters-depth-2">[</span>ARRAY_SIZE<span class="org-rainbow-delimiters-depth-2">]</span>;
<span class="org-preprocessor">    #else</span>
       <span class="org-comment-delimiter">// </span><span class="org-comment">===&gt; Heap allocation </span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [LOG] Heap (dynamic memory) allocation."</span> &lt;&lt; <span class="org-string">"\n"</span>;
       <span class="org-comment-delimiter">// </span><span class="org-comment">Note: It throws std::bad_alloc exception. </span>
       <span class="org-type">double</span>* <span class="org-variable-name">array</span> = <span class="org-keyword">new</span> <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">[</span>ARRAY_SIZE<span class="org-rainbow-delimiters-depth-2">]</span>;       
       <span class="org-keyword">delete</span> <span class="org-rainbow-delimiters-depth-2">[]</span> array;
<span class="org-preprocessor">    #endif</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [LOG] Program ended gracefully OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Testing stack-allocation limit:</b>
</p>

<ul class="org-ul">
<li>Note: Tested on Linux-64 bits - Kernel 4.16.3</li>

<li>Result: Core dump due to stack overflow happens when the array size is
10,000,000, 10 million doubles or 7812 kb (kbytes) or 7.6 Mb
(Megabytes). This behavior depends on the operating system and
may be not be the same on other operating systems or new Linux's
kernel versions.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ stack-allocation-test.cpp -o <span class="org-keyword">out.bin</span> -DHEAP=false -DARRAY_SIZE=100 &amp;&amp; ./out.bin
 [LOG] Number of elements = 100
 [LOG] Array size<span class="org-keyword"> in</span> Kbytes = 0
 [LOG] Stack allocation.
 [LOG] Program ended gracefully OK.

$ clang++ stack-allocation-test.cpp -o <span class="org-keyword">out.bin</span> -DHEAP=false -DARRAY_SIZE=1000000 &amp;&amp; ./out.bin
 [LOG] Number of elements = 1000000
 [LOG] Array size<span class="org-keyword"> in</span> Kbytes = 7812
 [LOG] Stack allocation.
 [LOG] Program ended gracefully OK.

$ clang++ stack-allocation-test.cpp -o <span class="org-keyword">out.bin</span> -DHEAP=false -DARRAY_SIZE=10000000 &amp;&amp; ./out.bin
Segmentation fault (core dumped)

$ ./out.bin
Segmentation fault (core dumped)
</pre>
</div>

<p>
<b>Testing heap (dynamic memory) allocation limit:</b>
</p>

<ul class="org-ul">
<li>Note: Tested on Linux-64 bits - Kernel 4.16.3</li>

<li>Result: bad_alloc exception happens when the array size is 10
billions or 78125000 kb (= 76293 Mb or 74 GB. The limit of the heap
allocation is the size of the virtual memory or RAM memory.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">10 millions</span>
$ clang++ stack-allocation-test.cpp -o <span class="org-keyword">out.bin</span> -DHEAP=true -DARRAY_SIZE=10000000 &amp;&amp; ./out.bin
 [LOG] Number of elements = 10000000
 [LOG] Array size<span class="org-keyword"> in</span> Kbytes = 78125
 [LOG] Heap (dynamic memory) allocation.
 [LOG] Program ended gracefully OK.

<span class="org-comment-delimiter"># </span><span class="org-comment">100 millions </span>
$ clang++ stack-allocation-test.cpp -o <span class="org-keyword">out.bin</span> -DHEAP=true -DARRAY_SIZE=100000000 &amp;&amp; ./out.bin
 [LOG] Number of elements = 100000000
 [LOG] Array size<span class="org-keyword"> in</span> Kbytes = 781250
 [LOG] Heap (dynamic memory) allocation.
 [LOG] Program ended gracefully OK.

<span class="org-comment-delimiter"># </span><span class="org-comment">10 billions</span>
$ clang++ stack-allocation-test.cpp -o <span class="org-keyword">out.bin</span> -DHEAP=true -DARRAY_SIZE=10000000000 &amp;&amp; ./out.bin
 [LOG] Number of elements = 10000000000
 [LOG] Array size<span class="org-keyword"> in</span> Kbytes = 78125000
 [LOG] Heap (dynamic memory) allocation.
terminate called after throwing an instance of <span class="org-string">'std::bad_alloc'</span>
  what():  std::bad_alloc
<span class="org-function-name">Aborted</span> (core dumped)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd51a1a0" class="outline-4">
<h4 id="orgd51a1a0"><span class="section-number-4">1.18.5</span> New and delete overloading functions</h4>
<div class="outline-text-4" id="text-1-18-5">
</div>
<ol class="org-ol">
<li><a id="org3717c16"></a>Overloadings for new and delete operators<br />
<div class="outline-text-5" id="text-1-18-5-1">
<p>
<b>Global new and delete operators free functions</b> 
</p>

<ul class="org-ul">
<li>size_t =&gt; Size of object being allocated in bytes. This parameter
is implicitly passed by the compiler.</li>

<li>Returns =&gt; A void* pointer to the beginning of the allocated
memory block.</li>

<li>Note: The operator 'new' allocates objects in the heap memory
segment.</li>
</ul>

<p>
<b>Overloading for <span class="underline">new</span> operator</b>
</p>

<ul class="org-ul">
<li>Operator new for single object (throws std::bad_alloc on failure)</li>

<li>For all overloadings se:
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/memory/new/operator_new">https://en.cppreference.com/w/cpp/memory/new/operator_new</a></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Signature </span>
<span class="org-type">void</span>* <span class="org-keyword">operator</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">size_t</span> <span class="org-variable-name">size</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Example: allocate single object</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">--------------------------------------------------//</span>
<span class="org-type">BaseClass</span>* <span class="org-variable-name">ptr</span> = <span class="org-constant">nullptr</span>;
<span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    ptr = <span class="org-keyword">new</span> <span class="org-type">DerivedClassA</span><span class="org-rainbow-delimiters-depth-2">(</span>param0, param1, param2, ...<span class="org-rainbow-delimiters-depth-2">)</span>;
    ptr-&gt;CallVirtualMethod1<span class="org-rainbow-delimiters-depth-2">()</span>; 
    <span class="org-keyword">delete</span> ptr;    <span class="org-comment-delimiter">// </span><span class="org-comment">Always delete when the object is no longer needed </span>
    ptr = <span class="org-constant">nullptr</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Always set to nullptr </span>
<span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">bad_alloc</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Allocation failed."</span><span class="org-rainbow-delimiters-depth-3">)</span>
<span class="org-rainbow-delimiters-depth-2">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Operator new for single object, without exception
<ul class="org-ul">
<li>=&gt; Returns null pointer nullptr on failure. The second parameter
is type tag, used only for making the type signature different.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-comment-delimiter">// </span><span class="org-comment">Signature </span>
<span class="org-type">void</span>* <span class="org-keyword">operator</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">size_t</span> <span class="org-variable-name">size</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">nothrow_t</span>&amp; <span class="org-variable-name">tag</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Example: allocate single object</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">--------------------------------------------------//</span>
<span class="org-type">BaseClass</span>* <span class="org-variable-name">ptr</span> = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::nowthrow<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">DerivedClassA</span><span class="org-rainbow-delimiters-depth-1">(</span>param0, param1, param2, ...<span class="org-rainbow-delimiters-depth-1">)</span>;
ptr-&gt;CallVirtualMethod1<span class="org-rainbow-delimiters-depth-1">()</span>; 
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-negation-char">!</span>ptr<span class="org-rainbow-delimiters-depth-1">){</span> 
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [FAILURE] Abort operation. \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">delete</span> ptr;    
</pre>
</div>

<ul class="org-ul">
<li>Operator new for array allocation, throws <span class="underline">std::bad_alloc</span> exception.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Signature </span>
<span class="org-type">void</span>* <span class="org-keyword">operator</span> <span class="org-keyword">new</span><span class="org-rainbow-delimiters-depth-1">[]</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">size_t</span> <span class="org-variable-name">size</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Example: =&gt; Allocates 10 integers </span>
<span class="org-comment-delimiter">//</span><span class="org-comment">----------------------------------------------------</span>
<span class="org-type">int</span>* <span class="org-variable-name">pArray</span> = <span class="org-constant">nullptr</span>;
<span class="org-keyword">try</span><span class="org-rainbow-delimiters-depth-1">{</span> 
  pArray = <span class="org-keyword">new</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">[</span>10<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">bad_alloc</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Abort operation </span>
  <span class="org-keyword">return</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>
pArray<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = 100; pArray<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = 25; 
<span class="org-keyword">delete</span> <span class="org-rainbow-delimiters-depth-1">[]</span> pArray; <span class="org-comment-delimiter">// </span><span class="org-comment">Always call delete </span>
pArray = <span class="org-constant">nullptr</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Always set the pointer to nullptr after calling delete</span>
</pre>
</div>
</div>
</li>

<li><a id="org092dbff"></a>Example: Raw memory allocation with new operator<br />
<div class="outline-text-5" id="text-1-18-5-2">
<p>
The 'new' operator can be used for raw memory allocation without
calling constructor, in the same way as the C-function malloc. 
</p>

<p>
<b>Experiment 1</b>
</p>

<p>
Allocating an array in heap for 4 integers. (CERN's Root REPL)
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">void</span>* pi = ::<span class="org-keyword">operator</span> <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span>4 * <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x3184af0

&gt;&gt; assert<span class="org-rainbow-delimiters-depth-1">(</span>pi != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; <span class="org-type">int</span>* pint = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>pi<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x3184af0

&gt;&gt; pint<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = 20, pint<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = 100, pint<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = 3, pint<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = 25;

&gt;&gt; pint<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 20

&gt;&gt; pint<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 100

&gt;&gt; pint<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 3

&gt;&gt; pint<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 25
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::for_each<span class="org-rainbow-delimiters-depth-1">(</span>pint, pint + 4, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" x = %d \n"</span>, x<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 x = 20 
 x = 100 
 x = 3 
 x = 25 

<span class="org-comment-delimiter">// </span><span class="org-comment">Call operator delete </span>
&gt;&gt; <span class="org-keyword">delete</span> pint

<span class="org-comment-delimiter">// </span><span class="org-comment">Set to null when no longer used. </span>
&gt;&gt; pi = <span class="org-constant">nullptr</span>; 
&gt;&gt; pint = <span class="org-constant">nullptr</span>;
</pre>
</div>

<p>
<b>Experiment 2</b> 
</p>

<p>
Allocating raw memory for an instance of a class with new operator: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">Circle</span><span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">int</span> <span class="org-variable-name">x</span>; 
   <span class="org-type">int</span> <span class="org-variable-name">y</span>;  
   <span class="org-type">int</span> <span class="org-variable-name">radius</span>;

   <span class="org-function-name">Circle</span><span class="org-rainbow-delimiters-depth-2">()</span>: x<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span>, y<span class="org-rainbow-delimiters-depth-2">(</span>20<span class="org-rainbow-delimiters-depth-2">)</span>, radius<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span> 
   <span class="org-rainbow-delimiters-depth-2">{</span> 
      <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Cirlce constructed OK.\n"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>

   ~<span class="org-function-name">Circle</span><span class="org-rainbow-delimiters-depth-2">()</span>
   <span class="org-rainbow-delimiters-depth-2">{</span> 
      <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Cirlce destroyed OK.\n"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>

   <span class="org-type">void</span> <span class="org-function-name">set_radius</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span> 
   <span class="org-rainbow-delimiters-depth-2">{</span>
      radius = r;
   <span class="org-rainbow-delimiters-depth-2">}</span>

   <span class="org-type">void</span> <span class="org-function-name">plot</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> 
   <span class="org-rainbow-delimiters-depth-2">{</span> 
      <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Draw circle at Point(%d, %d) with radius = %d\n"</span>
         , <span class="org-keyword">this</span>-&gt;x, <span class="org-keyword">this</span>-&gt;y, <span class="org-keyword">this</span>-&gt;radius<span class="org-rainbow-delimiters-depth-3">)</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
REPL Session part 1:
</p>
<ul class="org-ul">
<li>The following call to operator 'new' only allocates memory for the
object without calling its constructor.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Constructor is not called!!! </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">=&gt;&gt; Throws std::bad_alloc on failure. </span>
&gt;&gt; <span class="org-type">void</span>* p = ::<span class="org-keyword">operator</span> <span class="org-keyword">new</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>Circle<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x1f30150

assert<span class="org-rainbow-delimiters-depth-1">(</span>p != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span>; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Constructor is not called!!!</span>
&gt;&gt; Circle* cp1 = <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Circle</span>*<span class="org-rainbow-delimiters-depth-1">)</span> p
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Circle</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x1f30150

<span class="org-comment-delimiter">// </span><span class="org-comment">=========&gt;&gt;&gt; Manually Initialize Object &lt;&lt;=============//</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">--------------------------------------------------------- </span>


<span class="org-comment-delimiter">// </span><span class="org-comment">Solution: Initialize object manually. </span>
&gt;&gt; cp1-&gt;x = 10;
&gt;&gt; cp1-&gt;y = 20;
&gt;&gt; cp1-&gt;radius = 25;

&gt;&gt; cp1-&gt;plot<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Draw circle at Point<span class="org-rainbow-delimiters-depth-1">(</span>10, 20<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">with</span> <span class="org-variable-name">radius</span> = 25
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">=========&gt;&gt;&gt; Destroy object and release memory &lt;&lt;=============//</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">----------------------------------------------------------------- </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Call destructor when the object is no longer needed</span>
&gt;&gt; <span class="org-keyword">delete</span> cp1
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Cirlce destroyed OK.

<span class="org-comment-delimiter">// </span><span class="org-comment">Set pointer to null </span>
&gt;&gt; cp1 = <span class="org-constant">nullptr</span>
</pre>
</div>

<p>
REPL Session Part 2:
</p>
<ul class="org-ul">
<li>The constructor could be called if the placement-new operator was
used.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">void</span>* pp = ::<span class="org-keyword">operator</span> <span class="org-keyword">new</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-2">(</span>Circle<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x32acf00

<span class="org-comment-delimiter">// </span><span class="org-comment">Abort computation if pp is null. </span>
assert<span class="org-rainbow-delimiters-depth-1">(</span> pp != <span class="org-constant">nullptr</span> <span class="org-rainbow-delimiters-depth-1">)</span>; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Now constructor is called. </span>

&gt;&gt; Circle* cpp = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span>pp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">Circle</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Cirlce constructed OK.
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Circle</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x32acf00

&gt;&gt; cpp-&gt;x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10

&gt;&gt; cpp-&gt;y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 20

&gt;&gt; cpp-&gt;plot<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Draw circle at Point<span class="org-rainbow-delimiters-depth-1">(</span>10, 20<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">with</span> <span class="org-variable-name">radius</span> = 2

&gt;&gt; <span class="org-keyword">delete</span> cpp
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Cirlce destroyed OK.
</pre>
</div>
</div>
</li>
<li><a id="org38a182b"></a>Example: User-defined new and delete operators<br />
<div class="outline-text-5" id="text-1-18-5-3">
<p>
It is possible to override the global <span class="underline">new</span> and <span class="underline">delete</span> operators free
functions. 
</p>

<ul class="org-ul">
<li>Note: replacing the default <span class="underline">new</span> and <span class="underline">delete</span> operators is not recommended.</li>

<li>Instead of replacing the default <span class="underline">new</span> and <span class="underline">delete</span> operators, a
better alternative is defining class-specific operators as static
member functions.</li>
</ul>

<p>
<b>File: new-delete-experiment1.cpp</b>
</p>

<ul class="org-ul">
<li>File: <a href="src/new-delete-experiment1.cpp">file:src/new-delete-experiment1.cpp</a></li>
</ul>

<p>
Class <span class="underline">SomeClass</span>: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">SomeClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-type">int</span> <span class="org-variable-name">x</span>;
    <span class="org-type">int</span> <span class="org-variable-name">y</span>;
    <span class="org-type">char</span> <span class="org-variable-name">buffer</span><span class="org-rainbow-delimiters-depth-2">[</span>200<span class="org-rainbow-delimiters-depth-2">]</span>;

    <span class="org-function-name">SomeClass</span><span class="org-rainbow-delimiters-depth-2">()</span>: x<span class="org-rainbow-delimiters-depth-2">(</span>125<span class="org-rainbow-delimiters-depth-2">)</span>, y<span class="org-rainbow-delimiters-depth-2">(</span>2561<span class="org-rainbow-delimiters-depth-2">)</span>, buffer<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] SomeClass object created OK"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" =&gt;&gt; SomeClass { x = %d, y = %d, buffer = %s } \n"</span>, x, y, buffer<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">SomeClass</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] SomeClass object destroyed OK"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Class <span class="underline">SomeClassB</span>:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">SomeClassB</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">char</span> <span class="org-variable-name">m_name</span><span class="org-rainbow-delimiters-depth-2">[</span>200<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"Unnamed"</span>;
    <span class="org-type">int</span>  <span class="org-variable-name">m_id</span> = -1;

    <span class="org-function-name">SomeClassB</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] &lt;CTOR1&gt; Object of SomeClassB created =&gt; addr = %p "</span>
                    <span class="org-string">" id = %d - name = '%s'"</span>
                    , <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span>, m_id, m_name<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">SomeClassB</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] &lt;DTOR&gt; Object of SomeClassC deleted =&gt; addr = %p \n"</span>
                    , <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Class <span class="underline">SomeClassC</span>:
</p>

<ul class="org-ul">
<li>This class has class-specific <span class="underline">new</span> and <span class="underline">delete</span> operators defined as
static member functions. In this case, The keyword <span class="underline">static</span> case can
be omitted, but it was used for making the code more explicit.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">SomeClassC</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-type">char</span> <span class="org-variable-name">m_name</span><span class="org-rainbow-delimiters-depth-2">[</span>200<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"Unnamed"</span>;
    <span class="org-type">int</span>  <span class="org-variable-name">m_id</span> = -1;

    <span class="org-function-name">SomeClassC</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] &lt;CTOR1&gt; Object of SomeClassC created =&gt; addr = %p "</span>
                    <span class="org-string">" id = %d - name = '%s'"</span>
                    , <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span>, m_id, m_name<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-function-name">SomeClassC</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span>, <span class="org-type">int</span> <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::strcpy<span class="org-rainbow-delimiters-depth-3">(</span>m_name, name<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_id = id;
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] &lt;CTOR2&gt; Object of SomeClassC created =&gt; addr = %p "</span>
                    <span class="org-string">" id = %d - name = '%s' \n"</span>
                    , <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span>, m_id, m_name<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">SomeClassC</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] &lt;DTOR&gt; Object of SomeClassC deleted =&gt; addr = %p \n"</span>
                    , <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Member fuction overloading of new operator</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">-------------------------------------------------------</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Note: the keyword static is redundant, this operator is a static member function</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">even without the keyword 'static'. It was added to make the declaration more explicit.</span>
    <span class="org-keyword">static</span> <span class="org-type">void</span>* <span class="org-keyword">operator</span> <span class="org-keyword">new</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">sz</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-type">void</span>* <span class="org-variable-name">ptr</span> = <span class="org-constant">std</span>::malloc<span class="org-rainbow-delimiters-depth-3">(</span>sz<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-negation-char">!</span>ptr<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [ERROR] Not enough memory"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] SomeClassB =&gt; Custom new operator called. Allocated %lu Bytes =&gt; "</span>
                    <span class="org-string">" ptr = %p \n"</span>
                    , sz, ptr<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">return</span> ptr;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Member fuction overloading of delete operator</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Static keyword redundant</span>
    <span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-keyword">operator</span> <span class="org-keyword">delete</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">void</span>* <span class="org-variable-name">addr</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] Custom delete operator called for SomeClassB =&gt; p = %p \n"</span>
                    , addr<span class="org-rainbow-delimiters-depth-3">)</span>;
        free<span class="org-rainbow-delimiters-depth-3">(</span>addr<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Global operator <span class="underline">new</span> free-function:
</p>

<ul class="org-ul">
<li>Note: This overloading throws exceptin std::bad_alloc when there
is no enough memory.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Global free-function overloading of new operator Note: Cannot be</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">declared inside a namespace Note: DO NOT DO IT!</span>
<span class="org-type">void</span>* <span class="org-keyword">operator</span> <span class="org-keyword">new</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">size</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] NEW - Called operator new, Allocated %lu Bytes\n"</span>, size<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">void</span>* <span class="org-variable-name">ptr</span> = <span class="org-constant">std</span>::malloc<span class="org-rainbow-delimiters-depth-2">(</span>size<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [ERROR] Not enough memory"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::bad_alloc<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> ptr;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Global operator <span class="underline">new</span> free-function (std::nothrow):
</p>

<ul class="org-ul">
<li>Note: This overloading does not throw exception. It just returns a
null pointer when there is no enough memory.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Global free-function overloading of new operator (std::notrhow)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: Cannot be declared inside a namespace</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: Does not throw exception, just returns a null pointer when there is no</span>
<span class="org-comment-delimiter">//       </span><span class="org-comment">memory available</span>
<span class="org-type">void</span>* <span class="org-keyword">operator</span> <span class="org-keyword">new</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">size</span>, <span class="org-constant">std</span>::<span class="org-type">nothrow_t</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">tag</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] NEW (std::nothrow) - Called operator new, Allocated %lu Bytes\n"</span>, size<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">void</span>* <span class="org-variable-name">ptr</span> = <span class="org-constant">std</span>::malloc<span class="org-rainbow-delimiters-depth-2">(</span>size<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [ERROR] Not enough memory"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> ptr;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Global operator <span class="underline">delete</span> free function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Global free-function overloading of delete operator</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: Cannot be delcared inside a namespace</span>
<span class="org-type">void</span> <span class="org-keyword">operator</span> <span class="org-keyword">delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span>* <span class="org-variable-name">ptr</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">noexcept</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] DELETE - Called operator delete"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    free<span class="org-rainbow-delimiters-depth-2">(</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Main Function / Experiment 1</b>
</p>

<ul class="org-ul">
<li>Allocate primitive type with custom <span class="underline">new</span> operator.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ==&gt;&gt; Experiment 1 == Global overloading -test with primitive type \n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span>* <span class="org-variable-name">ptr</span> = <span class="org-keyword">new</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">(</span>25<span class="org-rainbow-delimiters-depth-2">)</span>;
    *ptr = 10 + *ptr;
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" Value of ptr[%p] = %d \n"</span>, <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-3">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-3">)</span>, *ptr<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">delete</span>  ptr;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">==&gt;&gt; Experiment 1 == Global overloading -test with primitive type 

[TRACE] NEW - Called operator new, Allocated 4 Bytes
Value of ptr[0x2478e80] = 35 
[TRACE] DELETE - Called operator delete
</pre>
</div>

<p>
<b>Main Function / Experiment 2</b> 
</p>

<ul class="org-ul">
<li>Allocate and instantiate an object of class SomeClass in the
process heap using the user-defined global <span class="underline">new</span> (std::bad_alloc)
operator. Note: The default constructor is called.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ==&gt;&gt; Experiment 2 == Global Overloading - test with class ====\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">SomeClass</span>* <span class="org-variable-name">pcls</span> = <span class="org-keyword">new</span> <span class="org-type">SomeClass</span>;
    pcls-&gt;x = 25;
    pcls-&gt;y = 1005;
    pcls-&gt;show<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">delete</span> pcls;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">==&gt;&gt; Experiment 2 == Global Overloading - test with class ====

[TRACE] NEW - Called operator new, Allocated 208 Bytes
[TRACE] SomeClass object created OK
=&gt;&gt; SomeClass { x = 25, y = 1005, buffer = Hello world } 
[TRACE] SomeClass object destroyed OK
[TRACE] DELETE - Called operator delete
</pre>
</div>


<p>
<b>Main Function / Experiment 3</b>
</p>

<ul class="org-ul">
<li>Allocate and instantiate an object of class SomeClass in the
process heap using the user-defined global <span class="underline">new</span> (std::nothrow)
operator. Note: The default constructor is called.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ==&gt;&gt; Experiment 3 == (std::notrhow) Global Overloading - test with class ====\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">SomeClass</span>* <span class="org-variable-name">pcls</span> = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::nothrow<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-type">SomeClass</span>;
    pcls-&gt;x = 25;
    pcls-&gt;y = 1005;
    pcls-&gt;show<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">delete</span> pcls;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">==&gt;&gt; Experiment 3 == (std::notrhow) Global Overloading - test with class ====

 [TRACE] NEW (std::nothrow) - Called operator new, Allocated 208 Bytes
 [TRACE] SomeClass object created OK
 =&gt;&gt; SomeClass { x = 25, y = 1005, buffer = Hello world } 
 [TRACE] SomeClass object destroyed OK
 [TRACE] DELETE - Called operator delete
</pre>
</div>

<p>
<b>Main Function / Experiment 4</b>
</p>

<ul class="org-ul">
<li>The global operator <span class="underline">new</span> is used only for raw allocation, in the
same way as <span class="underline">malloc</span>. The object is not instantiated and no
constructor is called.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ==&gt;&gt; Experiment 4 - Explicit raw allocation  == Global Overloading - test with class ====\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Raw memory allocation =&gt; Without calling the constructor</span>
    <span class="org-type">void</span>* <span class="org-variable-name">raw_pcls</span> = ::<span class="org-keyword">operator</span> <span class="org-keyword">new</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-3">(</span>SomeClass<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Note: The constructor is not called</span>
    <span class="org-type">SomeClass</span>* <span class="org-variable-name">pcls</span> = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">SomeClass</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>raw_pcls<span class="org-rainbow-delimiters-depth-2">)</span>;
    pcls-&gt;x = 251;
    pcls-&gt;y = -1005;
    <span class="org-constant">std</span>::strcpy<span class="org-rainbow-delimiters-depth-2">(</span>pcls-&gt;buffer, <span class="org-string">"raw-memory-allocated"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    pcls-&gt;show<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">delete</span> pcls;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">==&gt;&gt; Experiment 4 - Explicit raw allocation  == Global Overloading - test with class ====

[TRACE] NEW - Called operator new, Allocated 208 Bytes
=&gt;&gt; SomeClass { x = 251, y = -1005, buffer = raw-memory-allocated } 
[TRACE] SomeClass object destroyed OK
[TRACE] DELETE - Called operator delete
</pre>
</div>

<p>
<b>Main Function / Experiment 5</b>
</p>

<ul class="org-ul">
<li>Calls new and delete operators specific for SomeClassC defined as
static meber functions.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ==&gt;&gt; Experiment 5 === Member Function Overloading ==========\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">SomeClassC</span>* <span class="org-variable-name">pclassB</span> = <span class="org-keyword">new</span> <span class="org-type">SomeClassC</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Hello"</span>, 2005<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt;&gt;  Print object =&gt; pclassB-&gt;m_name = %s; pclassB-&gt;m_id = %d \n"</span>
                , pclassB-&gt;m_name, pclassB-&gt;m_id<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">delete</span> pclassB;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">==&gt;&gt; Experiment 5 === Member Function Overloading ==========

[TRACE] SomeClassB =&gt; Custom new operator called. Allocated 204 Bytes =&gt;  ptr = 0x2478ea0 
[TRACE] &lt;CTOR2&gt; Object of SomeClassC created =&gt; addr = 0x2478ea0  id = 2005 - name = <span class="org-string">'Hello'</span> 
=&gt;&gt;  Print object =&gt; pclassB-&gt;m_name = Hello; pclassB-&gt;m_id = 2005 
[TRACE] &lt;DTOR&gt; Object of SomeClassC deleted =&gt; addr = 0x2478ea0 
[TRACE] Custom delete operator called for SomeClassB =&gt; p = 0x2478ea0 
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org14becc7" class="outline-4">
<h4 id="org14becc7"><span class="section-number-4">1.18.6</span> Placement new and delete operators</h4>
<div class="outline-text-4" id="text-1-18-6">
</div>
<ol class="org-ol">
<li><a id="org02125c0"></a>Overview<br />
<div class="outline-text-5" id="text-1-18-6-1">
<p>
The <span class="underline">placement new</span> operator has an additional parameter void* which
allows instantiating a type or class in a specific memory
location. 
</p>

<p>
Notes: 
</p>

<ul class="org-ul">
<li>This operator does not allocate any storage. It instantiantes
object at a pre-allocated storage or at specific memory
address.</li>

<li>The global new and delete placement operators cannot be replaced
by user-defined ones.</li>
</ul>

<p>
Some <b>use-cases</b> for this operator are: 
</p>

<ul class="org-ul">
<li>Instantiate object in shared memory between two processes.</li>

<li>Instantiate object in memory mapped file.</li>

<li>Instantiate object in some pre-allocated buffer, it allows
instantiating polymorphic objects at runtime in a 
static-allocated buffer (global variable) or in a stack-allocated
buffer. This technique is useful in <b>embedded systems</b> for enabling
polymorphism without heap allocation.
<ul class="org-ul">
<li>Note: A buffer in this cases is a byte array: <span class="underline">char buffer [BUFFER_SIZE]</span></li>
</ul></li>

<li>Instantiate object in some specific hardware address - Memory
Mapped IO, MMIO (<b>embedded systems</b>)</li>

<li>Custom allocators</li>
</ul>

<p>
<b>Placemente new and delete operators for single object</b> 
</p>

<ul class="org-ul">
<li>The parameter <span class="underline">size</span> is the size of the data type to be
allocated.</li>

<li>The pointer <span class="underline">place</span> holds the address where the object will be
instantiated.</li>

<li>The return value is the pointer to the allocated object.</li>

<li>Note: This gloabl new placement operator cannot be replaced by
an user-defined one. However, it is possible to define
class-specific one as static member function.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Placement new operator:</span>
<span class="org-type">void</span>* <span class="org-keyword">operator</span> <span class="org-keyword">new</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">size_t</span> <span class="org-variable-name">size</span>, <span class="org-type">void</span>* <span class="org-variable-name">location</span><span class="org-rainbow-delimiters-depth-1">)</span>; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Placement delete operator: </span>
<span class="org-type">void</span> <span class="org-keyword">delete</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span>* <span class="org-variable-name">p_object</span>, <span class="org-type">void</span>* <span class="org-variable-name">location</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Usage example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Allocate object in pre-allocated buffer </span>
<span class="org-keyword">constexpr</span> <span class="org-type">size_t</span> <span class="org-variable-name">BUFFER_SIZE</span> = 2048; <span class="org-comment-delimiter">// </span><span class="org-comment">2048 bytes or 2kb</span>
<span class="org-type">char</span> <span class="org-variable-name">buffer</span><span class="org-rainbow-delimiters-depth-1">[</span>BUFFER_SIZE<span class="org-rainbow-delimiters-depth-1">]</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Construct object at buffer </span>
<span class="org-type">BaseClass</span>* <span class="org-variable-name">obj</span> = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span>buffer<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">DerivedClass</span><span class="org-rainbow-delimiters-depth-1">(</span>arg0, arg1, arg2, ... argN-1<span class="org-rainbow-delimiters-depth-1">)</span>

obj-&gt;callVirtualMethod<span class="org-rainbow-delimiters-depth-1">()</span>; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Invoke destructor when object is no longer needed</span>
obj-&gt;~BaseClass<span class="org-rainbow-delimiters-depth-1">()</span>;  

<span class="org-comment-delimiter">// </span><span class="org-comment">Call placement delete operator </span>
::<span class="org-keyword">operator</span> <span class="org-keyword">delete</span><span class="org-rainbow-delimiters-depth-1">(</span>obj, buffer<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Placemente new and delete operators for arrays</b> 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Placement new operator for arrays</span>
<span class="org-type">void</span>* <span class="org-keyword">operator</span> <span class="org-keyword">new</span><span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-constant">std</span>::<span class="org-type">size_t</span> <span class="org-variable-name">size</span>, <span class="org-type">void</span>* <span class="org-variable-name">location</span><span class="org-rainbow-delimiters-depth-1">)</span>; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Placement new operator for arrays </span>
<span class="org-type">void</span>* <span class="org-keyword">operator</span> <span class="org-keyword">delete</span><span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">void</span>* <span class="org-variable-name">p_object</span>, <span class="org-type">void</span>* <span class="org-variable-name">location</span><span class="org-rainbow-delimiters-depth-1">)</span>; 
</pre>
</div>
</div>
</li>

<li><a id="org91b2abe"></a>Example - placement-new experiment in REPL<br />
<div class="outline-text-5" id="text-1-18-6-2">
<p>
Note: This example was run in the CERN's Root REPL.
</p>

<p>
Class Dummmy: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Dummy</span><span class="org-rainbow-delimiters-depth-1">{</span>   
<span class="org-function-name">public</span>:
    <span class="org-type">int</span> <span class="org-variable-name">x</span> = 200;
    <span class="org-type">int</span> <span class="org-variable-name">y</span> = 25;
    <span class="org-type">char</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">[</span>200<span class="org-rainbow-delimiters-depth-2">]</span> = <span class="org-string">"Unnamed"</span>;

    <span class="org-function-name">Dummy</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Default ctor called. =&gt; this = %p \n"</span>
                  , <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-function-name">Dummy</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::strcpy<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">this</span>-&gt;name, name<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">this</span>-&gt;x = x;
        <span class="org-keyword">this</span>-&gt;y = y;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">Dummy</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Dtor called. =&gt; this = %p \n"</span>
                    , <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">show</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Dummy { name = '%s' ; x = %d; y = %d } \n"</span>
                    , <span class="org-keyword">this</span>-&gt;name, <span class="org-keyword">this</span>-&gt;x, <span class="org-keyword">this</span>-&gt;y<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>REPL Session:</b> 
</p>

<p>
Get size of type 'Dummy' in bytes 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">sizeof</span><span class="org-rainbow-delimiters-depth-1">(</span>Dummy<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 208
</pre>
</div>

<p>
Pre-allocated static (global) or stack buffer large enough for storing
an instance of class dummy. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Create a buffer with 416 bytes </span>
<span class="org-function-name">std</span>::uint8_t buffer<span class="org-rainbow-delimiters-depth-1">[</span>416<span class="org-rainbow-delimiters-depth-1">]</span>;
</pre>
</div>

<p>
Buffer before instantiation: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; buffer
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::uint8_t <span class="org-rainbow-delimiters-depth-2">[</span>416<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, .... <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span> <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> buffer<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> buffer<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> buffer<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; 
</pre>
</div>

<p>
Use the placment-new operator for creating an object of class Dummy in
the buffer.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; Dummy* p = <span class="org-keyword">new</span> <span class="org-rainbow-delimiters-depth-1">(</span>buffer<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">Dummy</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Default ctor called. =&gt; <span class="org-keyword">this</span> = 0x7fda9fe7a010 
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Dummy</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7fda9fe7a010

&gt;&gt; p-&gt;show<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Dummy <span class="org-rainbow-delimiters-depth-1">{</span> name = <span class="org-warning">'</span>Unnamed<span class="org-warning">'</span> ; x = 200; y = 25 <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; 

&gt;&gt; p-&gt;x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 200

&gt;&gt; p-&gt;y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 25

&gt;&gt; p-&gt;name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span> <span class="org-rainbow-delimiters-depth-2">[</span>200<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Unnamed\0\0\0\0\0\0\0\0 ... ... \0\0\0"</span>
</pre>
</div>

<p>
Buffer after instantiation: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; buffer
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::uint8_t <span class="org-rainbow-delimiters-depth-2">[</span>416<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 
  <span class="org-warning">'</span>0xc8<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x19<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-string">'U'</span>, <span class="org-string">'n'</span>, <span class="org-string">'n'</span>, <span class="org-string">'a'</span>, <span class="org-string">'m'</span>, <span class="org-string">'e'</span>, <span class="org-string">'d'</span>,
  <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span> .... ... <span class="org-warning">'</span>0x00<span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> buffer<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 200

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> buffer<span class="org-rainbow-delimiters-depth-1">[</span>4<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 25
</pre>
</div>

<p>
Manipulating  object variable:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">int</span> xx1 = 0x4ABC7852
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 1253865554

&gt;&gt; <span class="org-type">int</span> yy1 = 0x3DFCA3E2
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 1039967202

&gt;&gt; p-&gt;x = xx1;
&gt;&gt; p-&gt;y = yy1;
&gt;&gt; <span class="org-constant">std</span>::strcpy<span class="org-rainbow-delimiters-depth-1">(</span>p-&gt;name, <span class="org-string">"I_am_dummy_object_in_C++1z"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; p-&gt;show<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Dummy <span class="org-rainbow-delimiters-depth-1">{</span> name = <span class="org-warning">'</span>I_am_dummy_object_in_C++1z<span class="org-warning">'</span> ; x = 1253865554; y = 1039967202 <span class="org-rainbow-delimiters-depth-1">}</span> 
</pre>
</div>

<p>
Check buffer: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; buffer
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::uint8_t <span class="org-rainbow-delimiters-depth-2">[</span>416<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">'R'</span>, <span class="org-string">'x'</span>, <span class="org-warning">'</span>0xbc<span class="org-warning">'</span>, <span class="org-string">'J'</span>, <span class="org-warning">'</span>0xe2<span class="org-warning">'</span>, <span class="org-warning">'</span>0xa3<span class="org-warning">'</span>, <span class="org-warning">'</span>0xfc<span class="org-warning">'</span>
, <span class="org-string">'='</span>, <span class="org-string">'I'</span>, <span class="org-string">'_'</span>, <span class="org-string">'a'</span>, <span class="org-string">'m'</span>, <span class="org-string">'_'</span>, <span class="org-string">'d'</span>, <span class="org-string">'u'</span>, <span class="org-string">'m'</span>, <span class="org-string">'m'</span>, <span class="org-string">'y'</span>, <span class="org-string">'_'</span>, <span class="org-string">'o'</span>, <span class="org-string">'b'</span>, <span class="org-string">'j'</span>, <span class="org-string">'e'</span>
, <span class="org-string">'c'</span>, <span class="org-string">'t'</span>, <span class="org-string">'_'</span>, <span class="org-string">'i'</span>, <span class="org-string">'n'</span>, <span class="org-string">'_'</span>, <span class="org-string">'C'</span>, <span class="org-string">'+'</span>, <span class="org-string">'+'</span>, <span class="org-string">'1'</span>, <span class="org-string">'z'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span>, <span class="org-warning">'</span>0x00<span class="org-warning">'</span> .. ... <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Create function display_buffer for showing buffer content in decimal,
hexadecimal and char format: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">display_bytes</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">uint8_t</span>* <span class="org-variable-name">buffer</span>, <span class="org-type">size_t</span> <span class="org-variable-name">min</span>, <span class="org-type">size_t</span> <span class="org-variable-name">max</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>min &gt; max<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Error: supposed min &lt;= max"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = min; i &lt; max; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-type">char</span> <span class="org-variable-name">ch</span> = <span class="org-constant">std</span>::isprint<span class="org-rainbow-delimiters-depth-3">(</span>buffer<span class="org-rainbow-delimiters-depth-4">[</span>i<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span> ? buffer<span class="org-rainbow-delimiters-depth-3">[</span>i<span class="org-rainbow-delimiters-depth-3">]</span> : <span class="org-string">' '</span>;
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" =&gt; byte[%lu] = 0x%X %d %c\n"</span>, i
                    , <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>buffer<span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>
                    , <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>buffer<span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>
                    , ch<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Analyze buffer bytes 0 to 3: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" =&gt; xx1 = %X \n"</span>, xx1<span class="org-rainbow-delimiters-depth-1">)</span>;
 =&gt; xx1 = 4ABC7852 

<span class="org-comment-delimiter">// </span><span class="org-comment">Value of p-&gt;x == 0x4ABC7852 </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">0x 4A BC 78 52 </span>
&gt;&gt; display_bytes<span class="org-rainbow-delimiters-depth-1">(</span>buffer, 0, 4<span class="org-rainbow-delimiters-depth-1">)</span>
 =&gt; byte<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> = 0x52 82 R
 =&gt; byte<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> = 0x78 120 x
 =&gt; byte<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> = 0xBC 188  
 =&gt; byte<span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> = 0x4A 74 J

&gt;&gt;  <span class="org-type">int</span> x1_value = <span class="org-rainbow-delimiters-depth-1">(</span>buffer<span class="org-rainbow-delimiters-depth-2">[</span>3<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; 24<span class="org-rainbow-delimiters-depth-1">)</span> + <span class="org-rainbow-delimiters-depth-1">(</span>buffer<span class="org-rainbow-delimiters-depth-2">[</span>2<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; 16<span class="org-rainbow-delimiters-depth-1">)</span> + <span class="org-rainbow-delimiters-depth-1">(</span>buffer<span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; 8<span class="org-rainbow-delimiters-depth-1">)</span> + buffer<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 1253865554

&gt;&gt; p-&gt;x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 1253865554

x1_value == p-&gt;x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>

&gt;&gt; <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" p-&gt;x = %X ; x1_value = %X \n"</span>, p-&gt;x, x1_value<span class="org-rainbow-delimiters-depth-1">)</span>;
 p-&gt;x = 4ABC7852 ; x1_value = 4ABC7852 
</pre>
</div>

<p>
Analyze buffer bytes 4 to 7: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" =&gt; yy1 = %X \n"</span>, yy1<span class="org-rainbow-delimiters-depth-1">)</span>;
 =&gt; yy1 = 3DFCA3E2 

<span class="org-comment-delimiter">// </span><span class="org-comment">p-&gt;y = 0x3DFCA3E2 </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Bytes: 0x 3D FC A3 E2 </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">In the buffer, the bytes are stored in "Little Endian Format" </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">as E2 A3 FC 3D</span>
&gt;&gt; display_bytes<span class="org-rainbow-delimiters-depth-1">(</span>buffer, 4, 8<span class="org-rainbow-delimiters-depth-1">)</span>
 =&gt; byte<span class="org-rainbow-delimiters-depth-1">[</span>4<span class="org-rainbow-delimiters-depth-1">]</span> = 0xE2 226  
 =&gt; byte<span class="org-rainbow-delimiters-depth-1">[</span>5<span class="org-rainbow-delimiters-depth-1">]</span> = 0xA3 163  
 =&gt; byte<span class="org-rainbow-delimiters-depth-1">[</span>6<span class="org-rainbow-delimiters-depth-1">]</span> = 0xFC 252  
 =&gt; byte<span class="org-rainbow-delimiters-depth-1">[</span>7<span class="org-rainbow-delimiters-depth-1">]</span> = 0x3D 61 =

&gt;&gt; <span class="org-type">int</span> y1_value = <span class="org-rainbow-delimiters-depth-1">(</span>buffer<span class="org-rainbow-delimiters-depth-2">[</span>7<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; 24<span class="org-rainbow-delimiters-depth-1">)</span> + <span class="org-rainbow-delimiters-depth-1">(</span>buffer<span class="org-rainbow-delimiters-depth-2">[</span>6<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; 16<span class="org-rainbow-delimiters-depth-1">)</span> + <span class="org-rainbow-delimiters-depth-1">(</span>buffer<span class="org-rainbow-delimiters-depth-2">[</span>5<span class="org-rainbow-delimiters-depth-2">]</span> &lt;&lt; 8<span class="org-rainbow-delimiters-depth-1">)</span> +  buffer<span class="org-rainbow-delimiters-depth-1">[</span>4<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 1039967202

&gt;&gt; printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" p-&gt;y = %X ; y1_value = %X \n"</span>, p-&gt;y, y1_value<span class="org-rainbow-delimiters-depth-1">)</span>;
 p-&gt;y = 3DFCA3E2 ; y1_value = 3DFCA3E2 
</pre>
</div>

<p>
Copy character portion to a std::string object.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::string str<span class="org-rainbow-delimiters-depth-1">(</span>buffer + 8, buffer + 40<span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; str
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"I_am_dummy_object_in_C++1z\0\0\0\0\0\0"</span>
&gt;&gt; 
</pre>
</div>

<p>
Release memory: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Call destructor </span>
&gt;&gt; p-&gt;~Dummy<span class="org-rainbow-delimiters-depth-1">()</span> 
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Dtor called. =&gt; <span class="org-keyword">this</span> = 0x7ff08c52c010 

<span class="org-comment-delimiter">// </span><span class="org-comment">Call placement-delete operator </span>
&gt;&gt; ::<span class="org-keyword">operator</span> <span class="org-keyword">delete</span><span class="org-rainbow-delimiters-depth-1">(</span>p, buffer<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org633fffa" class="outline-4">
<h4 id="org633fffa"><span class="section-number-4">1.18.7</span> References and further reading</h4>
<div class="outline-text-4" id="text-1-18-7">
<p>
General: 
</p>

<ul class="org-ul">
<li><a href="https://www.gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html">7. Memory : Stack vs Heap</a></li>

<li><a href="http://www.yolinux.com/TUTORIALS/Cpp-DynamicMemory.html">C / C++ and Dynamic memory allocation</a></li>

<li><a href="http://www.modernescpp.com/index.php/strategies-for-the-allocation-of-memory">Strategies for the Allocation of Memory - ModernesCpp.com</a></li>

<li><a href="https://www.design-reuse.com/articles/25090/dynamic-memory-allocation-fragmentation-c.html">Dynamic Memory Allocation and Fragmentation in C and C++</a></li>

<li><a href="https://www.learncpp.com/cpp-tutorial/79-the-stack-and-the-heap/">7.9 — The stack and the heap | Learn C++</a></li>

<li><b>CS 414: Operating Systems Fall 2005 - Operating Systems</b>
<ul class="org-ul">
<li><a href="http://www.cs.virginia.edu/~son/cs414.f05/lec11.slides.pdf">http://www.cs.virginia.edu/~son/cs414.f05/lec11.slides.pdf</a></li>
</ul></li>

<li><b>Thinking in C++, 2nd ed. Volume 1</b>
<ul class="org-ul">
<li><a href="http://www.cs.ust.hk/~dekai/library/ECKEL_Bruce/TICPP-2nd-ed-Vol-one/TICPP-2nd-ed-Vol-one-html/Chapter13.html">http://www.cs.ust.hk/~dekai/library/ECKEL_Bruce/TICPP-2nd-ed-Vol-one/TICPP-2nd-ed-Vol-one-html/Chapter13.html</a></li>
</ul></li>

<li><b>Dynamic Memory Allocation and Deallocation</b>
<ul class="org-ul">
<li><a href="http://www.umsl.edu/~lawtonb/224/dynamic0.html">http://www.umsl.edu/~lawtonb/224/dynamic0.html</a></li>
</ul></li>

<li><b>Dynamic Memory in Real Time Systems - a solution?</b>
<ul class="org-ul">
<li><a href="https://blogs.mentor.com/colinwalls/blog/2014/05/06/dynamic-memory-in-real-time-systems-a-solution/">https://blogs.mentor.com/colinwalls/blog/2014/05/06/dynamic-memory-in-real-time-systems-a-solution/</a></li>
</ul></li>

<li><b>Dynamic Memory Allocation in Critical Embedded Systems</b>
<ul class="org-ul">
<li><a href="https://critical.eschertech.com/2010/07/30/dynamic-memory-allocation-in-critical-embedded-systems/">https://critical.eschertech.com/2010/07/30/dynamic-memory-allocation-in-critical-embedded-systems/</a></li>
</ul></li>

<li><b>Favorite Tools: C++11 std::array</b>
<ul class="org-ul">
<li><a href="https://www.embeddedrelated.com/showarticle/1031.php">https://www.embeddedrelated.com/showarticle/1031.php</a></li>
</ul></li>
</ul>

<p>
Placement New and Delete Opeators:
</p>

<ul class="org-ul">
<li>Wikipedia - <b>Placement syntax</b> 
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Placement_syntax">https://en.wikipedia.org/wiki/Placement_syntax</a></li>
</ul></li>

<li><b>Thinking in C++, 2nd ed. Volume 1</b> - Dynamic Object Creation  - Bruce Eckel
<ul class="org-ul">
<li><a href="http://www.cs.ust.hk/~dekai/library/ECKEL_Bruce/TICPP-2nd-ed-Vol-one/TICPP-2nd-ed-Vol-one-html/Chapter13.html">http://www.cs.ust.hk/~dekai/library/ECKEL_Bruce/TICPP-2nd-ed-Vol-one/TICPP-2nd-ed-Vol-one-html/Chapter13.html</a></li>
</ul></li>

<li><b>Calling Constructors with Placement New</b>
<ul class="org-ul">
<li><a href="https://www.drdobbs.com/cpp/calling-constructors-with-placement-new/232901023?pgno=2">https://www.drdobbs.com/cpp/calling-constructors-with-placement-new/232901023?pgno=2</a></li>
</ul></li>

<li><a href="https://stackoverflow.com/questions/222557/what-uses-are-there-for-placement-new">c++ - What uses are there for "placement new"? - Stack Overflow</a></li>
</ul>

<p>
C++ Idioms related to Heap-Allocation: 
</p>

<ul class="org-ul">
<li><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Requiring_or_Prohibiting_Heap-based_Objects">More C++ Idioms/Requiring or Prohibiting Heap-based Objects - Wikibooks, open books for an open world</a></li>
</ul>

<p>
Debugging: 
</p>

<ul class="org-ul">
<li><a href="https://www.eventhelix.com/RealtimeMantra/Basics/debugging_software_crashes_2.htm#.W-RbqB6YW00">Debugging Software Crashes in C and C++ - II</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org40c9378" class="outline-3">
<h3 id="org40c9378"><a id="ID-69b48bc0-1b18-4997-b954-3da566a3508a"></a><span class="section-number-3">1.19</span> OOP Object Lifecycle</h3>
<div class="outline-text-3" id="text-1-19">
<p>
This code shows how object lifecycle works in C++ by instrumenting
constructors and destructors member functions.
</p>

<ul class="org-ul">
<li>File: <a href="src/object-lifecycle.cpp">file:src/object-lifecycle.cpp</a></li>
<li>Online Compiler: <a href="https://rextester.com/QUQ52793">https://rextester.com/QUQ52793</a></li>
</ul>

<p>
C++ can allocated objects in three different areas or memories: 
</p>

<ul class="org-ul">
<li><b>stack</b> - Objects allocated by default on the stack when instantiated
inside functions, member functions or local scope. Objects
instantiated on the stack are automatically deleted or released
when they go out of scope and then the destructor is called.

<ul class="org-ul">
<li>Summary and further notes:
<ul class="org-ul">
<li>Objects allocated on the stack are automatically released when
they go out of scope.</li>
<li>There is a size limit for objects allocated on the stack which
depends on the operating system, therefore very large objects
allocated on the stack can cause segmentation fault. If it is
the case, it is better to allocate the object on the heap or
dynamic memory.</li>
</ul></li>
</ul></li>

<li><b>static memory</b> - Objects, declared outside functions or member
functions are instantiated on the static memory and they are only
deleted when the program finishes.</li>

<li><b>heap memory</b> - Objects are allocated on the heap memory (aka
dynamic memory) when they are instantiated with operator
<b>new</b>. Unlike stack or static allocated objects, heap allocated
objects are not automatically destroyed, so they must be released
manually with the <b>delete</b> operator. However, deleting heap-objects
manually is error prone since it is easy to forget to call delete
operator. A better approach to deal with heap object is to use C++
smart pointers that wraps raw pointers and automatically deletes
heap objects when they go out of scope.</li>
</ul>

<p>
Code Highlights: 
</p>

<ul class="org-ul">
<li>Object allocated in static memory - lives during the entire program
execution and are only destroyed when the program execution ends.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">DummyClass</span> <span class="org-variable-name">dummyGlobal</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"dummy-global"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span> 
  ... ... 
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Object allocated in stack: (dummy1, dummy2, object d in testObject())</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-comment-delimiter">// </span><span class="org-comment">... </span>
<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Allocated on stack </span>
    <span class="org-type">DummyClass</span> <span class="org-variable-name">dummy1</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"dummy1-stack"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ---- ENTER LOCAL SCOPE "</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
      TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Create local scope"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">Allocated on stack </span>
      <span class="org-type">DummyClass</span> <span class="org-variable-name">dummy2</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"dummy2-stack-local-scope"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
          ... ... .. 
      <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">"EXIT LOCAL SCOPE "</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">dummy2 deleted here </span>

<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">dummy1 is deleted here </span>
</pre>
</div>

<ul class="org-ul">
<li>Objects allocated on the heap (dummyInHeap) must be released
manually or automatically with smart pointers (not used in this
code).
<ul class="org-ul">
<li>Note: For every object allocated on the heap,  it is necessary a
delete operator if smart pointers are not used.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-function-name">makeDummyHeap</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-type">DummyClass</span>* <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">... ... </span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Heap-allocated object </span>
  <span class="org-type">DummyClass</span>* <span class="org-variable-name">ptr</span> = <span class="org-keyword">new</span> <span class="org-type">DummyClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"dummy-heap"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
  <span class="org-keyword">return</span> ptr; 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">... ... ... .</span>
  <span class="org-type">DummyClass</span>* <span class="org-variable-name">dummyInHeap</span> =  makeDummyHeap<span class="org-rainbow-delimiters-depth-2">()</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">....   </span>
  dummyInHeap-&gt;speakWithUser<span class="org-rainbow-delimiters-depth-2">()</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">....</span>

  <span class="org-keyword">delete</span> dummyInHeap;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<ul class="org-ul">
<li>Deterministic destructor

<ul class="org-ul">
<li>In C++, destructors are <b>deterministic</b>. They are always called
automatically when an object allocated on the static memory
(global object) or stack goes out of scope or an exception
happens. Due to this feature, it is safe to release resources like
allocated memory, database handlers, file handlers, socket
handlers or perform other cleanup tasks on the destructor. It is
the foundation of the RAAI technique/idiom - "Resource Acquisition
is Initialization".</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ---- ENTER LOCAL EXCEPTION SCOPE "</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
     <span class="org-type">DummyClass</span> <span class="org-variable-name">dummyException</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"dummy2-stack-local-scope"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     dummyException.speakWithUser<span class="org-rainbow-delimiters-depth-2">()</span>;
     <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" ERROR Throw a failure for testing deterministic destructor"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ---- EXIT LOCAL EXCEPTION SCOPE "</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">runtime_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ---- ENTER EXCEPTION HANDLER"</span> &lt;&lt; <span class="org-string">"\n\n"</span>;        
     <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Failure = "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ---- EXIT EXCEPTION HANDLER"</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text"> ---- ENTER LOCAL EXCEPTION SCOPE 

object-lifecycle.cpp:21: - fun = DummyClass ; name = dummy2-stack-local-scope - I was created.
I am a dummy object called = dummy2-stack-local-scope
object-lifecycle.cpp:54: - fun = ~DummyClass ; name = dummy2-stack-local-scope - I was destroyed

 ---- ENTER EXCEPTION HANDLER

Failure =  ERROR Throw a failure for testing deterministic destructor

 ---- EXIT EXCEPTION HANDLER

</pre>
</div>


<p>
Complete Code: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">File:  object-lifecycle.cpp </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Brief: Demonstrate Object Lifecycle </span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">DEBUG_TRACE</span>

<span class="org-preprocessor">#ifdef</span> DEBUG_TRACE
<span class="org-preprocessor">  #pragma</span> message <span class="org-string">"Logging Enabled"</span>
<span class="org-preprocessor">  #define</span> <span class="org-function-name">TRACE</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">msg</span><span class="org-rainbow-delimiters-depth-1">)</span> \
    <span class="org-constant">std</span>::cerr &lt;&lt; __FILE__ &lt;&lt; <span class="org-string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="org-string">": - fun = "</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="org-string">" ; "</span> &lt;&lt; msg &lt;&lt; <span class="org-string">"\n"</span>
<span class="org-preprocessor">#else</span>
<span class="org-preprocessor">  #pragma</span> message <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Logging disabled"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">  #define</span> <span class="org-function-name">TRACE</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-variable-name">msg</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-preprocessor">#endif</span> 

<span class="org-keyword">class</span> <span class="org-type">DummyClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-comment-delimiter">// </span><span class="org-comment">Constructor </span>
        <span class="org-function-name">DummyClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">_object_name</span><span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){</span>
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"name = "</span><span class="org-rainbow-delimiters-depth-4">)</span> + name + <span class="org-string">" - I was created."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Copy constructor </span>
        <span class="org-function-name">DummyClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">DummyClass</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Enter copy constructor"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"name = "</span> + _object_name + <span class="org-string">" - I was copied. "</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-keyword">this</span>-&gt;_object_name = rhs._object_name + <span class="org-string">"-COPIED"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Move constructor </span>
        <span class="org-function-name">DummyClass</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-type">DummyClass</span>&amp;&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Enter move constructor"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"name = "</span> + _object_name + <span class="org-string">" - I was moved"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-keyword">this</span>-&gt;_object_name = rhs._object_name + <span class="org-string">"-MOVED"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Copy assignment operator</span>
        <span class="org-type">DummyClass</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">DummyClass</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Enter copy assignment operator"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"name = "</span> + _object_name + <span class="org-string">" - I was copied. "</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-keyword">this</span>-&gt;_object_name = rhs._object_name + <span class="org-string">"-COPIED"</span>;
                <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-comment-delimiter">//</span><span class="org-comment">DummyClass&amp; operator= (DummyClass&amp;&amp; rhs) = delete;</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Move assignment operator </span>
        <span class="org-type">DummyClass</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">DummyClass</span>&amp;&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Enter move assignment operator"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"name = "</span> + _object_name + <span class="org-string">" - I was moved. "</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-keyword">this</span>-&gt;_object_name = rhs._object_name + <span class="org-string">"-MOVED"</span>;
                <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Destructor </span>
        ~<span class="org-function-name">DummyClass</span><span class="org-rainbow-delimiters-depth-2">(){</span>
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"name = "</span><span class="org-rainbow-delimiters-depth-4">)</span> + _object_name  + <span class="org-string">" - I was destroyed"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">void</span> <span class="org-function-name">speakWithUser</span><span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"I am a dummy object called = "</span> &lt;&lt; _object_name &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-function-name">private</span>:
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">_object_name</span>;   
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Object allocated on the static memory </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">is deleted when the programs finishes. </span>
<span class="org-type">DummyClass</span> <span class="org-variable-name">dummyGlobal</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"dummy-global"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-function-name">testObject</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-type">DummyClass</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ==&gt; ENTER FUNCTION  testObject()"</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
    TRACE<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Enter function"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">d</span>  = DummyClass<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"local-dummy-in-function"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        d.speakWithUser<span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ==&gt; EXIT FUNCTION  testObject()"</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
    TRACE<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Exit function"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Object d is deleted here when it goes out scope</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">and then a copy of it is returned from here.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Therefore, the copy constructor is invoked.</span>
        <span class="org-keyword">return</span> d;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">auto</span> <span class="org-function-name">makeDummyHeap</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-type">DummyClass</span>* <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ==&gt; ENTER FUNCTION  makeDummyHeap()"</span> &lt;&lt; <span class="org-string">"\n\n"</span>;  
        <span class="org-comment-delimiter">// </span><span class="org-comment">Object allocated in dynamic memory, so it survives this scope</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">and is not deleted when returned from function. </span>
        <span class="org-type">DummyClass</span>* <span class="org-variable-name">ptr</span> = <span class="org-keyword">new</span> <span class="org-type">DummyClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"dummy-heap"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        ptr-&gt;speakWithUser<span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ==&gt; EXIT FUNCTION  makeDummyHeap()"</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
        <span class="org-keyword">return</span> ptr; 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">"ENTER FUNCTION MAIN"</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
        TRACE<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Main function started."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Object allocated on the stack -&gt; auto storage class, it is</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">destroyed when it goes out of scope </span>
        <span class="org-type">DummyClass</span> <span class="org-variable-name">dummy1</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"dummy1-stack"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        dummy1.speakWithUser<span class="org-rainbow-delimiters-depth-2">()</span>;

        <span class="org-type">DummyClass</span>* <span class="org-variable-name">dummyInHeap</span> =  makeDummyHeap<span class="org-rainbow-delimiters-depth-2">()</span>;
        dummyInHeap-&gt;speakWithUser<span class="org-rainbow-delimiters-depth-2">()</span>;

        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ---- ENTER LOCAL SCOPE "</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Create local scope"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-type">DummyClass</span> <span class="org-variable-name">dummy2</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"dummy2-stack-local-scope"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                dummy2.speakWithUser<span class="org-rainbow-delimiters-depth-3">()</span>;
                dummyGlobal.speakWithUser<span class="org-rainbow-delimiters-depth-3">()</span>;
                dummyInHeap-&gt;speakWithUser<span class="org-rainbow-delimiters-depth-3">()</span>;
                TRACE<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"End local scope"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-comment-delimiter">// </span><span class="org-comment">Object dummy2 deleted here</span>
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">"EXIT LOCAL SCOPE "</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ---- ENTER LOCAL EXCEPTION SCOPE "</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
                <span class="org-type">DummyClass</span> <span class="org-variable-name">dummyException</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"dummy2-stack-local-scope"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                dummyException.speakWithUser<span class="org-rainbow-delimiters-depth-3">()</span>;
                <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" ERROR Throw a failure for testing deterministic destructor"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ---- EXIT LOCAL EXCEPTION SCOPE "</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">runtime_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">){</span>
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ---- ENTER EXCEPTION HANDLER"</span> &lt;&lt; <span class="org-string">"\n\n"</span>;     
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Failure = "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">" ---- EXIT EXCEPTION HANDLER"</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>


        TRACE<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Copy object returned from function"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-type">DummyClass</span> <span class="org-variable-name">dummy2</span> = testObject<span class="org-rainbow-delimiters-depth-2">()</span>;
        dummy2.speakWithUser<span class="org-rainbow-delimiters-depth-2">()</span>;

        dummyInHeap-&gt;speakWithUser<span class="org-rainbow-delimiters-depth-2">()</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Objects allocated on the heap must be released manually or a</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">memory leak will happen. However, it is easy to forget to</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">delete a heap-allocated object, so the this approach is error</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">prone and better solution is to use C++11 smart pointers.</span>
        <span class="org-keyword">delete</span> dummyInHeap;

        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"\n"</span> &lt;&lt; <span class="org-string">"EXIT FUNCTION MAIN"</span> &lt;&lt; <span class="org-string">"\n\n"</span>;
        TRACE<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Main function finished."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">return</span> 0;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Object dummy1 and dummyGlobal deleted here </span>
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Complete Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ object-lifecycle.cpp -o <span class="org-keyword">object-lifecycle.bin</span> -g -std=c++1z -Wall -Wextra &amp;&amp; ./object-lifecycle.bin

<span class="org-function-name">object-lifecycle.cpp</span>:9:19: note: <span class="org-comment-delimiter">#</span><span class="org-comment">pragma message: Logging Enabled</span>
   <span class="org-comment-delimiter">#</span><span class="org-comment">pragma message "Logging Enabled"</span>
                   ^~~~~~~~~~~~~~~~~
<span class="org-function-name">object-lifecycle.cpp</span>:21: - fun = DummyClass ; name = dummy-global - I was created.

ENTER FUNCTION MAIN

<span class="org-function-name">object-lifecycle.cpp</span>:93: - fun = main ; Main <span class="org-keyword">function</span> <span class="org-function-name">started.</span>
<span class="org-function-name">object-lifecycle.cpp</span>:21: - fun = DummyClass ; name = dummy1-stack - I was created.
I am a dummy object called = dummy1-stack

 ==&gt; ENTER FUNCTION  makeDummyHeap()

<span class="org-function-name">object-lifecycle.cpp</span>:21: - fun = DummyClass ; name = dummy-heap - I was created.
I am a dummy object called = dummy-heap

 ==&gt; EXIT FUNCTION  makeDummyHeap()

I am a dummy object called = dummy-heap

 ---- ENTER LOCAL SCOPE 

<span class="org-function-name">object-lifecycle.cpp</span>:104: - fun = main ; Create local scope
<span class="org-function-name">object-lifecycle.cpp</span>:21: - fun = DummyClass ; name = dummy2-stack-local-scope - I was created.
I am a dummy object called = dummy2-stack-local-scope
I am a dummy object called = dummy-global
I am a dummy object called = dummy-heap
<span class="org-function-name">object-lifecycle.cpp</span>:109: - fun = main ; End local scope

EXIT LOCAL SCOPE 

<span class="org-function-name">object-lifecycle.cpp</span>:54: - fun = ~DummyClass ; name = dummy2-stack-local-scope - I was destroyed

 ---- ENTER LOCAL EXCEPTION SCOPE 

<span class="org-function-name">object-lifecycle.cpp</span>:21: - fun = DummyClass ; name = dummy2-stack-local-scope - I was created.
I am a dummy object called = dummy2-stack-local-scope
<span class="org-function-name">object-lifecycle.cpp</span>:54: - fun = ~DummyClass ; name = dummy2-stack-local-scope - I was destroyed

 ---- ENTER EXCEPTION HANDLER

Failure =  ERROR Throw a failure for testing deterministic destructor

 ---- EXIT EXCEPTION HANDLER

<span class="org-function-name">object-lifecycle.cpp</span>:127: - fun = main ; Copy object returned from <span class="org-keyword">function</span>

 ==&gt; ENTER FUNCTION  testObject()

<span class="org-function-name">object-lifecycle.cpp</span>:70: - fun = testObject ; Enter <span class="org-keyword">function</span>
<span class="org-function-name">object-lifecycle.cpp</span>:21: - fun = DummyClass ; name = local-dummy-in-function - I was created.
I am a dummy object called = local-dummy-in-function

 ==&gt; EXIT FUNCTION  testObject()

<span class="org-function-name">object-lifecycle.cpp</span>:74: - fun = testObject ; Exit <span class="org-keyword">function</span>
I am a dummy object called = local-dummy-in-function
I am a dummy object called = dummy-heap
<span class="org-function-name">object-lifecycle.cpp</span>:54: - fun = ~DummyClass ; name = dummy-heap - I was destroyed

EXIT FUNCTION MAIN

<span class="org-function-name">object-lifecycle.cpp</span>:140: - fun = main ; Main <span class="org-keyword">function</span> <span class="org-function-name">finished.</span>
<span class="org-function-name">object-lifecycle.cpp</span>:54: - fun = ~DummyClass ; name = local-dummy-in-function - I was destroyed
<span class="org-function-name">object-lifecycle.cpp</span>:54: - fun = ~DummyClass ; name = dummy1-stack - I was destroyed
<span class="org-function-name">object-lifecycle.cpp</span>:54: - fun = ~DummyClass ; name = dummy-global - I was destroyed
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfbcead6" class="outline-3">
<h3 id="orgfbcead6"><span class="section-number-3">1.20</span> OOP Polymorphism and Inheritance</h3>
<div class="outline-text-3" id="text-1-20">
</div>
<div id="outline-container-org4e075d8" class="outline-4">
<h4 id="org4e075d8"><span class="section-number-4">1.20.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-20-1">
<p>
Dynamic or subtyping polymorphis is basically, the ability
of the client code to deal with any any instance of derived classes in
the same way it deals with an instance of the base class. 
</p>

<p>
In C++, it is only possible to use OOP subtyping polymorphism with
pointers or references. As a result, it is not possible to store
instances of base class in STL containers by value, or to create
polymorphic functions which return instance of derived classes by
value or take instance derived classes as argument passed by value.
</p>

<p>
To summarize: 
</p>

<ul class="org-ul">
<li>Object Oriented Polymorphism, is aso called:
<ul class="org-ul">
<li>Dynamic polymorphism</li>
<li>Runtime polymorphism</li>
</ul></li>
<li>In C++ it is only possible to use polymorphism with references or
pointers.</li>
<li>A polymorphic function which returns any instance of the derived
class casted as an instance of the base class can only return them
<b>by pointer to objects allocated on the heap</b> (dynamic memory) with
<b>new</b> operator. Functions like this are called factory functions and
in this case, it is better to wrap the pointer in smart pointer,
<code>unique_ptr</code> or <code>shared_ptr</code>.</li>
</ul>
</div>
</div>
<div id="outline-container-org361232b" class="outline-4">
<h4 id="org361232b"><span class="section-number-4">1.20.2</span> OOP - Dynamic Polymorphism in deep</h4>
<div class="outline-text-4" id="text-1-20-2">
<ul class="org-ul">
<li>File: <a href="src/polymorphism1.C">file:src/polymorphism1.C</a> (CLING - Script)</li>
</ul>

<p>
Classes in the script <a href="src/polymorphism1.C">file:src/polymorphism1.C</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
   <span class="org-function-name">Base</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Copy constructor</span>
   <span class="org-function-name">Base</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Base</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>
       <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [TRACE] "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="org-string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="org-string">" "</span>
                 &lt;&lt; <span class="org-string">" Base copy constructor invoked."</span> &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Copy assignment operator</span>
   <span class="org-type">Base</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Base</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [TRACE] "</span> &lt;&lt; __FILE__ &lt;&lt; <span class="org-string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="org-string">" "</span> 
                  &lt;&lt; <span class="org-string">" Base copy assignment operator invoked."</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">The base class always need a virtual</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">destructor </span>
   <span class="org-keyword">virtual</span> ~<span class="org-function-name">Base</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;   

   <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getType</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> <span class="org-string">"Base"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>    
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getType2</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> <span class="org-string">"Base"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-type">void</span> <span class="org-function-name">showType</span><span class="org-rainbow-delimiters-depth-2">(){</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">OR: std::cout &lt;&lt; "Class type = " &lt;&lt; getType() &lt;&lt; "\n";</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Class type = "</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;getType<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">DerivedA</span>: <span class="org-keyword">public</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-function-name">DerivedA</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getType</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-string">"DerivedA"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getType2</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">return</span> <span class="org-string">"DerivedA"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>       
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">DerivedB</span>: <span class="org-keyword">public</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
   <span class="org-function-name">DerivedB</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getType</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> <span class="org-string">"DerivedB"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getType2</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> <span class="org-string">"DerivedB"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>        
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Load classes from script and create instances.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .L polymorphism1.C
Base base;
<span class="org-type">DerivedA</span> <span class="org-variable-name">da</span>;
<span class="org-type">DerivedB</span> <span class="org-variable-name">db</span>;
</pre>
</div>

<p>
<b>Testing methods:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Test method getType</span>
&gt;&gt; base.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>

&gt;&gt; da.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>

&gt;&gt; db.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedB"</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Test method get</span>
&gt;&gt; base.showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = Base
&gt;&gt; da.showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = DerivedA
&gt;&gt; db.showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = DerivedB
&gt;&gt; 
</pre>
</div>

<p>
<b>Testing object slicing on assingment by value</b>
</p>

<ul class="org-ul">
<li>Object: slicing =&gt; Happens when the an object of derived class is
assigned to a base class object, the virtual methods overridden in
the derived class are sliced off from the derived class. As a
result, any method call performed by the assigned object will call
the method base version, instead of the method overridden by the
derived class.
<ul class="org-ul">
<li>Summary: An object loses its polymorphic abilities when assigned
by value.</li>
</ul></li>
<li>Note: assignment in C++, is different from assignment in Java and
other OO languages. In C++, the assignment copies the object from
right side to the assigned object discarding all previous state
from the assigned object. In Java and other OO languages, the
assignment copies the reference (pointer) from the right-hand side
object to the left-hand side object, thus the assigned object
becomes an alias or mirror to right-hand side object.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; base = da
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> polymorphism1.C:19  Base copy assignment <span class="org-keyword">operator</span> <span class="org-type">invoked</span>.
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f9882578010
&gt;&gt; 
<span class="org-comment-delimiter">// </span><span class="org-comment">It should print "DerivedA", however due to object slicing, it prints "Base"</span>
&gt;&gt; base.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>

&gt;&gt; base.showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = Base
&gt;&gt; 
&gt;&gt; 

&gt;&gt; da.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>
&gt;&gt; da.showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = DerivedA
</pre>
</div>

<p>
<b>Assignment by pointer</b>
</p>

<p>
The solution for avoiding object slicing on assignment is to assign by
pointer instead of assigning by value.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; Base* p = <span class="org-constant">nullptr</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Point to object base ------------------------------------</span>
&gt;&gt; p = &amp;base;
&gt;&gt; p-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
&gt;&gt; p-&gt;getType2<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
&gt;&gt; p-&gt;showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = Base
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Point to object da (class DerivedA)</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">------------------------------------</span>
&gt;&gt; p = &amp;da;
&gt;&gt; p-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: overriding doesn't work because getType2() is annotated as virtual&#183; </span>
&gt;&gt; p-&gt;getType2<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
&gt;&gt; p-&gt;showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = DerivedA
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Point to object da (class DerivedB)</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">------------------------------------</span>
&gt;&gt; p = &amp;db;
&gt;&gt; p-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedB"</span>
&gt;&gt; p-&gt;getType2<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
&gt;&gt; p-&gt;showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = DerivedB
&gt;&gt; 
</pre>
</div>

<p>
<b>Assigning by reference</b>
</p>

<p>
Another solution for keeping the polymorphic behavior and avoid object
slicing is using references. 
</p>
<ul class="org-ul">
<li>Note: Unlike pointers, references cannot be reassigned once they
are created.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; Base&amp; refb = base;

&gt;&gt; refb.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>

&gt;&gt; refb.getType2<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>

&gt;&gt; refb.showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = Base
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Failure: object slicing!</span>
&gt;&gt; refb = da;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> polymorphism1.C:19  Base copy assignment <span class="org-keyword">operator</span> <span class="org-type">invoked</span>.
&gt;&gt; 
&gt;&gt; refb.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
&gt;&gt; refb.showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = Base
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Now, it works.</span>
&gt;&gt; Base&amp; refda = da;
&gt;&gt; refda.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>
&gt;&gt; refda.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>
&gt;&gt; refda.showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = DerivedA
&gt;&gt; refda.getType2<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
</pre>
</div>

<p>
<b>Passing by value</b>
</p>

<p>
Testing object slicing on passing parameters by value: 
</p>
<ul class="org-ul">
<li>Object slicing also happens when objects are passed by value.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">printClassNameValue</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span> <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Object type is: "</span> &lt;&lt; obj.getType<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; printClassNameValue<span class="org-rainbow-delimiters-depth-1">(</span>base<span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> polymorphism1.C:13  Base copy constructor invoked.
Object type is: Base
&gt;&gt; 
<span class="org-comment-delimiter">// </span><span class="org-comment">Should print Object type is: DerivedA </span>
&gt;&gt; printClassNameValue<span class="org-rainbow-delimiters-depth-1">(</span>da<span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> polymorphism1.C:13  Base copy constructor invoked.
Object type is: Base
&gt;&gt; 
<span class="org-comment-delimiter">// </span><span class="org-comment">Should print Object type is: DerivedB </span>
&gt;&gt; printClassNameValue<span class="org-rainbow-delimiters-depth-1">(</span>db<span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> polymorphism1.C:13  Base copy constructor invoked.
Object type is: Base
&gt;&gt; 
</pre>
</div>

<p>
<b>Passing by Pointer</b>
</p>

<p>
The solution for avoiding <b>object slicing</b> is passing objects by pointer
or reference:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Pass by pointer =&gt; Object slicling doesn't happen.</span>
<span class="org-type">void</span> <span class="org-function-name">printClassNamePtr</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Base</span>* <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Object type is: "</span> &lt;&lt; obj-&gt;getType<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; printClassNamePtr<span class="org-rainbow-delimiters-depth-1">(</span>&amp;base<span class="org-rainbow-delimiters-depth-1">)</span>
Object <span class="org-type">type</span> <span class="org-variable-name">is</span>: Base

&gt;&gt; printClassNamePtr<span class="org-rainbow-delimiters-depth-1">(</span>&amp;da<span class="org-rainbow-delimiters-depth-1">)</span>
Object <span class="org-type">type</span> <span class="org-variable-name">is</span>: DerivedA

&gt;&gt; printClassNamePtr<span class="org-rainbow-delimiters-depth-1">(</span>&amp;db<span class="org-rainbow-delimiters-depth-1">)</span>
Object <span class="org-type">type</span> <span class="org-variable-name">is</span>: DerivedB
&gt;&gt; 
&gt;&gt; Base* ptr = <span class="org-constant">nullptr</span>;
&gt;&gt; ptr = &amp;da;
&gt;&gt; printClassNamePtr<span class="org-rainbow-delimiters-depth-1">(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span>
Object <span class="org-type">type</span> <span class="org-variable-name">is</span>: DerivedA
&gt;&gt; 
&gt;&gt; ptr = &amp;db;
&gt;&gt; printClassNamePtr<span class="org-rainbow-delimiters-depth-1">(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span>
Object <span class="org-type">type</span> <span class="org-variable-name">is</span>: DerivedB
&gt;&gt; 

</pre>
</div>

<p>
<b>Passing by Reference</b>
</p>

<ul class="org-ul">
<li>Passing by reference
<ul class="org-ul">
<li>Note: In most object oriented languages, objects are passed by
reference by default, unlike C++ where objects are passed by
value.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">printClassNameRef</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Base</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Object type is: "</span> &lt;&lt; obj.getType<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; printClassNameRef<span class="org-rainbow-delimiters-depth-1">(</span>base<span class="org-rainbow-delimiters-depth-1">)</span>
Object <span class="org-type">type</span> <span class="org-function-name">is</span>: Base

&gt;&gt; printClassNameRef<span class="org-rainbow-delimiters-depth-1">(</span>da<span class="org-rainbow-delimiters-depth-1">)</span>
Object <span class="org-type">type</span> <span class="org-function-name">is</span>: DerivedA

&gt;&gt; printClassNameRef<span class="org-rainbow-delimiters-depth-1">(</span>db<span class="org-rainbow-delimiters-depth-1">)</span>
Object <span class="org-type">type</span> <span class="org-variable-name">is</span>: DerivedB
&gt;&gt; 
</pre>
</div>

<p>
<b>Factory function:</b>
</p>

<ul class="org-ul">
<li>A factory function returns any instance of any derived class of a
given base class.</li>
</ul>

<p>
Object slicing also happens when polymorphic types are returned by
value: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">This factory functon will fail due to object slicing </span>
<span class="org-type">Base</span> <span class="org-function-name">factoryFunctionValue</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">type</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"base"</span><span class="org-rainbow-delimiters-depth-2">)</span>
             <span class="org-keyword">return</span> Base<span class="org-rainbow-delimiters-depth-2">()</span>;
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"da"</span><span class="org-rainbow-delimiters-depth-2">)</span>
             <span class="org-keyword">return</span> DerivedA<span class="org-rainbow-delimiters-depth-2">()</span>;
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"db"</span><span class="org-rainbow-delimiters-depth-2">)</span>
             <span class="org-keyword">return</span> DerivedB<span class="org-rainbow-delimiters-depth-2">()</span>;
     <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Error: class type not found."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; Base rbase = factoryFunctionValue<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"base"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f9882578038
&gt;&gt; rbase.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
&gt;&gt; rbase.showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = Base
&gt;&gt; 

&gt;&gt; Base rda = factoryFunctionValue<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"da"</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span>/home/archbox/root-scripts/polymorphism1.C:13  Base copy constructor invoked.
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f9882578040

<span class="org-comment-delimiter">// </span><span class="org-comment">Fails! It should return derivedA </span>
&gt;&gt; rda.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
&gt;&gt; rda.showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = Base
&gt;&gt; 
</pre>
</div>

<p>
A workaround to the object slicing problem could be returning by
reference. However, this approach doesn't work because the function
<span class="underline">factoryFunctionRef</span> returns a reference to the object p allocated on
the stack, which is destroyed when the function returns, thus any
attempt to use this returned reference to a destroyed object will
result in a segmentation fault.
</p>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-comment-delimiter">// </span><span class="org-comment">This factory functon will fail due to object slicing </span>
<span class="org-type">Base</span>&amp; <span class="org-function-name">factoryFunctionRef</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">type</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-type">Base</span> <span class="org-variable-name">p</span>;
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"base"</span><span class="org-rainbow-delimiters-depth-2">)</span>
        p = Base<span class="org-rainbow-delimiters-depth-2">()</span>;
     <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"da"</span><span class="org-rainbow-delimiters-depth-2">)</span>
        p = DerivedA<span class="org-rainbow-delimiters-depth-2">()</span>;
     <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"db"</span><span class="org-rainbow-delimiters-depth-2">)</span>
        p = DerivedB<span class="org-rainbow-delimiters-depth-2">()</span>;
     <span class="org-keyword">else</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Error: class type not found."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">return</span> p;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; Base&amp; retda2 = factoryFunctionRef<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"da"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span>/home/archbox/root-scripts/polymorphism1.C:19  Base copy assignment <span class="org-keyword">operator</span> <span class="org-type">invoked</span>.
&gt;&gt; retda2.getType<span class="org-rainbow-delimiters-depth-1">()</span>

 *** Break *** segmentation violation

</pre>
</div>

<p>
An alternative approach is to return a pointer an object allocated on
the heap. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">Base</span>* <span class="org-function-name">factoryFunctionRawPointer</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">type</span><span class="org-rainbow-delimiters-depth-1">){</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"base"</span><span class="org-rainbow-delimiters-depth-2">)</span>
         <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-2">()</span>;
      <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"da"</span><span class="org-rainbow-delimiters-depth-2">)</span>
         <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">DerivedA</span><span class="org-rainbow-delimiters-depth-2">()</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"db"</span><span class="org-rainbow-delimiters-depth-2">)</span>
         <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">DerivedB</span><span class="org-rainbow-delimiters-depth-2">()</span>;
      <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Instantiate of class Base</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">--------------------------------</span>
&gt;&gt; Base* ptr_base1 = factoryFunctionRawPointer<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"base"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x2564130
&gt;&gt; ptr_base1-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
&gt;&gt; ptr_base1-&gt;getType2<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
&gt;&gt; ptr_base1-&gt;showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = Base
&gt;&gt; 
<span class="org-comment-delimiter">// </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Every heap-allocated object must be disposed when no longer </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">needed by calling the operator delete. </span>
&gt;&gt; <span class="org-keyword">delete</span> ptr_base1 ;
<span class="org-comment-delimiter">// </span><span class="org-comment">It is advisable to set the pointer of disposed heap-allocated</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">object to null.</span>
&gt;&gt; ptr_base1 = <span class="org-constant">nullptr</span>;
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Instantiate of class DerivedA </span>
<span class="org-comment-delimiter">//</span><span class="org-comment">--------------------------------</span>
&gt;&gt; Base* ptr_da = factoryFunctionRawPointer<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"da"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x334e4c0

&gt;&gt; ptr_da-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>

&gt;&gt; ptr_da-&gt;getType2<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>

&gt;&gt; ptr_da-&gt;showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = DerivedA
&gt;&gt; 

&gt;&gt; <span class="org-keyword">delete</span> ptr_da;
&gt;&gt; ptr_da = <span class="org-constant">nullptr</span>;
&gt;&gt; 
</pre>
</div>

<p>
<b>Safer Factory Function with smart pointers</b>
</p>

<p>
The factory function factoryFunctionRawPointer is vulnerable to memory
leaks since it returns a raw pointer to a heap-allocated object which
needs to be disposed with the operator delete once the object is no
longer needed. However, it is easy to forget to call delete and to
track all possible return paths and objects needing this pointer. A
solution to this issue is to use smart pointers which are
stack-allocated objects that delete pointed objects when the the they
go out of scope. It is possible to use <code>unique_ptr</code> which is only
movable and not copiable or <code>shared_ptr</code> which is copiable.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Requires header: &lt;memory&gt;</span>
<span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Base<span class="org-rainbow-delimiters-depth-1">&gt;</span> 
factoryFunctionSafe<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">type</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"base"</span><span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>Base<span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
    <span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"da"</span><span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>DerivedA<span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>type == <span class="org-string">"db"</span><span class="org-rainbow-delimiters-depth-2">)</span>
       <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>DerivedB<span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
    <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> uptr_base = factoryFunctionSafe<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"base"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; uptr_base
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>Base, <span class="org-constant">std</span>::<span class="org-type">default_delete</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>Base<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f9882578088

&gt;&gt; uptr_base-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>

&gt;&gt; uptr_base-&gt;showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = Base


&gt;&gt; <span class="org-keyword">auto</span> uptr_da = factoryFunctionSafe<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"da"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; uptr_da-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>

&gt;&gt; uptr_da-&gt;getType2<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>

&gt;&gt; uptr_da-&gt;showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = DerivedA
</pre>
</div>

<p>
<b>STL Containers and Polymorphic Types</b> 
</p>

<ul class="org-ul">
<li>Storing by value =&gt; Leads to object slicing.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">NOTE: Objects base, da and db are copied to the vector, not stored in the vector.</span>
&gt;&gt;  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Base<span class="org-rainbow-delimiters-depth-1">&gt;</span> objlist = <span class="org-rainbow-delimiters-depth-1">{</span>base, da, db<span class="org-rainbow-delimiters-depth-1">}</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> polymorphism1.C:13  Base copy constructor invoked.
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> polymorphism1.C:13  Base copy constructor invoked.
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> polymorphism1.C:13  Base copy constructor invoked.
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> polymorphism1.C:13  Base copy constructor invoked.
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> polymorphism1.C:13  Base copy constructor invoked.
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> polymorphism1.C:13  Base copy constructor invoked.

 &gt;&gt; objlist<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.getType<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
 <span class="org-comment-delimiter">// </span><span class="org-comment">Expected DerivedA </span>
 &gt;&gt; objlist<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.getType<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
 <span class="org-comment-delimiter">// </span><span class="org-comment">Expected DerivedB</span>
 &gt;&gt; objlist<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>.getType<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
 &gt;&gt; 

 <span class="org-comment-delimiter">// </span><span class="org-comment">Objects stored in the vector don't have </span>
 <span class="org-comment-delimiter">// </span><span class="org-comment">the same memory location as the following objects.</span>
 &gt;&gt; &amp;objlist<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span> == &amp;base
 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
 &gt;&gt; &amp;objlist<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> == &amp;da
 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
 &gt;&gt; &amp;objlist<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> == &amp;db
 <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
 &gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Storing by Pointer =&gt; Object Slicing does not happen.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> objects = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Base</span>*<span class="org-rainbow-delimiters-depth-1">&gt;{}</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Base</span> *, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Base</span> *<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
&gt;&gt; objects.push_back<span class="org-rainbow-delimiters-depth-1">(</span>&amp;base<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; objects.push_back<span class="org-rainbow-delimiters-depth-1">(</span>&amp;da<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; objects.push_back<span class="org-rainbow-delimiters-depth-1">(</span>&amp;db<span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">e</span> : objects<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; e-&gt;getType<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;<span class="org-rainbow-delimiters-depth-1">}</span>
type = Base
type = DerivedA
type = DerivedB
&gt;&gt; 

&gt;&gt; 
&gt;&gt; objects<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
&gt;&gt; objects<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>-&gt;showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = Base

&gt;&gt; objects<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>
&gt;&gt; objects<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>-&gt;showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = DerivedA

&gt;&gt; objects<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedB"</span>
&gt;&gt; objects<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>-&gt;showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = DerivedB
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Storing by Reference (Since C++11 with reference wrapper) =&gt; Object
Slicing does not happen.
<ul class="org-ul">
<li>See: <a href="https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper">std::reference_wrapper</a></li>
<li>Requires: C++11 and header &lt;functional&gt;</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">Provides: std::reference_wrapper</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">DOES NOT WORK: Ugly, cryptic and verbose  error!! </span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Base</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;</span> objRef;
  18: error: <span class="org-warning">'</span>pointer<span class="org-warning">'</span> declared as a pointer to a reference of type <span class="org-warning">'</span>Base &amp;<span class="org-warning">'</span>
       <span class="org-keyword">typedef</span> _Tp*       pointer;

<span class="org-comment-delimiter">// </span><span class="org-comment">Header: </span>
&gt;&gt; <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">reference_wrapper</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> objRef;
&gt;&gt; <span class="org-keyword">auto</span> objRefList = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">reference_wrapper</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;{}</span>;

&gt;&gt; objRefList.push_back<span class="org-rainbow-delimiters-depth-1">(</span>base<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; objRefList.push_back<span class="org-rainbow-delimiters-depth-1">(</span>da<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; objRefList.push_back<span class="org-rainbow-delimiters-depth-1">(</span>db<span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; objRefList<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.get<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f3604aa6010

&gt;&gt; objRefList<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.get<span class="org-rainbow-delimiters-depth-1">()</span>.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>

&gt;&gt; objRefList<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.get<span class="org-rainbow-delimiters-depth-1">()</span>.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>

&gt;&gt; objRefList<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>.get<span class="org-rainbow-delimiters-depth-1">()</span>.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedB"</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">p</span>: objRefList<span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; p.get<span class="org-rainbow-delimiters-depth-2">()</span>.getType<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;<span class="org-rainbow-delimiters-depth-1">}</span>
type = Base
type = DerivedA
type = DerivedB
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Check whether objects stored in the vector were not copied.</span>
&gt;&gt; &amp;objRefList<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>.get<span class="org-rainbow-delimiters-depth-1">()</span> == &amp;base
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; &amp;objRefList<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>.get<span class="org-rainbow-delimiters-depth-1">()</span> == &amp;da
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; &amp;objRefList<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>.get<span class="org-rainbow-delimiters-depth-1">()</span> == &amp;db
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Storing objects heap-allocated objects (aka free store or dynamic memory)
<ul class="org-ul">
<li>Requires: C++11 + header &lt;memory&gt; which provides smart pointers.</li>
<li>See: <a href="http://www.cplusplus.com/reference/memory/">&lt;memory&gt;</a></li>
<li>In order to avoid memory leaks, it is better to store
heap-allocated objects in STL containers using smart pointers as
they delete the allocated objects when out of scope or an
exception happens (RAII). If raw pointers were used, the heap
allocated-objects would not be disposed automatically without the
<span class="underline">delete</span> operator, as a result, a memory leak could happen.</li>
<li>Note: this example assumes single ownership of the allocated
objects, in other words, only the container is responsible for
deleting the objects. So, shared_ptr is a better option when
multiple ownership is required,</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">memory</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Custom deleter type alias </span>
<span class="org-keyword">using</span> <span class="org-type">Deleter</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Base</span>*<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Type synonym for unique_ptr which manages objects </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">from class Base and its classes.</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">-----------------------------------</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">To use without the custom delter: </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">using Ubase = std::unique_ptr&lt;Base&gt;;</span>
<span class="org-keyword">using</span> <span class="org-type">Ubase</span> = <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Base</span>, <span class="org-type">Deleter</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Custom deleter used for logging </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">and demonstrate what the smart pointer does.</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">deleter</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">Base</span>* <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [TRACE] Deleted  object of type = "</span> &lt;&lt; b-&gt;getType<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
  <span class="org-keyword">delete</span> b;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">xlist</span> = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Ubase</span><span class="org-rainbow-delimiters-depth-1">&gt;{}</span>;
xlist.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">Base</span>, deleter<span class="org-rainbow-delimiters-depth-1">)</span>
xlist.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">DerivedA</span>, deleter<span class="org-rainbow-delimiters-depth-1">)</span>
xlist.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">DerivedB</span>, deleter<span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; xlist<span class="org-rainbow-delimiters-depth-1">[</span>0<span class="org-rainbow-delimiters-depth-1">]</span>-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>

&gt;&gt; xlist<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>

&gt;&gt; xlist<span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span>-&gt;getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedB"</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; xlist.size<span class="org-rainbow-delimiters-depth-2">()</span>; i++<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"type = "</span> &lt;&lt; xlist<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span>-&gt;getType<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;<span class="org-rainbow-delimiters-depth-1">}</span>
type = Base
type = DerivedA
type = DerivedB
&gt;&gt; 

&gt;&gt; xlist.clear<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> Deleted  object of type = Base
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> Deleted  object of type = DerivedA
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> Deleted  object of type = DerivedB
&gt;&gt; 

&gt;&gt; xlist.size<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; 
</pre>
</div>

<p>
<b>Summary:</b> 
</p>

<ul class="org-ul">
<li>An object loses its polymorphic abilities if assigned by value,
passed by value or returned by value. It is called <b>object slicing</b>.</li>

<li>Polymorphic types cannot be stored by value in STL containers due
to object slicing. The only way to store them is by pointer or
reference.</li>

<li>In C++, polymorphism only works when objects are assigned by
pointer or reference or when passed by pointer or reference.
<ul class="org-ul">
<li><b>Polymorphism (dynamic) only works with references or pointers.</b></li>
</ul></li>

<li>Methods, aka member functions not annotated as virtual cannot be
overridden by derived classes.</li>

<li>The only way to return polymorphic objects from functions is to
return pointers (prone to memory leaks) or smart-pointers (safer)
to heap-allocated objects.</li>
</ul>
</div>
</div>
<div id="outline-container-org45de873" class="outline-4">
<h4 id="org45de873"><span class="section-number-4">1.20.3</span> Dynamic Polymorphism example - code</h4>
<div class="outline-text-4" id="text-1-20-3">
<p>
File: polymorphism.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">memory</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>   <span class="org-comment-delimiter">// </span><span class="org-comment">C++11 Smart pointers (unique_ptr and shared_ptr)</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">map</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>      <span class="org-comment-delimiter">// </span><span class="org-comment">Hash table, hash map or dictionary</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cassert</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">assertions tests </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Interface class </span>
<span class="org-keyword">class</span> <span class="org-type">GenericDBDriver</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
  <span class="org-function-name">GenericDBDriver</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
  <span class="org-keyword">virtual</span> <span class="org-keyword">auto</span> <span class="org-function-name">driverName</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-string">"generic"</span>;   
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">virtual</span> <span class="org-keyword">auto</span> <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-string">"unknown"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">virtual</span> <span class="org-keyword">auto</span> <span class="org-function-name">connect</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">url</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Connecting to generic driver url = "</span> &lt;&lt; url &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">virtual</span> <span class="org-keyword">auto</span> <span class="org-function-name">isConnected</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default destructor</span>
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">GenericDBDriver</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Disconnecting from generic driver - id = "</span> &lt;&lt; <span class="org-string">"unknown"</span>&lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">DriverSQLiteDriver</span>: <span class="org-keyword">public</span> <span class="org-type">GenericDBDriver</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
  <span class="org-type">bool</span> <span class="org-variable-name">m_connected</span> = <span class="org-constant">false</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_id</span> = <span class="org-string">"unknown"</span>;
<span class="org-function-name">public</span>:
  <span class="org-function-name">DriverSQLiteDriver</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
  <span class="org-function-name">DriverSQLiteDriver</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">m_id</span><span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Const keyword in this case indicates that the member function (method)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">doesn't change the current object.</span>
  <span class="org-keyword">auto</span> <span class="org-function-name">driverName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">override</span><span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-string">"sqlite"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">auto</span> <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> m_id;
  <span class="org-rainbow-delimiters-depth-2">}</span>  
  <span class="org-comment-delimiter">// </span><span class="org-comment">This keyword override -&gt; indicates visually that the method</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">is being overriden and also provides some safety features which</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">helps to improve type-safety and compile-time correctness.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">For instance, if member function (aka method) being overriden</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">is not annotated as virtual in the base class, this C++11 keyword</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">will generate a compile-time error. It also will generate a compile-time</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">error if the member function being overriden doesn't exist in the base class.  </span>
  <span class="org-keyword">auto</span> <span class="org-function-name">connect</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">url</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Connecting to "</span> &lt;&lt; url &lt;&lt; <span class="org-constant">std</span>::endl;
    m_connected = <span class="org-constant">true</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">auto</span> <span class="org-function-name">isConnected</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">bool</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> m_connected;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  ~<span class="org-function-name">DriverSQLiteDriver</span><span class="org-rainbow-delimiters-depth-2">(){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Disconnecting from PosgresDB - m_id = "</span> &lt;&lt; m_id &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-keyword">class</span> <span class="org-type">DriverPostgresSQL</span>: <span class="org-keyword">public</span> <span class="org-type">GenericDBDriver</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
  <span class="org-type">bool</span> <span class="org-variable-name">m_connected</span> = <span class="org-constant">false</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_id</span> = <span class="org-string">"unknown"</span>;  
<span class="org-function-name">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">DriverPostgresSQL () = default;</span>
  <span class="org-function-name">DriverPostgresSQL</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">m_id</span><span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span>

  <span class="org-keyword">auto</span> <span class="org-function-name">driverName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">override</span><span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-string">"PostGresSQL"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">virtual</span> <span class="org-keyword">auto</span> <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> m_id;
  <span class="org-rainbow-delimiters-depth-2">}</span>   
  <span class="org-keyword">auto</span> <span class="org-function-name">connect</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">url</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Connecting to "</span> &lt;&lt; url &lt;&lt; <span class="org-constant">std</span>::endl;
    m_connected = <span class="org-constant">true</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">auto</span> <span class="org-function-name">isConnected</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">bool</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> m_connected;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  ~<span class="org-function-name">DriverPostgresSQL</span><span class="org-rainbow-delimiters-depth-2">(){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Disconnecting from PostGresSQL - id = "</span> &lt;&lt; m_id &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>  
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-keyword">class</span> <span class="org-type">DriverSQLServer</span> : <span class="org-keyword">public</span> <span class="org-type">GenericDBDriver</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
  <span class="org-type">bool</span> <span class="org-variable-name">m_connected</span> = <span class="org-constant">false</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_id</span> = <span class="org-string">"unknown"</span>;  
<span class="org-function-name">public</span>:
  <span class="org-function-name">DriverSQLServer</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
  <span class="org-function-name">DriverSQLServer</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">m_id</span><span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span>

  <span class="org-keyword">auto</span> <span class="org-function-name">driverName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">override</span><span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-string">"SQLServer"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">auto</span> <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> m_id;
  <span class="org-rainbow-delimiters-depth-2">}</span>    
  <span class="org-keyword">auto</span> <span class="org-function-name">connect</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">url</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">void</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Connecting to "</span> &lt;&lt; url &lt;&lt; <span class="org-constant">std</span>::endl;
    m_connected = <span class="org-constant">true</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">auto</span> <span class="org-function-name">isConnected</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">bool</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> m_connected;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  ~<span class="org-function-name">DriverSQLServer</span><span class="org-rainbow-delimiters-depth-2">(){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Disconnecting from SQLServer - id = "</span> &lt;&lt; m_id &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>  
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Non-polymorphi function -&gt; Parameters passed by value cannot be polymorphic</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">void showDriverStatus(const GenericDBDriver driver){ ... }</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Polymorphic function using references </span>
<span class="org-type">void</span> <span class="org-function-name">showDriverStatus1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">GenericDBDriver</span>&amp; <span class="org-variable-name">driver</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Driver = "</span> &lt;&lt; driver.driverName<span class="org-rainbow-delimiters-depth-2">()</span>
            &lt;&lt; <span class="org-string">" id = "</span> &lt;&lt; driver.getID<span class="org-rainbow-delimiters-depth-2">()</span>
            &lt;&lt; <span class="org-string">" ; status = "</span> &lt;&lt; driver.isConnected<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt;  <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Polymorphic function using pointers </span>
<span class="org-type">void</span> <span class="org-function-name">showDriverStatus2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">GenericDBDriver</span>* <span class="org-variable-name">driver</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Driver = "</span> &lt;&lt; driver-&gt;driverName<span class="org-rainbow-delimiters-depth-2">()</span>
            &lt;&lt; <span class="org-string">" id = "</span> &lt;&lt; driver-&gt;getID<span class="org-rainbow-delimiters-depth-2">()</span>
            &lt;&lt; <span class="org-string">" ; status = "</span> &lt;&lt; driver-&gt;isConnected<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt;  <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-comment-delimiter">// </span><span class="org-comment">Factory method</span>
<span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">DriverType</span><span class="org-rainbow-delimiters-depth-1">{</span>
 <span class="org-variable-name">generic</span>,
 <span class="org-variable-name">sqlite</span>,
 <span class="org-variable-name">postgres</span>,
 <span class="org-variable-name">sqlserver</span>                        
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">auto</span> <span class="org-function-name">dbDriverFactory</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">DriverType</span>&amp; <span class="org-variable-name">dbtype</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">id</span> = <span class="org-string">"unknown"</span><span class="org-rainbow-delimiters-depth-1">)</span>
  -&gt; <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">GenericDBDriver</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span>
  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>dbtype == <span class="org-constant">DriverType</span>::generic<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">GenericDBDriver</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>;   
  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>dbtype == <span class="org-constant">DriverType</span>::sqlite<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DriverSQLiteDriver</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>id<span class="org-rainbow-delimiters-depth-2">)</span>;   
  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>dbtype == <span class="org-constant">DriverType</span>::postgres<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DriverPostgresSQL</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>id<span class="org-rainbow-delimiters-depth-2">)</span>;   
  <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>dbtype == <span class="org-constant">DriverType</span>::sqlserver<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DriverSQLServer</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>id<span class="org-rainbow-delimiters-depth-2">)</span>;    
  <span class="org-comment-delimiter">// </span><span class="org-comment">Failure -&gt; DO NOT return old C++98 NULL as it is not typesafe </span>
  <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-keyword">class</span> <span class="org-type">DriverFactory</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:

<span class="org-function-name">public</span>:

  <span class="org-function-name">DriverFactory</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">delete</span>;
  <span class="org-function-name">DriverFactory</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">DriverFactory</span>&amp; <span class="org-variable-name">lhs</span><span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;

  <span class="org-keyword">static</span> <span class="org-keyword">auto</span> <span class="org-function-name">getInstance</span><span class="org-rainbow-delimiters-depth-2">()</span> 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>

  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n====== Test 1 ==========="</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Uniform initialization </span>
    <span class="org-type">GenericDBDriver</span>   <span class="org-variable-name">d0</span>;
    <span class="org-type">DriverSQLServer</span>   <span class="org-variable-name">d1</span><span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"d1"</span><span class="org-rainbow-delimiters-depth-3">}</span>;
    <span class="org-type">DriverPostgresSQL</span> <span class="org-variable-name">d2</span> = <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"d2"</span><span class="org-rainbow-delimiters-depth-3">}</span>;
    <span class="org-type">DriverSQLServer</span>   <span class="org-variable-name">d3</span> = <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"d3"</span><span class="org-rainbow-delimiters-depth-3">}</span>;

    showDriverStatus1<span class="org-rainbow-delimiters-depth-3">(</span>d0<span class="org-rainbow-delimiters-depth-3">)</span>;
    showDriverStatus1<span class="org-rainbow-delimiters-depth-3">(</span>d1<span class="org-rainbow-delimiters-depth-3">)</span>;
    d1.connect<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"file:///home/user/datbase.sqlite"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    showDriverStatus1<span class="org-rainbow-delimiters-depth-3">(</span>d1<span class="org-rainbow-delimiters-depth-3">)</span>;
    showDriverStatus1<span class="org-rainbow-delimiters-depth-3">(</span>d2<span class="org-rainbow-delimiters-depth-3">)</span>;
    showDriverStatus1<span class="org-rainbow-delimiters-depth-3">(</span>d3<span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"====== End of test 1 ==========="</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n====== Test 2 ==========="</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Uniform initialization </span>
    <span class="org-type">GenericDBDriver</span>   <span class="org-variable-name">d0</span>;
    <span class="org-type">DriverSQLServer</span>   <span class="org-variable-name">d1</span><span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"d1"</span><span class="org-rainbow-delimiters-depth-3">}</span>;
    <span class="org-type">DriverPostgresSQL</span> <span class="org-variable-name">d2</span> = <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"d2"</span><span class="org-rainbow-delimiters-depth-3">}</span>;
    <span class="org-type">DriverSQLServer</span>   <span class="org-variable-name">d3</span> = <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"d3"</span><span class="org-rainbow-delimiters-depth-3">}</span>;

    showDriverStatus2<span class="org-rainbow-delimiters-depth-3">(</span>&amp;d0<span class="org-rainbow-delimiters-depth-3">)</span>;
    showDriverStatus2<span class="org-rainbow-delimiters-depth-3">(</span>&amp;d1<span class="org-rainbow-delimiters-depth-3">)</span>;
    d1.connect<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"file:///home/user/datbase.sqlite"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    showDriverStatus2<span class="org-rainbow-delimiters-depth-3">(</span>&amp;d1<span class="org-rainbow-delimiters-depth-3">)</span>;
    showDriverStatus2<span class="org-rainbow-delimiters-depth-3">(</span>&amp;d2<span class="org-rainbow-delimiters-depth-3">)</span>;
    showDriverStatus2<span class="org-rainbow-delimiters-depth-3">(</span>&amp;d3<span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"====== End of test 2 ==========="</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Failure ! -&gt; It only calls the methods of GenericDBDriver</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">It is not possible to polymorphism (subtyping polymorphism) in C++</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">without pointers or references.</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n====== Test 3 ==========="</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">GenericDBDriver</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">xs</span>;

    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>GenericDBDriver<span class="org-rainbow-delimiters-depth-4">{}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>DriverSQLServer <span class="org-rainbow-delimiters-depth-4">{</span><span class="org-string">"d1"</span><span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>DriverPostgresSQL<span class="org-rainbow-delimiters-depth-4">{</span><span class="org-string">"d2"</span><span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>DriverSQLServer<span class="org-rainbow-delimiters-depth-4">{</span><span class="org-string">"d3"</span><span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: xs<span class="org-rainbow-delimiters-depth-3">){</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" - driver = "</span> &lt;&lt; x.driverName<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-string">" ; id = "</span> &lt;&lt; x.getID<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-3">}</span>

    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>0<span class="org-rainbow-delimiters-depth-4">)</span>.driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"generic"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>1<span class="org-rainbow-delimiters-depth-4">)</span>.driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"generic"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>2<span class="org-rainbow-delimiters-depth-4">)</span>.driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"generic"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>3<span class="org-rainbow-delimiters-depth-4">)</span>.driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"generic"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n====== End of test 3 ==========="</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>


  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n====== Test 4 ==========="</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">GenericDBDriver</span>*<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">xs</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">d0</span> = GenericDBDriver<span class="org-rainbow-delimiters-depth-3">{}</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">d1</span> = DriverSQLiteDriver <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"d1"</span><span class="org-rainbow-delimiters-depth-3">}</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">d2</span> = DriverPostgresSQL<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"d2"</span><span class="org-rainbow-delimiters-depth-3">}</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">d3</span> = DriverSQLServer<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-string">"d3"</span><span class="org-rainbow-delimiters-depth-3">}</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>&amp;d0<span class="org-rainbow-delimiters-depth-3">)</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>&amp;d1<span class="org-rainbow-delimiters-depth-3">)</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>&amp;d2<span class="org-rainbow-delimiters-depth-3">)</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>&amp;d3<span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: xs<span class="org-rainbow-delimiters-depth-3">){</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" - driver = "</span> &lt;&lt; x-&gt;driverName<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-string">" ; id = "</span> &lt;&lt; x-&gt;getID<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>0<span class="org-rainbow-delimiters-depth-4">)</span>-&gt;driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"generic"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>1<span class="org-rainbow-delimiters-depth-4">)</span>-&gt;driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"sqlite"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>2<span class="org-rainbow-delimiters-depth-4">)</span>-&gt;driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"PostGresSQL"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>3<span class="org-rainbow-delimiters-depth-4">)</span>-&gt;driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"SQLServer"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"====== End of test 4 ==========="</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>  

  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n====== Test 5 ==========="</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">GenericDBDriver</span><span class="org-rainbow-delimiters-depth-4">&gt;</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">xs</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>dbDriverFactory<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">DriverType</span>::generic<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>dbDriverFactory<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">DriverType</span>::sqlite,    <span class="org-string">"d1"</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>dbDriverFactory<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">DriverType</span>::postgres,  <span class="org-string">"d2"</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    xs.push_back<span class="org-rainbow-delimiters-depth-3">(</span>dbDriverFactory<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">DriverType</span>::sqlserver, <span class="org-string">"d3"</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: xs<span class="org-rainbow-delimiters-depth-3">){</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" - driver = "</span> &lt;&lt; x-&gt;driverName<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-string">" ; id = "</span> &lt;&lt; x-&gt;getID<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;;
    <span class="org-rainbow-delimiters-depth-3">}</span>
    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>0<span class="org-rainbow-delimiters-depth-4">)</span>-&gt;driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"generic"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>1<span class="org-rainbow-delimiters-depth-4">)</span>-&gt;driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"sqlite"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>2<span class="org-rainbow-delimiters-depth-4">)</span>-&gt;driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"PostGresSQL"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    assert<span class="org-rainbow-delimiters-depth-3">(</span>xs.at<span class="org-rainbow-delimiters-depth-4">(</span>3<span class="org-rainbow-delimiters-depth-4">)</span>-&gt;driverName<span class="org-rainbow-delimiters-depth-4">()</span> == <span class="org-string">"SQLServer"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"====== End of test 5 ==========="</span> &lt;&lt; <span class="org-constant">std</span>::endl;
  <span class="org-rainbow-delimiters-depth-2">}</span>  
  <span class="org-keyword">return</span> EXIT_SUCCESS;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ polymorphism.cpp -std=c++1z -Wall -Wextra &amp;&amp; ./a.out

====== Test 1 ===========
 [INFO] Driver = generic id = unknown ; status = false
 [INFO] Driver = SQLServer id = d1 ; status = false
Connecting to file:///home/user/datbase.sqlite
 [INFO] Driver = SQLServer id = d1 ; status = true
 [INFO] Driver = PostGresSQL id = d2 ; status = false
 [INFO] Driver = SQLServer id = d3 ; status = false
====== End of test 1 ===========
Disconnecting from SQLServer - id = d3
Disconnecting from generic driver - id = unknown
Disconnecting from PostGresSQL - id = d2
Disconnecting from generic driver - id = unknown
Disconnecting from SQLServer - id = d1
Disconnecting from generic driver - id = unknown
Disconnecting from generic driver - id = unknown

====== Test 2 ===========
 [INFO] Driver = generic id = unknown ; status = false
 [INFO] Driver = SQLServer id = d1 ; status = false
Connecting to file:///home/user/datbase.sqlite
 [INFO] Driver = SQLServer id = d1 ; status = true
 [INFO] Driver = PostGresSQL id = d2 ; status = false
 [INFO] Driver = SQLServer id = d3 ; status = false
====== End of test 2 ===========
Disconnecting from SQLServer - id = d3
Disconnecting from generic driver - id = unknown
Disconnecting from PostGresSQL - id = d2
Disconnecting from generic driver - id = unknown
Disconnecting from SQLServer - id = d1
Disconnecting from generic driver - id = unknown
Disconnecting from generic driver - id = unknown

====== Test 3 ===========
Disconnecting from generic driver - id = unknown
Disconnecting from SQLServer - id = d1
Disconnecting from generic driver - id = unknown
Disconnecting from PostGresSQL - id = d2
Disconnecting from generic driver - id = unknown
Disconnecting from SQLServer - id = d3
Disconnecting from generic driver - id = unknown
 - driver = generic ; id = unknown
 - driver = generic ; id = unknown
 - driver = generic ; id = unknown
 - driver = generic ; id = unknown

====== End of test 3 ===========
Disconnecting from generic driver - id = unknown
Disconnecting from generic driver - id = unknown
Disconnecting from generic driver - id = unknown
Disconnecting from generic driver - id = unknown

====== Test 4 ===========
 - driver = generic ; id = unknown
 - driver = sqlite ; id = d1
 - driver = PostGresSQL ; id = d2
 - driver = SQLServer ; id = d3
====== End of test 4 ===========
Disconnecting from SQLServer - id = d3
Disconnecting from generic driver - id = unknown
Disconnecting from PostGresSQL - id = d2
Disconnecting from generic driver - id = unknown
Disconnecting from PosgresDB - m_id = d1
Disconnecting from generic driver - id = unknown
Disconnecting from generic driver - id = unknown

====== Test 5 ===========
 - driver = generic ; id = unknown
 - driver = sqlite ; id = d1
 - driver = PostGresSQL ; id = d2
 - driver = SQLServer ; id = d3
====== End of test 5 ===========
Disconnecting from generic driver - id = unknown
Disconnecting from PosgresDB - m_id = d1
Disconnecting from generic driver - id = unknown
Disconnecting from PostGresSQL - id = d2
Disconnecting from generic driver - id = unknown
Disconnecting from SQLServer - id = d3
Disconnecting from generic driver - id = unknown

</pre>
</div>
</div>
</div>

<div id="outline-container-orgfd8fbe5" class="outline-4">
<h4 id="orgfd8fbe5"><span class="section-number-4">1.20.4</span> STL containers and polymorphism</h4>
<div class="outline-text-4" id="text-1-20-4">
<p>
C++'s STL (Standard Template Library) containers/collections such as
vector, deque, map, stack and so on can only store pointers to
instances of different derived classes from a given base
class. However the STL containers cannot store references to those
instances. The STL std::reference_wrapper solves this problem. 
</p>

<p>
Documentation: 
</p>
<ul class="org-ul">
<li><a href="http://www.cplusplus.com/reference/functional/reference_wrapper/operator_func/">http://www.cplusplus.com/reference/functional/reference_wrapper/operator_func/</a></li>
</ul>

<p>
Demonstration in CERN's ROOT C++ REPL: 
</p>

<ul class="org-ul">
<li>Create test classes.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Base class </span>
<span class="org-keyword">class</span> <span class="org-type">IRoot</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
  <span class="org-keyword">virtual</span> <span class="org-keyword">auto</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-string">"root"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">//</span><span class="org-comment">===== Derived Classes ====== //</span>

<span class="org-keyword">class</span> <span class="org-type">A</span>: <span class="org-keyword">public</span> <span class="org-type">IRoot</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
  <span class="org-keyword">auto</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-string">"Class A"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">B</span>: <span class="org-keyword">public</span> <span class="org-type">IRoot</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
  <span class="org-keyword">auto</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-string">"Class B"</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Play with sample objects:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Create test objects </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">r</span> = IRoot<span class="org-rainbow-delimiters-depth-1">()</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">a</span> = A<span class="org-rainbow-delimiters-depth-1">()</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">b</span> = B<span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Test objects </span>
&gt;&gt; r.getName<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"root"</span>
&gt;&gt; a.getName<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Class A"</span>
&gt;&gt; b.getName<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Class B"</span>
&gt;&gt;
</pre>
</div>

<ul class="org-ul">
<li>Store those objects in a collection by pointer:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> xsp = <span class="org-constant">std</span>::deque<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">IRoot</span>*<span class="org-rainbow-delimiters-depth-1">&gt;()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IRoot</span> *, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">IRoot</span> *<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
&gt;&gt; xsp.push_back<span class="org-rainbow-delimiters-depth-1">(</span>&amp;r<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; xsp.push_back<span class="org-rainbow-delimiters-depth-1">(</span>&amp;a<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; xsp.push_back<span class="org-rainbow-delimiters-depth-1">(</span>&amp;b<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; xsp
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">IRoot</span> *, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">IRoot</span> *<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> @0x2f01990, @0x2f01998, @0x2f019a0 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt;
&gt;&gt;

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span>: xsp<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"name = "</span> &lt;&lt; x-&gt;getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-1">}</span>
name = root
name = Class A
name = Class B
&gt;&gt;

</pre>
</div>

<ul class="org-ul">
<li>Try to store those object r, a and b in a container/collection by
reference.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Many of errors: new_allocator.h:63:18: error: 'pointer' declared</span>
<span class="org-comment"> * as a pointer to a reference of type 'IRoot &amp;' typedef _Tp* pointer;</span>
<span class="org-comment"> */</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">xs</span> = <span class="org-constant">std</span>::deque<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">IRoot</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;()</span> 
</pre>
</div>

<ul class="org-ul">
<li>Try to store those object r, a and b in a container/collection by
reference using <span class="underline">std::reference_wrapper</span>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> xsr = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">reference_wrapper</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>IRoot<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">reference_wrapper</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>IRoot<span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">reference_wrapper</span><span class="org-rainbow-delimiters-depth-4">&lt;</span>IRoot<span class="org-rainbow-delimiters-depth-4">&gt;</span> <span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
&gt;&gt;

xsr.push_back<span class="org-rainbow-delimiters-depth-1">(</span>a<span class="org-rainbow-delimiters-depth-1">)</span>
xsr.push_back<span class="org-rainbow-delimiters-depth-1">(</span>r<span class="org-rainbow-delimiters-depth-1">)</span>
xsr.push_back<span class="org-rainbow-delimiters-depth-1">(</span>b<span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; xsr
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">reference_wrapper</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>IRoot<span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">reference_wrapper</span><span class="org-rainbow-delimiters-depth-4">&lt;</span>IRoot<span class="org-rainbow-delimiters-depth-4">&gt;</span> <span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span> @0x31013c0, @0x31013c8, @0x31013d0 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt;

&gt;&gt; xsr.at<span class="org-rainbow-delimiters-depth-1">(</span>0<span class="org-rainbow-delimiters-depth-1">)</span>.get<span class="org-rainbow-delimiters-depth-1">()</span>.getName<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Class A"</span>
&gt;&gt; xsr.at<span class="org-rainbow-delimiters-depth-1">(</span>1<span class="org-rainbow-delimiters-depth-1">)</span>.get<span class="org-rainbow-delimiters-depth-1">()</span>.getName<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"root"</span>
&gt;&gt; xsr.at<span class="org-rainbow-delimiters-depth-1">(</span>2<span class="org-rainbow-delimiters-depth-1">)</span>.get<span class="org-rainbow-delimiters-depth-1">()</span>.getName<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Class B"</span>
&gt;&gt; 
&gt;&gt;

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span>: xsr<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"name = "</span> &lt;&lt; x.get<span class="org-rainbow-delimiters-depth-2">()</span>.getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-1">}</span>
name = Class A
name = root
name = Class B
&gt;&gt; 

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: xsr<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"name = "</span> &lt;&lt; x.get<span class="org-rainbow-delimiters-depth-2">()</span>.getName<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-1">}</span>
name = Class A
name = root
name = Class B
&gt;&gt; 
</pre>
</div>

<p>
References: 
</p>

<ul class="org-ul">
<li><a href="https://oopscenities.net/2012/08/09/reference_wrapper/">https://oopscenities.net/2012/08/09/reference_wrapper/</a></li>

<li>How to correctly use std::reference_wrappers -
<a href="https://stackoverflow.com/questions/18127469/how-to-correctly-use-stdreference-wrappers">https://stackoverflow.com/questions/18127469/how-to-correctly-use-stdreference-wrappers</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org1ac1668" class="outline-3">
<h3 id="org1ac1668"><span class="section-number-3">1.21</span> OOP Operator Overloading</h3>
<div class="outline-text-3" id="text-1-21">
</div>
<div id="outline-container-org581343c" class="outline-4">
<h4 id="org581343c"><span class="section-number-4">1.21.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-21-1">
<p>
Operator overloads allows defining common primitives types operations
for user defined types such as classes. Seom types of operators are arithmentic
operators (+, *, /), comparison operators ( <code>==</code>, !=, &lt;, &gt;, &lt;=, &gt;=),
assignment +=, *=, /=, and so on.
</p>

<p>
Types of operator overloading: 
</p>

<ul class="org-ul">
<li>Member function operator overloading.
<ul class="org-ul">
<li>The operator such as +, *, / or == is a class method, the left
hand-side of a binary operator is the current object passed as
implicit argument and the right-hand-side is the operator
argument.</li>
</ul></li>

<li>Free function operator overloading (a non member function, non method):
<ul class="org-ul">
<li><span class="underline">Non-friend function operator overloading</span> - The operator is
defined as a free function, just as an ordinary function without
access to class private data. There is no implicit argument, both
left-hand-side and right-hand-side are function arguments.</li>

<li><span class="underline">Friend function Operator overloading</span> - The operator is defined as
a free function (non member function or non method) and has
access to class private data and private member functions.</li>
</ul></li>
</ul>

<p>
Operators that cannot be overloaded: 
</p>

<ul class="org-ul">
<li>(.) Object.member() - Member access operator</li>
<li>(?) Ternary operator</li>
<li>(::) Escope Resolution operator</li>
</ul>

<p>
Operator properties: 
</p>

<ul class="org-ul">
<li>Precedency</li>
<li>Associativity</li>
<li>Arity - number of operands (operator arguments)
<ul class="org-ul">
<li>Unary Operators:  -Object, !Object, &#x2026;</li>
<li>Binary Operators: (+), (=), (*), &#x2026;</li>
</ul></li>
<li>Types of operators:
<ul class="org-ul">
<li>Arithmetic: +, /, *,</li>
<li>Logical: &amp;&amp;, ||</li>
<li>Assignment: =, <code>+=</code>, <code>*=</code>, ..</li>
<li>Bitwise: &amp;, |, ^ &#x2026;</li>
<li>Function-call:
<ul class="org-ul">
<li>Object(10), Object.operator()(10) ..</li>
</ul></li>
<li>Increment/Decrement: Object++, &#x2013;Object &#x2026;</li>
<li>Pointer
<ul class="org-ul">
<li>Array index,  ([]), Object[10]</li>
<li>Deference operator  (*), *Object</li>
<li>Address-of operator (&amp;), &amp;Object</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org59afa67" class="outline-4">
<h4 id="org59afa67"><span class="section-number-4">1.21.2</span> Example: Arithmetic member function operator overloading</h4>
<div class="outline-text-4" id="text-1-21-2">
<p>
Source:
</p>
<ul class="org-ul">
<li>File: <a href="src/operator-overload1.cpp">file:src/operator-overload1.cpp</a></li>
<li>Online compiler: <a href="https://rextester.com/QVFZX23695">https://rextester.com/QVFZX23695</a></li>
</ul>

<p>
Class Complex declaration (file: Complex.hpp):
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">Complex number */</span>
<span class="org-keyword">class</span> <span class="org-type">Complex</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
     <span class="org-type">double</span> <span class="org-variable-name">m_real</span>, <span class="org-variable-name">m_imag</span>;
<span class="org-function-name">public</span>:
     <span class="org-comment-delimiter">/** </span><span class="org-comment">Make class printable */</span>
     <span class="org-keyword">friend</span> <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">&lt;&lt;</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp;, <span class="org-keyword">const</span> <span class="org-type">Complex</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;    

     <span class="org-comment-delimiter">/** </span><span class="org-comment">Constructors */</span>
     <span class="org-function-name">Complex</span><span class="org-rainbow-delimiters-depth-2">()</span>;
     <span class="org-function-name">Complex</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">real</span>, <span class="org-type">double</span> <span class="org-variable-name">imag</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-comment-delimiter">/** </span><span class="org-comment">Named constructor */</span>
     <span class="org-keyword">static</span> <span class="org-type">Complex</span> <span class="org-function-name">fromReal</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">real</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">static</span> <span class="org-type">Complex</span> <span class="org-function-name">fromImag</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">imag</span><span class="org-rainbow-delimiters-depth-2">)</span>;

     <span class="org-type">double</span> <span class="org-function-name">Real</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
     <span class="org-type">double</span> <span class="org-function-name">Imag</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;

     <span class="org-type">Complex</span> <span class="org-keyword">operator</span><span class="org-function-name">-</span><span class="org-rainbow-delimiters-depth-2">()</span>;
     <span class="org-type">Complex</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Complex</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-type">Complex</span> <span class="org-keyword">operator</span><span class="org-function-name">-</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Complex</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-type">Complex</span> <span class="org-keyword">operator</span><span class="org-function-name">*</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Complex</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-type">Complex</span> <span class="org-keyword">operator</span><span class="org-function-name">/</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Complex</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>;

     <span class="org-type">Complex</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">d</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-type">Complex</span> <span class="org-keyword">operator</span><span class="org-function-name">-</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">d</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-type">Complex</span> <span class="org-keyword">operator</span><span class="org-function-name">*</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">scale</span><span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-type">Complex</span> <span class="org-keyword">operator</span><span class="org-function-name">/</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">factor</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Class Complex implementation (file: Complex.cpp):
</p>

<ul class="org-ul">
<li>Arithmetic operator overloading definitions for Complex as operator
explicit argument:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-type">Complex</span> <span class="org-constant">Complex</span>::<span class="org-keyword">operator</span><span class="org-function-name">-</span><span class="org-rainbow-delimiters-depth-1">(){</span>
      <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{</span>-m_real, -m_imag<span class="org-rainbow-delimiters-depth-2">}</span>;
 <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-type">Complex</span> <span class="org-constant">Complex</span>::<span class="org-keyword">operator</span><span class="org-function-name">+</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Complex</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">self</span> = *<span class="org-keyword">this</span>;
      <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{</span>self.m_real + rhs.m_real, self.m_imag + rhs.m_imag <span class="org-rainbow-delimiters-depth-2">}</span>;
 <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-type">Complex</span> <span class="org-constant">Complex</span>::<span class="org-keyword">operator</span><span class="org-function-name">-</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Complex</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">self</span> = *<span class="org-keyword">this</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">(x1 + j . y1)(x2 + j . y2) = x1.x2 + j( -y1.y2 )</span>
      <span class="org-keyword">return</span> Complex<span class="org-rainbow-delimiters-depth-2">{</span>self.m_real - rhs.m_real, self.m_imag - rhs.m_imag <span class="org-rainbow-delimiters-depth-2">}</span>;
 <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">Complex</span> <span class="org-constant">Complex</span>::<span class="org-keyword">operator</span><span class="org-function-name">*</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Complex</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> Complex<span class="org-rainbow-delimiters-depth-2">{</span>
         m_real * rhs.m_real - m_imag * rhs.m_imag,
         m_real * rhs.m_imag + m_imag * rhs.m_real
                 <span class="org-rainbow-delimiters-depth-2">}</span>;
 <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Arithmetic operator overloading definitions for double as explicit
argument.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">Complex</span> <span class="org-constant">Complex</span>::<span class="org-keyword">operator</span><span class="org-function-name">+</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">d</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">return</span> Complex<span class="org-rainbow-delimiters-depth-2">{</span>m_real + d, m_imag + d<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">Complex</span> <span class="org-constant">Complex</span>::<span class="org-keyword">operator</span><span class="org-function-name">-</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">d</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">return</span> Complex<span class="org-rainbow-delimiters-depth-2">{</span>m_real - d, m_imag - d<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">Complex</span> <span class="org-constant">Complex</span>::<span class="org-keyword">operator</span><span class="org-function-name">*</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">scale</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">this</span>-&gt;m_real * scale, <span class="org-keyword">this</span>-&gt;m_imag *  scale<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">Complex</span> <span class="org-constant">Complex</span>::<span class="org-keyword">operator</span><span class="org-function-name">/</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">factor</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">return</span> Complex<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">this</span>-&gt;m_real / factor, <span class="org-keyword">this</span>-&gt;m_imag / factor<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Test in CERN's ROOT REPL:</b>
</p>

<p>
Load file and instantiate some variables:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .L <span class="org-keyword">operator</span>-overload1.cpp 

&gt;&gt; Complex c1;

&gt;&gt; Complex c2<span class="org-rainbow-delimiters-depth-1">{</span>2, 5<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Complex</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f4088144020

&gt;&gt; Complex c3<span class="org-rainbow-delimiters-depth-1">{</span>3, 4<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Complex</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f4088144030
</pre>
</div>

<p>
Test operators: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"c1 + c2 + c3 = "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-1">(</span>c1 + c2 + c3<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
c1 + c2 + c3 = Complex<span class="org-rainbow-delimiters-depth-1">{</span> 5 + 9j <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; c2 + c3 &lt;&lt; <span class="org-constant">std</span>::endl;
Complex<span class="org-rainbow-delimiters-depth-1">{</span> 5 + 9j <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; c3 + c2 &lt;&lt; <span class="org-constant">std</span>::endl;
Complex<span class="org-rainbow-delimiters-depth-1">{</span> 5 + 9j <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Call operator explicitly:
</p>

<ul class="org-ul">
<li>c2 + c3 = c2.operator+()(c3)</li>
<li>c3 + c2 = c3.operator+()(c2)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">c2 + c3 = c2.operator+(c3) </span>
&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; c2.<span class="org-keyword">operator</span>+<span class="org-rainbow-delimiters-depth-1">(</span>c3<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
Complex<span class="org-rainbow-delimiters-depth-1">{</span> 5 + 9j <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">c3 + c2 = c2.operator+(c3)</span>
&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; c3.<span class="org-keyword">operator</span>+<span class="org-rainbow-delimiters-depth-1">(</span>c2<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
Complex<span class="org-rainbow-delimiters-depth-1">{</span> 5 + 9j <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Member function operator overloading is not symmetric:
</p>
<ul class="org-ul">
<li>c2 + 10 = c2.operator+(10) =&gt; OK.</li>
<li>10 + c2 = 10.operator+(c2) ?? =&gt; Compile-time ERROR!</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"c2 + 10 = "</span> &lt;&lt; c2 + 10 &lt;&lt; <span class="org-constant">std</span>::endl;
c2 + 10 = Complex<span class="org-rainbow-delimiters-depth-1">{</span> 12 + 15j <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">ERROR!!!</span>
&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"10 + c2 = "</span> &lt;&lt; 10 + c2 &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">ROOT_prompt_17</span>:1:33: error: invalid operands to binary expression <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-warning">'</span><span class="org-type">int</span><span class="org-warning">'</span> <span class="org-keyword">and</span> <span class="org-warning">'</span>Complex<span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"10 + c2 = "</span> &lt;&lt; 10 + c2 &lt;&lt; <span class="org-constant">std</span>::endl;
                             ~~ ^ ~~
<span class="org-function-name">/home/archbox/opt/root/include/TString.h</span>:531:1: note: candidate function <span class="org-keyword">not</span> viable: no known conversion from <span class="org-warning">'</span>Complex<span class="org-warning">'</span> to
      <span class="org-warning">'</span><span class="org-keyword">const</span> TString<span class="org-warning">'</span> <span class="org-keyword">for</span> 2nd argument
<span class="org-keyword">operator</span>+<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span> <span class="org-variable-name">i</span>, <span class="org-keyword">const</span> <span class="org-type">TString</span> &amp;<span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-1">)</span>
^
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb2826d8" class="outline-4">
<h4 id="orgb2826d8"><span class="section-number-4">1.21.3</span> Example: Arithmetic free-function function operator overloading</h4>
<div class="outline-text-4" id="text-1-21-3">
<p>
Operators can also be defined as ordinary functions (aka free
functions), or non-member and non-friend function, it means without
access to private members.
</p>

<p>
Source:
</p>
<ul class="org-ul">
<li>File: <a href="src/operator-overload2.cpp">file:src/operator-overload2.cpp</a></li>
<li>Online Compiler: <a href="https://rextester.com/UBME18391">https://rextester.com/UBME18391</a></li>
</ul>

<p>
Syntax for non-friend free-function operator overloading: 
</p>

<ul class="org-ul">
<li>Unary operator</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">RETURN_TYPE</span> <span class="org-keyword">operator</span> <span class="org-function-name">&lt;&lt;</span>UNARY-OPERATOR&gt;&gt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">LSH</span>&amp; <span class="org-variable-name">lhs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or, C++11 syntax </span>
<span class="org-keyword">auto</span> <span class="org-keyword">operator</span> <span class="org-function-name">&lt;&lt;</span>UNARY-OPERATOR&gt;&gt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">LSH</span>&amp; <span class="org-variable-name">lhs</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; RETURN_TYPE;

<span class="org-comment-delimiter">// </span><span class="org-comment">Example: Invert vector </span>
<span class="org-type">Vector3D</span> <span class="org-keyword">operator</span><span class="org-function-name">-</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector3D</span>&amp; <span class="org-variable-name">lhs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">-</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector3D</span>&amp; <span class="org-variable-name">lhs</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; Vector3D;
</pre>
</div>

<ul class="org-ul">
<li>Binary operator</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">RETURN_TYPE</span> <span class="org-keyword">operator</span> <span class="org-function-name">&lt;&lt;</span>BINARY-OPERATOR&gt;&gt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">LSH</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-keyword">const</span> <span class="org-type">RHS</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or, C++11 flavor: </span>
<span class="org-keyword">auto</span> <span class="org-keyword">operator</span> <span class="org-function-name">&lt;&lt;</span>BINARY-OPERATOR&gt;&gt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">LSH</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-keyword">const</span> <span class="org-type">RHS</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; RETURN_TYPE;

<span class="org-comment-delimiter">// </span><span class="org-comment">Example: </span>
<span class="org-type">Vector3D</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector3D</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-type">double</span> <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector3D</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-type">double</span> <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; Vector3D;
</pre>
</div>


<p>
Declaration (It should be Vector2D.hpp)
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/** </span><span class="org-comment">A struct is just a class with everything public by default. */</span>
<span class="org-keyword">struct</span> <span class="org-type">Vector2D</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-variable-name">y</span>;
    <span class="org-function-name">Vector2D</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-function-name">Vector2D</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">std</span>::ostream&amp; <span class="org-keyword">operator</span>&lt;&lt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">vec</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">Vector2D</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">/** </span><span class="org-comment">C++11 Notation */</span>
<span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">-</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector2D</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-type">Vector2D</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; Vector2D;
<span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">-</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">lhs</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; Vector2D;

<span class="org-type">Vector2D</span> <span class="org-keyword">operator</span><span class="org-function-name">*</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">k</span>, <span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">Vector2D</span> <span class="org-keyword">operator</span><span class="org-function-name">*</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">rhs</span>, <span class="org-type">double</span> <span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">/</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-type">double</span> <span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; Vector2D;
</pre>
</div>

<p>
Implementation (It should be Vector2D.cpp)
</p>

<ul class="org-ul">
<li>Constructors:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">Vector2D</span>::Vector2D<span class="org-rainbow-delimiters-depth-1">()</span>: x<span class="org-rainbow-delimiters-depth-1">(</span>0.0<span class="org-rainbow-delimiters-depth-1">)</span>, y<span class="org-rainbow-delimiters-depth-1">(</span>0.0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">Vector2D</span>::Vector2D<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">)</span>: x<span class="org-rainbow-delimiters-depth-1">(</span>x<span class="org-rainbow-delimiters-depth-1">)</span>, y<span class="org-rainbow-delimiters-depth-1">(</span>y<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Operators as free-functions:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::ostream&amp; <span class="org-keyword">operator</span>&lt;&lt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">vec</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> os &lt;&lt; <span class="org-string">"Vector2D{ x = "</span> &lt;&lt; vec.x &lt;&lt; <span class="org-string">" ; "</span>
              &lt;&lt; <span class="org-string">" y = "</span> &lt;&lt; vec.y &lt;&lt; <span class="org-string">" } "</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">Vector2D</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> Vector2D<span class="org-rainbow-delimiters-depth-2">(</span>lhs.x + rhs.x, lhs.y + rhs.y<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">-</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector2D</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-type">Vector2D</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; Vector2D
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> Vector2D<span class="org-rainbow-delimiters-depth-2">(</span>lhs.x - rhs.x, lhs.y - rhs.y<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
  ... .... ... ... 

<span class="org-comment-delimiter">// </span><span class="org-comment">Symmetric operator </span>

Vector2D <span class="org-keyword">operator</span>*<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">rhs</span>, <span class="org-type">double</span> <span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{</span>k * rhs.x, k * rhs.y<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">/</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-type">double</span> <span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; Vector2D
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{</span>lhs.x / k, lhs.y / k<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>REPL Test:</b>
</p>

<p>
Load file in the CERN's ROOT REPL.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .L <span class="org-keyword">operator</span>-overload2.cpp

&gt;&gt; Vector2D v1<span class="org-rainbow-delimiters-depth-1">{</span>3, 5<span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; Vector2D v2<span class="org-rainbow-delimiters-depth-1">{</span>5, 6<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"v1 = "</span> &lt;&lt; v1 &lt;&lt; <span class="org-constant">std</span>::endl;
v1 = Vector2D<span class="org-rainbow-delimiters-depth-1">{</span> x = 3 ;  y = 5 <span class="org-rainbow-delimiters-depth-1">}</span> 
&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"v2 = "</span> &lt;&lt; v2 &lt;&lt; <span class="org-constant">std</span>::endl;
v2 = Vector2D<span class="org-rainbow-delimiters-depth-1">{</span> x = 5 ;  y = 6 <span class="org-rainbow-delimiters-depth-1">}</span> 
</pre>
</div>

<p>
Test operator overloading:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> v = v1 + v2
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector2D</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7fb99c26d030

&gt;&gt; v.x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 8.0000000

&gt;&gt; v.y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 11.000000

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"v1 + v2 = "</span> &lt;&lt; v &lt;&lt; <span class="org-constant">std</span>::endl;
v1 + v2 = Vector2D<span class="org-rainbow-delimiters-depth-1">{</span> x = 8 ;  y = 11 <span class="org-rainbow-delimiters-depth-1">}</span> 
</pre>
</div>

<p>
Test symmetry:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" v1 * 5 = "</span> &lt;&lt; v1 * 5 &lt;&lt; <span class="org-constant">std</span>::endl;
 v1 * 5 = Vector2D<span class="org-rainbow-delimiters-depth-1">{</span> x = 15 ;  y = 25 <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" 5 * v1 = "</span> &lt;&lt;  5 * v1 &lt;&lt; <span class="org-constant">std</span>::endl;
 5 * v1 = Vector2D<span class="org-rainbow-delimiters-depth-1">{</span> x = 15 ;  y = 25 <span class="org-rainbow-delimiters-depth-1">}</span> 
</pre>
</div>

<p>
Explicitly calling operator function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" v1 * 5 = "</span> &lt;&lt;  <span class="org-keyword">operator</span>*<span class="org-rainbow-delimiters-depth-1">(</span>v1, 5<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
 v1 * 5 = Vector2D<span class="org-rainbow-delimiters-depth-1">{</span> x = 15 ;  y = 25 <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" 5 * v1 = "</span> &lt;&lt;  <span class="org-keyword">operator</span>*<span class="org-rainbow-delimiters-depth-1">(</span>5, v1<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
 5 * v1 = Vector2D<span class="org-rainbow-delimiters-depth-1">{</span> x = 15 ;  y = 25 <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" v1 + v2 = "</span> &lt;&lt;  v1 + v2 &lt;&lt; <span class="org-constant">std</span>::endl;
 v1 + v2 = Vector2D<span class="org-rainbow-delimiters-depth-1">{</span> x = 8 ;  y = 11 <span class="org-rainbow-delimiters-depth-1">}</span> 

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" v1 + v2 = "</span> &lt;&lt; <span class="org-keyword">operator</span>+<span class="org-rainbow-delimiters-depth-1">(</span>v1, v2<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
 v1 + v2 = Vector2D<span class="org-rainbow-delimiters-depth-1">{</span> x = 8 ;  y = 11 <span class="org-rainbow-delimiters-depth-1">}</span> 
</pre>
</div>
</div>
</div>

<div id="outline-container-org925574b" class="outline-4">
<h4 id="org925574b"><span class="section-number-4">1.21.4</span> Example: Arithmetic friend function operator overloading</h4>
<div class="outline-text-4" id="text-1-21-4">
<p>
Operators can also be defined as class friend-functions, in this case
the opertor is just a ordinary function, however with access to class
privage member variable and memebr functions.
</p>

<p>
Source: 
</p>
<ul class="org-ul">
<li>File: <a href="src/operator-overloading3.cpp">file:src/operator-overloading3.cpp</a></li>
<li>Online Compiler: <a href="https://rextester.com/ABWWL87635">https://rextester.com/ABWWL87635</a></li>
</ul>

<p>
Class declaration: (It should be in header file Vector2D.hpp)
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Vector2D</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
   <span class="org-type">double</span> <span class="org-variable-name">m_x</span>, <span class="org-variable-name">m_y</span>;
<span class="org-function-name">public</span>:
   <span class="org-function-name">Vector2D</span><span class="org-rainbow-delimiters-depth-2">()</span>;
   <span class="org-function-name">Vector2D</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-type">double</span> <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
   <span class="org-type">double</span> <span class="org-function-name">Y</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;    
   <span class="org-keyword">friend</span> <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">&lt;&lt;</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">vec</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">friend</span> <span class="org-type">Vector2D</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>;

   <span class="org-comment-delimiter">/** </span><span class="org-comment">C++11 Notation */</span>
   <span class="org-keyword">friend</span> <span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">-</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Vector2D</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-type">Vector2D</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; Vector2D;
   <span class="org-keyword">friend</span> <span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">-</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">lhs</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; Vector2D;

   <span class="org-keyword">friend</span> <span class="org-type">Vector2D</span> <span class="org-keyword">operator</span><span class="org-function-name">*</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">k</span>, <span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">friend</span> <span class="org-type">Vector2D</span> <span class="org-keyword">operator</span><span class="org-function-name">*</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">rhs</span>, <span class="org-type">double</span> <span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">friend</span> <span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">/</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-type">double</span> <span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; Vector2D;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Class implementation: (It should be in header file Vector2D.cpp)
</p>

<ul class="org-ul">
<li>Constructors and member functions:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">Vector2D</span>::Vector2D<span class="org-rainbow-delimiters-depth-1">()</span>: m_x<span class="org-rainbow-delimiters-depth-1">(</span>0.0<span class="org-rainbow-delimiters-depth-1">)</span>, m_y<span class="org-rainbow-delimiters-depth-1">(</span>0.0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">Vector2D</span>::Vector2D<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">)</span>: m_x<span class="org-rainbow-delimiters-depth-1">(</span>x<span class="org-rainbow-delimiters-depth-1">)</span>, m_y<span class="org-rainbow-delimiters-depth-1">(</span>y<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">double</span> <span class="org-constant">Vector2D</span>::<span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-keyword">this</span>-&gt;m_x;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">double</span> <span class="org-constant">Vector2D</span>::<span class="org-function-name">Y</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-keyword">this</span>-&gt;m_y;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<ul class="org-ul">
<li>Some class operators functions:
<ul class="org-ul">
<li>Note: They are not member functions (methods).</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::ostream&amp; <span class="org-keyword">operator</span>&lt;&lt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">vec</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> os &lt;&lt; <span class="org-string">"Vector2D{ x = "</span> &lt;&lt; vec.m_x &lt;&lt; <span class="org-string">" ; "</span>
               &lt;&lt; <span class="org-string">" y = "</span> &lt;&lt; vec.m_y &lt;&lt; <span class="org-string">" } "</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">Vector2D</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> Vector2D<span class="org-rainbow-delimiters-depth-2">(</span>lhs.m_x + rhs.m_x, lhs.m_y + rhs.m_y<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">-</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector2D</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-type">Vector2D</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; Vector2D
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> Vector2D<span class="org-rainbow-delimiters-depth-2">(</span>lhs.m_x - rhs.m_x, lhs.m_y - rhs.m_y<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

    . .. ... ... .. 

Vector2D <span class="org-keyword">operator</span>*<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">k</span>, <span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{</span>k * rhs.m_x, k * rhs.m_y<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">Vector2D</span> <span class="org-keyword">operator</span><span class="org-function-name">*</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Vector2D</span>&amp; <span class="org-variable-name">rhs</span>, <span class="org-type">double</span> <span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{</span>k * rhs.m_x, k * rhs.m_y<span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
REPL Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .L <span class="org-keyword">operator</span>-overloading3.cpp 

&gt;&gt; Vector2D v1<span class="org-rainbow-delimiters-depth-1">{</span>3, 5<span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; v1.X<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 3.0000000

&gt;&gt; v1.Y<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 5.0000000

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>v1 * 4<span class="org-rainbow-delimiters-depth-1">)</span>.X<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 12.000000

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span>v1 * 4<span class="org-rainbow-delimiters-depth-1">)</span>.Y<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 20.000000

&gt;&gt; Vector2D v2<span class="org-rainbow-delimiters-depth-1">{</span>5, 6<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector2D</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f181a05b020

&gt;&gt; v = v1 + v2
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Vector2D</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f181a05b030

&gt;&gt; v.X<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 8.0000000

&gt;&gt; v.Y<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 11.000000
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbddae68" class="outline-4">
<h4 id="orgbddae68"><span class="section-number-4">1.21.5</span> Example: Insertion &lt;&lt; and extraction &gt;&gt; operator overload</h4>
<div class="outline-text-4" id="text-1-21-5">
<p>
Moved to: <a href="STL_Input_and_output.html">STL IO - Input and Output</a> advanced IO.
</p>
</div>
</div>

<div id="outline-container-org95a928c" class="outline-4">
<h4 id="org95a928c"><span class="section-number-4">1.21.6</span> Member function operator overloading reference card</h4>
<div class="outline-text-4" id="text-1-21-6">
<p>
Member functions operators are binary or unary class methods and the
left hand-side of a binary operator is its implicit argument.
</p>

<p>
<b>Arithmetic Operators</b> 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Arithmetic member function operator overloading</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Member function signature</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">for class C and RHS type R</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Addition</td>
<td class="org-left">LHS + RHS</td>
<td class="org-left">C C::operator+(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Subtraction</td>
<td class="org-left">LHS - RHS</td>
<td class="org-left">C C::operator-(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Multiplication</td>
<td class="org-left">LHS * RHS</td>
<td class="org-left">C C::operator*(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Division</td>
<td class="org-left">LSH / RHS</td>
<td class="org-left">C C::operator/(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Remainder</td>
<td class="org-left">LSH % RHS</td>
<td class="org-left">C C::operator%(const RHS&amp; rhs)</td>
</tr>
</tbody>
</table>


<ul class="org-ul">
<li>C: Class that the operator belongs to.</li>
<li>LHS - Left-hand-side type (Implicit argument current object of class C.)</li>
<li>RHS - Right-hand-side type or class (a class is also a type)</li>
</ul>

<p>
<b>Comparison Operators</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 4:</span> Comparison member function operator overloading</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Member function signature</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">for class C and RHS type R</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Equal</td>
<td class="org-left">LHS == RHS</td>
<td class="org-left">bool C::operator==(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Not equal</td>
<td class="org-left">LHS != RHS</td>
<td class="org-left">bool C::operator-(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Greater than</td>
<td class="org-left">LHS &gt;  RHS</td>
<td class="org-left">bool C::operator&gt;(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Greater or equal than</td>
<td class="org-left">LHS &gt;= RHS</td>
<td class="org-left">bool C::operator&gt;=(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Less than</td>
<td class="org-left">LHS &lt;  RHS</td>
<td class="org-left">bool C::operator&lt;(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Less or equal than</td>
<td class="org-left">LHS &lt;= RHS</td>
<td class="org-left">bool C::operator&lt;=(const RHS&amp; rhs)</td>
</tr>
</tbody>
</table>


<p>
<b>Prefix/Postfix - Increment / Decrement</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 5:</span> Increment and decrement operator overloading.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Expansion</th>
<th scope="col" class="org-left">Member function signature</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Prefix increment</td>
<td class="org-left">++Object</td>
<td class="org-left">Object = Object + 1</td>
<td class="org-left">C&amp; C::operator++()</td>
</tr>

<tr>
<td class="org-left">Postfix increment</td>
<td class="org-left">Object++</td>
<td class="org-left">Object = Object + 1</td>
<td class="org-left">C  C::operator++(int)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Prefix decrement</td>
<td class="org-left">&#x2013;Object</td>
<td class="org-left">Object = Object - 1</td>
<td class="org-left">C&amp;  C::operator&#x2013;()</td>
</tr>

<tr>
<td class="org-left">Postfix decrement</td>
<td class="org-left">Object--</td>
<td class="org-left">Object = Object - 1</td>
<td class="org-left">C   C::operator&#x2013;(int)</td>
</tr>
</tbody>
</table>


<ul class="org-ul">
<li>Note: The argument is postfix operator is a dummy parameter, it is
unnused. The point of this parameter is just allow the compiler
differ between prefix and postfix operators.</li>

<li><span class="underline">Prefix operator</span>: The increment or decrement happens before the operattion
being performed on the variable.
<ul class="org-ul">
<li>Example: For an int variable set to 10, the statement
printVar(++x), will print 11, the increment happens before the
operation, then the value of x will be 11.</li>
</ul></li>

<li><span class="underline">Postfix operator</span>: The increment or decrement happens after the operation
being performed on the variable.
<ul class="org-ul">
<li>Example: For an int variable set to 10, the statement
printVar(x++), will print 10, the increment happens after the
operation, then the value of x will be 11.</li>
</ul></li>

<li>Semantics Summary: (Note &lt;- array means assignment)
<ul class="org-ul">
<li>Prefix:
<ul class="org-ul">
<li>x = ++y; Means y &lt;- y + 1 and x &lt;- y</li>
<li>x = &#x2013;y; Means y &lt;- y - 1 and x &lt;- y</li>
</ul></li>
<li>Postfix:
<ul class="org-ul">
<li>x = y++; Means x &lt;- y and y &lt;- y + 1</li>
<li>x = y&#x2013;; Means x &lt;- y and y &lt;- y - 1</li>
</ul></li>
</ul></li>
</ul>

<p>
<b>Assignment Operators</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 6:</span> Assignment operator overloading</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Expansion</th>
<th scope="col" class="org-left">Member function signature</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">for class C and RHS type R</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Assignment</td>
<td class="org-left">LHS = RSH</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">C&amp; C::operator= (const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left"><b>Copy-assignment operator</b></td>
<td class="org-left">LHS = RSH</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">C&amp; C::operator= (const C&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Assignment sum</td>
<td class="org-left">LHS += RHS</td>
<td class="org-left">LHS = LHS + RHS</td>
<td class="org-left">C C::operator+=(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Assignment subtraction (aka difference)</td>
<td class="org-left">LHS -= RHS</td>
<td class="org-left">LHS = LHS - RHS</td>
<td class="org-left">C C::operator=-(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Assignment product (multiplication)</td>
<td class="org-left">LHS *= RHS</td>
<td class="org-left">LHS = LHS * RHS</td>
<td class="org-left">C C::operator*=(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Assignment division</td>
<td class="org-left">LSH /= RHS</td>
<td class="org-left">LHS = LHS / RHS</td>
<td class="org-left">C C::operator/=(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Assignment remainder</td>
<td class="org-left">LHS %= RHS</td>
<td class="org-left">LHS = LHS % RHS</td>
<td class="org-left">C C::operator%=(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Assignment bitwise AND</td>
<td class="org-left">LHS &amp;= RHS</td>
<td class="org-left">LHS = LHS &amp; RHS</td>
<td class="org-left">C C::operator&amp;=(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Assignment bitwise OR</td>
<td class="org-left">LHS &vert;= RHS</td>
<td class="org-left">LHS = LHS &vert; RHS</td>
<td class="org-left">C C::operator&vert;=(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Assignment bitwise exclusive OR (XOR)</td>
<td class="org-left">LHS ^= RHS</td>
<td class="org-left">LHS = LHS ^ RHS</td>
<td class="org-left">C C::operator^=(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Assignment left shift</td>
<td class="org-left">LHS &lt;&lt;= RHS</td>
<td class="org-left">LHS = LHS &lt;&lt; RHS</td>
<td class="org-left">C C::operator&lt;&lt;=(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Assignment right shift</td>
<td class="org-left">LHS &gt;&gt;= RHS</td>
<td class="org-left">LHS = LHS &gt;&gt; RHS</td>
<td class="org-left">C C::operator&gt;&gt;=(const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>


<p>
<b>Function-Call Operators</b>
</p>

<p>
Function-call operators allow objects to be called as they were
functions and define "functors" - function-objects.
</p>

<ul class="org-ul">
<li>Note: The operator is '()' parenthesis.</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 7:</span> Function call operator overloading - "functors"</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Operator Usage</th>
<th scope="col" class="org-left">Member function signature for class C and RHS type R</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">RHS x = Object()</td>
<td class="org-left">R C::operator()()</td>
</tr>

<tr>
<td class="org-left">int a = Object("hello world")</td>
<td class="org-left">int C::operator()(const char* text)</td>
</tr>

<tr>
<td class="org-left">std::string text = AnObject(count)</td>
<td class="org-left">std::string C::operator()(std::size_t count)</td>
</tr>

<tr>
<td class="org-left">RHS result = Object(x, y, text)</td>
<td class="org-left">RHS C::operator() (int x, double y, char const* text)</td>
</tr>
</tbody>
</table>


<p>
<b>Pointer Operarators</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 8:</span> Pointer operator overloading.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Usage</th>
<th scope="col" class="org-left">Member function signature</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">for class C and RHS type R</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Subscript, array index</td>
<td class="org-left">[]</td>
<td class="org-left">Object[Index]</td>
<td class="org-left">X C::operator[] (const Index&amp; index)</td>
</tr>

<tr>
<td class="org-left">Indirection - deference</td>
<td class="org-left">*</td>
<td class="org-left">*Object</td>
<td class="org-left">X&amp; C::operator*()</td>
</tr>

<tr>
<td class="org-left">Indirection - deference</td>
<td class="org-left">*</td>
<td class="org-left">*Object</td>
<td class="org-left">X&amp; C::operator*()  const</td>
</tr>

<tr>
<td class="org-left">Class member access or dereference operator</td>
<td class="org-left">-&gt;</td>
<td class="org-left">pointerToOjbect-&gt;Member()</td>
<td class="org-left">X* C::operator-&gt;()</td>
</tr>

<tr>
<td class="org-left">Class member access or dereference operator</td>
<td class="org-left">-&gt;</td>
<td class="org-left">pointerToOjbect-&gt;Member()</td>
<td class="org-left">X* C::operator-&gt;()  const</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Address or reference</td>
<td class="org-left">&amp;</td>
<td class="org-left">&amp;Object</td>
<td class="org-left">X* C::operator&amp;()</td>
</tr>

<tr>
<td class="org-left">Heap allocation - single object</td>
<td class="org-left">new</td>
<td class="org-left">C* ptr = new C;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Heap allocation - array</td>
<td class="org-left">new []</td>
<td class="org-left">C* ptr = new C[10];</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Delete operator</td>
<td class="org-left">delete</td>
<td class="org-left">delete ptr;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Delete array operator</td>
<td class="org-left">delete []</td>
<td class="org-left">delete [] ptr;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Note:
<ul class="org-ul">
<li>The overloading of operators (*) and (-&gt;) is useful for implementing smart pointers.</li>
<li>The overloading of operators new and delete can be used for
implementing custom allocators.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org2c3722e" class="outline-4">
<h4 id="org2c3722e"><span class="section-number-4">1.21.7</span> Free function operator overloading tables reference card</h4>
<div class="outline-text-4" id="text-1-21-7">
<p>
Note: The following operators cannot be overloaded by non-member
functions, in other words, they cannot be free functions.
</p>

<ul class="org-ul">
<li>=   - assignment operator</li>
<li>[]  - array index</li>
<li>()  - Function-call operator</li>
<li>-&gt;  - Deference operator</li>
</ul>

<p>
<b>Arithmetic Operators</b> 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 9:</span> Free-function arithmetic operator overloading</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Operator function signature</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Addition</td>
<td class="org-left">LHS + RHS</td>
<td class="org-left">LHS operator+(const LHS&amp;, const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Subtraction</td>
<td class="org-left">LHS - RHS</td>
<td class="org-left">LHS operator-(const LHS&amp;, const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Multiplication</td>
<td class="org-left">LHS * RHS</td>
<td class="org-left">LHS operator*(const LHS&amp;, const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Division</td>
<td class="org-left">LSH / RHS</td>
<td class="org-left">LHS operator/(const LHS&amp;, const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Remainder</td>
<td class="org-left">LSH % RHS</td>
<td class="org-left">LHS operator%(const LHS&amp;, const RHS&amp; rhs)</td>
</tr>
</tbody>
</table>


<ul class="org-ul">
<li>C: Class that the operator belongs to.</li>
<li>LHS - Left-hand-side type</li>
<li>RHS - Right-hand-side type or class (a class is also a type)</li>
</ul>

<p>
<b>Comparison Operators</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 10:</span> Free-function comparison operator overloading</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Operator function signature</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Equal</td>
<td class="org-left">LHS == RHS</td>
<td class="org-left">bool operator==(const LHS&amp;, const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Not equal</td>
<td class="org-left">LHS != RHS</td>
<td class="org-left">bool operator-(const LHS&amp;, const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Greater than</td>
<td class="org-left">LHS &gt;  RHS</td>
<td class="org-left">bool operator&gt;(const LHS&amp;, const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Greater or equal than</td>
<td class="org-left">LHS &gt;= RHS</td>
<td class="org-left">bool operator&gt;=(const LHS&amp;, const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Less than</td>
<td class="org-left">LHS &lt;  RHS</td>
<td class="org-left">bool operator&lt;(const LHS&amp;, const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Less or equal than</td>
<td class="org-left">LHS &lt;= RHS</td>
<td class="org-left">bool operator&lt;=(const LHS&amp;, const RHS&amp; rhs)</td>
</tr>
</tbody>
</table>


<p>
<b>Prefix/Postfix - Increment / Decrement</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 11:</span> Free-function prefix and postfix increment/decrement operator overloading</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Expansion</th>
<th scope="col" class="org-left">Operator function signature</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Prefix increment</td>
<td class="org-left">++Object</td>
<td class="org-left">Object = Object + 1</td>
<td class="org-left">LHS&amp; operator++(LHS&amp; lhs)</td>
</tr>

<tr>
<td class="org-left">Postfix increment</td>
<td class="org-left">Object++</td>
<td class="org-left">Object = Object + 1</td>
<td class="org-left">LHS  operator++(LSH&amp; lhs, int dummy)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Prefix decrement</td>
<td class="org-left">&#x2013;Object</td>
<td class="org-left">Object = Object - 1</td>
<td class="org-left">LHS&amp; operator&#x2013;(LHS&amp; lhs)</td>
</tr>

<tr>
<td class="org-left">Postfix decrement</td>
<td class="org-left">Object--</td>
<td class="org-left">Object = Object - 1</td>
<td class="org-left">LHS  operator&#x2013;(LHS&amp;,int dummy)</td>
</tr>
</tbody>
</table>

<p>
<b>Insertion / Extraction operators</b> 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 12:</span> Free-function stream insertion/extraction operator overloading</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Operator</th>
<th scope="col" class="org-left">Operator function signature</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Insertion operator  (&lt;&lt;)</td>
<td class="org-left">OS &lt;&lt; Object;</td>
<td class="org-left">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Insertion operator  (&lt;&lt;) [C++11]</td>
<td class="org-left">OS &lt;&lt; Object;</td>
<td class="org-left">auto operator&lt;&lt;(std::ostream&amp; os, const RHS&amp; rhs) -&gt; std::ostream&amp;</td>
</tr>

<tr>
<td class="org-left">Extraction operator (&gt;&gt;)</td>
<td class="org-left">IS &gt;&gt; Object;</td>
<td class="org-left">std::istream&amp; operator&gt;&gt;(std::istream&amp; os, RHS&amp; rhs)</td>
</tr>

<tr>
<td class="org-left">Extraction operator (&gt;&gt;) [C++11]</td>
<td class="org-left">IS &gt;&gt; Object;</td>
<td class="org-left">auto operator&gt;&gt;(std::istream&amp; os, RHS&amp; rhs) -&gt; std::istream&amp;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>OS: Output stream: derived class of std::ostream (std::cout,
std::cerr, std::stringstream &#x2026;)</li>

<li>IS: Inoput stream: derived clas sof std::istream (std::cin,
std::ifstream, std::stringstream &#x2026;)</li>

<li>Object: An instance of the class or type RHS (Right-hand side).</li>

<li>Insertion operator (&lt;&lt;)
<ul class="org-ul">
<li>Insert or write object to output stream.</li>
</ul></li>

<li>Extraction operator (&gt;&gt;)
<ul class="org-ul">
<li>Extract or read object from input stream.</li>
</ul></li>
</ul>

<p>
Calling the operator (&lt;&lt;) explicitly:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [1] Hello world C++"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
 <span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span> Hello world C++

&gt;&gt; <span class="org-keyword">operator</span>&lt;&lt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cout, <span class="org-string">" [2] Hello world C++\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-rainbow-delimiters-depth-1">]</span> Hello world C++

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [3] Hello world C++"</span> &lt;&lt; <span class="org-string">"\n [3] This is a new line.\n"</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> Hello world C++
 <span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> This is a <span class="org-keyword">new</span> <span class="org-type">line</span>.
&gt;&gt; 

&gt;&gt; <span class="org-keyword">operator</span>&lt;&lt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">operator</span>&lt;&lt;<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cout, <span class="org-string">" [3] Hello world C++"</span><span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-string">"\n [3] This is a new line.\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> Hello world C++
 <span class="org-rainbow-delimiters-depth-1">[</span>3<span class="org-rainbow-delimiters-depth-1">]</span> This is a <span class="org-keyword">new</span> <span class="org-type">line</span>.

 <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-constant">std</span>::ostream&amp; printStream<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-type">T</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">object</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">return</span> os &lt;&lt; object;
 <span class="org-rainbow-delimiters-depth-1">}</span>

 &gt;&gt; printStream<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cout, <span class="org-string">"hello world\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-type">hello</span> <span class="org-variable-name">world</span>

 &gt;&gt; printStream<span class="org-rainbow-delimiters-depth-1">(</span>printStream<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cout, <span class="org-string">"hello world\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-string">" A new line\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-type">hello</span> <span class="org-type">world</span>
  <span class="org-variable-name">A</span> <span class="org-keyword">new</span> <span class="org-type">line</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org34962a0" class="outline-4">
<h4 id="org34962a0"><span class="section-number-4">1.21.8</span> References</h4>
<div class="outline-text-4" id="text-1-21-8">
<p>
<b>C++ ISO Standard - Language Specification:</b>
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/operator_incdec">Increment/decrement operators</a></li>

<li>Overloading - <a href="http://eel.is/c++draft/over.oper">http://eel.is/c++draft/over.oper</a></li>

<li><a href="https://isocpp.org/wiki/faq/operator-overloading">https://isocpp.org/wiki/faq/operator-overloading</a></li>
</ul>

<p>
<b>Further Reading</b> 
</p>

<ul class="org-ul">
<li><a href="http://www.modernescpp.com/index.php/c-core-guidelines-rules-for-overloading-and-overload-operators">C++ Core Guidelines: Rules for Overloading and Overload Operators</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org740023d" class="outline-3">
<h3 id="org740023d"><span class="section-number-3">1.22</span> <span class="todo TODO">TODO</span> OOP Multiple Inheritance</h3>
<div class="outline-text-3" id="text-1-22">
</div>
<div id="outline-container-org3e7962f" class="outline-4">
<h4 id="org3e7962f"><span class="section-number-4">1.22.1</span> Ambiguity resolution</h4>
<div class="outline-text-4" id="text-1-22-1">
<p>
This example shows how to solve multiple inheritacne ambiguity
problems in C++ when a derived class inherits more than two base
classes containing member variables and member functions with same
name. 
</p>


<p>
File: <a href="src/inheritance-multiple-ambiguity.cpp">file:src/inheritance-multiple-ambiguity.cpp</a>
</p>


<ul class="org-ul">
<li>Base class BaseA:</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>class BaseA label:code-baseA-class</label><pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">BaseA</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">protected</span>:
     <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">key</span> = <span class="org-string">"KEY-BASEA"</span>;
<span class="org-function-name">public</span>: 

     <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">_name</span>;

     <span class="org-function-name">BaseA</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">_name</span><span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [LOG] BaseA instantiated. OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">A base class always needs virtual constructor in order to avoid memory leaks.</span>
     <span class="org-keyword">virtual</span> ~<span class="org-function-name">BaseA</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;

     <span class="org-type">void</span> <span class="org-function-name">printName</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" A - [printName] =&gt; Name = "</span> &lt;&lt; _name &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>  
     <span class="org-type">void</span> <span class="org-function-name">printNameA</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [printNameA] =&gt; NameA = "</span> &lt;&lt; _name &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-type">void</span> <span class="org-function-name">callOverridenVFun</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [BaseB::callOverridenVFun] BaseB::overridenVfun() returned"</span>
                  &lt;&lt; <span class="org-string">'\n'</span> &lt;&lt; <span class="org-string">" +=&gt; RETURN = "</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;overridenVfun<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">overridenVfun</span><span class="org-rainbow-delimiters-depth-2">()</span> = 0;   

     <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">nonOverridenVfun</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-keyword">return</span> <span class="org-string">"BaseA::nonOverridenVfun"</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>

     <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">specificAVFun</span><span class="org-rainbow-delimiters-depth-2">(){</span>
       <span class="org-keyword">return</span> <span class="org-string">"specificAVFun not overriden."</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>

     <span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">staticMethod</span><span class="org-rainbow-delimiters-depth-2">(){</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [BaseA] I am a static method from BaseA"</span> &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>  
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Base class BaseB</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">BaseB</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Only derived classes can access </span>
<span class="org-function-name">protected</span>: 
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">key</span> = <span class="org-string">"KEY-BASEB"</span>;

   <span class="org-comment-delimiter">// </span><span class="org-comment">Derived classes and any external code can access  </span>
<span class="org-function-name">public</span>:    
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">_name</span>;

    <span class="org-function-name">BaseB</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">_name</span><span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [LOG] BaseB instantiated. OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">virtual</span> ~<span class="org-function-name">BaseB</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;

    <span class="org-type">void</span> <span class="org-function-name">printName</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" B - [printName] =&gt; Name = "</span> &lt;&lt; _name &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">printNameB</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [PrintName] =&gt; NameB = "</span> &lt;&lt; _name &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">callOverridenVFun</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [BaseB::callOverridenVFun] BaseB::overridenVfun() returned"</span>
                  &lt;&lt; <span class="org-string">'\n'</span> &lt;&lt; <span class="org-string">" +=&gt; RETURN = "</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;overridenVfun<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">overridenVfun</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-keyword">return</span> <span class="org-string">" BaseB::overridenVfun not overriden"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>   
    <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">nonOverridenVfun</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-keyword">return</span> <span class="org-string">"BaseB::nonOverridenVfun"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">specificBVFun</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-keyword">return</span> <span class="org-string">"specificBVFun not overriden."</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">staticMethod</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [BaseB] I am a static method from BaseB"</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>


<ul class="org-ul">
<li>Class DerivedD - inherits both class BaseA and BaseB.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Derived</span>: <span class="org-keyword">public</span> <span class="org-type">BaseA</span>, <span class="org-keyword">public</span> <span class="org-type">BaseB</span><span class="org-rainbow-delimiters-depth-1">{</span>  
<span class="org-function-name">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">Base class constructos must always be initialized through</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">initialization list like this.</span>
    <span class="org-function-name">Derived</span><span class="org-rainbow-delimiters-depth-2">()</span>
      : BaseA<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"nameA"</span><span class="org-rainbow-delimiters-depth-2">)</span>, BaseB<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"nameB"</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>       
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-function-name">Derived</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">nameA</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">nameB</span><span class="org-rainbow-delimiters-depth-2">)</span>
      : BaseA<span class="org-rainbow-delimiters-depth-2">(</span>nameA<span class="org-rainbow-delimiters-depth-2">)</span>, BaseB<span class="org-rainbow-delimiters-depth-2">(</span>nameB<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>       
    <span class="org-rainbow-delimiters-depth-2">}</span>
    ~<span class="org-function-name">Derived</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [Derived] Destructor called. "</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Access ambiguous protected field from base class </span>
    <span class="org-type">void</span> <span class="org-function-name">showKeyBaseA</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [showKeyBaseA] Key-BaseA = "</span> &lt;&lt; <span class="org-constant">BaseA</span>::key &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [showKeyBaseA] Key-BaseA = "</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;<span class="org-constant">BaseA</span>::key &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">showKeyBaseB</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [showKeyBaseB] Key-BaseB = "</span> &lt;&lt; <span class="org-constant">BaseB</span>::key &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [showKeyBaseB] Key-BaseB = "</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;<span class="org-constant">BaseB</span>::key &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">printNameX</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">BaseA</span>::printName<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Or 'this' pointer can be used too.</span>
        <span class="org-keyword">this</span>-&gt;<span class="org-constant">BaseB</span>::printName<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

  <span class="org-comment-delimiter">/* </span><span class="org-comment">The derived class overrides both virtual member functions, BaseA::overridenVfun()</span>
<span class="org-comment">    * and BaseB::overridenVfun(). As a result, both base classes will share the derived class </span>
<span class="org-comment">    * implementation.</span>
<span class="org-comment">    */</span>
<span class="org-preprocessor">    #if</span> <span class="org-constant">true</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">overridenVfun</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
         <span class="org-keyword">return</span> <span class="org-string">"Both functions overriden, BaseA::overridenVfun() and BaseB::overridenVfun(). OK."</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-preprocessor">    #endif</span> 

    <span class="org-comment-delimiter">// </span><span class="org-comment">std::string specificAVFun() override {</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">specificAVFun</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span><span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-string">"Overriden: specificAVFun"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">specificBVFun</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-string">"Overriden: specificBVFun"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">staticMethod</span><span class="org-rainbow-delimiters-depth-2">(){</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [Derived] I am a static method from Derived"</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Loading the code in ROOT REPL: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .L inheritance-multiple-ambiguity.cpp 
</pre>
</div>

<p>
Creating an instance of derived class named Derived.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; Derived d;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">LOG</span><span class="org-rainbow-delimiters-depth-1">]</span> BaseA instantiated. OK.
 <span class="org-rainbow-delimiters-depth-1">[</span>LOG<span class="org-rainbow-delimiters-depth-1">]</span> BaseB instantiated. OK.
&gt;&gt; 
</pre>
</div>

<p>
<b>Access ambiguous publi field</b>
</p>

<ul class="org-ul">
<li>Problem:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">FAILURE - Compilation error: </span>
&gt;&gt; d._name
<span class="org-function-name">ROOT_prompt_2</span>:1:3: error: member <span class="org-warning">'</span>_name<span class="org-warning">'</span> found in multiple base classes of different types
d._name
  ^
<span class="org-function-name">inheritance-multiple-ambiguity.cpp</span>:12:14: note: member found by ambiguous name lookup
        <span class="org-constant">std</span>::string _name;
                    ^
<span class="org-function-name">inheritance-multiple-ambiguity.cpp</span>:53:14: note: member found by ambiguous name lookup
        <span class="org-constant">std</span>::string _name;
</pre>
</div>

<ul class="org-ul">
<li>Solution: Use fully qualified field name. <code>d.BaseA::_name</code> or
<code>d.BaseB::_name</code>. Or upcast pointer from derived to pointer to base class.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-comment-delimiter">// </span><span class="org-comment">SOLUTION: </span>
&gt;&gt; d.<span class="org-constant">BaseA</span>::_name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"nameA"</span>

&gt;&gt; d.<span class="org-constant">BaseB</span>::_name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"nameB"</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Pointer to derived </span>
&gt;&gt; Derived* ptr_derived = &amp;d;

&gt;&gt; ptr_derived-&gt;<span class="org-constant">BaseA</span>::_name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"nameA"</span>

&gt;&gt; ptr_derived-&gt;<span class="org-constant">BaseB</span>::_name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"nameB"</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Access/refer by pointer - BaseA</span>
&gt;&gt; BaseA* ptr_baseA = &amp;d;

&gt;&gt; ptr_baseA-&gt;_name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"nameA"</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Access/refer by pointer - BaseB</span>
&gt;&gt; BaseB* ptr_baseB = &amp;d;

&gt;&gt; ptr_baseB-&gt;_name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"nameB"</span>
</pre>
</div>

<p>
<b>Call non-ambiguous methods</b> 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; d.printNameA<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>printNameA<span class="org-rainbow-delimiters-depth-1">]</span> =&gt; NameA = nameA
<span class="org-comment-delimiter">// </span><span class="org-comment">OR:</span>
&gt;&gt; d.<span class="org-constant">BaseA</span>::printNameA<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>printNameA<span class="org-rainbow-delimiters-depth-1">]</span> =&gt; NameA = nameA

&gt;&gt; d.printNameB<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>PrintName<span class="org-rainbow-delimiters-depth-1">]</span> =&gt; NameB = nameB

<span class="org-comment-delimiter">// </span><span class="org-comment">OR</span>
&gt;&gt; d.<span class="org-constant">BaseA</span>::printNameA<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>printNameA<span class="org-rainbow-delimiters-depth-1">]</span> =&gt; NameA = nameA

</pre>
</div>

<p>
<b>Call ambiguous method printName:</b>
</p>

<ul class="org-ul">
<li>Problem:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">COMPILATION ERROR:</span>
&gt;&gt; d.printName<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-function-name">ROOT_prompt_5</span>:1:3: error: member <span class="org-warning">'</span>printName<span class="org-warning">'</span> found in multiple base classes of different types
d.printName<span class="org-rainbow-delimiters-depth-1">()</span>
  ^
<span class="org-function-name">inheritance-multiple-ambiguity.cpp</span>:20:7: note: member found by ambiguous name lookup
        <span class="org-type">void</span> printName<span class="org-rainbow-delimiters-depth-1">(){</span>
             ^
<span class="org-function-name">inheritance-multiple-ambiguity.cpp</span>:61:7: note: member found by ambiguous name lookup
        <span class="org-type">void</span> printName<span class="org-rainbow-delimiters-depth-2">(){</span>
             ^
</pre>
</div>

<ul class="org-ul">
<li>Solution:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; d.<span class="org-constant">BaseA</span>::printName<span class="org-rainbow-delimiters-depth-1">()</span>
 A - <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">printName</span><span class="org-rainbow-delimiters-depth-1">]</span> =&gt; Name = nameA

&gt;&gt; d.<span class="org-constant">BaseB</span>::printName<span class="org-rainbow-delimiters-depth-1">()</span>
 B - <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">printName</span><span class="org-rainbow-delimiters-depth-1">]</span> =&gt; Name = nameB
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Access/refer by pointer - BaseA</span>
&gt;&gt; BaseA* ptr_baseA = &amp;d;

&gt;&gt; ptr_baseA-&gt;printName<span class="org-rainbow-delimiters-depth-1">()</span>
 A - <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">printName</span><span class="org-rainbow-delimiters-depth-1">]</span> =&gt; Name = nameA

&gt;&gt; ptr_baseA-&gt;_name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"nameA"</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Access/refer by pointer - BaseA</span>
&gt;&gt; BaseB* ptr_baseB = &amp;d;

&gt;&gt; ptr_baseB-&gt;printName<span class="org-rainbow-delimiters-depth-1">()</span>
 B - <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">printName</span><span class="org-rainbow-delimiters-depth-1">]</span> =&gt; Name = nameB

&gt;&gt; ptr_baseB-&gt;_name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"nameB"</span>
&gt;&gt; 

</pre>
</div>

<p>
<b>Invoke Overriden Virtual Function</b> 
</p>

<ul class="org-ul">
<li>If a base class overrides a virtual member function required by
multiple base classes, all of them will share the same
implementation supplied by the derived class. There is no way to
override or supply a different implementations to each one of them
in the derived class.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; d.overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Both functions overriden, BaseA::overridenVfun() and BaseB::overridenVfun(). OK."</span>
&gt;&gt; 

&gt;&gt; d.<span class="org-constant">BaseB</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">" BaseB::overridenVfun not overriden"</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Access/refer by pointer - BaseA</span>
&gt;&gt; BaseA* ptr_baseA = &amp;d;

&gt;&gt; ptr_baseA-&gt;overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Both functions overriden, BaseA::overridenVfun() and BaseB::overridenVfun(). OK."</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Access/refer by pointer - BaseB</span>
&gt;&gt; BaseB* ptr_baseB = &amp;d;

&gt;&gt; ptr_baseB-&gt;overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Both functions overriden, BaseA::overridenVfun() and BaseB::overridenVfun(). OK."</span>
&gt;&gt; 
</pre>
</div>

<p>
<b>Invoke method callOverridenVFun</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Compilation error: </span>
&gt;&gt; d.callOverridenVFun<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-function-name">ROOT_prompt_19</span>:1:3: error: member <span class="org-warning">'</span>callOverridenVFun<span class="org-warning">'</span> found in multiple base classes of different types
d.callOverridenVFun<span class="org-rainbow-delimiters-depth-1">()</span>

&gt;&gt; d.<span class="org-constant">BaseA</span>::callOverridenVFun<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">BaseB</span>::callOverridenVFun<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-constant">BaseB</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span> returned
 +=&gt; RETURN = Both functions overriden, <span class="org-constant">BaseA</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">and</span> <span class="org-constant">BaseB</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>. OK.

&gt;&gt; d.<span class="org-constant">BaseB</span>::callOverridenVFun<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">BaseB</span>::callOverridenVFun<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-constant">BaseB</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span> returned
 +=&gt; RETURN = Both functions overriden, <span class="org-constant">BaseA</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">and</span> <span class="org-constant">BaseB</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>. OK.
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Access/refer by pointer - BaseA</span>
&gt;&gt; BaseA* ptr_baseA = &amp;d;

<span class="org-comment-delimiter">// </span><span class="org-comment">No ambiguity happens </span>
&gt;&gt; ptr_baseA-&gt;callOverridenVFun<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">BaseB</span>::callOverridenVFun<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-constant">BaseB</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span> returned
 +=&gt; RETURN = Both functions overriden, <span class="org-constant">BaseA</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">and</span> <span class="org-constant">BaseB</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>. OK.
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Access/refer by pointer - BaseB</span>
&gt;&gt; BaseB* ptr_baseB = &amp;d;

&gt;&gt; ptr_baseB-&gt;callOverridenVFun<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">BaseB</span>::callOverridenVFun<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-constant">BaseB</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span> returned
 +=&gt; RETURN = Both functions overriden, <span class="org-constant">BaseA</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">and</span> <span class="org-constant">BaseB</span>::overridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>. OK.
</pre>
</div>

<p>
Call functions showKeyBaseA and showKeyBaseB:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; d.showKeyBaseA<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>showKeyBaseA<span class="org-rainbow-delimiters-depth-1">]</span> Key-BaseA = KEY-BASEA
 <span class="org-rainbow-delimiters-depth-1">[</span>showKeyBaseA<span class="org-rainbow-delimiters-depth-1">]</span> Key-BaseA = KEY-BASEA
&gt;&gt; 
&gt;&gt; d.showKeyBaseB<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>showKeyBaseB<span class="org-rainbow-delimiters-depth-1">]</span> Key-BaseB = KEY-BASEB
 <span class="org-rainbow-delimiters-depth-1">[</span>showKeyBaseB<span class="org-rainbow-delimiters-depth-1">]</span> Key-BaseB = KEY-BASEB
&gt;&gt; 
</pre>
</div>

<p>
Invoke a non-overriden ambiguous virtual function.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; d.nonOverridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-function-name">ROOT_prompt_40</span>:1:3: error: member <span class="org-warning">'</span>nonOverridenVfun<span class="org-warning">'</span> found in multiple base classes of different types
d.nonOverridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>
  ^

&gt;&gt; d.<span class="org-constant">BaseA</span>::nonOverridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"BaseA::nonOverridenVfun"</span>
&gt;&gt; 

&gt;&gt; d.<span class="org-constant">BaseB</span>::nonOverridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"BaseB::nonOverridenVfun"</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Pointer to derived </span>
&gt;&gt; Derived* ptr_derived = &amp;d;

&gt;&gt; ptr_derived-&gt;<span class="org-constant">BaseA</span>::nonOverridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"BaseA::nonOverridenVfun"</span>
&gt;&gt; 
&gt;&gt; ptr_derived-&gt;<span class="org-constant">BaseB</span>::nonOverridenVfun<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"BaseB::nonOverridenVfun"</span>
&gt;&gt; 
</pre>
</div>

<p>
Call static methods:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">BaseA</span>::staticMethod<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>BaseA<span class="org-rainbow-delimiters-depth-1">]</span> I am a <span class="org-keyword">static</span> method from BaseA

&gt;&gt; <span class="org-constant">BaseB</span>::staticMethod<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>BaseB<span class="org-rainbow-delimiters-depth-1">]</span> I am a <span class="org-keyword">static</span> method from BaseB

&gt;&gt; <span class="org-constant">Derived</span>::staticMethod<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>Derived<span class="org-rainbow-delimiters-depth-1">]</span> I am a <span class="org-keyword">static</span> method from Derived
&gt;&gt;

&gt;&gt; d.staticMethod<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>Derived<span class="org-rainbow-delimiters-depth-1">]</span> I am a <span class="org-keyword">static</span> method from Derived
&gt;&gt; 

&gt;&gt; d.<span class="org-constant">BaseA</span>::staticMethod<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>BaseA<span class="org-rainbow-delimiters-depth-1">]</span> I am a <span class="org-keyword">static</span> method from BaseA

&gt;&gt; d.<span class="org-constant">BaseB</span>::staticMethod<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>BaseB<span class="org-rainbow-delimiters-depth-1">]</span> I am a <span class="org-keyword">static</span> method from BaseB
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Pointer to derived </span>
&gt;&gt; Derived* ptr_derived = &amp;d;

&gt;&gt; ptr_derived-&gt;staticMethod<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>Derived<span class="org-rainbow-delimiters-depth-1">]</span> I am a <span class="org-keyword">static</span> method from Derived
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Access/refer by pointer - BaseA</span>
&gt;&gt; BaseA* ptr_baseA = &amp;d;

<span class="org-comment-delimiter">// </span><span class="org-comment">Access/refer by pointer - BaseB</span>
&gt;&gt; BaseA* ptr_baseB = &amp;d;

&gt;&gt; ptr_baseA-&gt;staticMethod<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>BaseA<span class="org-rainbow-delimiters-depth-1">]</span> I am a <span class="org-keyword">static</span> method from BaseA

&gt;&gt; ptr_baseB-&gt;staticMethod<span class="org-rainbow-delimiters-depth-1">()</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>BaseB<span class="org-rainbow-delimiters-depth-1">]</span> I am a <span class="org-keyword">static</span> method from BaseB
&gt;&gt; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org1c39f55" class="outline-4">
<h4 id="org1c39f55"><span class="section-number-4">1.22.2</span> <span class="todo TODO">TODO</span> OOP Diamond problem</h4>
</div>
<div id="outline-container-orgceeba86" class="outline-4">
<h4 id="orgceeba86"><span class="section-number-4">1.22.3</span> References and further reading:</h4>
<div class="outline-text-4" id="text-1-22-3">
<ul class="org-ul">
<li><a href="https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/">GotW #5 Solution: Overriding Virtual Functions | Sutter’s Mill</a></li>

<li><a href="http://www.gotw.ca/gotw/069.htm">GotW #69: Enforcing Rules for Derived Classes</a></li>

<li><a href="https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/cplr138.htm">IBM Knowledge Center - Ambiguous base classes (C++ only)</a></li>

<li><a href="https://drive.google.com/viewerng/viewer?url=https://www.cs.bgu.ac.il/~spl181/wiki.files/Lecture5_OOP.pptx">Lecture 5 - Inheritance, Polymorphism and The Object Memory Model</a></li>

<li><a href="http://www.msg.ucsf.edu/local/programs/IBM_Compilers/C:C++/html/language/ref/clrc14cplr140.htm#HDRCPLR140">Ambiguous Virtual Function Calls</a></li>

<li><a href="http://architectworkshop.com/martin/papers/separation.pdf">The Separation of Interface and Implementation in C++</a></li>

<li><a href="https://slideplayer.com/slide/10302342/">Unit IV</a></li>

<li><a href="https://drive.google.com/viewerng/viewer?url=http://www.cs.nuim.ie/~markh/paradigms/CS351Lect10.ppt">CS351 - Programming Paradigms - Inheritance and Polymorphism</a></li>

<li><a href="http://hep.ph.liv.ac.uk/~gwilliam/cppcourse/lecture8.pdf">Introduction to Programming using C++</a></li>

<li><a href="https://softwareengineering.stackexchange.com/questions/246273/code-re-use-in-c-via-multiple-inheritance-or-composition-or">interfaces - Code re-use in C++, via multiple inheritance or composition? Or&#x2026;? - Software Engineering Stack Exchange</a></li>

<li><a href="https://stackoverflow.com/questions/18529277/overriding-functions-from-two-abstract-base-classes-that-differ-only-by-their">c++ - Overriding functions (from two abstract base classes) that differ only by their return value - Stack Overflow</a></li>

<li><a href="https://stackoverflow.com/questions/18398409/c-inherit-from-multiple-base-classes-with-the-same-virtual-function-name">C++ inherit from multiple base classes with the same virtual function name - Stack Overflow</a></li>

<li><a href="https://stackoverflow.com/questions/28556872/ambiguous-inheritance-of-function-when-multiple-inheritance-of-classes-that-them">c++ - Ambiguous inheritance of function when multiple inheritance of classes that themselves have diamond inheritance in their hierarchy - Stack Overflow</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8c71d55" class="outline-3">
<h3 id="org8c71d55"><span class="section-number-3">1.23</span> Type Casting / Type Conversion</h3>
<div class="outline-text-3" id="text-1-23">
</div>
<div id="outline-container-orga0af697" class="outline-4">
<h4 id="orga0af697"><span class="section-number-4">1.23.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-23-1">
<p>
In addition to the old C-style castiung, C++ supports new casting
operators which are more type-safe and make the program's intent
explicit, thus enhancing the readability and maintanability. 
</p>

<p>
<b>C-style Casting</b>
</p>

<ul class="org-ul">
<li>(NEW-TYPE) &lt;EXPRESSION&gt;</li>
<li>Note: should be avoided.</li>
<li>Example:
<ul class="org-ul">
<li>char x = (char) 65;</li>
</ul></li>
</ul>

<p>
<b>C++ Sytle-Casting</b>
</p>

<ul class="org-ul">
<li><code>static_cast&lt;TYPE&gt;(EXPR)</code>
<ul class="org-ul">
<li>Use-case: implicity type conversion of related types, conversion
of base class to derived class, void* pointer to othe pointer
(except function pointer.). static_cast is the most used C++
casting operator.</li>
<li>When happens: this casting is performed at compile-time.</li>
<li>Can:
<ul class="org-ul">
<li>Convert between related types such as char to int, int to
double,</li>
<li>Convert from and to void* pointer to other pointers: void* to
double*, double* to void* and so on.</li>
<li>Convert base class to derived class (downcasting).</li>
</ul></li>
<li>Cannot:
<ul class="org-ul">
<li>Convert between unrelated types such as <span class="underline">unsigned long</span> to <span class="underline">double*</span>.</li>
<li>Convert between pointers of unrelated types, for instance int*
to double* or unsigned long to double*.</li>
</ul></li>
</ul></li>

<li><code>reinterpret_cast&lt;TYPE&gt;(EXPR);</code>
<ul class="org-ul">
<li>Use-cases: This is a dangerous low level casting used for
converting unrelated types. WARNING: failed conversion can
result in segmentation fault, core dump and subtle crashing use
with care. 
<ul class="org-ul">
<li>Converting pointers of unrelated types such as double* to int*</li>
<li>Convert void* to function pointer.
<ul class="org-ul">
<li>Loading C-functions from shared libraries (.DLL files on
Windows or .SO on U-nix, Linux, BSD, OSX &#x2026;)</li>
<li>Implement type erasure of function-pointers for reflection
libraries.</li>
</ul></li>
<li>Access hardware registers of Embedded Systems (_memory mapped_
<span class="underline">IO</span>). Many embedded systems such as microcontrollers have
memory mapped-IO which are hardware devices like Analog to
Digital Convertes, digital Input/Output ports bound to
specific memory addresses assigned by the manufacturer. By
writing to those memory locations, it is possible to
configure, control and read data from hardware
devices. <code>reinterpret_cast</code> can be used for converting the
numerical address given in usigned hexadecimal to some pointer
of type int*, char*, double* and so on.</li>
</ul></li>
</ul></li>

<li><code>dynamic_cast&lt;TYPE&gt;(EXPR);</code>
<ul class="org-ul">
<li>Use cases: Casting for polymorphic types, class hierachies for
identifying at runtime instances of derived classes. This is
part of the C++ RTTI - Runtime Type Identification.</li>
<li>When happens: this casting is performed at run-time.</li>
</ul></li>

<li><code>const_cast&lt;TYPE&gt;(EXPR);</code>
<ul class="org-ul">
<li>Use-case: Create non-const reference to const variable, so it
can bypass the const constraint.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org34b357a" class="outline-4">
<h4 id="org34b357a"><span class="section-number-4">1.23.2</span> Example: Old C-Style Casting:</h4>
<div class="outline-text-4" id="text-1-23-2">
<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">int</span> k = 10;
&gt;&gt; <span class="org-type">int</span> z = 7;

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">)</span> k
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">)</span> 10.0000f

&gt;&gt; <span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">(</span>k<span class="org-rainbow-delimiters-depth-1">)</span> / z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">)</span> 1.42857f
&gt;&gt; 

&gt;&gt; <span class="org-type">int</span> m = 65
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 65

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> m
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'A'</span>
&gt;&gt; 

&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>m+1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'B'</span>
&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>m+2<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'C'</span>
&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>m+3<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'D'</span>
&gt;&gt; <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>m+5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'F'</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-orge4672cd" class="outline-4">
<h4 id="orge4672cd"><span class="section-number-4">1.23.3</span> Example: Static Casting</h4>
<div class="outline-text-4" id="text-1-23-3">
<ul class="org-ul">
<li><b>Implicit conversion:</b></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">int</span> k = 10;
&gt;&gt; <span class="org-type">int</span> z = 7;

&gt;&gt; k / z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 1

&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>k<span class="org-rainbow-delimiters-depth-1">)</span> / z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 1.4285714

&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>k<span class="org-rainbow-delimiters-depth-1">)</span> / z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">)</span> 1.42857f
&gt;&gt; 

&gt;&gt; <span class="org-type">int</span> m = 65;
&gt;&gt; <span class="org-type">char</span> ch;
&gt;&gt; ch = m
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'A'</span>
&gt;&gt; 
<span class="org-comment-delimiter">// </span><span class="org-comment">Implicit conversion </span>
&gt;&gt; ch = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>m<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'A'</span>
&gt;&gt; ch = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>m + 1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'B'</span>
&gt;&gt; ch = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>m + 2<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'C'</span>
&gt;&gt; ch = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>m + 3<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">'D'</span>
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li><b>Pointer conversion:</b></li>
</ul>

<p>
Conversion between pointer of unrelated types is not possible with
static casting. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">
&gt;&gt; <span class="org-type">double</span> x = 10.2;
&gt;&gt; <span class="org-type">int</span> k = 10;
&gt;&gt; x

&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>&amp;x<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_5</span>:1:1: error: <span class="org-keyword">static_cast</span> from <span class="org-warning">'</span><span class="org-type">double</span> *<span class="org-warning">'</span> to <span class="org-warning">'</span><span class="org-type">int</span> *<span class="org-warning">'</span> is <span class="org-keyword">not</span> allowed
<span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>&amp;x<span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~~~~~~~~~~~~~
&gt;&gt; 


</pre>
</div>

<p>
Conversion to and from void pointer to other pointer types (except
function pointer) is possible: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">double</span> x = 10.2;
&gt;&gt; <span class="org-type">int</span> k = 10;

&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>&amp;x<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f639f3ca010
&gt;&gt; 
&gt;&gt; <span class="org-type">void</span>* ptrErased = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>&amp;x<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f639f3ca010
&gt;&gt; 
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptrErased<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f639f3ca010
&gt;&gt; *<span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptrErased<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 10.200000
&gt;&gt; 

&gt;&gt; ptrErased = &amp;k
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f639f3ca018
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptrErased<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f639f3ca018

<span class="org-comment-delimiter">// </span><span class="org-comment">However, it may fail without any notice. </span>
&gt;&gt; *<span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptrErased<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 4.9406565e-323
&gt;&gt; 

&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptrErased<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f639f3ca018
&gt;&gt; *<span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptrErased<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
&gt;&gt; 

</pre>
</div>

<p>
Conversion from number (numeric value of address) to to pointer is not
possible with static casting.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; &amp;x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f639f3ca010
&gt;&gt; 
&gt;&gt; <span class="org-type">double</span>* ptrX = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f639f3ca010<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_18</span>:1:16: error: cannot cast from type <span class="org-warning">'</span><span class="org-type">long</span><span class="org-warning">'</span> to pointer type <span class="org-warning">'</span><span class="org-type">double</span> *<span class="org-warning">'</span>
<span class="org-type">double</span>* ptrX = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f639f3ca010<span class="org-rainbow-delimiters-depth-1">)</span>
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&gt;&gt; <span class="org-type">double</span>* ptrX = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f639f3ca010UL<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_19</span>:1:16: error: cannot cast from type <span class="org-warning">'</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-warning">'</span> to pointer type <span class="org-warning">'</span><span class="org-type">double</span> *<span class="org-warning">'</span>
<span class="org-type">double</span>* ptrX = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f639f3ca010UL<span class="org-rainbow-delimiters-depth-1">)</span>
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li><b>Conversion between polymorphic types</b> / Classes from a given
hierarchy.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">cstring</span> = <span class="org-keyword">const</span> <span class="org-type">char</span>*;

<span class="org-keyword">class</span> <span class="org-type">Base</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-function-name">Base</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">Base</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
        <span class="org-keyword">virtual</span> <span class="org-type">cstring</span> <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-string">"Base"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">DerivedA</span>: <span class="org-keyword">public</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
         <span class="org-type">cstring</span> <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-string">"DerivedA"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">void</span> <span class="org-function-name">showA</span><span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Exclusive method of class A."</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">DerivedB</span>: <span class="org-keyword">public</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-type">cstring</span> <span class="org-function-name">getID</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-string">"DerivedB"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">double</span> <span class="org-function-name">method</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span>
                <span class="org-keyword">return</span> 3 * x;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">void</span> <span class="org-function-name">showB</span><span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Exclusive method of class B."</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">Base</span>     <span class="org-variable-name">b</span>;
<span class="org-type">DerivedA</span> <span class="org-variable-name">da</span>;
<span class="org-type">DerivedB</span> <span class="org-variable-name">db</span>;

<span class="org-type">Base</span>* <span class="org-variable-name">ptr</span> = <span class="org-constant">nullptr</span>;

&gt;&gt; ptr = &amp;b
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7fd81941b010
&gt;&gt; ptr-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span>cstring<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Base"</span>
&gt;&gt; 

&gt;&gt; ptr = &amp;da;
&gt;&gt; ptr-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span>cstring<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>

&gt;&gt; ptr = &amp;db;
&gt;&gt; ptr-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span>cstring<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedB"</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Downcast/Convert at compile-time pointer from the base class</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">to derived class</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">-------------------------------------------------</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Try access exclusive method:</span>
&gt;&gt; ptr = &amp;da;
&gt;&gt; ptr-&gt;showA<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-function-name">ROOT_prompt_42</span>:1:6: error: no member named <span class="org-warning">'</span>showA<span class="org-warning">'</span> in <span class="org-warning">'</span>Base<span class="org-warning">'</span>
ptr-&gt;showA<span class="org-rainbow-delimiters-depth-1">()</span>
~~~  ^

&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedA</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span>cstring<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>

&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedA</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;showA<span class="org-rainbow-delimiters-depth-1">()</span>
Exclusive method of <span class="org-keyword">class</span> <span class="org-type">A</span>.
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Note: Can result in undefined behavior!</span>
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedB</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;showB<span class="org-rainbow-delimiters-depth-1">()</span>
Exclusive method of <span class="org-keyword">class</span> <span class="org-type">B</span>.

&gt;&gt; 
&gt;&gt; ptr = &amp;db;
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedB</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;getID<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span>cstring<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedB"</span>
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedB</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;showB<span class="org-rainbow-delimiters-depth-1">()</span>
Exclusive method of <span class="org-keyword">class</span> <span class="org-type">B</span>.
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedB</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span>-&gt;method<span class="org-rainbow-delimiters-depth-1">(</span>3.0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 9.0000000
&gt;&gt; 
</pre>
</div>


<ul class="org-ul">
<li><b>Conversio from/to void</b> to function pointer is not possible.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">double</span> someFunction<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> 3.0 * x + y; <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; someFunction<span class="org-rainbow-delimiters-depth-1">(</span>3, 5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 14.000000

&gt;&gt; <span class="org-type">void</span>* ptrErasure = <span class="org-constant">nullptr</span>;

&gt;&gt; ptrErasure = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-type">someFunction</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_26</span>:1:14: error: <span class="org-keyword">static_cast</span> from <span class="org-warning">'</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-1">(</span>*<span class="org-rainbow-delimiters-depth-1">)(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span> to <span class="org-warning">'</span><span class="org-type">void</span> *<span class="org-warning">'</span> is <span class="org-keyword">not</span> allowed
ptrErasure = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>someFunction<span class="org-rainbow-delimiters-depth-1">)</span>
             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<span class="org-comment-delimiter">// </span><span class="org-comment">However, it is possible with the old C-style casting. </span>
&gt;&gt; ptrErasure = <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">)</span> &amp;someFunction
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f639f3730a0

<span class="org-comment-delimiter">// </span><span class="org-comment">Or: </span>
&gt;&gt; ptrErasure = <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-function-name">someFunction</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f639f3730a0
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">But, it works with C-style casting.</span>
&gt;&gt; <span class="org-keyword">auto</span> fnPointer2 = <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> ptrErasure
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> Function @0x7f639f3730a0
&gt;&gt; 
&gt;&gt; fnPointer2<span class="org-rainbow-delimiters-depth-1">(</span>3, 4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 13.000000
&gt;&gt; fnPointer2<span class="org-rainbow-delimiters-depth-1">(</span>5, 4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 19.000000

</pre>
</div>
</div>
</div>

<div id="outline-container-orgc58bb2c" class="outline-4">
<h4 id="orgc58bb2c"><span class="section-number-4">1.23.4</span> Example: Reinterpret Cast</h4>
<div class="outline-text-4" id="text-1-23-4">
<ul class="org-ul">
<li>Casting function/pointer from and to void*
<ul class="org-ul">
<li>Note: this is useful for type erasure and reflection and loading
functions/symbols from shared libraries at runtime.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">double</span> <span class="org-function-name">someFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> 3.0 * x + y; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">double</span> <span class="org-function-name">mfun1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> x * x + 10 * x - 25; <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span>* <span class="org-variable-name">ptrErasure</span> = <span class="org-constant">nullptr</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Testing function some function:</span>
&gt;&gt; ptrErasure = <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>&amp;someFunction<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7fe3b065a080

&gt;&gt; <span class="org-keyword">auto</span> fnPtr1 = <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptrErasure<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> Function @0x7fe3b065a080

&gt;&gt; fnPtr1<span class="org-rainbow-delimiters-depth-1">(</span>3, 5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 14.000000
&gt;&gt; fnPtr1<span class="org-rainbow-delimiters-depth-1">(</span>5, 5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 20.000000
&gt;&gt; 
&gt;&gt; <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptrErasure<span class="org-rainbow-delimiters-depth-1">)(</span>3, 5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 14.000000
&gt;&gt; <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptrErasure<span class="org-rainbow-delimiters-depth-1">)(</span>4, 5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 17.000000
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Testing with mfun</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">--&gt; C-style casting  </span>
&gt;&gt; ptrErasure = <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">)</span> mfun1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f94856da090
&gt;&gt; ptrErasure = <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">)</span> &amp;mfun1
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f94856da090
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Failed   </span>
&gt;&gt; ptrErasure = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>&amp;mfun1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_7</span>:1:14: error: <span class="org-keyword">static_cast</span> from <span class="org-warning">'</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-1">(</span>*<span class="org-rainbow-delimiters-depth-1">)(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-warning">'</span> to <span class="org-warning">'</span><span class="org-type">void</span> *<span class="org-warning">'</span> is <span class="org-keyword">not</span> allowed
ptrErasure = <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>&amp;mfun1<span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; <span class="org-keyword">auto</span> fnPtr2 = <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>mfun1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> Function @0x7f94856da090

&gt;&gt; fnPtr2<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 31.000000
&gt;&gt; fnPtr2<span class="org-rainbow-delimiters-depth-1">(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 50.000000
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">It is really dangerous as it can cast anything to anything!</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">and the compiler cannot help.    </span>
&gt;&gt; <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>4<span class="org-rainbow-delimiters-depth-1">)(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">*** Break *** segmentation violation</span>

</pre>
</div>

<ul class="org-ul">
<li>Cast address/pointer to int and print it in hexadecimal format.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; 
&gt;&gt; <span class="org-type">double</span> x;
&gt;&gt; &amp;x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7fd510b760a0
&gt;&gt; 
&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::hex &lt;&lt; <span class="org-string">"0x"</span> &lt;&lt; <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::uintptr_t<span class="org-rainbow-delimiters-depth-1">&gt;(</span>&amp;x<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::dec &lt;&lt; <span class="org-string">"\n"</span>;
0x7fd510b760a0

<span class="org-type">void</span> printAddress<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span>* <span class="org-variable-name">ptr</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Address of variable is = "</span> 
               &lt;&lt; <span class="org-constant">std</span>::hex &lt;&lt; <span class="org-string">"0x"</span> &lt;&lt; <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::uintptr_t<span class="org-rainbow-delimiters-depth-2">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span>
               &lt;&lt; <span class="org-constant">std</span>::dec 
               &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>


&gt;&gt; <span class="org-constant">std</span>::string s
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">""</span>
&gt;&gt; &amp;s
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7fd510b760b0
&gt;&gt; 
&gt;&gt; <span class="org-type">double</span> m
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000
&gt;&gt; 
&gt;&gt; printAddress<span class="org-rainbow-delimiters-depth-1">(</span>&amp;s<span class="org-rainbow-delimiters-depth-1">)</span>
Address of <span class="org-type">variable</span> <span class="org-variable-name">is</span> = 0x7fd510b760b0
&gt;&gt; printAddress<span class="org-rainbow-delimiters-depth-1">(</span>&amp;m<span class="org-rainbow-delimiters-depth-1">)</span>
Address of <span class="org-type">variable</span> <span class="org-variable-name">is</span> = 0x7fd510b760d0
</pre>
</div>

<ul class="org-ul">
<li>Casting memory locations to pointer.
<ul class="org-ul">
<li>Note: It doesn't have applicability in most cases, but it can be
useful for accessing memory mapped IO.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">double</span> x = 10.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 10.000000
&gt;&gt; <span class="org-type">unsigned</span> <span class="org-type">long</span> n = 300
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 300
&gt;&gt; 

&gt;&gt; &amp;x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f3fd32e9010
&gt;&gt; &amp;n
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f3fd32e9018
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">=========== Variable x =================</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Failure! Doesn't compile</span>
&gt;&gt; <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f3fd32e9010<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_4</span>:1:1: error: cannot cast from type <span class="org-warning">'</span><span class="org-type">long</span><span class="org-warning">'</span> to pointer type <span class="org-warning">'</span><span class="org-type">double</span> *<span class="org-warning">'</span>
<span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f3fd32e9010<span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&gt;&gt; 
&gt;&gt; <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f3fd32e9010<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f3fd32e9010
&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f3fd32e9010<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 10.000000
&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f3fd32e9010<span class="org-rainbow-delimiters-depth-1">)</span> = 100.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.00000
&gt;&gt; x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.00000
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">=========== Variable n =================</span>
&gt;&gt; <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f3fd32e9018<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f3fd32e9018
&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f3fd32e9018<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 300
&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f3fd32e9018<span class="org-rainbow-delimiters-depth-1">)</span> = 100
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 100
&gt;&gt; <span class="org-type">int</span>&amp; z = *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>0x7f3fd32e9018<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 100
&gt;&gt; z  = 500
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 500
&gt;&gt; n
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 500
&gt;&gt; n = 600
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 600
&gt;&gt; z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 600
&gt;&gt; 
</pre>
</div>

<ul class="org-ul">
<li>Load Symbols from a DLL / Shared Object
<ul class="org-ul">
<li>Note: Windows uses the Win32 API-Calls <a href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, LoadLibraryA,
LoadLibraryW, <a href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> and so on.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">dlfcn.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">GNU Scientific Library - Linear Algebra CBLAS </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">dllPath</span> = <span class="org-string">"/usr/lib64/libgslcblas.so"</span>;

&gt;&gt; <span class="org-type">void</span>* libHandle = dlopen<span class="org-rainbow-delimiters-depth-1">(</span>dllPath, RTLD_LAZY<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x1be2de0
&gt;&gt; 

&gt;&gt; <span class="org-type">void</span>* sym = dlsym<span class="org-rainbow-delimiters-depth-1">(</span>libHandle, <span class="org-string">"cblas_daxpy"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f3fb97d2010

&gt;&gt; sym == <span class="org-constant">nullptr</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">auto</span> cblas_daxpy = <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-keyword">const</span> <span class="org-type">double</span>*, <span class="org-type">int</span>, <span class="org-type">double</span>*, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>sym<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> *, <span class="org-type">int</span>, <span class="org-type">double</span> *, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> Function @0x7f3fb97d2010
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Or </span>
<span class="org-keyword">using</span> cblas_daxpy_type = <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-keyword">const</span> <span class="org-type">double</span>*, <span class="org-type">int</span>, <span class="org-type">double</span>*, <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; <span class="org-keyword">auto</span> xs = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span> 3.0, 5.0, 6.0, 10.0, 8.0<span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; <span class="org-keyword">auto</span> ys = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;{</span> 2.0, 2.0, 2.0,  2.0, 2.0<span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; 

&gt;&gt; cblas_daxpy<span class="org-rainbow-delimiters-depth-1">(</span>xs.size<span class="org-rainbow-delimiters-depth-2">()</span>, 4.0, &amp;xs<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span>, 1, &amp;ys<span class="org-rainbow-delimiters-depth-2">[</span>0<span class="org-rainbow-delimiters-depth-2">]</span>, 1<span class="org-rainbow-delimiters-depth-1">)</span>
&gt;&gt; xs
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span> 3.0000000, 5.0000000, 6.0000000, 10.000000, 8.0000000 <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; ys
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span> 14.000000, 22.000000, 26.000000, 42.000000, 34.000000 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Close the library handle (Better use SMART POINTERS!!!!)</span>
&gt;&gt; dlclose<span class="org-rainbow-delimiters-depth-1">(</span>libHandle<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-org9d7d130" class="outline-4">
<h4 id="org9d7d130"><span class="section-number-4">1.23.5</span> Example: Const cast</h4>
<div class="outline-text-4" id="text-1-23-5">
<p>
Const cast is used for removing the const qualifier/modifier from const
reference or const pointer in order to modify the referenced memory
location. 
</p>

<ul class="org-ul">
<li>Note: The const cast cannot be used for removing the const
qualifierfrom const variables. In this case the casting behavior
is undefined.</li>
<li>Documentation: <a href="https://en.cppreference.com/w/cpp/language/const_cast">const_cast conversion - cppreference.com</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">double</span> x = 10.0;
&gt;&gt; <span class="org-keyword">const</span> <span class="org-type">double</span>&amp; xref = x;
&gt;&gt; xref
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 10.000000
&gt;&gt; 
&gt;&gt; xref = 20.0
<span class="org-function-name">ROOT_prompt_3</span>:1:6: error: cannot assign to variable <span class="org-warning">'</span>xref<span class="org-warning">'</span> with <span class="org-keyword">const</span>-qualified type <span class="org-warning">'</span><span class="org-keyword">const</span> <span class="org-type">double</span> &amp;<span class="org-warning">'</span>
xref = 20.0
~~~~ ^
<span class="org-function-name">ROOT_prompt_1</span>:1:15: note: variable <span class="org-warning">'</span>xref<span class="org-warning">'</span> declared <span class="org-keyword">const</span> here
<span class="org-keyword">const</span> <span class="org-type">double</span>&amp; xref = x;
~~~~~~~~~~~~~~^~~~~~~~
&gt;&gt; 
<span class="org-comment-delimiter">// </span><span class="org-comment">Remove the const qualifier of xref </span>
&gt;&gt; <span class="org-keyword">const_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;(</span>xref<span class="org-rainbow-delimiters-depth-1">)</span> = 25.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 25.000000
&gt;&gt; x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 25.000000
&gt;&gt; xref
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 25.000000
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Creating a non-const reference from a const reference.</span>
&gt;&gt; <span class="org-type">double</span>&amp; usualRef = <span class="org-keyword">const_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;(</span>xref<span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 25.000000
&gt;&gt; usualRef = 16.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 16.000000
&gt;&gt; x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 16.000000
&gt;&gt; xref
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 16.000000
&gt;&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-org0b9b6cc" class="outline-4">
<h4 id="org0b9b6cc"><span class="section-number-4">1.23.6</span> References and further reading</h4>
<div class="outline-text-4" id="text-1-23-6">
<ul class="org-ul">
<li>Cambridge University - <b>Casting in C++ (intermediate level)</b> -
<a href="http://www-h.eng.cam.ac.uk/help/tpl/languages/C++/casting.html">http://www-h.eng.cam.ac.uk/help/tpl/languages/C++/casting.html</a></li>

<li><b>4.4a — Explicit type conversion (casting)</b> -
<a href="http://www.learncpp.com/cpp-tutorial/4-4a-explicit-type-conversion-casting/">http://www.learncpp.com/cpp-tutorial/4-4a-explicit-type-conversion-casting/</a></li>

<li><a href="https://anteru.net/blog/2007/12/18/200/index.html">https://anteru.net/blog/2007/12/18/200/index.html</a></li>

<li><b>Casting operators in C++ | Set 1 (const_cast)</b> -
<a href="http://www.geeksforgeeks.org/casting-operators-in-c-set-1-const_cast/">http://www.geeksforgeeks.org/casting-operators-in-c-set-1-const_cast/</a></li>

<li><b>Casting – what could possibly go wrong?</b> -
<a href="https://blog.feabhas.com/2013/09/casting-what-could-possibly-go-wrong/">https://blog.feabhas.com/2013/09/casting-what-could-possibly-go-wrong/</a></li>

<li><b>C++ Casting, or: "Oh No, They Broke Malloc!</b> -
<a href="https://embeddedartistry.com/blog/2017/2/28/c-casting-or-oh-no-we-broke-malloc">https://embeddedartistry.com/blog/2017/2/28/c-casting-or-oh-no-we-broke-malloc</a></li>

<li><b>When should static_cast, dynamic_cast, const_cast and
reinterpret_cast be used?</b> - <a href="https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used">https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used</a></li>

<li><a href="http://cppblogs.blogspot.com.br/2013/08/c-style-casts.html">http://cppblogs.blogspot.com.br/2013/08/c-style-casts.html</a></li>

<li><b>Type-Conversion operators</b> -
<a href="http://www.bogotobogo.com/cplusplus/typecast.php">http://www.bogotobogo.com/cplusplus/typecast.php</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2d816f4" class="outline-3">
<h3 id="org2d816f4"><span class="section-number-3">1.24</span> OOP RTTI - Runtime Type Identification</h3>
<div class="outline-text-3" id="text-1-24">
</div>
<div id="outline-container-org7afbe8c" class="outline-4">
<h4 id="org7afbe8c"><span class="section-number-4">1.24.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-24-1">
<p>
RTTI - Runtime Type Identification is the ability to provide
information about types at rutime rather than at compile time. It is a
limited form of reflection. In C++, the RTTI functionality is provided
by the operators <b>typeid</b> getting type information and <b>dynamic_cast</b> used
for safely casting polymorphic types.
</p>

<p>
<b>RTTI in C++:</b>
</p>

<ul class="org-ul">
<li>Operator <b>dynamic_cast</b></li>
<li>Operator <b>typeid</b></li>
<li>Class      std::type_info</li>
<li>Exception: std::bad_typeid (derived class of std::exception)</li>
</ul>

<p>
<b>Further Reading</b> 
</p>

<ul class="org-ul">
<li><b>Inneficiences of C++ - Fact or Fiction</b>
<ul class="org-ul">
<li><a href="https://www.iar.com/globalassets/about-us/events/atc2015/inefficiencies-of-c.pdf">https://www.iar.com/globalassets/about-us/events/atc2015/inefficiencies-of-c.pdf</a></li>
</ul></li>

<li><b>How C++ Works</b>
<ul class="org-ul">
<li><a href="http://pages.cpsc.ucalgary.ca/~bdstephe/585_W11/d403_C++.pdf">http://pages.cpsc.ucalgary.ca/~bdstephe/585_W11/d403_C++.pdf</a></li>
</ul></li>

<li><b>Const, RTTI and Efficiency</b>
<ul class="org-ul">
<li><a href="https://www.artima.com/intv/const2.html">https://www.artima.com/intv/const2.html</a></li>
</ul></li>

<li><b>RTTI and Reflection</b>
<ul class="org-ul">
<li><a href="http://www.cs.huji.ac.il/course/2004/ood/docs/lec08.pdf">http://www.cs.huji.ac.il/course/2004/ood/docs/lec08.pdf</a></li>
</ul></li>

<li><b>Visual RTTI Inspection</b>
<ul class="org-ul">
<li><a href="https://blog.quarkslab.com/visual-c-rtti-inspection.html">https://blog.quarkslab.com/visual-c-rtti-inspection.html</a></li>
</ul></li>

<li><b>C++ RTTI - casting around</b>
<ul class="org-ul">
<li><a href="http://www.two-sdg.demon.co.uk/curbralan/papers/RTTI.html">http://www.two-sdg.demon.co.uk/curbralan/papers/RTTI.html</a></li>
</ul></li>

<li><b>Practical RTTI For Games</b>
<ul class="org-ul">
<li><a href="https://gamedevcoder.wordpress.com/2013/02/16/c-plus-plus-rtti-for-games/">https://gamedevcoder.wordpress.com/2013/02/16/c-plus-plus-rtti-for-games/</a></li>
</ul></li>

<li><a href="https://stackoverflow.com/questions/281818/unmangling-the-result-of-stdtype-infoname">c++ - Unmangling the result of std::type_info::name - Stack Overflow</a></li>

<li><a href="https://stackoverflow.com/questions/579887/how-expensive-is-rtti">c++ - How expensive is RTTI? - Stack Overflow</a></li>
</ul>
</div>
</div>

<div id="outline-container-org825861e" class="outline-4">
<h4 id="org825861e"><span class="section-number-4">1.24.2</span> Operator typeid</h4>
<div class="outline-text-4" id="text-1-24-2">
<p>
The operator typeid retrives information about a given type by
returning a reference to an object of type <span class="underline">typeinfo</span>.
</p>

<p>
Header: 
</p>
<ul class="org-ul">
<li>&lt;typeinfo&gt;</li>
</ul>

<p>
<b>Operator typeid:</b>
</p>

<ul class="org-ul">
<li>Documentaiton: <a href="https://en.cppreference.com/w/cpp/language/typeid">typeid operator - cppreference.com</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">const</span> <span class="org-type">typeinfo</span>&amp; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span>ARGUMENT<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Use cases: 
</p>

<ul class="org-ul">
<li>Compare types.</li>
<li>Recover wrapped type from type erasure. This approach is used by
Boost.Any and std::any from C++17.</li>
<li>Debugging</li>
</ul>

<p>
<b>Class std::type_info:</b>
</p>

<ul class="org-ul">
<li>Documentation: <a href="https://en.cppreference.com/w/cpp/types/type_info">std::type_info - cppreference.com</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">type_info</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
   <span class="org-keyword">virtual</span> ~<span class="org-function-name">type_info</span><span class="org-rainbow-delimiters-depth-2">()</span>;
   <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">==</span><span class="org-rainbow-delimiters-depth-2">(</span>cons <span class="org-type">type_info</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span>;
   <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">!=</span><span class="org-rainbow-delimiters-depth-2">(</span>cons <span class="org-type">type_info</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span>;
   <span class="org-type">bool</span> <span class="org-function-name">before</span><span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-keyword">const</span> <span class="org-type">type_info</span>&amp; <span class="org-variable-name">rhs</span> <span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span>;
   <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">name</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
   <span class="org-comment-delimiter">// </span><span class="org-comment">Since: C++11</span>
   <span class="org-type">size_t</span> <span class="org-function-name">hash_code</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Note: the type name returned by method .name() of type_info returns
the decorated name of type or the mangled name of type. The value
returned is compiler-dependent which means that a code should not rely
on the returned name. 
</p>

<p>
<b>Example:</b>
</p>

<p>
Get type name: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"i"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"d"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"f"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"l"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span>*<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Pi"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Pd"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">float</span>*<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Pf"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">long</span>*<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Pl"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"v"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span>*<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Pv"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span>**<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"PPv"</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"St6vectorIdSaIdEE"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"St5dequeIdSaIdEE"</span>
</pre>
</div>

<p>
Explore type_info object:
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">const</span> <span class="org-constant">std</span>::type_info&amp; ti = <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span>3.434<span class="org-rainbow-delimiters-depth-1">)</span>;
&gt;&gt; ti.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"d"</span>

&gt;&gt; ti.hash_code<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 14494284460613645429

<span class="org-comment-delimiter">// </span><span class="org-comment">Check whether type is int </span>
&gt;&gt; ti == <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Check whether type is double </span>
&gt;&gt; ti == <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Return the managled name of type </span>
&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span>*<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"PNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"</span>


&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span>.hash_code<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 5774750460303204477
</pre>
</div>

<p>
typeid and polymorphic types: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">dummy</span><span class="org-rainbow-delimiters-depth-2">(){}</span> <span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">class</span> <span class="org-type">Da</span>: <span class="org-keyword">public</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{}</span>;
<span class="org-keyword">class</span> <span class="org-type">Db</span>: <span class="org-keyword">public</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{}</span>;

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span>Base<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"4Base"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span>Da<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"2Da"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span>Db<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"2Db"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span>*<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"P4Base"</span>

&gt;&gt; <span class="org-keyword">typeid</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Da</span>*<span class="org-rainbow-delimiters-depth-1">)</span>.name<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"P2Da"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9ec8323" class="outline-4">
<h4 id="org9ec8323"><span class="section-number-4">1.24.3</span> Operator dynamic_cast</h4>
<div class="outline-text-4" id="text-1-24-3">
<p>
The operator <span class="underline">dynamic_cast</span> is used for safely downcasting a base class
to a particular derived class and is also for checking whether a
pointer to the base class refers to an instance of a particular
derived class. In general, dynamic casting should be avoided as it
violates OOP good practices, for instance, the client code in most
cases should have no knowledge about which particular derived class it
is dealing with and it also should be able to work with new derived
classes without any modification. The usage of dynamic cast and
if-else in a client code for performing operation specific for each
derived class can be avoided by adding new a virtual member function
to the base class or by using the visitor design pattern or double
dispatching. 
</p>

<p>
The operator <span class="underline">static_cast</span> can also be used for downcasting, however if
the operation is not possible, the result is undefined, thus using
<span class="underline">static_cast</span> is unsafe. It is only safe using <span class="underline">static_cast</span>, if there is
no doubt that the conversion is possible.
</p>

<p>
Dynamic cast use case(s): 
</p>

<ul class="org-ul">
<li>Extend the functionality of a class hierarchy without modifying the
base class or adding new virtual member functions. However, it will
require modification of client code if a new derived class is
created.</li>
</ul>

<p>
Notes and remarks: 
</p>

<ul class="org-ul">
<li>The operator <span class="underline">dynamic_cast</span> only works with polymorphic types, in
other words, any class with at least one virtual member function.</li>

<li><span class="underline">dynamic_cast</span> operator only works with <span class="underline">pointers</span>  or <span class="underline">references</span> to
classes with at least one virtual method.</li>

<li><span class="underline">static_cast</span> downcasting is unsafe. There is undefined behavior if
the conversion is not possible.</li>

<li><span class="underline">static_cast</span> is a compile-time construct.</li>

<li><span class="underline">dynamic_cast</span> is a run-time construct.</li>
</ul>

<p>
<b>Casting Pointers</b>
</p>

<p>
If the conversion fails, the pointer to the derived class is set to
null and no exception is thrown. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">BaseClass</span>* <span class="org-variable-name">pointerToBase</span> = &amp;objectOfDerivedA;

<span class="org-comment-delimiter">// </span><span class="org-comment">Downcast pointer from base to derived class</span>
<span class="org-type">DerivedClass</span>* <span class="org-variable-name">pointertoDerived</span> = <span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedClass</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>pointerToBase<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">pointertoDerived</span> = <span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedClass</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>pointerToBase<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>pointertoDerived<span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"It is the derived class"</span> &lt;&lt; <span class="org-string">"\n"</span>;
  pointertoDerived-&gt;exclusiveMethod1<span class="org-rainbow-delimiters-depth-2">()</span>;
  ... ... .. 
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> 
  <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Conversion failed."</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Casting References</b>
</p>

<p>
In this case, if the casting fails, it throws a <b>std::bad_cast</b>
exception. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">BaseClass</span>&amp; <span class="org-variable-name">refBaseClass</span> = objectOfDerivedA;   
<span class="org-keyword">try</span><span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Downcast reference </span>
   <span class="org-type">DerivedClass</span>&amp; <span class="org-variable-name">refDerived</span> = <span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DerivedClass</span>&amp;<span class="org-rainbow-delimiters-depth-2">&gt;(</span>refBaseClass<span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Found derived class ..."</span> &lt;&lt; <span class="org-string">"\n"</span>;
   refDerived.exclusiveMethod1<span class="org-rainbow-delimiters-depth-2">()</span>; 
   refDerived.exclusiveMethod2<span class="org-rainbow-delimiters-depth-2">()</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">bad_cast</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Error: casting not possible."</span> &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [ERROR] "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
<b>Example:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-function-name">Base</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Destructor of base class must always be virtual </span>
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">Base</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;   
      <span class="org-keyword">virtual</span> <span class="org-keyword">auto</span> <span class="org-function-name">getType</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> <span class="org-string">"Base"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>    
   <span class="org-type">void</span> <span class="org-function-name">showType</span><span class="org-rainbow-delimiters-depth-2">(){</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Class type = "</span> &lt;&lt; <span class="org-keyword">this</span>-&gt;getType<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">DerivedA</span>: <span class="org-keyword">public</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
   <span class="org-function-name">DerivedA</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
   <span class="org-keyword">auto</span> <span class="org-function-name">getType</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>  -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> <span class="org-string">"DerivedA"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">DerivedB</span>: <span class="org-keyword">public</span> <span class="org-type">Base</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
   <span class="org-function-name">DerivedB</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
   <span class="org-keyword">auto</span> <span class="org-function-name">getType</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-2">{</span>
      <span class="org-keyword">return</span> <span class="org-string">"DerivedB"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Creating testing objects: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">Base</span> <span class="org-variable-name">base</span>;
<span class="org-type">DerivedA</span> <span class="org-variable-name">da</span>;
<span class="org-type">DerivedB</span> <span class="org-variable-name">db</span>;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; Base *ptr = <span class="org-constant">nullptr</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Point to stack-object base </span>
&gt;&gt; ptr = &amp;base
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f6d9a022010

<span class="org-comment-delimiter">// </span><span class="org-comment">Check whether pointed object is of type base </span>
&gt;&gt; Base* ptrBase = <span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Base</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptrBase<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Object of type Base"</span> &lt;&lt; <span class="org-string">"\n"</span>;<span class="org-rainbow-delimiters-depth-1">}</span>
Object of <span class="org-type">type</span> <span class="org-variable-name">Base</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Base</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Object of type Base"</span> &lt;&lt; <span class="org-string">"\n"</span>;<span class="org-rainbow-delimiters-depth-1">}</span>
Object of <span class="org-type">type</span> <span class="org-variable-name">Base</span>
&gt;&gt; 
</pre>
</div>

<p>
Point to the object da (DerivedA)
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; ptr = &amp;da;

<span class="org-comment-delimiter">// </span><span class="org-comment">Cast pointer </span>
&gt;&gt; DerivedA* ptrDA = <span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedA</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">DerivedA</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7f6d9a022018

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptrDA != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Object of type DerivedA"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
Object of <span class="org-type">type</span> <span class="org-function-name">DerivedA</span>

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptrDA<span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Object of type DerivedA"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
Object of <span class="org-type">type</span> <span class="org-function-name">DerivedA</span>
&gt;&gt; 

&gt;&gt; ptrDA-&gt;showType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-type">Class</span> <span class="org-variable-name">type</span> = DerivedA
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Check whether pointer refers to an object of type DerivedA</span>
&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DerivedA</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Object of type A"</span> &lt;&lt; <span class="org-string">"\n"</span>;<span class="org-rainbow-delimiters-depth-1">}</span>
Object of <span class="org-type">type</span> <span class="org-variable-name">A</span>
</pre>
</div>

<p>
Check whether pointer refers to an object of type DerivedB
</p>

<ul class="org-ul">
<li>If the casting is not possible, the dynamic_cast operator returns a
null pointer.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; ptr = &amp;da;

&gt;&gt; DerivedB* ptrDB = <span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedB</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">DerivedB</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">nullptr</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptrDB != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"=&gt; Type DerivedB"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Casting failed"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">Casting</span> <span class="org-function-name">failed</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptrDB<span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"=&gt; Type DerivedB"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Casting failed"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">Casting</span> <span class="org-variable-name">failed</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DerivedB</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"=&gt; Type DerivedB"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Casting failed"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-type">Casting</span> <span class="org-variable-name">failed</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DerivedA</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"=&gt; Type DerivedA"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Casting failed"</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
=&gt; Type DerivedA
&gt;&gt; 
</pre>
</div>

<p>
Function which applies operations specific to the derived class using pointers:  
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">processType</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span>* <span class="org-variable-name">ptr</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">auto</span> <span class="org-variable-name">ptrA</span> = <span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DerivedA</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>ptrA<span class="org-rainbow-delimiters-depth-2">){</span>
         <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Found object of type = DerivedA"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">".getType() = "</span> &lt;&lt; ptrA-&gt;getType<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
         <span class="org-keyword">return</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-keyword">auto</span> <span class="org-variable-name">ptrB</span> = <span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DerivedB</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span>;
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>ptrB<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" Found object of type = DerivedB"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">".getType() = "</span> &lt;&lt; ptrB-&gt;getType<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-keyword">return</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>ptr<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Found object of type Base"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">".getType() = "</span> &lt;&lt; ptr-&gt;getType<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-keyword">return</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Null pointer or cannot determine instance type."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>


&gt;&gt; processType<span class="org-rainbow-delimiters-depth-1">(</span>&amp;da<span class="org-rainbow-delimiters-depth-1">)</span>
Found object <span class="org-type">of</span> <span class="org-variable-name">type</span> = DerivedA
.getType<span class="org-rainbow-delimiters-depth-1">()</span> = DerivedA

&gt;&gt; processType<span class="org-rainbow-delimiters-depth-1">(</span>&amp;db<span class="org-rainbow-delimiters-depth-1">)</span>
 Found object <span class="org-type">of</span> <span class="org-variable-name">type</span> = DerivedB
.getType<span class="org-rainbow-delimiters-depth-1">()</span> = DerivedB

&gt;&gt; processType<span class="org-rainbow-delimiters-depth-1">(</span>&amp;base<span class="org-rainbow-delimiters-depth-1">)</span>
Found object <span class="org-type">of</span> <span class="org-type">type</span> <span class="org-function-name">Base</span>
.getType<span class="org-rainbow-delimiters-depth-1">()</span> = Base

&gt;&gt; processType<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Null</span> <span class="org-variable-name">pointer</span> <span class="org-keyword">or</span> cannot determine instance type.
</pre>
</div>

<p>
Dynamic casting references: 
</p>

<ul class="org-ul">
<li>Note: References to polymorphic objects can be casted with dynamic
cast too. In this case if the operation fails, it throws an
<span class="underline">std::bad_cast</span> exception.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; Base&amp; refb1 = base;

<span class="org-comment-delimiter">// </span><span class="org-comment">Throws exception, casting failed </span>
&gt;&gt; DerivedA&amp; refa1 = <span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedA</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-type">refb1</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Error</span> <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: <span class="org-constant">std</span>::bad_cast caught: <span class="org-constant">std</span>::bad_cast
&gt;&gt; 

&gt;&gt; Base&amp; refb2 = da;
&gt;&gt; 
&gt;&gt; DerivedA&amp; refa2 = <span class="org-keyword">dynamic_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">DerivedA</span>&amp;<span class="org-rainbow-delimiters-depth-1">&gt;(</span>refb2<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">DerivedA</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7f9d32750018
&gt;&gt; 
&gt;&gt; refa2.getType<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"DerivedA"</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4c34af7" class="outline-3">
<h3 id="org4c34af7"><span class="section-number-3">1.25</span> Friend Functions</h3>
<div class="outline-text-3" id="text-1-25">
<p>
A friend function is a function that can access the private and
protected member variables or member functions (methods) of some
class. There are lots of controversies about friend function over
breaking of encapsulation, however there are legitimate cases for
their usage such as serialization. 
</p>

<p>
Features: 
</p>

<ul class="org-ul">
<li>A friend function to some class has access to private and
protected member variables and functions of that class.</li>

<li>F.F. can be friend to multiple classes via function overloading.</li>

<li>F.F. are not member functions or part of any class.</li>
</ul>

<p>
<b>Example:</b>
</p>

<p>
Class: ClassA 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">ClassA</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
     <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_id</span>;
     <span class="org-type">double</span> <span class="org-variable-name">m_x</span>, <span class="org-variable-name">m_y</span>;
     <span class="org-type">void</span> <span class="org-function-name">describe</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"This is the class: ClassA"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
     <span class="org-rainbow-delimiters-depth-2">}</span>  
<span class="org-function-name">public</span>:
    <span class="org-function-name">ClassA</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">id</span>, <span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">)</span>:
       m_id<span class="org-rainbow-delimiters-depth-2">(</span>id<span class="org-rainbow-delimiters-depth-2">)</span>, m_x<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>, m_y<span class="org-rainbow-delimiters-depth-2">(</span>y<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span> <span class="org-function-name">GetX</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> m_x; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">double</span> <span class="org-function-name">GetY</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> m_y; <span class="org-rainbow-delimiters-depth-2">}</span> 
    <span class="org-keyword">friend</span> <span class="org-type">void</span> <span class="org-function-name">showClassInfo</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ClassA</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Class: ClassB.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">ClassB</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
     <span class="org-constant">std</span>::<span class="org-type">string</span>  <span class="org-variable-name">m_id</span>;
     <span class="org-type">int</span> <span class="org-variable-name">m_a</span>, <span class="org-variable-name">m_b</span>, <span class="org-variable-name">m_c</span>;
<span class="org-function-name">public</span>:
    <span class="org-function-name">ClassB</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">id</span>, <span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-type">int</span> <span class="org-variable-name">b</span>, <span class="org-type">int</span> <span class="org-variable-name">c</span><span class="org-rainbow-delimiters-depth-2">)</span>:
            m_id<span class="org-rainbow-delimiters-depth-2">(</span>id<span class="org-rainbow-delimiters-depth-2">)</span>, m_a<span class="org-rainbow-delimiters-depth-2">(</span>a<span class="org-rainbow-delimiters-depth-2">)</span>, m_b<span class="org-rainbow-delimiters-depth-2">(</span>b<span class="org-rainbow-delimiters-depth-2">)</span>, m_c<span class="org-rainbow-delimiters-depth-2">(</span>c<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>       
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">friend</span> <span class="org-type">void</span> <span class="org-function-name">showClassInfo</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ClassB</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<p>
Friend Implementation:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">showClassInfo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">ClassA</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"ClassA Information."</span> &lt;&lt; <span class="org-string">"\n"</span>;
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"  id = "</span>    &lt;&lt; obj.m_id
               &lt;&lt; <span class="org-string">" ; x = "</span> &lt;&lt; obj.m_x
               &lt;&lt; <span class="org-string">" ; y =  "</span> &lt;&lt; obj.m_y
               &lt;&lt; <span class="org-string">"\n"</span>;
     obj.describe<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">showClassInfo</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">ClassB</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"ClassB Information."</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" id = "</span> &lt;&lt; obj.m_id
              &lt;&lt; <span class="org-string">" ; a = "</span> &lt;&lt; obj.m_a
              &lt;&lt; <span class="org-string">" ; b = "</span> &lt;&lt; obj.m_b
              &lt;&lt; <span class="org-string">" ; c = "</span> &lt;&lt; obj.m_c
              &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
ROOT REPL Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; ClassA clsA<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"objectA"</span>, 203.67, 9.345<span class="org-rainbow-delimiters-depth-1">}</span>;
&gt;&gt; ClassB clsB<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"objB"</span>, 20, 824, 561<span class="org-rainbow-delimiters-depth-1">}</span>;

&gt;&gt; clsA.m_x
<span class="org-function-name">ROOT_prompt_8</span>:1:6: error: <span class="org-warning">'</span>m_x<span class="org-warning">'</span> is a <span class="org-keyword">private</span> member of <span class="org-warning">'</span>ClassA<span class="org-warning">'</span>
clsA.m_x
     ^
<span class="org-function-name">input_line_17</span>:5:9: note: declared <span class="org-keyword">private</span> here
        <span class="org-type">double</span> m_x, m_y;
               ^

&gt;&gt; showClassInfo<span class="org-rainbow-delimiters-depth-1">(</span>clsA<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">ClassA</span> <span class="org-variable-name">Information</span>.
  id = objectA ; x = 203.67 ; y =  9.345
This is the <span class="org-keyword">class</span>: <span class="org-type">ClassA</span>


&gt;&gt; showClassInfo<span class="org-rainbow-delimiters-depth-1">(</span>clsB<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">ClassB</span> <span class="org-variable-name">Information</span>.
 id = objB ; a = 20 ; b = 824 ; c = 561
</pre>
</div>


<p>
Further Reading: 
</p>

<ul class="org-ul">
<li>Example - Usage of friend function for serialization:
<ul class="org-ul">
<li><a href="https://perso.telecom-paristech.fr/elc/software/jsonserial.pdf">https://perso.telecom-paristech.fr/elc/software/jsonserial.pdf</a></li>
<li><a href="https://web.archive.org/web/20181227170325/https://perso.telecom-paristech.fr/elc/software/jsonserial.pdf">https://web.archive.org/web/20181227170325/https://perso.telecom-paristech.fr/elc/software/jsonserial.pdf</a></li>
</ul></li>

<li><a href="https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_73/rzarg/cplr042.htm">IBM Knowledge Center - Friends (C++ only)</a></li>

<li><a href="http://www.cs.fsu.edu/~jestes/cop3330/notes/overload.html">Operator Overloads</a></li>
</ul>
</div>
</div>
<div id="outline-container-org91a2428" class="outline-3">
<h3 id="org91a2428"><span class="section-number-3">1.26</span> Namespaces</h3>
<div class="outline-text-3" id="text-1-26">
</div>
<div id="outline-container-org5fa6a02" class="outline-4">
<h4 id="org5fa6a02"><span class="section-number-4">1.26.1</span> Summary</h4>
<div class="outline-text-4" id="text-1-26-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">C++ Namespace</th>
<th scope="col" class="org-left">Python Equivalent</th>
<th scope="col" class="org-left">Description</th>
</tr>

<tr>
<th scope="col" class="org-left">Operation</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>using namespace std;</code></td>
<td class="org-left">from std import *</td>
<td class="org-left">Import everything from  a namespace.</td>
</tr>

<tr>
<td class="org-left"><code>using std::cout;</code></td>
<td class="org-left">from std import cout</td>
<td class="org-left">Import an object, function from a namespace.</td>
</tr>

<tr>
<td class="org-left">using std::cout, std::cin, std::endl;</td>
<td class="org-left">from std import cout, cin &#x2026;</td>
<td class="org-left">Import multiple items from a namespace (C++17 only.)</td>
</tr>

<tr>
<td class="org-left"><code>namespace mk = mathkit::ellipticfun;</code></td>
<td class="org-left">import mathkit.ellipticfun as mk</td>
<td class="org-left">Create an alias to a namespace.</td>
</tr>

<tr>
<td class="org-left">mathkit::function::sind(90);</td>
<td class="org-left">import mathkit; mathkit.function.sind(90);</td>
<td class="org-left">Call a function from namespace.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgb0f6195" class="outline-4">
<h4 id="orgb0f6195"><span class="section-number-4">1.26.2</span> Examples</h4>
<div class="outline-text-4" id="text-1-26-2">
<p>
Open namespace:
</p>

<ul class="org-ul">
<li><code>using namespace &lt;namespace&gt;</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Not recommended - It defeats the purpose of namespace which is prevent </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">nameclashes and improve discoverability. </span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"Hello world"</span> &lt;&lt; <span class="org-string">"\n"</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Import everything from boost linear algebra library.</span>
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">boost</span>::<span class="org-constant">numeric</span>::<span class="org-constant">ublas</span>;
</pre>
</div>

<p>
Open namespace inside function:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">printNumbers</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Import everything from std namespace </span>
        <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
                cout &lt;&lt; <span class="org-string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">C++11 auto syntax for function declaration</span>
<span class="org-keyword">auto</span> <span class="org-function-name">printNumbers</span><span class="org-rainbow-delimiters-depth-1">()</span> -&gt; <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
                cout &lt;&lt; <span class="org-string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">C++14 return type deduction with optional type deduction.</span>
<span class="org-keyword">auto</span> <span class="org-function-name">printNumbers</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Import everything from std namespace </span>
        <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
                cout &lt;&lt; <span class="org-string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Using element from namespace without import namespace. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"hello world"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-keyword">auto</span> <span class="org-variable-name">matrixI3</span> =  <span class="org-constant">boost</span>::<span class="org-constant">numeric</span>::<span class="org-constant">ublas</span>::identity_matrix<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>3<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-unmatched">)</span>;
</pre>
</div>

<p>
Import specific elements from namespace 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Option 1 </span>
<span class="org-comment-delimiter">//</span><span class="org-comment">----------------------------------------//</span>
<span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">cout</span>; 
<span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">cerr</span>; 
<span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">endl</span>; 
<span class="org-keyword">using</span> <span class="org-constant">boost</span>::<span class="org-constant">numeric</span>::<span class="org-constant">ublas</span>::<span class="org-type">identity_matrix</span>;
<span class="org-keyword">using</span> <span class="org-constant">boost</span>::<span class="org-constant">numeric</span>::<span class="org-constant">ublas</span>::<span class="org-type">norm_1</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Option 2 =&gt; Multiple imports at same line. </span>
<span class="org-comment-delimiter">//</span><span class="org-comment">----------------------------------------//</span>
<span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">cout</span>; <span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">cerr</span>;  <span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">endl</span>; 
<span class="org-keyword">using</span> <span class="org-constant">boost</span>::<span class="org-constant">numeric</span>::<span class="org-constant">ublas</span>::<span class="org-type">identity_matrix</span>; <span class="org-keyword">using</span> <span class="org-constant">boost</span>::<span class="org-constant">numeric</span>::<span class="org-constant">ublas</span>::<span class="org-type">norm_1</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Option 3 =&gt; C++17 only </span>
<span class="org-comment-delimiter">//</span><span class="org-comment">----------------------------------------//</span>
<span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">cout</span>, <span class="org-constant">std</span>::cerr, <span class="org-constant">std</span>::endl; 
<span class="org-keyword">using</span> <span class="org-constant">boost</span>::<span class="org-constant">numeric</span>::<span class="org-constant">ublas</span>::<span class="org-type">identity_matrix</span>, <span class="org-constant">boost</span>::<span class="org-constant">numeric</span>::<span class="org-constant">ublas</span>::norm_1;

</pre>
</div>

<p>
Namespace synonym/alias:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Create namespace alias ub </span>
<span class="org-keyword">namespace</span> <span class="org-constant">ub</span> = <span class="org-constant">boost</span>::<span class="org-constant">numeric</span>::ublas;

<span class="org-function-name">ub</span>::<span class="org-type">matrix</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> matrix1<span class="org-rainbow-delimiters-depth-1">(</span>3, 3, 2.5<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">auto type inference + uniform initalization </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">matrix1</span> = <span class="org-constant">ub</span>::<span class="org-type">matrix</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>3, 3, 2.5<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<p>
Creating a namespace: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">ostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cmath</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">namespace</span> <span class="org-constant">MyFunctions</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Import everything from namespace std </span>
    <span class="org-keyword">using</span> <span class="org-keyword">namespace</span>::<span class="org-constant">std</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Type alias or synonym </span>
    <span class="org-keyword">using</span> <span class="org-type">cstring</span> = <span class="org-keyword">const</span> <span class="org-type">char</span>*;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Or: using MathFunc = std::function&lt;double (double)&gt;;</span>
    <span class="org-keyword">using</span> <span class="org-type">MathFunc</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">auto</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>;

    <span class="org-type">cstring</span> <span class="org-variable-name">description</span> = <span class="org-string">"Utility functions"</span>;

    <span class="org-type">double</span> <span class="org-function-name">add</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">){</span>
       <span class="org-keyword">return</span> x + y;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">auto</span> <span class="org-function-name">saySomething</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        cout &lt;&lt; <span class="org-string">"A computer was a skilled mathematician who computed firing tables."</span> &lt;&lt; endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">struct</span> <span class="org-type">Coord</span><span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Latitude in degrees/decimal </span>
        <span class="org-type">double</span> <span class="org-variable-name">lat</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Longitude in degrees/decimal </span>
        <span class="org-type">double</span> <span class="org-variable-name">lon</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>;

    <span class="org-keyword">namespace</span> <span class="org-constant">math</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">showTable</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">MathFunc</span> <span class="org-variable-name">fun</span>, <span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span> = <span class="org-constant">std</span>::cout<span class="org-rainbow-delimiters-depth-3">)</span> -&gt; <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span> = 0; x &lt; 10.0; x += 1.0<span class="org-rainbow-delimiters-depth-4">){</span>
               os &lt;&lt; setw<span class="org-rainbow-delimiters-depth-5">(</span>10<span class="org-rainbow-delimiters-depth-5">)</span> &lt;&lt; x &lt;&lt; setw<span class="org-rainbow-delimiters-depth-5">(</span>10<span class="org-rainbow-delimiters-depth-5">)</span> &lt;&lt; fun<span class="org-rainbow-delimiters-depth-5">(</span>x<span class="org-rainbow-delimiters-depth-5">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">makeMultiplier</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; <span class="org-type">MathFunc</span> <span class="org-rainbow-delimiters-depth-3">{</span>
             <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-4">[</span>x<span class="org-rainbow-delimiters-depth-4">](</span><span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-4">){</span><span class="org-keyword">return</span> x * x; <span class="org-rainbow-delimiters-depth-4">}</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>       
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">End of namespace MyFunctions --/</span>
</pre>
</div>

<p>
Testing: (CERN's ROOT/Cling REPL.)
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">MyFunctions</span>::add<span class="org-rainbow-delimiters-depth-1">(</span>102.3, -93.4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 8.9000000
&gt;&gt; <span class="org-constant">MyFunctions</span>::add<span class="org-rainbow-delimiters-depth-1">(</span>102.3, -193.4<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -91.100000
&gt;&gt;
&gt;&gt; <span class="org-constant">MyFunctions</span>::saySomething<span class="org-rainbow-delimiters-depth-1">()</span>
A computer was a skilled mathematician who computed <span class="org-type">firing</span> <span class="org-variable-name">tables</span>
&gt;&gt;

&gt;&gt; <span class="org-constant">MyFunctions</span>::<span class="org-constant">math</span>::showTable<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> x * 3.0 + 4.0;<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-1">)</span>
         0         4
         1         7
         2        10
         3        13
  ... ... ... ... 

<span class="org-comment-delimiter">// </span><span class="org-comment">import MyFunctions.math as m</span>
&gt;&gt; <span class="org-keyword">namespace</span> <span class="org-constant">m</span> = <span class="org-constant">MyFunctions</span>::math;
&gt;&gt; <span class="org-constant">m</span>::showTable<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> x * 3.0 + 4.0;<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-1">)</span>
         0         4
         1         7
         2        10
         3        13
  ... ... ... ... 

<span class="org-comment-delimiter">// </span><span class="org-comment">from MyFunctions.math import *</span>
&gt;&gt; <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">MyFunctions</span>::<span class="org-constant">math</span>;

&gt;&gt; showTable<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> x * x;<span class="org-rainbow-delimiters-depth-2">}</span>, <span class="org-constant">std</span>::cerr <span class="org-rainbow-delimiters-depth-1">)</span>
         0         0
         1         1
         2         4
         3         9
         4        16
    ... ... ... ...  

&gt;&gt; showTable<span class="org-rainbow-delimiters-depth-1">(</span>exp, <span class="org-constant">std</span>::cerr <span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">ROOT_prompt_34</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>showTable<span class="org-warning">'</span>
showTable<span class="org-rainbow-delimiters-depth-1">(</span>exp, <span class="org-constant">std</span>::cerr <span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~

&gt;&gt; showTable<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-rainbow-delimiters-depth-3">)(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>exp<span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-constant">std</span>::cerr<span class="org-rainbow-delimiters-depth-1">)</span>
         0         1
         1   2.71828
         2   7.38906
         3   20.0855
         4   54.5982
         5   148.413
         6   403.429
         7   1096.63
         8   2980.96
         9   8103.08
</pre>
</div>

<p>
Define a function at some namespace: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-constant">General</span>::<span class="org-function-name">GetNumberOfDays</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">d1</span>, <span class="org-type">int</span> <span class="org-variable-name">d2</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-keyword">return</span> d2 - d1;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9943de4" class="outline-3">
<h3 id="org9943de4"><span class="section-number-3">1.27</span> Move Semantics</h3>
<div class="outline-text-3" id="text-1-27">
</div>
<div id="outline-container-org79623aa" class="outline-4">
<h4 id="org79623aa"><span class="section-number-4">1.27.1</span> r-value and l-values</h4>
<div class="outline-text-4" id="text-1-27-1">
<p>
<b>Lvalues X Rvalues</b> 
</p>

<p>
The names LValues and RValues come from C, "L-value" name comes from
the left-hand side from an assignment operation referring to a memory
location from which it is possible to take the address.  The "R-value"
name come from the right-hand side from an assignment expression and
is a temporary value from which it is not possible to take the
address.
</p>

<div class="org-src-container">
<pre class="src src-text">&lt;Lvalue&gt; = &lt;Rvalue&gt;; 
    |         |
    |         \+--------&gt;&gt; R-value: right-hand side of assignment, 
    \                      non-addressable. Not possible to take address, 
     \                     temporary object.
      \ 
       +-----------------&gt;&gt; L-value: left-hand side of assignment, 
                            addressable memory location. 
</pre>
</div>

<p>
So: 
</p>

<ul class="org-ul">
<li><b>Lvalue</b> =&gt; value with an addressable and identifiable memory
location from which is possible to take the address with the
ampersand operator (&amp;), set or assign a new value.</li>

<li><b>Rvalue</b> =&gt; literal, expression or temporary object from which it is
not possible to take the address with ampersand operator(&amp;) or
set a new value. For short, it can be said that, everything that is
not an L-value, is an R-value.</li>

<li>More at: <a href="https://en.cppreference.com/w/cpp/language/value_category">value category</a> (CppReference)</li>
</ul>

<p>
Examples: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">x =&gt; is a Lvalue, 10 is an Rvalue   </span>
<span class="org-type">int</span> <span class="org-variable-name">x</span> = 10;                             

<span class="org-comment-delimiter">// </span><span class="org-comment">str1 is a Lvalue and "hello world" is a </span>
<span class="org-function-name">std</span>::string str1 = <span class="org-string">"hello world"</span>;       

<span class="org-comment-delimiter">// </span><span class="org-comment">str2 is a Lvalue and the right-hand side (str1 + " - rvalue") is a r-value </span>
<span class="org-function-name">std</span>::string str2 = str1 + <span class="org-string">" - rvalue;"</span>;

<span class="org-keyword">class</span> <span class="org-type">A</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
   <span class="org-function-name">A</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span> ... <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">void</span> <span class="org-function-name">Function</span><span class="org-rainbow-delimiters-depth-1">(){</span> 
   <span class="org-type">A</span> <span class="org-variable-name">a</span>; 
   .... ... 
   <span class="org-keyword">return</span> a; 
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">A</span> <span class="org-variable-name">obj</span>; 

<span class="org-comment-delimiter">//  </span><span class="org-comment">obj is an L-value, while the object returned by 'Function()' is</span>
<span class="org-comment-delimiter">//  </span><span class="org-comment">a R-value (temporary object).</span>
obj = Function<span class="org-rainbow-delimiters-depth-1">()</span>; 
</pre>
</div>
</div>
</div>
<div id="outline-container-org2fa4e6e" class="outline-4">
<h4 id="org2fa4e6e"><span class="section-number-4">1.27.2</span> r-value references and r-value references</h4>
<div class="outline-text-4" id="text-1-27-2">
<p>
<b>LValue Reference</b> 
</p>

<p>
A L-value reference is an alias to a non-temporary object with a
defined memory location, which is similar to a constant pointer.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">'x' is a Lvalue =&gt; 10 is a R-value </span>
&gt;&gt; <span class="org-type">int</span> x = 10;

<span class="org-comment-delimiter">// </span><span class="org-comment">refx is a L-value reference bound to 'x', in other words, refers to 'x'. </span>
&gt;&gt; <span class="org-type">int</span>&amp; refx = x;
&gt;&gt; 
&gt;&gt; refx
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10

<span class="org-comment-delimiter">// </span><span class="org-comment">An L-value reference has the same address as the variable that the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">reference it is bound to.</span>
&gt;&gt; <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>&amp;refx == &amp;x<span class="org-rainbow-delimiters-depth-1">)</span> printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] Have the same address Ok.\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">INFO</span><span class="org-rainbow-delimiters-depth-1">]</span> Have the same address Ok.

&gt;&gt; refx = 50
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 50
&gt;&gt; x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 50
</pre>
</div>

<p>
An L-value reference cannot bind to R-values or temporary objects: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; 
&gt;&gt; <span class="org-type">int</span>&amp; refy = x + 10;
<span class="org-function-name">ROOT_prompt_6</span>:1:6: error: non-<span class="org-keyword">const</span> lvalue reference to type <span class="org-warning">'</span><span class="org-type">int</span><span class="org-warning">'</span> cannot bind to a temporary of type
      <span class="org-warning">'</span><span class="org-type">int</span><span class="org-warning">'</span>
<span class="org-type">int</span>&amp; refy = x + 10;
     ^      ~~~~~~
</pre>
</div>

<p>
<b>Rvalue References</b> 
</p>

<p>
RValue references are references which binds to temporary
objects. They were introduced in C++11 for enabling move semantics and
move-member functions, namely, move constructor and move assignment
operator which allow to reuse resources from temporary objects by
performing shallow copy instead of deep copy, which would be performed
by the copy-constructor and copy assignment operator. Therefore, as a
shallow copy is much less expansive than a deep copy, move semantics
can provide significant performance improvements eliminating wasteful
copies of temporary objects.
</p>

<ul class="org-ul">
<li>Example 1: Rvalue binding.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">int</span> x = 10;

<span class="org-comment-delimiter">// </span><span class="org-comment">R-value reference</span>
&gt;&gt; <span class="org-type">int</span>&amp;&amp; rv = x + 10;

&gt;&gt; rv
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 20

&gt;&gt; rv = 25
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 25

<span class="org-comment-delimiter">// </span><span class="org-comment">Compile-time error! R-value references cannot bind to L-values.</span>
&gt;&gt; <span class="org-type">int</span>&amp;&amp; rv2 = x;
<span class="org-function-name">ROOT_prompt_22</span>:1:7: error: rvalue reference to type <span class="org-warning">'</span><span class="org-type">int</span><span class="org-warning">'</span> cannot bind to lvalue of type <span class="org-warning">'</span><span class="org-type">int</span><span class="org-warning">'</span>
<span class="org-type">int</span>&amp;&amp; rv2 = x;
      ^     ~
</pre>
</div>

<ul class="org-ul">
<li>Example 2: Lvalue X Rvalue and function overload.</li>
</ul>

<p>
Attempt to use the L-value reference overload of the function
printLines with a L-value and R-value.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">fstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-comment-delimiter">// </span><span class="org-comment">Overload of printLine taking an L-value reference as parameter </span>
<span class="org-type">void</span> <span class="org-function-name">printLines</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span>&amp; <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] L-value reference overload"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">line</span>; 
   <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-2">(</span>is, line<span class="org-rainbow-delimiters-depth-2">)</span>; 
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" line1 =: "</span> &lt;&lt; line &lt;&lt; <span class="org-constant">std</span>::endl;
   <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-2">(</span>is, line<span class="org-rainbow-delimiters-depth-2">)</span>; 
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" line2 =: "</span> &lt;&lt; line &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-constant">std</span>::ifstream fd1 <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">"/etc/protocols"</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Use the function with an L-value reference </span>
&gt;&gt; printLines<span class="org-rainbow-delimiters-depth-1">(</span>fd1<span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> L-value reference overload
 line1 =: # /etc/protocols:
 line2 =: # $Id: protocols,v 1.12 2016/07/08 12:27 ovasik Exp $
</pre>
</div>

<p>
Attempt to pass an R-value (temporary object in this case): 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">'std::ifstream{"/etc/protocols"}' is an R-value (temporary object)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">It is not possible to take address of this expression. </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">If the code was compiled, it would result in compile-time error. </span>
&gt;&gt; printLines<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::ifstream<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"/etc/protocols"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-function-name">ROOT_prompt_10</span>:1:1: error: no matching function <span class="org-keyword">for</span> call to <span class="org-warning">'</span>printLines<span class="org-warning">'</span>
printLines<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::ifstream<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"/etc/protocols"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
^~~~~~~~~~
<span class="org-function-name">ROOT_prompt_0</span>:1:6: note: candidate function <span class="org-keyword">not</span> viable: no known conversion from <span class="org-warning">'</span><span class="org-constant">std</span>::ifstream<span class="org-warning">'</span> <span class="org-rainbow-delimiters-depth-1">(</span>aka
      <span class="org-warning">'</span><span class="org-type">basic_ifstream</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">)</span> to <span class="org-warning">'</span><span class="org-constant">std</span>::istream &amp;<span class="org-warning">'</span> <span class="org-rainbow-delimiters-depth-1">(</span>aka <span class="org-warning">'</span><span class="org-type">basic_istream</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-warning">'</span><span class="org-rainbow-delimiters-depth-1">)</span>
      <span class="org-keyword">for</span> 1st argument
<span class="org-type">void</span> printLines<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span>&amp; <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-1">){</span>
    ^
</pre>
</div>

<p>
Solution, create a new overload of the function 'printLines' that
takes an r-value reference as parameter.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Overload of printLine taking an R-value reference as parameter </span>
<span class="org-type">void</span> <span class="org-function-name">printLines</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">istream</span>&amp;&amp; <span class="org-variable-name">is</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] R-value reference overload"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">line</span>; 
   <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-2">(</span>is, line<span class="org-rainbow-delimiters-depth-2">)</span>; 
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" line1 =: "</span> &lt;&lt; line &lt;&lt; <span class="org-constant">std</span>::endl;
   <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-2">(</span>is, line<span class="org-rainbow-delimiters-depth-2">)</span>; 
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" line2 =: "</span> &lt;&lt; line &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; printLines<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::ifstream<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"/etc/protocols"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> R-value reference overload
 line1 =: # /etc/protocols:
 line2 =: # $Id: protocols,v 1.12 2016/07/08 12:27 ovasik Exp $
</pre>
</div>
</div>
</div>




<div id="outline-container-org0e3c57e" class="outline-4">
<h4 id="org0e3c57e"><span class="section-number-4">1.27.3</span> Move-semantics member functions</h4>
<div class="outline-text-4" id="text-1-27-3">
<p>
<b>Move Constructor and move assignment operator</b> 
</p>

<p>
C++11 introduced new special member functions for move semantics, the
move constructor and move assignment operator. Those special member
functions were added for enhancing performance through elimination of
temporary objects (R-values) <span class="underline">deep copies</span>, that were performed by the
copy constructor or copy assignment operator. 
</p>

<p>
Despite the name, the move constructor and move assignment operator
don't move anything, they just transfer the ownership of resources
from a temporary object (rvalue) to a new object, in the case of the
move-ctor and to an existing object, in the case of the
move-operator. After the transfer, the temporary object is left in a
valid, but undetermined state without any resources. 
</p>

<p>
Example: 
</p>

<p>
If a class manages a heap-allocated array: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span>* <span class="org-variable-name">p_res</span> = <span class="org-keyword">new</span> <span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-1">[</span>10<span class="org-rainbow-delimiters-depth-1">]</span>;
</pre>
</div>

<p>
The move assignment operator copies the pointer (_shallow copy_) p_res
from a temporary object, transferring it to an existing object on the
left-hand side of the assignment, then the OldObject.p_res is set
nullptr. Without the move assignment operator, the copy assignment
operator would be called creating a wasteful <span class="underline">deep copy</span> due to a new
array allocation and copy of all elements.
</p>

<p>
<b>Benefits</b> 
</p>

<ul class="org-ul">
<li>The move semantics makes returning by value from functions or
member functions more efficient than before C++11 as only shallow
copy is performed, therefore the return value no longer need to be
returned as function parameter reference.</li>

<li>All STL containers, such as std::vector, std::deque,
std::unique_ptr, std::shared_ptr, std::map and so on, define move
member functions which makes returning any instance of them by
value more efficient and without any deep copy overhead.</li>
</ul>


<p>
<b>Default member functions</b> 
</p>

<p>
Before C++11, if class did not define any user declared special member
function, the compiler generated by default a default constructor,
copy-constructor, copy-assignment operator and a destructor. Since
C++11, in addition to those functions, the compiler also generates the
move constructor and move assignment operator in the absence of any
user declared member function. 
</p>

<p>
<b>Rule of three</b> 
</p>

<p>
Before C++11, if a class manages a resource such as heap-allocated
object, file descriptor, socket handler, &#x2026; and so. And the class
implements a user-defined default destructor, copy constructor or
copy-assignment operator, it should implement all of three.
</p>

<p>
<b>Rule of five</b> 
</p>

<p>
Since C++11, if a class managing a resource implement a user-defined
destructor, copy constructor, copy assignment operator, move
constructor or move assignment operator, it should implement all of
five. 
</p>

<ul class="org-ul">
<li>Note 1: If the copy member functions are annotated as deleted, only
the destructor and move member functions needs to be implemented.</li>

<li>Note 2: If the user do not define or annotate the copy-member
functions as deleted, the compiler may provide default copy-member
functions that are not aware of the resources. As a result, a
shallow-copy will be performed instead of deep copy resulting in a
bug when any of objects using the same resources disposes them 
while they are being used by other objects.</li>

<li>Note 3: Generally, classes that manages non-heap allocated
resources such as sockets descriptors, handlers, database handlers
should not be copiable, in other words, it should annotate copy
member functions as deleted.</li>
</ul>
</div>
</div>

<div id="outline-container-orgdaa4b1a" class="outline-4">
<h4 id="orgdaa4b1a"><span class="section-number-4">1.27.4</span> Signature of copy and move member functions</h4>
<div class="outline-text-4" id="text-1-27-4">
<p>
<b>Signature of copy member functions</b> 
</p>

<p>
Copy constructor: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">AClass</span>::AClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">AClass</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or </span>
<span class="org-function-name">AClass</span>::AClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">AClass</span> &amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or </span>
<span class="org-function-name">AClass</span>::AClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">AClass</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Copy assignment operator: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">AClass</span>&amp; <span class="org-constant">AClass</span>::<span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">AClass</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or </span>
<span class="org-type">AClass</span>&amp; <span class="org-constant">AClass</span>::<span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">AClass</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Signature of move member functions</b>
</p>

<p>
Move constructor:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">AClass</span>::AClass<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">AClass</span>&amp;&amp; <span class="org-variable-name">temporary</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Move assignment operator: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">AClass</span>&amp; <span class="org-constant">AClass</span>::<span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">AClass</span>&amp;&amp; <span class="org-variable-name">temporary</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org1ac0de0" class="outline-4">
<h4 id="org1ac0de0"><span class="section-number-4">1.27.5</span> Example: Move Semantics Member Functions</h4>
<div class="outline-text-4" id="text-1-27-5">
<p>
Full source code: 
</p>

<ul class="org-ul">
<li><a href="src/move_member_funcs.cpp">file:src/move_member_funcs.cpp</a></li>
</ul>

<p>
Class: AClass. 
</p>
<ul class="org-ul">
<li>The class AClass manages a heap-allocated object resource.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">AClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">Object unique ID for easier identification</span>
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">m_id</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Simulates a resource (heap-allocated object)</span>
    <span class="org-type">int</span>* <span class="org-variable-name">m_p</span>;

    <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">make_id</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">id</span> = 0;
        <span class="org-keyword">return</span> ++id;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Default constructor</span>
    <span class="org-function-name">AClass</span><span class="org-rainbow-delimiters-depth-2">()</span>: AClass<span class="org-rainbow-delimiters-depth-2">(</span>0<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-function-name">AClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span>: m_id<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">AClass</span>::make_id<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>, m_p<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-keyword">new</span> <span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-3">{</span>n<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] Object created =&gt; id = %d ; *m_p = %d\n"</span>, m_id, *m_p<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Copy constructor</span>
    <span class="org-function-name">AClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AClass</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">that</span><span class="org-rainbow-delimiters-depth-2">)</span>: m_id<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">AClass</span>::make_id<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        m_p = <span class="org-keyword">new</span> <span class="org-type">int</span> <span class="org-rainbow-delimiters-depth-3">(</span>*that.m_p<span class="org-rainbow-delimiters-depth-3">)</span>;
        printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] Copy ctor invoked =&gt; Copied src=%d dest=%d \n"</span>
               , that.m_id, m_id<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Copy assignment operator</span>
    <span class="org-type">AClass</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AClass</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">that</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] Copy asn. operator invoked. =&gt; src_id = %d - dest_id = %d \n"</span>
               , that.m_id, m_id<span class="org-rainbow-delimiters-depth-3">)</span>;
        *m_p = *that.m_p;
        <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-preprocessor">#if</span> 1
    <span class="org-comment-delimiter">// </span><span class="org-comment">Move constructor: move resource from a temporary object (RValue) to a new object.</span>
    <span class="org-function-name">AClass</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AClass</span>&amp;&amp; <span class="org-variable-name">that</span><span class="org-rainbow-delimiters-depth-2">)</span>: m_id<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-constant">AClass</span>::make_id<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] Move ctor invoked OK. =&gt; src_id = %d - dest_id = %d \n"</span>
               , that.m_id, m_id<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Transfer ownership of resource managed by temporary object that</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">to this object.</span>
        m_p = that.m_p;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Make the temporary object empty</span>
        that.m_p = <span class="org-constant">nullptr</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Move assignment operator: move resource from a temporary object (RValue)</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">to an existing object (this).</span>
    <span class="org-type">AClass</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">AClass</span>&amp;&amp; <span class="org-variable-name">that</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] Move asn operator invoked. OK. src_id = %d - dest_id = %d \n"</span>
               , that.m_id, m_id<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-type">int</span>* <span class="org-variable-name">p_temp</span> = m_p;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Transfer ownership of resources from the temporary object(that) to</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">this object.</span>
        m_p = that.m_p;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Diposes the resource of the existing object (this)</span>
        that.m_p = p_temp;
        <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-preprocessor">#endif</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Destructor</span>
    ~<span class="org-function-name">AClass</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] Object destroyed =&gt; Dtor called =&gt; id = %d \n"</span>, m_id<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">delete</span> m_p;
        m_p = <span class="org-constant">nullptr</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">int</span> <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> *m_p; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-type">void</span> <span class="org-function-name">set</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> *m_p = n; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Helper functions: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">is_lvalue_or_rvalue</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">AClass</span>&amp; <span class="org-variable-name">arg</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" ===&gt; Passed LVALUE \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">is_lvalue_or_rvalue</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">AClass</span>&amp;&amp; <span class="org-variable-name">arg</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" ===&gt; Passed RVALUE \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<p>
Load the file in CERN's root repl: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; .L move_member_funcs.cpp 
</pre>
</div>

<p>
Create some testing object: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; AClass obj1;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created =&gt; id = 1 ; *m_p = 0

&gt;&gt; AClass obj2<span class="org-rainbow-delimiters-depth-1">(</span>8<span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created =&gt; id = 2 ; *m_p = 8

&gt;&gt; AClass obj3<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created =&gt; id = 3 ; *m_p = 10
</pre>
</div>

<p>
Check R-values and L-values: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Pass an L-value </span>
&gt;&gt; is_lvalue_or_rvalue<span class="org-rainbow-delimiters-depth-1">(</span>obj1<span class="org-rainbow-delimiters-depth-1">)</span>
 ===&gt; Passed LVALUE 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Pass an R-value =&gt; temporary object</span>
&gt;&gt; is_lvalue_or_rvalue<span class="org-rainbow-delimiters-depth-1">(</span>AClass<span class="org-rainbow-delimiters-depth-2">(</span>100<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> Object created =&gt; id = 4 ; *m_p = 100
 ===&gt; Passed RVALUE 
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> Object destroyed =&gt; Dtor called =&gt; id = 4 

&gt;&gt; is_lvalue_or_rvalue<span class="org-rainbow-delimiters-depth-1">(</span>make_object<span class="org-rainbow-delimiters-depth-2">(</span>4<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> Object created =&gt; id = 5 ; *m_p = 4
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> FUN = make_object =&gt; Created object =&gt; id = 5 ; cls.get<span class="org-rainbow-delimiters-depth-1">()</span> = 8
 ===&gt; Passed RVALUE 
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> Object destroyed =&gt; Dtor called =&gt; id = 5 
</pre>
</div>

<p>
Invoke copy constructor: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; AClass objA<span class="org-rainbow-delimiters-depth-1">(</span>obj2<span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy ctor invoked =&gt; Copied src=2 dest=6 

&gt;&gt; objA.get<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 8

&gt;&gt; obj2.get<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 8
</pre>
</div>

<p>
Return value-optimization RVO =&gt; neither the copy constructor or move
constructor are called. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; AClass objB<span class="org-rainbow-delimiters-depth-1">(</span>make_object<span class="org-rainbow-delimiters-depth-2">(</span>6<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created =&gt; id = 7 ; *m_p = 4
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> FUN = make_object =&gt; Created object =&gt; id = 7 ; cls.get<span class="org-rainbow-delimiters-depth-1">()</span> = 10

&gt;&gt; objB.m_id
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 7

&gt;&gt; objB.get<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10

&gt;&gt; AClass objC = make_object<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created =&gt; id = 8 ; *m_p = 4
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> FUN = make_object =&gt; Created object =&gt; id = 8 ; cls.get<span class="org-rainbow-delimiters-depth-1">()</span> = 14
&gt;&gt; 
&gt;&gt; objC.m_id
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 8
&gt;&gt; 
&gt;&gt; objC.get<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 14
&gt;&gt; 
</pre>
</div>

<p>
Force invocation of move constructor with std::move which casts an
lvalue argument to an rvalue. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; objB.m_p
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x39c38d0

<span class="org-comment-delimiter">// </span><span class="org-comment">===&gt; Before calling move ctor </span>

&gt;&gt; AClass objM <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-2">(</span>objB<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-1">}</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Move ctor invoked OK. =&gt; src_id = 7 - dest_id = 10 
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">===&gt; After calling move ctor </span>

&gt;&gt; objB.m_p
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">nullptr</span>
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">The resource was transfered to object objM and objB no longer owns</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the resource.</span>
&gt;&gt; objM.m_p
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x39c38d0
&gt;&gt; 

&gt;&gt; *objM.m_p
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
</pre>
</div>

<p>
The copy assignment operator is called when assigning an l-vavlue to
an l-value or an addressable object to another.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; AClass c1;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created =&gt; id = 11 ; *m_p = 0

<span class="org-comment-delimiter">// </span><span class="org-comment">Copy assignment operator called. </span>
<span class="org-comment-delimiter">//</span><span class="org-comment">-----------------------------------</span>
&gt;&gt; c1 = obj2;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy asn. <span class="org-keyword">operator</span> <span class="org-type">invoked</span>. =&gt; src_id = 2 - dest_id = 11 

&gt;&gt; c1.m_p
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x46c5de0

&gt;&gt; obj2.m_p
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x2503fe0

&gt;&gt; c1.get<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 8
&gt;&gt; 
</pre>
</div>

<p>
The move assignment operator is called when assigning an l-value object
to a temporary value or r-value. If a move constructor is not defined
or was not created by the compiler, then the copy constructor is invoked
resulting in an expensive deep copy. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; AClass cx;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created =&gt; id = 12 ; *m_p = 0

<span class="org-comment-delimiter">// </span><span class="org-comment">Move assignment operator is called as cx is assigned to a temporary</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">object (R-value)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">-------------------------------</span>
&gt;&gt; cx = AClass<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created =&gt; id = 13 ; *m_p = 4
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> Move asn <span class="org-keyword">operator</span> <span class="org-type">invoked</span>. OK. src_id = 13 - dest_id = 12 
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> Object destroyed =&gt; Dtor called =&gt; id = 13 

&gt;&gt; cx.get<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 4
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Move assignment operator called as cx is assigned to a R-value </span>
&gt;&gt; cx = make_object<span class="org-rainbow-delimiters-depth-1">(</span>3<span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Object created =&gt; id = 14 ; *m_p = 4
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> FUN = make_object =&gt; Created object =&gt; id = 14 ; cls.get<span class="org-rainbow-delimiters-depth-1">()</span> = 7
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> Move asn <span class="org-keyword">operator</span> <span class="org-type">invoked</span>. OK. src_id = 14 - dest_id = 12 
 <span class="org-rainbow-delimiters-depth-1">[</span>TRACE<span class="org-rainbow-delimiters-depth-1">]</span> Object destroyed =&gt; Dtor called =&gt; id = 14 
&gt;&gt; 

&gt;&gt; cx.get<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 7
&gt;&gt; 
</pre>
</div>

<p>
Force invocation of the move-assignment operator by using std::move
which casts the argument from l-value to r-value: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; cx = obj1;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Copy asn. <span class="org-keyword">operator</span> <span class="org-type">invoked</span>. =&gt; src_id = 1 - dest_id = 12 

&gt;&gt; cx = <span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-1">(</span>obj2<span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">TRACE</span><span class="org-rainbow-delimiters-depth-1">]</span> Move asn <span class="org-keyword">operator</span> <span class="org-type">invoked</span>. OK. src_id = 2 - dest_id = 12 

&gt;&gt; cx.get<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 8
</pre>
</div>

<p>
<b>Simplifcation of move member functions</b> 
</p>

<p>
The move constructor and assignment operator could be rewritten in a
more concise way by using the std::move and std::swap facilities from
the standard library. 
</p>

<ul class="org-ul">
<li>Move constructor:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Move constructor: move resource from a temporary object (RValue) to a new object.</span>
<span class="org-function-name">AClass</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">AClass</span>&amp;&amp; <span class="org-variable-name">that</span><span class="org-rainbow-delimiters-depth-1">)</span>: m_id<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-constant">AClass</span>::make_id<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">}</span>, m_p<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-rainbow-delimiters-depth-1">{</span> 
    <span class="org-constant">std</span>::swap<span class="org-rainbow-delimiters-depth-2">(</span>m_p, that.m_p<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> 
</pre>
</div>

<p>
Move assignment operator: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Move assignment operator: move resource from a temporary object (RValue)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">to an existing object (this).</span>
<span class="org-type">AClass</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">AClass</span>&amp;&amp; <span class="org-variable-name">that</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::swap<span class="org-rainbow-delimiters-depth-2">(</span>m_p, that.m_p<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Functions std::swap: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">int</span> xx = 10, yy = 20;

&gt;&gt; xx
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
&gt;&gt; yy
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 20

&gt;&gt; <span class="org-constant">std</span>::swap<span class="org-rainbow-delimiters-depth-1">(</span>xx, yy<span class="org-rainbow-delimiters-depth-1">)</span>;
&gt;&gt; xx
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 20
&gt;&gt; yy
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
&gt;&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-orge8fbc9d" class="outline-4">
<h4 id="orge8fbc9d"><span class="section-number-4">1.27.6</span> Move Semantics References from C++ standard</h4>
<div class="outline-text-4" id="text-1-27-6">
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/value_category">Value Categories</a></li>

<li><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move constructor</a></li>

<li><a href="https://en.cppreference.com/w/cpp/language/move_assignment">Move assignment operator</a></li>

<li><a href="http://www.cplusplus.com/doc/tutorial/classes2/">Special Member Functions</a></li>

<li><a href="https://en.cppreference.com/w/cpp/algorithm/swap">std::swap</a></li>

<li><a href="https://en.cppreference.com/w/cpp/utility/move">std::move</a></li>

<li><a href="https://en.cppreference.com/w/cpp/utility/forward">std::forward</a></li>
</ul>
</div>
</div>

<div id="outline-container-org542b631" class="outline-4">
<h4 id="org542b631"><span class="section-number-4">1.27.7</span> References and further reading</h4>
<div class="outline-text-4" id="text-1-27-7">
<ul class="org-ul">
<li><b>Move constructor - cppreference</b>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/move_constructor">https://en.cppreference.com/w/cpp/language/move_constructor</a></li>
</ul></li>

<li><b>Move assignment operator - cppreference</b>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/move_assignment">https://en.cppreference.com/w/cpp/language/move_assignment</a></li>
</ul></li>

<li><b>Move Constructor and Move Assignment Operators (C++)</b> - Microsft
<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=vs-2019">https://docs.microsoft.com/en-us/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=vs-2019</a></li>
</ul></li>

<li><b>C++11: Move Semantics  - DKFZ</b>
<ul class="org-ul">
<li><a href="http://mitk.org/images/c/ca/MoveConstructor.pdf">http://mitk.org/images/c/ca/MoveConstructor.pdf</a></li>
</ul></li>

<li><b>C++ Move Semantics Gotchas</b>
<ul class="org-ul">
<li><a href="https://web.mst.edu/~nmjxv3/articles/move-gotchas.html">https://web.mst.edu/~nmjxv3/articles/move-gotchas.html</a></li>
</ul></li>

<li><b>When C++ does not move</b>
<ul class="org-ul">
<li><a href="https://pspdfkit.com/blog/2019/when-cpp-doesnt-move/">https://pspdfkit.com/blog/2019/when-cpp-doesnt-move/</a></li>
</ul></li>

<li><b>C++ rules for automatic member function generation</b>
<ul class="org-ul">
<li><a href="http://www.enyo.de/fw/notes/cpp-auto-members.html">http://www.enyo.de/fw/notes/cpp-auto-members.html</a></li>
</ul></li>

<li><b>Copying and assigning objects in C++</b>
<ul class="org-ul">
<li><a href="https://www.ics.uci.edu/~thornton/ics46/Notes/MoveSemantics/">https://www.ics.uci.edu/~thornton/ics46/Notes/MoveSemantics/</a></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org26b3ed6" class="outline-3">
<h3 id="org26b3ed6"><span class="section-number-3">1.28</span> Smart Pointers</h3>
<div class="outline-text-3" id="text-1-28">
</div>
<div id="outline-container-org8a0de53" class="outline-4">
<h4 id="org8a0de53"><span class="section-number-4">1.28.1</span> Problems of Raw Pointer</h4>
<div class="outline-text-4" id="text-1-28-1">
<p>
Raw pointers to dynamically allocated objects, (objects allocated with
<span class="underline">new</span> and disposed with <span class="underline">delete</span> operator) are responsible for a broad
range of problems such as memory leaks, double free and dangling
pointers that affected many old codebases. Some of the problems and
pontential bugs of raw pointers are: 
</p>

<ul class="org-ul">
<li><span class="underline">memory leak</span>
<ul class="org-ul">
<li>=&gt; The dynamically allocated object was not disposed. For every
object allocated with <span class="underline">AType* ptr = new AType()</span>, there should be a
matching <span class="underline">delete</span> operator. A memory leak happens when a call to
this operator is missing. It can happen due to be hard to keep
track of the onership of an owning raw pointer in large codebase;
code refactoring and early return from functions.</li>
</ul></li>

<li><span class="underline">dangling pointer</span>
<ul class="org-ul">
<li>=&gt; An owning pointer is still being used after the object has
been deleted, for instance, <span class="underline">AType* ptr = new AType</span>, the object is
deleted, the pointer was not set nullptr and later some part of
the code calls ptr-&gt;MemberFunction().</li>
</ul></li>

<li><span class="underline">double free</span>
<ul class="org-ul">
<li>=&gt; The pointer to a dynamically-allocated object was deleted more
than once and was not set null or nullptr after it was deleted
at the first time.</li>
</ul></li>

<li><span class="underline">lack of exception safety</span>
<ul class="org-ul">
<li>=&gt; If an exception happens after a heap-allocated object was
instantiaded, the matching delete operator will not be called,
therefore a memory leak will happen.</li>
</ul></li>

<li><span class="underline">lack of clear ownership</span>
<ul class="org-ul">
<li>=&gt; Ownership is the responbility to dispose a heap-allocated
object and keep it alive while it is being used. Raw pointers doe
not provide clear ownership, it is not possible to know if there
are any other objects still using the pointer and the ones that
will responsible for disposing the resource.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgff38e91" class="outline-4">
<h4 id="orgff38e91"><span class="section-number-4">1.28.2</span> Smart Pointers from standard library</h4>
<div class="outline-text-4" id="text-1-28-2">
<p>
Smart pointers are classes that manages the lifetime and ownership of
heap-allocated objects by wrapping raw pointers and emulating them
through overloading of dereference operators (*) and (-&gt;). They intend
to solve the raw owning pointers issues by making the ownership clear
and providing proper resource cleanup ensuring exception safety.
</p>

<p>
Note: 
</p>

<ul class="org-ul">
<li>Smart pointers should be used for <span class="underline">polymorphic objects</span> (objects
with at least one virtual member function) or large objects that
cannot fit on the stack.</li>

<li>Smart pointers <b>should</b> not be used for stack-allocated or static
objects (global objects). They should only be used with objects
that would be instantiated with <span class="underline">new</span> operator.</li>
</ul>

<p>
<b>Smart Pointers in the C++ Standard</b>
</p>

<ul class="org-ul">
<li><del>std::auto_ptr</del> - Deprecated (Removed in C++17) =&gt; Replace it for
<b>std::unique_ptr</b></li>

<li>std::unique_ptr
<ul class="org-ul">
<li>predecessor: boost:unique_ptr</li>
<li>Features:
<ul class="org-ul">
<li>Single ownership</li>
<li>Non-copiable and movable-only.</li>
<li>No runtime overhead over raw pointers and costs less than a
shared_ptr.</li>
</ul></li>
<li>Use Cases:
<ul class="org-ul">
<li>PIMPL design pattern</li>
<li>Heap-allocated object is refered by a single parent object.</li>
<li>Factory functions that instatiates dynamically allocated
polymorphic objects. In this case, it is recommeded to use
unique_ptr as it is easier to convert to shared_ptr than the
other way around.</li>
</ul></li>
</ul></li>

<li>std::shared_ptr
<ul class="org-ul">
<li>predecessor: boost::shared_ptr</li>
<li>Features: Shared ownership with reference counting.</li>
<li>Use Case:
<ul class="org-ul">
<li>More than one object need a copy of the pointer to
polymorphic dynamically allocated object and also need to keep
the object alive while it is being used.</li>
</ul></li>
</ul></li>

<li>std::weak_ptr
<ul class="org-ul">
<li>predecessor: boost::weak_ptr</li>
<li>Feature: No ownership.</li>
<li>Use Case:
<ul class="org-ul">
<li>Solves shared_ptr cyclic reference problems.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org1e2eab2" class="outline-4">
<h4 id="org1e2eab2"><span class="section-number-4">1.28.3</span> Other Smart Pointer Implementations</h4>
<div class="outline-text-4" id="text-1-28-3">
<p>
Boost: 
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_69_0/libs/smart_ptr/doc/html/smart_ptr.html#scoped_ptr">boost::scoped_ptr</a> - Similar to unique_ptr, but no-copiable and
no-copiable.</li>

<li><a href="https://www.boost.org/doc/libs/1_70_0/libs/smart_ptr/doc/html/smart_ptr.html#intrusive_ptr">Boost.Intrusive_ptr</a> - Similar to shared_ptr.</li>
</ul>

<p>
QT Framework:
</p>

<ul class="org-ul">
<li><a href="https://doc.qt.io/qt-5/qsharedpointer.html">QSharedPointer</a></li>

<li><a href="https://doc.qt.io/qt-5/qweakpointer.html">QWeakPointer</a></li>

<li><a href="https://doc.qt.io/qt-5/qscopedpointer.html">QScopedPointer</a></li>
</ul>

<p>
WXWidgets Smart Pointers: 
</p>

<ul class="org-ul">
<li><a href="https://docs.wxwidgets.org/3.1/group__group__class__smartpointers.html">smart pointers</a></li>
</ul>

<p>
Windows ATL - Active Template Library - COM (Component Object Model)
Smart Pointers
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/cpp/atl/reference/ccomptr-class?view=vs-2017">CComPtr Class</a></li>

<li><a href="https://docs.microsoft.com/en-us/cpp/atl/reference/ccomqiptr-class?view=vs-2017">CComQIPtr</a></li>

<li><a href="https://docs.microsoft.com/en-us/cpp/atl/reference/ccomheapptr-class?view=vs-2017">CComHeapPtr</a></li>

<li><a href="https://docs.microsoft.com/en-us/cpp/atl/reference/ccomgitptr-class?view=vs-2017">CComGITPtr</a></li>

<li><a href="https://docs.microsoft.com/en-us/cpp/cpp/com-ptr-t-class?view=vs-2017">_com_ptr_t</a></li>
</ul>

<p>
VTK Smart Pointers: 
</p>

<ul class="org-ul">
<li><a href="https://vtk.org/Wiki/VTK/Tutorials/SmartPointers">Vtk SmartPointers</a></li>
</ul>

<p>
Poco Framework 
</p>

<ul class="org-ul">
<li><a href="https://pocoproject.org/docs/Poco.SharedPtr.html">Poco.SharedPtr</a></li>
</ul>

<p>
ARM Mbed 
</p>

<ul class="org-ul">
<li><a href="https://os.mbed.com/docs/mbed-os/v5.13/apis/shared-pointer.html">Shared Pointer</a></li>
</ul>

<p>
Misc - Found in Github
</p>

<ul class="org-ul">
<li><a href="https://github.com/mariano-perez-rodriguez/value_ptr">value_ptr</a> - "A value semantics smart pointer for C++"</li>

<li><a href="https://github.com/martinmoene/value-ptr-lite">value-ptr-lite</a> - "value-ptr-lite - A C++ smart-pointer with value
semantics for C++98, C++11 and later in a single-file header-only
library"</li>

<li><a href="https://github.com/loopperfect/valuable">valuable</a> - "A C++ smart-pointer with value-semantics."</li>

<li><a href="https://github.com/martong/rcu_ptr">rcu_ptr</a> - "A special smart pointer to exchange data between
threads"</li>

<li><a href="https://github.com/Corralx/tag_ptr">tag_ptr</a> - "This is a simple C++11 implementation of a tagged
pointer, that allows to use the least significant bits in a
pointer to save a payload, generally called tag. It does so by
exploiting the alignment of types in memory."</li>

<li><a href="https://github.com/scottslacksmith/any_ptr">any_ptr</a> - "any_ptr and any_shared_ptr are 2 C++ containers for
storing pointers to heterogeneous types that, unlike std::any,
preserves normal pointer behaviour."</li>

<li><a href="https://github.com/dzitkowskik/CUDA-smart-pointers">CUDA-smart-pointers</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgc5af499" class="outline-4">
<h4 id="orgc5af499"><span class="section-number-4">1.28.4</span> Documentation Links</h4>
<div class="outline-text-4" id="text-1-28-4">
<p>
Header File: 
</p>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/memory">&lt;memory&gt;</a></li>
</ul>

<p>
Smart Pointer Classes: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a></li>

<li><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a></li>

<li><a href="https://en.cppreference.com/w/cpp/memory/weak_ptr">std::weak_ptr</a></li>
</ul>

<p>
Helper Functions for Smart Pointer Instatitation: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique">std::make_unique</a> - Prefered way of instantiating unique ptr.</li>

<li><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared">std::make_shared</a> - Function for instantiating shared pointers.</li>

<li><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast">Pointer casting function</a>
<ul class="org-ul">
<li>Functions:
<ul class="org-ul">
<li>std::static_pointer_cast</li>
<li>std::dynamic_pointer_cast</li>
<li>std::const_pointer_cast</li>
<li>std::reinterpret_pointer_cast</li>
</ul></li>
</ul></li>
</ul>

<p>
Related Concepts: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/pimpl">pimpl idiom</a></li>

<li><a href="https://en.cppreference.com/w/cpp/language/type#Incomplete_type">Incomplete type</a></li>

<li><a href="https://en.cppreference.com/w/cpp/language/destructor#Virtual_destructors">Virtual Destructors</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6779604" class="outline-4">
<h4 id="org6779604"><span class="section-number-4">1.28.5</span> std::unique_ptr</h4>
<div class="outline-text-4" id="text-1-28-5">
<p>
Single ownership, movable-only and non-copiable smart pointer. 
</p>

<ul class="org-ul">
<li>Header file: <a href="https://en.cppreference.com/w/cpp/memory">&lt;memory&gt;</a></li>
<li>Documentation: <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">unique_ptr</a></li>
</ul>

<p>
<b>Use Cases</b> 
</p>

<ul class="org-ul">
<li>Factory functions that instantiates dynamically allocated
polymorphic objects.</li>

<li>The lifetime of the managed object depends only on the lifetime of
a single object or only a single objects need a copy of the
pointer, one to one relationship.</li>

<li>Pimpl design pattern.</li>
</ul>


<p>
<b>Class template declaration</b> 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-keyword">typename</span> <span class="org-type">T</span>
         ,<span class="org-keyword">typename</span> <span class="org-type">Deleter</span> = <span class="org-constant">std</span>::<span class="org-type">default_delete</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
         <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span>; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Array version </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-keyword">typename</span> <span class="org-type">T</span>
         ,<span class="org-keyword">typename</span> <span class="org-type">Deleter</span> = <span class="org-constant">std</span>::<span class="org-type">default_delete</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
         <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span>&lt;<span class="org-type">T</span> <span class="org-rainbow-delimiters-depth-1">[]</span>, <span class="org-type">Deleter</span>; 
</pre>
</div>

<p>
<b>Member Function Table</b> 
</p>

<p>
Member functions of <code>std::unique_ptr&lt;T, Deleter&gt;</code>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function signature</th>
<th scope="col" class="org-left">Return</th>
<th scope="col" class="org-left">Description</th>
</tr>

<tr>
<th scope="col" class="org-left">with parameters</th>
<th scope="col" class="org-left">type</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>Constructor</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">unique_ptr() noexcept</td>
<td class="org-left">-</td>
<td class="org-left">Default constructor</td>
</tr>

<tr>
<td class="org-left">unique_ptr(nullptr) noexcept</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">unique_ptr(T* pointer)</td>
<td class="org-left">-</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#x2026; &#x2026; &#x2026; ..</td>
<td class="org-left">-</td>
<td class="org-left">Many others</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>Observers</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">get() const noexcept</td>
<td class="org-left">T*</td>
<td class="org-left">Return pointer to managed object or nullptr if it owns no object.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>Modifiers</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">release() noexcept</td>
<td class="org-left">T*</td>
<td class="org-left">Deletes the managed object, release the memory allocated for it.</td>
</tr>

<tr>
<td class="org-left">reset(T* ptr)</td>
<td class="org-left">void</td>
<td class="org-left">Replaces the managed object by a new one, deleting the old object.</td>
</tr>

<tr>
<td class="org-left">swap(unique_ptr&lt;T&gt;&amp; other)</td>
<td class="org-left">void</td>
<td class="org-left">Swaps the managed objects of two unique_ptr's</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>Operators</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">operator*() const</td>
<td class="org-left">T&amp;</td>
<td class="org-left">Dereference: Get reference to managed object</td>
</tr>

<tr>
<td class="org-left">operator-&gt;() const noexcept</td>
<td class="org-left">T*</td>
<td class="org-left">Dereference: Access managed object member functions.</td>
</tr>

<tr>
<td class="org-left">operator bool() const noexcept</td>
<td class="org-left">bool</td>
<td class="org-left">Returns true if there is a managed object. Used for if(ptr) { &#x2026; not null &#x2026;}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Helper functions (not member Functions): 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function signature</th>
<th scope="col" class="org-left">Return Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">std::make_unique&lt;T&gt;(Args &#x2026;)</td>
<td class="org-left">UP&lt;T&gt;</td>
<td class="org-left">Creates a new unique_ptr (preferred.)</td>
</tr>

<tr>
<td class="org-left">std::allocate_shared</td>
<td class="org-left">-</td>
<td class="org-left">Same as make_unique, but with a custom allocator.</td>
</tr>

<tr>
<td class="org-left">std::swap(UP&lt;T&gt;&amp; lhs, UP&lt;T&gt;&amp; rhs)</td>
<td class="org-left">void</td>
<td class="org-left">Swap managed objects of two unique_ptr's</td>
</tr>

<tr>
<td class="org-left">operator &lt;&lt;(OS&amp; os, std::unique_ptr&lt;T&gt;)</td>
<td class="org-left">OS&amp;</td>
<td class="org-left">Print managed object to output stream (C++20)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Note: The following type synonym were used to describe the signatures
in a concise way: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">using</span> <span class="org-type">UP</span> = <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>; 
<span class="org-keyword">using</span> <span class="org-type">OS</span> = <span class="org-constant">std</span>::ostream;
</pre>
</div>


<p>
<b>Simplified Member Functions Signatures</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-keyword">typename</span> <span class="org-type">T</span>
         ,<span class="org-keyword">typename</span> <span class="org-type">Deleter</span> = <span class="org-constant">std</span>::<span class="org-type">default_delete</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
         <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">unique_ptr</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Internal raw owning pointer that points to a heap-allocated object.</span>
    <span class="org-type">T</span>* <span class="org-variable-name">m_ptr</span> = <span class="org-constant">nullptr</span>;
<span class="org-function-name">public</span>:
    <span class="org-comment-delimiter">//</span><span class="org-comment">----- Constructors --------------------------//</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">---------------------------------------------//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Default ctor</span>
    <span class="org-function-name">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Overload ctor1 - construct from a owning pointer</span>
    <span class="org-function-name">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>* <span class="org-variable-name">ptr</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Move ctor</span>
    <span class="org-function-name">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_ptr</span>&amp;&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Move assignment operator deleted</span>
    <span class="org-type">unique_ptr</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_ptr</span>&amp;&amp; <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">noexcept</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Copy ctor deleted =&gt; Smart pointer non-copiable</span>
    <span class="org-function-name">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_ptr</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Copy assignment operator deleted =&gt; Smart pointer non-copiable</span>
    <span class="org-type">unique_ptr</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_ptr</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Destructor</span>
    ~<span class="org-function-name">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-comment-delimiter">//</span><span class="org-comment">--- Operator Overloading Member Functions ------//</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">-----------------------------------------------//</span>
    <span class="org-type">T</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">*</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span>;
    <span class="org-type">T</span>* <span class="org-keyword">operator</span><span class="org-function-name">-&gt;</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">noexcept</span>;
    <span class="org-keyword">operator</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;

    <span class="org-comment-delimiter">//</span><span class="org-comment">---- Ordinary Member Functions -----------------//</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">------------------------------------------------//</span>
    <span class="org-type">T</span>*   <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">()</span>                    <span class="org-keyword">const</span> <span class="org-keyword">noexcept</span>;
    <span class="org-type">T</span>*   <span class="org-function-name">release</span><span class="org-rainbow-delimiters-depth-2">()</span>                <span class="org-keyword">noexcept</span>;
    <span class="org-type">void</span> <span class="org-function-name">reset</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>* <span class="org-variable-name">new_object</span><span class="org-rainbow-delimiters-depth-2">)</span>     <span class="org-keyword">noexcept</span>;
    <span class="org-type">void</span> <span class="org-function-name">swap</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">noexcept</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Member Functions in Detail</b>
</p>

<ul class="org-ul">
<li>Default constructor - initialized to nullptr.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr;
</pre>
</div>

<ul class="org-ul">
<li>Constructors:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">Type</span><span class="org-rainbow-delimiters-depth-2">{</span>args ...<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li><b>std::make_unique</b> - alternaitve to constructor</li>
<li>Intialization through helper function std::make_unique (C++14)
<ul class="org-ul">
<li>Note: It is not recomended to initialized a smart pointer
directly through constructor.</li>
</ul></li>
</ul>

<p>
Allocating single object: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Args are constructor arguments.</span>
<span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr = <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-1">&gt;(</span>args, ....<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Allocating array: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr = <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>;
</pre>
</div>


<p>
Or: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">ptr</span> = <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-1">&gt;(</span>args, ....<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Definition: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span>, <span class="org-keyword">typename</span>... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-function-name">make_unique</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Args</span> &amp;&amp;... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> <span class="org-constant">std</span>::unique_ptr<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-keyword">new</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::forward<span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-4">&gt;(</span>args<span class="org-rainbow-delimiters-depth-4">)</span>...<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Move constructor:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-1">&gt;</span> old_ptr<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">Type</span><span class="org-rainbow-delimiters-depth-2">{</span>args ...<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Move ctor initialized from an old pointer. </span>
<span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-2">(</span>old_ptr<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<ul class="org-ul">
<li>Move assignment.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-1">&gt;</span> old_ptr<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">Type</span><span class="org-rainbow-delimiters-depth-2">{</span>args ...<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr;

ptr = <span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-1">(</span>old_ptr<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>Delete pointed object, releasing its memory.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">ptr</span> = <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-1">&gt;(</span>args, ....<span class="org-rainbow-delimiters-depth-1">)</span>;   

ptr.reset<span class="org-rainbow-delimiters-depth-1">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Delete heap-allocated object releasing memory and</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">resetting the pointer.</span>
</pre>
</div>

<ul class="org-ul">
<li>Check whether the pointer is null or not.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">ptr</span> = <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-1">&lt;</span>Type<span class="org-rainbow-delimiters-depth-1">&gt;(</span>args, ....<span class="org-rainbow-delimiters-depth-1">)</span>;   

<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptr<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Pointer is null"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Pointer is not null"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptr == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Pointer is null"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Pointer is not null"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org89b1e3a" class="outline-4">
<h4 id="org89b1e3a"><span class="section-number-4">1.28.6</span> std::shared_ptr</h4>
<div class="outline-text-4" id="text-1-28-6">
<p>
shared_ptr is a smart pointer that provides shared ownership semantics
and memory management through reference counting. This class contains
two parts, a pointer to the managed object (heap-allocated object) and
a heap-allocated control block which is shared by all smart pointers
owning the same object and contains a reference counter. 
</p>

<p>
Whenever a copy of the smart happens, the reference counter in the
shared control block is incremented by one. Whenever any smart pointer,
that manages a common object, is deleted when it goes out scope, the
reference counter is decremented by one. When reference counter
reaches zero, the owned object and the control block are disposed. 
</p>

<p>
Use cases: 
</p>

<ul class="org-ul">
<li>Emulate the experience of a language with garbage collection.</li>

<li>Polymorphic object that will be referred by many other objects, in
other words, many other objects need a copy of the pointer to the
polymorphic object.</li>

<li>Instantiation of large objects that cannot fit in the stack.</li>
</ul>

<p>
<b>Header</b> 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/memory">&lt;memory&gt;</a></li>
</ul>

<p>
<b>Documentation</b> 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> (Cppreference)</li>

<li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/shared-ptr-class?view=vs-2019">std::shared_ptr</a> (Microsft)</li>

<li><a href="https://docs.microsoft.com/en-us/cpp/cpp/how-to-create-and-use-shared-ptr-instances?view=vs-2019">How to: Create and Use shared_ptr Instances</a> (Microsft)</li>

<li><a href="https://www.boost.org/doc/libs/1_70_0/libs/smart_ptr/doc/html/smart_ptr.html#shared_ptr">boost:shared_ptr</a> (Predecessor, pre-C++11)</li>
</ul>


<p>
<b>Simplified Member Functions</b> of std::shared_ptr&lt;T&gt;
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Member function</th>
<th scope="col" class="org-left">Return</th>
<th scope="col" class="org-left">Description</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">type</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>Most relevant constructors</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">shared_ptr()</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Default constructor, initialize with nullptr.</td>
</tr>

<tr>
<td class="org-left">shared_ptr( std::nullptr_t )</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">shared_ptr(T* )</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Initialize with <span class="underline">new</span> keyword.</td>
</tr>

<tr>
<td class="org-left">std::shared_ptr(std::unique_ptr&lt;T&gt;&amp;&amp; r)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Initialize with a unique_ptr R-value.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><b>Observers</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">get() const</td>
<td class="org-left">T*</td>
<td class="org-left">Return pointer to owned object.</td>
</tr>

<tr>
<td class="org-left">use_count()</td>
<td class="org-left">long</td>
<td class="org-left">Value of reference counter</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">operator bool()</td>
<td class="org-left">bool</td>
<td class="org-left">Checks whether the pointer is not null. if(ptr) { &#x2026; }</td>
</tr>

<tr>
<td class="org-left">operator*() const</td>
<td class="org-left">T&amp;</td>
<td class="org-left">Dereference operator. Return reference to owned object.</td>
</tr>

<tr>
<td class="org-left">operator-&gt;() const</td>
<td class="org-left">T*</td>
<td class="org-left">Dereference operator. Access member function of managed object.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><b>Modifier</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">reset()</td>
<td class="org-left">void</td>
<td class="org-left">Replace the current managed object by this pointer by nullptr.</td>
</tr>

<tr>
<td class="org-left">reset(T* ptr)</td>
<td class="org-left">void</td>
<td class="org-left">Replace the current managed object by this pointer by ptr.</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Note: 
</p>

<ul class="org-ul">
<li>use_count() returns the number of shared_ptr managing the same
heap-allocated object, in other words, it returns the value of the
reference counter. When it reaches zero, the shared_ptr object owns
no object or does not manage any object.</li>

<li>reset() and reset(T*) members only deletes the current managed
object, if there are any other std::shared_ptr using it.</li>
</ul>


<p>
<b>Simplified Member Functions Signature</b> 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">shared_ptr</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">..... omit private part  ... //</span>
<span class="org-function-name">public</span>:

    <span class="org-comment-delimiter">//</span><span class="org-comment">----- Constructors --------------------------//</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">---------------------------------------------//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Default ctor</span>
    <span class="org-function-name">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Overload ctor1 - construct from a owning pointer</span>
    <span class="org-function-name">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>* <span class="org-variable-name">ptr</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Move ctor</span>
    <span class="org-function-name">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">shared_ptr</span>&amp;&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Move assignment operator</span>
    <span class="org-type">shared_ptr</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">shared_ptr</span>&amp;&amp; <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Copy ctor</span>
    <span class="org-function-name">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">shared_ptr</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Copy assignment operator</span>
    <span class="org-type">shared_ptr</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">shared_ptr</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Destructor</span>
    ~<span class="org-function-name">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-comment-delimiter">//</span><span class="org-comment">--- Operator Overloading Member Functions ------//</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">-----------------------------------------------//</span>
    <span class="org-type">T</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">*</span><span class="org-rainbow-delimiters-depth-2">()</span>  <span class="org-keyword">const</span>;
    <span class="org-type">T</span>* <span class="org-keyword">operator</span><span class="org-function-name">-&gt;</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">noexcept</span>;    
    <span class="org-keyword">operator</span> <span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;

    <span class="org-comment-delimiter">//</span><span class="org-comment">---- Ordinary Member Functions -----------------//</span>
    <span class="org-comment-delimiter">//</span><span class="org-comment">------------------------------------------------//</span>

    <span class="org-type">long</span>  <span class="org-function-name">use_count</span><span class="org-rainbow-delimiters-depth-2">()</span>              <span class="org-keyword">const</span> <span class="org-keyword">noexcept</span>;
    <span class="org-type">T</span>*    <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">()</span>                    <span class="org-keyword">const</span> <span class="org-keyword">noexcept</span>;
    <span class="org-type">T</span>*    <span class="org-function-name">release</span><span class="org-rainbow-delimiters-depth-2">()</span>                <span class="org-keyword">noexcept</span>;
    <span class="org-type">void</span>  <span class="org-function-name">reset</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>* <span class="org-variable-name">new_object</span><span class="org-rainbow-delimiters-depth-2">)</span>     <span class="org-keyword">noexcept</span>;
    <span class="org-type">void</span>  <span class="org-function-name">swap</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">rhs</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">noexcept</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Non Member Functions</b> 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-keyword">class</span> <span class="org-type">T</span>, <span class="org-keyword">class</span>... <span class="org-type">Args</span> <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-function-name">make_shared</span><span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-type">Args</span>&amp;&amp;... <span class="org-variable-name">args</span> <span class="org-rainbow-delimiters-depth-1">)</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">Since C++11 </span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-function-name">make_shared</span><span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-constant">std</span>::<span class="org-type">size_t</span> <span class="org-variable-name">N</span> <span class="org-rainbow-delimiters-depth-1">)</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">Since C++20 </span>

 <span class="org-comment-delimiter">// </span><span class="org-comment">... many other operators ... // </span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-keyword">class</span> <span class="org-type">T</span> <span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">==</span><span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-constant">std</span>::<span class="org-type">nullptr_t</span> <span class="org-variable-name">lhs</span>, <span class="org-keyword">const</span> <span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">rhs</span> <span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">noexcept</span>;

<span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span> <span class="org-keyword">class</span> <span class="org-type">T</span>, <span class="org-keyword">class</span> <span class="org-type">U</span> <span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">==</span><span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-keyword">const</span> <span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">lhs</span>, <span class="org-keyword">const</span> <span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">U</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">rhs</span> <span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">noexcept</span>;
</pre>
</div>

<p>
<b>Basics - How it works</b> 
</p>

<ul class="org-ul">
<li>When a shared_ptr owns not object or is default initialized or
initialized with nullptr, the reference counter is set to zero.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Reference counter is zero </span>
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>AClass<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr1;
<span class="org-comment-delimiter">// </span><span class="org-comment">.use_counter =&gt; Return the value of the reference counter.</span>
assert<span class="org-rainbow-delimiters-depth-1">(</span>ptr.use_counter<span class="org-rainbow-delimiters-depth-2">()</span> == 0<span class="org-rainbow-delimiters-depth-1">)</span> ; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Reference counter is zero, the ptr2 object owns anything</span>
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>AClass<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr2 = <span class="org-constant">nullptr</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>ptr2.use_counter<span class="org-rainbow-delimiters-depth-2">()</span> == 0<span class="org-rainbow-delimiters-depth-1">)</span> ; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Reference counter is zero </span>
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>AClass<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr2<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">}</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>ptr2.use_counter<span class="org-rainbow-delimiters-depth-2">()</span> == 0<span class="org-rainbow-delimiters-depth-1">)</span> ; 
</pre>
</div>

<ul class="org-ul">
<li>When a shared_ptr is initialized (not default initialized, copy or
move initialization) with <span class="underline">new</span> keyword or std::make_shared, the
reference counter is set to 1, the member function <span class="underline">use_count</span>
returns 1.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">AClass</span><span class="org-rainbow-delimiters-depth-1">{</span> 
<span class="org-function-name">public</span>:
   ... ... ... 
   <span class="org-type">void</span> method1<span class="org-rainbow-delimiters-depth-2">(){</span> ... .<span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-type">void</span> <span class="org-function-name">method2</span><span class="org-rainbow-delimiters-depth-2">(){</span> .... .. <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Not: recommended (AVOID)</span>
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">AClass</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> cls<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">AClass</span>&gt;<span class="org-rainbow-delimiters-depth-2">(</span>arg0, arg1, arg2 ...<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>ptr.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 1<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Call methods just like it would be with an ordinary pointer </span>
ptr-&gt;method1<span class="org-rainbow-delimiters-depth-1">()</span>; 
ptr-&gt;method2<span class="org-rainbow-delimiters-depth-1">()</span>; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Get a reference to the object: </span>
<span class="org-type">AClass</span> <span class="org-type">ref</span>&amp; = *ptr;

<span class="org-comment-delimiter">// </span><span class="org-comment">Best </span>
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">AClass</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> cls =  <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">AClass</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>arg0, arg1, arg2 ...<span class="org-rainbow-delimiters-depth-1">)</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>ptr.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 1<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Best </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">cls</span> =  <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">AClass</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>arg0, arg1, arg2 ...<span class="org-rainbow-delimiters-depth-1">)</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>ptr.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 1<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>When a copy of a shared_ptr object is performed, the reference
counter is incremented and when a copy object goes out of scope,
the reference counter is decremented.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>AClass<span class="org-rainbow-delimiters-depth-1">&gt;</span> cls =  <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span>AClass<span class="org-rainbow-delimiters-depth-1">&gt;(</span>arg0, arg1, arg2 ...<span class="org-rainbow-delimiters-depth-1">)</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>ptr.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 1<span class="org-rainbow-delimiters-depth-1">)</span>;

cls-&gt;CallMethod1OfAClass<span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-rainbow-delimiters-depth-1">{</span> 
   <span class="org-comment-delimiter">// </span><span class="org-comment">Copy constructor of std::shared_ptr&lt;T&gt; called </span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; Incremente reference counter by 1 </span>
   <span class="org-keyword">auto</span> <span class="org-variable-name">copy1</span> =  cls; 
   assert<span class="org-rainbow-delimiters-depth-2">(</span>ptr.use_count<span class="org-rainbow-delimiters-depth-3">()</span> == 2<span class="org-rainbow-delimiters-depth-2">)</span>;   
   assert<span class="org-rainbow-delimiters-depth-2">(</span>copy1.use_count<span class="org-rainbow-delimiters-depth-3">()</span> == 2<span class="org-rainbow-delimiters-depth-2">)</span>;   

  <span class="org-rainbow-delimiters-depth-2">{</span>
     <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>AClass<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">copy2</span>; 
     assert<span class="org-rainbow-delimiters-depth-3">(</span>copy2.use_count<span class="org-rainbow-delimiters-depth-4">()</span> == 0<span class="org-rainbow-delimiters-depth-3">)</span>;

     <span class="org-comment-delimiter">// </span><span class="org-comment">Call move assignment operator of std::shared&lt;T&gt; </span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">Increment reference counter. </span>
     copy2 = cls;
     assert<span class="org-rainbow-delimiters-depth-3">(</span>copy2.use_count<span class="org-rainbow-delimiters-depth-4">()</span> == 3<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Object: copy2 =&gt; Destroyed here, decremente ref counter by 1 </span>
  assert<span class="org-rainbow-delimiters-depth-2">(</span>cls.use_count<span class="org-rainbow-delimiters-depth-3">()</span> == 2<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Object copy1 destroyed here (end of its scope), decremente </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">counter by one. </span>
assert<span class="org-rainbow-delimiters-depth-1">(</span>cls.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 1<span class="org-rainbow-delimiters-depth-1">)</span>;  

<span class="org-comment-delimiter">// </span><span class="org-comment">Decremente control block by 1, when it reaches zero, </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the control block and the managed object are destroyed.</span>
cls = <span class="org-constant">nullptr</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>cls.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 0<span class="org-rainbow-delimiters-depth-1">)</span>;  
<span class="org-comment-delimiter">// </span><span class="org-comment">Or: </span>
cls.reset<span class="org-rainbow-delimiters-depth-1">()</span>; 
assert<span class="org-rainbow-delimiters-depth-1">(</span>cls.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 0<span class="org-rainbow-delimiters-depth-1">)</span>;  
</pre>
</div>

<ul class="org-ul">
<li>The shared managed object and the control block are only disposed
when the number of shared_ptr objects owning the managed objects
is zero, in other words, the reference counter equal to zero.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">cls</span> =  <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span>AClass<span class="org-rainbow-delimiters-depth-1">&gt;(</span>arg0, arg1, arg2 ...<span class="org-rainbow-delimiters-depth-1">)</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>ptr.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 1<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>AClass<span class="org-rainbow-delimiters-depth-1">&gt;</span> copy1<span class="org-rainbow-delimiters-depth-1">{</span>cls<span class="org-rainbow-delimiters-depth-1">}</span>; 
assert<span class="org-rainbow-delimiters-depth-1">(</span>cls.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 2<span class="org-rainbow-delimiters-depth-1">)</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>copy1.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 2<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Reference counter decremented and cls set nullptr. </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">However, the shared control block and the managed object </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">were not deleted as they are still used by object 'copy1'. </span>
cls = <span class="org-constant">nullptr</span>; 
assert<span class="org-rainbow-delimiters-depth-1">(</span>cls.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 0<span class="org-rainbow-delimiters-depth-1">)</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>copy1.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 1<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Reference counter decremented, now it reaches zero and both the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">control block and the managed (heap-allocated) object are deleted</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">as they are no longer used by any other shared_ptr.</span>
copy1 = <span class="org-constant">nullptr</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>copy.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 0<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfc61e65" class="outline-4">
<h4 id="orgfc61e65"><span class="section-number-4">1.28.7</span> Best practices and things to avoid for std::shared_ptr</h4>
<div class="outline-text-4" id="text-1-28-7">
<p>
<b>Initialization of shared_ptr</b> 
</p>

<p>
Instead of: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>SomeType<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr<span class="org-rainbow-delimiters-depth-1">{</span><span class="org-keyword">new</span> <span class="org-type">SomeType</span><span class="org-rainbow-delimiters-depth-2">(</span>arg0, arg1, ..., argN<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Better: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>SomeType<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span>SomeType<span class="org-rainbow-delimiters-depth-1">&gt;(</span>arg0, arg1, ..., argN<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Or even better: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">ptr</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span>SomeType<span class="org-rainbow-delimiters-depth-1">&gt;(</span>arg0, arg1, ..., argN<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>


<p>
<b>Polymorphic objects and containers</b> 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">IBase</span><span class="org-rainbow-delimiters-depth-1">(){</span>
<span class="org-function-name">public</span>:
   <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-variable-name">method1</span><span class="org-rainbow-delimiters-depth-2">()</span> = 0;
   ~IInterface<span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">ClassA</span>: <span class="org-keyword">public</span> <span class="org-type">IBase</span> <span class="org-rainbow-delimiters-depth-1">{</span>
     ... ... 
<span class="org-rainbow-delimiters-depth-1">}</span>; 

<span class="org-keyword">class</span> <span class="org-type">ClassB</span>: <span class="org-keyword">public</span> <span class="org-type">IBase</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    .. ... ...
<span class="org-rainbow-delimiters-depth-1">}</span>; 
   ... ... ... .. 
</pre>
</div>

<p>
Instead of: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>IBase<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">dataset</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">new</span> <span class="org-type">ClassA</span><span class="org-rainbow-delimiters-depth-2">()</span>, <span class="org-keyword">new</span> <span class="org-type">ClasB</span><span class="org-rainbow-delimiters-depth-2">(</span>param0, param1, ...<span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-keyword">new</span> <span class="org-type">Class</span> C, ... <span class="org-rainbow-delimiters-depth-1">}</span>;
 dataset.push_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">ClassA</span><span class="org-rainbow-delimiters-depth-2">(</span>param0, param1, ..., paramN<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
 dataset.push_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">ClassB</span><span class="org-rainbow-delimiters-depth-2">(</span>param0, param1, ..., paramN<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183; omit &#183;&#183;&#183; &#183;&#183;&#183; &#183;&#183;&#183;&#183; </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Dispose: </span>
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-variable-name">ptr</span>: dataset<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">delete</span> ptr; <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Better: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>IBase<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">dataset</span> <span class="org-rainbow-delimiters-depth-1">{</span> 
      <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>ClassA<span class="org-rainbow-delimiters-depth-2">&gt;()</span>, 
      <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>ClassB<span class="org-rainbow-delimiters-depth-2">&gt;(</span>param0, param1, ...<span class="org-rainbow-delimiters-depth-2">)</span>,
      <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>ClassC<span class="org-rainbow-delimiters-depth-2">&gt;()</span>, 
      ... 
<span class="org-rainbow-delimiters-depth-1">}</span>;
dataset.push_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>ClassA<span class="org-rainbow-delimiters-depth-2">&gt;(</span>param0, param1, ..., paramN<span class="org-rainbow-delimiters-depth-2">)</span>;
dataset.push_back<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-3">&lt;</span>ClassB<span class="org-rainbow-delimiters-depth-3">&gt;(</span>param0, param1, ..., paramN<span class="org-rainbow-delimiters-depth-3">)</span>;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span> <span class="org-type">cosnt</span>&amp; <span class="org-variable-name">ptr</span>: dataset<span class="org-rainbow-delimiters-depth-3">){</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">iterate over a container with polymorphic objects ... </span>
   ... ... ... ... ... 
<span class="org-rainbow-delimiters-depth-3">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">.... Disposed automatically ... </span>
</pre>
</div>

<p>
Or simplified with: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Type alias </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">using</span> <span class="org-type">sh</span> = <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">sh</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>IBase<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> dataset <span class="org-rainbow-delimiters-depth-1">{</span> 
      <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>ClassA<span class="org-rainbow-delimiters-depth-2">&gt;()</span>, 
      <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>ClassB<span class="org-rainbow-delimiters-depth-2">&gt;(</span>param0, param1, ...<span class="org-rainbow-delimiters-depth-2">)</span>,
      <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>ClassC<span class="org-rainbow-delimiters-depth-2">&gt;()</span>, 
      ... 
<span class="org-rainbow-delimiters-depth-1">}</span>; 
 ... ... ... ... ... 
</pre>
</div>

<p>
It could also be written as:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">using</span> <span class="org-type">shared_vector</span> = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-type">shared_vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">dataset</span> <span class="org-rainbow-delimiters-depth-1">{</span> 
      <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>ClassA<span class="org-rainbow-delimiters-depth-2">&gt;()</span>, 
      <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>ClassB<span class="org-rainbow-delimiters-depth-2">&gt;(</span>param0, param1, ...<span class="org-rainbow-delimiters-depth-2">)</span>,
      <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>ClassC<span class="org-rainbow-delimiters-depth-2">&gt;()</span>, 
      ... 
<span class="org-rainbow-delimiters-depth-1">}</span>; 

<span class="org-comment-delimiter">// </span><span class="org-comment">... ... ... // </span>
</pre>
</div>


<p>
<b>Free Functions and member parameter passing</b> 
</p>

<p>
If the function only needs to query or modify the managed object and
does not need to know anything about the shared_ptr, pass by
reference, const reference or by pointer in the case that null pointer
is acceptable. Functions with those types of arguments will be able to
work with ordinary values, dumb pointers and any type of smart pointers.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">someModifierFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">AType</span>&amp; <span class="org-variable-name">obj1</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" id = "</span> &lt;&lt; obj1.id<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl; 
   obj1.setName<span class="org-rainbow-delimiters-depth-2">(</span>new_name<span class="org-rainbow-delimiters-depth-2">)</span>; 
   obj1.display<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">someConstFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">AType</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">obj1</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" id = "</span> &lt;&lt; obj1.id<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl; 
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">somePointerFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">AType</span>* <span class="org-variable-name">pobj1</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>pobj1<span class="org-rainbow-delimiters-depth-2">){</span>
       <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Supplied null pointer"</span>  &lt;&lt; <span class="org-constant">std</span>::endl;
       <span class="org-keyword">return</span>; 
   <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" id = "</span> &lt;&lt; pobj1-&gt;id<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl; 
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">auto</span> <span class="org-variable-name">ptr</span> = <span class="org-constant">std</span>::make_shared_ptr<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">AType</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>Arg0, Arg1, ... ArgN<span class="org-rainbow-delimiters-depth-1">)</span>; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Passing ptr to functions </span>
someModifierFunction<span class="org-rainbow-delimiters-depth-1">(</span>*ptr<span class="org-rainbow-delimiters-depth-1">)</span>;
someConstFunction<span class="org-rainbow-delimiters-depth-1">(</span>*ptr<span class="org-rainbow-delimiters-depth-1">)</span>;
somePointerFunction<span class="org-rainbow-delimiters-depth-1">(</span>ptr,get<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Avoid passing the shared pointer by value, if taking ownership, in
other words, storing a copy of the pointer is not needed as the copy
increments the reference counter incurring on a performance overhead. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">AVOID </span>
<span class="org-type">void</span> <span class="org-function-name">someFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>T<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">ptr</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">... incremente atomic reference counter ... </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">... . .. // </span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Only pass by reference to shared_ptr if the function needs to know
about the pointer and does not need to take any ownership (storing a
copy of the pointer for later reference).
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">function_that_needs_to_know_about_ptr</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>T<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ptr</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Ref count value = "</span> &lt;&lt; ptr.use_count<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Address = "</span> &lt;&lt; ptr.get<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Value returned by object's member function = "</span> &lt;&lt; ptr-&gt;memberFunction<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Ownership</b> 
</p>

<p>
Avoid: 
</p>

<ul class="org-ul">
<li>The following class needs to store a copy of a pointer to polymorphic
class for later reference and it is responsible for disposing the
resource during its destruction. In other words, it takes ownership
of the resource.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">ClassThatTakesOwnership</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
   <span class="org-comment-delimiter">// </span><span class="org-comment">Pointer to heap-allocated instance of polymorphic class </span>
   <span class="org-type">IInterface</span>* <span class="org-variable-name">m_ptr</span>;

<span class="org-function-name">public</span>: 
   <span class="org-function-name">ClassThatTakesOwnership</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IInterface</span>* <span class="org-variable-name">ptr</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">m_ptr</span><span class="org-rainbow-delimiters-depth-2">(</span>ptr<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>  <span class="org-rainbow-delimiters-depth-2">}</span> 

   ~<span class="org-function-name">ClassThatTakesOwnership</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
       <span class="org-keyword">delete</span> m_ptr; 
       m_ptr = <span class="org-constant">nullptr</span>; 
    <span class="org-rainbow-delimiters-depth-2">}</span>

   <span class="org-type">void</span> <span class="org-function-name">callLater</span><span class="org-rainbow-delimiters-depth-2">(){</span> 
      ptr-&gt;callMethod<span class="org-rainbow-delimiters-depth-3">()</span>; 
   <span class="org-rainbow-delimiters-depth-2">}</span>      
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">ClassThatTakesOwnership</span> <span class="org-variable-name">cls1</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-keyword">new</span> <span class="org-type">ImplementationA</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">NO! BROKEN!</span>
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">IInterface</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> obj = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span>ImplementationA<span class="org-rainbow-delimiters-depth-1">&gt;()</span>; 
<span class="org-comment-delimiter">// </span><span class="org-comment">NO FLAWED! </span>
<span class="org-type">ClassThatTakesOwnership</span> <span class="org-variable-name">cls2</span><span class="org-rainbow-delimiters-depth-1">{</span>obj.get<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Better:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">ClassThatTakesOwnership</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
   <span class="org-comment-delimiter">// </span><span class="org-comment">Pointer to heap-allocated instance of polymorphic class </span>
   <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>IInterface<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">m_ptr</span>;

<span class="org-function-name">public</span>: 
   <span class="org-function-name">ClassThatTakesOwnership</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>IInterface<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">ptr</span><span class="org-rainbow-delimiters-depth-2">)</span>
     : m_ptr<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>ptr<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>  <span class="org-rainbow-delimiters-depth-2">}</span> 

   <span class="org-type">void</span> <span class="org-function-name">callLater</span><span class="org-rainbow-delimiters-depth-2">(){</span> 
      ptr-&gt;callMethod<span class="org-rainbow-delimiters-depth-3">()</span>; 
   <span class="org-rainbow-delimiters-depth-2">}</span>      
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>IInterface<span class="org-rainbow-delimiters-depth-1">&gt;</span> obj = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span>ImplementationA<span class="org-rainbow-delimiters-depth-1">&gt;()</span>; 
<span class="org-type">ClassThatTakesOwnership</span> <span class="org-variable-name">cls1</span><span class="org-rainbow-delimiters-depth-1">{</span>obj<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">ClassThatTakesOwnership</span> <span class="org-variable-name">cls2</span><span class="org-rainbow-delimiters-depth-1">{</span><span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>ImplementationB<span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Factory functions</b> 
</p>

<p>
It is better to return std::unique_ptr from factory functions rather
than shared_ptr as the first is easily turned into the later and
opposite is more difficult. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">IInterface</span><span class="org-rainbow-delimiters-depth-1">(){</span>
<span class="org-function-name">public</span>:
   <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-variable-name">method1</span><span class="org-rainbow-delimiters-depth-2">()</span> = 0;
   ~<span class="org-variable-name">IInterface</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">ImplementationA</span>: <span class="org-keyword">public</span> <span class="org-type">IInterface</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">void</span> <span class="org-function-name">method1</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
      ... ... .. 
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>; 

<span class="org-keyword">class</span> <span class="org-type">ImplementationB</span>: <span class="org-keyword">public</span> <span class="org-type">IInterface</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">void</span> <span class="org-function-name">method1</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
      ... ... .. 
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>; 

<span class="org-keyword">auto</span> <span class="org-function-name">factoryFunction</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">IInterface</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>id == 1<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ImplementationA</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>id == 2<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">ImplementationB</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">----------- Usage ----------------------------</span>
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">IInterface</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> p_int1 = factoryFunction<span class="org-rainbow-delimiters-depth-1">(</span>1<span class="org-rainbow-delimiters-depth-1">)</span>; 
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">IInterface</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> p_int2 <span class="org-rainbow-delimiters-depth-1">{</span> factoryFunction<span class="org-rainbow-delimiters-depth-2">(</span>1<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Polymorphism and Casting of Shared Pointers</b> 
</p>

<p>
The functions std::static_pointer_cast, std::dynamic_pointer_cast,
std::const_pointer_cast and std::shared_pointer_cast from <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast">pointer_cast</a>
(cppreference) can be used for downcasting and runtime type
identification of polymorphic objects. 
</p>

<p>
Consider the hierarchy: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">IBase</span><span class="org-rainbow-delimiters-depth-1">(){</span>
<span class="org-function-name">public</span>:
   <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-variable-name">method1</span><span class="org-rainbow-delimiters-depth-2">()</span> = 0;
   ~IInterface<span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">ClassA</span>: <span class="org-keyword">public</span> <span class="org-type">IBase</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">void</span> <span class="org-function-name">method1</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
      ... ... .. 
   <span class="org-rainbow-delimiters-depth-2">}</span>

   <span class="org-type">void</span> <span class="org-function-name">methodExclusiveOfA</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span> .... <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>; 

<span class="org-keyword">class</span> <span class="org-type">ClassB</span>: <span class="org-keyword">public</span> <span class="org-type">IBase</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">void</span> <span class="org-function-name">method1</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
      ... ... .. 
   <span class="org-rainbow-delimiters-depth-2">}</span>

   <span class="org-type">void</span> <span class="org-function-name">methodExclusiveOfB</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span> ... <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>; 
</pre>
</div>

<p>
Create an instance of class A: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>IBase<span class="org-rainbow-delimiters-depth-1">&gt;</span> obj = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span>ClassA<span class="org-rainbow-delimiters-depth-1">&gt;(</span>obj<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li><b>Static casting</b> - Casting at compile time without any runtime
overhead, however, if the casting is not possible, it results in
undefined behavior just like what happens with static_cast for
pointers.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>A<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr_a = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-1">&lt;</span>A<span class="org-rainbow-delimiters-depth-1">&gt;(</span>obj<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptr_a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   ptr_a-&gt;method1<span class="org-rainbow-delimiters-depth-2">()</span>;
   ptr_a-&gt;methodExclusiveofA<span class="org-rainbow-delimiters-depth-2">()</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">**** WARNING!! UNDEFINED BEHAVIOR!! *****</span>
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>A<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr_b = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-1">&lt;</span>B<span class="org-rainbow-delimiters-depth-1">&gt;(</span>obj<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li><b>Dynamic Casting</b> - RTTI - Runtime Type Identification, if the
casting fails, the function <span class="underline">std::dynamic_pointer_cast</span> returns a
null pointer just like <span class="underline">dynamic_cast&lt;T&gt;</span> operator.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Increment reference counter by 1 if successful </span>
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>A<span class="org-rainbow-delimiters-depth-1">&gt;</span> ptr_a = <span class="org-constant">std</span>::dynamic_pointer_cast<span class="org-rainbow-delimiters-depth-1">&lt;</span>A<span class="org-rainbow-delimiters-depth-1">&gt;(</span>obj<span class="org-rainbow-delimiters-depth-1">)</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span> ptr_a != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptr_a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
   ptr_a-&gt;method1<span class="org-rainbow-delimiters-depth-2">()</span>;
   ptr_a-&gt;methodExclusiveofA<span class="org-rainbow-delimiters-depth-2">()</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">auto</span> <span class="org-variable-name">ptr_b</span> = <span class="org-constant">std</span>::dynamic_pointer_cast<span class="org-rainbow-delimiters-depth-1">&lt;</span>B<span class="org-rainbow-delimiters-depth-1">&gt;(</span>obj<span class="org-rainbow-delimiters-depth-1">)</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span> ptr_b == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>ptr_b<span class="org-rainbow-delimiters-depth-1">){</span>
   ptr_b-&gt;method1<span class="org-rainbow-delimiters-depth-2">()</span>;
   ptr_b-&gt;methodExclusiveofB<span class="org-rainbow-delimiters-depth-2">()</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org4a524ce" class="outline-4">
<h4 id="org4a524ce"><span class="section-number-4">1.28.8</span> Example: unique_ptr</h4>
<div class="outline-text-4" id="text-1-28-8">
<p>
Example: 
</p>

<ul class="org-ul">
<li>A car object has  only one engine, multiple cars cannot have the
same engine and the engine is destroyed when the car object is destroyed.</li>

<li>The engine is polymorphic object implementing the interface
IEngine.</li>

<li>The car object can replace the engine at runtime.</li>
</ul>

<p>
Full code: 
</p>
<ul class="org-ul">
<li><a href="src/smart_ptr_unique1.cpp">file:src/smart_ptr_unique1.cpp</a></li>
</ul>


<p>
Headers: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Provide std::unique_ptr and std::shared_ptr</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">memory</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
</pre>
</div>

<p>
Interface: IEngine
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Car Engine Interface</span>
<span class="org-keyword">class</span> <span class="org-type">IEngine</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span>        <span class="org-function-name">run</span><span class="org-rainbow-delimiters-depth-2">()</span>  = 0;
    <span class="org-comment-delimiter">// </span><span class="org-comment">virtual void        shutdown() = 0;</span>
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">IEngine</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Class DieselEngine implemeting the interface IEngine.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">DieselEngine</span>: <span class="org-keyword">public</span> <span class="org-type">IEngine</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-function-name">DieselEngine</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Diesel Engine created."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">DieselEngine</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Diesel Engine deleted."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-string">"diesel engine"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">run</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" Running a super powerful diesel Engine!!"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Class ElectricEngine implemeting the interface IEngine: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">ElectricEngine</span>: <span class="org-keyword">public</span> <span class="org-type">IEngine</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-function-name">ElectricEngine</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Electrict Engine created."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">ElectricEngine</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Electric Engine deleted."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-string">"electric engine"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">run</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" =&gt;&gt; Running a silent and clean electric engine!!"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Class SomeCar that contains an engine object implemeting the IEngine
interface. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-keyword">class</span> <span class="org-type">SomeCar</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
    <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>IEngine<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">m_engine</span>;
<span class="org-function-name">public</span>:

    <span class="org-function-name">SomeCar</span><span class="org-rainbow-delimiters-depth-2">()</span>: m_engine<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Constructor: Dependency injection</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; the dependency is supplied and instantiated</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">by an external code rather than being instantiated by this class.</span>
    <span class="org-function-name">SomeCar</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IEngine</span>* <span class="org-variable-name">obj</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">m_engine</span><span class="org-rainbow-delimiters-depth-2">(</span>obj<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Unique_ptr cannot be copied, they only can be moved.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">The std::move, transfers the ownership of the supplied std::unique_ptr</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">to this class.</span>
    <span class="org-function-name">SomeCar</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">IEngine</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">engine</span><span class="org-rainbow-delimiters-depth-2">)</span>
        : m_engine<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>engine<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">run_engine</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Run car engine."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Unique_ptr can be used just as an ordinary pointer</span>
        m_engine-&gt;run<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Set a new engine.</span>
    <span class="org-type">void</span> <span class="org-function-name">set_engine</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">IEngine</span>* <span class="org-variable-name">engine</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Disposes the old engine and sets a new one</span>
        m_engine.reset<span class="org-rainbow-delimiters-depth-3">(</span>engine<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">set_engine</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">IEngine</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">engine</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Calls move assingment operator disposing the old engine</span>
        m_engine  = <span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>engine<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">engine_type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> m_engine-&gt;type<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">remove_engine</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Delete wrapped heap-allocated object</span>
        m_engine.release<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Check if the car has an engine</span>
    <span class="org-type">bool</span> <span class="org-function-name">has_engine</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-keyword">return</span> m_engine != <span class="org-constant">nullptr</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">SomeCar</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] object of class SomeCar disposed. OK"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Factory function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>IEngine<span class="org-rainbow-delimiters-depth-1">&gt;</span>
factoryFunction<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span> <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>code == <span class="org-string">'e'</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>ElectricEngine<span class="org-rainbow-delimiters-depth-3">&gt;()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>code == <span class="org-string">'d'</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>DieselEngine<span class="org-rainbow-delimiters-depth-3">&gt;()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Main Function</b> - int main() 
</p>

<ul class="org-ul">
<li>Main Function - Experiment 0</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n ***** EXPERIENT 0 === Type Traits *********************\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"---------------------------------------------------------------\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;
<span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" is_abstract&lt;IEngine&gt;() = "</span>
              &lt;&lt; <span class="org-constant">std</span>::is_abstract<span class="org-rainbow-delimiters-depth-2">&lt;</span>IEngine<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" is_abstract&lt;ElectricEngine&gt;() = "</span>
              &lt;&lt; <span class="org-constant">std</span>::is_abstract<span class="org-rainbow-delimiters-depth-2">&lt;</span>ElectricEngine<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" is_fundamental&lt;ElectricEngine&gt;() = "</span>
              &lt;&lt; <span class="org-constant">std</span>::is_fundamental<span class="org-rainbow-delimiters-depth-2">&lt;</span>ElectricEngine<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" is_polymorphic&lt;ElectricEngine&gt;() = "</span>
              &lt;&lt; <span class="org-constant">std</span>::is_polymorphic<span class="org-rainbow-delimiters-depth-2">&lt;</span>ElectricEngine<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" is_trivially_copiable&lt;ElectricEngine() = "</span>
              &lt;&lt; <span class="org-constant">std</span>::is_trivially_copyable<span class="org-rainbow-delimiters-depth-2">&lt;</span>ElectricEngine<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" is_trivially_move_constructible&lt;ElectricEngine() = "</span>
              &lt;&lt; <span class="org-constant">std</span>::is_trivially_move_constructible<span class="org-rainbow-delimiters-depth-2">&lt;</span>ElectricEngine<span class="org-rainbow-delimiters-depth-2">&gt;()</span> &lt;&lt; <span class="org-string">"\n"</span>;

<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">***** EXPERIENT 0 === Type Traits *********************
---------------------------------------------------------------
 is_abstract&lt;IEngine&gt;() = true
 is_abstract&lt;ElectricEngine&gt;() = false
 is_fundamental&lt;ElectricEngine&gt;() = false
 is_polymorphic&lt;ElectricEngine&gt;() = true
 is_trivially_copiable&lt;ElectricEngine() = false
 is_trivially_move_constructible&lt;ElectricEngine() = false
</pre>
</div>


<ul class="org-ul">
<li>Main function - Experiment 1</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n ***** EXPERIMENT 1 = Instatiate a car with new operator ****\n "</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"---------------------------------------------------------------\n"</span>;
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Note: note recommended using 'new', instead use std::make_unique</span>
    <span class="org-type">SomeCar</span> <span class="org-variable-name">car1</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">new</span> <span class="org-type">DieselEngine</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" car1.has_engine() = "</span> &lt;&lt; car1.has_engine<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" car1.engine_type() = "</span> &lt;&lt; car1.engine_type<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    car1.run_engine<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Car and engine deleted at the end of this scope or at this bracket.</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">***** EXPERIMENT 1 = Instatiate a car with new operator ****
---------------------------------------------------------------
[INFO] Diesel Engine created.
car1.has_engine() = true
car1.engine_type() = diesel engine
[INFO] Run car engine.
Running a super powerful diesel Engine!!
[INFO] object of class SomeCar disposed. OK
[INFO] Diesel Engine deleted.
</pre>
</div>

<ul class="org-ul">
<li>Main function - Experiment 2</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n **** EXPERIMENT 2 = Instatiate a car with an exising unique_ptr ****\n "</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"---------------------------------------------------------------\n"</span>;
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Not recommended using new!</span>
    <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>IEngine<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">engineA</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">new</span> <span class="org-type">ElectricEngine</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Note: engineA is not copiable, can only be moved</span>
    <span class="org-type">SomeCar</span> <span class="org-variable-name">carA</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>engineA<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" carA.has_engine() = "</span> &lt;&lt; carA.has_engine<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" carA.engine_type() = "</span> &lt;&lt; carA.engine_type<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    carA.run_engine<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Remove engine of carA and sell it at the market</span>
    carA.remove_engine<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" After removal of carA's engine."</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" car1.has_engine() = "</span> &lt;&lt; carA.has_engine<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n After removing engine of CarA"</span> &lt;&lt; <span class="org-string">"\n"</span>;
    carA.set_engine<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">new</span> <span class="org-type">DieselEngine</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" carA.engine_type() = "</span> &lt;&lt; carA.engine_type<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    carA.run_engine<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">**** EXPERIMENT 2 = Instatiate a car with an exising unique_ptr ****
 ---------------------------------------------------------------
 [INFO] Electrict Engine created.
 [INFO] Called SomeCar L-value reference constructor
 carA.has_engine() = true
 carA.engine_type() = electric engine
 [INFO] Run car engine.
 =&gt;&gt; Running a silent and clean electric engine!!
 After removal of carA's engine.
 car1.has_engine() = false

 After removing engine of CarA
 [INFO] Diesel Engine created.
 carA.engine_type() = diesel engine
 [INFO] Run car engine.
 Running a super powerful diesel Engine!!
 [INFO] object of class SomeCar disposed. OK
 [INFO] Diesel Engine deleted.
</pre>
</div>

<ul class="org-ul">
<li>Main function - Experiment 3</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n **** EXPERIMENT 3 = Using std::make_unique ****\n "</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"---------------------------------------------------------------\n"</span>;
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">SomeCar</span> <span class="org-variable-name">carA</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>DieselEngine<span class="org-rainbow-delimiters-depth-3">&gt;()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" carA.has_engine() = "</span> &lt;&lt; carA.has_engine<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" carA.engine_type() = "</span> &lt;&lt; carA.engine_type<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    carA.run_engine<span class="org-rainbow-delimiters-depth-2">()</span>;


    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n [TRACE] After setting a new engine for CarA"</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">engine</span> = <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>ElectricEngine<span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" ?? engine == nullptr "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span>engine == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;

    carA.set_engine<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>engine<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" carA.engine_type() = "</span> &lt;&lt; carA.engine_type<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    carA.run_engine<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n [TRACE] After setting a new engine again for CarA"</span> &lt;&lt; <span class="org-string">"\n"</span>;
    carA.set_engine<span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>DieselEngine<span class="org-rainbow-delimiters-depth-3">&gt;()</span> <span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" carA.engine_type() = "</span> &lt;&lt; carA.engine_type<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    carA.run_engine<span class="org-rainbow-delimiters-depth-2">()</span>;

<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">**** EXPERIMENT 3 = Using std::make_unique ****
---------------------------------------------------------------
[INFO] Diesel Engine created.
[INFO] Called SomeCar R-value reference constructor
carA.has_engine() = true
carA.engine_type() = diesel engine
[INFO] Run car engine.
Running a super powerful diesel Engine!!

[TRACE] After setting a new engine for CarA
[INFO] Electrict Engine created.
?? engine == nullptr false
[INFO] Diesel Engine deleted.
carA.engine_type() = electric engine
[INFO] Run car engine.
=&gt;&gt; Running a silent and clean electric engine!!

[TRACE] After setting a new engine again for CarA
[INFO] Diesel Engine created.
[INFO] Electric Engine deleted.
carA.engine_type() = diesel engine
[INFO] Run car engine.
Running a super powerful diesel Engine!!
[INFO] object of class SomeCar disposed. OK
[INFO] Diesel Engine deleted.
</pre>
</div>

<ul class="org-ul">
<li>Main function - Experiment 4</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n **** EXPERIMENT 4 = Factory Function ****\n "</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"---------------------------------------------------------------\n"</span>;
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">SomeCar</span> <span class="org-variable-name">car</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">engine1</span> = factoryFunction<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">If the pointer is not nullptr (null) evalutes to true</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>engine1<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Engine created from factory function. Ok. \n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        car.set_engine<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-4">(</span>engine1<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" ??? car.has_engine() = "</span> &lt;&lt; car.has_engine<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n Set engine to DIESEL engine.\n"</span>;
    car.set_engine<span class="org-rainbow-delimiters-depth-2">(</span>factoryFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">'d'</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" ??? car.has_engine() = "</span> &lt;&lt; car.has_engine<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Engine type = "</span> &lt;&lt; car.engine_type<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    car.run_engine<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n Set engine to ELECTRIC engine.\n"</span>;
    car.set_engine<span class="org-rainbow-delimiters-depth-2">(</span>factoryFunction<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">'e'</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" ??? car.has_engine() = "</span> &lt;&lt; car.has_engine<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Engine type = "</span> &lt;&lt; car.engine_type<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
    car.run_engine<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">**** EXPERIMENT 4 = Factory Function ****
---------------------------------------------------------------
??? car.has_engine() = false

Set engine to DIESEL engine.
[INFO] Diesel Engine created.
??? car.has_engine() = true
Engine type = diesel engine
[INFO] Run car engine.
Running a super powerful diesel Engine!!

Set engine to ELECTRIC engine.
[INFO] Electrict Engine created.
[INFO] Diesel Engine deleted.
??? car.has_engine() = true
Engine type = electric engine
[INFO] Run car engine.
=&gt;&gt; Running a silent and clean electric engine!!
[INFO] object of class SomeCar disposed. OK
[INFO] Electric Engine deleted.
</pre>
</div>
</div>
</div>
<div id="outline-container-org3a20d1b" class="outline-4">
<h4 id="org3a20d1b"><span class="section-number-4">1.28.9</span> Example: shared_ptr</h4>
<div class="outline-text-4" id="text-1-28-9">
<p>
Full code: 
</p>
<ul class="org-ul">
<li>File:  <a href="src/smart_ptr_shared1.cpp">file:src/smart_ptr_shared1.cpp</a></li>
</ul>

<p>
Build: 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Build </span>
$ g++ shared_ptr1.cpp -o <span class="org-keyword">out.bin</span> -std=c++1z -g -O0 -Wall -Wextra 

<span class="org-comment-delimiter"># </span><span class="org-comment">Run </span>
./out.bin 
</pre>
</div>

<p>
Headers:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">algorithm</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cassert</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">assert (assertions)</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">memory</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">Provide: std::shared_ptr</span>
</pre>
</div>

<p>
Interface: IMediaAsset
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Media asset interface =&gt; generic specification for an media asset.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: A struct is just a class with everything public by default.</span>
<span class="org-keyword">struct</span> <span class="org-type">IMediaAsset</span><span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">name</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">play</span><span class="org-rainbow-delimiters-depth-2">()</span>              = 0;

    <span class="org-comment-delimiter">/** </span><span class="org-comment">Always add a default destructor. */</span>
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">IMediaAsset</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Class: MusicAsset
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-keyword">class</span> <span class="org-type">MusicAsset</span>: <span class="org-keyword">public</span> <span class="org-type">IMediaAsset</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
<span class="org-function-name">public</span>:

    <span class="org-function-name">MusicAsset</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>:
        m_name<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>name<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] CTOR - Music object =&gt; name = %s created. \n "</span>
                    , m_name.c_str<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-function-name">MusicAsset</span><span class="org-rainbow-delimiters-depth-2">()</span>: MusicAsset<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"unnamed-music"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">MusicAsset</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] DTOR - Music object =&gt; name = %s destroyed. \n "</span>
                    , m_name.c_str<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Override keyword is optional, but it is recommended in C++11</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-string">"music"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">name</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> m_name;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">play</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Playing music: "</span> &lt;&lt; m_name &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">setVolumePercent</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">volume</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Volume of music &lt;"</span>
                  &lt;&lt; m_name &lt;&lt; <span class="org-string">"&gt; set to "</span>
                  &lt;&lt; volume &lt;&lt; <span class="org-string">"%\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Class PictureAsset: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-keyword">class</span> <span class="org-type">PictureAsset</span>: <span class="org-keyword">public</span> <span class="org-type">IMediaAsset</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">m_name</span>;
<span class="org-function-name">public</span>:

    <span class="org-function-name">PictureAsset</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>:
        m_name<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>name<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] CTOR - Picture object =&gt; name = %s created. \n "</span>
                   , m_name.c_str<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-function-name">PictureAsset</span><span class="org-rainbow-delimiters-depth-2">()</span>: PictureAsset<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"unnamed-picture"</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">PictureAsset</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] DTOR - Picture object =&gt; name = %s destroyed. \n "</span>
                    , m_name.c_str<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Override keyword is optional, but it is recommended in C++11</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">type</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> <span class="org-string">"picture"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">name</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> m_name;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">play</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Show picture : "</span> &lt;&lt; m_name &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">resizeInPercent</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">percent</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Picture&lt;"</span>
                  &lt;&lt; m_name &lt;&lt; <span class="org-string">"&gt; resized "</span>
                  &lt;&lt; percent &lt;&lt; <span class="org-string">"%\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>


<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Shared pointer type alias: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Type alias for shared_ptr</span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">using</span> <span class="org-type">sh</span> = <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;
</pre>
</div>

<p>
Factory function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">/* </span><span class="org-comment">For the factory function use std::unique_ptr instead of shared_ptr as</span>
<span class="org-comment"> * it is easier to convert unique_ptr to shared_ptr than the other way around.</span>
<span class="org-comment"> */</span>
<span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>IMediaAsset<span class="org-rainbow-delimiters-depth-1">&gt;</span>
factoryFunction<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">id</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>id == 1<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>MusicAsset<span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-string">"Fur Elise"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>id == 2<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>PictureAsset<span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-string">"S&#227;o Paulo's Skyline"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>id == 3<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>MusicAsset<span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-string">"Baorque music"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>id == 4<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>PictureAsset<span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-string">"Tokyo skyline"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>main() Function - Experiment 1</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::boolalpha;

<span class="org-comment-delimiter">//</span><span class="org-comment">=============== EXPERIMENT 1 ===============================================//</span>
<span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ****** =&gt;&gt;&gt;&gt; EXPERIMENT 1 - Reference counter test **************\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Not recommended using new =&gt; Instead use std::make_shared</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">When the object is created, the reference count is set to 1.</span>
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>PictureAsset<span class="org-rainbow-delimiters-depth-1">&gt;</span> pic1<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">new</span> <span class="org-type">PictureAsset</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Desert sunshine"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span> pic1.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 1<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; Type of object pic1 = "</span> &lt;&lt; pic1-&gt;type<span class="org-rainbow-delimiters-depth-1">()</span>
          &lt;&lt; <span class="org-string">"  ; name = "</span> &lt;&lt; pic1-&gt;name<span class="org-rainbow-delimiters-depth-1">()</span>
          &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; Address of pic1 managed object = "</span> &lt;&lt; pic1.get<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; Value of ref. counter of pic1 = "</span> &lt;&lt; pic1.use_count<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;


<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" &gt;&gt; [TRACE] Before entering local scope &lt;&lt;=== \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Increments reference counter by 1 (set to 2) =&gt; .use_count() returns 2</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>PictureAsset<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">pic1_copyA</span> = pic1;
    assert<span class="org-rainbow-delimiters-depth-2">(</span>pic1_copyA.use_count<span class="org-rainbow-delimiters-depth-3">()</span> == 2<span class="org-rainbow-delimiters-depth-2">)</span>;
    assert<span class="org-rainbow-delimiters-depth-2">(</span>pic1.use_count<span class="org-rainbow-delimiters-depth-3">()</span> == 2<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [INFO] Reference count of pic1_copyA = %ld \n"</span>, pic1_copyA.use_count<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" pic1_copyA-&gt;name() = %s \n"</span>, pic1_copyA-&gt;name<span class="org-rainbow-delimiters-depth-3">()</span>.c_str<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;


    <span class="org-comment-delimiter">// </span><span class="org-comment">Increments reference counter by 1 (set to 3)</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">pic1_copyB</span> = pic1;
    assert<span class="org-rainbow-delimiters-depth-2">(</span>pic1.use_count<span class="org-rainbow-delimiters-depth-3">()</span> == 3<span class="org-rainbow-delimiters-depth-2">)</span>;
    assert<span class="org-rainbow-delimiters-depth-2">(</span>pic1_copyB.use_count<span class="org-rainbow-delimiters-depth-3">()</span> == 3<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">.use_count() returns 3</span>
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [INFO] Reference count of pic1_copyB = %ld \n"</span>, pic1_copyA.use_count<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" pic1_copyB-&gt;name() = %s \n"</span>, pic1_copyB-&gt;name<span class="org-rainbow-delimiters-depth-3">()</span>.c_str<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">/** </span><span class="org-comment">Objdcts pic1_copyA and pic1_copyB are destroyed,</span>
<span class="org-comment">     * then each one decrements the reference counter by 1</span>
<span class="org-comment">     */</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" &gt;&gt; [TRACE] Levaing  local scope &lt;&lt;=== "</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">.use_count returns 1 as the two copies were destroyed.</span>
<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] Before reset(). Reference count of pic1 = %ld \n"</span>, pic1.use_count<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

assert<span class="org-rainbow-delimiters-depth-1">(</span>pic1.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 1<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Decrements reference counter of control block by 1.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">The owned object and the control block are deleted when the counter is zero.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">When the counter reaches zero, the internal pointer is set to nullptr.</span>
pic1.reset<span class="org-rainbow-delimiters-depth-1">()</span>;
assert<span class="org-rainbow-delimiters-depth-1">(</span>pic1.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 0<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] After reset(). Reference count of pic1 = %ld \n"</span>, pic1.use_count<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" ?? Is pic1 nullptr =&gt; (pic1 == nullptr) : "</span>
          &lt;&lt; <span class="org-rainbow-delimiters-depth-1">(</span>pic1  == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span>
          &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" ?? Does shared_ptr pic1 own an object =&gt; (pic1 != nullptr) : "</span>
          &lt;&lt; <span class="org-rainbow-delimiters-depth-1">(</span>pic1  != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span>
          &lt;&lt; <span class="org-constant">std</span>::endl;

</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">****** =&gt;&gt;&gt;&gt; EXPERIMENT 1 - Reference counter test **************

 [TRACE] CTOR - Picture object =&gt; name = Desert sunshine created. 
  =&gt; Type of object pic1 = picture  ; name = Desert sunshine
 =&gt; Address of pic1 managed object = 0x1b73e80
 =&gt; Value of ref. counter of pic1 = 1
 &gt;&gt; [TRACE] Before entering local scope &lt;&lt;=== 

 [INFO] Reference count of pic1_copyA = 2 
 pic1_copyA-&gt;name() = Desert sunshine 
 [INFO] Reference count of pic1_copyB = 3 
 pic1_copyB-&gt;name() = Desert sunshine 
 &gt;&gt; [TRACE] Levaing  local scope &lt;&lt;=== 
 [INFO] Before reset(). Reference count of pic1 = 1 
 [TRACE] DTOR - Picture object =&gt; name = Desert sunshine destroyed. 
  [INFO] After reset(). Reference count of pic1 = 0 
 ?? Is pic1 nullptr =&gt; (pic1 == nullptr) : true
 ?? Does shared_ptr pic1 own an object =&gt; (pic1 != nullptr) : false

</pre>
</div>

<ul class="org-ul">
<li>main() Function - Experiment 2</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">//</span><span class="org-comment">======= EXPERIMENT 2 ===&gt;&gt; Polymorphism ======================================//</span>
<span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ****** =&gt;&gt;&gt;&gt; EXPERIMENT 2 - Polymorphism test **************\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" \n --- Experiment 2.A - musicA object \n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Default initialized to nullptr (reference counter is zero).</span>
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>IMediaAsset<span class="org-rainbow-delimiters-depth-1">&gt;</span> media1;
assert<span class="org-rainbow-delimiters-depth-1">(</span>media1.use_count<span class="org-rainbow-delimiters-depth-2">()</span> == 0<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-negation-char">!</span>media1<span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Media pointer owns no object, it is nullptr"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Media pointer owns an object, it is not nullptr"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] Ref count of media1 = %ld \n"</span>, media1.use_count<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Best way to instantiante a polymorphic object</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Type: std::shared_ptr&lt;MusicAsset&gt;</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">musicA</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span>MusicAsset<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-string">"Fur Elise"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] Ref count of musicA = %ld \n"</span>, musicA.use_count<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Polymorphism: the pointer to a derived class</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">can be assigned to a pointer of the base class.</span>
media1 = musicA;
<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] Ref count of musicA = %ld \n"</span>, musicA.use_count<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] Ref count of medai1 = %ld \n"</span>, media1.use_count<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" \n --- Experiment 2.B - pictA object \n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-rainbow-delimiters-depth-1">{</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Type: std::shared_ptr&lt;PictureAsset&gt;</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">pictA</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>PictureAsset<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"Canyon sunset"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [INFO] Before assigning: Ref count of pictA = %ld \n"</span>
                , pictA.use_count<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; pictA-&gt;type() = '%s' - pictA-&gt;name() = %s  "</span>
                , pictA-&gt;type<span class="org-rainbow-delimiters-depth-3">()</span>.c_str<span class="org-rainbow-delimiters-depth-3">()</span>, pictA-&gt;name<span class="org-rainbow-delimiters-depth-3">()</span>.c_str<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">)</span>;

    media1 = pictA;
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [INFO] After assigning: Ref count of pictA = %ld \n"</span>
                , musicA.use_count<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" =&gt; media1-&gt;type() = '%s' - media1-&gt;name() = %s  \n"</span>
                , media1-&gt;type<span class="org-rainbow-delimiters-depth-3">()</span>.c_str<span class="org-rainbow-delimiters-depth-3">()</span>, media1-&gt;name<span class="org-rainbow-delimiters-depth-3">()</span>.c_str<span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Object (shared pointer) pictA destroyed here</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">, but not the owned object "Canyon sunset" as it also owned by 'media1' pointer</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" \n --- Experiment 2.C - After end of local scope \n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>IMediaAsset<span class="org-rainbow-delimiters-depth-1">&gt;</span> media2 = media1;
<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] Ref count of media1 = %ld \n"</span>, media1.use_count<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] Ref count of media1 = %ld \n"</span>, media2.use_count<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

media1 = <span class="org-constant">nullptr</span>;
<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] Ater setting media1 to null =&gt; Ref count of media1 = %ld \n"</span>
            , media1.use_count<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" [INFO] Ater setting media2 to null =&gt; Ref count of media2 = %ld \n"</span>
            , media2.use_count<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" Before setting media2 to nullptr =&gt; media2-&gt;type() = '%s' - media2-&gt;name() = %s  \n"</span>
            , media2-&gt;type<span class="org-rainbow-delimiters-depth-2">()</span>.c_str<span class="org-rainbow-delimiters-depth-2">()</span>, media2-&gt;name<span class="org-rainbow-delimiters-depth-2">()</span>.c_str<span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Reference count set to zero =&gt; The object "Canyon sunset" is destroyed</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">as any pointer no longer owns it.</span>
media2 = <span class="org-constant">nullptr</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" After setting media2 to nullptr =&gt; ?? Is media2 nullptr = "</span>
          &lt;&lt; <span class="org-rainbow-delimiters-depth-1">(</span>media2 == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">****** =&gt;&gt;&gt;&gt; EXPERIMENT 2 - Polymorphism test **************


 --- Experiment 2.A - musicA object 
 [TRACE] Media pointer owns no object, it is nullptr
 [INFO] Ref count of media1 = 0 
 [TRACE] CTOR - Music object =&gt; name = Fur Elise created. 
  [INFO] Ref count of musicA = 1 
 [INFO] Ref count of musicA = 2 
 [INFO] Ref count of medai1 = 2 

 --- Experiment 2.B - pictA object 
 [TRACE] CTOR - Picture object =&gt; name = Canyon sunset created. 
  [INFO] Before assigning: Ref count of pictA = 1 
 =&gt; pictA-&gt;type() = 'picture' - pictA-&gt;name() = Canyon sunset   [INFO] After assigning: Ref count of pictA = 1 
 =&gt; media1-&gt;type() = 'picture' - media1-&gt;name() = Canyon sunset  

 --- Experiment 2.C - After end of local scope 
 [INFO] Ref count of media1 = 2 
 [INFO] Ref count of media1 = 2 
 [INFO] Ater setting media1 to null =&gt; Ref count of media1 = 0 
 [INFO] Ater setting media2 to null =&gt; Ref count of media2 = 1 
 Before setting media2 to nullptr =&gt; media2-&gt;type() = 'picture' - media2-&gt;name() = Canyon sunset  
 [TRACE] DTOR - Picture object =&gt; name = Canyon sunset destroyed. 
  After setting media2 to nullptr =&gt; ?? Is media2 nullptr = true
</pre>
</div>

<ul class="org-ul">
<li>Experiment 3</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">//</span><span class="org-comment">=============== EXPERIMENT 3 - Polymorphism and pointer casting ===========//</span>
<span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ****** =&gt;&gt;&gt;&gt; EXPERIMENT 3 - Polymorphism and casting ***********\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>IMediaAsset<span class="org-rainbow-delimiters-depth-1">&gt;</span> asset1 = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span>MusicAsset<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-string">"Blues"</span><span class="org-rainbow-delimiters-depth-1">)</span>;


<span class="org-comment-delimiter">// </span><span class="org-comment">Downcast object at runtime (RTTI) checking whetehr it</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">is a Music asset taking its ownership.</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">RTTI Runtime - Type information</span>
    <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>PictureAsset<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">asset_is_music</span> = <span class="org-constant">std</span>::dynamic_pointer_cast<span class="org-rainbow-delimiters-depth-2">&lt;</span>PictureAsset<span class="org-rainbow-delimiters-depth-2">&gt;(</span>asset1<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>asset_is_music<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt;&gt;&gt; Asset type is music OK"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" Object Type = %s - object name = %s\n"</span>
                    , asset_is_music-&gt;type<span class="org-rainbow-delimiters-depth-4">()</span>.c_str<span class="org-rainbow-delimiters-depth-4">()</span>
                        , asset_is_music-&gt;name<span class="org-rainbow-delimiters-depth-4">()</span>.c_str<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt;&gt; Asset type is not music. "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Static casting object at runtime =&gt; IF the casting is wrong, it results in</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">undefined behavior!!</span>

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n ---- Before changing pointed object "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
asset1 = factoryFunction<span class="org-rainbow-delimiters-depth-1">(</span>2<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n ---- After changing pointed object "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>asset1-&gt;type<span class="org-rainbow-delimiters-depth-2">()</span> == <span class="org-string">"picture"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Warning: if the casting does not match, results in undefined behavior!!</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">asset_picture</span> = <span class="org-constant">std</span>::static_pointer_cast<span class="org-rainbow-delimiters-depth-2">&lt;</span>PictureAsset<span class="org-rainbow-delimiters-depth-2">&gt;(</span>asset1<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n =&gt;&gt;&gt; Asset type is picture OK"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" Object Type = %s - object name = %s\n"</span>
                , asset_picture-&gt;type<span class="org-rainbow-delimiters-depth-3">()</span>.c_str<span class="org-rainbow-delimiters-depth-3">()</span>
                    , asset_picture-&gt;name<span class="org-rainbow-delimiters-depth-3">()</span>.c_str<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    asset_picture-&gt;resizeInPercent<span class="org-rainbow-delimiters-depth-2">(</span>40<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">****** =&gt;&gt;&gt;&gt; EXPERIMENT 3 - Polymorphism and casting ***********

 [TRACE] CTOR - Music object =&gt; name = Blues created. 
  =&gt;&gt; Asset type is not music. 

 ---- Before changing pointed object 
 [TRACE] CTOR - Picture object =&gt; name = S&#227;o Paulo's Skyline created. 
  [TRACE] DTOR - Music object =&gt; name = Blues destroyed. 

 ---- After changing pointed object 

 =&gt;&gt;&gt; Asset type is picture OK
 Object Type = picture - object name = S&#227;o Paulo's Skyline
 [INFO] Picture&lt;S&#227;o Paulo's Skyline&gt; resized 40%
</pre>
</div>

<ul class="org-ul">
<li>Experiment 4</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">//</span><span class="org-comment">=============== EXPERIMENT 4 - Polymorphism and containers ================//</span>
<span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n ****** =&gt;&gt;&gt;&gt; EXPERIMENT 4 - Polymorphioc Objects and Containers *****\n"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">objA</span> = <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-1">&lt;</span>MusicAsset<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-string">"Some medieval music"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::<span class="org-type">shared_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>IMediaAsset<span class="org-rainbow-delimiters-depth-1">&gt;</span> objB = factoryFunction<span class="org-rainbow-delimiters-depth-1">(</span>2<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n --- Before filling 'collection' "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-comment-delimiter">// </span><span class="org-comment">Polymorphism</span>
<span class="org-function-name">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">sh</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>IMediaAsset<span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> collection =
    <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>PictureAsset<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"Max turbo power diesel engine"</span><span class="org-rainbow-delimiters-depth-2">)</span>
      , <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>MusicAsset<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"Some baroque music"</span><span class="org-rainbow-delimiters-depth-2">)</span>
      , <span class="org-constant">std</span>::make_shared<span class="org-rainbow-delimiters-depth-2">&lt;</span>PictureAsset<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"Desert canyon"</span><span class="org-rainbow-delimiters-depth-2">)</span>
      , factoryFunction<span class="org-rainbow-delimiters-depth-2">(</span>1<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-1">}</span>;

collection.push_back<span class="org-rainbow-delimiters-depth-1">(</span>objA<span class="org-rainbow-delimiters-depth-1">)</span>;
collection.push_back<span class="org-rainbow-delimiters-depth-1">(</span>objB<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" --- After filling 'collection' \n\n"</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" Ref counter of objA = "</span> &lt;&lt; objA.use_count<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" ==== Print objects in the container ==== "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">ptr</span>: collection<span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; ptr-&gt;type<span class="org-rainbow-delimiters-depth-2">()</span>
              &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-string">"  "</span>
              &lt;&lt; <span class="org-constant">std</span>::left  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>35<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; ptr-&gt;name<span class="org-rainbow-delimiters-depth-2">()</span>
              &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::right;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n ----- Before clearing the vector  ----- "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

collection.clear<span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">"\n ----- After clearing the vector  ----- "</span> &lt;&lt; <span class="org-constant">std</span>::endl;

objA = <span class="org-constant">nullptr</span>;
objB.reset<span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-function-name">std</span>::puts<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"\n  *********** End of Main() *****************"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">return</span> 0;
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-text">****** =&gt;&gt;&gt;&gt; EXPERIMENT 4 - Polymorphioc Objects and Containers *****

 [TRACE] CTOR - Music object =&gt; name = Some medieval music created. 
  [TRACE] CTOR - Picture object =&gt; name = S&#227;o Paulo's Skyline created. 

 --- Before filling 'collection' 
 [TRACE] CTOR - Picture object =&gt; name = Max turbo power diesel engine created. 
  [TRACE] CTOR - Music object =&gt; name = Some baroque music created. 
  [TRACE] CTOR - Picture object =&gt; name = Desert canyon created. 
  [TRACE] CTOR - Music object =&gt; name = Fur Elise created. 
  --- After filling 'collection' 

 Ref counter of objA = 2
 ==== Print objects in the container ==== 
        picture  Max turbo power diesel engine      
          music  Some baroque music                 
        picture  Desert canyon                      
          music  Fur Elise                          
          music  Some medieval music                
        picture  S&#227;o Paulo's Skyline               

 ----- Before clearing the vector  ----- 
 [TRACE] DTOR - Picture object =&gt; name = Max turbo power diesel engine destroyed. 
  [TRACE] DTOR - Music object =&gt; name = Some baroque music destroyed. 
  [TRACE] DTOR - Picture object =&gt; name = Desert canyon destroyed. 
  [TRACE] DTOR - Music object =&gt; name = Fur Elise destroyed. 

 ----- After clearing the vector  ----- 
 [TRACE] DTOR - Music object =&gt; name = Some medieval music destroyed. 
  [TRACE] DTOR - Picture object =&gt; name = S&#227;o Paulo's Skyline destroyed. 

  *********** End of Main() *****************
 [TRACE] DTOR - Picture object =&gt; name = S&#227;o Paulo's Skyline destroyed. 
  [TRACE] DTOR - Music object =&gt; name = Fur Elise destroyed. 
</pre>
</div>
</div>
</div>
<div id="outline-container-orge87ae92" class="outline-4">
<h4 id="orge87ae92"><span class="section-number-4">1.28.10</span> Selected Codebases with std::shared_ptr</h4>
<div class="outline-text-4" id="text-1-28-10">
<p>
Libraries and Applications: 
</p>

<ul class="org-ul">
<li>Project: <a href="https://github.com/LibreOffice/core">LibreOffice</a> - Read-only LibreOffice core repo. Note:
Contains more than 1000 usages of shared_ptr. 
<ul class="org-ul">
<li><a href="https://github.com/LibreOffice/core/search?q=shared_ptr&amp;unscoped_q=shared_ptr">std::shared_ptr search</a></li>
</ul></li>

<li>Project: <a href="https://gitlab.com/inkscape/inkscape">inkscape</a> - Vector drawing and diagram application similar to Microsft Visio.
<ul class="org-ul">
<li><a href="https://gitlab.com/search?utf8=%E2%9C%93&amp;search=shared_ptr&amp;group_id=&amp;project_id=3472737&amp;search_code=true&amp;repository_ref=master&amp;nav_source=navbar">std::shared_ptr search</a></li>
</ul></li>

<li>Project: <a href="https://github.com/emweb/wt">WT</a> C++ Web Toolkit, aka Web Framework.
<ul class="org-ul">
<li><a href="https://github.com/emweb/wt/search?q=shared_ptr&amp;unscoped_q=shared_ptr">std::shared_ptr search</a></li>
</ul></li>

<li>Project: <a href="https://github.com/BVLC/caffe">caffe</a> - Caffe is a deep learning framework made with
expression, speed, and modularity in mind. It is developed by
Berkeley AI Research (BAIR)/The Berkeley Vision and Learning
Center (BVLC) and community contributors.
<ul class="org-ul">
<li><a href="https://github.com/BVLC/caffe/search?q=std%3A%3Ashared_ptr&amp;unscoped_q=std%3A%3Ashared_ptr">std::shared_ptr search</a></li>
</ul></li>

<li>Project: <a href="https://github.com/facebook/rocksdb">rocksdb</a> - A Persistent Key-Value Store for Flash and RAM
Storage (developed by Facebook)
<ul class="org-ul">
<li><a href="https://github.com/facebook/rocksdb/search?q=shared_ptr&amp;unscoped_q=shared_ptr">std::shared_ptr search</a></li>
</ul></li>

<li>Project: <a href="https://github.com/microsoft/terminal">microsoft/terminal</a> - The new Windows Terminal, and the
original Windows console host &#x2013; all in the same place!
<ul class="org-ul">
<li><a href="https://github.com/microsoft/terminal/search?q=shared_ptr&amp;unscoped_q=shared_ptr">std::shared_ptr search</a></li>
</ul></li>

<li>Project: <a href="https://github.com/skypjack/uvw">uvw</a> - Header-only, event based, tiny and easy to use
libuv wrapper in modern C++. 
<ul class="org-ul">
<li><a href="https://github.com/skypjack/uvw/search?q=shared_ptr&amp;unscoped_q=shared_ptr">std::shared_ptr search</a></li>
</ul></li>
</ul>

<p>
Computer Graphics and Game Engines: 
</p>

<ul class="org-ul">
<li>Project: <a href="https://github.com/WolfEngine/Wolf.Engine">Wolf.Engine</a> - The Wolf is a comprehensive set of C++ open
source libraries for realtime rendering, realtime streaming and
game developing <a href="https://wolfengine.app">https://wolfengine.app</a> 
<ul class="org-ul">
<li><a href="https://github.com/WolfEngine/Wolf.Engine/search?q=shared_ptr&amp;unscoped_q=shared_ptr">std::shared_ptr search</a></li>
</ul></li>

<li>Project: <a href="https://github.com/4ian/GDevelop">GDevelop</a> - video_game GDevelop is an open-source,
cross-platform game engine designed to be used by
everyone. <a href="https://gdevelop-app.com">https://gdevelop-app.com</a>
<ul class="org-ul">
<li><a href="https://github.com/4ian/GDevelop/search?q=shared_ptr&amp;unscoped_q=shared_ptr">std::shared_ptr search</a></li>
</ul></li>

<li>Project: <a href="https://github.com/SourMesen/Mesen">Mesen</a> - Mesen is a cross-platform (Windows &amp; Linux)
NES/Famicom emulator built in C++ and C# <a href="https://www.mesen.ca">https://www.mesen.ca</a>
<ul class="org-ul">
<li><a href="https://github.com/SourMesen/Mesen/search?q=shared_ptr&amp;unscoped_q=shared_ptr">std::shared_ptr search</a></li>
</ul></li>

<li>Project: <a href="https://github.com/PCSX2/pcsx2">pcsx2</a> - The Playstation 2 Emulator 
<ul class="org-ul">
<li><a href="https://github.com/PCSX2/pcsx2/search?q=shared_ptr&amp;unscoped_q=shared_ptr">std::shared_ptr search</a></li>
</ul></li>

<li>Project: <a href="https://github.com/Shervanator/Engine">Shervanator/Engine</a> - A basic cross-platform (Mac,
Windows, Linux, HTML5, Android) 3D game engine.
<ul class="org-ul">
<li><a href="https://github.com/Shervanator/Engine/search?q=shared_ptr&amp;unscoped_q=shared_ptr">std::shared_ptr search</a></li>
</ul></li>

<li>Project: <a href="https://github.com/openscad/openscad">openscad</a> - OpenSCAD - The Programmers Solid 3D CAD Modeller
<ul class="org-ul">
<li><a href="https://github.com/openscad/openscad/search?q=shared_ptr&amp;unscoped_q=shared_ptr">search std::shared_ptr</a></li>
</ul></li>

<li>Project: <a href="https://github.com/jpvanoosten/LearningDirectX12">LearningDirectX12</a> - This repository is intended to be
used as a code repository for learning DirectX 12. The tutorials
can be found on <a href="https://www.3dgep.com">https://www.3dgep.com</a>. 
<ul class="org-ul">
<li><a href="https://github.com/jpvanoosten/LearningDirectX12/search?q=std%3A%3Ashared_ptr&amp;unscoped_q=std%3A%3Ashared_ptr">std::shared_ptr search</a></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-org0adfd12" class="outline-4">
<h4 id="org0adfd12"><span class="section-number-4">1.28.11</span> Additional Reading</h4>
<div class="outline-text-4" id="text-1-28-11">
<p>
<b>General:</b>
</p>

<ul class="org-ul">
<li><b>Five Popular Miths about C++</b>
<ul class="org-ul">
<li><a href="http://www.stroustrup.com/Myths-final.pdf">http://www.stroustrup.com/Myths-final.pdf</a></li>
</ul></li>

<li>StackOverflow - <b>Why do C++ libraries and frameworks never use smart pointers?</b>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/10334511">https://stackoverflow.com/questions/10334511</a></li>
</ul></li>

<li>Boost intrusive_ptr : faster shared pointer
<ul class="org-ul">
<li><a href="https://baptiste-wicht.com/posts/2011/11/boost-intrusive_ptr.html">https://baptiste-wicht.com/posts/2011/11/boost-intrusive_ptr.html</a></li>
</ul></li>

<li>Wrapping C++ std::shared_ptr and similar smart pointers
<ul class="org-ul">
<li><a href="https://discuss.ocaml.org/t/wrapping-c-std-shared-ptr-and-similar-smart-pointers/3582">https://discuss.ocaml.org/t/wrapping-c-std-shared-ptr-and-similar-smart-pointers/3582</a></li>
</ul></li>

<li>C++ Gof Design Patterns heavily depends on new or shared_ptr
<ul class="org-ul">
<li><a href="https://softwareengineering.stackexchange.com/questions/381197">https://softwareengineering.stackexchange.com/questions/381197</a></li>
</ul></li>
</ul>

<p>
<b>Shared Pointers in Projects and Libraries</b> 
</p>

<ul class="org-ul">
<li><b>Boost Shared Pointers</b> - Inkscape
<ul class="org-ul">
<li><a href="http://wiki.inkscape.org/wiki/index.php/Boost_shared_pointers">http://wiki.inkscape.org/wiki/index.php/Boost_shared_pointers</a></li>
</ul></li>

<li><b>Mantid Project - Some C++ Tips</b>
<ul class="org-ul">
<li><a href="https://www.mantidproject.org/Some_C++_Tips">https://www.mantidproject.org/Some_C++_Tips</a></li>
</ul></li>

<li><b>Boost Structures in OMPL - Open Motion Planing</b>
<ul class="org-ul">
<li><a href="https://www.mantidproject.org/Some_C++_Tips">https://www.mantidproject.org/Some_C++_Tips</a></li>
</ul></li>

<li><b>Project Chrono - Shared Pointers</b>
<ul class="org-ul">
<li><a href="http://api.projectchrono.org/shared_pointers.html">http://api.projectchrono.org/shared_pointers.html</a></li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orge5141a3" class="outline-3">
<h3 id="orge5141a3"><span class="section-number-3">1.29</span> Exceptions and Error Handling</h3>
<div class="outline-text-3" id="text-1-29">
</div>
<div id="outline-container-org3745848" class="outline-4">
<h4 id="org3745848"><span class="section-number-4">1.29.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-29-1">
<p>
<b>C++ has several error Handling approaches:</b>
</p>

<ul class="org-ul">
<li><span class="underline">Exceptions</span>: - try-catch and throw
<ul class="org-ul">
<li>Benefits:
<ul class="org-ul">
<li>Code Separation:
<ul class="org-ul">
<li>Separation of error handling from the computation logic.</li>
</ul></li>
<li>Error notification
<ul class="org-ul">
<li>Forces developers to handle the error by ending the the
program execution when the application is not ready to handle
the error that caused the exception.</li>
</ul></li>
<li>Easier to recover from errors and failures.</li>
<li>Stack Traces:</li>
</ul></li>
<li>Downsides:
<ul class="org-ul">
<li>Increase of executable size - It should not be a concern anymore,
since hard driver are becoming more cheaper with the passing of
time.</li>
<li>According to many sources, exceptions can be a concern in real
time embedded systems.</li>
</ul></li>
</ul></li>

<li><span class="underline">Error codes in global variables</span>
<ul class="org-ul">
<li>Many C APIs handle error by setting some global variable that the
calling code must check for some some error condition. For
instance, the U*nix C-API indicates error by setting the global
variable <span class="underline">errno</span> that must be checked by the calling code after
after some operation that may set this flag. The downside of the
this approach is that if the program doesn't check the global
error flag, the program may continue its execution without
notifying the user that something is wrong what can lead to
runtime bugs hard to trace.</li>

<li>Downsides:
<ul class="org-ul">
<li>It is easy to forget handling global variables with error code.</li>
<li>May have multi-threading racing conditions issues.</li>
<li>Don't notify users that the program cannot handle the runtime
errors.</li>
<li>Hard to trace and debug.</li>
</ul></li>
</ul></li>

<li><span class="underline">Error codes as return value</span>:

<ul class="org-ul">
<li>A function can provide error notification by returning an error
code to the caller. For instance, a function which downloads a
file could return 1 for successful download, 2 for DNS resolution
error, 3 for network error and so on.</li>

<li>Variations:

<ul class="org-ul">
<li><span class="underline">Return an error code such as a bitmask or enumeration</span>. Example:
HRESULT type is returned type by many Windows COM API for
indicating error
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/HRESULT">https://en.wikipedia.org/wiki/HRESULT</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/seccrypto/common-hresult-values">Common HRESULT Values | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)">IUnknown::QueryInterface(REFIID,void) | Microsoft Docs</a></li>
</ul></li>

<li><span class="underline">Return a null pointer</span> to indicate failure or the absence of an
object, that it was no possible to find an object or allocate
memory. Example: C++ new operator with nothrow,

<ul class="org-ul">
<li>Example:</li>
<li>Base* ptr = new (nothrow ) Derived;</li>
<li>if(ptr){ .. do something &#x2026;} else { std::puts("Error: &#x2026; "); )}</li>
</ul></li>

<li><span class="underline">Return an error code or error flag from class methods</span>. This
approach is used by C++ streams std::iosbase and its derived
classes, std::cin, std::istream and so on., bool
std::iosbase.good(), bool std::iosbase.fail().</li>
</ul></li>
</ul></li>

<li><span class="underline">User supplied callback function</span>
<ul class="org-ul">
<li>The client code supplies a callback function which is called when
an error happens.</li>
</ul></li>

<li><span class="underline">Using 'either' type</span>
<ul class="org-ul">
<li>See:
<a href="https://hackernoon.com/error-handling-in-c-or-why-you-should-use-eithers-in-favor-of-exceptions-and-error-codes-f0640912eb45">Error Handling in C++ or: Why You Should Use Eithers in Favor of Exceptions and Error-codes</a></li>
</ul></li>

<li><span class="underline">std::optional&lt;T&gt;</span> - C++17 Maybe or Optional type.</li>
</ul>

<p>
<b>Exception Headers</b> 
</p>

<ul class="org-ul">
<li>Headers: 
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/header/stdexcept">&lt;stdexcept&gt;</a></li>
<li><a href="http://www.cplusplus.com/reference/exception/exception/">&lt;exception&gt;</a></li>
</ul></li>
</ul>

<p>
<b>Exceptions Good Practices:</b>
</p>

<ul class="org-ul">
<li>Assertions: should not be used for argument validation since they
can be disabled during compilation or on release builds.</li>

<li>Exceptions should be used on objects' constructors in order to avoid
letting the object in an invalid state. =&gt; <span class="underline">Fail Fast principle</span>.</li>

<li>Destructors should not throw exceptions as it invokers terminates()
shutting down the program.</li>

<li>DO NOT: catch all exceptions. Only exceptions that can be handled
should be caught.</li>
</ul>

<p>
<b>C++ Stack Terminology</b>
</p>

<ul class="org-ul">
<li>Exception Specification</li>
<li>Stack Unwinding</li>
<li>Exception-safety</li>
<li>RAII - Resource Aquisition is Resource Initialization</li>
<li>Smart Pointers</li>
</ul>

<p>
<b>Functions related to exceptions</b> 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/error/current_exception">std::current_exception</a></li>
<li><a href="https://en.cppreference.com/w/cpp/error/rethrow_exception">std::rethrow_exception</a></li>
<li><a href="https://en.cppreference.com/w/cpp/error/terminate">std::terminate</a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a></li>
<li><a href="https://en.cppreference.com/w/cpp/error/terminate_handler">std::terminate_handler</a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/program/exit">std::exit</a></li>
</ul>

<p>
<b>Standard Library Exception defined in header file &lt;exception&gt;</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Exception</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>std::exception</code></td>
<td class="org-left">An exception and parent class of all the standard C++ exceptions.</td>
</tr>

<tr>
<td class="org-left"><code>std::runtime_error</code></td>
<td class="org-left">An exception that theoretically can not be detected by reading the code.</td>
</tr>

<tr>
<td class="org-left"><code>std::logic_error</code></td>
<td class="org-left">An exception that theoretically can be detected by reading the code.</td>
</tr>

<tr>
<td class="org-left"><code>std::domain_error</code></td>
<td class="org-left">This is an exception thrown when a mathematically invalid domain is used</td>
</tr>

<tr>
<td class="org-left"><code>std::invalid_argument</code></td>
<td class="org-left">This is thrown due to invalid arguments.</td>
</tr>

<tr>
<td class="org-left"><code>std::bad_alloc</code></td>
<td class="org-left">This can be thrown by new.</td>
</tr>

<tr>
<td class="org-left"><code>std::bad_cast</code></td>
<td class="org-left">This can be thrown by dynamic_cast.</td>
</tr>

<tr>
<td class="org-left"><code>std::bad_exception</code></td>
<td class="org-left">This is useful device to handle unexpected exceptions in a C++ program</td>
</tr>

<tr>
<td class="org-left"><code>std::bad_typeid</code></td>
<td class="org-left">This can be thrown by typeid.</td>
</tr>

<tr>
<td class="org-left"><code>std::length_error</code></td>
<td class="org-left">This is thrown when a too big std::string is created</td>
</tr>

<tr>
<td class="org-left"><code>std::out_of_range</code></td>
<td class="org-left">This can be thrown by the at method from for example a std::vector and std::bitset&lt;&gt;::operator[]().</td>
</tr>

<tr>
<td class="org-left"><code>std::overflow_error</code></td>
<td class="org-left">This is thrown if a mathematical overflow occurs.</td>
</tr>

<tr>
<td class="org-left"><code>std::range_error</code></td>
<td class="org-left">This is occured when you try to store a value which is out of range.</td>
</tr>

<tr>
<td class="org-left"><code>std::underflow_error</code></td>
<td class="org-left">This is thrown if a mathematical underflow occurs.</td>
</tr>
</tbody>
</table>


<p>
References: 
</p>

<p>
C++ Documentation: 
</p>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/error/exception">std::exception - cppreference.com</a></li>
<li><a href="https://en.cppreference.com/w/cpp/error/exception/what">std::exception::what - cppreference.com</a></li>
<li><a href="https://isocpp.org/wiki/faq/exceptions">Exceptions and Error Handling, C++ FAQ</a></li>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR56-CPP.+Guarantee+exception+safety">ERR56-CPP. Guarantee exception safety - SEI CERT C++ Coding Standard - Confluence</a></li>
<li><a href="https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/cplr156.htm">IBM Knowledge Center - Exception specifications (C++ only)</a></li>
</ul>

<p>
Misc:
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/11938979/what-exception-classes-are-in-the-standard-c-library">What exception classes are in the standard C++ library - Stack Overflow</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/throw">throw expression - cppreference.com</a></li>
<li><a href="https://blog.mozilla.org/nnethercote/2011/01/18/the-dangers-of-fno-exceptions/">The dangers of -fno-exceptions | Nicholas Nethercote</a></li>
<li><a href="https://stackoverflow.com/questions/16182781/how-to-create-exceptions">c++ - How to create exceptions? - Stack Overflow</a></li>
<li><a href="https://dzone.com/articles/some-useful-facts-to-know-when-using-c-exceptions">Some Useful Facts to Know Before Using C++ Exceptions - DZone Performance</a></li>
<li><a href="http://www.acodersjourney.com/2016/08/top-15-c-exception-handling-mistakes-avoid/">Top 15 C++ Exception handling mistakes and how to avoid them. - A CODER'S JOURNEY</a></li>
</ul>

<p>
Best: 
</p>

<ul class="org-ul">
<li><a href="https://blog.plan99.net/what-s-wrong-with-exceptions-nothing-cee2ed0616?gi=33a0310b3ff9">What’s wrong with exceptions? Nothing. – Mike’s blog</a></li>
<li><a href="https://isocpp.org/wiki/faq/exceptions">Exceptions and Error Handling, C++ FAQ</a></li>
<li><a href="http://www.learncpp.com/cpp-tutorial/145-exceptions-classes-and-inheritance/">14.5 — Exceptions, classes, and inheritance | Learn C++</a></li>
<li><a href="https://en.wikibooks.org/wiki/C++_Programming/Exception_Handling">C++ Programming/Exception Handling - Wikibooks, open books for an open world</a></li>
<li><a href="http://rdiez.shoutwiki.com/wiki/Error_Handling_in_General_and_C++_Exceptions_in_Particular">Error Handling in General and C++ Exceptions in Particular - rdiez's Personal Wiki</a></li>
</ul>
</div>
</div>
<div id="outline-container-org160e385" class="outline-4">
<h4 id="org160e385"><span class="section-number-4">1.29.2</span> Exception Basics</h4>
<div class="outline-text-4" id="text-1-29-2">
<p>
C++ can throw any type as exception: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">throw</span> 10
Error <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: Exception caught<span class="org-negation-char">!</span>
&gt;&gt; 
&gt;&gt; <span class="org-keyword">throw</span> <span class="org-string">"hello world"</span>
Error <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: Exception caught<span class="org-negation-char">!</span>
&gt;&gt; 
&gt;&gt; <span class="org-keyword">throw</span> 34.212
Error <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: Exception caught<span class="org-negation-char">!</span>
&gt;&gt; 
&gt;&gt; <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Illegal state exception!"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Error</span> <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: <span class="org-constant">std</span>::runtime_error caught: Illegal state exception<span class="org-negation-char">!</span>

&gt;&gt; <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Error: number of elements cannot be negative."</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Error</span> <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: <span class="org-constant">std</span>::invalid_argument caught: Error: number of elements cannot be negative.
&gt;&gt; 
&gt;&gt; <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Invalid element index. Aborting operation!"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Error</span> <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: <span class="org-constant">std</span>::out_of_range caught: Invalid element index. Aborting operation<span class="org-negation-char">!</span>

</pre>
</div>

<p>
Catching exceptions: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">testException</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">action</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span>
         action<span class="org-rainbow-delimiters-depth-3">()</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">handle of std::invalid_argument</span>
     <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">invalid_argument</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">){</span>
          <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [ERROR] {std::invalid_argument} \n =&gt; "</span>
                    &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
          <span class="org-keyword">return</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">handle of std::out_of_range</span>
     <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">out_of_range</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">){</span>
          <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [ERROR] {std::out_of_range} \n =&gt; "</span>
                    &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
          <span class="org-keyword">return</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">exception</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">){</span>
          <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [ERROR] {std::exception} \n =&gt; "</span>
                    &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
          <span class="org-keyword">return</span>;
     <span class="org-rainbow-delimiters-depth-2">}</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Executed gracefully. OK"</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; testException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Fatal error 0xBAF5F8"</span><span class="org-rainbow-delimiters-depth-3">)</span>;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>ERROR<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-constant">std</span>::exception<span class="org-rainbow-delimiters-depth-1">}</span> 
 =&gt; Fatal error 0xBAF5F8

&gt;&gt; testException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::invalid_argument<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Expected x = 10"</span><span class="org-rainbow-delimiters-depth-3">)</span>;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>ERROR<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-constant">std</span>::invalid_argument<span class="org-rainbow-delimiters-depth-1">}</span> 
 =&gt; Expected x = 10
&gt;&gt; 

&gt;&gt; testException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Error: given invalid index."</span><span class="org-rainbow-delimiters-depth-3">)</span>;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>ERROR<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-constant">std</span>::out_of_range<span class="org-rainbow-delimiters-depth-1">}</span> 
 =&gt; Error: given invalid index.
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Crash the program as it cannot handle this exception </span>
&gt;&gt; testException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-keyword">throw</span> 10 ;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Error</span> <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: Exception caught<span class="org-negation-char">!</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Crash again!</span>
&gt;&gt; testException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-keyword">throw</span> <span class="org-string">"hello world"</span> ;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-type">Error</span> <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: Exception caught<span class="org-negation-char">!</span>
&gt;&gt; 

&gt;&gt; testException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::overflow_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Number cannot be represented. Overflow error!"</span><span class="org-rainbow-delimiters-depth-3">)</span>;<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>ERROR<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-constant">std</span>::exception<span class="org-rainbow-delimiters-depth-1">}</span> 
 =&gt; Number cannot be represented. Overflow error<span class="org-negation-char">!</span>
&gt;&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-org1a88d90" class="outline-4">
<h4 id="org1a88d90"><span class="section-number-4">1.29.3</span> Types of Program termination</h4>
<div class="outline-text-4" id="text-1-29-3">
<p>
<b>Types of program/process termination</b> 
</p>

<p>
C++ has two types of process termination, normal and abnormal. 
</p>

<ul class="org-ul">
<li><span class="underline">normal termination</span> (aka normal exit)
<ul class="org-ul">
<li>Happens when the main function finishes its execution returning
an integer status code or the function std::exit(int status) is
called. When it happens, all objects with automatic (stack
allocated) and static storage (global objects) are destroyed and
their destructors called.</li>
</ul></li>

<li><span class="underline">abnormal termination</span> (aka abnormal exits)

<ul class="org-ul">
<li>Happens when the function <a href="https://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a> is called raising the
SIGABRT signal (abort signal). This function terminates the
program without calling destructors of automatic, thread or
static storage duration, thefore resources are not cleaned up.</li>

<li>The function std::abort is also called when an assertion macro
fails from <a href="https://en.cppreference.com/w/cpp/error/assert">&lt;cassert&gt;</a> header fails.</li>
</ul></li>
</ul>

<p>
<b>Causes of Abnormal Termination</b> - std::terminate 
</p>

<p>
When the function <a href="https://en.cppreference.com/w/cpp/error/terminate">std::terminate</a> is called by the C++ runtime, it
calls <a href="https://en.cppreference.com/w/cpp/error/terminate_handler">std::terminate_handler</a> callback function which is set by default
to <a href="https://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a>, which abnormally termintes the program. The function called by
std::terminate can be changed with <a href="https://en.cppreference.com/w/cpp/error/set_terminate">std::set_terminate</a> which sets a new
terminate handler(aka callback).  
</p>

<p>
The functions <a href="https://en.cppreference.com/w/cpp/error/terminate">std::terminate</a> and  <a href="https://en.cppreference.com/w/cpp/utility/program/abort">std::abort</a> are called by the C++
runtime when: 
</p>

<ul class="org-ul">
<li>Uncaught exception =&gt; A thrown exception is not caught with try
&#x2026; catch block.</li>

<li>Constructor of static (global object) and thread-local objects
throw exceptions.</li>

<li>Noexcept specification is violated: a function or member function
annotated with noexcept throws an exception.</li>

<li>A joinable std::thread (thread that is still running) is
destroyed or assigned to.</li>
</ul>

<p>
<b>Further Reading</b> 
</p>

<ul class="org-ul">
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR50-CPP.+Do+not+abruptly+terminate+the+program">ERR50-CPP. Do not abruptly terminate the program - SEI CERT C++ Coding Standard - Confluence</a></li>

<li><a href="https://blog.mozilla.org/nnethercote/2011/01/18/the-dangers-of-fno-exceptions/">The dangers of -fno-exceptions | Nicholas Nethercote</a></li>

<li><a href="https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.cbclx01/cplr163.htm">The terminate() function (C++ only)</a></li>

<li><a href="https://stackoverflow.com/questions/7054685/are-destructors-run-when-calling-exit">c++ - Are destructors run when calling exit()? - Stack Overflow</a></li>

<li><a href="https://www.quora.com/Does-this-C++-program-using-std-exit-really-invoke-undefined-behavior">Does this C++ program using std::exit really invoke undefined behavior? - Quora</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2a699fc" class="outline-4">
<h4 id="org2a699fc"><span class="section-number-4">1.29.4</span> Overriding std::terminate handler</h4>
<div class="outline-text-4" id="text-1-29-4">
<p>
This experiment program overrides std::terminate_handler for testing
what happens with the application and destructors in normal and
abnormal terminations.
</p>

<ul class="org-ul">
<li><p>
File: <a href="src/test_terminate.cpp">file:src/test_terminate.cpp</a>
</p>

<p>
<b>Source Code Listing</b> 
</p></li>
</ul>

<p>
Class DummayClass: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">DummyClass</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-function-name">DummyClass</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Object ctor =&gt; Constructor called."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    ~<span class="org-function-name">DummyClass</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Object dtor =&gt; Destructor called."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Function main() part 1: Instantiante a dummy object of class
DummyClass for testing destructor and constructor. 
</p>

<p>
Function main() part 1: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">DummyClass</span> <span class="org-variable-name">cls</span>;
</pre>
</div>

<p>
Function main() - part 2 
</p>
<ul class="org-ul">
<li>Override <a href="https://en.cppreference.com/w/cpp/error/terminate_handler">std::terminate_handler</a> via std::set_terminate if the
environment variable named TERMINATE is set to the string "true".</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">option</span> = <span class="org-constant">std</span>::getenv<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"TERMINATE"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>option != <span class="org-constant">nullptr</span> &amp;&amp; <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span>option<span class="org-rainbow-delimiters-depth-2">)</span> == <span class="org-string">"true"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] Override std::terminate handler."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Overrides the function called by std::terminate (std::abort by default).</span>
    <span class="org-comment-delimiter">//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">It accepts function pointer or a non-capturing lambda.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Override std::termiante setting std::terminate_handler callback</span>
    <span class="org-constant">std</span>::set_terminate<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[](){</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [FATAL] std::terminate() called; SIGABRT signal abort sent."</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-comment-delimiter">// </span><span class="org-comment">terminate current process sending abrt</span>
        <span class="org-constant">std</span>::abort<span class="org-rainbow-delimiters-depth-4">()</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Function main() - part 3: 
</p>
<ul class="org-ul">
<li>Register function to be called when the program is terminated via
std::atexit. This function accepts function pointer or
non-capturing lambda.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Register function to be called when the program exits.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: It does not override the normal termination behavior.</span>
<span class="org-function-name">std</span>::atexit<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span>
    <span class="org-constant">std</span>::cerr  &lt;&lt; <span class="org-string">" [INFO] Normal termination. Ok."</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Function main() - part 4:  
</p>
<ul class="org-ul">
<li>Handle command line arguments.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>argc &lt; 2<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [ERROR] Missing command. Shutdown"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> 1;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-function-name">std</span>::string cmd = argv<span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>;
</pre>
</div>

<p>
Function main() - part 5:  
</p>
<ul class="org-ul">
<li>Simulate many types of normal and abornal terminations.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>cmd == <span class="org-string">"terminate_normal1"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] Nothing."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">else</span> <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-1">(</span>cmd == <span class="org-string">"terminate_normal2"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] Call std::exit(int status_code);"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::exit<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span>cmd == <span class="org-string">"terminate_except"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] Before throwing exception"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"Invalid input domain"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] After throwing exception"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">else</span> <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-1">(</span>cmd == <span class="org-string">"terminate_thread"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] Joinable thread out of scope without calling .join() or detach"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::<span class="org-type">thread</span> <span class="org-variable-name">th</span><span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-3">[](){</span>
            <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">" [TRACE] Thread running ...."</span><span class="org-rainbow-delimiters-depth-5">)</span>;
                <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-5">(</span>1s<span class="org-rainbow-delimiters-depth-5">)</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Missing thread::join() or thread::detach method call</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; The runtime calls std::terminate()</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::cout  &lt;&lt; <span class="org-string">" [TRACE] End of main function"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-keyword">return</span> 0;
</pre>
</div>

<p>
<b>Building:</b>
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ test_terminate.cpp -o <span class="org-keyword">term</span> -std=c++1z -g -Wall -Wextra -g -lpthread
</pre>
</div>

<p>
<b>Running:</b>
</p>

<ul class="org-ul">
<li>Normal termination:</li>
</ul>

<p>
Termiante via main() return statement. 
</p>

<div class="org-src-container">
<pre class="src src-sh">./term terminate_normal1
 [INFO] Object ctor =&gt; Constructor called.
 [TRACE] Nothing.
 [TRACE] End of main <span class="org-keyword">function</span>
 [INFO] Object dtor =&gt; Destructor called.
 [INFO] Normal termination. Ok.
</pre>
</div>

<p>
Terminate with std::exit.
</p>

<div class="org-src-container">
<pre class="src src-sh">./term terminate_normal2
 [INFO] Object ctor =&gt; Constructor called.
 [TRACE] Call std::exit(int status_code);
 [INFO] Normal termination. Ok.
</pre>
</div>

<ul class="org-ul">
<li>Abornmal termination through uncaught exception</li>
</ul>

<p>
Run without overriding std::set_terminate 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./term terminate_except
 [INFO] Object ctor =&gt; Constructor called.
 [TRACE] Before throwing exception
terminate called after throwing an instance of <span class="org-string">'std::runtime_error'</span>
  what():  Invalid input domain
<span class="org-function-name">Aborted</span> (core dumped)
</pre>
</div>

<p>
Run overriding std::terminate_handler handler by setting environment
variable TERMINATE to string 'true'.
</p>

<div class="org-src-container">
<pre class="src src-sh">$ env <span class="org-variable-name">TERMINATE</span>=true ./term terminate_except
 [INFO] Object ctor =&gt; Constructor called.
 [TRACE] Override std::terminate handler.
 [TRACE] Before throwing exception
 [FATAL] std::terminate() called; SIGABRT signal abort sent.
<span class="org-function-name">Aborted</span> (core dumped)
</pre>
</div>

<ul class="org-ul">
<li>Abornmal termination through joinable std::thread object out of
scope without calling .join() or .detach().</li>
</ul>

<p>
Run without overriding std::terminate_handler
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./term terminate_thread
 [INFO] Object ctor =&gt; Constructor called.
 [TRACE] Joinable thread out of scope without calling .join() or detach
terminate called without an active exception
 [TRACE] Thread running ....
<span class="org-function-name">Aborted</span> (core dumped)
</pre>
</div>

<p>
Run without std::terminate_handler: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ env <span class="org-variable-name">TERMINATE</span>=true ./term terminate_thread
 [INFO] Object ctor =&gt; Constructor called.
 [TRACE] Override std::terminate handler.
 [TRACE] Joinable thread out of scope without calling .join() or detach
 [FATAL] std::terminate() called; SIGABRT signal abort sent. [TRACE] Thread running ....

<span class="org-function-name">Aborted</span> (core dumped)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf5d0cdb" class="outline-4">
<h4 id="orgf5d0cdb"><span class="section-number-4">1.29.5</span> Custom Exceptions</h4>
<div class="outline-text-4" id="text-1-29-5">
<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">enum</span> <span class="org-keyword">class</span> <span class="org-type">ErrorFlags</span> : <span class="org-type">unsigned</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-variable-name">MemoryError</span>     =  0x2A,
    <span class="org-variable-name">NetWorkFailure</span>  =  0xFA,
    <span class="org-variable-name">DNSFailure</span>      =  0x50, 
    <span class="org-variable-name">UnknownError</span>    =  0xAF
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">DownloadException</span>: <span class="org-keyword">public</span> <span class="org-constant">std</span>::<span class="org-type">exception</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">ErrorFlags</span> <span class="org-variable-name">errorCode</span>;
    <span class="org-function-name">DownloadException</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">ErrorFlags</span> <span class="org-variable-name">errorCode</span><span class="org-rainbow-delimiters-depth-2">)</span>
       :errorCode<span class="org-rainbow-delimiters-depth-2">{</span>errorCode<span class="org-rainbow-delimiters-depth-2">}{}</span>  
    <span class="org-keyword">auto</span> <span class="org-function-name">what</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">throw</span><span class="org-rainbow-delimiters-depth-2">()</span> -&gt; <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-rainbow-delimiters-depth-2">{</span>
         <span class="org-keyword">return</span> <span class="org-string">"Error: Download failure. See error code. "</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">void</span> <span class="org-function-name">testDownloadException</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">action</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-constant">std</span>::<span class="org-type">exception_ptr</span> <span class="org-variable-name">p</span>;
    <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        action<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">DownloadException</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"[FAILURE] Error code = "</span>
                  &lt;&lt; <span class="org-constant">std</span>::hex &lt;&lt;  <span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">unsigned</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>ex.errorCode<span class="org-rainbow-delimiters-depth-3">)</span>
                  &lt;&lt; <span class="org-constant">std</span>::dec
                  &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-keyword">return</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span>...<span class="org-rainbow-delimiters-depth-2">){</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Catch all exceptions, log and rethrow        </span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"[FAILURE] Unknown exception."</span> &lt;&lt; <span class="org-string">"\n"</span>;
        p = <span class="org-constant">std</span>::current_exception<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-constant">std</span>::rethrow_exception<span class="org-rainbow-delimiters-depth-3">(</span> p<span class="org-rainbow-delimiters-depth-3">)</span>;     
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Download ended gracefully. OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Testing: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; testDownloadException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){}</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">[</span>INFO<span class="org-rainbow-delimiters-depth-1">]</span> Download ended gracefully. OK.

&gt;&gt; testDownloadException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-keyword">throw</span> DownloadException<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">ErrorFlags</span>::NetWorkFailure<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">Error</span>: Download failure. See error code. 
<span class="org-rainbow-delimiters-depth-1">[</span>FAILURE<span class="org-rainbow-delimiters-depth-1">]</span> Error code = fa
&gt;&gt; 
&gt;&gt; testDownloadException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-keyword">throw</span> DownloadException<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">ErrorFlags</span>::DNSFailure<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">Error</span>: Download failure. See error code. 
<span class="org-rainbow-delimiters-depth-1">[</span>FAILURE<span class="org-rainbow-delimiters-depth-1">]</span> Error code = 50
&gt;&gt; 
&gt;&gt; testDownloadException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-keyword">throw</span> DownloadException<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">ErrorFlags</span>::UnknownError<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-function-name">Error</span>: Download failure. See error code. 
<span class="org-rainbow-delimiters-depth-1">[</span>FAILURE<span class="org-rainbow-delimiters-depth-1">]</span> Error code = af
&gt;&gt; 

&gt;&gt; testDownloadException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Fatal kernel failure!!"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">[</span>FAILURE<span class="org-rainbow-delimiters-depth-1">]</span> Unknown exception.
Error <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: <span class="org-constant">std</span>::runtime_error caught: Fatal kernel failure<span class="org-negation-char">!</span>!

&gt;&gt; testDownloadException<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::out_of_range<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Invalid index"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">[</span>FAILURE<span class="org-rainbow-delimiters-depth-1">]</span> Unknown exception.
Error <span class="org-type">in</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">TRint</span>::HandleTermInput<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>: <span class="org-constant">std</span>::out_of_range caught: Invalid index
&gt;&gt; 
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbdcb8fb" class="outline-4">
<h4 id="orgbdcb8fb"><span class="section-number-4">1.29.6</span> Example - code</h4>
<div class="outline-text-4" id="text-1-29-6">
<p>
File: exceptions.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">ostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">exception</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">struct</span> <span class="org-type">Error</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">reason</span>;
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">errorCode</span>;    
    <span class="org-function-name">Error</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">errorCode</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">reason</span><span class="org-rainbow-delimiters-depth-2">)</span>: errorCode<span class="org-rainbow-delimiters-depth-2">(</span>errorCode<span class="org-rainbow-delimiters-depth-2">)</span>, reason<span class="org-rainbow-delimiters-depth-2">(</span>reason<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-type">void</span> <span class="org-function-name">display</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span><span class="org-rainbow-delimiters-depth-2">){</span>
        os &lt;&lt; <span class="org-string">"Error code = "</span> &lt;&lt; errorCode &lt;&lt; <span class="org-string">"; reason = "</span> &lt;&lt; reason &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">NetworkFailure</span> : <span class="org-keyword">public</span> <span class="org-constant">std</span>::<span class="org-type">exception</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">what</span> <span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">throw</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-keyword">return</span> <span class="org-string">" ==&gt; Error: network failure."</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span> networkFailure;

<span class="org-keyword">struct</span> <span class="org-type">OutOfmemoryError</span> : <span class="org-constant">std</span>::<span class="org-type">exception</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">what</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">throw</span><span class="org-rainbow-delimiters-depth-2">(){</span>
        <span class="org-keyword">return</span> <span class="org-string">"==&gt; Error: there is no enough memory."</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">UnknownError</span> <span class="org-rainbow-delimiters-depth-1">{}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Any object, class or type can be thrown like an Exception.</span>
<span class="org-type">void</span> <span class="org-function-name">exceptionThrower</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">code</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-type">NetworkFailure</span> <span class="org-variable-name">networkFailure</span>;
    <span class="org-keyword">switch</span><span class="org-rainbow-delimiters-depth-2">(</span>code<span class="org-rainbow-delimiters-depth-2">){</span>
    <span class="org-keyword">case</span> 0:
        <span class="org-keyword">throw</span> <span class="org-string">"Error (1) has happened"</span>;
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> 1:
        <span class="org-keyword">throw</span> 4090;
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> 2:
        <span class="org-keyword">throw</span> <span class="org-string">'x'</span>;
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> 3:
        <span class="org-keyword">throw</span> Error<span class="org-rainbow-delimiters-depth-3">(</span>0xffa, <span class="org-string">"Failure to download update."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> 4:
        <span class="org-keyword">throw</span> Error<span class="org-rainbow-delimiters-depth-3">(</span>0xff5, <span class="org-string">"Invalide input parameters."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> 5:
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Runtime error happened."</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> 6:
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::bad_alloc<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> 7:
        <span class="org-keyword">throw</span> OutOfmemoryError<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> 8:
        <span class="org-keyword">throw</span> networkFailure;
        <span class="org-keyword">break</span>;  
    <span class="org-keyword">default</span>:
        <span class="org-keyword">throw</span> UnknownError<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">handleException</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">){</span>
    <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        exceptionThrower<span class="org-rainbow-delimiters-depth-3">(</span>n<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">perror</span><span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"==&gt; [String] An error of type string happened: "</span> &lt;&lt; perror &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">errorCode</span><span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"==&gt; [Int   ] Returned error code = "</span> &lt;&lt; errorCode &lt;&lt; <span class="org-constant">std</span>::endl;       
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">char</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"==&gt; [Char  ] Returned char error code = "</span> &lt;&lt; x &lt;&lt; <span class="org-constant">std</span>::endl;      
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Error</span> <span class="org-variable-name">err</span><span class="org-rainbow-delimiters-depth-2">){</span>
        err.display<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::cerr<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">exception</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"Catch an std::exception. = "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Catch all exceptions - Not recommeded. </span>
    <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-2">(</span>...<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">"==&gt; Unknown exception."</span> &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
    handleException<span class="org-rainbow-delimiters-depth-2">(</span>0<span class="org-rainbow-delimiters-depth-2">)</span>;
    handleException<span class="org-rainbow-delimiters-depth-2">(</span>1<span class="org-rainbow-delimiters-depth-2">)</span>;
    handleException<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span>;
    handleException<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
    handleException<span class="org-rainbow-delimiters-depth-2">(</span>4<span class="org-rainbow-delimiters-depth-2">)</span>;
    handleException<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span>;
    handleException<span class="org-rainbow-delimiters-depth-2">(</span>6<span class="org-rainbow-delimiters-depth-2">)</span>;
    handleException<span class="org-rainbow-delimiters-depth-2">(</span>7<span class="org-rainbow-delimiters-depth-2">)</span>;
    handleException<span class="org-rainbow-delimiters-depth-2">(</span>8<span class="org-rainbow-delimiters-depth-2">)</span>;
    handleException<span class="org-rainbow-delimiters-depth-2">(</span>100<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Finish successfully"</span> &lt;&lt; <span class="org-constant">std</span>::endl;    
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Compiling and running:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ -std=c++11 exceptions.cpp -o <span class="org-keyword">out.bin</span> &amp;&amp; ./out.bin

==&gt; [String] An error of type string happened: Error (1) has happened
==&gt; [Int   ] Returned error code = 4090
==&gt; [Char  ] Returned char error code = x
Error code = 4090; reason = Failure to download update.
Error code = 4085; reason = Invalide input parameters.
Catch an std::exception. = Runtime error happened.
Catch an std::exception. = std::bad_alloc
Catch an std::exception. = ==&gt; Error: there is no enough memory.
Catch an std::exception. =  ==&gt; Error: network failure.
==&gt; Unknown exception.
Finish successfully

</pre>
</div>
</div>
</div>

<div id="outline-container-org6f5a4fa" class="outline-4">
<h4 id="org6f5a4fa"><span class="section-number-4">1.29.7</span> Exception Safety Guarantees</h4>
<div class="outline-text-4" id="text-1-29-7">
<p>
Exception-Safety Concept: 
</p>

<ul class="org-ul">
<li>According to <a href="http://www.stroustrup.com/except.pdf">Stroustrup</a>, an operation is said to be <span class="underline">exception-safe</span>
it it leaves the object in a valid and well-defined state after its
termination when an exception is thrown.</li>

<li>An Exception-Safe code should:

<ul class="org-ul">
<li>Left the the program in a valid state after an exception
happens.</li>

<li>avoid memory leaks =&gt; always release the allocated memory when an
exception happens or no longer needed.</li>

<li>avoid resource leaks =&gt; always release acquired resources such as
socket handlers, file descriptors, database connection handlers,
locks and so on when an exception happens or no longer needed.</li>

<li>not allow data structures being corrupted.</li>
</ul></li>
</ul>


<p>
<b>Levels of Excpetion-Safety Guarantees</b> 
</p>

<p>
Exception-safety guarantees are a set of promises made by class or
library to a client code allowing better reasoning about exceptions. A
library or code can provide the following <span class="underline">exception-safety guarantees</span>,
aka <span class="underline">levels of exception-safety guarantees</span>:
</p>

<ul class="org-ul">
<li><span class="underline">basic exception-safety guarantees</span> (aka <span class="underline">no-leak guarantee</span>)

<ul class="org-ul">
<li>No resources are leaked and the invariants of the component are
preserved.</li>

<li>The component must be in a valid state after the exception is
thrown, but it does not mean that its state was kept.</li>

<li>This is the minimum standard that a library, component, container
or class should implement.</li>
</ul></li>

<li><span class="underline">strong exception-safety guarantees</span> (aka <span class="underline">commit or rollback semantics</span>)

<ul class="org-ul">
<li>Some functions from standard library with strong exception safety guarantee:
<ul class="org-ul">
<li>Member functions for several containers: push_back, push_front
and rehash.</li>
</ul></li>

<li>The component state is kept the same as it was before the
operation has been completed successfuly or thrown an exception.</li>

<li>Summary: if an operation fails, it has no effects.</li>
</ul></li>

<li><span class="underline">no-throw guarantees</span> (aka <span class="underline">no-fail</span> or <span class="underline">failure transparency</span>)

<ul class="org-ul">
<li>The operation does not throw an exception and all operations are
guaranteed to complete successfully with any exception handled
internally, therefore not affecting any client code.</li>

<li>Some functions from standard library with no-throw exception-safe guarantee.
<ul class="org-ul">
<li>Member functions of several containers: erase, pop_back,
pop_front and clear.</li>
<li>Function: <span class="underline">std::swap</span></li>
</ul></li>

<li>Functions with no-throw guarantee can be explicitly annotated
with <a href="https://en.cppreference.com/w/cpp/language/noexcept_spec">noexcept</a> specifier.</li>

<li>The <b>noexcepet</b> specifier annotation for copy constructor and move
constructor allows many functions from the C++ standard library
to choose the most efficient function overloading based on this
annotation. For instance, if the move constructor of a given type
<b>M</b> is not marked with <span class="underline">noexcept</span> specfier, the member function
push_back of std::vector container will not use this constructor,
instead it will use the copy constructor incurring on a copy
overhead and less efficiency. If the annotation is used, the
push_back member function will use move-constructor which makes
the operation more efficient.</li>

<li>Note: If a function or member function is annotated with
noexcept and throws any exception, the function std::terminate is
called terminating the process immediately.</li>
</ul></li>

<li><span class="underline">No exception safety</span>
<ul class="org-ul">
<li>Non guarantees are provided and the object or container may be in
a corrupt state. No exception-safety should be avoided.</li>
</ul></li>

<li><span class="underline">Exception neutral</span> (additional exception-safety level)
<ul class="org-ul">
<li>An exception neutral code does not throw or catch exception. It
only forwards exceptions thrown in the code that it calls to the
client code.</li>
</ul></li>
</ul>


<p>
<b>Principles for exception-safe code</b>
</p>

<ul class="org-ul">
<li>Avoid resouce leaks and memory leaks.</li>

<li>Always keep an object in valid state when an exception is thrown.</li>

<li>Do not destroy a piece of data before its replacement can be
store.</li>
</ul>

<p>
<b>Language features for exception safety</b> 
</p>

<ul class="org-ul">
<li>try-catch block</li>

<li>RAII Idiom - Resource Acquisition Is Initialization technique.

<ul class="org-ul">
<li>Resources, which can be heap-allocated memory, socket handlers,
file descriptiors, database handlers and so on, are acquired in
constructor and released at destructor which are determinstic and
always called when an exception happens.</li>

<li>The C++ language guarantees that a destructor always will be
called at the end of scope where the object is defined or when an
exception happens.</li>

<li>Note: A destructor should always catch all exceptions and never
allow them to propagate from them, otherwise, the program will be
terminated immediately.</li>
</ul></li>

<li>Copy-and-swap idiom</li>
</ul>

<p>
References: 
</p>

<ul class="org-ul">
<li><b>Exception Safety: Concepts and Techniques</b>  - Bjarne Stroutrup [BEST]
<ul class="org-ul">
<li><a href="http://www.stroustrup.com/except.pdf">http://www.stroustrup.com/except.pdf</a></li>
</ul></li>

<li><b>Progamming with Exceptions</b> - Bjarne Stroustrup
<ul class="org-ul">
<li><a href="http://www.informit.com/articles/article.aspx?p=21084">http://www.informit.com/articles/article.aspx?p=21084</a></li>
</ul></li>

<li><b>Standard Library Exception Safety</b>  - Bjarne Stroustrup  [BEST]
<ul class="org-ul">
<li><a href="https://www.cise.ufl.edu/~manuel/stroustrup/ex.pdf">https://www.cise.ufl.edu/~manuel/stroustrup/ex.pdf</a></li>
</ul></li>

<li><b>Exception Safety in Generic Components</b> - David Abrahams
<ul class="org-ul">
<li><a href="https://www.boost.org/community/exception_safety.html">https://www.boost.org/community/exception_safety.html</a></li>
</ul></li>

<li><b>Exception Safety Analysis</b> - Andrei Alexandrescu
<ul class="org-ul">
<li><a href="http://www.drdobbs.com/exception-safety-analysis/184401728">http://www.drdobbs.com/exception-safety-analysis/184401728</a></li>
</ul></li>

<li><b>C++ Core Guidelines: Rules for Error Handling</b> - Rainer Grimm [BEST]
<ul class="org-ul">
<li><a href="https://www.modernescpp.com/index.php/c-core-guidelines-rules-to-error-handling">https://www.modernescpp.com/index.php/c-core-guidelines-rules-to-error-handling</a></li>
</ul></li>

<li><b>Design Patterns in C++ - Safety to exceptions</b> - Giuseppe Lipari [BEST]   
<ul class="org-ul">
<li><a href="http://retis.sssup.it/~lipari/courses/oosd2010-2/09.exception_safety.pdf">http://retis.sssup.it/~lipari/courses/oosd2010-2/09.exception_safety.pdf</a></li>
</ul></li>

<li><b>Using Exception in C++ - a practical guide</b> - Zibigniew Skowron [BEST]
<ul class="org-ul">
<li><a href="http://cpp.mimuw.edu.pl/files/Using%20Exceptions%20in%20C++.pdf">http://cpp.mimuw.edu.pl/files/Using Exceptions in C++.pdf</a></li>
</ul></li>

<li><b>5 Exception Safety - Handling Errors and Exceptions</b> - University of Hellsinki [BEST]
<ul class="org-ul">
<li><a href="https://www.cs.helsinki.fi/u/vihavain/s08/cpp/slides/CppCh5_2.pdf">https://www.cs.helsinki.fi/u/vihavain/s08/cpp/slides/CppCh5_2.pdf</a></li>
</ul></li>

<li><b>C++ Exception Safety</b> - Ali Çehreli [BEST]
<ul class="org-ul">
<li><a href="http://acehreli.org/turkcecpp/exception_safety.pdf">http://acehreli.org/turkcecpp/exception_safety.pdf</a></li>
</ul></li>

<li><b>Part 9 - Exception Safety</b>
<ul class="org-ul">
<li><a href="https://wiki.ifs.hsr.ch/CppAdvanced/files/lecture_09_exception_safety.pdf">https://wiki.ifs.hsr.ch/CppAdvanced/files/lecture_09_exception_safety.pdf</a></li>
</ul></li>

<li><b>Make Move Constructor No-Throw</b>
<ul class="org-ul">
<li><a href="http://blogs.microsoft.co.il/sasha/2014/08/08/make-move-constructors-no-throw/">http://blogs.microsoft.co.il/sasha/2014/08/08/make-move-constructors-no-throw/</a></li>
</ul></li>

<li><b>How to: Design for Exception Safety</b> - Microsoft [BEST]
<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/cpp/cpp/how-to-design-for-exception-safety?view=vs-2019">https://docs.microsoft.com/en-us/cpp/cpp/how-to-design-for-exception-safety?view=vs-2019</a></li>
</ul></li>

<li><b>Generic: Change the Way you write Exception-Safe Code - Forever</b> -
Andrei Alexandrescu and Petru Marginean
<ul class="org-ul">
<li><a href="http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758">http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758</a></li>
</ul></li>

<li><b>Effective C++ item 29: Strive For Exception-safe Code</b>
<ul class="org-ul">
<li><a href="http://blog.ycshao.com/2017/11/15/effective-c-item-29-strive-for-exception-safe-code/">http://blog.ycshao.com/2017/11/15/effective-c-item-29-strive-for-exception-safe-code/</a></li>
</ul></li>

<li><b>Making Operations on standard library containers strong exception safe</b>
<ul class="org-ul">
<li><a href="https://pdfs.semanticscholar.org/2a6a/30b9f7cd82ef29b64fbecae10463d533a6da.pdf">https://pdfs.semanticscholar.org/2a6a/30b9f7cd82ef29b64fbecae10463d533a6da.pdf</a></li>
</ul></li>

<li><b>Exceptions</b> - CppReference
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></li>
</ul></li>

<li><b>ERR56-CPP. Guarantee exception safety</b>
<ul class="org-ul">
<li><a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR56-CPP.+Guarantee+exception+safety">https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR56-CPP.+Guarantee+exception+safety</a></li>
</ul></li>

<li><b>Exception Safety</b> - QT Documentation
<ul class="org-ul">
<li><a href="https://doc.qt.io/qt-5/exceptionsafety.html">https://doc.qt.io/qt-5/exceptionsafety.html</a></li>
</ul></li>

<li>Question - <b>Do you (really) write exception safe code?</b>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/1853243/do-you-really-write-exception-safe-code">https://stackoverflow.com/questions/1853243/do-you-really-write-exception-safe-code</a></li>
</ul></li>

<li><b>Exception Safety</b> - Wikipedia
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Exception_safety">https://en.wikipedia.org/wiki/Exception_safety</a></li>
</ul></li>

<li><b>Copy-and-Swap Pattern</b>
<ul class="org-ul">
<li><a href="https://cpppatterns.com/patterns/copy-and-swap.html">https://cpppatterns.com/patterns/copy-and-swap.html</a></li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org442c4a5" class="outline-3">
<h3 id="org442c4a5"><span class="section-number-3">1.30</span> C++11 Tuples</h3>
<div class="outline-text-3" id="text-1-30">
</div>
<div id="outline-container-orgfb08d45" class="outline-4">
<h4 id="orgfb08d45"><span class="section-number-4">1.30.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-30-1">
<p>
Tuples are a generic containers (product type) common in functional
languages for storing heterogeneous types. Some use cases for tuples
are, grouping unrelated types into a single object and returning multiple
values from functions. C++11 provide tuples in the
standard library in the header &lt;tuple&gt;. 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/utility/tuple">std::tuple - cppreference.com</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgcee4001" class="outline-4">
<h4 id="orgcee4001"><span class="section-number-4">1.30.2</span> Function std::make_tuple</h4>
<div class="outline-text-4" id="text-1-30-2">
<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> coord0 = <span class="org-constant">std</span>::make_tuple<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Madrid"</span>, 40.4168, -3.7038<span class="org-rainbow-delimiters-depth-1">)</span>;

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;(</span>coord0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">char</span>*<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"Madrid"</span>
&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(</span>coord0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 40.416800
&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>2<span class="org-rainbow-delimiters-depth-1">&gt;(</span>coord0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -3.7038000
&gt;&gt; 

&gt;&gt; coord0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">tuple</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">const</span> <span class="org-type">char</span> *, <span class="org-type">double</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"Madrid"</span>, 40.416800, -3.7038000 <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"City = "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;(</span>coord0<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
City = Madrid

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Latitude = "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(</span>coord0<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
Latitude = 40.4168

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Longitude = "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>2<span class="org-rainbow-delimiters-depth-1">&gt;(</span>coord0<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
Longitude = -3.7038
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf0ad25a" class="outline-4">
<h4 id="orgf0ad25a"><span class="section-number-4">1.30.3</span> Example in Cling REPL</h4>
<div class="outline-text-4" id="text-1-30-3">
<p>
Create database row: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">DbRow</span> = <span class="org-constant">std</span>::<span class="org-type">tuple</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span>;
</pre>
</div>

<p>
Create an instance of the tuple: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; DbRow<span class="org-rainbow-delimiters-depth-1">(</span>200, 500.23, <span class="org-string">"Diesel Power Generator"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span>DbRow<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 200, 500.23000, <span class="org-string">"Diesel Power Generator"</span> <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; DbRow<span class="org-rainbow-delimiters-depth-1">(</span>51300, 1.2, <span class="org-string">"1 kg Orange"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span>DbRow<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 51300, 1.2000000, <span class="org-string">"1 kg Orange"</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 
</pre>
</div>

<p>
Get tuple elements: (std::get&lt;INDEX&gt;)
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> row = DbRow<span class="org-rainbow-delimiters-depth-1">(</span>51300, 1.2, <span class="org-string">"1 kg Orange"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span> 51300, 1.2000000, <span class="org-string">"1 kg Orange"</span> <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;(</span>row<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 51300

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(</span>row<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 1.2000000

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>2<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-type">row</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"1 kg Orange"</span>
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;(</span>row<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">" / "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(</span>row<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">" / "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>2<span class="org-rainbow-delimiters-depth-1">&gt;(</span>row<span class="org-rainbow-delimiters-depth-1">)</span> &lt;&lt; <span class="org-string">"\n\n"</span> ;
51300 / 1.2 / 1 kg Orange
</pre>
</div>


<p>
Split tuple elements: (std::tie)
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-constant">std</span>::tie<span class="org-rainbow-delimiters-depth-1">(</span>Index, Price, Name<span class="org-rainbow-delimiters-depth-1">)</span> = row
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">tuple</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 51300, 1.2000000, <span class="org-string">"1 kg Orange"</span> <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; Index
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 51300

&gt;&gt; Price
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 1.2000000

&gt;&gt; Name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"1 kg Orange"</span>
&gt;&gt; 

</pre>
</div>

<p>
Create function to print tuple:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">printTuple</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">DbRow</span>&amp; <span class="org-variable-name">row</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Id    = "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-2">&lt;</span>0<span class="org-rainbow-delimiters-depth-2">&gt;(</span>row<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Name  = "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-2">&lt;</span>1<span class="org-rainbow-delimiters-depth-2">&gt;(</span>row<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Price = "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-2">&lt;</span>2<span class="org-rainbow-delimiters-depth-2">&gt;(</span>row<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Pass tuple to function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; printTuple<span class="org-rainbow-delimiters-depth-1">(</span>row<span class="org-rainbow-delimiters-depth-1">)</span>
Id    = 51300
Name  = 1.2
Price = 1 kg Orange

&gt;&gt; printTuple<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::tuple<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;(</span>100, 12.5, <span class="org-string">"1kg Fresh Bacon"</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
Id    = 100
Name  = 12.5
Price = 1kg Fresh Bacon
&gt;&gt; 

&gt;&gt; printTuple<span class="org-rainbow-delimiters-depth-1">(</span>DbRow<span class="org-rainbow-delimiters-depth-2">{</span>100, 12.5, <span class="org-string">"1kg Fresh Bacon"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
Id    = 100
Name  = 12.5
Price = 1kg Fresh Bacon

&gt;&gt; printTuple<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">{</span>100, 12.5, <span class="org-string">"1kg Fresh Bacon"</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
Id    = 100
Name  = 12.5
Price = 1kg Fresh Bacon
&gt;&gt;                                                 
</pre>
</div>

<p>
Return tuple from function: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Profit margin in percent </span>
<span class="org-type">DbRow</span> <span class="org-function-name">makeProduct</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-variable-name">profitMargin</span>, <span class="org-type">int</span> <span class="org-variable-name">index</span>, <span class="org-type">double</span> <span class="org-variable-name">price</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-type">double</span> <span class="org-variable-name">factor</span> = <span class="org-rainbow-delimiters-depth-2">(</span>profitMargin + 100.0<span class="org-rainbow-delimiters-depth-2">)</span> / 100.0; 
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">{</span>index, factor * price, name <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-keyword">auto</span> p = makeProduct<span class="org-rainbow-delimiters-depth-1">(</span>15.0, 600, 1.5, <span class="org-string">"Water bottle 1L - Brand XPMFN"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span> 600, 1.7250000, <span class="org-string">"Water bottle 1L - Brand XPMFN"</span> <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;(</span>p<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 600

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(</span>p<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 1.7250000

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>2<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-type">p</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"Water bottle 1L - Brand XPMFN"</span>
</pre>
</div>

<p>
Change tuple elements: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> r = DbRow<span class="org-rainbow-delimiters-depth-1">{</span>-1, 0, <span class="org-string">"Dummy Product"</span><span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-rainbow-delimiters-depth-1">{</span> -1, 0.0000000, <span class="org-string">"Dummy Product"</span> <span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;(</span>r<span class="org-rainbow-delimiters-depth-1">)</span> 
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> -1

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>0<span class="org-rainbow-delimiters-depth-1">&gt;(</span>r<span class="org-rainbow-delimiters-depth-1">)</span> = 500
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 500

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(</span>r<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>1<span class="org-rainbow-delimiters-depth-1">&gt;(</span>r<span class="org-rainbow-delimiters-depth-1">)</span> = 200.0 
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 200.00000

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>2<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-type">r</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"Dummy Product"</span>

&gt;&gt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-1">&lt;</span>2<span class="org-rainbow-delimiters-depth-1">&gt;(</span>r<span class="org-rainbow-delimiters-depth-1">)</span> = <span class="org-string">"Super high power diesel"</span>
<span class="org-string">"Super high power diesel"</span>

&gt;&gt; r
<span class="org-rainbow-delimiters-depth-1">{</span> 500, 200.00000, <span class="org-string">"Super high power diesel"</span> <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfa81bf2" class="outline-4">
<h4 id="orgfa81bf2"><span class="section-number-4">1.30.4</span> Example - sample source code</h4>
<div class="outline-text-4" id="text-1-30-4">
<p>
Example: 
</p>

<ul class="org-ul">
<li>File: cpp11Tuples.cpp</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">sstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">tuple</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Type synonym </span>
<span class="org-keyword">using</span> <span class="org-type">DbRow</span> = <span class="org-constant">std</span>::<span class="org-type">tuple</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-function-name">std</span>::string toString<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">DbRow</span>&amp; <span class="org-variable-name">row</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::<span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>;
        ss &lt;&lt; <span class="org-string">"id = "</span>       &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-2">&lt;</span>0<span class="org-rainbow-delimiters-depth-2">&gt;(</span>row<span class="org-rainbow-delimiters-depth-2">)</span>
           &lt;&lt; <span class="org-string">" ; price = "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-2">&lt;</span>1<span class="org-rainbow-delimiters-depth-2">&gt;(</span>row<span class="org-rainbow-delimiters-depth-2">)</span>
           &lt;&lt; <span class="org-string">"; name = "</span>   &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-2">&lt;</span>2<span class="org-rainbow-delimiters-depth-2">&gt;(</span>row<span class="org-rainbow-delimiters-depth-2">)</span>
           &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-keyword">return</span> ss.str<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">printInventory</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DbRow</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">inventory</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">cout</span>;
        <span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">endl</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span> &amp;<span class="org-variable-name">p</span>: inventory<span class="org-rainbow-delimiters-depth-2">){</span>
                <span class="org-type">int</span> <span class="org-variable-name">id</span>;
                <span class="org-type">double</span> <span class="org-variable-name">price</span>;
                <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>;
                <span class="org-constant">std</span>::tie<span class="org-rainbow-delimiters-depth-3">(</span>id, price, name<span class="org-rainbow-delimiters-depth-3">)</span> = p;
                cout &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>10<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; id
                         &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>10<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-3">(</span>2<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-constant">std</span>::fixed &lt;&lt; price
                         &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>5<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-string">" "</span>
                         &lt;&lt; <span class="org-constant">std</span>::left  &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-3">(</span>10<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; name
                         &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">cout</span>;
        <span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">endl</span>;
        <span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">string</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Database row </span>
        <span class="org-constant">std</span>::<span class="org-type">tuple</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">string</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">row1</span><span class="org-rainbow-delimiters-depth-2">(</span>412, 200.41, <span class="org-string">"battery pack"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-type">DbRow</span> <span class="org-variable-name">row2</span><span class="org-rainbow-delimiters-depth-2">(</span>100, 20.5, <span class="org-string">"something else"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        cout &lt;&lt; <span class="org-string">"Product 1 = "</span> &lt;&lt; toString<span class="org-rainbow-delimiters-depth-2">(</span>row1<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; endl;
        cout &lt;&lt; <span class="org-string">"Product 2 = "</span> &lt;&lt; toString<span class="org-rainbow-delimiters-depth-2">(</span>row2<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; endl;

        <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">DbRow</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">dataset</span> = <span class="org-rainbow-delimiters-depth-2">{</span>
                DbRow<span class="org-rainbow-delimiters-depth-3">(</span>100, 2.5,  <span class="org-string">"apples"</span><span class="org-rainbow-delimiters-depth-3">)</span>,
                DbRow<span class="org-rainbow-delimiters-depth-3">(</span>200, 1.4,  <span class="org-string">"oranges"</span><span class="org-rainbow-delimiters-depth-3">)</span>,
                DbRow<span class="org-rainbow-delimiters-depth-3">(</span>300, 12.4, <span class="org-string">"sugar"</span><span class="org-rainbow-delimiters-depth-3">)</span>,
                DbRow<span class="org-rainbow-delimiters-depth-3">(</span>205, 20.5, <span class="org-string">"coffee"</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-2">}</span>;

        printInventory<span class="org-rainbow-delimiters-depth-2">(</span>dataset<span class="org-rainbow-delimiters-depth-2">)</span>;         
        <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ cpp11Tuples.cpp -o <span class="org-keyword">cpp11Tuples.bin</span> -g -std=c++11 -Wall -Wextra &amp;&amp; ./cpp11Tuples.bin
Product 1 = id = 412 ; price = 200.41; name = battery pack

Product 2 = id = 100 ; price = 20.5; name = something else

       100      2.50     apples    
       200      1.40     oranges   
       300     12.40     sugar     
       205     20.50     coffee    
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6a29c10" class="outline-3">
<h3 id="org6a29c10"><span class="section-number-3">1.31</span> Handling Signals</h3>
<div class="outline-text-3" id="text-1-31">
</div>
<div id="outline-container-org5692af2" class="outline-4">
<h4 id="org5692af2"><span class="section-number-4">1.31.1</span> Oveview</h4>
<div class="outline-text-4" id="text-1-31-1">
<p>
Signals are software interrupts sent to a process by the operating
system. The signals can be generated by memory corruption; user
pressing Ctrl + Z in ther terminal; killing the process on Unix-like
OSes with command $ kill &lt;Process-ID&gt; and so on. 
</p>

<p>
Headers: 
</p>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/header/csignal">&lt;csignal&gt;</a> Cppreference</li>
<li><a href="http://www.cplusplus.com/reference/csignal/">&lt;csignal&gt;</a> CplusPlus</li>
</ul>

<p>
More about signals at: 
</p>
<ul class="org-ul">
<li><a href="https://www.sharcnet.ca/help/index.php/Signal_Handling_and_Checkpointing">Signal Handling and Checkpointing - Documentation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Signal_(IPC)">Signal (IPC) - Wikipedia</a></li>
<li><a href="http://www.yolinux.com/TUTORIALS/C++Signals.html">C/C++ signal handling</a></li>
<li><a href="http://man7.org/linux/man-pages/man7/signal.7.html">signal(7) - Linux manual page</a></li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 13:</span> Listing of signals that can be sent to a process</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Signal Macro</th>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SIGINT</td>
<td class="org-left">Signal Interrupt</td>
<td class="org-left">Generated when user types Ctrl + C</td>
</tr>

<tr>
<td class="org-left">SIGTSTP (Posix)</td>
<td class="org-left">Terminal Stop Signal</td>
<td class="org-left">Generated when user types Ctrl + Z on any Unix-like OS.</td>
</tr>

<tr>
<td class="org-left">SIGTERM</td>
<td class="org-left">Signal Terminal Request</td>
<td class="org-left">Signal sent by Unix command $ kill &lt;PID&gt;</td>
</tr>

<tr>
<td class="org-left">SIGABRT</td>
<td class="org-left">Signal Abort</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGFPE</td>
<td class="org-left">Singla Float-Point Exception</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGILL</td>
<td class="org-left">Signal Illegal Instruction</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGSEGV</td>
<td class="org-left">Signal Segmentation Violation</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">SIGQUIT (Posix)</td>
<td class="org-left">Signal Quit</td>
<td class="org-left">Terminate program with a core dump (Ctrl + \) Unix-like OS only.</td>
</tr>

<tr>
<td class="org-left">SIGHUP (Posix)</td>
<td class="org-left">Signal hang-up</td>
<td class="org-left">Parent terminal process killed.</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Additional signals at <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html">signals.h</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html">Terminal Signals - Linux GlibC</a></li>
</ul>

<p>
<b>Function Signal:</b> 
</p>

<p>
Install signal handler or callback function that is called when a
given signal is sent to the current process. 
</p>

<p>
Signature: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-type">void</span> <span class="org-function-name">signal</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">SIGNAL</span>, <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-function-name">HANDLER</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-1">)</span>;

 <span class="org-comment-delimiter">// </span><span class="org-comment">Or: </span>
 <span class="org-type">void</span> <span class="org-function-name">signal</span><span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-type">int</span> <span class="org-variable-name">SIGNAL</span>,            <span class="org-comment-delimiter">/* </span><span class="org-comment">Signal */</span>
              <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-function-name">HANDLER</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">Callback (function-pointer) */</span>
            <span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Or: </span>
 <span class="org-type">void</span> <span class="org-function-name">signal</span><span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-type">int</span> <span class="org-variable-name">SIGNAL</span>,            <span class="org-comment-delimiter">/* </span><span class="org-comment">Signal */</span>
              <span class="org-type">void</span> <span class="org-function-name">HANDLER</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-comment-delimiter">/* </span><span class="org-comment">Callback (function-pointer) */</span>
            <span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-org6dfeebc" class="outline-4">
<h4 id="org6dfeebc"><span class="section-number-4">1.31.2</span> Example</h4>
<div class="outline-text-4" id="text-1-31-2">
<ul class="org-ul">
<li>File: <a href="src/handle-signal.cpp">file:src/handle-signal.cpp</a></li>
</ul>

<p>
Headers: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">map</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">csignal</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">fstream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-comment-delimiter">// </span><span class="org-comment">Unix specific (not valid for MS-Windows)</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">unistd.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">Import getpid()</span>
</pre>
</div>

<p>
Class Dummy used for creating the global static object dummyGlobal:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">Dummy</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-function-name">Dummy</span><span class="org-rainbow-delimiters-depth-2">(){</span>
      <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [TRACE] Program initialized OK "</span>  &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
   ~<span class="org-function-name">Dummy</span><span class="org-rainbow-delimiters-depth-2">(){</span>
      <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [TRACE] All objects destroyed. Program End OK. "</span>  &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">Dummy</span> <span class="org-variable-name">dummyGlobal</span>;
</pre>
</div>


<p>
Function: signal_handler
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">signal_handler</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">signal</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">static auto logger = []{</span>
   <span class="org-comment-delimiter">//   </span><span class="org-comment">auto log = std::ofstream("signals.log");</span>
   <span class="org-comment-delimiter">//   </span><span class="org-comment">log &lt;&lt; " [INFO] Initialized Logger OK." &lt;&lt; std::endl;</span>
   <span class="org-comment-delimiter">//   </span><span class="org-comment">return log; </span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">}();</span>

   <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">logger</span> = <span class="org-constant">std</span>::cerr;

   <span class="org-keyword">const</span> <span class="org-keyword">static</span> <span class="org-constant">std</span>::<span class="org-type">map</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">signalDatabse</span> = <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>SIGINT,   <span class="org-string">"SIGINT"</span><span class="org-rainbow-delimiters-depth-3">}</span>
       ,<span class="org-rainbow-delimiters-depth-3">{</span>SIGABRT,  <span class="org-string">"SIGABRT"</span><span class="org-rainbow-delimiters-depth-3">}</span>
       ,<span class="org-rainbow-delimiters-depth-3">{</span>SIGSEGV,  <span class="org-string">"SIGSEV"</span><span class="org-rainbow-delimiters-depth-3">}</span>
       ,<span class="org-rainbow-delimiters-depth-3">{</span>SIGFPE,   <span class="org-string">"SIGFPE"</span><span class="org-rainbow-delimiters-depth-3">}</span>
       ,<span class="org-rainbow-delimiters-depth-3">{</span>SIGTSTP,  <span class="org-string">"SIGTSTP"</span><span class="org-rainbow-delimiters-depth-3">}</span>
       ,<span class="org-rainbow-delimiters-depth-3">{</span>SIGTERM,  <span class="org-string">"SIGTERM"</span><span class="org-rainbow-delimiters-depth-3">}</span>
       ,<span class="org-rainbow-delimiters-depth-3">{</span>SIGQUIT,  <span class="org-string">"SIGQUIT"</span><span class="org-rainbow-delimiters-depth-3">}</span>
     <span class="org-rainbow-delimiters-depth-2">}</span>;

   <span class="org-comment-delimiter">// </span><span class="org-comment">std::cin.ignore(1000);</span>
   <span class="org-constant">std</span>::cin.clear<span class="org-rainbow-delimiters-depth-2">()</span>;

   <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">sigName</span>;

   <span class="org-keyword">auto</span> <span class="org-variable-name">it</span> = signalDatabse.find<span class="org-rainbow-delimiters-depth-2">(</span>signal<span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>it != signalDatabse.end<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>
     sigName = it-&gt;second;
   <span class="org-keyword">else</span>
     sigName = <span class="org-string">"UNKNOWN"</span>;

   logger &lt;&lt; <span class="org-string">"\n [INFO] "</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="org-string">"() "</span>
          &lt;&lt; <span class="org-string">" Received signal = {"</span> &lt;&lt; sigName &lt;&lt; <span class="org-string">"} =&gt; code = "</span> &lt;&lt; signal &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Function main(): 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">pid_t</span> <span class="org-variable-name">pid</span> = ::getpid<span class="org-rainbow-delimiters-depth-1">()</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" Process ID =  "</span> &lt;&lt; pid &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" Attach to it with $ gdb --tui --pid="</span> &lt;&lt; pid &lt;&lt; <span class="org-string">"\n"</span>;

<span class="org-function-name">std</span>::signal<span class="org-rainbow-delimiters-depth-1">(</span>SIGINT,  &amp;signal_handler<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::signal<span class="org-rainbow-delimiters-depth-1">(</span>SIGFPE,  &amp;signal_handler<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::signal<span class="org-rainbow-delimiters-depth-1">(</span>SIGTERM,  signal_handler<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::signal<span class="org-rainbow-delimiters-depth-1">(</span>SIGTSTP,  signal_handler<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-function-name">std</span>::signal<span class="org-rainbow-delimiters-depth-1">(</span>SIGQUIT,  signal_handler<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">int</span> <span class="org-variable-name">n</span> = 0;
<span class="org-type">char</span> <span class="org-variable-name">ch</span> = 0;

<span class="org-function-name">std</span>::string line;

<span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::cin.good<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">){</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Variable n = "</span> &lt;&lt; n++ &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; Input = "</span>;
   <span class="org-constant">std</span>::getline<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::cin, line<span class="org-rainbow-delimiters-depth-2">)</span>;

   <span class="org-comment-delimiter">// </span><span class="org-comment">Simulate float-point exception </span>
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>line == <span class="org-string">"sigfpe"</span><span class="org-rainbow-delimiters-depth-2">){</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" 10.0 / 0.0 = "</span> &lt;&lt; 10.0 / 0.0 &lt;&lt; <span class="org-string">"\n"</span>;
   <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">return</span> EXIT_SUCCESS;
</pre>
</div>

<p>
Compiling: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ handle-signal.cpp -o <span class="org-keyword">handle-signal.bin</span> -std=c++1z -g -O0 -Wall 
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./handle-signal.bin 
 [TRACE] Program initialized OK 
 Process ID =  27650
 Attach to it with $ gdb --tui --pid=27650
 Variable n = 0
 =&gt; Input = 
 Variable n = 1
 =&gt; Input = 
 Variable n = 2

 <span class="org-comment-delimiter"># </span><span class="org-comment">User types Ctrl + C</span>
 =&gt; Input = ^C
 [INFO] signal_handler()  Received signal = {SIGINT} =&gt; code = 2

 Variable n = 3

 <span class="org-comment-delimiter"># </span><span class="org-comment">User types Ctrl + Z </span>
 =&gt; Input = ^Z
 [INFO] signal_handler()  Received signal = {SIGTSTP} =&gt; code = 20

 <span class="org-comment-delimiter"># </span><span class="org-comment">User types Ctrl + \ </span>
 Variable n = 4
 =&gt; Input = ^<span class="org-sh-escaped-newline">\</span>
 [INFO] signal_handler()  Received signal = {SIGQUIT} =&gt; code = 3

 <span class="org-comment-delimiter"># </span><span class="org-comment">User runs from another terminal $ kill 27650</span>
 Variable n = 5
 =&gt; Input = 
 [INFO] signal_handler()  Received signal = {SIGTERM} =&gt; code = 15
 [TRACE] All objects destroyed. Program End OK. 
(base) 
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7bd6a17" class="outline-3">
<h3 id="org7bd6a17"><span class="section-number-3">1.32</span> Pointer to Function or Function Pointer</h3>
<div class="outline-text-3" id="text-1-32">
</div>
<div id="outline-container-orgb9d522a" class="outline-4">
<h4 id="orgb9d522a"><span class="section-number-4">1.32.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-32-1">
<p>
In C++, functions pointers are not so common as in C. However, they
are still useful when it is necessary to call a C-library which uses
this type of pointer for callbacks and event handlers.
</p>

<p>
It is preferrable to use std::function for callbacks and higher order
functions instead of function pointers as std::function can be used
with anything callable, such as function pointers, functors
(function-objects) or C++11 lambdas. 
</p>

<p>
Use cases of function pointers in C:
</p>
<ul class="org-ul">
<li>Callbacks</li>
<li>Higher Order Functions</li>
<li>Event Handlers</li>
</ul>

<p>
Use cases of function pointers in C++:
</p>
<ul class="org-ul">
<li>Type erasure of functions.</li>
<li>Interfacing C-libraries.</li>
<li>Creating C++ wrappers for C-libraries.</li>
<li>Load functions at runtime from a DLL, shared library on Windows or
Shared Object on U*nix (Linux, BSD, OSX, &#x2026;).</li>
</ul>

<p>
<b>Function pointer variable declaration:</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp">ReturnType <span class="org-rainbow-delimiters-depth-1">(</span>* VariableName<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ArgType0, ArgType1, ArgType2 ....<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">OR -&gt; Intitalized to null </span>
ReturnType <span class="org-rainbow-delimiters-depth-1">(</span>* VariableName<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ArgType0, ArgType1, ArgType2 ....<span class="org-rainbow-delimiters-depth-1">)</span> = <span class="org-constant">nullptr</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Initialized to the address of some function </span>
ReturnType <span class="org-rainbow-delimiters-depth-1">(</span>* VariableName<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ArgType0, ArgType1, ArgType2 ....<span class="org-rainbow-delimiters-depth-1">)</span> = FUNCTION1;
ReturnType <span class="org-rainbow-delimiters-depth-1">(</span>* VariableName<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ArgType0, ArgType1, ArgType2 ....<span class="org-rainbow-delimiters-depth-1">)</span> = &amp;FUNCTION1;
</pre>
</div>

<p>
<b>Function pointer Type Synonym - Prior to C++11</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">typedef</span> <span class="org-type">ReturnType</span> <span class="org-rainbow-delimiters-depth-1">(</span>* <span class="org-type">PointerAliasType</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ArgType0, ArgType1, ArgType2 ....<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">PointerAliasType</span> <span class="org-variable-name">fp</span> = <span class="org-constant">nullptr</span>;
<span class="org-type">PointerAliasType</span> <span class="org-variable-name">fp</span> = &amp;FUNCTION1;
<span class="org-type">PointerAliasType</span> <span class="org-variable-name">fp</span> = FUNCTION1;

<span class="org-comment-delimiter">// </span><span class="org-comment">Call </span>
<span class="org-type">ReturnType</span> <span class="org-variable-name">result</span> = fp<span class="org-rainbow-delimiters-depth-1">(</span>arg0, arg1, arg2, ... argn1<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Function pointer Type Synonym - C++11</b> (better and more readable)
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">PointerAliasType</span> = ReturnType <span class="org-rainbow-delimiters-depth-1">(</span>*<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ArgType0, ArgType1, ArgType2 ....<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Or: </span>
<span class="org-keyword">using</span> <span class="org-type">PointerAliasType</span> = <span class="org-keyword">auto</span> <span class="org-rainbow-delimiters-depth-1">(</span>ArgType0, ArgType1, ArgType2 ....<span class="org-rainbow-delimiters-depth-1">)</span> -&gt; ReturnType;
</pre>
</div>

<p>
Examples: 
</p>

<ul class="org-ul">
<li><code>void (* fpointer)(int);</code>
<ul class="org-ul">
<li>Function pointer taking an integer as paremeter and returns
nothing, void.</li>
</ul></li>

<li><code>void* (* fp)(double *);</code>
<ul class="org-ul">
<li>Function pointer that points to a function taking a double
pointer (double *) and returns a void pointer.</li>
</ul></li>

<li><code>int (* myFunPointer)(int, int);</code>
<ul class="org-ul">
<li>Function pointer that points to a function that takes two
integers as parameters and returns an integer.</li>
</ul></li>

<li>double (* FunPointer) (double) = &amp;sin;
<ul class="org-ul">
<li>Function pointer initialized with the address with of the
function sin.</li>
</ul></li>

<li>double (* FunPointer) (double) = sin;
<ul class="org-ul">
<li>Function pointer initialized with the address with of the
function sin.</li>
</ul></li>

<li><code>int (p2* funcp)(double, double) = NULL</code>
<ul class="org-ul">
<li>Function pointer initialized to NULL or zero.</li>
</ul></li>

<li><code>void (*p[10]) (void *) ()</code>
<ul class="org-ul">
<li>Array of 10 pointers to a function that returns void</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org3f38faa" class="outline-4">
<h4 id="org3f38faa"><span class="section-number-4">1.32.2</span> Function Pointer Declaration</h4>
<div class="outline-text-4" id="text-1-32-2">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Declare a function pointer to a function </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">of type: double =&gt; double </span>
&gt;&gt; <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-1">(</span>* mfunptr<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> = <span class="org-constant">nullptr</span>;

&gt;&gt; mfunptr = sin
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> Function @0x7ff56aa56f80

&gt;&gt; mfunptr<span class="org-rainbow-delimiters-depth-1">(</span>M_PI<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 1.2246468e-16

&gt;&gt; mfunptr<span class="org-rainbow-delimiters-depth-1">(</span>M_PI_2<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 1.0000000
&gt;&gt; 

&gt;&gt; mfunptr<span class="org-rainbow-delimiters-depth-1">(</span>1<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000
&gt;&gt; mfunptr<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 2.0000000
&gt;&gt; mfunptr<span class="org-rainbow-delimiters-depth-1">(</span>1000<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 3.0000000
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Pass a non-capturing lambda </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">--------------------------------------------</span>
&gt;&gt; mfunptr = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> 3 * x; <span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>*<span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> Function @0x7ff56bb000c0

&gt;&gt; mfunptr<span class="org-rainbow-delimiters-depth-1">(</span>3<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 9.0000000

&gt;&gt; mfunptr<span class="org-rainbow-delimiters-depth-1">(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 15.000000

<span class="org-comment-delimiter">// </span><span class="org-comment">Pass a capturing lambda =&gt; Cannot pass capturing </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">lambdas to function pointers.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">--------------------------------------------</span>

&gt;&gt; <span class="org-type">double</span> k = 10.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 10.000000

<span class="org-comment-delimiter">//</span>
&gt;&gt; mfunptr = <span class="org-rainbow-delimiters-depth-1">[</span>&amp;<span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-1">](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> 3 * x + k;<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-function-name">ROOT_prompt_31</span>:1:13: error: <span class="org-string">'k'</span> cannot be captured because it does <span class="org-keyword">not</span> have automatic storage duration
mfunptr = <span class="org-rainbow-delimiters-depth-1">[</span>&amp;<span class="org-variable-name">k</span><span class="org-rainbow-delimiters-depth-1">](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> 3 * x + k;<span class="org-rainbow-delimiters-depth-1">}</span>
            ^
&gt;&gt; mfunptr = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">k</span><span class="org-rainbow-delimiters-depth-1">](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> 3 * x + k;<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-function-name">ROOT_prompt_32</span>:1:12: error: <span class="org-string">'k'</span> cannot be captured because it does <span class="org-keyword">not</span> have automatic storage duration
mfunptr = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">k</span><span class="org-rainbow-delimiters-depth-1">](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-keyword">return</span> 3 * x + k;<span class="org-rainbow-delimiters-depth-1">}</span>
           ^
<span class="org-function-name">ROOT_prompt_28</span>:1:8: note: <span class="org-string">'k'</span> declared here
<span class="org-type">double</span> k = 10.0
</pre>
</div>
</div>
</div>

<div id="outline-container-org401281c" class="outline-4">
<h4 id="org401281c"><span class="section-number-4">1.32.3</span> Function Pointer Callbacks</h4>
<div class="outline-text-4" id="text-1-32-3">
<p>
Example 1: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">doTimes</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-2">(</span>* <span class="org-function-name">action</span><span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++<span class="org-rainbow-delimiters-depth-2">)</span>
             action<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">void</span> <span class="org-function-name">printLine</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="org-string">" \n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; doTimes<span class="org-rainbow-delimiters-depth-1">(</span>4, printLine<span class="org-rainbow-delimiters-depth-1">)</span>
i = 0 
i = 1 
i = 2 
i = 3 

</pre>
</div>

<p>
Example 2: 
</p>

<ul class="org-ul">
<li>Higher order function for tabulating numerical functions
implemented with function pointers.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Alternative 1: </span>
<span class="org-type">void</span> <span class="org-function-name">tabulateFun1</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span>* <span class="org-function-name">MathFunc</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::fixed;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; i
                   &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; MathFunc<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>
                   &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Alternative 2: </span>
<span class="org-type">void</span> <span class="org-function-name">tabulateFun2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-function-name">MathFunc</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::fixed;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; i
                   &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; MathFunc<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>
                   &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Syntax 3 (C++11)</span>
<span class="org-type">void</span> <span class="org-variable-name">tabulateFun3</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span> MathFunc <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::fixed;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; i
                   &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; MathFunc<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>
                   &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
The syntax can be simplified with type synonym using "using" (C++11)
or typedef (old standard).
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Type Synonym [1] (C++11)</span>
<span class="org-keyword">using</span> <span class="org-type">MathFunPtr</span> = <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-1">(</span>*<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Type Synonym [2] (C++11)</span>
<span class="org-keyword">using</span> <span class="org-type">MathFunPtr</span> = <span class="org-keyword">auto</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">double</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Type Synonym [3] (Old standards)</span>
<span class="org-keyword">typedef</span> <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-1">(</span>* <span class="org-type">MathFunPtr</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">void</span> <span class="org-function-name">tabulateFun4</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">MathFunPtr</span> <span class="org-variable-name">MathFunc</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::fixed;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; i
                   &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; MathFunc<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>
                   &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
It is not recomended to implement this function using function
pointers. It is better to use the type std::function available in the
header &lt;functional&gt; as it can also work with anything callable such as
C++11 lambdas, functions-objects and function pointers.
</p>

<ul class="org-ul">
<li>Better implementation, more C++ friendly using C++11 std::function
from header &lt;functional&gt;.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">tabulateFunCPP11</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">MathFunc</span><span class="org-rainbow-delimiters-depth-1">){</span>
     <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setprecision<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::fixed;
     <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
         <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>5<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; i
                   &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>10<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; MathFunc<span class="org-rainbow-delimiters-depth-2">(</span>i<span class="org-rainbow-delimiters-depth-2">)</span>
                   &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Running in CLING Repl: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; tabulateFun1<span class="org-rainbow-delimiters-depth-1">(</span>sin<span class="org-rainbow-delimiters-depth-1">)</span>
    0     0.000
    1     0.841
    2     0.909
    3     0.141
   ... ... .... 

&gt;&gt; tabulateFun2<span class="org-rainbow-delimiters-depth-1">(</span>log<span class="org-rainbow-delimiters-depth-1">)</span>
    0      -inf
    1     0.000
    2     0.693
    3     1.099
    4     1.386
   ... ... .... 

&gt;&gt; tabulateFun3<span class="org-rainbow-delimiters-depth-1">(</span>&amp;exp2<span class="org-rainbow-delimiters-depth-1">)</span>
    0     1.000
    1     2.000
    2     4.000
    3     8.000
  ... ... .... 

&gt;&gt; tabulateFun4<span class="org-rainbow-delimiters-depth-1">(</span>&amp;cos<span class="org-rainbow-delimiters-depth-1">)</span>
    0     1.000
    1     0.540
    2    -0.416
   ... ... .... 
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6c75160" class="outline-3">
<h3 id="org6c75160"><a id="ID-07dc0b5f-0486-4c18-b356-226ec48d4834"></a><span class="section-number-3">1.33</span> Pointer to Class Member Function</h3>
<div class="outline-text-3" id="text-1-33">
<p>
In addition to ordinary pointers and function pointers, C++ has member
function pointers which can point to a particular class method and be
used for performing indirect method calls. 
</p>

<p>
Despite member function pointer are much less used than other types of
pointers, they are still useful in lots of use cases such as: 
</p>

<ul class="org-ul">
<li>Implementing callbacks =&gt; Example: QT Slots and Signals.</li>
<li>Creating warappers     =&gt; Example: Boost.Python</li>
<li>Reflection</li>
</ul>

<p>
Pointer to member function declaration: 
</p>

<ul class="org-ul">
<li>It declares a pointer-to-member function of the class
<span class="underline">CLASS_NAME</span>. The pointer variable  is named pVariable and has the
type signature:  <span class="underline">(ARG0, ARG1, &#x2026; ARGN) =&gt; RETURN_TYPE</span></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Define a pointer to member function named 'pVariable' </span>
RETURN_TYPE <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">CLASS_NAME</span>::* pVariable<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ARG0, ARG1, ..., ARGN-1<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Define a pointer to member function 'pVariable' set to null pointer. </span>
RETURN_TYPE <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">CLASS_NAME</span>::* pVariable<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ARG0, ARG1, ..., ARGN-1<span class="org-rainbow-delimiters-depth-1">)</span> = <span class="org-constant">nullptr</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Define a pointer to member function named 'pVariable' initialized with the </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">address of method (member function) member_functionA.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: The signature of member_functionA is: </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">RETURN_TYPE CLASS_NAME::member_functionA (ARG0, ARG1, ...)   </span>
RETURN_TYPE <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">CLASS_NAME</span>::* pVariable<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ARG0, ARG1, ..., ARGN-1<span class="org-rainbow-delimiters-depth-1">)</span> = &amp;<span class="org-constant">CLASS_NAME</span>::member_functionA;

<span class="org-comment-delimiter">// </span><span class="org-comment">Define a pointer to member function named 'pVariable' initialized with the </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">address of method (member function) memebr_funnctionA. </span>
RETURN_TYPE <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">CLASS_NAME</span>::* pVariable<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ARG0, ARG1, ..., ARGN-1<span class="org-rainbow-delimiters-depth-1">)</span> = &amp;<span class="org-constant">CLASS_NAME</span>::member_functionB;
</pre>
</div>

<ul class="org-ul">
<li>Example: Pointer to any member function taking zero arguments and
returning a string.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::string <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Dummy</span>::* pMemfn<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">()</span> = <span class="org-constant">nullptr</span>;
</pre>
</div>

<ul class="org-ul">
<li>Invoking a pointer to member function. It is necessary an instance
of the class in order to invoke the member function pointed by the
pointer.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">CLASS_TYPE</span> <span class="org-variable-name">obj</span>;
pVariable = &amp;<span class="org-constant">CLASS_TYPE</span>::member_function1;
<span class="org-rainbow-delimiters-depth-1">(</span>obj.*pVariable<span class="org-rainbow-delimiters-depth-1">)(</span>arg0, arg1, arg2, ... argn<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>


<ul class="org-ul">
<li>Type synonym with Typdef</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">typedef</span> <span class="org-type">RETURN_TYPE</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">CLASS_NAME</span>::* pMemberFunction<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ARG0, ARG1, ..., ARGN-1<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">pMemberFunction</span> <span class="org-variable-name">pvar</span> = &amp;<span class="org-constant">CLASS_NAME</span>::member_functionA;
<span class="org-type">CLASS_NAME</span> <span class="org-variable-name">obj</span>;
<span class="org-rainbow-delimiters-depth-1">(</span>obj.*pvar<span class="org-rainbow-delimiters-depth-1">)(</span>arg0, arg1, .... argn-1<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>Type synonym with C++11 "using" keyword</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">pMemberFunction</span> = RETURN_TYPE <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">CLASS_NAME</span>::*<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>ARG0, ARG1, ..., ARGN-1<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">pMemberFunction</span> <span class="org-variable-name">pvar</span> = &amp;<span class="org-constant">CLASS_NAME</span>::member_functionA;
<span class="org-type">CLASS_NAME</span> <span class="org-variable-name">obj</span>;
<span class="org-rainbow-delimiters-depth-1">(</span>obj.*pvar<span class="org-rainbow-delimiters-depth-1">)(</span>arg0, arg1, .... argn-1<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Further Reading:</b>
</p>

<ul class="org-ul">
<li><a href="https://accu.org/index.php/journals/495">ACCU - An Application of Pointers to Members</a></li>
<li><a href="http://soggywizards.com/tips/code/c++/member-pointers.html">Pointers to C++ Member Functions</a></li>
<li><a href="https://yosefk.com/c++fqa/function.html">C++ FQA Lite: Pointers to member functions</a></li>
<li><a href="https://arne-mertz.de/2017/01/decltype-declval/">Modern C++ Features - decltype and std::declval - Simplify C++!</a></li>
<li><a href="https://isocpp.org/wiki/faq/pointers-to-members">Pointers to Member Functions, C++ FAQ</a></li>
<li><a href="https://wiki.qt.io/New_Signal_Slot_Syntax">New Signal Slot Syntax - Qt Wiki</a></li>
<li><a href="https://www.codeguru.com/cpp/cpp/article.php/c17401/C-Tutorial-PointertoMember-Function.htm">C++ Tutorial: Pointer-to-Member Function</a></li>
<li><a href="https://embeddedartistry.com/blog/2017/1/26/c11-improving-your-callback-game">Improving Your Callback Game — Embedded Artistry</a></li>
</ul>


<p>
<b>Example</b>
</p>

<p>
File: 
</p>
<ul class="org-ul">
<li><a href="src/member-function-pointer.cpp">file:src/member-function-pointer.cpp</a></li>
<li>Online compiler: <a href="http://rextester.com/WYFC32509">http://rextester.com/WYFC32509</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iomanip</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">map</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cassert</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">Dummy</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">private</span>:
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">_name</span> = <span class="org-string">"unnamed"</span>;
<span class="org-function-name">public</span>:
        <span class="org-function-name">Dummy</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
        <span class="org-function-name">Dummy</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">_name</span><span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span>
        ~<span class="org-function-name">Dummy</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-string">"I am a dummy class named &lt;"</span> + _name + <span class="org-string">"&gt;"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getLocation</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-string">"Unknown location"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-keyword">return</span> <span class="org-string">"I am a function-object called: &lt;"</span> + _name + <span class="org-string">"&gt;"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">auto</span> <span class="org-function-name">compute</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-2">)</span> -&gt; <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> 4 * x + 5 * y;
        <span class="org-rainbow-delimiters-depth-2">}</span>   
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">DummyB</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-function-name">DummyB</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
        ~<span class="org-function-name">DummyB</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getName</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-string">"My name is DummyB"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">getLocation</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-string">"Location of dummyB location"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(){</span>
                <span class="org-keyword">return</span> <span class="org-string">"I am the class DummyB"</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Create type synonym to any member function of Dummy class</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">which takes no parameter and returns a string.</span>
<span class="org-keyword">typedef</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Dummy</span>::* pDummyMemFnStr<span class="org-rainbow-delimiters-depth-1">)()</span>;

<span class="org-type">void</span> <span class="org-function-name">invokeMemberFun</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Dummy</span>&amp; <span class="org-variable-name">obj</span>, <span class="org-type">pDummyMemFnStr</span> <span class="org-variable-name">pMemfn</span><span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [1] Method invocation returned value: "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span>obj.*pMemfn<span class="org-rainbow-delimiters-depth-2">)()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Create type synonum with the new "using" C++11 syntax</span>
<span class="org-keyword">using</span> <span class="org-type">pDummyMemFnStrCPP11</span> = <span class="org-constant">std</span>::string <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">Dummy</span>::*<span class="org-rainbow-delimiters-depth-1">)()</span>;

<span class="org-keyword">auto</span> <span class="org-function-name">invokeMemberFun2</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Dummy</span>&amp; <span class="org-variable-name">obj</span>, <span class="org-type">pDummyMemFnStrCPP11</span> <span class="org-variable-name">pMemfn</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [2] Method invocation returned value: "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span>obj.*pMemfn<span class="org-rainbow-delimiters-depth-2">)()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">invokeMemberFun3</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">T</span>&amp; <span class="org-variable-name">obj</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">T</span>::* <span class="org-function-name">pMemfn</span><span class="org-rainbow-delimiters-depth-2">)()</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">void</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [3] Method invocation returned value: "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span>obj.*pMemfn<span class="org-rainbow-delimiters-depth-2">)()</span> &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">T</span>, <span class="org-keyword">class</span> <span class="org-type">R</span>, <span class="org-keyword">class</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">invokeMemfn</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">R</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">T</span>::* <span class="org-function-name">pMemfn</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Args</span> ... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>, <span class="org-type">T</span>&amp; <span class="org-variable-name">obj</span>, <span class="org-type">Args</span> ... <span class="org-variable-name">arglist</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">(</span>obj.*pMemfn<span class="org-rainbow-delimiters-depth-2">)(</span>arglist ...<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
        <span class="org-keyword">const</span> <span class="org-keyword">auto</span> nl = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">const</span> <span class="org-keyword">auto</span> nl2 = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">line</span> = <span class="org-string">"--------------------------------------------------\n"</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"=== Experiment 1 ==============="</span> &lt;&lt; nl2;
        <span class="org-constant">std</span>::cout &lt;&lt; line;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Pointer to member function to any member functions</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">(aka method) which takes no argument and returns a string</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">of signature: () =&gt; std::string</span>
        <span class="org-comment-delimiter">//</span><span class="org-comment">.....................................................</span>
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">Dummy</span>::* <span class="org-variable-name">pMemfn</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-constant">nullptr</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">std::string (Dummy::* pMemfn) ();</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>pMemfn == <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [INFO] Pointer not initilialized yet."</span> &lt;&lt; nl;

        <span class="org-type">Dummy</span> <span class="org-variable-name">d</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"DUMMY"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Set the function pointer to member function getName().</span>
        pMemfn = &amp;<span class="org-constant">Dummy</span>::getName;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Invoke pointer to member function (aka pointer to method)</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Name     = "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span>d.*pMemfn<span class="org-rainbow-delimiters-depth-2">)()</span> &lt;&lt; nl2;
        assert<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>d.*pMemfn<span class="org-rainbow-delimiters-depth-3">)()</span> == <span class="org-string">"I am a dummy class named &lt;DUMMY&gt;"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>pMemfn != <span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [INFO] Pointer initilialized OK."</span> &lt;&lt; nl;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Set pointer to Dummy::getLocation</span>
        pMemfn = &amp;<span class="org-constant">Dummy</span>::getLocation;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Location = "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span>d.*pMemfn<span class="org-rainbow-delimiters-depth-2">)()</span> &lt;&lt; nl;
        <span class="org-comment-delimiter">// </span><span class="org-comment">assert((d.*pMemfn)() == "I am a dummy class named &lt;DUMMY&gt;"); </span>


        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"=== Experiment 2 - Using typedef ==============="</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; line;
        <span class="org-type">pDummyMemFnStr</span> <span class="org-variable-name">pMemfn2</span> = <span class="org-constant">nullptr</span>;
        pMemfn2 = &amp;<span class="org-constant">Dummy</span>::getName;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"d.getName() == "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span>d.*pMemfn2<span class="org-rainbow-delimiters-depth-2">)()</span> &lt;&lt; nl;
        assert<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>d.*pMemfn2<span class="org-rainbow-delimiters-depth-3">)()</span> == <span class="org-string">"I am a dummy class named &lt;DUMMY&gt;"</span><span class="org-rainbow-delimiters-depth-2">)</span>;   

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"=== Experiment 3 - Invoking member function with free function ="</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; line;
        <span class="org-comment-delimiter">// </span><span class="org-comment">execute d.getName() </span>
        invokeMemberFun<span class="org-rainbow-delimiters-depth-2">(</span>d, &amp;<span class="org-constant">Dummy</span>::getName<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">execute d.getLocation() </span>
        invokeMemberFun<span class="org-rainbow-delimiters-depth-2">(</span>d, &amp;<span class="org-constant">Dummy</span>::getLocation<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">execute d() </span>
        invokeMemberFun<span class="org-rainbow-delimiters-depth-2">(</span>d, &amp;<span class="org-constant">Dummy</span>::<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"=== Experiment 4 - Invoking member function with free function C++11"</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; line;
        invokeMemberFun2<span class="org-rainbow-delimiters-depth-2">(</span>d, &amp;<span class="org-constant">Dummy</span>::getName<span class="org-rainbow-delimiters-depth-2">)</span>;
        invokeMemberFun2<span class="org-rainbow-delimiters-depth-2">(</span>d, &amp;<span class="org-constant">Dummy</span>::getLocation<span class="org-rainbow-delimiters-depth-2">)</span>;
        invokeMemberFun2<span class="org-rainbow-delimiters-depth-2">(</span>d, &amp;<span class="org-constant">Dummy</span>::<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"=== Experiment 5 - Pointer to member functions in STL deque collection"</span> &lt;&lt; nl;
        <span class="org-keyword">auto</span> <span class="org-variable-name">plist</span> = <span class="org-constant">std</span>::deque<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">pDummyMemFnStrCPP11</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
        plist.push_back<span class="org-rainbow-delimiters-depth-2">(</span>&amp;<span class="org-constant">Dummy</span>::getName<span class="org-rainbow-delimiters-depth-2">)</span>;
        plist.push_back<span class="org-rainbow-delimiters-depth-2">(</span>&amp;<span class="org-constant">Dummy</span>::getLocation<span class="org-rainbow-delimiters-depth-2">)</span>;
        plist.push_back<span class="org-rainbow-delimiters-depth-2">(</span>&amp;<span class="org-constant">Dummy</span>::<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">p</span>: plist<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" (+) Calll returned = "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span>d.*p<span class="org-rainbow-delimiters-depth-2">)()</span> &lt;&lt; nl;

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"=== Experiment 6 - Pointer to member functions in map collection"</span> &lt;&lt; nl;
        <span class="org-keyword">auto</span> <span class="org-variable-name">dict</span> = <span class="org-constant">std</span>::map<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>, <span class="org-type">pDummyMemFnStrCPP11</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
        dict<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"getName"</span><span class="org-rainbow-delimiters-depth-2">]</span>     = &amp;<span class="org-constant">Dummy</span>::getName;
        dict<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"getLocation"</span><span class="org-rainbow-delimiters-depth-2">]</span> = &amp;<span class="org-constant">Dummy</span>::getLocation;
        dict<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"callme"</span><span class="org-rainbow-delimiters-depth-2">]</span>      = &amp;<span class="org-constant">Dummy</span>::<span class="org-keyword">operator</span><span class="org-rainbow-delimiters-depth-2">()</span>;
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">kv</span>: dict<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::right &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>20<span class="org-rainbow-delimiters-depth-2">)</span>  &lt;&lt; <span class="org-string">"invoke(object, "</span>
                          &lt;&lt; <span class="org-constant">std</span>::setw<span class="org-rainbow-delimiters-depth-2">(</span>15<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; kv.first &lt;&lt; <span class="org-string">")"</span>
                          &lt;&lt; <span class="org-string">" = "</span> &lt;&lt; <span class="org-rainbow-delimiters-depth-2">(</span>d.*<span class="org-rainbow-delimiters-depth-3">(</span>kv.second<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)()</span> &lt;&lt; nl;

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"=== Experiment 7 - Template "</span> &lt;&lt; nl;
        <span class="org-type">DummyB</span> <span class="org-variable-name">b</span>;
        invokeMemberFun3<span class="org-rainbow-delimiters-depth-2">(</span>d, &amp;<span class="org-constant">Dummy</span>::getName<span class="org-rainbow-delimiters-depth-2">)</span>;
        invokeMemberFun3<span class="org-rainbow-delimiters-depth-2">(</span>b, &amp;<span class="org-constant">DummyB</span>::getName<span class="org-rainbow-delimiters-depth-2">)</span>;
        invokeMemberFun3<span class="org-rainbow-delimiters-depth-2">(</span>d, &amp;<span class="org-constant">Dummy</span>::getLocation<span class="org-rainbow-delimiters-depth-2">)</span>;
        invokeMemberFun3<span class="org-rainbow-delimiters-depth-2">(</span>b, &amp;<span class="org-constant">DummyB</span>::getLocation<span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; nl &lt;&lt; <span class="org-string">"=== Experiment 8 - Template "</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; line;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"d.getName()         = "</span> &lt;&lt; invokeMemfn<span class="org-rainbow-delimiters-depth-2">(</span>&amp;<span class="org-constant">Dummy</span>::getName, d<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; nl;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"d.compute(3.0, 4.0) = "</span> &lt;&lt; invokeMemfn<span class="org-rainbow-delimiters-depth-2">(</span>&amp;<span class="org-constant">Dummy</span>::compute, d, 3.0, 4.0<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; nl;

        <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ member-function-pointer.cpp -o <span class="org-keyword">member-function-pointer.bin</span> -std=c++1z -Wall -Wextra  
$ ./member-function-pointer.bin

=== Experiment 1 ===============

--------------------------------------------------
 [INFO] Pointer not initilialized yet.
Name     = I am a dummy class named &lt;DUMMY&gt;

 [INFO] Pointer initilialized OK.
Location = Unknown location

=== Experiment 2 - Using typedef ===============
--------------------------------------------------
<span class="org-function-name">d.getName</span>() == I am a dummy class named &lt;DUMMY&gt;

=== Experiment 3 - Invoking member <span class="org-keyword">function</span> <span class="org-function-name">with</span> free <span class="org-keyword">function</span> =
--------------------------------------------------
 [1] Method invocation returned value: I am a dummy class named &lt;DUMMY&gt;
 [1] Method invocation returned value: Unknown location
 [1] Method invocation returned value: I am a function-object called: &lt;DUMMY&gt;

=== Experiment 4 - Invoking member <span class="org-keyword">function</span> <span class="org-function-name">with</span> free <span class="org-keyword">function</span> <span class="org-function-name">C</span>++11
--------------------------------------------------
 [2] Method invocation returned value: I am a dummy class named &lt;DUMMY&gt;
 [2] Method invocation returned value: Unknown location
 [2] Method invocation returned value: I am a function-object called: &lt;DUMMY&gt;

=== Experiment 5 - Pointer to member functions<span class="org-keyword"> in</span> STL deque collection
 (+) Calll returned = I am a dummy class named &lt;DUMMY&gt;
 (+) Calll returned = Unknown location
 (+) Calll returned = I am a function-object called: &lt;DUMMY&gt;

=== Experiment 6 - Pointer to member functions<span class="org-keyword"> in</span> map collection
     invoke(object,          callme) = I am a function-object called: &lt;DUMMY&gt;
     invoke(object,     getLocation) = Unknown location
     invoke(object,         getName) = I am a dummy class named &lt;DUMMY&gt;

=== Experiment 7 - Template 
 [3] Method invocation returned value: I am a dummy class named &lt;DUMMY&gt;
 [3] Method invocation returned value: My name is DummyB
 [3] Method invocation returned value: Unknown location
 [3] Method invocation returned value: Location of dummyB location

=== Experiment 8 - Template 
--------------------------------------------------
<span class="org-function-name">d.getName</span>()         = I am a dummy class named &lt;DUMMY&gt;
<span class="org-function-name">d.compute</span>(3.0, 4.0) = 32

</pre>
</div>
</div>
</div>
<div id="outline-container-orgbb261b1" class="outline-3">
<h3 id="orgbb261b1"><span class="section-number-3">1.34</span> Pointer to Class Member Variable</h3>
<div class="outline-text-3" id="text-1-34">
</div>
<div id="outline-container-orgada1dc0" class="outline-4">
<h4 id="orgada1dc0"><span class="section-number-4">1.34.1</span> Summary</h4>
<div class="outline-text-4" id="text-1-34-1">
<p>
Pointers to members variables provides an way to access class member
data indirectly. 
</p>

<p>
Among other things, it has the following use cases:
</p>

<ul class="org-ul">
<li>Create setters/getters</li>
<li>Serialization</li>
<li>Reflection</li>
<li>Indirect Access</li>
<li>Security research.</li>
<li>Get the member data pointer offset in bytes.</li>
</ul>

<p>
<b>Syntax for pointer to member data</b>
</p>

<ul class="org-ul">
<li>Declare a pointer to member of a certain class of an specific
type.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">MEMBER_TYPE</span>  <span class="org-constant">CLASS_NAME</span>::* <span class="org-variable-name">PointerVariableName</span>;
</pre>
</div>

<ul class="org-ul">
<li>Declare a pointer to member intialized to null.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">MEMBER_TYPE</span>  <span class="org-constant">CLASS_NAME</span>::* <span class="org-variable-name">PointerVariableName</span> = nulltpr;
</pre>
</div>

<ul class="org-ul">
<li>Declare a pointer to member intialized to the address of some
member variable.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">MEMBER_TYPE</span>  <span class="org-constant">CLASS_NAME</span>::* <span class="org-variable-name">PointerVariableName</span> = &amp;<span class="org-constant">CLASS_NAME</span>::memberVariable;
</pre>
</div>

<p>
<b>Syntax for type alias/synonym of pointer to member data</b>
</p>

<ul class="org-ul">
<li><b>Before C++11</b> - type alias with the typedef keyword.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">typedef</span> <span class="org-type">MEMBER_TYPE</span> <span class="org-constant">CLASS_NAME</span>::* <span class="org-type">TypeAliasName</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">Instance declaration: </span>
<span class="org-type">TypeAliasName</span> <span class="org-variable-name">pointerToMember</span>;
<span class="org-type">TypeAliasName</span> <span class="org-variable-name">pointerToMember</span> = <span class="org-constant">nullptr</span>;
<span class="org-type">TypeAliasName</span> <span class="org-variable-name">pointerToMember</span> = &amp;<span class="org-constant">CLASS_NAME</span>::MemeberVariable;
</pre>
</div>

<ul class="org-ul">
<li><b>C++11</b> - type alias with 'using' keyword</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">TypeAliasName</span> = MEMBER_TYPE <span class="org-constant">CLASS_NAME</span>::*;
<span class="org-comment-delimiter">// </span><span class="org-comment">Instance declaration: </span>
<span class="org-type">TypeAliasName</span> <span class="org-variable-name">pointerToMember</span>;
<span class="org-type">TypeAliasName</span> <span class="org-variable-name">pointerToMember</span> = <span class="org-constant">nullptr</span>;
<span class="org-type">TypeAliasName</span> <span class="org-variable-name">pointerToMember</span> = &amp;<span class="org-constant">CLASS_NAME</span>::MemeberVariable;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf75621b" class="outline-4">
<h4 id="orgf75621b"><span class="section-number-4">1.34.2</span> Example</h4>
<div class="outline-text-4" id="text-1-34-2">
<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">It could also be: struct Dummy{ ... }</span>
<span class="org-keyword">class</span> <span class="org-type">Dummy</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-type">double</span>      <span class="org-variable-name">x</span>;
        <span class="org-type">double</span>      <span class="org-variable-name">y</span>;
        <span class="org-type">int</span>         <span class="org-variable-name">points</span>;
        <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">name</span>;
        <span class="org-type">double</span>      <span class="org-variable-name">z</span>;
        <span class="org-type">char</span>        <span class="org-variable-name">ch</span>;
        <span class="org-function-name">Dummy</span><span class="org-rainbow-delimiters-depth-2">(){}</span>
        <span class="org-function-name">Dummy</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span>, <span class="org-type">double</span> <span class="org-variable-name">y</span>, <span class="org-type">int</span> <span class="org-variable-name">points</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span><span class="org-rainbow-delimiters-depth-2">)</span>:
                x<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>, y<span class="org-rainbow-delimiters-depth-2">(</span>y<span class="org-rainbow-delimiters-depth-2">)</span>, points<span class="org-rainbow-delimiters-depth-2">(</span>points<span class="org-rainbow-delimiters-depth-2">)</span>, name<span class="org-rainbow-delimiters-depth-2">(</span>name<span class="org-rainbow-delimiters-depth-2">){}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Creating a test object: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt;  <span class="org-keyword">auto</span> obj = Dummy<span class="org-rainbow-delimiters-depth-1">(</span>20.2, 9.0, 10, <span class="org-string">"dummy"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
&gt;&gt; obj.x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 20.200000
&gt;&gt; obj.y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 9.0000000
&gt;&gt; obj.points
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">)</span> 10
&gt;&gt; obj.name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"dummy"</span>
&gt;&gt; obj.z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000
&gt;&gt; obj.ch
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-warning">'</span>0x00<span class="org-warning">'</span>

&gt;&gt; <span class="org-keyword">auto</span> obj2 = Dummy<span class="org-rainbow-delimiters-depth-1">(</span>100.0, -10.0, 70, <span class="org-string">"objectx"</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Dummy</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> @0x7fda2fd33060
&gt;&gt; 
</pre>
</div>

<p>
Create an initialized to null pointer to double member data: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-type">double</span> <span class="org-constant">Dummy</span>::* p_to_member_double = <span class="org-constant">nullptr</span>;
&gt;&gt; 
&gt;&gt; p_to_member_double
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-constant">Dummy</span>::*<span class="org-rainbow-delimiters-depth-1">)</span> @0x43cbed0
</pre>
</div>

<p>
Set pointer <code>p_to_member_double</code> to field x.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; p_to_member_double = &amp;<span class="org-constant">Dummy</span>::x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> <span class="org-constant">Dummy</span>::*<span class="org-rainbow-delimiters-depth-1">)</span> @0x46bc260
&gt;&gt; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Acess field x of obj </span>
&gt;&gt; obj.* p_to_member_double
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 20.200000
&gt;&gt; 
&gt;&gt; obj.* p_to_member_double = -90.2
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -90.200000
&gt;&gt; obj.* p_to_member_double 
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -90.200000
&gt;&gt; obj.x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -90.200000
&gt;&gt;  

&gt;&gt; obj2.* p_to_member_double
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.00000
&gt;&gt; 

&gt;&gt; obj2.* p_to_member_double = 200.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 200.00000
&gt;&gt; obj2.x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 200.00000
&gt;&gt; 
</pre>
</div>

<p>
Set pointer <code>p_to_member_double</code> to field y.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; p_to_member_double = &amp;<span class="org-constant">Dummy</span>::y;

&gt;&gt; obj.y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 9.0000000
&gt;&gt; 
&gt;&gt; obj.* p_to_member_double
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 9.0000000
&gt;&gt; obj.* p_to_member_double = -190.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -190.00000
&gt;&gt; obj.* p_to_member_double
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -190.00000
&gt;&gt; obj.y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -190.00000
&gt;&gt; 
&gt;&gt;

&gt;&gt; obj2.y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -10.000000
&gt;&gt; obj2.* p_to_member_double
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -10.000000
&gt;&gt; 
&gt;&gt; obj2.* p_to_member_double = -900.223
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -900.22300
&gt;&gt; obj2.* p_to_member_double
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -900.22300
</pre>
</div>

<p>
Create a type alias to pointer to member of type double.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">C++11 =&gt; Better!!</span>
<span class="org-keyword">using</span> <span class="org-type">PointerToMemberDouble</span> = <span class="org-type">double</span> <span class="org-constant">Dummy</span>::*;
<span class="org-comment-delimiter">// </span><span class="org-comment">Old C++ standards =&gt; Cryptic  </span>
<span class="org-keyword">typedef</span> <span class="org-type">double</span> <span class="org-constant">Dummy</span>::* <span class="org-type">PointerToMemberDoubleTypedef</span> ; 

<span class="org-type">PointerToMemberDouble</span> <span class="org-variable-name">ptrdouble</span> = &amp;<span class="org-constant">Dummy</span>::z;

&gt;&gt; obj.* ptrdouble 
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000

&gt;&gt; obj.z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000

&gt;&gt; obj.* ptrdouble 
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000

&gt;&gt; obj.* ptrdouble = 100.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.00000

&gt;&gt; obj.* ptrdouble 
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.00000

&gt;&gt; obj.z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.00000


&gt;&gt; obj2.z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000

&gt;&gt; obj2.z = 600.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 600.00000

&gt;&gt; obj2.* ptrdouble 
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 600.00000

&gt;&gt; obj2.* ptrdouble = -100.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -100.00000

&gt;&gt; obj2.* ptrdouble 
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -100.00000

&gt;&gt; obj2.z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -100.00000
&gt;&gt; 
&gt;&gt; 

</pre>
</div>

<p>
Use pointer to member with object pointer. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> pobj1 = &amp;obj
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Dummy</span> *<span class="org-rainbow-delimiters-depth-1">)</span> @0x7ffd126ee978

&gt;&gt; pobj1-&gt;y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -190.00000
&gt;&gt; 

&gt;&gt; PointerToMemberDouble ptom_double = &amp;<span class="org-constant">Dummy</span>::y;
&gt;&gt; 
&gt;&gt; pobj1-&gt;* ptom_double
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -190.00000
&gt;&gt; 
&gt;&gt; pobj1-&gt;* ptom_double = -300.0;
&gt;&gt; 
&gt;&gt; pobj1-&gt;y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -300.00000
&gt;&gt; 
</pre>
</div>

<p>
Get member offset: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Class</span>, <span class="org-keyword">class</span> <span class="org-type">Field</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">size_t</span> <span class="org-function-name">getOffset</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Field</span> <span class="org-constant">Class</span>::*<span class="org-variable-name">fieldp</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> 
        <span class="org-keyword">return</span> size_t<span class="org-rainbow-delimiters-depth-2">(</span>&amp;<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Class</span>*<span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-constant">nullptr</span><span class="org-rainbow-delimiters-depth-4">)</span>-&gt;*fieldp<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

&gt;&gt; <span class="org-keyword">auto</span> offset_x = getOffset<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">Dummy</span>::x<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 0

&gt;&gt; <span class="org-keyword">auto</span> offset_y = getOffset<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">Dummy</span>::y<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 8

&gt;&gt; <span class="org-keyword">auto</span> offset_z = getOffset<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">Dummy</span>::z<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 56
&gt;&gt; 
&gt;&gt; <span class="org-keyword">auto</span> offset_name = getOffset<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">Dummy</span>::name<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 24
&gt;&gt; <span class="org-keyword">auto</span> offset_points = getOffset<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">Dummy</span>::points<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 16
</pre>
</div>

<p>
Access class member x using x offset.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> p = &amp;obj
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Dummy</span> *<span class="org-rainbow-delimiters-depth-1">)</span> @0x7ffd126ee978

&gt;&gt; <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">)</span> p<span class="org-rainbow-delimiters-depth-2">)</span> + offset_x<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span> *<span class="org-rainbow-delimiters-depth-1">)</span> 0x7fda2fd33010

&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">)</span> p<span class="org-rainbow-delimiters-depth-2">)</span> + offset_x<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -90.200000

&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">)</span> p<span class="org-rainbow-delimiters-depth-2">)</span> + offset_x<span class="org-rainbow-delimiters-depth-1">)</span> = -100.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -100.00000

&gt;&gt; p-&gt;x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -100.00000
&gt;&gt; 
&gt;&gt; 
&gt;&gt; <span class="org-type">double</span>&amp; xref1 = *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">)</span> p<span class="org-rainbow-delimiters-depth-2">)</span> + offset_x<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -100.00000
&gt;&gt; xref1 = 900.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 900.00000
&gt;&gt; p-&gt;x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 900.00000
&gt;&gt; 


</pre>
</div>

<p>
Access class member z using z offset.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; p-&gt;z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.00000
&gt;&gt; 

&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">)</span> p<span class="org-rainbow-delimiters-depth-2">)</span> + offset_z<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 100.00000
&gt;&gt; 

&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">)</span> p<span class="org-rainbow-delimiters-depth-2">)</span> + offset_z<span class="org-rainbow-delimiters-depth-1">)</span> = -200.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -200.00000

&gt;&gt; p-&gt;z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -200.00000
&gt;&gt; 

&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">)</span> &amp;obj2<span class="org-rainbow-delimiters-depth-2">)</span> + offset_z<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -100.00000

&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">)</span> &amp;obj2<span class="org-rainbow-delimiters-depth-2">)</span> + offset_z<span class="org-rainbow-delimiters-depth-1">)</span> = 300.0
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 300.00000

&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">)</span> &amp;obj2<span class="org-rainbow-delimiters-depth-2">)</span> + offset_z<span class="org-rainbow-delimiters-depth-1">)</span> = 300.0;

&gt;&gt; obj2.z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 300.00000
&gt;&gt; 
</pre>
</div>

<p>
Access field 'name' using its offset.
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; obj.name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"dummy"</span>
&gt;&gt; 
&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">)</span> &amp;obj<span class="org-rainbow-delimiters-depth-2">)</span> + offset_name<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"dummy"</span>

&gt;&gt; *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span>*<span class="org-rainbow-delimiters-depth-1">&gt;(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-3">)</span> &amp;obj<span class="org-rainbow-delimiters-depth-2">)</span> + offset_name<span class="org-rainbow-delimiters-depth-1">)</span> = <span class="org-string">"binary"</span>;
&gt;&gt; obj.name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"binary"</span>
&gt;&gt; 

&gt;&gt; obj.name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"P0WN3D"</span>
</pre>
</div>

<p>
Generic solution for dealing with offsets: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">FIELD</span>, <span class="org-keyword">typename</span> <span class="org-type">CLASS</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">FIELD</span>* <span class="org-function-name">getFieldPointer</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">CLASS</span>&amp; <span class="org-variable-name">obj</span>, <span class="org-type">size_t</span> <span class="org-variable-name">offset</span> <span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">FIELD</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-4">)</span> &amp;obj<span class="org-rainbow-delimiters-depth-3">)</span> + offset<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">FIELD</span>, <span class="org-keyword">typename</span> <span class="org-type">CLASS</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">FIELD</span> <span class="org-function-name">getFieldValue</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">CLASS</span>&amp; <span class="org-variable-name">obj</span>, <span class="org-type">size_t</span> <span class="org-variable-name">offset</span> <span class="org-rainbow-delimiters-depth-1">){</span>
        <span class="org-keyword">return</span> *<span class="org-keyword">reinterpret_cast</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">FIELD</span>*<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">size_t</span><span class="org-rainbow-delimiters-depth-4">)</span> &amp;obj<span class="org-rainbow-delimiters-depth-3">)</span> + offset<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Get object's members values by their offset: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">&gt;&gt; <span class="org-keyword">auto</span> obj3 = Dummy<span class="org-rainbow-delimiters-depth-1">(</span>120.2, -89.0, 143, <span class="org-string">"blob"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
&gt;&gt; obj3.x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 120.20000
&gt;&gt; obj3.y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -89.000000
&gt;&gt; obj3.z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000
&gt;&gt; obj3.z = 45.0;
&gt;&gt; obj3.name;
&gt;&gt; 

&gt;&gt; 
&gt;&gt; getOffset<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">Dummy</span>::x<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 0
&gt;&gt; getOffset<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">Dummy</span>::y<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 8
&gt;&gt; getOffset<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">Dummy</span>::z<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 56
&gt;&gt; getOffset<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">Dummy</span>::name<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 24
&gt;&gt; getOffset<span class="org-rainbow-delimiters-depth-1">(</span>&amp;<span class="org-constant">Dummy</span>::points<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">unsigned</span> <span class="org-type">long</span><span class="org-rainbow-delimiters-depth-1">)</span> 16
&gt;&gt; 

&gt;&gt; obj3.x
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 120.20000

&gt;&gt; getFieldValue<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>obj3, 0<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 120.20000
&gt;&gt; 

&gt;&gt; obj3.y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -89.000000

&gt;&gt; getFieldValue<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>obj3, 8<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> -89.000000
&gt;&gt; 

&gt;&gt; obj3.z
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 0.0000000
&gt;&gt; obj3.z = 45.0;

&gt;&gt; getFieldValue<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>obj3, 56<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">)</span> 45.000000
&gt;&gt; 

&gt;&gt; obj3.name
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> &amp;<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-string">"blob"</span>
&gt;&gt; 
&gt;&gt; getFieldValue<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">string</span><span class="org-rainbow-delimiters-depth-1">&gt;(</span>obj3, 24<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-string">"blob"</span>
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-12-23 Mon 19:16</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
