#+INCLUDE: theme/style.org
#+TITLE: CPP / C++ Review
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

- [[wiki:index][Index]]

* Standard Library Reference Card 
** STL Components 

 + *Containers* - standard collections or data structures, they are a
   fundamental building block of most programming languages, in C++
   the addition benefit is that most of them abstracts away the memory
   allocation as they can grow or shrink during the program runtime.
   * Sequential
     + *vector*
     + *deque*
     + array
     + list
     + forward list 
     + valarray [DEPRECATED] - It would provide a Fortran-like fixed
       size array for linear algebra. But the STL implementation is incomplete.
   * Associative
     + Ordered Associative Container 
       + *map* - key-value data structure, also known as dictionary. A
         map always have unique keys. 
         hash-map, hash table and so on.
       + *set* - A set is data structure which cannot have any repeated
         values. 
       + multimap - A multimap can have repeated keys. 
       + multiset
     + Unordered Associative Containers
       + ~unordered_map~
       + ~unordered_set~
 + *Iterators*
 + *Algorithms*
 + *Adapters*
   - Queue
   - Stack  
 + *Functors* - Function-objects or objects that can be called like a
   function. Functors have several use cases in the STL, for instance
   many STL containers and algorithms expects functors as arguments or
   optional arguments and also the STL provides many standard
   functors in the header <functional>. 
   + Standard functors:
     + plus<T>
     + minus<T>
     + multiplies<T>
     + divides<T>
     + modules<T>
     + equal_to<T>
     + not_equal_to<T>
     + greater<T>
     + greater_equal<T>
     + less<T>
     + less_equal<T>
 + *Allocators*

Further references: 
 + [[https://en.cppreference.com/w/cpp/header/functional][Standard library header <functional> - cppreference.com]]
 + [[http://cs.stmarys.ca/~porter/csc/ref/stl/function_objects.html][STL Function Objects (Functors)]]

** Bookmarks 

 + [[https://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/lectures/containers.html][Helsinki - university - STL Containers]]

 + [[https://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/lectures/algorithms.html][Helsinki University - STL Algorithms]]

** STL Sequential Container Methods - Cheat Sheet  
*** Use Cases 

Use Cases: 
 + _vector_
   + Operations where the vector size is known in advance and it is
     necessary constant access time for random access to any
     element. Example of use case: linear algebra and numerical
     algorithms. Insertion of elements at end or at the front is
     efficient, however it less efficient than the deque container and
     whenever a new element is added. Vectors are not ideal for
     operations where the number of elements is not known because its
     elements are stored in C-array allocated in the heap, as result,
     all elements are reallocated whenever a new element is added or
     removed.
   + Use cases:
     + General sequential container
     + Linear algebra and numerical algorithms 
     + C++ replacement for C-arrays 
     + C-arrays interoperability
 + _deque_
   + Operations with requires fast random access time and fast
     insertion or deletion of elements at both ends. Unlike vectors,
     deque is not stored internally as a C-array and unlike vectors,
     whenever an element is inserted, any reallocation happens which
     means that deques are more efficient than vectors when the size
     of container is not known in advance.
   + Use Case:
     + General sequential container
     + Fast random access
     + Number of elements aren't known in advance.
*** Member Functions / Methods reference table 

| Method of Container<T> | Return type | Description                                              | vector | deque | list | array |
|------------------------+-------------+----------------------------------------------------------+--------+-------+------+-------|
| *Element Access*         |             |                                                          |        |       |      |       |
| operator[](int n)      | T&          | return nth-element, doesn't throw exception.             | yes    | yes   | no   | yes   |
| at(int n)              | T&          | return nth-element, but throws exception.                | yes    | yes   | no   | yes   |
| front()                | T&          | return first element                                     | yes    | yes   | yes  | yes   |
| back()                 | T&          | return last element                                      | yes    | yes   | yes  | yes   |
| data()                 | T*          | Return pointer to first element of container.            | yes    | no    | no   | yes   |
|                        |             |                                                          |        |       |      |       |
| *Capacity*               |             |                                                          |        |       |      |       |
| size()                 | size_t      | Return number of container elements.                     | yes    | yes   | yes  | yes   |
| max_size()             | size_t      | Return maximum container size.                           | yes    | yes   | yes  | yes   |
| empty()                | bool        | Return true if container is empty                        | yes    | yes   | yes  | yes   |
| reserve(size_t n)      | void        | Reserve a minimum storage for vectors.                   | yes    | no    | no   | no    |
| resize(size_t n)       | void        | Resize container to n elements.                          | yes    | yes   | yes  | no    |
|                        |             |                                                          |        |       |      |       |
| *Modifiers*              |             |                                                          |        |       |      |       |
| ~push_back(T t)~         | void        | Add element at the end of container                      | yes    | yes   | yes  | no    |
| ~push_front(T t)~        | void        | Add element at the beggining of container.               | yes    | yes   | yes  | no    |
| ~pop_back()~             | void        | Delete element at the end of container.                  | yes    | yes   | yes  | no    |
| ~pop_front()~            | void        | Delete element at beginning of container.                | yes    | yes   | yes  | no    |
| emplace_back           | void        | Construct and insert element at the end without copying. | yes    | yes   | yes  | no    |
| clear()                | void        | Remove all elements.                                     | yes    | yes   | yes  | no    |
| fill(T t)              | void        | Fill all elements                                        | no     | no    | no   | yes   |
|                        |             |                                                          |        |       |      |       |
| *Iterator*               |             |                                                          |        |       |      |       |
| begin()                | iterator    | Return iterator to beggining                             |        |       |      |       |
| end()                  | iterator    | Return iterator to end                                   |        |       |      |       |
| rbegin()               | iterator    | Return reverse iterator to beggining                     |        |       |      |       |
| rend()                 | iterator    | Return reverse iterator to end                           |        |       |      |       |
| cbegin()               | iterator    | Return const iterator to beginning                       |        |       |      |       |
| cend()                 | iterator    | Return const iterator to end                             |        |       |      |       |
| crebegin()             | iterator    | Return const iterator to beginning                       |        |       |      |       |
| crend()                | iterator    | Return const iterator to end                             |        |       |      |       |
    
*** Constructors 

Vector constructors: 

#+BEGIN_SRC cpp 
  // Empty vector 
  >> std::vector<double> xs1
  (std::vector<double> &) {}

  // Intialize vector with a given size
  >> std::vector<double> xs2(5, 3.0)
  (std::vector<double> &) { 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000 }

  // Constructor with uniform initialization 
  >> std::vector<double> xs4 {1.0, -2.0, 1.0, 10 }
  (std::vector<double> &) { 1.0000000, -2.0000000, 1.0000000, 10.000000 }

  // =========== Constructors with C++11 auto keyword =============//

  >> auto xs1 = vector<double>()
  (std::vector<double, std::allocator<double> > &) {}
  >> 
  >> auto xs2 = vector<double>(5, 3.0)
  (std::vector<double, std::allocator<double> > &) { 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000 }
  >> 
  >> auto xs3 = vector<double>{1, -2, 1, 1}
  (std::vector<double, std::allocator<double> > &) { 1.0000000, -2.0000000, 1.0000000, 1.0000000 }
  >> 
#+END_SRC

Deque constructors: 

#+BEGIN_SRC cpp 
  >> std::deque<int> ds1
  (std::deque<int> &) {}
  >> 
  >> std::deque<int> ds2(5, 2)
  (std::deque<int> &) { 2, 2, 2, 2, 2 }
  >> 
  >> std::deque<int> ds3 {2, -10, 20, 100, 20}
  (std::deque<int> &) { 2, -10, 20, 100, 20 }
  >> 
  // ======== Constructors with auto type inference ========== //
  >> auto ds1 = std::deque<int>()
  (std::deque<int, std::allocator<int> > &) {}
  >> 
  >> auto ds2 = std::deque<int>(5, 2)
  (std::deque<int, std::allocator<int> > &) { 2, 2, 2, 2, 2 }
  >> 
  >> auto ds3 = std::deque<int>{2, -10, 20, 100, 20}
  (std::deque<int, std::allocator<int> > &) { 2, -10, 20, 100, 20 }
  >> 
#+END_SRC

References: 
 + [[http://www.cplusplus.com/reference/vector/vector/][vector - C++ Reference]]  
 + [[http://www.cplusplus.com/reference/stl/][Containers - C++ Reference]] 
 + [[https://embeddedartistry.com/blog/2017/9/11/choosing-the-right-stl-container-sequential-containers][Choosing the Right Container: Sequential Containers — Embedded Artistry]]
 + [[http://cs.stmarys.ca/~porter/csc/ref/stl/containers_sequential.html][STL Sequential Container Member Function Summary]] 
	 
*** Tips and tricks 
**** Pass containers by reference or const reference

If the intent of the operation is not modify the container, it is
preferrable to pass it by const reference in order to avoid copying
overhead. 

For instance, the function: 

#+BEGIN_SRC cpp 
  double computeNorm(std::vector<double> xs)
  {
   // The vector xs is copied here, if it has 1GB of memory.
   // It will use 2GB instead of 1GB!
    ... ... 
  }
#+END_SRC

Should be written as: 

#+BEGIN_SRC cpp 
  double computeNorm(const std::vector<double>& xs)
  {
    ... ... 
  }
  double computeNorm(const std::list<double>& xs)
  {
    ... ... 
  }
  double computeNorm(const std::deque<double>& xs)
  {
    ... ... 
  }
#+END_SRC
**** Use the member function emplace_back to avoid uncessary copies.

Example: 

 - file: stl-emplace.cpp

#+BEGIN_SRC cpp :export both :results code
  #include <iostream>
  #include <ostream>
  #include <iomanip>
  #include <string>
  #include <vector>
  #include <deque>

  struct Product{
          std::string  name;	
          int          quantity;
          double       price;
          Product(){
                  std::cerr << " [TRACE] - Empty constructor invoked\n";
          }
          Product(const std::string& name, int quantity, double price):
                  name(name),
                  quantity(quantity),
                  price(price){
                  std::cerr << " [TRACE] - Product created as " << *this << "\n" ;
          }
          // The compiler generate an copy constructor automatically,
          // but this one was written to instrument C++ value semantics
          // and check when copies happen.
          Product(const Product& p){
                  this->name		= p.name;
                  this->quantity	= p.quantity;
                  this->price		= p.price;
                  std::cerr << " [TRACE] Copy constructor invoked -> copied = " << *this << "\n";
          }
          // Copy assignment-operator
          void operator=(const Product& p){
                  this->name		= p.name;
                  this->quantity	= p.quantity;
                  this->price		= p.price;
                  std::cerr << " [TRACE] Copy assignment operator invoked = " << *this << "\n";		
          }
          // Make class printable 
          friend std::ostream& operator<< (std::ostream& os, const Product& p)
          {
                  int size1 = 10;
                  int size2 = 2;
                  return os << " Product{ "
                                    << std::setw(1) << " name = "       << p.name
                                    << std::setw(10) << "; quantity  = "  << std::setw(size2) << p.quantity
                                    << std::setw(size1) << "; price = "      << std::setw(size2) << p.price
                                    << " }";
          }
  };


  int main(){
          auto inventory = std::deque<Product>();

          // Using push_back
          std::cerr << "====== Experiment .push_back() ======\n";
          std::cerr << " [INFO] - Adding orange with .push_back\n";
          inventory.push_back(Product("Orange - 1kg", 10, 3.50));
          std::cerr << " [INFO] - Adding rice with .push_back \n";
          inventory.push_back({"Rice bag", 20, 0.80});

          // Using emlace_back
          std::cerr << "====== Experiment .emplace_back() ======\n";	
          std::cerr << " [INFO] - Adding baccon with .emplace_back \n";
          inventory.emplace_back("Fresh tasty bacon", 50, 30.25);
          std::cerr << " [INFO] - Adding soft drink with .emplace_back \n";
          inventory.emplace_back("Soft drink", 100, 2.50);

          std::cerr << " ====== Inventory =======\n";
          // Print inventory
          int nth = 0;
          for(const auto& p: inventory){
                  std::cout << "product " << nth << " = " << p << "\n";
                  nth++;
          }	
          return 0;
  }

#+END_SRC

Running:

 - It can be seen in the program output that ~.emplace_back~ doen't
   invoke the copy constructor, so it has less overhead than
   ~.emplace_back~ which copies the passed element.

#+BEGIN_SRC txt
  $ clang++ stl-emplace.cpp -o stl-emplace.bin -g -std=c++11 -Wall -Wextra && ./stl-emplace.bin

  ====== Experiment .push_back() ======
   [INFO] - Adding orange with .push_back
   [TRACE] - Product created as  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
   [TRACE] Copy constructor invoked -> copied =  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
   [INFO] - Adding rice with .push_back 
   [TRACE] - Product created as  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
   [TRACE] Copy constructor invoked -> copied =  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
  ====== Experiment .emplace_back() ======
   [INFO] - Adding baccon with .emplace_back 
   [TRACE] - Product created as  Product{  name = Fresh tasty bacon; quantity  = 50; price = 30.25 }
   [INFO] - Adding soft drink with .emplace_back 
   [TRACE] - Product created as  Product{  name = Soft drink; quantity  = 100; price = 2.5 }
   ====== Inventory =======
  product 0 =  Product{  name = Orange - 1kg; quantity  = 10; price = 3.5 }
  product 1 =  Product{  name = Rice bag; quantity  = 20; price = 0.8 }
  product 2 =  Product{  name = Fresh tasty bacon; quantity  = 50; price = 30.25 }
  product 3 =  Product{  name = Soft drink; quantity  = 100; price = 2.5 }

#+END_SRC
** Methods of C++ STL Vetor<T>


| Vector Class Member               | Description                                                                  |
|-----------------------------------+------------------------------------------------------------------------------|
| *Constructors*                      |                                                                              |
|-----------------------------------+------------------------------------------------------------------------------|
| vector<a>(int size)               | Create a vector of size n                                                    |
| vector<a>(int size, a init)       | Create a vector of size n with all elements set to _init_                      |
| vector<a>(a [])                   | Intialize vector with an C-Array.                                            |
|                                   |                                                                              |
| *Methods*                           |                                                                              |
|-----------------------------------+------------------------------------------------------------------------------|
| vector<a>[i]                      | Get the element i of a vector. i ranges from 0 to size - 1                   |
| int  vector<a>::size()            | Get vector size                                                              |
| a    vector<a>::at(i)             | Get the nth element of a vector and checks if the index is within the bounds |
| bool vector<a>::empty()           | Returns true if vector is empty and false, otherwise.                        |
| void vector<a>::resize(int N)     | Resize vector to N elements.                                                 |
| void vector<a>::clear()           | Remove all elements and sets the vector size to 0.                           |
| ~void vector<a>::push_back(elem a)~ | Insert element at the end of v.                                              |
| a    vector<a>::begin()           | Returns first element.                                                       |
| a    vector<a>::end()             | Returns last element                                                         |
| ~void vector<a>::pop_back()~        | Remove last element of vector.                                               |
|                                   |                                                                              |
|                                   |                                                                              |

** Associative Container - Map methods 

Documentation: 
 + [[http://www.cplusplus.com/reference/map/map/][map - C++ Reference]]

| Method of map<K, V>          | Return type          |                                                                              |
|------------------------------+----------------------+------------------------------------------------------------------------------|
| *Capacity*                     |                      |                                                                              |
| empty()                      | bool                 | Return true if container empty                                               |
| size()                       | size_t               | Return number of elements                                                    |
| max_size()                   | sizet_t              | Return maximum number of elements                                            |
|                              |                      |                                                                              |
| *Element Access*               |                      |                                                                              |
| operator[](K k)              | V&                   | Return value associated to key k. It doesn't throw exception.                |
| at(K k)                      | V&                   | Return value associated to key k. Note: it can throw exception.              |
| find(const K& k)             | iterator             | Search for an element and returns map::end if it doesn't find the given key. |
| count(const K& k)            | size_t               | Count number of elements with a given key.                                   |
|                              |                      |                                                                              |
| *Modifiers*                    |                      |                                                                              |
| clear()                      | void                 | Remove all elements.                                                         |
| insert(std::pair<K, V> pair) | void                 | Insert a new key-value pair.                                                 |
| emplace(Args&&& ... args)    | pair<iterator, bool> |                                                                              |
|                              |                      |                                                                              |
|                              |                      |                                                                              |

Map example: 

 - File: *map-container.cpp*

#+BEGIN_SRC cpp 
  #include<iostream>
  #include<string>
  #include<map>
  #include <iomanip>

  struct Point3D{
          double x;
          double y;
          double z;
          Point3D(): x(0), y(0), z(0){}
          Point3D(double x, double y, double z): x(x), y(y), z(z){}
          /* Copy constructor 
       ,* -> Implement redundant copy constructor for logging purposes and 
       ,* detect when copy happens. 
       ,*/
          Point3D(const Point3D& p){		
                  std::cerr << " I was copied" << std::endl;
                  this->x = p.x;
                  this->y = p.y;
                  this->z = p.z;
          }
          ~Point3D() = default;
  };

  std::ostream& operator<< (std::ostream& os, const Point3D& p){
          os << std::setprecision(3) << std::fixed;
          return os << "Point3D{"
                            << "x = "  << p.x
                            << ",y = " << p.y
                            << ", z = "<< p.z
                            << "}";
  }

  int main(){	
          auto locations = std::map<std::string, Point3D>();
          locations["point1"] = Point3D(2.0, 3.0, 5.0);
          locations["pointX"] = Point3D(12.0, 5.0, -5.0);
          locations["pointM"] =  {121.0, 4.0, -15.0};
          locations["Origin"] = {}; // Point32{} or Point3D()
	
          // Invokes copy constructor
          std::cerr << "  <== Before inserting" << "\n";
          locations.insert(std::pair<std::string, Point3D>("PointO1", Point3D(0.0, 0.0, 0.0)));
          std::cerr << "  <== After inserting" << "\n";
	
          // operator[] doesn't throw exception 
          std::cout << "point1 = " << locations["point1"] << "\n";
          std::cout << "pointX = " << locations.at("pointX") << "\n";
          std::cout << "pointM = " << locations.at("pointM") << "\n";

          // Safer and uses exception 
          try {
                  std::cout << "pointY = " << locations.at("pointY") << "\n";
          } catch(const std::out_of_range& ex){
                  std::cout << "Error - not found element pointY. MSG = " << ex.what() << "\n";
          }

          if(auto it = locations.find("pointX"); it != locations.end())
                  std::cout << " [INFO]= => Location pointX found =  " << it->second << "\n";

          if(locations.find("pointMAS") == locations.end())
                  std::cout << " [ERROR] ==> Location pointMAS  not found" << "\n";
	
          std::cout << "Key-Value pairs " << "\n";
          std::cout << "-------------------------" << "\n";
          for (const auto& x: locations)
                  std::cout << x.first << " : " << x.second << "\n";
          std::cout << '\n';

          return 0;
  }

#+END_SRC

Running: 

#+BEGIN_SRC sh 
  $ clang++ map-container.cpp -o map-container.bin -std=c++1z -Wall -Wextra  && ./map-container.bin

    <== Before inserting
   I was copied
   I was copied
    <== After inserting
  point1 = Point3D{x = 2.000,y = 3.000, z = 5.000}
  pointX = Point3D{x = 12.000,y = 5.000, z = -5.000}
  pointM = Point3D{x = 121.000,y = 4.000, z = -15.000}
  pointY = Error - not found element pointY. MSG = map::at
   [INFO]= => Location pointX found =  Point3D{x = 12.000,y = 5.000, z = -5.000}
   [ERROR] ==> Location pointMAS  not found
  Key-Value pairs 
  -------------------------
  Origin : Point3D{x = 0.000,y = 0.000, z = 0.000}
  PointO1 : Point3D{x = 0.000,y = 0.000, z = 0.000}
  point1 : Point3D{x = 2.000,y = 3.000, z = 5.000}
  pointM : Point3D{x = 121.000,y = 4.000, z = -15.000}
  pointX : Point3D{x = 12.000,y = 5.000, z = -5.000}

#+END_SRC

** STL Algorithms 
*** Overview 

STL Algorithms are a collection of useful generic functions which
operates over iterators ranges of STL containers/collections for
performing many common tasks such as sorting, copying elements,
removing elements, computing sum of elements and so on. It is worth
knowing how to use iterators as they are already solve many common
tasks and problems and also avoids reiventing the wheel.

Notes: 

 + Function-object here means: function pointer, callable object which
   overloads the operator function-call _operator()(int x)_ or C++11
   lambda function. 

 + Many STL algorithsm works in similar way to higher order function
   of functional programming as they accept a function-object as
   argument.

 + STL Algorithms makes uses of iterators (generalization of pointers)
   and function-object argument or function arguments for short.

 + Benefits of STL Algorithms:
   + Allows declarative programming since they allow one to perform a task
     by declaring *what* to do instead of *how* to do. 
   + Provide a common vocabulary for C++ developers as iterators are
     standardized and widely known what can increase the code
     readability. 
   + Provide many blocks general building blocks for C++ what saves
     times and headaches.
   + Algorithms work with almost any STL container/collection/data
     structure and can also work with any custom collections which
     have iterators.

Iterator: 
 + Defintion: generalization of pointer - provides a standard
   interface for accessing elements of STL containers or any container
   supporting iterators without caring about the container
   implementation or the container internal data representation.

 + Types of iterators:

   + Input Iterator
     + Read-only and can be read only once.
     + istream_iterator(istream& is);
   + Output Iterator
     + Write-only
     + Example: ostream_iterator(ostream& os);
   + Forward Iterator
   + Random Access Iterator
     + Example: pointer to C-array and vector or deque iterators.

Algorithms: 

 + _Functional_
   + std::for_each
     + Applies a function which performs side effects on every element
       of a collection. 
   + std::transform 

 + _Query_
   + std::count
     + Count the number of elements equal to a given value 
   + std::count_if
     + Count the number of elements matching a given predicate function.
   + std::equal(iter begin1, iter end1, inter begin2)
   + std::all_of(iter begin, iter end, PRED pred) -> bool
     + Returns true if all elements satisfies a predicate function
       PRED which type is std::function<bool (X)> where X is the type
       of container elements. Note: For an empty container always returns
       true. 
   + std::any_of(iter begin, iter end, PRED pred) -> bool
     + Returns true if at least one element of the container satifies
       a predicate. For an empty containers, always returns false. 
   + std::none_of(iter begin, iter end, PRED pred) -> bool
     + Returns true if no element of a container satifies a given
       predicate.
   + std::find
   + std::find_if 
   + std::ajdacent_find
   + std::binary_search

 + _Moving_
   + std::copy(iter begin1, iter end1, iter begin2)
     + Copy contents of container 1 to container 2. Note: it makes the
       assumption that the second container or output iterator has
       enough slots to accomodate the elements of container1.
   + std::move(iter begin1, iter end1, iter begin2)
   + std::swap(iter begin1, iter end1, iter begin2)
     + Swap two containers with same size.

 + _Value Modifiers_
   + std::fill(iter begin1, iter end1, value);
     + Fill a container with a given value.
   + std::generate(iter begin1, iter end1, fn)
     + Fill a container by calling the function fn of type (() => T)
       at every element. Note: T is the type of container elements.
   + std::replace(iter begin1, iter end, T value1, T value2)
     + Replace all elements equal to value1 by value2.

 + _Reordering_
   + std::sort(iter begin, iter end)
   + std::reverse(iter begin, iter end)
   + std::rotate
   + std::shuffle(iter begin, iter end, std::default_random_engine(seed) - Note (C++11)
   + std::random_shuffle(iter begin, iter end) [Deprecated]
   + std::next_permutation
   + std::prev_permutation 

 + _Numeric_ - header <numeric>
   + std::iota
   + std::transform 
   + std::accumulate(iter begin, iter end, intial value)
     + Computes the sum of elements in the container by calling the
       operator (+)
   + std::adjacent_difference
   + std::partial_sum
   + std::inner_product 


Further Reading:  

 + [[https://www.youtube.com/watch?v=eidEEmGLQcU][CppCon 2015: Michael VanLoon “STL Algorithms in Action ” - YouTube]]
 + [[https://adv-r.hadley.nz/rcpp.html][Advanced R]]
 + [[https://www.fluentcpp.com/getthemap/][The World Map of C++ STL Algorithms - Fluent C++]]
 + [[http://www.techiedelight.com/data-structures-and-algorithms-interview-questions-stl/][Data structures and algorithms problems in C++ using STL]]
 + [[https://www.bogotobogo.com/cplusplus/stl4_algorithms.php][C++ Tutorial: STL IV - Algorithms - 2018]]
 + [[https://www.codeproject.com/Articles/854127/Top-Beautiful-Cplusplus-std-Algorithms-Examples][Top 5 Beautiful C++ std Algorithms Examples - CodeProject]]
 + [[https://www.go4expert.com/articles/cpp-stl-iterators-t34695/][C++ STL Iterators | Go4Expert]]
 + [[http://anderberg.me/2016/07/04/c-custom-iterators/][C++ Custom Iterators - Tobias Anderberg]]
 + [[http://www.drdobbs.com/c-iterators/184403135][C++: Iterators | Dr Dobb's]]
 + [[https://www.cs.odu.edu/~zeil/cs361/f17/Public/iterators/index.html][Iterators: an ADT for Positions]]

Documentation: 

 + C++ STL 
   * [[https://en.cppreference.com/w/cpp/iterator/iterator][std::iterator - cppreference.com]]
   * [[https://en.cppreference.com/w/cpp/iterator/next][std::next - cppreference.com]]
   * [[https://en.cppreference.com/w/cpp/iterator/iterator_traits][std::iterator_traits - cppreference.com]]

 + Boost Library 
   * [[https://www.boost.org/doc/libs/1_66_0/libs/iterator/doc/index.html][The Boost.Iterator Library Boost - 1.66.0]]

*** for_each 

 - vector 

#+BEGIN_SRC cpp 
  >> std::vector<int> v{2, 4, 56, 10, 25, 60, 10, 50, -10};
  >> std::for_each(v.begin(), v.end(), [](double x){ std::cout << std::setw(10) << x << "\n";});
           2
           4
          56
          10
          25
          60
          10
          50
         -10
#+END_SRC

 - deque 

#+BEGIN_SRC cpp 
  >> std::deque<int> vx{2, 4, 56, 10, 25, 50};
  >> std::for_each(vx.begin(), vx.end(), [](double x){ std::cout << std::setw(10) << x << "\n";});
           2
           4
          56
          10
          25
          50
#+END_SRC

 - list

#+BEGIN_SRC cpp 
>> std::list<int> v{2, 4, 56, 10, 25, 60, 10};
>>  std::for_each(v.begin(), v.end(), [](int x){ std::cout << std::setw(10) << x << "\n";});
         2
         4
        56
        10
        25
        60
        10
#+END_SRC

 - map (aka - hash map, hash table or dictionary)

#+BEGIN_SRC cpp 
  >> auto dataset = std::map<std::string, double> { {"x", 10.23}, {"z", -2.341}, {"k", sqrt(2)}};
  >> 
  std::cout << std::fixed << std::setprecision(3);
  std::for_each(dataset.begin(), dataset.end(),
                            [](const std::pair<std::string, double>& p){
                                    std::cout << std::setw(10) << p.first << std::setw(10) << p.second << "\n";
                            });
#+END_SRC

Output: 

#+BEGIN_SRC text 
         k     1.414
         x    10.230
         z    -2.341
#+END_SRC

*** istream iterator 
**** File 

#+BEGIN_SRC cpp 
  >> std::list<int> vy{2, 4, 56, 10, 25, 50};
  >> std::for_each(vy.begin(), vy.end(), [](double x){ std::cout << std::setw(10) << x << "\n";});
           2
           4
          56
          10
          25
          50
#+END_SRC

 - file: 

#+BEGIN_SRC cpp 
  auto file   = std::ifstream("/etc/hosts");
  auto b  = std::istream_iterator<std::string>(file);    
  auto e  = std::istream_iterator<std::string>(); 
  std::for_each(b, e, [](std::string word){ std::cout << word << "\n";});  

  >> auto file   = std::ifstream("/etc/hosts");
  >> auto b  = std::istream_iterator<std::string>(file);    
  >> auto e  = std::istream_iterator<std::string>(); 
  >> std::for_each(b, e, [](std::string word){ std::cout << word << "\n";});   
  127.0.0.1
  localhost
  localhost.localdomain
  localhost4
  localhost4.localdomain4
  ::1
  localhost
  localhost.localdomain
  localhost6
  localhost6.localdomain6
  >> 
 
#+END_SRC
**** String

#+BEGIN_SRC cpp 
  std::string price = "10.23 12.0 10.05 10.8 15.80 16.24";
  std::stringstream ss(price);
  std::istream_iterator<double> b(ss);
  std::istream_iterator<double> e;

  std::cout << std::fixed << std::setprecision(3);
  std::for_each(b, e, [](double x){ std::cout << std::setw(10) << x << "\n";})

  >> std::for_each(b, e, [](double x){ std::cout << std::setw(10) << x << "\n";})
      10.230
      12.000
      10.050
      10.800
      15.800
      16.240
#+END_SRC

*** fill 

Set or initialize all container elements with a given element.

 + Header: <algorithm>

Usage:

#+BEGIN_SRC cpp 
  std::fil(IteratorBegin, IteratorEnd, value);
#+END_SRC

 - Vector 

#+BEGIN_SRC cpp 
  >> std::vector<double> xs1(5);
  >> xs1
  (std::vector<double> &) { 0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000 }
  >> 
  >> std::fill(xs1.begin(), xs1.end(), 3.5)
  >> xs1
  (std::vector<double> &) { 3.5000000, 3.5000000, 3.5000000, 3.5000000, 3.5000000 }
  >> 
  >> std::fill(xs1.begin(), xs1.begin() + 3, 4.0)
  >> xs1
  (std::vector<double> &) { 4.0000000, 4.0000000, 4.0000000, 3.5000000, 3.5000000 }
  >> 
#+END_SRC

 - List 

#+BEGIN_SRC cpp 
  >> std::list<double> xs2(5);
  >> xs2
  (std::list<double> &) { 0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000 }
  >> std::fill(xs2.begin(), xs2.end(), 15.0)
  >> xs2
  (std::list<double> &) { 15.000000, 15.000000, 15.000000, 15.000000, 15.000000 }
  >> 
  >> 
#+END_SRC
*** Copy iterator to output stream 

#+BEGIN_SRC cpp 
 >> vector<double> p {3.0, 5.0, 5.0, -10.0};

 >> std::copy(p.begin(), p.end(), std::ostream_iterator<double>(std::cout, "\n"));
 3
 5
 5
 -10
#+END_SRC
*** Copy 

 - Copy vector to deque.

#+BEGIN_SRC cpp 
  >> std::vector<int> xs{1, 2, 10, 20, 30, 50};

  >> std::deque<int> ds;
  >> 
  >> ds
  (std::deque<int> &) {}
  >> 

  >> std::copy(xs.begin(), xs.end(), std::back_inserter(ds));
  >> ds
  (std::deque<int> &) { 1, 2, 10, 20, 30, 50 }
  >> 

#+END_SRC

 - Copy deque to stdout 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <deque>
  #include <iterator> // ostream_iterator 
  #include <algorithm>

  auto xs = std::deque<int> {15, -2, 10, 20, 30, 5};
  auto oit = std::ostream_iterator<int>(std::cout, "\n ");
  std::copy(xs.begin(), xs.end(), oit);

  >> std::copy(xs.begin(), xs.end(), oit);
  15
   -2
   10
   20
   30
   5
  >> 
#+END_SRC

 - Copy deque to string

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <deque>
  #include <iterator> // ostream_iterator 
  #include <algorithm>
  #include <string> 
  #include <sstream>  

  auto xs = std::deque<int> {15, -2, 10, 20, 30, 5};
  std::stringstream ss;
  auto oit = std::ostream_iterator<int>(ss, " ");
  std::copy(xs.begin(), xs.end(), oit);

  >> std::cout << ss.str() << "\n";
  15 -2 10 20 30 5 
  >> 
#+END_SRC

 - Copy C-array to vector

#+BEGIN_SRC cpp 
  >> auto v1 = std::vector<double>{}
  (std::vector<double, std::allocator<double> > &) {}

  >> auto v2 = std::vector<double>{}
  (std::vector<double, std::allocator<double> > &) {}

  >> double dataset[] = {-2.23, 10.94, 8.87, 4.56, 2.15}
  (double [5]) { -2.2300000, 10.940000, 8.8700000, 4.5600000, 2.1500000 }
  >> 

  >> std::copy(std::begin(dataset), std::end(dataset), std::back_inserter(v1))
  (std::back_insert_iterator<std::vector<double, std::allocator<double> > >) @0x250d860
  >> v1
  (std::vector<double, std::allocator<double> > &) { -2.2300000, 10.940000, 8.8700000, 4.5600000, 2.1500000 }
  >> 

  >> std::copy(dataset, dataset + 5, std::back_inserter(v2));
  >> v2
  (std::vector<double, std::allocator<double> > &) { -2.2300000, 10.940000, 8.8700000, 4.5600000, 2.1500000 }
  >> 

#+END_SRC

*** Count 

The algorithm count returns how many elements of a container are equal
to a given value.

 - Vector: 

#+BEGIN_SRC cpp 
  >> auto xs = std::vector<int> {1, 2, 3, 2, 2, 5, 9, 8, 10, 5, 9, 4, 2, 9, 1};
  >> 
  >> std::count(xs.begin(), xs.end(), 1)
  (long) 2
  >> std::count(xs.begin(), xs.end(), 2)
  (long) 4
  >> std::count(xs.begin(), xs.end(), 8)
  (long) 1
  >> std::count(xs.begin(), xs.end(), 100)
  (long) 0
  >> 
#+END_SRC

 - C arrays

#+BEGIN_SRC cpp 
  >> int arr [] = {1, 2, 3, 2, 2, 5, 9, 8, 10, 5, 9, 4, 2, 9, 1};

  // Number of array elements 
  >> int size = sizeof(arr) / sizeof(int)
  (int) 15

  >> std::count_if(arr, arr + size, [](int x){ return x == 100;})
  (long) 0
  >> std::count_if(arr, arr + size, [](int x){ return x == 2;})
  (long) 4
  >> std::count_if(arr, arr + size, [](int x){ return x == 8;})
  (long) 
#+END_SRC

*** CountIf 

Count how many elements satifies a given predicate.

#+BEGIN_SRC cpp 
  >> std::count_if(xs.begin(), xs.end(), [](int x){ return x == 100;})
  (long) 0
  >> 
  >> std::count_if(xs.begin(), xs.end(), [](int x){ return x == 2;})
  (long) 4
  >> std::count_if(xs.begin(), xs.end(), [](int x){ return x == 100;})
  (long) 0
  >> 

  >> std::count_if(arr, arr + size, [](int x){ return x <= 5;})
  (long) 10
  >> 
#+END_SRC
*** Equal 

Check whether two sequences are equal, example: 

#+BEGIN_SRC cpp 
   >> 
   >> std::vector<int> xs{1, 2, 3, 4, 5, 6};
   >> std::list<int> xslist{1, 2, 3, 4, 5, 6};
   >> 
   >> std::equal(xs.begin(), xs.end(), xslist.begin())
   (bool) true
   >> std::equal(xslist.begin(), xslist.end(), xs.begin())
   (bool) true
   >> xslist.push_front(7)
   >> xslist
   (std::list<int> &) { 7, 1, 2, 3, 4, 5, 6 }
   >> std::equal(xslist.begin(), xslist.end(), xs.begin())
   (bool) false
   >> std::equal(xs.begin(), xs.end(), xslist.begin())
   (bool) false
   >> 

#+END_SRC

*** generator 

Header: <algorithm>

 - <https://en.cppreference.com/w/cpp/algorithm/generate>

#+BEGIN_SRC cpp 
  >> std::vector<int> xs(10);
  >> xs
  (std::vector<int> &) { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

  >> std::generate(xs.begin(), xs.end(), [](){ return 5; })
  >> xs
  (std::vector<int> &) { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 }

  >> int x = 0;
  >> std::generate(xs.begin(), xs.end(), [&](){ x++  ; return x; })
  >> xs
  (std::vector<int> &) { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
  >> 

  >> int k = 1;
  >> std::generate(xs.begin(), xs.end(), [&](){ k++  ; return k * 3; })
  >> xs
  (std::vector<int> &) { 6, 9, 12, 15, 18, 21, 24, 27, 30, 33 }
  >> 

#+END_SRC
*** reverse 

Reverse a sequence. 
 - Header: <algorithm>
 - https://en.cppreference.com/w/cpp/algorithm/reverse

STL List 

#+BEGIN_SRC cpp 
  >> std::list<std::string> data = { "hello" , "world", "C++", "iterators", "assembly"};

  >> data
  (std::list<std::string> &) { "hello", "world", "C++", "iterators", "assembly" }
  >> std::reverse(data.begin(), data.end())

  >> data
  (std::list<std::string> &) { "assembly", "iterators", "C++", "world", "hello" }
  >> 
#+END_SRC

STL Vector 

#+BEGIN_SRC cpp 
  >> std::vector<std::string> data2 = { "hello" , "world", "C++", "iterators", "assembly"};

  >> std::reverse(data2.begin(), data2.end())

  >> data2
  (std::vector<std::string> &) { "assembly", "iterators", "C++", "world", "hello" }
  >> 
#+END_SRC

*** iota 

Header: <numeric>

 - [[https://en.cppreference.com/w/cpp/algorithm/iota][std::iota - cppreference.com]]

#+BEGIN_SRC cpp 
  >> std::iota(xsa.begin(), xsa.end(), 1)
  >> xsa
  (std::vector<int> &) { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
  >> std::iota(xsa.begin(), xsa.end(), 2)
  >> xsa
  (std::vector<int> &) { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }
  >> std::iota(xsa.begin(), xsa.end(), 2)
  >> xsa
  (std::vector<int> &) { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }
  >> std::iota(xsa.begin(), xsa.end(), 4)
  >> xsa
  (std::vector<int> &) { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 }
  >>     
#+END_SRC
*** accumulate 

This function works in a similar way to the fold-left operation common
in functional programming languages.

 - header: <numeric>
 - https://en.cppreference.com/w/cpp/algorithm/accumulate

#+BEGIN_SRC cpp 
  >> std::vector<int> xss{1, 2, 4, 5, 6, 7, 8, 9};
  >> xss
  (std::vector<int> &) { 1, 2, 4, 5, 6, 7, 8, 9 }
  >> 
  >> std::accumulate(xss.begin(), xss.end(), 0, [](int acc, int x){ return 10 * acc + x;})
  (int) 12456789
  >> 

  // Sum of all elements 
  >> std::accumulate(xss.begin(), xss.end(), 1, [](int acc, int x){ return acc + x;})
  (int) 43
  >> 

  // Product of all elements 
  >> std::accumulate(xss.begin(), xss.end(), 1, [](int acc, int x){ return acc * x;})
  (int) 120960
  >> 
#+END_SRC
*** adjacent different 

 - header: <numeric>
 - https://en.cppreference.com/w/cpp/algorithm/adjacent_difference

#+BEGIN_SRC cpp
  >> std::vector<int> v{2, 4, 56, 10, 25, 60};

  >> std::deque<int> d(v.size());

  >> std::adjacent_difference(v.begin(), v.end(), d.begin())
  (std::_Deque_iterator<int, int &, int *>) @0x3c84010

  >> d
  (std::deque<int> &) { 2, 2, 52, -46, 15, 35 }
  >> 
#+END_SRC
*** max_element and min_element 

Max element iterator -> Get the maximum element of an STL-like
container/collection. 

References:
 + [[https://en.cppreference.com/w/cpp/algorithm/max_element][std::max_element - cppreference.com]]
 + [[https://en.cppreference.com/w/cpp/algorithm/min_element][std::min_element - cppreference.com]]

Usage: 
 - Note: T is the type of container elements.
 
#+BEGIN_SRC text 
  max_element(iterator Begin, iterator End) -> iterator 
  max_element(iterator Begin, iterator End, Comparator comp) -> iterator 
#+END_SRC

Example: 

#+BEGIN_SRC cpp 
  std::vector<double> xs = {-1.2, -50.0, 100.0, -4.2, 105, -200.423};

  auto it = std::max_element(xs.begin(), xs.end());

  >> *it
  (double) 105.00000
  >> 

  for(; it != xs.end(); it++){ std::cout << *it << "\n"; }

  >> for(; it != xs.end(); it++){ std::cout << *it << "\n"; }
  105
  -200.423
  >>

  // Find maximum element with custom comparator 
  auto it2 = std::max_element(xs.begin(), xs.end(),
                             [](double x, double y){ return std::abs(x) < std::abs(y);} )

  >> *it2
  (double) -200.42300
  >> 
  >>
  >> for(; it2 != xs.end(); it2++){ std::cout << *it2 << "\n"; }
  -200.423
  -200.423
  >> 

  >> xs.clear()
  >> xs
  (std::vector<double> &) {}
  >> 

  auto it3 = std::max_element(xs.begin(), xs.end(),
                             [](double x, double y){ return std::abs(x) < std::abs(y);});

  // If returns true, then no value is found. 
  >> it3 == xs.end()
  (bool) true

  >> it3 != xs.end()
  (bool) false
	
#+END_SRC

** Math 
*** Standard library Math-releated headers

 - C++ Numeric Library Overview
   + [[https://en.cppreference.com/w/cpp/numeric][Numerics library - cppreference.com]]
 - *<cmath>* - Math functions, sin, cos, tan, exp, log, ... 
   + [[https://en.cppreference.com/w/cpp/header/cmath][Standard library header <cmath> - cppreference.com]]
 - *<cfloat>* - Float Point Constants such as ~FLT_RADIX~, ~DBL_RADIX~, ~FLT_MIN~,  ~DBL_EPS~ ... 
   + [[http://www.cplusplus.com/reference/cfloat/][<cfloat> (float.h) - C++ Reference]]
 - *<limits>* - Allows querying numeric types information such as radix,
   machine  precision eps, number of decimal digits and so on. 
   + [[https://en.cppreference.com/w/cpp/types/numeric_limits][std::numeric_limits - cppreference.com]]
 - *<random>* - C++11 Random number generator.
   + [[https://en.cppreference.com/w/cpp/header/random][Standard library header <random> - cppreference.com]]

*** Numerical Constants

Notes: Those constants are defined at the header <cmath>

| Constant                    |      Value | Description                                                                   |
|-----------------------------+------------+-------------------------------------------------------------------------------|
| *IEE754 Float Point Contants* |            |                                                                               |
| NAN                         |          - | (Since C++11) Constant not a number, used to indicate an invalid float point. |
| INFINITY                    |          - | (Since C++11) Positive infinity.                                              |
| -INFINITY                   |          - | (Since C++11) Negative infinity.                                              |
|                             |            |                                                                               |
| *General Math Constants*      |            |                                                                               |
| ~M_E~                         |  2.7182818 | Euler's number or exp(1)                                                      |
| ~M_LN2~                       | 0.69314718 | Natural logarithm of 2 or log(2)                                              |
| ~M_LN10~                      |  2.3025851 | Natural logarithm of 10 or log(10)                                            |
|                             |            |                                                                               |
| ~M_LOG10E~                    | 0.43429448 | Log of E (Euler's number) at base 10                                          |
| ~M_LOG2E~                     |  1.4426950 | Log of E (Euler's number) at base 2                                           |
|                             |            |                                                                               |
| ~M_SQRT2~                     |  1.4142136 | Square root of 2 or sqrt(2)                                                   |
| ~M_SQRT1_2~                   | 0.70710678 | Square root of 1/2 or sqrt(1/2) or 1/sqrt(2)                                  |
|                             |            |                                                                               |
| ~M_PI~                        |  3.1415927 | PI number                                                                     |
| ~M_PI_2~                      |  1.5707963 | PI/2                                                                          |
| ~M_PI_4~                      | 0.78539816 | PI/3                                                                          |
| ~M_1_PI~                      | 0.31830989 | 1/PI                                                                          |
| ~M_2_PI~                      | 0.63661977 | 2/PI                                                                          |
| ~M_2_SQRTPI~                  |  1.1283792 | 2/sqrt(PI)                                                                    |
|                             |            |                                                                               |
|                             |            |                                                                               |

See: 

 + P0631R2 Math Constants - Document P0631R2 - *Math Constants* -
   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0631r2.pdf>

 + [[https://en.cppreference.com/w/cpp/numeric/math/INFINITY][INFINITY - cppreference.com]]

 + [[https://en.cppreference.com/w/cpp/numeric/math/NAN][NAN -
   cppreference.com]]
** C++17 std::invoke 
   :PROPERTIES:
   :ID:       5754cb0e-f4d3-434c-85e0-5ea55655a22f
   :END:

 Function which provides an uniform interface for invoking anything
 callable such as class member functions (ordinary methods), static
 member functions (static methods), functios and etc.

 See: https://en.cppreference.com/w/cpp/utility/functional/invoke

  + File: [[file:src/cpp17/cpp17-invoke.cpp][file:src/cpp17/cpp17-invoke.cpp]]
  + Online Compiler: http://rextester.com/IPY88297


 #+BEGIN_SRC cpp :tangle src/cpp17/cpp17-invoke.cpp
   #include <iostream>
   #include <string>
   #include <ostream>

   // std::invoke is provide by header functional
   #include <functional> 

   struct Dummy{
           double evalme(double x)	{
                   std::cerr << __FILE__ << ":" << __LINE__ << " I was evaluated ; 2x = " << 2 *x << '\n';
                   return 2 * x;
           }
           double operator()(double x){
                   std::cerr << __FILE__ << ":" << __LINE__ << " Call function-operator << 4 * x = " << 4 * x << '\n';
                   return 4 * x;
           }
   };

   double computeDouble(double x){
           std::cerr << __FILE__ << ":" << __LINE__ << " Computed double of 2x = " << 2 * x << '\n';
           return 2 * x;
   }

   int main(){
           std::invoke(computeDouble, 3.0);
           Dummy dummy;
           std::invoke(dummy, 3.0);
           std::invoke(Dummy(), 2.0);
           // Call method: .evalme indirectly 
           std::invoke(&Dummy::evalme, dummy, 3.0);
           return 0;
   }

 #+END_SRC

 Compile and run: 

 #+BEGIN_SRC sh 
   g++ cpp17-invoke.cpp -o out.bin -std=c++1z -Wall -Wextra && ./out.bin
   cpp17-invoke.cpp:20 Computed double of 2x = 6
   cpp17-invoke.cpp:14 Call function-operator << 4 * x = 12
   cpp17-invoke.cpp:14 Call function-operator << 4 * x = 8
   cpp17-invoke.cpp:9 I was evaluated ; 2x = 6
 #+END_SRC

** C++17 std::any 
   :PROPERTIES:
   :ID:       9397a9a0-e641-4cb6-89b7-24a82fe12d99
   :END:

This example shows how to use the C++17 std::any container which comes
froom boost::any.

See: https://en.cppreference.com/w/cpp/utility/any

File:  [[file:src/cpp17/cpp17-any.cpp][file:src/cpp17/cpp17-any.cpp]] 

#+BEGIN_SRC cpp :tangle src/cpp17/cpp17-any.cpp
  #include <iostream>
  #include <string>
  #include <iomanip>
  #include <ostream>

  #include <any>

  struct Point{
      double x;
      double y;
      Point(double x, double y): x(x), y(y) {}

      // Copy constructor
      Point(const Point& p){
          std::cerr << " -->> Copy constructor" << '\n';
          x = p.x;
          y = p.y;
      }   
  };

  std::ostream& operator<<(std::ostream& os, const Point& p){
      os << "Point(" << p.x << ", " << p.y << ") ";
      return os;
  }

  template<typename T>
  auto printInfo(std::any x) -> void{
      std::cout << " x.type = " << x.type().name()
                << " ; value(x) = "
                << std::any_cast<T>(x)
                << '\n';  
  }

  int main(){
      // Print boolean as 'true', 'false', instead of 0 or 1
      std::cout << std::boolalpha;
      std::any x = 1;
      printInfo<int>(x);
      x = 10.233;
      printInfo<double>(x);
      x = 'k';
      printInfo<char>(x);
      x = "hello world";
      printInfo<const char*>(x);
      x = std::string("hello world");
      printInfo<std::string>(x);  
      x = Point(100.0, 20.0);
      printInfo<Point>(x);
      std::cout << "Has value: x.has_value() = " << x.has_value() << '\n';
      x.reset();                                                         
      std::cout << "Has value: x.has_value() = " << x.has_value() << '\n';                                                               
      std::cout << "Try casting " << std::endl;
      x = "testing type casting";
      try{
          std::any_cast<int>(x);
      } catch (const std::bad_any_cast& ex) {
          std::cerr << " >>> Exception: what = " << ex.what() << '\n'; 
      }
      std::cerr << " >>> End the program gracefully" << '\n'; 
      return 0;
  }

#+END_SRC

Compiling with gcc: 

#+BEGIN_SRC sh 
  $ g++ --version
  g++ (GCC) 7.3.1 20180130 (Red Hat 7.3.1-2)
  .. ... ... ... 

  $ g++ cpp17-any.cpp -o out.bin -std=c++1z -Wall -Wextra && ./out.bin
   x.type = i ; value(x) = 1
   x.type = d ; value(x) = 10.233
   x.type = c ; value(x) = k
   x.type = PKc ; value(x) = hello world
   x.type = NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE ; value(x) = hello world
   -->> Copy constructor
   -->> Copy constructor
   x.type = 5Point ; value(x) =  -->> Copy constructor
  Point(100, 20) 
  Has value: x.has_value() = true
  Has value: x.has_value() = false
  Try casting 
   >>> Exception: what = bad any_cast
   >>> End the program gracefully
#+END_SRC

Compile with MSVC / VC++ on Windows: 

#+BEGIN_SRC sh 
  $ cl.exe cpp17-any.cpp /EHsc /Zi /nologo /std:c++17 /Fe:out.exe && out.exe
  cpp17-any.cpp
   x.type = int ; value(x) = 1
   x.type = double ; value(x) = 10.233
   x.type = char ; value(x) = k
   x.type = char const * __ptr64 ; value(x) = hello world
   x.type = class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > ; value(x) = hello world
   -->> Copy constructor
   -->> Copy constructor
   -->> Copy constructor
   x.type = struct Point ; value(x) = Point(100, 20) 
  Has value: x.has_value() = true
  Has value: x.has_value() = false
  Try casting 
   >>> Exception: what = Bad any_cast
   >>> End the program gracefully
#+END_SRC
** C++17 std::variant 
   :PROPERTIES:
   :ID:       8232d77f-99a5-4434-96f2-c5c3cfd6d956
   :END:

C++17 new std::variant which comes from Boost.Variant provides a
type-safe discriminated union or sum type which is similar to pattern
matching from functional programming languages like Haskell, OCaml and
Scala. In addition to those benefits, the std::variant is an
out-of-the-box generic visitor design pattern and a type-safe
replacement for old C-unions.

Potential Applications: 
 + Implement visitor OOP pattern.
 + Simulate or emulate pattern matching from functional languages.
 + Manipulate abstract syntax trees.

Useful concepts references: 
 + [[https://en.wikipedia.org/wiki/Tagged_union][Tagged union - Wikipedia]]
 + [[https://en.wikipedia.org/wiki/Algebraic_data_type][Algebraic data type - Wikipedia]]

Documentation: 
 + https://en.cppreference.com/w/cpp/utility/variant
 + [[https://www.boost.org/doc/libs/1_64_0/doc/html/variant.html][Chapter 45. Boost.Variant - 1.64.0]]

Code example: 

 - File: [[file:src/cpp17/variant.cpp][file:src/cpp17/variant.cpp]] 

#+BEGIN_SRC cpp :tangle src/cpp17/variant.cpp
  #include <iostream>
  #include <variant> // C++17
  #include <string>
  #include <ostream>
  #include <deque>
  #include <vector>
  #include <iomanip>

  template <class T>
  auto display(const std::string& name, const T& t) -> void;

  // Pattern matching using constexpr => May be the more performant way 
  template<class T>
  auto identifyAndPrint(const T& v) -> void;

  struct VisitorOperation{
          auto operator()(int num) -> void {
                  std::cout << "type = int     => value = " << num << "\n";
          }
          auto operator()(double num) -> void {
                  std::cout << "type = double  => value = " << num << "\n";
          }
          auto operator()(const std::string& s){
                  std::cout << "type = string  => value = " << s << "\n";
          }
  };

  int main(){
          // using <1>, <2>, ... <n> => Only available at C++17
          using std::cout, std::endl, std::cerr;
          auto nl = "\n";
          std::cout << std::boolalpha;
          cout << "========== Test 1 ==================" << nl;	
	
          // std::variant<int, double, std::string> somevar;
          auto x = std::variant<int, double, std::string>();
          x = 100;
          std::cout << "variant has int    = " << std::holds_alternative<int>(x) << nl;
          std::cout << "variant has double = " << std::holds_alternative<double>(x) << nl;
          std::cout << "variant has string = " << std::holds_alternative<std::string>(x) << nl;
          display("x", x);
          std::cout << "-------------------" << nl;
          x = 204.45;
          std::cout << "variant has double = " << std::holds_alternative<double>(x) << nl;	
          display("x", x);
          std::cout << "-------------------" << nl;
          x = "std::variant is awesome!";
          std::cout << "variant has string = " << std::holds_alternative<std::string>(x) << nl;
          display("x", x);

          cout << "========== Test 2 ==================" << nl;
          try{ 
                  // Try to get int 
                  int m = std::get<int>(x);
                  std::cout << "m = " << m << "\n";
          } catch(const std::bad_variant_access& ex){
                  std::cerr << "Error: Failed to extract int." << nl;
          }
          try{ 
                  // Try to get string 
                  auto s = std::get<std::string>(x);
                  std::cout << "s = " << s << nl;
          } catch(const std::bad_variant_access& ex){
                  std::cerr << "Error: Failed to extract string." << nl;
          }

          cout << "========== Test 3 ==================" << nl;
          x = -100;
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);
          x = 20.52;
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);

          x = "<hello world std::variant>";
          std::visit([](auto&& p){
                                     std::cout << "x = " << p << '\n';
                             }, x);

          cout << "========== Test 4 ==================" << nl;
          // auto + uniform initialization 
          auto xs = std::deque<std::variant<int, double, std::string>>{10.0, 20, 5, "hello", 10, "world"};
          for(const auto& e: xs){
                  identifyAndPrint(e);
          }
          cout << "========== Test 5 ==================" << nl;
          for(const auto& e: xs){
                  std::visit(VisitorOperation(), e);
          }	
          return 0;
  }

  // It works in a similar fashion to functional languages with
  // pattern matching such as Haskell, Scala, OCaml and so on.
  // std::variant is also a type-safe alternative to old C-unions.
  template <class T>
  auto display(const std::string& name, const T& t) -> void {
          auto nl = "\n";
          // Boost.Variant uses boost::get<TYPE>(&t), now changed to std::get_if
          if(auto n = std::get_if<int>(&t)){
                  std::cout << " = " << *n << nl;
                  return; // Early return 
          }
          if(auto d = std::get_if<double>(&t)){
                  std::cout << name << " = " << *d << nl;
                  return;
          }	
          if(auto s = std::get_if<std::string>(&t)){
                  std::cout << name << " = " << *s << nl;
                  return;
          }
          std::cout << "<UNKNOWN>" << std::endl;
  }

  template<class T>
  auto identifyAndPrint(const T& v) -> void{
          std::visit([](auto&& a){
              using C = std::decay_t<decltype(a)>;
              if constexpr(std::is_same_v<C, int>){
                              std::cout << "Type is int => value = " << a << "\n";
                              return;
              }
              if constexpr(std::is_same_v<C, double>){
                              std::cout << "Type is double => value = " << a << "\n";
                              return;
              }
              if constexpr(std::is_same_v<C, std::string>){
                              std::cout << "Type is string => value = " << a << "\n";
                              return;
              }
              std::cout << "Type is unknown" << "\n";
                             }, v);
  } // End of func. identifyAndPrint() ---//

#+END_SRC

Compile with GCC:

#+BEGIN_SRC sh 
 $ g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin 
#+END_SRC

Compile with Clang:

#+BEGIN_SRC sh 
 $ g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin 
#+END_SRC

Running: 

#+BEGIN_SRC sh 
  g++ variant.cpp -o variant.bin -std=c++1z -Wall -Wextra  && ./variant.bin

  ========== Test 1 ==================
  variant has int    = true
  variant has double = false
  variant has string = false
   = 100
  -------------------
  variant has double = true
  x = 204.45
  -------------------
  variant has string = true
  x = std::variant is awesome!
  ========== Test 2 ==================
  Error: Failed to extract int.
  s = std::variant is awesome!
  ========== Test 3 ==================
  x = -100
  x = 20.52
  x = <hello world std::variant>
  ========== Test 4 ==================
  Type is double => value = 10
  Type is int => value = 20
  Type is int => value = 5
  Type is string => value = hello
  Type is int => value = 10
  Type is string => value = world
  ========== Test 5 ==================
  type = double  => value = 10
  type = int     => value = 20
  type = int     => value = 5
  type = string  => value = hello
  type = int     => value = 10
  type = string  => value = world


#+END_SRC

* General C++ Reference Card 
** Namespace
*** Summary 

| C++ Namespace                         | Python Equivalent                          | Description                                          |
| Operation                             |                                            |                                                      |
|---------------------------------------+--------------------------------------------+------------------------------------------------------|
| ~using namespace std;~                  | from std import *                          | Import everything from  a namespace.                 |
| ~using std::cout;~                      | from std import cout                       | Import an object, function from a namespace.         |
| using std::cout, std::cin, std::endl; | from std import cout, cin ...              | Import multiple items from a namespace (C++17 only.) |
| ~namespace mk = mathkit::ellipticfun;~  | import mathkit.ellipticfun as mk           | Create an alias to a namespace.                      |
| mathkit::function::sind(90);          | import mathkit; mathkit.function.sind(90); | Call a function from namespace.                      |
|                                       |                                            |                                                      |

*** Examples 

Open namespace:

 - =using namespace <namespace>=

#+BEGIN_SRC cpp  
 // Not recommended - It defeats the purpose of namespace which is prevent 
 // nameclashes and improve discoverability. 
 using namespace std;
 std::cout << "Hello world" << "\n";

 // Import everything from boost linear algebra library.
 using namespace boost::numeric::ublas;
#+END_SRC

Open namespace inside function:

#+BEGIN_SRC cpp 
  void printNumbers() {
          // Import everything from std namespace 
          using namespace std;
          for(int i = 0; i < 10; i++)
                  cout << "i = " << i << "\n";
  }

  // C++11 auto syntax for function declaration
  auto printNumbers() -> void {
          using namespace std;
          for(int i = 0; i < 10; i++)
                  cout << "i = " << i << "\n";
  }

  // C++14 return type deduction with optional type deduction.
  auto printNumbers() {
          // Import everything from std namespace 
          using namespace std;
          for(int i = 0; i < 10; i++)
                  cout << "i = " << i << "\n";
  }
#+END_SRC

Using element from namespace without import namespace. 

#+BEGIN_SRC cpp 
  std::cout << "hello world" << std::endl;
  auto matrixI3 =  boost::numeric::ublas::identity_matrix<double>(3));
#+END_SRC

Import specific elements from namespace 

#+BEGIN_SRC cpp 
  // Option 1 
  //----------------------------------------//
  using std::cout; 
  using std::cerr; 
  using std::endl; 
  using boost::numeric::ublas::identity_matrix;
  using boost::numeric::ublas::norm_1;
 
  // Option 2 => Multiple imports at same line. 
  //----------------------------------------//
  using std::cout; using std::cerr;  using std::endl; 
  using boost::numeric::ublas::identity_matrix; using boost::numeric::ublas::norm_1;

  // Option 3 => C++17 only 
  //----------------------------------------//
  using std::cout, std::cerr, std::endl; 
  using boost::numeric::ublas::identity_matrix, boost::numeric::ublas::norm_1;

#+END_SRC

Namespace synonym/alias:

#+BEGIN_SRC cpp
  // Create namespace alias ub 
  namespace ub = boost::numeric::ublas;

  ub::matrix<double> matrix1(3, 3, 2.5);
  // auto type inference + uniform initalization 
  auto matrix1 = ub::matrix<double> {3, 3, 2.5};

#+END_SRC

Create a namespace: 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <ostream>
  #include <functional>
  #include <cmath>

  namespace MyFunctions{
          // Import everything from namespace std 
          using namespace::std;

          // Type alias or synonym 
          using cstring = const char*;

          // Or: using MathFunc = std::function<double (double)>;
          using MathFunc = std::function<auto (double) -> double>;

          cstring description = "Utility functions";
	
          double add(double x, double y){
                  return x + y;
          }
	
          auto saySomething() -> void {
                  cout << "A computer was a skilled mathematician who computed the firing tables" << endl;
          }
          struct Coord{
                  // Latitude in degrees/decimal 
                  double lat;
                  // Longitude in degrees/decimal 
                  double lon;
          };

          namespace math {
                  auto showTable(MathFunc fun, std::ostream& os = std::cout) -> void{
                          for(double x = 0; x < 10.0; x += 1.0){
                                  os << setw(10) << x << setw(10) << fun(x) << "\n";
                          }
                  }
                  auto makeMultiplier(double x) -> MathFunc {
                          return [x](double y){return x * x; };
                  }		
          }
	
  }; // End of namespace MyFunctions --/
#+END_SRC

Testing: (CERN's ROOT/Cling REPL.)

#+BEGIN_SRC cpp 
  >> MyFunctions::add(102.3, -93.4)
  (double) 8.9000000
  >> MyFunctions::add(102.3, -193.4)
  (double) -91.100000
  >>
  >> MyFunctions::saySomething()
  A computer was a skilled mathematician who computed the firing tables
  >>

  >> MyFunctions::math::showTable([](double x){ return x * 3.0 + 4.0;} )
           0         4
           1         7
           2        10
           3        13
    ... ... ... ... 

  // import MyFunctions.math as m
  >> namespace m = MyFunctions::math;
  >> m::showTable([](double x){ return x * 3.0 + 4.0;} )
           0         4
           1         7
           2        10
           3        13
    ... ... ... ... 

  // from MyFunctions.math import *
  >> using namespace MyFunctions::math;

  >> showTable([](double x){ return x * x;}, std::cerr )
           0         0
           1         1
           2         4
           3         9
           4        16
      ... ... ... ...  

  >> showTable(exp, std::cerr )
  ROOT_prompt_34:1:1: error: no matching function for call to 'showTable'
  showTable(exp, std::cerr )
  ^~~~~~~~~

  >> showTable(static_cast<double (*)(double)>(exp), std::cerr)
           0         1
           1   2.71828
           2   7.38906
           3   20.0855
           4   54.5982
           5   148.413
           6   403.429
           7   1096.63
           8   2980.96
           9   8103.08
#+END_SRC

Define a function at some namespace: 

#+BEGIN_SRC cpp 
  int General::GetNumberOfDays(int d1, int d2){
     return d2 - d1;
  }
#+END_SRC

** Data Types 

Numeric Types 

| Type                |   Size |    Size | Description                            | Maximum number of |
|                     | (bits) | (bytes) |                                        |    decimal digits |
|---------------------+--------+---------+----------------------------------------+-------------------|
| *Fixed-width integer* |        |         |                                        |                   |
| int8_t              |      8 |       1 | 8-bits signed int                      |                 2 |
| uint8_t             |     16 |       2 | 8-bits unisgned int (positive)         |                 2 |
| int16_t             |     16 |       2 | 16-bits signed int                     |                 4 |
| uint16_t            |     32 |       4 | 16-bits unsigned int                   |                 4 |
| int32_t             |     32 |       4 | 32-bits signed int                     |                 9 |
| uint32_t            |     32 |       4 | 32-bits unsigned int                   |                 9 |
| int64_t             |     64 |       8 | 64-bits signed int                     |                18 |
| uint64_t            |     64 |       8 | 64-bits unsigned int                   |                18 |
|                     |        |         |                                        |                   |
| *Integers*            |        |         |                                        |                   |
| short               |     16 |       2 | 16-bits signed int                     |                 4 |
| unsigned short      |     16 |       2 | 16-bits unsigned int                   |                 4 |
| int                 |     32 |       4 | 32-bits signed int                     |                 9 |
| unsigned int        |     32 |       4 |                                        |                 9 |
|                     |        |         |                                        |                   |
| long                |     64 |       8 | 64-bits signed int                     |                18 |
| unsigned long       |     64 |       8 | 64-bits unsigned int                   |                19 |
| long long           |     64 |       8 | 64-bits unsigned int (in this machine) |                19 |
|                     |        |         |                                        |                   |

Float Point Numebers 

| Type         | Size (bits) | Size (bytes) | Description                             |
|--------------+-------------+--------------+-----------------------------------------|
| *Float Points* |             |              |                                         |
| float        |          32 |            4 | Single-precision IEEE754 float point    |
| double       |          64 |            8 | Double-precision IEEE754 float point    |
| long float   |         128 |           16 | Quadruple-precision IEEE754 float point |


 *Sample code for showing numeric limits:*

File:
 + [[file:src/numeric-limits.cpp][file:src/numeric-limits.cpp]]
 + Online Compiler: https://rextester.com/BBXAM15894

#+BEGIN_SRC cpp :tangle src/numeric-limits.cpp 
  /*******************************************************************************************
   ,* File: numeric-limits.cpp 
   ,* Brief: Shows the numeric limits for all possible numerical types.  
   ,* Author: Caio Rodrigues
   ,*****************************************************************************************/

  #include <iostream>
  #include <limits>    // Numeric limits 
  #include <iomanip>   // setw, and other IO manipulators 
  #include <string>    // std::string 
  #include <cstdint>   // uint8_t, int8_t, ...
  #include <functional>

  struct RowPrinter{
          int m_left;  // Left alignment 
          int m_right; // Right alignment  
          RowPrinter(int left, int right): m_left(left), m_right(right){
                  // Print bool as 'true' or 'false' instead of 0 or 1.
                  std::cout << std::boolalpha;
          }
	
          template<class A>
          auto printRow(const std::string& label, const A& value) const -> void {
                  std::cout << std::setw(m_left)  << label
                                    << std::setw(m_right) << value << "\n";
          }
  };

  #define SHOW_INTEGER_LIMITS(numtype) showNumericLimits<numtype>(#numtype)
  #define SHOW_FLOAT_LIMITS(numtype)   showFloatPointLimits<numtype>(#numtype)

  template <class T>
  void showNumericLimits(const std::string& name){
          RowPrinter rp{30, 25};	
          std::cout << "Numeric limits for type: " << name << "\n";
          std::cout << std::string(60, '-') << "\n";
          rp.printRow("Type:",                    name);
          rp.printRow("Is integer:",              std::numeric_limits<T>::is_integer);
          rp.printRow("Is signed:",               std::numeric_limits<T>::is_signed);
          rp.printRow("Number of digits 10:",     std::numeric_limits<T>::digits10);
          rp.printRow("Max Number of digits 10:", std::numeric_limits<T>::max_digits10);

          // RTTI - Run-Time Type Information 
          if(typeid(T) == typeid(uint8_t)
             || typeid(T) == typeid(int8_t)
             || typeid(T) == typeid(bool)
             || typeid(T) == typeid(char)
             || typeid(T) == typeid(unsigned char)
                  ){
                  // Min Abs - samllest positive value for float point numbers 
                  rp.printRow("Min Abs:",         static_cast<int>(std::numeric_limits<T>::min()));
                  // Smallest value (can be negative)
                  rp.printRow("Min:",             static_cast<int>(std::numeric_limits<T>::lowest()));
                  // Largest value  
                  rp.printRow("Max:",             static_cast<int>(std::numeric_limits<T>::max()));	
          } else {
                  rp.printRow("Min Abs:",         std::numeric_limits<T>::min());
                  rp.printRow("Min:",             std::numeric_limits<T>::lowest());
                  rp.printRow("Max:",              std::numeric_limits<T>::max());
          }
          rp.printRow("Size in bytes:",       sizeof(T));
          rp.printRow("Size in bits:",        8 * sizeof(T));
          std::cout << "\n";
  }

  template<class T>
  void showFloatPointLimits(const std::string& name){
          RowPrinter rp{30, 25};	
          showNumericLimits<T>(name);
          rp.printRow("Epsilon:",        std::numeric_limits<T>::epsilon());
          rp.printRow("Min exponent:",   std::numeric_limits<T>::min_exponent10);
          rp.printRow("Max exponent:",   std::numeric_limits<T>::max_exponent10);
  }

  int main(){
          SHOW_INTEGER_LIMITS(bool);
          SHOW_INTEGER_LIMITS(char);
          SHOW_INTEGER_LIMITS(unsigned char);
          SHOW_INTEGER_LIMITS(wchar_t);

          // Standard integers in <cstdint>
          SHOW_INTEGER_LIMITS(int8_t);
          SHOW_INTEGER_LIMITS(uint8_t);
          SHOW_INTEGER_LIMITS(int16_t);
          SHOW_INTEGER_LIMITS(uint16_t);
          SHOW_INTEGER_LIMITS(int32_t);
          SHOW_INTEGER_LIMITS(uint32_t);
          SHOW_INTEGER_LIMITS(int64_t);
          SHOW_INTEGER_LIMITS(uint64_t);

          SHOW_INTEGER_LIMITS(short);
          SHOW_INTEGER_LIMITS(unsigned short);
          SHOW_INTEGER_LIMITS(int);
          SHOW_INTEGER_LIMITS(unsigned int);
          SHOW_INTEGER_LIMITS(long);
          SHOW_INTEGER_LIMITS(unsigned long);
          SHOW_INTEGER_LIMITS(long long);
          SHOW_INTEGER_LIMITS(unsigned long long);
	
          SHOW_FLOAT_LIMITS(float);
          SHOW_FLOAT_LIMITS(double);
          SHOW_FLOAT_LIMITS(long double);
	
      return 0;
  }

#+END_SRC

Output: 

#+BEGIN_SRC text 
   $ clang++ numeric-limits.cpp -o numeric-limits.bin -g -std=c++11 -Wall -Wextra && ./numeric-limits.bin
   Numeric limits for type: bool
   ------------------------------------------------------------
                            Type:                     bool
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        0
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:                        1
                   Size in bytes:                        1
                    Size in bits:                        8

   Numeric limits for type: char
   ------------------------------------------------------------
                            Type:                     char
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        2
         Max Number of digits 10:                        0
                         Min Abs:                     -128
                             Min:                     -128
                             Max:                      127
                   Size in bytes:                        1
                    Size in bits:                        8

   Numeric limits for type: unsigned char
   ------------------------------------------------------------
                            Type:            unsigned char
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        2
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:                      255
                   Size in bytes:                        1
                    Size in bits:                        8

   Numeric limits for type: wchar_t
   ------------------------------------------------------------
                            Type:                  wchar_t
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        9
         Max Number of digits 10:                        0
                         Min Abs:              -2147483648
                             Min:              -2147483648
                             Max:               2147483647
                   Size in bytes:                        4
                    Size in bits:                       32

   Numeric limits for type: int8_t
   ------------------------------------------------------------
                            Type:                   int8_t
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        2
         Max Number of digits 10:                        0
                         Min Abs:                     -128
                             Min:                     -128
                             Max:                      127
                   Size in bytes:                        1
                    Size in bits:                        8

   Numeric limits for type: uint8_t
   ------------------------------------------------------------
                            Type:                  uint8_t
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        2
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:                      255
                   Size in bytes:                        1
                    Size in bits:                        8

   Numeric limits for type: int16_t
   ------------------------------------------------------------
                            Type:                  int16_t
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        4
         Max Number of digits 10:                        0
                         Min Abs:                   -32768
                             Min:                   -32768
                             Max:                    32767
                   Size in bytes:                        2
                    Size in bits:                       16

   Numeric limits for type: uint16_t
   ------------------------------------------------------------
                            Type:                 uint16_t
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        4
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:                    65535
                   Size in bytes:                        2
                    Size in bits:                       16

   Numeric limits for type: int32_t
   ------------------------------------------------------------
                            Type:                  int32_t
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        9
         Max Number of digits 10:                        0
                         Min Abs:              -2147483648
                             Min:              -2147483648
                             Max:               2147483647
                   Size in bytes:                        4
                    Size in bits:                       32

   Numeric limits for type: uint32_t
   ------------------------------------------------------------
                            Type:                 uint32_t
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        9
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:               4294967295
                   Size in bytes:                        4
                    Size in bits:                       32

   Numeric limits for type: int64_t
   ------------------------------------------------------------
                            Type:                  int64_t
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                       18
         Max Number of digits 10:                        0
                         Min Abs:     -9223372036854775808
                             Min:     -9223372036854775808
                             Max:      9223372036854775807
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: uint64_t
   ------------------------------------------------------------
                            Type:                 uint64_t
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                       19
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:     18446744073709551615
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: short
   ------------------------------------------------------------
                            Type:                    short
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        4
         Max Number of digits 10:                        0
                         Min Abs:                   -32768
                             Min:                   -32768
                             Max:                    32767
                   Size in bytes:                        2
                    Size in bits:                       16

   Numeric limits for type: unsigned short
   ------------------------------------------------------------
                            Type:           unsigned short
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        4
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:                    65535
                   Size in bytes:                        2
                    Size in bits:                       16

   Numeric limits for type: int
   ------------------------------------------------------------
                            Type:                      int
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                        9
         Max Number of digits 10:                        0
                         Min Abs:              -2147483648
                             Min:              -2147483648
                             Max:               2147483647
                   Size in bytes:                        4
                    Size in bits:                       32

   Numeric limits for type: unsigned int
   ------------------------------------------------------------
                            Type:             unsigned int
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                        9
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:               4294967295
                   Size in bytes:                        4
                    Size in bits:                       32

   Numeric limits for type: long
   ------------------------------------------------------------
                            Type:                     long
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                       18
         Max Number of digits 10:                        0
                         Min Abs:     -9223372036854775808
                             Min:     -9223372036854775808
                             Max:      9223372036854775807
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: unsigned long
   ------------------------------------------------------------
                            Type:            unsigned long
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                       19
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:     18446744073709551615
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: long long
   ------------------------------------------------------------
                            Type:                long long
                      Is integer:                     true
                       Is signed:                     true
             Number of digits 10:                       18
         Max Number of digits 10:                        0
                         Min Abs:     -9223372036854775808
                             Min:     -9223372036854775808
                             Max:      9223372036854775807
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: unsigned long long
   ------------------------------------------------------------
                            Type:       unsigned long long
                      Is integer:                     true
                       Is signed:                    false
             Number of digits 10:                       19
         Max Number of digits 10:                        0
                         Min Abs:                        0
                             Min:                        0
                             Max:     18446744073709551615
                   Size in bytes:                        8
                    Size in bits:                       64

   Numeric limits for type: float
   ------------------------------------------------------------
                            Type:                    float
                      Is integer:                    false
                       Is signed:                     true
             Number of digits 10:                        6
         Max Number of digits 10:                        9
                         Min Abs:              1.17549e-38
                             Min:             -3.40282e+38
                             Max:              3.40282e+38
                   Size in bytes:                        4
                    Size in bits:                       32

                         Epsilon:              1.19209e-07
                    Min exponent:                      -37
                    Max exponent:                       38
   Numeric limits for type: double
   ------------------------------------------------------------
                            Type:                   double
                      Is integer:                    false
                       Is signed:                     true
             Number of digits 10:                       15
         Max Number of digits 10:                       17
                         Min Abs:             2.22507e-308
                             Min:            -1.79769e+308
                             Max:             1.79769e+308
                   Size in bytes:                        8
                    Size in bits:                       64

                         Epsilon:              2.22045e-16
                    Min exponent:                     -307
                    Max exponent:                      308
   Numeric limits for type: long double
   ------------------------------------------------------------
                            Type:              long double
                      Is integer:                    false
                       Is signed:                     true
             Number of digits 10:                       18
         Max Number of digits 10:                       21
                         Min Abs:             3.3621e-4932
                             Min:           -1.18973e+4932
                             Max:            1.18973e+4932
                   Size in bytes:                       16
                    Size in bits:                      128

                         Epsilon:               1.0842e-19
                    Min exponent:                    -4931
                    Max exponent:                     4932
#+END_SRC

** Numeric Literals 

| Literal            | Suffix   | Type          | Description                                                                    | Sizeof Bytes |
|--------------------+----------+---------------+--------------------------------------------------------------------------------+--------------|
| 2001               | -        | int           | signed integer                                                                 |            4 |
| 20u                | u or U   | unsingned int |                                                                                |            4 |
| 0xFFu              | u or U   | unsigned int  | unsingned int literal in hexadecimal (0xff = 255)                              |            4 |
|                    |          |               |                                                                                |              |
| 100l or 100L       | l or L   | long          |                                                                                |            8 |
| 100ul or 100UL     | ul or UL | unsigned long |                                                                                |            8 |
| 0xFAul or 0xFAUL   |          | unsigned long | unsigned long literal in hexadecimal format (0xfa = 250)                       |            8 |
|                    |          |               |                                                                                |              |
| 100.23f or 100.23F | f or F   | float         | 32 bits IEEE754 Float Point number mostly used in games and computer graphics. |            8 |
| 20.12   (default)  |          | double        | 64 bits IEEE754 Float Point number commonly used in scientific computing.      |            4 |
|                    |          |               |                                                                                |              |
|                    |          |               |                                                                                |              |

** Types of Parameter Passing 

| Parameter Passing | Alternative | Parameter t passed by                                    |
|-------------------+-------------+----------------------------------------------------------|
| T t               |             | by value                                                 |
| T* t              | T *t        | pased by pointer                                         |
| const T* t        | const T* t  |                                                          |
| T& t              | T &t        | by reference or *L-value reference*                        |
| const T& t        | const T &t  | by const reference or const *L-value reference.*           |
| const T&& t       | const T &&t | by r-value reference                                     |
| T t []            | T* t        | by pointer, this notation is used for C-array parameters |
|-------------------+-------------+----------------------------------------------------------|

Notes: 

 + Function here means both member function (class methods) or free
   functions (aka ordinary functions).

 + _Parameters passed by value cannot be modified within the function_
   as they are _copied_. It happens for all C++ types, including
   instances of classes what is different from most OO languages like
   Java, C#, Python and etc.

 + When an object is passed by value, its _copy constructor_ is invoked,
   as a result a copy is created.

 + Prefere passing large objects such large matrices or arrays by
   _reference or const_ reference when the function is not supposed to
   modify the parameter in order to avoid memory overhead due to
   copy.

 + I is better to pass objects instantiated on the heap (dynamic
   memory) with _new_ operator using *smart pointers* (~unique_ptr~,
   ~shared_ptr~) in order to avoid memory leaks.

** C++ Standard Library Reference

*C++ Standards* ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp1_Basics.html][Source]])

 - *C++ is standardized as ISO/IEC 14882.* Currently, there are two
   versions:

   - _C++98 (ISO/IEC 14882:1998)_ 1st standard version of C++.
   - _C++03 (ISO/IEC 14882:2003)_ minor "bug-fix" to C++98 with no change
     to the language. Commonly refer to as C++98/C++03 or First C++
     standard.
 - _C++11 (ISO/IEC 14882:2011)_ 2nd standard version of C++.


*C++ Libraries* 

 + STL (Standard Template Library) Containers, Iterators and Function objects.
   + Sequence
     + vector  -> <vector>
     + list    -> <list>
     + dequee  -> <deque>
     + array   -> <array>

   + Associative Sequence
     + set
     + map (Hashmap or hash table).
     + multiset
     + multimap
     + ~unordered_set~
     + ~unordered_map~

 + C++ Libraries ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][Source]])
   + <ios>, <iostream>, <istream>, <ostream>, <fstream>, <sstream>
   + <iomanip> 
   + <string>  - C++ Strings.
   + <regex>
   + <random>
   + <limits>
   + <stdexcept>, <exception>
   + <complex>, <tuple>, <valarray>
   + <locale>
   + <typeinfo>
   + <chrono>

   + Other: <codecvt>, <new>, <ratio>, <system_error>, <type_traits>

 + Useful non-standard C++ Libraries 
   + Boost C++ libaries
   + QT toolkit / GUI - Toolkit

 + C Compatibility
   + Standard ANSI C libaries ported to C++ are prefixed with "c"
     without ".h". For instance, "#include <math.h>" form C becomes
     "#include <cmath>" in C++.

   + C Libraries. ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][Source]])
     + <cmath> - (math.h) - Standard mathematical functions such as
       sin, cos, sqrt and so on.
     + <cctypes> - (ctypes.h) - Checking character types (isalpha,
       isdigit, isalnum, isspace, isupper, islower, isblank, iscntrl,
       isgraph, isprint, ispunct, isxdigit) and character conversion
       (toupper, tolower).
     + <climits>, <cfloat>: Size and limit of integer types (INT_MAX,
       INT_MIN, UINT_MAX, CHAR_BIT; and SHRT_XXX for short, LONG_XXX
       for long, LLONG_XXX for long long, CHAR_XXX for char) and
       floating-point types (DBL_MIN, DBL_MAX, DBL_DIG, DBL_MIN_EXP,
       DBL_MAX_EXP; and FLT_XXX for float, LDBL_XXX for long double).

     + <ctime>: time, difftime, clock, gmttime, localtime, and etc.
     + <cstdio>: C's IO operations (scanf, printf, fscanf, fprintf, fopen, fclose, etc)
     + <cassert>, <cerrno>, <csignal>: Diagnostics and error
     + <clocale>: localizaton
     + <cstdbool>, <cstdint>, <cstddef>, <cstdarg>
     + <cstdbool>, <cstdint>, <cstddef>, <cstdarg>
** Operators and operator overload 
*** Summary Table 

| Description                                             | Operator               | Class operator overload declaration  |
|---------------------------------------------------------+------------------------+--------------------------------------|
| Equal to                                                | a == b                 |                                      |
| Logical not                                             | !a, !false, !true      |                                      |
| Logical and                                             | a && b                 |                                      |
| Logical or                                              | a \vert\vert b         |                                      |
|                                                         |                        |                                      |
| Pre increment (prefix)                                  | ++i                    |                                      |
| Post increment                                          | i++                    |                                      |
| Pre decrement                                           | ++i                    |                                      |
| Post increment                                          | i--                    |                                      |
|                                                         |                        |                                      |
| Addition assignment        ~(+=)~                         | a += b ; a <- a + b    |                                      |
| Subtraction assignment     ~(-=)~                         | a -= b ; a <- a - b    |                                      |
| Multiplication assignment  ~(*=)~                         | a *= b ; a <- a * b    |                                      |
| Division assignment       ~(/=)~                          | a /= b ; a <- a / b    |                                      |
|                                                         |                        |                                      |
| Subscript, array index                                  | a[b]                   | ~A C::operator [](S index)~            |
| Indirection - derreference                              | ~*a~                     | ~A C::operator *()~                     |
| Address or reference                                    | &a                     | ~A* C::operator &()~                    |
| Structure dereference                                   | a->memberFunction(x)   |                                      |
| Structure reference (.)                                 | a.memberFunction(x)    | - N/A                                |
|                                                         |                        |                                      |
| Function call (function-object declaration)             | A(p0, p1, p2)          | R C::operator()(P0 p0, P1 p1, P2 p2) |
| Ternary conditional - similar to if x = (if cond 10 20) | a ? b : c              | - N/A                                |
| Scope resolution operator                               | Class::staticMethod(x) | - N/A                                |
| Sizeof - returns size of type at compile-time           | sizeof(type)           | - N/A                                |
|                                                         |                        |                                      |
|                                                         |                        |                                      |
|                                                         |                        |                                      |

For more details check out: 

 - [[https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B][Operators in C and C++ - Wikipedia]]
*** Operator Overload Snippet 1 

#+BEGIN_SRC cpp 
  class SomeClass{
  private:
      // ---->> Private data here <------
  public:
      SomeClass(){}
      SomeClass(double x, double y){
          m_x = x;
          m_y = y;
      }
      // Copy assignment operator 
      SomeClass& operator=(const SomeClass& other){
          //  ...  ......
      }
      // Equality operator - check whether current object is equal to
      // the other.
      //-----------------------------------------------
      bool operator==(const SomeClass& p){
          return this->x == p.x && this->y == p.y;
      }
      // Not equal operator - checks whether current object is not equal to
      // the other.
      //-----------------------------------------------
      bool operator!=(const SomeClass& p){
          return this->x != p.x || this->y != p.y;
      }
      // Not logical operator (!) Exclamation mark.
      // if(!obj){ ... }
      //-----------------------------------------------
      bool operator! (){
          return this->m_data != nullptr;
      }
      // Operator ++obj
      //-----------------------------------------------
      SomeClass& operator++(){
          this->m_counter += 1;
          return *this;
      }

      // Operator (+)
      // SomeClass a, b;
      // SomeClass c = a + b;
      SomeClass operator+(SomeClass other){
          SomeClass res;
          res.x = m_x + other.x;
          res.y = m_y + other.y;
          return res;
      }
      // Operator (+)
      SomeClass operator+(double x){
          SomeClass res;
          res.x = m_x + x
          res.y = m_y + x
          return res;
      }
      // Operator (*)
      SomeClass operator*(double x){
          SomeClass res;
          res.x = res.x * x;
          res.y = res.y * x;
          return res;
      }

      // Operator (+=)
      // SomeClass cls;
      // cls += 10.0;
      SomeClass& operator +=(double x){
          m_x += x;
          m_y += y;
          return *this;
      }
      // Operator index -> obj[2]
      // SomeClass cls;
      // double z = cls[2];
      //-----------------------------------------------
      double operator[](int idx){
          return this->array[idx];
      }
      // Function application operator
      // SomeClass obj;
      // double x = obj();
      //-----------------------------------------------
      double operator()(){
          return m_counter * 10;
      }
      // Function application operator
      // SomeClass obj;
      // double x = obj(3.4, "hello world");
      //-----------------------------------------------
      double operator()(double x, std::string msg){
          std::cout << "x = " << x << " msg  = " << msg;
          return 3.5 * x;                                       
      }
      // Operator string insertion, allows printing the current object 
      // SomeClass obj;
      // std::cout << obj << std::enl;
      //-----------------------------------------------
      friend std::ostream& operator<<(std::ostream &os, const SomeClass& cls){
          // Print object internal data structure 
          os << cls.m_x << cls.m_y  ;
          return os;
      }
  };
#+END_SRC
*** Operator Overload Snippet 2 

File: SomeClass.hpp - Header file. 

#+BEGIN_SRC cpp 
  class SomeClass{
  private:
      // ---->> Private data here <------
  public:
      SomeClass(){}
      SomeClass(double x, double y);
      bool operator==(const SomeClass& p);
      bool operator!=(const SomeClass& p);
      bool operator! ();
      SomeClass& operator++();
      SomeClass operator+(SomeClass other);
      SomeClass operator+(double x);
      SomeClass operator*(double x);
      SomeClass& operator +=(double x);
      double operator[](int idx);
      double operator()();
      double operator()(double x, std::string msg);
      friend std::ostream& operator<<(std::ostream &os, const SomeClass& cls);
  };
#+END_SRC

File: SomeClass.cpp - implementation

#+BEGIN_SRC cpp 
  SomeClass::SomeClass(){}

  SomeClass::SomeClass(double x, double y){
          m_x = x;
          m_y = y;
      }
      
  // Equality operator - check whether current object is equal to
  // the other.
  //-----------------------------------------------
  bool SomeClass::operator==(const SomeClass& p){
      return this->x == p.x && this->y == p.y;
  }

  // Not equal operator - checks whether current object is not equal to
  // the other.
  //-----------------------------------------------
  bool SomeClass::operator!=(const SomeClass& p){
      return this->x != p.x || this->y != p.y;
  }
      
  // Not logical operator (!) Exclamation mark.
  // if(!obj){ ... }
  //-----------------------------------------------
  bool SomeClass::operator! (){
      return this->m_data != nullptr;
  }
      
  // Operator ++obj
  //-----------------------------------------------
  SomeClass& SomeClass::operator++(){
      this->m_counter += 1;
      return *this;
  }

  // Operator (+)
  // SomeClass a, b;
  // SomeClass c = a + b;
  SomeClass SomeClass::operator+(SomeClass other){
      SomeClass res;
      res.x = m_x + other.x;
          res.y = m_y + other.y;
          return res;
  }
  // Operator (+)
  SomeClass SomeClass::operator+(double x){
      SomeClass res;
      res.x = m_x + x;
      res.y = m_y + x;
      return res;
  }
  // Operator (*)
  SomeClass SomeClass::operator*(double x){
      SomeClass res;
      res.x = res.x * x;
      res.y = res.y * x;
          return res;
  }

  // Operator (+=)
  // SomeClass cls;
  // cls += 10.0;
  SomeClass& SomeClass::operator +=(double x){
      m_x += x;
      m_y += y;
      return *this;
  }
      
      
  // Operator index -> obj[2]
  // SomeClass cls;
  // double z = cls[2];
  //-----------------------------------------------
  double SomeClass::operator[](int idx){
      return this->array[idx];
  }
      
  // Function application operator
  // SomeClass obj;
  // double x = obj();
  //-----------------------------------------------
  double SomeClass::operator()(){
      return m_counter * 10;
  }

  // Function application operator
  // SomeClass obj;
  // double x = obj(3.4, "hello world");
  //-----------------------------------------------
  double SomeClass::operator()(double x, std::string msg){
      std::cout << "x = " << x << " msg  = " << msg;
      return 3.5 * x;                                       
  }

  // Operator string insertion, allows printing the current object 
  // SomeClass obj;
  // std::cout << obj << std::enl;
  //-----------------------------------------------
  friend std::ostream& SomeClass::operator<<(std::ostream &os, const SomeClass& cls){
      // Print object internal data structure 
      os << cls.m_x << cls.m_y  ;
      return os;
  }

#+END_SRC
*** Array index operator overload 

This example how to overload the operator array index to allow
returning a value or performing an assignment operation. 

File: *array-index-overload.cpp* 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <vector>

  class Container{
  private:
          std::vector<double> xs =  { 1.0, 2.0, 4.0, 6.233, 2.443};
  public:
      Container(){}
      double& operator[](int index){
          return xs[index];
      }
  };

  int main(){
      Container t;
      std::cout << "t[0] = " << t[0] << std::endl;
      std::cout << "t[1] = " << t[1] << std::endl;
      std::cout << "t[2] = " << t[2] << std::endl;
      std::cout << "\n--------\n";
      t[0] = 3.5;
      std::cout << "t[0] = " << t[0] << std::endl;
      t[2] = -15.684;
      std::cout << "t[2] = " << t[2] << std::endl;    
      return 0;
  }
#+END_SRC

Running: 

#+BEGIN_SRC sh 
$ cl.exe array-index-overload.cpp /EHsc /Zi /nologo /Fe:out.exe && out.exe
t[0] = 1
t[1] = 2
t[2] = 4

--------
t[0] = 3.5
t[2] = -15.684

#+END_SRC
*** Conversion Operators and user-defined type conversion 

Conversion operators allow to convert a class to any type implicitly
or explicitly with type-cast operator ~static_cast<T>~. 

Example: 
 
 - ROOT Script File: _conversion-operator.cpp_

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>

  #define LOGFUNCTION(type)  std::cerr << "Convert to: [" << type << "] => Called: line " \
          << __LINE__ << "; fun = " << __PRETTY_FUNCTION__ << "\n"

  // Or: struct Dummy { 
  class Dummy{
  public:
          bool flag = false;

          // Type conversion operator which converts an instance
          // of dummy to double.	
          explicit operator double() {
                  LOGFUNCTION("double");
                  return 10.232;
          }	
          #if 1
          // Implicit conversion to int is not allowed, it is only possible to convert
          // this object explicitly with static_cast. 	
          explicit operator int() const {
                  LOGFUNCTION("int");
                  return 209;
          }	
          explicit operator long() const {
                  LOGFUNCTION("long");
                  return 100L;
          }
          operator std::string() const {
                  LOGFUNCTION("std::string");
                  return "C++ string std::string";
          }
          explicit operator const char*() const {
                  LOGFUNCTION("const char*");
                  return "C string";
          }		
          operator bool() const {
                  LOGFUNCTION("bool");
                  std::cerr << " Called " << __FUNCTION__ << "\n";
                  return flag;
          }
          #endif 
  };
#+END_SRC

Testing: 

 - C-style casting

#+BEGIN_SRC cpp 
  >> .L conversion-operator.cpp 
  >> Dummy d;  

  >> (double) d
  Convert to: [double] => Called: line 15; fun = double Dummy::operator double()
  (double) 10.232000

  >> (int) d
  Convert to: [int] => Called: line 22; fun = int Dummy::operator int() const
  (int) 209

  >> (long) d
  Convert to: [long] => Called: line 26; fun = long Dummy::operator long() const
  (long) 100

  >> (std::string) d
  Convert to: [std::string] => Called: line 30; fun = std::string Dummy::operator basic_string() const
  (std::string) "C++ string std::string"
  >> 
#+END_SRC

 + C++ style casting:

#+BEGIN_SRC cpp 

  >> static_cast<int>(d)
  Convert to: [int] => Called: line 22; fun = int Dummy::operator int() const
  (int) 209
  >> 
  >> static_cast<long>(d)
  Convert to: [long] => Called: line 26; fun = long Dummy::operator long() const
  (long) 100
  >> 
  >> static_cast<double>(d)
  Convert to: [double] => Called: line 15; fun = double Dummy::operator double()
  (double) 10.232000

  >> static_cast<std::string>(d)
  Convert to: [std::string] => Called: line 30; fun = std::string Dummy::operator basic_string() const
  (std::string) "C++ string std::string"
  >> 

  >> static_cast<bool>(d)
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  (bool) false
  >> 

  >> d.flag = true
  (bool) true

  >> static_cast<bool>(d)
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  (bool) true
  >> 

#+END_SRC
 
 + Simulating implicit conversion:
   + Note: implicitly assignment type conversion is not allowed for
     operators annotated with explicit. So it is not possible to
     perform the assignment: const char* s = d 

#+BEGIN_SRC cpp 
  // Implicit conversion 
  >> std::string message = d
  Convert to: [std::string] => Called: line 30; fun = std::string Dummy::operator basic_string() const
  (std::string &) "C++ string std::string"
  >> 
  >> std::cout << "text = " << message << "\n";
  text = C++ string std::string
  >> 
  >> 

  >> const char* s = d
  ROOT_prompt_16:1:13: error: no viable conversion from 'Dummy' to 'const char *'
  const char* s = d
              ^   ~
  // Conversion operators marked as explicit can only casted using C-style cast or 
  // or static_cast<T>
  >> const char* s = static_cast<const char*>(d)
  Convert to: [const char*] => Called: line 34; fun = const char *Dummy::operator const char *() const
  (const char *) "C string"

  >> d ? "true" : "false";
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool

  >> d ? "true" : "false"
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  (const char *) "true"

  >> d.flag = false;

  >> d ? "true" : "false"
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  (const char *) "false"
  >> 
#+END_SRC

 + Bool type conversion in conditional statements.

#+BEGIN_SRC cpp 
  >> d.flag = true;

  >> if(d) { std::cout << "Flag is true OK" << std::endl; }
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  Flag is true OK

  >> d.flag = false;

  >> if(!d) { std::cout << "Flag is false OK" << std::endl; }
  Convert to: [bool] => Called: line 38; fun = bool Dummy::operator bool() const
   Called operator bool
  Flag is false OK
  >> 
  >> 
#+END_SRC


 - Note: The macro ~__PRETTY_FUNCTION__~ is only available in GCC or
   CLANG, in MSVC use ~__FUNCSIG__~


Further Reading:  
 + [[https://msdn.microsoft.com/en-us/library/ts48df3y.aspx][Cast Operator: ()]]
 + [[https://docs.microsoft.com/en-us/cpp/cpp/user-defined-type-conversions-cpp?view=vs-2017][User-Defined Type Conversions (C++) | Microsoft Docs]]
 + [[https://stackoverflow.com/questions/1307876/how-do-conversion-operators-work-in-c][How do conversion operators work in C++? - Stack Overflow]]
 + Explicit Conversion Operators -
   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1592.pdf>
** Compiler flags and invocation 
*** Overview

 *Search Path and Library Linking Flags* 

 * -l[linalg]
   + => Links to shared library or shared object - Specifically, it
     links to linalg.dll on Windows, liblinalg.so (on Unix-like oses like
     Linux, BSD, AIX, ...) or linalg.dylib on MacOSX.
 * -L[/path/to/shared-libraries]
   + => Add search path to shared libraries, directory containing
     *.so, *.dll or *.dlyb files such as libLinearAlgebra.so depending
     on the current operating system.
 * -I[/path/to/header-files]
   * Add search path to header files (.h) or (.hpp).
 * -D[FLAG] or -D[FLAG]=VALUE
   * Pass preprocessor flag #if FLAG ... 


 *GCC and Clang* Most common compiler flags: 

 + std - Specify the C++ version 
   + -std=c++11
   + -std=c++14
   + -std=c++20
   + -std=gnu++
 + Verbosity - [W]arning 
   + -Wall
   + -Wextra
   + -pendantic
   + -Wconversion
   + -Wcast-align
   + -Wunnused
   + -Wshadow
   + -Wold-style-cast
   + -Wpointer-arith -Wcast-qual -Wmissing-prototypes -Wno-missing-braces 
 + Output file: -o <outputfile>
   + g++ file.cpp -o file.bin
 + Common library flags
   + -lm
   + -lpthread  - Compile against Posix threads shared library
 + Include Path - Directories containing headers files.
   + -I/path/to/include1 -I/path/to/include2 ... 
 + Compilation flags -D<flag name>
   + ~-DMYSOFTWARE_COMPILATION_VARIABLE~ -> Enable flag ~MYSOFTWARE_COMPILATION_VARIABLE~
   + ~-DDO_SOMETHING=1~
   + ~-DDISABLE_DEPRECATED_FUNCTIONS=0~
 + Optmization - [[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html][docs]]
   + -O2 
   + -O3
   + -OFast
     + Enables higher level of optmization than (-O3). It enables lots
       of flags as can be seen [[https://stackoverflow.com/questions/3005564/gcc-options-for-fastest-code][src]] (-ffloat-store, -ffsast-math,
       -ffinite-math-only, -O3 ...)
   + -finline-functions
   + -m64
   + -funroll-loops
   + -fvectorize
   + -fprofile-generate
 + Misc
   + -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4

 *Files Generated by the Compiler* 
 + Object Files
   + *.o -> Generated on *NIX - Linux, MacOSX ... by GCC or Clang
   + *.obj -> Windows
 + Binary Native Executable - Object Code
   + *NIX: Linux, MacOSX, FreeBSD -> Without extension.
   + Windows: *.exe
   + *.hex -> Extension of many compiled firmwares generated by
     embedded systems compilers such as proprietary compilers for
     Microcontrollers.  
 + Shared Objects - Shared Libraries
   + *.dll -> Called dynamic linked libraries on Windows -> libplot.dll
   + *.so  -> Called shared Object on Linux -> libplot.so
   + *.dylib -> Extension used on MacOSX.
 + Static Library
   + *.a - extension 

Review See: 

 + [[https://gist.github.com/gubatron/32f82053596c24b6bec6][Things to remember when compiling and linking C/C++ programs · GitHub]]

 + [[https://msdn.microsoft.com/en-us/library/y0zzbyt4.aspx][Linker Options]]

C++ Compiler Online: 

 + http://rextester.com/FCCXK65881

*** Compiler invocation examples
**** Example - Build executable with unified compilation

Compile file1.cpp, file.cpp, file2.cpp into the executable app.bin 

 - Option 1: Compile and link once in a single command. The
   disadvantage of this way is the slower compile time rather than
   separate compilation and linking. 

#+BEGIN_SRC sh 
  # CC=gcc 
  CC=clang++

  $ clang++ file1.cpp file2.cpp file3.cpp \
    -std=c++14  -o app.bin -O3 -g \
    -Wall -Wextra -pendantic \
    -lpthread -lblas -lboost_system -lboost_filesystem \
    -I./include/path1/with/headers1 -I./include2 -L./path/lib1 -L./pathLib2
#+END_SRC
 
Explanation: 

 + -std=c++14 -> Set the C++ version. This flag can be C++11, C++14,
   C++17, C++20 ... 
 + -o app.bin -> Set the output native executable file ot app.bin
 + -I./include/path1/with/headers
   + Directory with header files
 + -g Produce executable with debug symbols
 + -Wall -Wextra -Wshadow 
   + Warning flags - enable more verbosity which helps to catch bugs
     earlier.
 + -O3 - Use optmization of level 3 - the disadvantage of using
   optmization is the slower compile time. So this flag should only be
   enabled on production builds.
 + -lpthread -lblas ~-lboost_system~ ~-lboost_filesystem~
   + Link against shared libraries (extensions: *.so - Unix, *.dylib
     or *.dll on Windows) pthread, blas, ~boost_system~ ...

**** Compile source with static Linking

#+BEGIN_SRC sh 
 $ gcc -static example.o -lgsl -lgslcblas -lm
#+END_SRC
**** Release / Debug building 

Compiler: 

 + GCC and CLANG
   + Debug: No optmized, but faster building time.
     * -OO -g  
   + Release:
     * -O3 -s -DNDEBUG [-march=native] [-mtune=native]
     * -O2 -s -DNDEBGU
 + MSVC:
   + Debug:
     * /MDd /Zi /Ob0 /Od /RTC1
   + Release:
     * /MD /O1 /Ob1 /DNDEBUG
Note: 
 - For GCC and Clang
   + -OO means no optmization
   + -g - adds debugging symbols to executable.
   + -DNDEBUG - disable assertions


References: 

 + [[https://stackoverflow.com/questions/1534912/how-to-build-in-release-mode-with-optimizations-in-gcc][c++ - How to build in release mode with optimizations in GCC? - Stack Overflow]]

 + 
** Common Acronyms and abbreviations 

|----------------------+--------------------------------------------------------------------------|
| Acronym or name      | Description                                                              |
|----------------------+--------------------------------------------------------------------------|
| IEEE                 | Institute of Electrical and Electronics Engineers                        |
| ISO                  | International Organization for Standardization                           |
|                      |                                                                          |
| TMP                  | Template Meta Programming                                                |
| GP                   | Generic Programming                                                      |
| CTOR                 | Constructor                                                              |
| DTOR                 | Destructor                                                               |
| RAAI                 | Resource Acquisition Is Initialization                                   |
| SFINAE               | Substitution Is Not An Error                                             |
| RVO                  | Return Value Optmization                                                 |
| EP                   | Expression Template                                                      |
| CRTP                 | Curious Recurring Template Pattern                                       |
| PIMPL                | Pointer to Implementation                                                |
| RTTI                 | Runtime Type Identification                                              |
| STL                  | Standard Template Library                                                |
| MSVC                 | Microsoft Visual C++ Compiler                                            |
| VC++                 | Microsoft Visual C++ Compiler                                            |
|                      |                                                                          |
| POSIX                | Portable Operating System Interface (POSIX)                              |
|                      |                                                                          |
| PE, PE32 and PE64    | Portable Executable format - Windows object code format.                 |
| ELF, ELF32 and ELF64 | Executable Linkable Format - [U]-nix object code format.                 |
|                      |                                                                          |
| DLL                  | Dynamic Linked Library - Windows shared library format.                  |
| SO                   | Shared Object - [U]-nix, Linux, BSD, AIX, Solaris shared library format. |
| DSO                  | Dynamic Shared Object, [U]-nix shared library format.                    |
|                      |                                                                          |
|----------------------+--------------------------------------------------------------------------|
