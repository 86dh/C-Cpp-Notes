#+INCLUDE: theme/style.org 
#+TITLE: Embedded Scripting Languages
#+DESCRIPTION: cpp/c++ embedded scripting languages survey 
#+STARTUP: content 

* Embedded Scripting Languages 
** Overview 

  *Reasonable Features of Embedded Scripting Languages*

This section lsits some reasonable features that a language designed
to be embedded should have:

   + _Ligthweight_ -  Small footprint, small size and memory requirements. 

   + _Scripting Engine as a library_:
     + Must be available as C or C++ library which exposes the
       interpreter API allowing the client code to evaluate scripting
       code from strings or files and also to retrieve objects from the
       virtual machine memory.

   + _Sandboxing or capability limitations_
     + A reasonable requirement for an embedded scripting language is
       limiting the capabilities and APIs which can be used possibly
       allowing the execution of non-trusted scripts. Example: the
       Javascript engines of most web browsers do not allow the script
       to interact with file systems or operating system APIs.

   + _Permissive License for static linking_ 

   + _Use Cases_
     + DSL - Domain Specific Languages 
     + Game Engines 
     + Configuration files => Data Description language. 
     + User content
     + Allow application runtime changes without recompilation.
     + User extension without modification of source code. 

 *Examples of embedded scripting languages usage and use-cases*

     * TCL - Tool Command Language => Used by many EDA - Electronic
       Design Automation Sofware in electronic engineering.

     * JavaScript => Used in Web Browsers, which are written mostly in
       C++, for controlling user interaction, animation and etc. 

     * TinyScheme => Used by GNU GIMP drawing application ans Apple's
       MacOSX sandbox configuration. 

     * Lua language => Used by many game engines and also by
       applications such as: Nginx web server; Linux Conky; Geany
       Editor; NMap editor and so on.

     * Squirrel Language => Used in game engines

     * Python
       + => Python is used as embedded scripting language by GDB - GNU
         Debugger ; WinDBG  - Windows Debugger; IDA - Debugger for
         Reverse Engineering.
       + Disadvantages: Python has a large footprint; it was not
         designed as an embedded scripting language and it is not
         possible to forbid the interpreter from calling file system
         and process creation APIs.

     * AutoLisp [proprietary] => Lisp-like language used in Autocad.

     * SQL (Structured Query Language) => Many databases are
       implemented in C or C++ uses SQL as scripting language and
       domain specific language (DSL) for querying and storing
       data. Example: SQLite, Postgres SQL, ...

     * Emacs Lisp => Emacs core, including the LISP
       engine/interpreter, is written in C and other parts are
       written in Emacs Lisp. This lisp dialect allows extending Emacs
       at with custom extensions (plugins) and also modifying the
       application behavior at runtime.

     * VBA - Visual Basic for Application [proprietary] => Used in
       Microsft Office Suite, specially in Microsft Excel.

 *Considerations for choosing embedded scripting languages*

  * Small footprint and small overhead

  * Stability of C or C++ API 

  * C++ API bindings

  * Permissive license for static linking or option of dual license
    for static linking. 

  * Documentation and of C or C++ binding APIs, examples about binding
    code

  * Garbage collector implementation 

  * Heavy duty computations with significant overhead should be
    performed on the C++-side, specially loops.

  * JIT - Just-In-Time compiler => can increase the performance by
    translating bytecodes into machine code.
    + Example: Lua JIT, Javascript V8 engine used by Chrome browser.

  * Features for running untrusted scripts or configuration: 

    * Ability for restricting capabilities such as creating process,
      accessing the file system and so on.

    * Non-turing complete => better for configuration 

  * Familiarity of the targe audience

    * Lua is pervasive in Games

    * TCL is pervasive on Electronic Design Automation Software 

    * Javascript is widely used on the Web, NodeJS and also as
      embedded scripting language of web browsers. 

 *Further Reading* 
 
  + [[https://accu.org/index.php/journals/351][ACCU - Embedded Scripting Languages]]

  + [[https://github.com/dbohdan/embedded-scripting-languages][GitHub - dbohdan/embedded-scripting-languages: A list of embedded scripting languages]]

  + [[https://articles.emptycrate.com/2016/03/26/so-you-want-to-embed-a-scripting-language.html][EmptyCrate.com: So You Want to Embed A Scripting Language in Your Application]]

  + [[https://softwareengineering.stackexchange.com/questions/403911/what-makes-a-scripting-language-embeddable][What makes a scripting language "embeddable"? - Software Engineering Stack Exchange]]

** Embedded Scripting Languages Selection 
 
Selection of embedded scripting languages and engines available as  libraries:

 *Non categorized:*

  * [[http://tcl-lang.org/][TCL]] - Tool Command Language
    * License: akin to BSD
    * Implementation: C
    * Syntax Type: N/A
    * Note: pervasive in EDA - Electronic Design Automation software.
    * See:
      * [[https://wiki.tcl-lang.org/page/How+to+embed+Tcl+in+C+applications][How to embed Tcl in C applications]]

  * [[https://github.com/mruby/mruby][mruby]] (Embeddable Ruby implementation)
    * License: BSD
    * Implementation: C
    * Syntax type: Ruby

  * [[https://github.com/munificent/wren][Wren]]
    * License: MIT
    * Implementation: C
    * Syntax Type: N/A 

  * [[https://www.jinx-lang.org/][Jinx]]
    * License: MIT
    * Implementation: C++17
    * Syntax Type: N/A

  * [[https://marcobambini.github.io/gravity][Gravity]]
    * License: -
    * Implementation: C
    * Syntax type: Apple's SWIFT language

  * [[https://github.com/GaijinEntertainment/daScript][DaScript]] 
    * License: - 
    * Implementation: C++14
    * Syntax type: Akin to Python

 *Lua or similar to Lua (mimics Lua syntax)*

  * [[http://lua.org/][Lua]]
    * License: MIT
    * Implementation: C
    * Syntax Type: syntax inspired by scheme.

  * [[http://luajit.org/][LuaJIT]] (Lua with JIT - Just-in-Time compiler which translates
    bytecodes to native machine code for better performance.)
    * License: MIT
    * Implementation: C
    * Syntax type:  lua 

  * [[http://www.gmscript.com/][GameMonkey Script]]
    * License: MIT 
    * Implementation: C++
    * Syntax type: Akin to Lua

  * [[http://squirrel-lang.org/][Squirrel]]
    * License: MIT
    * Implementation: C++
    * Syntax type:    Lua-like
    * Note: Despite be implemented in C++, does not expose a C++ API,
      it exposes a C API. 

  * [[https://github.com/mingodad/squilu][Squilu]] (Squirrel fork)
    * License: MIT
    * Implementation: C++
    * Syntax type: Lua-like 

 *Similar to C++ (syntax that mimics C++)*

  * [[http://www.angelcode.com/angelscript/][AngelScript]]  (Note: statically typed)
    * License: Zlib
    * Implementation: C++ 
    * Syntax type: C++-like


 *Smiliar to Javascript or subset of Javascript (ECMAScript)*

  * [[https://en.wikipedia.org/wiki/SpiderMonkey][SpiderMonkey]] - Java Script Engine (VM - Virtual Machine)
    used by Mozzila Firefox. 
    * License: MPL 2.0 
    * Implementation: C and C++
    * Syntax tyope: JavScript (ECMAscript)
    * Used by:
      * Firefox Web Browser
      * MongoDB Document Database
      * [[https://blog.couchdb.org/2020/02/26/the-road-to-couchdb-3-0-update-to-javascript-engine/][CoucheDB]]
      * Adobe Acrobat Reader 
    * See:
      * [[https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/How_to_embed_the_JavaScript_engine][Mozilla - How to embed the JavaScript engine]]
    * Repository:
      * https://github.com/ricardoquesada/Spidermonkey/

  * [[http://duktape.org/][Duktape]]
    * License: MIT
    * Implementation: C
    * Syntax type: Javascript (aka ECMAScript) E5/E5.1

  * [[https://github.com/espruino/Espruino][Espruino]]
    * License: MPL 2       
    * Implementation: C
    * Syntax type: ES5 - Javascript (ECMaScript)

  * [[https://github.com/jerryscript-project/jerryscript][JerryScript]]
    * License: Apache v2
    * Implementation: C
    * Syntax type: Javascript (ECMAScript)

  * [[http://chaiscript.com/][ChaiScript]] 
    * License: BSD 
    * Implementation: C++
    * Syntax type: Javascript-like 

 *Similar to Lisp or Scheme*

  * [[https://gitlab.com/embeddable-common-lisp/ecl][ECL - Embeddable Common Lisp]]
    * License: LGPL - 2
    * Implementation: C
    * Syntax type:    Lisp, Common Lisp

  * [[http://tinyscheme.sourceforge.net/][TinyScheme]]
    * License: BSD 
    * Implementation: C
    * Syntax tyope: scheme, lisp
    * Note: Used in GNU GIMP as scripting language and Apple MacOSX's
      sandbox as configuration language.

  * [[https://ccrma.stanford.edu/software/snd/snd/s7.html][S7 Scheme]] (Variant of TinyScheme)
    * License: BSD
    * Implementation: C
    * Syntax type: C 

  * [[https://github.com/ashinn/chibi-scheme][Chibi Scheme]]
    + Implementation: C
    + Syntax type: Scheme, Lisp 

  * [[https://janet-lang.org/][Janet Language]]
    * License: MIT 
    * Implementation: C
    * Syntax type: Clojure, Lisp

  * [[https://github.com/SuperFola/Ark][ArkScript]]  
    + License: MPL license
    + Implementation: C
    + Syntax type: Lisp-like, more clojure-like

License obligations and requirements:

  * *LGPL* allows dynamically linking of closed source
    applications, but static linking requires source code disclosure
    and release under the same license. Some LGPL libraries, such as
    QT, allows static linking via commercial license.

  * MIT, BSD, APACHE and so on => Add a copy of the license; Give credit.
 
** MuParser - Math expression parser 

MuParser is a non-turing complete embedded scripting engine for
evaluating math expressions. 

Web Site: 
 + https://beltoforion.de/article.php?a=muparser

Repository: 
 + https://github.com/beltoforion/muparser/

Conan Reference: 
 + [[https://bintray.com/conan-community/conan/muparser%253Aconan/2.2.6%253Astable][muparser/2.2.6@conan/stable]]

 *Sample Project*

File: *CMakeLists.txt*

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(cppexperiments)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  # ============= Conan Bootstrap =============================#

  # Download automatically, you can also just copy the conan.cmake file
  if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
     message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
     file(DOWNLOAD "https://github.com/conan-io/cmake-conan/raw/v0.13/conan.cmake"
                   "${CMAKE_BINARY_DIR}/conan.cmake")
  endif()

  include(${CMAKE_BINARY_DIR}/conan.cmake)

  # Possible values "default" and "llvm8"
  set(CONAN_PROFILE default)

  conan_cmake_run(REQUIRES
                  muparser/2.2.6@conan/stable
                  BASIC_SETUP
                  BUILD missing)

   #======= Targets Settings ===============+#

  add_executable(muparser1_formula muparser1_formula.cpp)
  target_link_libraries(muparser1_formula muparser)
#+END_SRC

File: *muparser1_formula.cpp*

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <cmath>

  #include <muParser.h>

  // Defined for UNIX-like: Linux, Mac OSX, QNX, ...
  #if __unix__
    #include <unistd.h>
  #endif

  bool isTTY_terminal()
  {
     #if __unix__
        return ::ttyname(STDIN_FILENO) != nullptr;
     #else
        return false;
     #endif
  }

  double future_value(double PV, double rate, double nper)
  {
      return PV * std::pow(1 + rate / 100.0, nper);
  }

  int main()
  {

      mu::Parser p1;

      std::puts("\n====== EXPERIMENT 1 - Simple math expression =======");
      p1.SetExpr("2^1 + 2^3 + 2^4");
      std::cout << " [*] p1-A value: "
                << p1.GetExpr() << " = " << p1.Eval() << std::endl;

      p1.SetExpr("3.5 * 10 - sin(3.1415) * 2.0 + sqrt(10) / 100.0 + 2^3");
      std::cout << " [*] p1-B value: "
                << p1.GetExpr() << " = " << p1.Eval() << std::endl;

      std::puts("\n====== EXPERIMENT 2 - Expression with variables =======");
      p1.DefineConst("pi", 3.1415);
      double x = 10.0, y = 4.5;
      p1.DefineVar("x", &x);
      p1.DefineVar("y", &y);
      p1.SetExpr(" 3 * pi + sin(pi) + 4 * x + y - 5");
      std::cout << " [*] p1-C value: "
                << p1.GetExpr() << " = " << p1.Eval() << std::endl;

      std::puts("\n====== EXPERIMENT 3 - Expression with custom function =======");

      p1.DefineFun("fv", &future_value);

      p1.DefineFun("payoff", [](double S, double K){
          return std::max(S - K, 0.0);
      });

      p1.SetExpr("fv(100, 2, 8) + payoff(100, 90)");
      std::cout << " [*] p1-D value: " << p1.GetExpr() << " = " << p1.Eval() << std::endl;


      std::puts("\n====== EXPERIMENT 4 - Parser error handling =======");

      // When an error happens it throws an exception: mu::ParserError
      try{
          p1.SetExpr("10.2 * 5.0 + a * 3");
          double value = p1.Eval();
          std::cout << " [*] p1-E value: " << value << std::endl;
      } catch (mu::ParserError const& ex)
      {
          std::cerr << " [ERROR] p1-C Parser error: " << ex.GetMsg() << std::endl;
      }


      std::puts("\n====== EXPERIMENT 5 - Calutor Interactive Shell ======");

      if(isTTY_terminal())
      {
          std::cout << " === Calculator Started OK. =====" << std::endl;

          mu::Parser p2;
          double ans = 0.0;
          p2.DefineVar("ans", &ans);
          std::string line;

          while(std::cin.good())
          {
              std::cout << " EXPR => ";
              std::getline(std::cin, line);

              if(line == "")
                  continue;

              if(line == "quit")
                  break;

              p2.SetExpr(line);
              try {
                  ans = p2.Eval();
                  std::cout << " => ans = " << ans << "\n\n";
              } catch(mu::ParserError const& ex)
              {
                  std::cerr << " [ERROR] Parser error " << ex.GetMsg() << std::endl;
              }
          }

      }

  #if _WIN32
      std::cout << "Enter RETURN to exit. " << std::endl;
      std::cin.get();
  #endif
      return 0;
  }
#+END_SRC

 *Program output:*

#+BEGIN_SRC sh 
   $ ./muparser1_formula 

   ====== EXPERIMENT 1 - Simple math expression =======
    [*] p1-A value: 2^1 + 2^3 + 2^4  = 26
    [*] p1-B value: 3.5 * 10 - sin(3.1415) * 2.0 + sqrt(10) / 100.0 + 2^3  = 43.0314

   ====== EXPERIMENT 2 - Expression with variables =======
    [*] p1-C value:  3 * pi + sin(pi) + 4 * x + y - 5  = 48.9246

   ====== EXPERIMENT 3 - Expression with custom function =======
    [*] p1-D value: fv(100, 2, 8) + payoff(100, 90)  = 127.166

   ====== EXPERIMENT 4 - Parser error handling =======
    [ERROR] p1-C Parser error: Unexpected token "a" found at position 13.

   ====== EXPERIMENT 5 - Calutor Interactive Shell ======
    === Calculator Started OK. =====
    EXPR => 9.81 * sin(3.1415 / 2.0) + 100 * sqrt(285.6) + exp(3.65)
    => ans = 1738.26

    EXPR => ans / 100.0 - 80.0
    => ans = -62.6174

    EXPR => ans * ans
    => ans = 3920.94

    EXPR => 

#+END_SRC

** Exprtk - Math expression parser 

Exprtk is a MIT-license single-header, header-only and turing-complete
math expression parsing engine.

Official Web Site: 

  + http://www.partow.net/programming/exprtk/

Official repository: 

  + https://github.com/ArashPartow/exprtk/

Features: 

   * Header-only library in  a single file.
   * Turing-complete
   * Sandboxed
   * Supports binding to defined-functions in C++-side.
   * Functions can operate on vectors
   * Control structures: for-loop; if-else; ternary operator.

Drawbacks: 

  + The library exprtk.hpp has one megabyte (1 mb) in a single header
    file which significantly slows down the compile-time. Header-only
    design should only be used for small libraries.


  *Sample Project* 

   + GIST: https://gist.github.com/2ff870b653b2ec1519bf0423165db1c5

   + Note: The static library target 'mparser' makes the compile-time
     of the client code 'main.cpp' faster by using the PIMPL
     (Pointer-To-Implementation) design pattern and not exposing
     exprtk.hpp in the library header file. 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.9)
   project(exprk-parser)

   #========== Global Configurations =============#
   #----------------------------------------------#

   set(CMAKE_CXX_STANDARD 17)     
   set(CMAKE_VERBOSE_MAKEFILE ON)
   set(CMAKE_CXX_EXTENSIONS OFF)

   #----------- Add dependencies --------------------------#

   #============= Functions and macros ===========================#
   macro(Download_Single_Headerlib FILE URL)
       file(DOWNLOAD ${URL} ${CMAKE_BINARY_DIR}/include/${FILE})
       IF(NOT Download_Single_Headerlib_flag)
          include_directories(${CMAKE_BINARY_DIR}/include)
          set(Download_Single_Headerlib_flag TRUE)
       ENDIF()
   endmacro()

   Download_Single_Headerlib( exprtk.hpp 
                              https://github.com/ArashPartow/exprtk/raw/d81ac1a2ddd9877a7981d32c731fd9a75544ec68/exprtk.hpp )

   #-----------  Target settings -------------------------------#

             add_library( mparser mparser.cpp mparser.hpp )
          add_executable( main main.cpp )
   target_link_libraries( main mparser )
#+END_SRC

File: mparser.hpp  (cmake target: mparser static library)

#+BEGIN_SRC cpp 
   #ifndef _MPARSER_HPP_
   #define _MPARSER_HPP_

   #include <string>
   #include <memory>
   #include <functional>


   // Unique-ownership smart pointer for implementing PimPl
   // 
   // Note: It was created because std::uniqe_ptr does 
   //       not support 'incomplete types'.
   //  
   // Note: PimPl (Pointer-To-Implementation) idiom 
   // is a technique for reducing compile-time and 
   // maintaining ABI stability which mitigates the 
   // fragile-ABI problem.
   // 
   template<typename T, void (*disposer) (T*)>
   class pimpl_ptr
   {
       T*       m_hnd;    
   public:
       pimpl_ptr()
           : m_hnd(nullptr)
           //, m_disp(disp) 
           { }

       pimpl_ptr(T* hnd)
           : m_hnd(hnd)
           { }

       ~pimpl_ptr()
       {
           this->release();
       }

       // Disable copy constructor 
       pimpl_ptr(pimpl_ptr const&) = delete;
       // Disable copy-
       pimpl_ptr& operator=(pimpl_ptr const&) = delete;

       // Move Ctor 
       pimpl_ptr(pimpl_ptr&& rhs)
       {
           std::swap(m_hnd, rhs.m_hnd);
       }

       // Move assignment operator 
       pimpl_ptr& operator=(pimpl_ptr&& rhs)
       {
           std::swap(m_hnd, rhs.m_hnd);
       }

       T* get() const { return m_hnd; }

       void release()
       { 
           // Note: it is not possible to delete incomplete type 
           // in this way: 'delete m_hnd;'
           disposer(m_hnd);
           m_hnd = nullptr;
       }

       void reset(T* hnd)
       {
           this->release();
           m_hnd = hnd;
       }

       bool empty() const { return m_hnd == nullptr; }
       T&   operator* () const { return *m_hnd; }
       T*   operator-> () const { return m_hnd; }
   };


   class MathEvaluator
   {
       struct impl;
       static void dispose(impl* p);
       pimpl_ptr<impl, MathEvaluator::dispose> m_pimpl;
   public:
       MathEvaluator();
       ~MathEvaluator() = default;
       MathEvaluator& add_var(std::string name, double& ref);   

       // Register function pointer callback or non-capture lambda 
       MathEvaluator& add_function(std::string, double fptr (double) );
       // Register function of two variables 
       MathEvaluator& add_function(std::string, double fptr (double, double) );

       double  eval_code(std::string code);    
       bool    compile(std::string code);
       double  value();
       void    repl();
   };

   #endif
#+END_SRC

File: mparser.cpp (cmake target: mparser static library)

#+BEGIN_SRC cpp 
   #include "mparser.hpp"

   #include <iostream>
   #include <string> 
   #include <exprtk.hpp>

   // --------------------------------------------------// 

   struct MathEvaluator::impl 
   {
       exprtk::expression<double>   expr;
       exprtk::symbol_table<double> symbol_table;
       exprtk::parser<double>       parser;     
       std::string                  code; 

       // Println function 
       exprtk::rtl::io::println<double> println{};

   };

   // static method 
   void 
   MathEvaluator::dispose(impl* p)
   {
       delete p;
   }

   MathEvaluator::MathEvaluator(): m_pimpl(new impl)
   {    
       m_pimpl->symbol_table.add_constants();
       m_pimpl->expr.register_symbol_table(m_pimpl->symbol_table);    
       m_pimpl->symbol_table.add_function("println", m_pimpl->println);
   }

   MathEvaluator& 
   MathEvaluator::add_var(std::string name, double& ref)
   {
       m_pimpl->symbol_table.add_variable(name, ref);
       return *this;
   }

   MathEvaluator& 
   MathEvaluator::add_function(std::string name, double fptr (double) )
   {
       m_pimpl->symbol_table.add_function(name, fptr);
       return *this;
   }

   MathEvaluator& 
   MathEvaluator::add_function(std::string name, double fptr (double, double) )
   {
       m_pimpl->symbol_table.add_function(name, fptr);
       return *this;
   }

   bool 
   MathEvaluator::compile(std::string code)
    {
       bool r = m_pimpl->parser.compile(code, m_pimpl->expr);

       if(!r){ 
           std::string err = "Error: ";
           err = err + m_pimpl->parser.error();
           std::cerr << " Error: " << err << "\n";
            throw std::runtime_error(" [PARSER] Unable to parse expression.");
       }
       return r;
    }

   double 
   MathEvaluator::value()
   {
       return m_pimpl->expr.value();
   }

   void MathEvaluator::repl()
   {
       std::string line; 
       double result;
       while( std::cin.good() )
       {
           std::cout << " EXPRTK $ >> ";
           std::getline(std::cin, line);
           if(line.empty()) continue;
           if(line == "exit") return;
           try {
               this->compile(line);            
               std::cout << this->value() << '\n';
           } catch (std::runtime_error& ex) {
               std::cerr << "Error: " << ex.what() << '\n';

           }

       }
   }
#+END_SRC

File: main.cpp  (cmake target: main)

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string>
   #include <cassert>

   #include "mparser.hpp"

   double myfun(double a, double b);
   void   test_engine(MathEvaluator& engine, double& x);

   int main(int argc, char** argv)
   {
       std::puts(" [TRACE] I am up and running Ok. ");

       MathEvaluator engine;    
       double x = 1.0, y = 2.0, z = 3.0;
       engine.add_var("x", x)
           .add_var("y", y)
           .add_var("z", z)
           .add_function("myfun", &myfun);

       assert(argc == 2);

       auto command = std::string(argv[1]);
       if(command == "test" ){ test_engine(engine, x); }
       if(command == "repl" ){ engine.repl();          }

       std::cerr << " [TRACE] Shutdown engine Ok. " << '\n';
       return 0;
   }

   // -----------------------------------------//


   double myfun(double a, double b)
   {
       std::cerr << "  [TRACE] a = " << a << "\n";
       std::cerr << "  [TRACE] b = " << b << "\n";
       double r =  3.0 * a + 5.0 * b;
       std::cerr << "  [TRACE] result = " << r << "\n";
       std::cerr << "---------------------------------\n";
       return r;
   }


   void test_engine(MathEvaluator& engine, double& x)
   {
       std::string code = R"( 
           // Define local variables 
           var a := 2.0 / exp(x) * x^2 + y;
           var b := 10.0 * sqrt(x) + z;

           // println('\n => x = ', x);
           // println('\n => y = ', y);

           // Call custom function
           var k := myfun(x, y);

           // Comment: the last expression is returned 
           4.0 * a + 3 * b + 10 * z + k;        
       )";        
       engine.compile(code);

       x = 3.0;
       std::cout << " => x = " << x << " ; engine = " << engine.value() << "\n";

       x = 5.0;
       std::cout << " => x = " << x << " ; engine = " << engine.value() << "\n";

       x = 15.0;
       std::cout << " => x = " << x << " ; engine = " << engine.value() << "\n";

       x = -15.0;
       std::cout << " => x = " << x << " ; engine = " << engine.value() << "\n";

       x = 20.0;
       std::cout << " => x = " << x << " ; engine = " << engine.value() << "\n";


       std::string code2 = R"( 
           // Vector/array variable 
           var xs [6] := {  2.0, 10.2,   -2.50,  9.256, 100.0,  25.0 };
           var ys [6] := { -2.0,  1.225, -5.56, 19.000, 125.0, 125.0 };

           println(' => xs =', xs);
           println(' => ys = ', ys);
           println(' => 3 * xs + 4 * ys = ', 3 * xs + 4 * ys);
           println(' => sum(xs) = ', sum(ys) );
           println(' => sum(ys) = ', sum(xs) );

       )";
       engine.compile(code2);
       engine.value();
   }

#+END_SRC

  *Building* 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/2ff870b653b2ec1519bf0423165db1c5 gist && cd gist 
  $ cmake --config Debug -H. -B_build  
  $ cmake --build _build --target 
#+END_SRC

 *Running* 

Running 'test' subcommand. 

#+BEGIN_SRC sh 
  # Redirect std::cerr or stderr to file 
  $ _build/main test 2> out.log
   [TRACE] I am up and running Ok. 
   => x = 3 ; engine = 121.546
   => x = 5 ; engine = 140.43
   => x = 15 ; engine = 218.19
   => x = -15 ; engine = -nan
   => x = 20 ; engine = 251.164
   => xs =   2.00000   10.20000   -2.50000    9.25600  100.00000   25.00000
   => ys =   -2.00000    1.22500   -5.56000   19.00000  125.00000  125.00000
   => 3 * xs + 4 * ys =   -2.00000   35.50000  -29.74000  103.76800  800.00000  575.00000
   => sum(xs) =  262.66500
   => sum(ys) =  143.95600

  # View log file 
  $ _build/main test 2> out.log
   [TRACE] I am up and running Ok. 
   => x = 3 ; engine = 121.546
   => x = 5 ; engine = 140.43
   => x = 15 ; engine = 218.19
   => x = -15 ; engine = -nan
   => x = 20 ; engine = 251.164
   => xs =   2.00000   10.20000   -2.50000    9.25600  100.00000   25.00000
   => ys =   -2.00000    1.22500   -5.56000   19.00000  125.00000  125.00000
   => 3 * xs + 4 * ys =   -2.00000   35.50000  -29.74000  103.76800  800.00000  575.00000
   => sum(xs) =  262.66500
   => sum(ys) =  143.95600
#+END_SRC

Running 'repl' subcommand for interactive shell.

#+BEGIN_SRC sh 
   rlwrap _build/main repl 
   [TRACE] I am up and running Ok. 
   EXPRTK $ >> sin(pi) * 2.0  + 5.3 * cos(3/2 * pi)
  -7.28665e-16
   EXPRTK $ >> exp(3.1)
  22.198
   EXPRTK $ >> var a := exp(2.5); var b := a * 3.0 + 10.0; 3 * a + b
  83.095
   EXPRTK $ >> 
   EXPRTK $ >> println(' x = ', x)
   x =    1.00000
  0
   EXPRTK $ >> myfun(5.1, 2.56)
    [TRACE] a = 5.1
    [TRACE] b = 2.56
    [TRACE] result = 28.1
  ---------------------------------
  28.1
   EXPRTK $ >> 
   EXPRTK $ >> myfun(5.1, 2.0 * pi + 10.0)
    [TRACE] a = 5.1
    [TRACE] b = 16.2832
    [TRACE] result = 96.7159
  ---------------------------------
  96.7159
   EXPRTK $ >> 
   EXPRTK $ >> exit
   [TRACE] Shutdown engine Ok. 

#+END_SRC
** Lua scripting engine 
*** Overview 

Lua (moon in Portuguese) is a ligthweight multi paradigm scripting
language written in C. Due to Lua be available as small footprint
libraryn this language is widely used as embedded scripting by many
applications for scripting and as configuration or data description
language.

Use cases: 

  + Scripting for C or C++ applications

  + Extension language => Add new functionality and updates without
    recompilation. 

  + Provide interactive REPL or shell to C or C++ applications.

  + Program configuration (settings)

  + Data description language 

Some applications using Lua: 

  + [[https://nmap.org/book/nse-language.html][Nmap]] network scanner 
  + MediaWiki (engine used by Wikipedia)
  + Nginx Web Server
  + Redis Database 
  + Linux Conky 
  + LuaTex
  + NetBSD
  + Cheat Engine
  + Geany text editor
  + [[https://github.com/xmake-io/xmake][Xmake]] building system for C, C++, Objective-C, Swift, Assembly,
    Golang, Rust, Dlang and Cuda
  + [[https://en.wikipedia.org/wiki/Category:Lua-scripted_video_games][Lots of games]] use lua for scripting and allow non-programmers,
    such as end-users and game artists to contribute to the game
    development, create animations, movements, finite state machines
    and so on.
  + ... ... 

More at: 

  + [[https://en.wikipedia.org/wiki/List_of_applications_using_Lua][List of applications using Lua - Wikipedia]]

  + [[https://web.archive.org/web/20180322033939/https://en.wikipedia.org/wiki/Category:Lua-scripted_video_games][Category:Lua-scripted video games - Wikipedia]] 


 *Repository and  C++ Binding Libraries* 

  * Official Repository Mirror
    + https://github.com/lua/lua

  * Lua Bind
    + https://www.rasterbar.com/products/luabind/docs.html
    + https://sourceforge.net/projects/luabind/
    + https://github.com/luabind/luabind 

  * Sol2 (means 'sun' 2 in Portuguese)
    + https://github.com/ThePhD/sol2
    + https://sol2.readthedocs.io/en/latest/
*** Further Reading 

 *Documentation* 
 
  + [[https://www.lua.org/manual/5.1/manual.html][Lua 5.1 Reference Manual]] - Documentation 

  + [[https://en.wikipedia.org/wiki/Lua_(programming_language)][Lua (programming language) - Wikipedia]]

 *Lua C API*

  + [[https://www.lua.org/pil/24.1.html][Programming in Lua : 24.1]] 

  + [[http://lua-users.org/wiki/BindingCodeToLua][lua-users wiki: Binding Code To Lua]] 

  + [[http://lua-users.org/wiki/SimpleLuaApiExample][lua-users wiki: Simple Lua Api Example]]

  + [[http://webserver2.tecgraf.puc-rio.br/lua/local/pil/24.html][Programming in Lua : 24]]

  + [[https://chsasank.github.io/lua-c-wrapping.html][Exposing C functions to Lua]]

 *Lua embedded in Geany Text Editor* 

  + https://plugins.geany.org/geanylua/geanylua-intro.html

  + https://github.com/geany/geany-plugins/tree/master/geanylua/examples

  + https://github.com/DGivney/geany-lua-scripts
    + Collection of Lua scripts for Geany text editor 

  + https://github.com/geany/geany-plugins/tree/master/geanylua

 *Lua scripting in NMap Network Scanner* 

  + [[https://nmap.org/book/nse-language.html][Script Language | Nmap Network Scanning]]
    + "The core of the Nmap Scripting Engine *is an embeddable Lua*
      *interpreter*. _Lua is a lightweight language designed for_
      _extensibility. It offers a powerful and well-documented API for_
      interfacing with other software such as Nmap. The second part of
      _the Nmap Scripting Engine is the NSE Library, which connects Lua_
      _and Nmap_. This layer handles issues such as initialization of
      the Lua interpreter, scheduling of parallel script execution,
      script retrieval and more. It is also the heart of the NSE
      network I/O framework and the exception handling mechanism. It
      also includes utility libraries to make scripts more powerful
      and convenient. The utility library modules and extensions are
      described in the section called 'NSE Libraries'."

  + [[https://github.com/nmap/nmap/tree/master/nselib][Nmap Scripting Engine Source Code]] / GITHUB

  + [[https://dev.to/citizen428/extending-nmap-withlua-bpa][Extending Nmap With Lua - DEV]]


 *Lua Scripting in Wireshark - Network Capture Application*

  + [[https://wiki.wireshark.org/Lua][Lua - The Wireshark Wiki]]

  + [[https://sharkfestus.wireshark.org/sharkfest.09/DT06_Bjorlykke_Lua%2520Scripting%2520in%2520Wireshark.pdf][Lua Scripting in Wireshark]]

 *Lua Scripting in XMake Building System* 

  + https://github.com/xmake-io/xmake

  + [[https://github.com/xmake-io/xmake/search?l=C%252B%252B&q=lua&type=][Search for usages of Lua C API in Xmake source code]]

 *Lua scripting on NetBSD Kernel* 

  + [[https://www.netbsd.org/gallery/presentations/mbalmer/fosdem2012/kernel_mode_lua.pdf][Lua in teh NetBSD Kernel]]

  + [[https://2018.eurobsdcon.org/static/slides/Fast,%2520Flexible%2520Packet%2520Filtering%2520in%2520NetBSD%2520using%2520Lua%2520Kernel%2520Scripts%2520-%2520Andrew%2520von%2520Dollen.pdf][Lua Kernel Scripting in NetBSD - Fast, Flexible Packet Filtering]]

  + [[https://www.lua.org/wshop13/Cormack.pdf][Towards a Lua scripted operating system]]

  + [[https://www.slideshare.net/eurobsdcon/lneto-npf-scripting][NPF scripting with Lua by Lourival Vieira Neto]]


 *Lua scripting on Redis Database* 

  + [[https://www.slideshare.net/itamarhaber/redis-lua-scripts][Redis Lua Scripts]]

  + [[https://www.slideshare.net/RedisLabs/redis-lua-scripts-a-primer-and-use-cases][Redis: Lua scripts - a primer and use cases]]


 *Lua scripting on Nginx Web Server* 

  + [[https://www.nginx.com/resources/wiki/modules/lua/][Lua on NGINX web server]]

  + [[https://blog.cloudflare.com/pushing-nginx-to-its-limit-with-lua/][Pushing Nginx to its limit with Lua]] - CloudFlare

  + [[https://www.slideshare.net/gakhov/implementing-a-fileserver-with-nginx-and-lua][Implementing a Fileserver with Nginx and Lua]]


 *Lua scripting on Unreal Engine / game engine* 

  * [[https://www.slideshare.net/Codemotion/roberto-de-ioris-scriptiamo-unreal-engine-con-lua-codemotion-rome-2019][Roberto De Ioris - Scriptiamo Unreal Engine con Lua - Codemotion Rome…]]

  * [[https://github.com/rdeioris/LuaMachine][GitHub - rdeioris/LuaMachine: Unreal Engine 4 Plugin for Lua APIs implementation]]

  * [[https://www.unrealengine.com/marketplace/en-US/product/luamachine][LuaMachine by Roberto De Ioris in Code Plugins - UE4 Marketplace]]
    + "Unreal Engine 4 Plugin for adding Lua scripting to your
      projects: If you want modders to customize your game/project, or
      you need to allow game designers to script parts of the logic,
      this plugin is for you; Contrary to the other Unreal Engine 4
      Lua plugins, this one does not try to expose the Unreal Engine 4
      api, but completely hides it exposing to the user/scripter only
      the features the developer decided to include (via Blueprints or
      C++); Currently Windows 64bit, Mac, Linux x86_64 (both Runtime
      and Editor), Linux AArch64, Android 32bit, Android 64bit, iOS
      (Runtime only) are supported."

 *Lua for DSL - Domain Specific Language*  

  + [[http://lua-users.org/wiki/LuaDataFormats][lua-users wiki: Lua Data Formats]]
    + "Lua can be used as a language to represent data, not just as a
      general programming language.  Different languages have been
      devised for different types of data representation in text
      format."

  + [[https://leafo.net/guides/dsl-in-lua.html][Writing a DSL in Lua]]

  + [[https://www.slideshare.net/agladysh/luaws13-ag][A visual DSL toolkit in Lua: Past, present and future]]

  + [[https://dnaeon.github.io/choosing-lua-as-the-ddl-and-config-language/][Choosing Lua as the data description and configuration language]] 

  + [[https://www.lua.org/wshop11/luaws11_ag.pdf][Declarative Internal DSLs in Lua / A Game-Changing Experience]]

  + [[https://en.m.wikibooks.org/wiki/Lua_Programming/Tables][Lua Programming/Tables - Wikibooks, open books for an open world]]

  + [[https://en.m.wikiversity.org/wiki/Lua/Tables][Lua/Tables - Wikiversity]]

  + [[https://sudonull.com/post/184529-Lua-declarative-programming-basics][Lua declarative programming basics / Sudo Null IT News]]

  + [[https://www.slideshare.net/ShuaiYuan/the-basics-and-design-of-lua-table][The basics and design of lua table]]

 *Videos*

  + [[https://www.youtube.com/watch?v=pfwHCiP1HFM][CppCon 2017: Andreas Weis "Howling at the Moon: Lua for C++ Programmers"]]
    + "C++ is a great tool for solving complex problems in a thorough
      way. But every once in a while, the desire for a simpler
      language emerges. For those parts of our code where performance
      is of secondary concern, but the ability to perform rapid
      iterations over the code is paramount, a scripting language
      might be a tempting choice. But integrating a second language
      besides C++ and managing the interaction between the two is also
      scary. Lua is a lightweight, dynamic language that was designed
      to be used as an embedded language within existing
      applications. It is easy to learn, has very reasonable runtime
      performance, and a memory footprint small enough that it is
      usable even on embedded systems. Furthermore, it is almost
      trivial to integrate with C++. This talk will give a brief
      introduction to the Lua scripting language, highlighting
      specifically how it can complement C++'s language features to
      enrich a developer's toolbox. In the second part of the talk, we
      will look at Lua's C API and give suggestions how to integrate
      it with a modern C++17 codebase. In particular we will focus on
      how to interface with the dynamic language Lua without
      compromising the benefits of C++'s strong type system." 

  + [[https://www.youtube.com/watch?v=xQAmGBfKnas][CppCon 2018: JeanHeyd Meneide “Scripting at the Speed of Thought: Lua and C++ with sol3”]]
    + "A big part of accelerating development and promoting
      collaboration often translates to deferring a lot of the typical
      programmer work to a scripting language, to allow for those with
      more design-oriented ideas and experience to handle some of the
      workload. What happens, then, when you have to bind a scripting
      language like Lua into C++ to allow for this workflow? This
      session is going to be all about how you enable non-developers
      and developers alike to rapidly increase their development
      productivity by turning routines and algorithms into data that
      can be shipped alongside your product in Lua. We will talk
      primarily how you can use the library sol2 to abstract away the
      muck of working with the Lua C API and instead focus on using
      and describing both Lua and C++ with each other in a simple
      manner. We will demonstrate some of the more interesting
      properties of sol such as Overloading Support, Container
      Support, Usertypes -- C++ classes made available with automatic
      support for unique/shared pointers -- and Tables. By the time
      this session is over, you will have a firm grasp over what a
      good Lua Binding can offer you, and how you can accelerate your
      C++ development with it." 

 *General* 

  + [[https://en.wikipedia.org/wiki/List_of_applications_using_Lua][List of applications using Lua - Wikipedia]]

  + [[https://en.wikipedia.org/wiki/Category:Lua-scripted_video_games][Category:Lua-scripted video games - Wikipedia]]

  + [[http://www.godpatterns.com/2005/07/using-lua-scripting-for-games.html][Godpatterns: Using Lua Scripting For Games]]

  + [[https://gamedev.stackexchange.com/questions/73728/how-does-lua-work-as-a-scripting-language-in-games][c++ - How does Lua work as a scripting language in games? - Game Development Stack Exchange]]

  + [[https://steamcommunity.com/sharedfiles/filedetails/?id=398177770][Steam Community - Guide - GameGuru LUA scripting summary and guide.]]

*** Example project with Sol2 C++ binding library 

This sample project builds a C++ statically linked executable
embedding the Lua scripting engine using the Sol2 binding library,
which is header only. Neither Sol2 nor Lua libraries need to be
installed before building this sample project as the CMake scripts
take care of downloading and building all dependencies.

Lua repostiory mirror: 

  + https://github.com/lua/lua

Sol2 library repository: 

  + https://github.com/ThePhD/sol2

Sol2 library documentation: 
 
  + https://sol2.readthedocs.io/en/latest/


  *Sample Project* 

GIST: 
  + https://gist.github.com/17a37d905d3d71c0ae66661a189481b5


File: _CMakeLists.txt_

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.0)
  project(duktape-cc-trial)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  include(lua-lib.cmake)

  #-----  Target Definitions ----------------------------#

         add_executable( embed-lua-sol embed-lua-sol.cpp)
  target_link_libraries( embed-lua-sol lua::lualib )

  # Lua REPL executable built from static library liblua.a (Linux)
  # Note: the main() function is in the file main.c in the lua sources directory
         add_executable( lua-repl $<TARGET_OBJECTS:lua::lualib> )
  target_link_libraries( lua-repl m pthread )
#+END_SRC


 File: _lua-lib.cmake_

  + CMake Script for downloading sol2 binding library and lua library
    sources. 

#+BEGIN_SRC cmake 
   include(FetchContent)

   # Note: the 'add_subriectory' line was commented becuyase 
   #       library that will be downloaded does not have 
   #       a CMakeListst.txt file at the root directory. 
   macro(Download_Library_Git  NAME TAG REPOSITORY_URL)
       FetchContent_Declare(
           ${NAME}
           GIT_REPOSITORY  ${REPOSITORY_URL}
           GIT_TAG         ${TAG}
       )
       FetchContent_GetProperties(${NAME})
       if(NOT cpputest_POPULATED)
           FetchContent_Populate(${NAME})
           message("${NAME}_SOURCE_DIR} = ${${NAME}_SOURCE_DIR}")        

           # => Disable following line: the library does not have a CMakeLists.txt
           #    at the root directory.
           # add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})
       endif()
   endmacro()


   # ====>> Download Lua library <<==========================#

   Download_Library_Git( lua                       
                         v5.3.5
                         https://github.com/lua/lua
                       )

   file(GLOB_RECURSE lua_sources "${lua_SOURCE_DIR}/*.c")
   file(GLOB_RECURSE lua_headers" ${lua_SOURCE_DIR}/*.h")

   message( [TRACE] " lua_SOURCE_DIR = ${lua_SOURCE_DIR} ")

                  add_library( lua STATIC ${lua_sources} ${lua_headers} )
   target_include_directories( lua PUBLIC ${lua_SOURCE_DIR} )

   add_library( lua::lualib  ALIAS lua)

   # ====>> Download Sol C++ binding library <<====================#

   FetchContent_Declare( sol2 
                         GIT_REPOSITORY  https://github.com/ThePhD/sol2
                         GIT_TAG         v3.2.0
                       )

   FetchContent_MakeAvailable( sol2 )
   include_directories( ${sol2_SOURCE_DIR}/include )

#+END_SRC

 File: _xmake.lua_  

  + Building script for [[https://xmake.io][XMake]] building system, which uses lua as
    embedded scripting language and as a building system DSL (Domain
    Specific Language) .
  + Xmake packages: [[https://github.com/xmake-io/xmake-repo/blob/master/packages/s/sol2/xmake.lua][sol2]], [[https://github.com/xmake-io/xmake-repo/blob/master/packages/l/lua/xmake.lua][lua]], [[https://github.com/xmake-io/xmake-repo/blob/master/packages/l/luajit/xmake.lua][luajit]]

#+BEGIN_SRC lua 
  add_rules("mode.debug", "mode.release")
  
  includes_lua = false 
  
  add_requires("sol2 v3.2.1")
  
  target("embed-lua-sol")
    set_kind("binary")
    set_languages("c++17")
    add_files("./embed-lua-sol.cpp")
    add_packages("sol2")  
#+END_SRC


 File: _embed-lua-sol.cpp_ 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string> 
  #include <vector> 
  #include <algorithm>

  #include <sol/sol.hpp>


  class Counter {
  private: 
      std::string m_name;
      int         m_counter;

  public: 

      // Ctor [1] => Default ctor 
      Counter(): Counter("untitled", 0) { }

      // Ctor [2]
      Counter(std::string name, int counter)
        : m_name{std::move(name)}, m_counter{counter}
      { 
          std::cout << " [TRACE] Counter created with =>  { " 
                    <<   " name = " << m_name 
                    << " ; counter = " << m_counter 
                    << " } \n";
      }

      int getCounter() const { return m_counter; }
      void setCounter(int n) {       
        m_counter = n; 
        std::cout << " [TRACE] I was set to value " << n << std::endl;
      }

      void increment() {       
        m_counter++; 
        std::cout << " [TRACE] increment event =>> counter = {  " 
                  << m_name << " ; " << m_counter 
                  << " } " << std::endl;
      }    
  };

  double add_fun(double a, double b)
  {
      std::cout << " [TRACE] addfun() => a = " << a 
                << " ; b = " << b << std::endl;
      return a + b;             
  }

  void sol_eval(sol::state& ctx, std::string code)
  {
      try {
          ctx.script( std::move(code) );        
      } catch ( sol::error const& ex) {
          std::cerr << " [SOL ERROR] " << ex.what() << "\n";
      }
  }


  int main()
  {
      // Create an instance of lua Engine (aka virtual Machine)
      sol::state ctx{};

      // Load basic libraries (such as print)
      ctx.open_libraries(sol::lib::base, sol::lib::coroutine, sol::lib::string, sol::lib::io);    

      // Register function pointer 
      ctx.set_function("add_fun", &add_fun);

      // Register lambda object 
      ctx.set_function("make_vector", [](int n ) -> std::vector<int> {
          auto vec = std::vector<int>(n);
          for(int i = 0; i < n; i++ ) vec[i]= i * 3;
          return vec;
      });

      // Set variables in the Lua engine 
      ctx["points"]    = 2000;
      ctx.set("character", "<Marcus Tulius Cicero>");

      /* ===========>>> E X P E  R I M E N T / 1  <<=========*/
      std::puts("\n [EXPERIMENT 1] ==>> Evaluating string as code ");
      {
          // ===>>> Eval code as string <<=== 
          // Throws exception sol::error 
          ctx.script(R"(
              print(" [LUA] Hello world lua "); 

              x = add_fun(10, 20);
              print("\n  [LUA] result =  " .. x);

              v = make_vector(5);
              print("\n  [LUA] Printing a vector ");

              for i = 1, 5 do 
                  print("   -> v[" .. i .. " ] = " .. v[i] );
              end 

              print("  [LUA] VAR points    = " .. points );
              print("  [LUA] VAR character = " .. character );
          )");

      }

      /* ===========>>> E X P E  R I M E N T / 2  <<=========*/
      std::puts("\n\n [EXPERIMENT 2] ==>> Reading configuration ");
      {
          ctx.script(R"(
              -- Simulation of user configuration from script     
              asset_path   = "C:\\\\Users\\myuser\\data\\files\\";
              user_credits = 2000;
              width        = 200.561;        
          )");

          auto asset_path = ctx.get<std::string>("asset_path");
          int user_credits = ctx["user_credits"];

          std::cout << "  [*] => asset_path = " << asset_path << "\n";
          std::cout << "  [*] => user_credits = " << user_credits << "\n";

      }

      /* ===========>>> E X P E  R I M E N T / 3  <<=========*/
      std::puts("\n\n [EXPERIMENT 3] ==>> Register C++ classes ");

      struct StatefulFunctor {
          int state = 0;
          StatefulFunctor(int state): state(state){ }
          int operator()(){ 

              std::cout << "  *=>> [StatefulFunctor] My new state is = " 
                        << this->state << "\n";
              return state++; 
          }
      };

      auto stateful = StatefulFunctor(10);
      ctx.set_function("stateful", stateful);

      ctx.script(R"(
          stateful();
          stateful();
          stateful();
      )");


      ctx.new_usertype<Counter>(
          // Class name 
           "Counter"          

          //  --- Register methods  ------ //
          ,"getCounter", &Counter::getCounter
          ,"setCounter", &Counter::setCounter
          ,"increment",  &Counter::increment

          // --- Register properties  ---- //
          , "value",     sol::property( &Counter::getCounter
                                      , &Counter::setCounter)
      );


      sol_eval(ctx, R"(
          print("\n ----->>> Calling C++ classes from Lua <----- ");

          -- Create new instance (object) of C++ class Counter 
          counter = Counter.new();
          counter:increment();
          counter:increment(); 
          counter:increment();

          x = counter:getCounter(); 
          print("  [*] value of counter is equal to = " .. x);

          counter.value = 2000;
          print(" [*] Counter value is equal to = " .. counter.value );
      )");

      Counter* ptr = ctx.get<Counter*>("counter");

      std::cout << " [FROM C++] counter value = " 
                << ptr->getCounter() 
                << "\n";

      return 0;
  }
#+END_SRC


Building => Debug build: 

#+BEGIN_SRC sh 
   $ git clone https://gist.github.com/17a37d905d3d71c0ae66661a189481b5 lua-sol && cd lua-sol 
   $ cmake --config Debug -H. -B_build 
   $ cmake --build _build --target 
#+END_SRC

Building => Release build: 

#+BEGIN_SRC sh 
   $ git clone https://gist.github.com/17a37d905d3d71c0ae66661a189481b5 lua-sol && cd lua-sol 
   $ cmake --config Release -H. -B_build 
   $ cmake --build _build --target 
#+END_SRC

Check executable: 

#+BEGIN_SRC sh 
 # Confirm whether the executable is statically linked against LuaLib 
 $ ldd _build/embed-lua-sol 
	linux-vdso.so.1 (0x00007ffdf0fc4000)
	libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007fe4490e6000)
	libm.so.6 => /lib64/libm.so.6 (0x00007fe448fa0000)
	libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007fe448f85000)
	libc.so.6 => /lib64/libc.so.6 (0x00007fe448dbb000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fe4492fa000)

   # Static library 
   $ file _build/liblua.a 
  _build/liblua.a: current ar archive
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
   $ _build/embed-lua-sol 

   [EXPERIMENT 1] ==>> Evaluating string as code 
   [LUA] Hello world lua 
   [TRACE] addfun() => a = 10 ; b = 20

    [LUA] result =  30.0

    [LUA] Printing a vector 
     -> v[1 ] = 0
     -> v[2 ] = 3
     -> v[3 ] = 6
     -> v[4 ] = 9
     -> v[5 ] = 12
    [LUA] VAR points    = 2000
    [LUA] VAR character = <Marcus Tulius Cicero>


   [EXPERIMENT 2] ==>> Reading configuration 
    [*] => asset_path = C:\\Users\myuser\data\files\
    [*] => user_credits = 2000


   [EXPERIMENT 3] ==>> Register C++ classes 
    *=>> [StatefulFunctor] My new state is = 10
    *=>> [StatefulFunctor] My new state is = 11
    *=>> [StatefulFunctor] My new state is = 12

   ----->>> Calling C++ classes from Lua <----- 
   [TRACE] Counter created with =>  {  name = untitled ; counter = 0 } 
   [TRACE] increment event =>> counter = {  untitled ; 1 } 
   [TRACE] increment event =>> counter = {  untitled ; 2 } 
   [TRACE] increment event =>> counter = {  untitled ; 3 } 
    [*] value of counter is equal to = 3
   [TRACE] I was set to value 2000
   [*] Counter value is equal to = 2000
   [FROM C++] counter value = 2000

#+END_SRC

Run Lua repl executable (defined in CMake): 

#+BEGIN_SRC js 
   $ rlwrap  _build/lua-repl 
   Lua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio
   > 
   > 

   > print(" Hello world Lua / Luna / Moon REPL ")
    Hello world Lua / Luna / Moon REPL 

   > for i = 1, 5 do print(" i = " .. i ) end
    i = 1
    i = 2
    i = 3
    i = 4
    i = 5


   function myfunction(a, b) 
     return math.sin(a) * math.exp(b) / a - a * b 
   end 

   > myfunction(3.5, 2.0)
   -7.7405591279893

   function add (a)
      local sum = 0
      for i,v in ipairs(a) do
         sum = sum + v
      end
      return sum
   end

   > add({ 2.5, 10.2, -2.51, 8.251, 10.56})
   29.001

   function add (a)
         local sum = 0
         for i,v in ipairs(a) do
           sum = sum + v
         end
   return su
#+END_SRC

  *Building and running with Xmake*

Building with Xmake: 

#+BEGIN_SRC sh 
   $ >> xmake build -P . -v 

  [ 25%]: ccache compiling.release embed-lua-sol.cpp
  /usr/bin/gcc -c -m64 -fvisibility=hidden -fvisibility-inlines-hidden -O3 -std=c++17 \
          -isystem /home/user/.xmake/packages/s/sol2/v3.2.1/5fa1980e381b40ed942748bdef09488a/include \
          -isystem /home/user/.xmake/packages/l/lua/v5.4.4/4de5c31814a64c0d9242d1e524082873/include/lua \
           -DNDEBUG -o build/.objs/embed-lua-sol/linux/x86_64/release/embed-lua-sol.cpp.o embed-lua-sol.cpp
           
  [ 50%]: linking.release embed-lua-sol
  /usr/bin/g++ -o build/linux/x86_64/release/embed-lua-sol build/.objs/embed-lua-sol/linux/x86_64/release/embed-lua-sol.cpp.o \
       -m64 -L/home/user/.xmake/packages/l/lua/v5.4.4/4de5c31814a64c0d9242d1e524082873/lib -s -llua -ldl -lm
  [100%]: build ok!
#+END_SRC

Generating a CMakeLists.txt file:

#+BEGIN_SRC sh 
   $ >> xmake project -v -k cmake -P . # Overrides CMakeLists.txt if it already exists

  configure
  {
      plat = linux
      buildir = build
      arch = x86_64
      mode = release
      ccache = true
      ndk_stdcxx = true
      host = linux
      kind = static
  }
  create ok!
  

#+END_SRC

Running the application: 

#+BEGIN_SRC sh 
   $ >> xmake run -P .
  
   [EXPERIMENT 1] ==>> Evaluating string as code 
   [LUA] Hello world lua 
   [TRACE] addfun() => a = 10 ; b = 20
  
    [LUA] result =  30.0
  
    [LUA] Printing a vector 
     -> v[1 ] = 0
     -> v[2 ] = 3
     -> v[3 ] = 6
     -> v[4 ] = 9
     -> v[5 ] = 12
    [LUA] VAR points    = 2000
    [LUA] VAR character = <Marcus Tulius Cicero>
  
  
   [EXPERIMENT 2] ==>> Reading configuration 
    [*] => asset_path = C:\\Users\myuser\data\files\
    [*] => user_credits = 2000
  
  
   [EXPERIMENT 3] ==>> Register C++ classes 
    *=>> [StatefulFunctor] My new state is = 10
    *=>> [StatefulFunctor] My new state is = 11
    *=>> [StatefulFunctor] My new state is = 12
  
   ----->>> Calling C++ classes from Lua <----- 
   [TRACE] Counter created with =>  {  name = untitled ; counter = 0 } 
   [TRACE] increment event =>> counter = {  untitled ; 1 } 
   [TRACE] increment event =>> counter = {  untitled ; 2 } 
   [TRACE] increment event =>> counter = {  untitled ; 3 } 
    [*] value of counter is equal to = 3
   [TRACE] I was set to value 2000
   [*] Counter value is equal to = 2000
   [FROM C++] counter value = 2000
#+END_SRC

** Squirrel Scripting Language 
*** Overview 

   + Squirrel is a embedded scripting language, similar to Lua, but with
     C-like syntax, designed to be embedded in larger C or C++
     applications such as game engines. Squirrel is written in C++, but
     it only exposes a C API, which makes binding C++ code
     cumbersome. However, there are many libraries which simplifies the
     embedding of squirrel in C++ codebases.

 *Official Web Site*

   + http://www.squirrel-lang.org/

 *Official Repository* 

   + https://github.com/albertodemichelis/squirrel

 *Squirrel fork with a more C++-like syntax*

 + https://github.com/mingodad/squilu

 *Articles about squirrel language*

  + [[https://developer.electricimp.com/squirrel/squirrelcrib][Squirrel Programming Guide | Dev Center]]

  + [[https://www.ibm.com/developerworks/aix/library/au-spunix_squirrel/index.html][Speaking UNIX: The Squirrel portable shell and scripting language]]

  + http://wiki.ogre3d.org/Squirrel+Scripting+Language

 *Applications using Squirrel*

  * CodeBlocks IDE for C and C++

  * OpenTTD Game - http://www.openttd.org/en/

 
 *Libraries for simplifying embedding squirrel in C++ code* 
 
Libraries for simplifying squirrel embedding in C++ code (binding
C++ code):

     + *SQPlus*
       + http://wiki.squirrel-lang.org/default.aspx/SquirrelWiki/SqPlus.html

     + *SQrat*
       + http://scrat.sourceforge.net/

     + *Squal*
       + https://github.com/jonigata/squall

     + *SimpleSquirrel*
       + https://github.com/matusnovak/simplesquirrel

*** Building Squirrel standalone REPL interpreter 

Download and build: 


#+BEGIN_SRC sh 
  $ mkdir ~/build && cd build 
  $ git clone https://github.com/albertodemichelis/squirrel
  $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug 
  $ cmake --build _build --target
#+END_SRC

Play with squirrel interactive shell (REPL):

#+BEGIN_SRC sh 
  $ _build/bin/sq
  Squirrel 3.1 stable Copyright (C) 2003-2017 Alberto Demichelis (64 bits)

  sq> print(" === Hello world Squirrel === ")
   === Hello world Squirrel === 

  sq> function add_to_10(x){ return x + 10; }

  sq>print(add_to_10(25))
  35

  sq> x <- cos(3.1415 / 2) + 10 

  sq>print(" x = " + x.tostring())
   x = 10

  sq> for(local i = 0; i < 5; i++) print(" \n [TRACE] i = " + i.tostring());

   [TRACE] i = 0 
   [TRACE] i = 1 
   [TRACE] i = 2 
   [TRACE] i = 3 
   [TRACE] i = 4
#+END_SRC

*** Example - embedding Squirrel with Squall Library 

This example demonstrates how to embed the Squirrel programming
language in a C++ application using the Squall header-only library. 

   + Squal Repository: https://github.com/jonigata/squall

   + Note: This project is self-contained, no library needs to be
     installed on the system as Squall automatically fetches Squirrel
     sources using Cmake FetchContent. 

 *Sample Project* 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
   cmake_minimum_required (VERSION 3.11)
   project(squirrel_squall_test)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED on)
   set(BUILD_EXAMPLES off)

   # -----------------------------------------------#
   include(FetchContent)

   FetchContent_Declare(
     squall 
     URL      https://github.com/jonigata/squall/archive/master.zip
     )

   FetchContent_MakeAvailable(squall)

   #-------- TARGET DEFINITIONS --------------------#
   message([TRACE] " squall_SOURCE_DIR = ${squall_SOURCE_DIR}/squall  ")

               add_executable ( squirrel-test squirrel_test.cpp)
        target_link_libraries ( squirrel-test squirrel_static sqstdlib_static)
   target_include_directories ( squirrel-test PUBLIC
                                  ${squirrel_SOURCE_DIR}/include
                                  ${squall_SOURCE_DIR}
                                  )
#+END_SRC

File: squirrel_test.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string>
   #include <algorithm>
   #include <vector> 

   #include <squall/squall_vmstd.hpp>
   #include <squall/squall_klass.hpp>

   void some_cpp_fun(int n )
   {
       for(int i = 0; i < n; i++)
           std::printf("\n   [some_cpp_function] => i = %d ", i);
   }

   class ChartXY
   {
       int m_width; 
       int m_height;
   public:
       ChartXY(): m_width(20), m_height(50) 
       {
           std::cout << " [ChartXY] Ctor() - I was created!. OK. " << std::endl;
       }

       void set_width(int x){ m_width = x; }
       void set_height(int x){ m_height = x; }

       void draw() const 
       { 
           std::printf(" [ChartXY] draw() => Draw chart with: width = %d ; height = %d"
                       , m_width, m_height);
       }
   };

   int main()
   {
       // Create a virtual-machine object for Squirrel language 
       // Note: throws squall::squirrel_error
       squall::VMStd vm; 

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 1] Evaluate scripts provided as strings                     //
       //-------------------------------------------------------------------------//
       std::puts(" =>> [EXPERIMENT] 1 - Evaluating code as string. ");  
       std::puts(" ---------------------------------------------\n");

       try {

           vm.dostring(R"( 
               // --- Squirrel Comment ----- // 
               print(" <SQUIRREL>  =>> Hello world squirrel!");

               function myfunc(x) {  
                   local a = x + 5;
                   local b = 7 * a + x;
                   return b - a + 10;  
               }

               function myfunc2() {
                   print(" \n  <SQUIRREL> I was called by the C++ code ");
               }

               print("\n <SQUIRREL> =>> myfunc(4) = " + myfunc(4).tostring() );

               print("\n\n <SQUIRREL> --- For Loop test ---- ");
               for(local i = 0; i < 5; i++) { 
                    print("\n   i = " + i.tostring() );  
               }
           )");

       } catch( squall::squirrel_error const& ex )
       {
           std::cerr << "\n [SQUIRREL ERROR] Error =>  " << ex.what() << std::endl;        
       }

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 2] Evaluate scripts provided as strings                     //
       //-------------------------------------------------------------------------//
       std::puts("\n =>> [EXPERIMENT] 2 - Getting variables defined in the code.");  
       std::puts(" -----------------------------------------------------------\n");

       {
           vm.dostring(R"( 
               // ---- Global varibles for configuration ------ // 
               ::myvar_width <- 100;
               ::myvar_float <- 122.56161;
               ::myvar_string <- "/path/to/interpreter.exe"; 
           )");

           squall::TableBase table = vm.root_table();
           auto myvar_float = table.get<float>("myvar_float");       
           auto myvar_width = table.get<int>("myvar_width");
           auto myvar_string = table.get<std::string>("myvar_string");
           std::cout << "  =>>  myvar_width = " << myvar_width << std::endl;
           std::cout << "  =>>  myvar_float = " << myvar_float << std::endl;
           std::cout << "  =>> myvar_string = " << myvar_string << std::endl;
       } 

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 3] Call functions defined in the script (Virtual Machine )  //
       //-------------------------------------------------------------------------//    
       std::puts("\n\n =>> [EXPERIMENT] 3 - Calling functions defined in the script (VM)");
       std::puts(" ------------------------------------------------------------------\n");    
       // Throws: 'squall::squirrel_error' 
       int result = vm.call<int>("myfunc", 10);
       std::cout << "   =>>> myfunc(4) = " << result << std::endl;

       vm.call<void>("myfunc2");

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 4] Call C++ functions from the script                       //
       //-------------------------------------------------------------------------//    
       std::puts("\n\n =>> [EXPERIMENT] 4 - Calling functions defined in the script (VM)");
       std::puts(" ------------------------------------------------------------------\n");

       // Register C++ function pointer 
       vm.defun("some_cpp_fun", &some_cpp_fun);

       vm.dostring(R"(
           print(" \n [SQUIRREL] => Call C++ function some_cpp_fun() ");
           some_cpp_fun(5);
        )");


       // Register C++ lambda object 
       vm.defun("call_me", [=](std::string const& param) {
           std::cout << "\n [TRACE] call_me() Parameter = " << param << "\n";
           return  " name = " + param;
       });

       vm.dostring(R"(
           local x = call_me("<SQUIRREL-INTERPRETER>");
           print(" [SQUIRREL] \n x <- " + x);
        )");

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 5] Call C++ classes from Squirrel-side                     //
       //-------------------------------------------------------------------------//    
       std::puts("\n\n =>> [EXPERIMENT] 5 - Calling C++ classes from Squirrel        ");
       std::puts(" ------------------------------------------------------------------\n");

       // Create metaobject 'k' that describes ChartXY class 
       squall::Klass<ChartXY> k(vm, "ChartXY");
       k.func("set_width",  &ChartXY::set_width);
       k.func("set_height", &ChartXY::set_height);
       k.func("draw",       &ChartXY::draw);

       vm.dostring(R"( 
           function manipulate_chart(ch){           
               ch.set_width(25);
               ch.set_height(10);
               ch.draw();
           }

           function draw_with(ch, w, h)
           {
               print(" \n [SQUIRREL LOG] Function draw_with called. OK. \n");
               ch.set_width(w);
               ch.set_height(h);
               ch.draw();
           }
        )");

       ChartXY mychart;
       vm.call<void>("manipulate_chart", &mychart);
       vm.call<void>("draw_with", &mychart, 100, 200);

       std::cout << "\n\n";

       squall::TableBase table = vm.root_table();

       // Pass object to Squirrel side 
       table.set("mychart", mychart);

       vm.dostring(R"(
           mychart.set_width(250);
           mychart.set_width(600);
           mychart.draw();
       )");


   #if 0  
       // Segmentation Falt Coredump if the C++ object 
       // is created on the Squirrel-side.
       vm.dostring(R"(
           local c = ChartXY();
           c.set_width(150);
           c.set_height(175);
           c.draw();
       )");
   #endif 

       return 0;
   }
#+END_SRC

Build: 

#+BEGIN_SRC sh 
   $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug 
   $ cmake --build _build --target 
#+END_SRC

Check executable dependencies: 

#+BEGIN_SRC sh 
 $ ldd _build/squirrel-test 
	linux-vdso.so.1 (0x00007ffe34dd6000)
	libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007fd3ebd2a000)
	libm.so.6 => /lib64/libm.so.6 (0x00007fd3ebbe4000)
	libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007fd3ebbc9000)
	libc.so.6 => /lib64/libc.so.6 (0x00007fd3eb9ff000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fd3ebf3e000)
#+END_SRC

Run application: 

#+BEGIN_SRC sh 
   $ _build/squirrel-test 

   =>> [EXPERIMENT] 1 - Evaluating code as string. 
   ---------------------------------------------

   <SQUIRREL>  =>> Hello world squirrel!
   <SQUIRREL> =>> myfunc(4) = 68

   <SQUIRREL> --- For Loop test ---- 
     i = 0
     i = 1
     i = 2
     i = 3
     i = 4
   =>> [EXPERIMENT] 2 - Getting variables defined in the code.
   -----------------------------------------------------------

    =>>  myvar_width = 100
    =>>  myvar_float = 122.562
    =>> myvar_string = /path/to/interpreter.exe


   =>> [EXPERIMENT] 3 - Calling functions defined in the script (VM)
   ------------------------------------------------------------------

     =>>> myfunc(4) = 110

    <SQUIRREL> I was called by the C++ code 

   =>> [EXPERIMENT] 4 - Calling functions defined in the script (VM)
   ------------------------------------------------------------------


   [SQUIRREL] => Call C++ function some_cpp_fun() 
     [some_cpp_function] => i = 0 
     [some_cpp_function] => i = 1 
     [some_cpp_function] => i = 2 
     [some_cpp_function] => i = 3 
     [some_cpp_function] => i = 4 
   [TRACE] call_me() Parameter = <SQUIRREL-INTERPRETER>
   [SQUIRREL] 
   x <-  name = <SQUIRREL-INTERPRETER>

   =>> [EXPERIMENT] 5 - Calling C++ classes from Squirrel        
   ------------------------------------------------------------------

   [ChartXY] Ctor() - I was created!. OK. 
   [ChartXY] draw() => Draw chart with: width = 25 ; height = 10 
   [SQUIRREL LOG] Function draw_with called. OK. 
   [ChartXY] draw() => Draw chart with: width = 100 ; height = 200

   [ChartXY] draw() => Draw chart with: width = 600 ; height = 200


#+END_SRC
** Duktape - Embeddable Javascript Engine 
*** Overview 

  + Duktape is a small footprint embeddable Javascript (ECMAScript)
    engine, written in C, which can be used for providing scripting
    capabilities for C or C++ applications.

  + License: MIT

  + Possible Use Cases:
    + Configuration
    + Data description language
    + User plugins
    + User extensions
    + Scripting for games 

  + Features:
    + Embeddable, portable, compact: can run on platforms with 160kB
      flash and 64kB RAM 
    + Built-in debugger
    + Built-in regular expression engine
    + Minimal, retargetable platform dependencies
    + Combined reference counting and mark-and-sweep garbage
      collection with finalization 
    + Bytecode dump/load for caching compiled functions
    + Distributable includes an optional logging framework,
      CommonJS-based module loading implementations, etc 

 *Official Website* 

  + https://duktape.org/

  + https://duktape.org/download.html
   
 *Official Repository* 

   + https://github.com/svaarala/duktape 

  *C++ Binding Libraries*  

   + https://github.com/Aloshi/dukglue/    

   + https://github.com/stfwi/duktape-cc
*** Example project with DukGlue C++ binding library 

This following project CMakeLists.txt automatically downloads _dukglue_
binding library and _duktape_ engine sources and builds a C++ demonstration
code embedding duktape JavaScript engine. 

  + DukGlue Binding Library: https://github.com/Aloshi/dukglue
    + Advantage:
      * Easy to use and lots of examples. 
    + Drawbacks:
      * Lack of namespaces which enhances API discoverability
      * Lack of C++ wrappers to some Duktape C-types
      * Lack of a CMakeLists.txt at the top directory. 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.0)
  project(duktap-embed)

  include(FetchContent)

  # Download library archive (zip, *.tar.gz, ...) from URL
  macro(Download_Library_Url NAME URL)
    FetchContent_Declare(${NAME} URL  ${URL})
    FetchContent_GetProperties(${NAME})
    if(NOT ${NAME}_POPULATED)
      FetchContent_Populate(${NAME})
     # add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})
    endif()
  endmacro()


  # ====>> Duktape JavaScript Engine Configuration <<===========#

  Download_Library_Url(duktape
    "https://duktape.org/duktape-2.5.0.tar.xz"
    )

  # FetchContent_MakeAvailable(duktape)

  message( [TRACE] " =>> duktape_SOURCE_DIR = ${duktape_SOURCE_DIR} ")


  file(GLOB_RECURSE duktape_sources "${duktape_SOURCE_DIR}/src/*.c")
  file(GLOB_RECURSE duktape_headers "${duktape_SOURCE_DIR}/src/*.h")

  message( [TRACE] " duktape_sources = ${duktape_sources} ")

                add_library (duktape ${duktape_sources} ${duktape_headers} )
  target_include_directories(duktape PUBLIC ${duktape_SOURCE_DIR}/src  )

  # ----------- DukGlue Library ----------------------------#

  FetchContent_Declare(
    dukglue 
    URL       https://github.com/Aloshi/dukglue/archive/master.zip
    )

  FetchContent_MakeAvailable(dukglue)

  #----- Main Target Definition ----------------------------#
  add_executable(duktape-embed duktape-embed.cpp)
  target_link_libraries(duktape-embed duktape dukglue)

#+END_SRC

File: duktape-embed.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string>
   #include <vector>
   #include <cassert> 

   // Repository: https://github.com/Aloshi/dukglue
   #include <dukglue/dukglue.h>

   void print_number(int x)
   {
     std::cout << " [TRACE] number passed is = " << x << std::endl;
   }

   void log_text(std::string const& text)
   {
       std::cout <<  " =>> [C++-LOG] - " << text << std::endl;
   }

   int eval_code(duk_context* ctx, std::string const& code)
   {
       return duk_peval_string(ctx, code.c_str());
   }

   void plot_points(std::vector<float> const& points)
   {
     std::cout << "  =>> [TRACE] Plot points  =>> ";
     for(auto const& x: points) { std::cout << " x = " << x; }
     std::cout << " \n";
   }

   class Counter {
   private: 
       std::string m_name;
       int         m_counter;

   public: 

       // Ctor [1] => Default ctor 
       Counter(): Counter("untitled", 0) { }

       // Ctor [2]
       Counter(std::string name, int counter)
         : m_name{std::move(name)}, m_counter{counter}
       { 
           std::cout << " [TRACE] Counter created with =>  { " 
                     <<   " name = " << m_name 
                     << " ; counter = " << m_counter 
                     << " } \n";
       }

       int getCounter() const { return m_counter; }
       void setCounter(int n) {       
         m_counter = n; 
         std::cout << " [TRACE] I was set to value " << n << std::endl;
       }

       void increment() {       
         m_counter++; 
         std::cout << " [TRACE] increment event =>> counter = {  " 
                   << m_name << " ; " << m_counter 
                   << " } " << std::endl;
       }    

   };


   int main()
   {
         // Create Duktape Virtual machine 
         duk_context* ctx = duk_create_heap_default();

         /* ========================== EXPERIMENT 1 =============*/
         std::puts("\n === [EXPERIMENT 1] ==>> Register and call C++ functions <<===== ");
         {
             // Register pointer to functions function (function pointer) in 
             // the JS engine (aka virtual machine)
             dukglue_register_function(ctx, &print_number, "print_number"); 
             dukglue_register_function(ctx, log_text, "log_text");
             dukglue_register_function(ctx, plot_points, "plot_points");

             const char* code1 = R"(
                 print_number(10);
                 log_text(" Hello world from Javascript" ); 
                 log_text(" Toke is equal to " + 100 ); 
                 log_text( " " + 1000 );      

                 plot_points( [ 20.5, 100.23, -125.254, 8.251, 100.0 ]);
             )";

             // Evaluate code, returns false on error 
             auto n = eval_code(ctx, code1);

             if(n) { std::cerr << " [ERROR] A duktape evaluation error has happened. "  << std::endl; }

         }

         /* ========================== EXPERIMENT 2 ====================*/
         std::puts("\n === [EXPERIMENT 2] ==>> Register and call C++ classes <<===== \n");
         {
             // Register class counter 
             dukglue_register_constructor<Counter>(ctx, "Counter");      
             dukglue_register_constructor<Counter, std::string, int>(ctx,  "Counter");     
             dukglue_register_method(ctx, &Counter::getCounter , "getCounter");
             dukglue_register_method(ctx, &Counter::setCounter , "setCounter");
             dukglue_register_method(ctx, &Counter::increment , "increment");

             dukglue_register_property(ctx                   // Pointer to engine (VM)
                                     , &Counter::getCounter  // Getter 
                                     , &Counter::setCounter  // Setter 
                                     , "number"              // Property name 
                                     );

             int ret = eval_code(ctx, R"( 
                 var counter = new Counter("mycounter", 10); 

                 for(i = 0 ; i < 5; i++) { counter.increment(); }

                 var n = counter.getCounter(); 
                 log_text(" [BEFORE] Counter value = " + n );

                 counter.setCounter(100);
                 log_text(" [AFTER 1 ] Counter value = " + counter.getCounter() );

                 counter.number = 400;
                 log_text(" [AFTER 2] Counter value = " + counter.number );
             )");
             assert( ret == 0 );

         }

         /* ======= Calling Javascript Engine from C++ ====================*/
         // Note: It is useful for reading data or user configuration 
         std::puts("\n === [EXPERIMENT 3] ==>> Calling engine objects from C++ <<===== \n");
         {
             const char* code = R"(
               // Global variables for configuration 
               points = 200; 
               asset_path = "C:\\\\Users\\dummy\\data\\graphics";

               function my_js_function(n){
                   log_text( " <my_js_function> =>> n = " + n );
                   var k = 20 * n + 100;
                   return k; 
               }

             )";
             eval_code(ctx, code);

             // Throws error: DukErrorException
             auto points = dukglue_peval<int>(ctx, "points");
             std::cout << "  [*] =>> points = " << points << std::endl;

             // Throws error: DukErrorException
             auto asset_path = dukglue_peval<std::string>(ctx, "asset_path");
             std::cout << "  [*] =>> asset_path = " << asset_path << std::endl;

             auto jsexpr = dukglue_peval<double>(ctx, "3.51 * 10.52 - 8.251 / 100");
             std::cout << "  [*] jsexpr = " << jsexpr << std::endl;

             // Call Javascript function from C++ 
             auto func = dukglue_peval<DukValue>(ctx, "my_js_function");
             int res = dukglue_pcall<int>(ctx, func, 20);
             std::cout << "  [*] res = " << res << std::endl;

         }

       // Release Javascript engine object (aka virtual machine)
       ::duk_destroy_heap(ctx);

       return 0;
   }

#+END_SRC

Build: 

#+BEGIN_SRC sh 
  $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build _build --target 
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
   $ ./build/duktape-embed 

   === [EXPERIMENT 1] ==>> Register and call C++ functions <<===== 
   [TRACE] number passed is = 10
   =>> [C++-LOG] -  Hello world from Javascript
   =>> [C++-LOG] -  Toke is equal to 100
   =>> [C++-LOG] -  1000
    =>> [TRACE] Plot points  =>>  x = 20.5 x = 100.23 x = -125.254 x = 8.251 x = 100 

   === [EXPERIMENT 2] ==>> Register and call C++ classes <<===== 

   [TRACE] Counter created with =>  {  name = mycounter ; counter = 10 } 
   [TRACE] increment event =>> counter = {  mycounter ; 11 } 
   [TRACE] increment event =>> counter = {  mycounter ; 12 } 
   [TRACE] increment event =>> counter = {  mycounter ; 13 } 
   [TRACE] increment event =>> counter = {  mycounter ; 14 } 
   [TRACE] increment event =>> counter = {  mycounter ; 15 } 
   =>> [C++-LOG] -  [BEFORE] Counter value = 15
   [TRACE] I was set to value 100
   =>> [C++-LOG] -  [AFTER 1 ] Counter value = 100
   [TRACE] I was set to value 400
   =>> [C++-LOG] -  [AFTER 2] Counter value = 400

   === [EXPERIMENT 3] ==>> Calling engine objects from C++ <<===== 

    [*] =>> points = 200
    [*] =>> asset_path = C:\\Users\dummy\data\graphics
    [*] jsexpr = 36.8427
   =>> [C++-LOG] -  <my_js_function> =>> n = 20
    [*] res = 500


#+END_SRC
*** Example project with Duktape-CC binding library 

  + Duktape-CC binding library: https://github.com/stfwi/duktape-cc/
    + Benefits 
      + Namespace 
      + RAII for duktape C-API
      + Javascript common known APIs such as console.log()
    + Disadvantage:
      + No possible to bind lambda function. 
      + No possible to bind C++ classes or objects
      + No CMakeLists.txt at top directory, which makes the library
        usage easier, but the following cmake scripts solves this
        problem.


File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.0)
  project(duktape-cc-trial)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  include(duktape.cmake)

  #----- Main Target Definition ----------------------------#
         add_executable( duktape-script duktape-script.cpp)
  target_link_libraries( duktape-script duktape-cc )
#+END_SRC

File: duktape.cmake 

#+BEGIN_SRC cmake 
   include(FetchContent)

   # Note: the 'add_subriectory' line was commented becuyase 
   #       library that will be downloaded does not have 
   #       a CMakeListst.txt file at the root directory. 
   macro(Download_Library_Git  NAME TAG REPOSITORY_URL)
       FetchContent_Declare(
           ${NAME}
           GIT_REPOSITORY  ${REPOSITORY_URL}
           GIT_TAG         ${TAG}
       )
       FetchContent_GetProperties(${NAME})
       if(NOT cpputest_POPULATED)
           FetchContent_Populate(${NAME})
           message("${NAME}_SOURCE_DIR} = ${${NAME}_SOURCE_DIR}")        

           # => Disable following line: the library does not have a CMakeLists.txt
           #    at the root directory.
           # add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})
       endif()
   endmacro()


   # ====>> Duktape JavaScript Engine Configuration <<===========#

   Download_Library_Git( duktape-cc 
                         51fed200b0c3353a60fa560aa8a13a480f0ec0c7
                         https://github.com/stfwi/duktape-cc/
                       )

   file(GLOB_RECURSE duktape_sources "${duktape-cc_SOURCE_DIR}/duktape/*.c")
   file(GLOB_RECURSE duktape_headers1 "${duktape-cc_SOURCE_DIR}/duktape/*.hh")
   file(GLOB_RECURSE duktape_headers2 "${duktape-cc_SOURCE_DIR}/duktape/*.h")

                  add_library( duktape-cc ${duktape_sources} ${duktape_headers1} ${duktape_headers2} )
   target_include_directories( duktape-cc PUBLIC ${duktape-cc_SOURCE_DIR} )

#+END_SRC

File: duktape-script.cpp 

#+BEGIN_SRC cpp 
   #include <iostream> 
   #include <string> 
   #include <vector> 
   #include <fstream>

   #include <duktape/duktape.hh>
   #include <duktape/mod/mod.stdio.hh>

   int main()
   {
       std::puts(" [TRACE] Program started Ok. ");

       // Create Duktape Engine object (Virtual Machine)
       auto ctx = duktape::engine{};

       // Load all functions from stdio module 
       // ==> Note: It is necessary for console.log() work 
       duktape::mod::stdio::define_in(ctx);   


       std::puts("\n [EXPERIMENT 1] ======= Evaluate string as code ========");

       ctx.eval<void>(R"( 
           console.log(" [INFO] Hello world Javascript Engine ");

           var i = 0;
           while(i < 5) {
               console.log(" [TRACE] <ducktape>  i = " + i);
               i++;
           }
       )");

       std::puts("\n [EXPERIMENT 2] == Read/write values to the engine the engine =");

       // Write or pass values to the engine. 
       ctx.define("app.version", "0.251");
       ctx.define("user.points", 1000);
       ctx.define("array1", std::vector<double>{ 4.51, 9.25, -25.154, 205.2 });
       ctx.define("array2", std::vector<std::string>{ "C++", "ADA-Spark", "Rust", "Dlang", "OCaml" });

       std::string script_file = "/tmp/myscript.js";

       const char* script_code = R"(
           console.log("  => app.version = " + app.version );
           console.log("  => user.points = " + user.points );
           console.log("  => array1 = " + array1);
           console.log("  => array2 = " + array2);

           myconfig_path = "/Users/data/osx/config";
           user_credits = 1020; 
           vector = [100.25, 90.251, -120.5150];
       )";

       // Write script code to file     
       auto fs = std::ofstream(script_file);
       // Flush forces writing to the IO
       fs << script_code << std::flush;          
       // Execute script from file 
       ctx.include(script_file);

       std::cout << " ---- Read configuration from file " << std::endl; 

       // Throws exception: duktape::detail::basic_script_error<void>
       auto myconfig_path = ctx.eval<std::string>("myconfig_path");
       auto credits       = ctx.eval<int>("user_credits");
       auto vec           = ctx.eval<std::vector<double>>("vector");
       std::cout << "\n\n[*] my_config_path = " << myconfig_path << "\n";
       std::cout << "[*]   user_credits = " << credits << "\n";
       std::cout << "[*] vec[0] = " << vec[0] << " ; vec[1] = " << vec[1] << "\n";    

       return 0;
   }
#+END_SRC

Build: 

#+BEGIN_SRC sh 
  $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build _build --target 
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
   $ _build/duktape-script 
   [TRACE] Program started Ok. 

   [EXPERIMENT 1] ======= Evaluate string as code ========

   [EXPERIMENT 2] == Read/write values to the engine the engine =
   [INFO] Hello world Javascript Engine 
   [TRACE] <ducktape>  i = 0
   [TRACE] <ducktape>  i = 1
   [TRACE] <ducktape>  i = 2
   [TRACE] <ducktape>  i = 3
   [TRACE] <ducktape>  i = 4
    => app.version = 0.251
    => user.points = 1000
    => array1 = 4.51,9.25,-25.154,205.2
    => array2 = C++,ADA-Spark,Rust,Dlang,OCaml
   ---- Read configuration from file 


  [*] my_config_path = /Users/data/osx/config
  [*]   user_credits = 1020
  [*] vec[0] = 100.25 ; vec[1] = 90.251

#+END_SRC
** QuickJS - ES20 Javascript Engine 

QuickJS is small and lightweight embeddable Javascript engine, written
in C, which supports ES2020 technical specification. This engine was
created by Fabrice Bellard, creator of many widely used open source
projects, namely, QEMU emulator used for emulation of operating
systems and embedded systems hardware; FFmpeg tool for video and audio
conversion; TCC (Tiny C Compiler). Some features supported by the
engine are: modules, proxies, BigInt and asynchronous generators.
 
   + QuickJS Web Site:
     + https://bellard.org/quickjs/quickjs.html

   + QuickJS Repository:
     + https://github.com/bellard/quickjs

   + QuickJSpp C++ Wrapper Repository (License: CC0)
     + https://github.com/ftk/quickjspp 

See also: 

  + [[https://dev.to/carlillo/es2020-features-in-simple-examples-1513][ES2020 Features in simple examples - DEV]]

  + [[https://gist.github.com/revolunet/537a3448cff850231a74][Python VS JavaScript ES6 syntax comparison · GitHub]] 
 
  *Sample CMake project* 

The following sample CMake projects demonstrates how to embed QuickJS
engine in a C++ code by using the QuickJSpp C++ wrapper. The CMake
script (CMakeLists.txt) downloads the QuickJS source code from its
repository and creates static library target for the JavaScript engine
which is then linked against the sample application embedding
QuickJS. This CMakeLists.txt script fully automates all steps, which relieves
the library user from installing QuickJS manually by using GNU make,
which is the original building system used by the engine. 

GIST Containing all sources: 

  + https://gist.github.com/1abdd1d36cd3e973cd1f11f5c20ef7eb 

File: _CMakeLists.txt_ 

#+BEGIN_SRC cmake 
    cmake_minimum_required(VERSION 3.9)
    project(QuickJS-Experiment)

    #========== Global Configurations =============#
    #----------------------------------------------#

    set( CMAKE_CXX_STANDARD     17 )
    set( CMAKE_VERBOSE_MAKEFILE ON )
    set( CMAKE_CXX_EXTENSIONS   OFF)

    # ------------ Download CPM CMake Script ----------------#

    ## Automatically donwload and use module CPM.cmake
    file(DOWNLOAD https://raw.githubusercontent.com/TheLartians/CPM.cmake/v0.26.2/cmake/CPM.cmake
                     "${CMAKE_BINARY_DIR}/CPM.cmake")
    include("${CMAKE_BINARY_DIR}/CPM.cmake")

    #----------- Add dependencies --------------------------#

    CPMAddPackage(
        NAME               quickjs 
        GITHUB_REPOSITORY  bellard/quickjs
        GIT_TAG            204682fb87ab9312f0cf81f959ecd181180457bc
        # DOWNLOAD_ONLY YES
        )


    # Add this directory where is this file (CMakeLists.txt) to include path. 
    include_directories( ${CMAKE_CURRENT_LIST_DIR} )

    # =============== QuickJS settings ====================================#

    include_directories( ${quickjs_SOURCE_DIR}/ )
    message([TRACE] " quickjs source = ${quickjs_SOURCE_DIR} ")

    file(GLOB quickjs_hpp ${quickjs_SOURCE_DIR}/*.h )

    file(GLOB quickjs_src ${quickjs_SOURCE_DIR}/quickjs.c 
                          ${quickjs_SOURCE_DIR}/libregexp.c 
                          ${quickjs_SOURCE_DIR}/libunicode.c  
                          ${quickjs_SOURCE_DIR}/cutils.c 
                          ${quickjs_SOURCE_DIR}/quickjs-libc.c 
                          ${quickjs_SOURCE_DIR}/libbf.c 
                          )


                   add_library( qjs-engine ${quickjs_src} ${quickjs_hpp} )
        target_compile_options( qjs-engine PRIVATE
                                    -MMD -MF
                                    -Wno-sign-compare 
                                    -Wno-missing-field-initializers 
                                    -Wundef -Wuninitialized 
                                    -Wundef -Wuninitialized -Wwrite-strings -Wchar-subscripts
                              )
    target_compile_definitions( qjs-engine PUBLIC 
                                           CONFIG_BIGNUM=y
                                           CONFIG_VERSION="2020-11-08"
                                           _GNU_SOURCE
                               )

    if(UNIX)
        target_link_libraries( qjs-engine PRIVATE m pthread dl)
    endif()

    # =========== Target Settings =========================================#

                # QuickJS compiler. 
                add_executable( qjsc ${quickjs_SOURCE_DIR}/qjsc.c )
    target_compile_definitions( qjsc  PUBLIC  CONFIG_BIGNUM=y  CONFIG_VERSION="2020-11-08"  _GNU_SOURCE )            
         target_link_libraries( qjsc  qjs-engine )

                # Sample application that embeds the quickJS Javascript engine. 
           add_executable( main main.cpp   )
    target_link_libraries( main qjs-engine )
#+END_SRC

File: _main.cpp_ 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <quickjspp.hpp>

  class ChartXY
  {
  private:
      double x = 0.0, y = 0.0;
      double width = 100.0, height = 100.0;
  public:
      ChartXY()
      { }
    
      ChartXY(double w, double h): width(w), height(h) 
      { }

      void show() const 
      {
        std::cout << " [ĆhartXY Object] x = " << x << " ; y = " << y 
                  << " ; width = " << width << " height = " << height 
                  << '\n';
      }

      void set_width(double width) 
      {  
          this->width = width; 
          std::fprintf(stdout, " [ChartXY] Width set to %f \n", width);
        
      }
    
      void set_height(double height)
      { 
          this->height = height; 
          std::fprintf(stdout, " [ChartXY] Height set to %f \n", height);        
      }

      double get_height() const { return this->height; }
      double get_width () const { return this->width; }

      void plot_points(std::vector<double> const& points)
      {
          std::cout << " [ChartXY] Plotting points =>> ";
          for(auto p : points) { std::cout << " " << p; }
          std::cout << "\n";
      }
  };

  qjs::Value
  try_eval_module(
               qjs::Context& context
             , qjs::Runtime& runtime
             , std::string const& code)
  {
        try
        {
            return context.eval(code, "<eval>", JS_EVAL_TYPE_MODULE);
        } catch( const qjs::exception& ex)
        {
              //js_std_dump_error(ctx);
              auto exc = context.getException();
              std::cerr << (exc.isError() ? "Error: " : "Throw: ") << (std::string)exc << std::endl;
              if((bool)exc["stack"])
                  std::cerr << (std::string)exc["stack"] << std::endl;

              js_std_free_handlers(runtime.rt);
              return context.newObject();
        }

  }

  int main(int argc, char** argv)
  {
      std::cout << " [INFO] Started Ok" << std::endl; 
    
      using namespace qjs;

      Runtime runtime;
      //JSRuntime* rt = runtime.rt;

      Context context(runtime);
      //JSContext* ctx = context.ctx;

      js_std_init_handlers(runtime.rt);
    
      /* loader for ES6 modules */
      JS_SetModuleLoaderFunc(runtime.rt, nullptr, js_module_loader, nullptr);
    
      js_std_add_helpers(context.ctx, argc - 1, argv + 1);

      /* system modules */
      js_init_module_std(context.ctx, "std");
      js_init_module_os(context.ctx, "os");

      std::fprintf(stderr, " [TRACE] Before loading code. \n");

      const char* str = R"(
              /*
              import * as std from 'std';
              import * as os from 'os';
              globalThis.std = std;
              globalThis.os = os;
              ,*/

              console.log(" [QUICJS] => =>> Script loaded. Ok. \n");

              for(n = 1; n <= 5; n++){
                  console.log(` [QUICKJS-TRACE] n = ${n}/5 `);
              }

              // ----- Define user variables here ----

              asset_path = "/Users/mydir-macosx/data/blackjack.txt";
              game_score = 0.25156;

              let x = 10.352;
              datapoints = [ 0.251, 19.2363, 9.262, 100.125 ];

              console.log(`\n  [QUICKJS] asset_path = ${asset_path}` );
              console.log(`   [QUICKJS] score = ${100.0 * game_score} (in percent) \n`);
              console.log(`   [QUICKJS] data points = ${datapoints} `)
        )";

      try
      {
           context.eval(str); //, "", JS_EVAL_TYPE_MODULE);
      } catch( const qjs::exception& ex)
      {
            //js_std_dump_error(ctx);
            auto exc = context.getException();
            std::cerr << (exc.isError() ? "Error: " : "Throw: ") << (std::string)exc << std::endl;
            if((bool)exc["stack"])
                std::cerr << (std::string)exc["stack"] << std::endl;

            js_std_free_handlers(runtime.rt);
            return 1;
      }

      std::fprintf(stderr, " [TRACE] After loading code. \n");


      int number = (int) context.eval(" 10 * (3 + 1 + 10 ) - 1000 * 2");                               
      std::cout << " [RESULT] number = " << number << '\n';
        
      std::puts("\n [*] ===== Read configuration variables defined in the js code. ====\n");    
      {
          auto var_asset_path = context.global()["asset_path"].as<std::string>();
          std::cout << "    =>> asset_path = " << var_asset_path << '\n';

          auto score = context.global()["game_score"].as<double>();
          std::cout << "    =>> game_score (%) = " << 100.0 * score << '\n';

          auto points = context.global()["datapoints"].as<std::vector<double>>();
          std::cout << "    ==>> datapoints = [" << points.size() << "]( ";
          for(auto p : points) {  std::cout << p << ' '; }
          std::cout << " ) \n";
      }

      std::puts("\n [*] ===== Define variables in C++-side  ====\n");    
      { 
        
          context.global()["user_name"]   = context.newValue("Gaius Julius Caesar");
          context.global()["user_points"] = context.newValue(101235);

          auto data = std::vector<std::string>{ "ADA", "RUST", "C++11", "C++17", "C++20"
                                              , "Dlang", "OCaml", "C#(Csharp)" };

          context.global()["user_data"] = context.newValue(data);         

          // Note: This code should be within an exception handler. 
          context.eval(R"(
              console.log(` [STEP 2] user_name = ${user_name} ; points = ${user_points} `);
              console.log(` [STEP 2] user_data = ${user_data} ; type = ${ typeof(user_data) } `);
              console.log(` [STEP 2] user_data[5] = ${ user_data[5] } `)

              // Iterate over the array 
              for(let x in user_data){ console.log(user_data[x]); }
          )");          

      }

      std::puts("\n [*] ===== Register class ChartXY   ====\n");    

      auto& module = context.addModule("chart");
      module.class_<ChartXY>("ChartXY")
        .constructor() 
        .constructor<double, double>()
        .fun<&ChartXY::show>("show")
        .fun<&ChartXY::set_height>("set_height")
        .fun<&ChartXY::set_width>("set_width")
        .fun<&ChartXY::plot_points>("plot_points")
        .property<&ChartXY::get_width,  &ChartXY::set_width>("width")      
        .property<&ChartXY::get_height, &ChartXY::set_height>("height")      
        ;  

      module.add("user_path", "/Users/data/assets/game/score/marks");
      module.add("user_points", 1023523);

      module.function("myfunc", [](double x, double y){ return 4.61 * x + 10 * y * y; });

      const char* module_code = R"(
          import { ChartXY } from "chart";

          import * as chart from "chart"

          console.log(` [SCRIPT] chart.user_path = ${chart.user_path} \n\n`);
          console.log(` [SCRIPT] chart.user_points = ${chart.user_points} \n\n`);

          console.log(` [SCRIPT] Result = ${ chart.myfunc(5.61, 9.821) } \n`);

          let ch = new ChartXY(200, 600);
          ch.show();

          ch.set_width(800.0);
          ch.set_height(700.0)
          ch.show();

          console.log("   [QUICKJS] Change chart dimensions using properties ");
          ch.width = 500;
          ch.height = 660;

          console.log(`\n   <QUICKJS> Chart width = ${ch.width} ; Chart height = ${ch.height} \n`);

          ch.plot_points( [ 10.522, 8.261, -100.24, 7.2532, 56.123, 89.23 ] );
      )";

      try_eval_module(context, runtime, module_code);

      js_std_loop(context.ctx);
      // ----- Shutdown virtual machine ---------------// 
      js_std_free_handlers(runtime.rt);
    
      return 0;
  }
#+END_SRC

  *Building and Running* 

Download sources: 

#+BEGIN_SRC sh 
   $ git clone https://gist.github.com/1abdd1d36cd3e973cd1f11f5c20ef7eb qqjs && cd qqjs 

   $ ls
  CMakeLists.txt  main.cpp  quickjspp.hpp
#+END_SRC

Building: 

#+BEGIN_SRC sh 
   $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug 
   $ cmake --build _build --target
#+END_SRC

Running qjsc (QuickJS - transpiler or C code generator)

#+BEGIN_SRC text 
     $ _build/qjsc 
    QuickJS Compiler version 2020-11-08
    usage: qjsc [options] [files]

    options are:
    -c          only output bytecode in a C file
    -e          output main() and bytecode in a C file (default = executable output)
    -o output   set the output filename
    -N cname    set the C name of the generated data
    -m          compile as Javascript module (default=autodetect)
    -D module_name         compile a dynamically loaded module or worker
    -M module_name[,cname] add initialization code for an external C module
    -x          byte swapped output
    -p prefix   set the prefix of the generated C names
    -S n        set the maximum stack size to 'n' bytes (default=262144)
#+END_SRC

Running _main_ application, which embeds QuickJS JS engine:  

#+BEGIN_SRC text 
    $ >> _build/main 
    [INFO] Started Ok
    [TRACE] Before loading code. 
    [QUICJS] => =>> Script loaded. Ok. 

    [QUICKJS-TRACE] n = 1/5 
    [QUICKJS-TRACE] n = 2/5 
    [QUICKJS-TRACE] n = 3/5 
    [QUICKJS-TRACE] n = 4/5 
    [QUICKJS-TRACE] n = 5/5 

     [QUICKJS] asset_path = /Users/mydir-macosx/data/blackjack.txt
      [QUICKJS] score = 25.156 (in percent) 

      [QUICKJS] data points = 0.251,19.2363,9.262,100.125 
    [TRACE] After loading code. 
    [RESULT] number = -1860

    [*] ===== Read configuration variables defined in the js code. ====

       =>> asset_path = /Users/mydir-macosx/data/blackjack.txt
       =>> game_score (%) = 25.156
       ==>> datapoints = [4]( 0.251 19.2363 9.262 100.125  ) 

    [*] ===== Define variables in C++-side  ====

    [STEP 2] user_name = Gaius Julius Caesar ; points = 101235 
    [STEP 2] user_data = ADA,RUST,C++11,C++17,C++20,Dlang,OCaml,C#(Csharp) ; type = object 
    [STEP 2] user_data[5] = Dlang 
   ADA
   RUST
   C++11
   C++17
   C++20
   Dlang
   OCaml
   C#(Csharp)

    [*] ===== Register class ChartXY   ====

    [SCRIPT] chart.user_path = /Users/data/assets/game/score/marks 


    [SCRIPT] chart.user_points = 1023523 


    [SCRIPT] Result = 990.3825099999999 

    [ĆhartXY Object] x = 0 ; y = 0 ; width = 200 height = 600
    [ChartXY] Width set to 800.000000 
    [ChartXY] Height set to 700.000000 
    [ĆhartXY Object] x = 0 ; y = 0 ; width = 800 height = 700
      [QUICKJS] Change chart dimensions using properties 
    [ChartXY] Width set to 500.000000 
    [ChartXY] Height set to 660.000000 

      <QUICKJS> Chart width = 500 ; Chart height = 660 

    [ChartXY] Plotting points =>>  10.522 8.261 -100.24 7.2532 56.123 89.23

#+END_SRC

** Chaiscript 

Scripting engine available as a header-only library that has
Javascript-like syntax and easy integration to C++ codebases.

Drawbacks: 
   + Header-only => Slow compile-time and large executable size due to
     the intesive use of templates. [[https://arne-mertz.de/2019/02/extern-template-reduce-compile-times/][Extern templates]] C++ language
     feature could reduce the compile time. 

Repository: 
  + https://github.com/ChaiScript/ChaiScript

Web site: 
  + https://chaiscript.com/examples.html  


  *Files* 

File: _CMakeLists.txt_ 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.0)
  project(chaiscript-eval)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  include( FetchContent )

  set( BUILD_SAMPLES  OFF CACHE BOOL  "") 
  set( BUILD_SAMPLES  OFF CACHE BOOL  "") 
  set( RUN_FUZZY_TESTS OFF CACHE BOOL "")
  set( RUN_PERFORMANCE_TESTS  OFF CACHE BOOL "")

  FetchContent_Declare(
       chaiscript 
       GIT_REPOSITORY  https://github.com/ChaiScript/ChaiScript/
       GIT_TAG         v6.1.0     
  )
  FetchContent_MakeAvailable(chaiscript)
  include_directories( chaiscript-runtime PUBLIC ${chaiscript_SOURCE_DIR}/include )    

  add_executable( runner chaiscript-eval.cpp)

  if(UNIX)
      target_link_libraries( runner PUBLIC pthread dl )
  endif()
#+END_SRC  

File: _chaiscript-eval.cpp_ 

#+BEGIN_SRC cpp 
  #include <iostream> 
  #include <string> 

  #include <chaiscript/chaiscript.hpp>

  void scriptable_function(const std::string& label, int w) 
  {
      std::cout << "\n [CALLED] label = " << label << " ; w = " << w << '\n';
  }

  class Robot
  {
      std::string name;
      float x = 0, y = 0;
  public:

      Robot(){ }

      Robot(float x, float y){}

      void setPosition(float x, float y)
      {
          this->x = x;
          this->y = y;
          std::fprintf(stderr, " [INFO] Robot moved to x = %f ; y = %f \n", x, y);
      }   

      void showPosition()
      {
        std::fprintf(stderr, " [INFO] Robot position (x = %f, y = %f ) \n", x, y);
      }
  };


  int main() {
  
    // Create script engine object 
    chaiscript::ChaiScript chai;

    // Register user function   
    chai.add( chaiscript::fun(&scriptable_function)
            , "scriptable_function");

    chai.add( chaiscript::constructor<Robot()>(), "Robot" );
    chai.add( chaiscript::fun(&Robot::showPosition), "showPosition");
    chai.add( chaiscript::fun(&Robot::setPosition),  "setPosition" );

    const char* code = R"(
          // It supports C++-like syntax 
          for(var i = 0; i < 5; ++i)
          { 
              print(i);
          }

          puts(" ========= Line ================= \n");
          scriptable_function("Moon", 200);
          scriptable_function("Mars", 500);

          var robot = Robot();
          robot.setPosition(200, 400);
          robot.showPosition();

          // User configuration function will be called 
          // by the script engine. 

          def on_init_hook()
          {
              puts("\n [TRACE] User function called. Ok.");
          }

      )";

    // Attempt to evaluate code 
    try { 
        chai.eval(code);
    } catch(chaiscript::exception::eval_error const& ex)
    {
        std::cout << " [TRACE] Exception = " << ex.what() << std::endl;
    }

    std::puts(" ==== Get robot object from script =========");

    auto robot = chai.eval<std::shared_ptr<Robot>>("robot");
  
    robot->showPosition();
    robot->setPosition(400, 1000);

  } // ---- End of main() ----------// 
#+END_SRC

 *Check Executable* 

#+BEGIN_SRC sh 
  $ du -h build/runner
  23M     build/runner

  # Remove debugging symbols 
  $ strip build/runner
  $ du -h build/runner
  7.6M    build/runner

  $ file build/runner
  build/runner: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2
#+END_SRC  

 *Running* 

#+BEGIN_SRC sh 
  $ ./runner 
  0
  1
  2
  3
  4
   ========= Line ================= 

   [CALLED] label = Moon ; w = 200

   [CALLED] label = Mars ; w = 500
   [INFO] Robot moved to x = 200.000000 ; y = 400.000000 
   [INFO] Robot position (x = 200.000000, y = 400.000000 ) 
   ==== Get robot object from script =========
   [INFO] Robot position (x = 200.000000, y = 400.000000 ) 
   [INFO] Robot moved to x = 400.000000 ; y = 1000.000000 
#+END_SRC
** Python Engine via Pybind11 

Documentation: 

  + [[https://pybind11.readthedocs.io/en/stable/advanced/embedding.html][Pybind11 Embedding]]

Advantages: 
  + High popularity
  + Lost of libraries
  + Easy usage 

Drawbacks: 
  + Hard to static link
  + Not ligthweight and designed to be embedded as Lua.
  + It is not possible to run multiple instances of the Python
    interpreter.
  + It is not possible to sandbox the interpreter and restrict
    accessing files or process manipulation APIs.
  + Requires pre-installation of Python development headers. But, it
    can be mitigated by using Anaconda or miniconda Python distributions.

Known Cases: 
  + GDB - GNU Debugger 
  + IDA Debugger
  + Sublime Text Editor 

 *Sample Project* 

GIST containing the sources: 
  + https://gist.github.com/d7fda02034757374a0b0114e54c7daff

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.9)
   project(embed-python-scripting)

   #========== Global Configurations =============#
   #----------------------------------------------#

   set(CMAKE_CXX_STANDARD 17)     
   set(CMAKE_VERBOSE_MAKEFILE ON)
   set(CMAKE_CXX_EXTENSIONS OFF)

   # ------------ Download CPM CMake Script ----------------#

   ## Automatically donwload and use module CPM.cmake
   file(DOWNLOAD https://raw.githubusercontent.com/TheLartians/CPM.cmake/v0.26.2/cmake/CPM.cmake
                    "${CMAKE_BINARY_DIR}/CPM.cmake")
   include("${CMAKE_BINARY_DIR}/CPM.cmake")

   #----------- Add dependencies --------------------------#

   find_package(PythonLibs REQUIRED)

   CPMAddPackage(
       NAME pybind11 
       URL  https://github.com/pybind/pybind11/archive/v2.5.zip    
       DOWNLOAD_ONLY true  
   )

   # add_subdirectory( {pybind11_SOURCE_DIR} )
   include_directories( ${pybind11_SOURCE_DIR}/include
                        ${PYTHON_INCLUDE_PATH} )

   message( [TRACE] "  pybind11_SOURCE_DIR = ${pybind11_SOURCE_DIR} ")

   # configure_file(script.py ${CMAKE_BINARY_DIR} COPYONLY )

   #----------- Set targets -------------------------------#

   add_executable(app1 app1.cpp)
   target_link_libraries( app1 ${PYTHON_LIBRARIES} )

   add_custom_command(
           TARGET app1 POST_BUILD
           COMMAND ${CMAKE_COMMAND} -E copy
                   ${CMAKE_SOURCE_DIR}/script.py 
                   ${CMAKE_CURRENT_BINARY_DIR}/script.py)

#+END_SRC

File: app.cpp 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string> 
  #include <sstream>
  #include <fstream>
  #include <cassert>
  #include <vector> 

  #include <pybind11/embed.h>

  namespace py = pybind11;

  // Requires: <string>, <stream>, <sstream>
  std::string readFile(std::string const& file)
  {
      auto is = std::ifstream(file);
      if( !is.good() ){
          throw std::runtime_error("Error: stream has errors.");
      }
      std::stringstream ss;
      ss << is.rdbuf();
      return ss.str();
  }


  int main(int argc, char** argv)
  {
      extern std::string pycode;

      auto guard = py::scoped_interpreter{};

      // ------ EXPERIMENT 1 ------------------------------------// 
      std::puts(" [EXPERIMENT 1] ===== Execute Python code ======================\n");

      auto code = readFile("./script.py");

      // std::cout << " code = " << code << "\n";

      auto g = py::globals();

      // Define global variables for the interpreter global scope 
      g["game_assets"] = "/Users/myuser/game_assets";
      g["speed"]       = 20.151;
      g["z_value"]     = 100;    

      // Evaluate Python code
      try {        
          py::exec( code, g );

      } catch(pybind11::error_already_set const& ex) {
          std::cerr << " [PYBIND11 ERROR] " << ex.what() << std::endl;
          return EXIT_FAILURE;
      }

      // ------ EXPERIMENT 2 ------------------------------------// 
      std::puts("\n [EXPERIMENT 2] == Read user defined configuration variables ===\n");

      auto v_x    = g["x"].cast<double>();
      auto v_path = g["path"].cast<std::string>();

      std::cout << " [*]    v_x = " << v_x << std::endl;
      std::cout << " [*] v_path = " << v_path << std::endl;

      return EXIT_SUCCESS;
  }

  // ----- Internal Python Embedded Module ---------------------------// 


  const char* version()
  {
      return "SampleModule Version 3.451-ZETA";
  }

  // Sample "function-object class"
  class LinearFunctor
  {
  public:
      double A = 0, B = 0;

      LinearFunctor();
      LinearFunctor(double a, double b): A(a), B(b){ }

      double GetA() const   { return A; }
      void   SetA(double a) { A = a; }
      double GetB() const   { return B; }
      void   SetB(double b) { B = b; }

      void show() const
      {
          std::cout << " LinearFunction: y(x) = A * x + B" << std::endl;
          std::cout << " => A = " << this->A << " ; B = " << this->B << std::endl;
      }
      std::string toString() const
      {
          std::stringstream ss;
          ss << " LinearFunction: y(x) = A * x + B" << std::endl;
          ss << " => A = " << this->A << " ; B = " << this->B << std::endl;
          return ss.str();
      }
      // Function-call operator
      double operator()(double x)
      {
          return A * x + B;
      }
  };

  // ---- Internal Module -----------------------// 

  PYBIND11_EMBEDDED_MODULE(SampleModule, m) {
      // optional module docstring
      m.doc() = "Sample Python built with C++ CeePlusPlus ";
      m.def("version", &version, "Show Library Version");

      m.def("cppLambda"
            ,[](double x, double y){ return 3.0 * x + y;}
            ,"A C++ lambda object or functor"
            //,py::arg("x"), py::args("y") = 15
      );

      // Register LinearFunction
      py::class_<LinearFunctor>(m, "LinearFunctor")
              .def(py::init<double, double>())             // Register overloaded consructor
              .def("GetA", &LinearFunctor::GetA)            // Reister method GetA()
              .def("GetB", &LinearFunctor::GetB)            // Register method GetB()
              .def("SetA", &LinearFunctor::SetA)            // Reister method GetA()
              .def("SetB", &LinearFunctor::SetB)            // Register method GetB()
              .def("show", &LinearFunctor::show)            // Register method show
              .def("call", &LinearFunctor::operator())      // Register function-call operator with name 'call'
              .def("__call__", &LinearFunctor::operator ()) // Register fun-call operator
              .def("__repr__", &LinearFunctor::toString)    // Register strin representation
              .def_readwrite("A", &LinearFunctor::A)        // Register field A
              .def_readwrite("B", &LinearFunctor::B);       // Register field B

  } /** --- End of PYBIND11_MODULE registration --- */

#+END_SRC

File: script.py 

#+BEGIN_SRC python 
   print("   => game_assets = ", game_assets)
   print("   =>       speed = ", speed)
   print("   =>     z_value = ", z_value)

   x: float = 10.0 * 20.51 / 200

   path = "C:\\\\Users\\dummy\\Documents\\data"

   print(" [PYTHON] The value of x = ", x)

   for i in range(5):
       print("   [PYTHON] i = ", i)

   # It is not possible to restrict the interpreter!
   import os 
   print(" [*] Current path = ", os.getcwd() )

   print("\n ------------------------------------------")
   print("\n =>>> Test Python Internal Module (C++) <<=\n")

   import SampleModule as m 
   from SampleModule import LinearFunctor 

   print(f"    ->   Module Information = [{m.__doc__}] ")
   print( "    ->       Module Version = ", m.version())
   print( "    -> m.cppLambda(100, 25) = ", m.cppLambda(100, 25) )

   functor = LinearFunctor(8.0, -10.0)
   print(f"\n C++ Functor -> ${functor} ")

   print(" functor(5.0) = ", functor(5.0))
   print(" functor(8.0) = ", functor(8.0))

#+END_SRC

Build and running: 

#+BEGIN_SRC sh 
  $ cd /tmp 
  $ git clone https://gist.github.com/d7fda02034757374a0b0114e54c7daff python-embed-script 
  $ cd python-embed-script

  $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build _build --target 
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
  $ _build/app1 

   [EXPERIMENT 1] ===== Execute Python code ======================

     => game_assets =  /Users/myuser/game_assets
     =>       speed =  20.151
     =>     z_value =  100
   [PYTHON] The value of x =  1.0255
     [PYTHON] i =  0
     [PYTHON] i =  1
     [PYTHON] i =  2
     [PYTHON] i =  3
     [PYTHON] i =  4
   [*] Current path =  /home/mxpkf8/temp-projects/python-embed-script

   ------------------------------------------

   =>>> Test Python Internal Module (C++) <<=

      ->   Module Information = [Sample Python built with C++ CeePlusPlus ] 
      ->       Module Version =  SampleModule Version 3.451-ZETA
      -> m.cppLambda(100, 25) =  325.0

   C++ Functor -> $ LinearFunction: y(x) = A * x + B
   => A = 8 ; B = -10

   functor(5.0) =  30.0
   functor(8.0) =  54.0

   [EXPERIMENT 2] == Read user defined configuration variables ===

   [*]    v_x = 1.0255
   [*] v_path = C:\\Users\dummy\Documents\data

#+END_SRC
** Scheme-like lisp interpreter in C++
*** Overview

Scheme is a simple dialect of lisp with several functional-programming
features. Functions are first class citizens, they can be passed as
argument to other functions and returned from functions. Everything is
an expression and evaluates to something, even assignments and if-else
statements. Some versions of scheme also feature tail-call
optimization that allow writing tail-recursive functions to be
converted to loop without creating excessive stack frames.

This section presents a lisp-like interpreter based on _Scheme_,
implemented using modern C++ features and object oriented design
patterns with a handwritten parser and lexer. This lisp interpreter is
based on [[https://norvig.com/lispy.html][lispy]], a lisp interpreter written in Python. Just like lispy,
this implementation is easy to understand and can be easily be embedded in
C++ applications for adding scripting capabilities or ursing
S-expressions as a DSL (Domain-Specific Language) or data description
language. 


Techniques used in this implementation: 

  + Smart pointers are used for memory managment.
    
  + _Composite design pattern_ for representing the AST

  + Visitor design pattern is used for traversing the AST and
    implementing AST printing. In a functional programming language
    with proper sum types (also known as variants or discriminated
    unions), the visitor could be replaced by _pattern matching_.

  + Inheritance is used for representing _sum types_ or _discriminated_
    _unitons_, common in functional programming languages.  The AST
    (Abstract Syntax Tree) nodes, including atoms and lists, are
    represented by classes inheriting from _IEXpr_ abstract class.

  + The interpreter uses direct recursive evaluation of the AST just
    like the inspiration [[https://norvig.com/lispy.html][lispy]].

  + Lists are not implemented using linked lists, instead they are
    implemented using std::vector container.

  + Besides the recursive abstract syntax tree evaluation
    implementation, the interpreter could also be implemented using a
    SECD (stack-environment-control-dump) virtual machine.

  + This implementation uses the _fn_ keyword instead of _lambda_; _def_
    instead of _define_ for creating named functions; and _set_ instead of
    _define_ for defining variables.


Possible implementation techniques of Lisp-like languages: 

  + Recursive AST (Abstract Syntax Tree) evaluation
    
  + SECD (stack-environment-control-dump) virtual/abstract machine 

  + _Meta-circular evaluator_ => Implement lisp-like dialects on top of
    an existing lisp implementation such as Common Lisp.

  + Compile lisp dialect to bytecodes of an existing virtual machine
    including, JVM (Java Virtual Machine); CLR (Common Language
    Runtime) - .NET virtual machine; parrot virtual machine or WASM -
    Web Assembly.

  + JIT (Just-In-Time) compiler => Compile itself to machine code at
    runtime for improving performance and speed. This technique is
    used by several common lisp implementations.

  + Transpile S-expressions to another language, including C or C++.

Lisp terminology:

  + Sexp - S-Expression  
    + Stands for symbolic expressions
      
  + Homoiconicity
    + Code is data. The lisp code represents the AST (Abstract Syntax
      Tree) that is just nested lists of lists or atoms.

  + atoms
    + Everything that is not a list is an atom. An indivisible value,
      including strings, symbols, keywords, numbers and so on.
    
  + car - comes from 'Contents of the Address part of the Register'

  + cdr - comes from 'Contents of the Decrement part of the Register' 
    
  + cons -  abbreviation of the word 'construct'

  + Lisp 1 =>> There is a single namespace for variables and
    functions. Example: Scheme variants.

  + Lisp 2 =>> There are separate namespaces for variables and
    functions. Example: Common Lisp and Elisp - Emacs' lisp.

  + Special forms
    + They are forms or primitives not evaluated as functions, instead
      arguments may not be evaluated at all. Most special forms are
      primitives or control structures such as 'if', 'set', 'define', 'lambda'
      and so on. For instance the 'if' special form, that has three
      arguments, the first argument is a predicate, the second
      argument is the action that happens when the predicate is true
      and  the third argument is the action that happens when the
      predicate is false. If the predicate is true, the second
      argument is not evaluated and the if expression is evaluated to
      the value of the first argument. If the predicate is false, the
      first argument is not evaluated and the if expression is
      evaluated to the value of the second argument.

  + DSL - Domain Specific Lanaguage 

  + (if <PREDICATE> <THEN-EXPR> <ELSE-EXPR> )
    + The <THEN-EXPR> or then-expression is evaluated if the predicate
      evaulates to true that happens when the predicate does not
      evaluate to #f or nil. If the predicate is evaluated to any
      other value, the else-expression is evaluated.

  + User-defined procedures
    + User-defined functions using the keyword _fn_ (equivalent to
      lambda) or _def_ equivalent to Scheme's define keyword.

  + Primitive procedures 
    + Built-in functions or procedures, for instance (+), (*), apply,
      map, list and so on. 

  + Literals
    + Boolean literals => #t or #f - in this implementation
    + nil literal: nil => For designating empty return value.
    + symbol literal: 'a-symbol
    + keyword literal: :keyword1, :keyword2
    + String literal - between quotes:  "my string"
      
C++ Features used in this interpreter prototype:

  1. [[https://en.cppreference.com/w/cpp/memory/shared_ptr][std::shared_ptr]]
    
  2. [[https://en.cppreference.com/w/cpp/io/basic_istream][std::basic_istream and std::istream]]

  3. [[https://en.cppreference.com/w/cpp/io/basic_istream/getline][std::getline()]]

  4. [[https://en.cppreference.com/w/cpp/container/vector][std::vector container]]

  5. [[https://en.cppreference.com/w/cpp/string/basic_string][std::string container]]

  6. [[https://en.cppreference.com/w/cpp/container/map][std::map container]]

  7. [[https://en.cppreference.com/w/cpp/utility/functional/function][std::function container]]

  8. [[https://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast][std::static_pointer_cast]]

  9. [[https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared][std::make_shared()]]


Typical AST - Abstract Syntax Tree of Lisp/Scheme implementations:

#+BEGIN_SRC text 
                  Expr - Expression 
                      |
                      |
       +--------------+-------------------------+
       |                                        |  
   Cons(Expr, Expr)                           Atom - anything that is not a pair (cons cell)
 (cons pair,                                    |
  cons linked list         +--------+--------+---+------+-----------+---------+--------------+
  or cons cell   )         |        |        |          |           |         |              |
                         Nil     Number    String    Boolean     Symbol    Keyword       Function 
                       literal   literal   Literal   Literal                                 |
                                                                                -------------+-------------
                                                                                |                         |
                                                                             Native                  Lisp Function
                                                                            Function              implemented in Lisp 
                                                                            
     data Expr =  -- Cons cell  
                  Cons Expr, Expr                      
                  -- Nil literal - represents an empty value 
                | Nil                             
                  -- Boolean literal 
                | Bool Bool                       
                  -- Number literal 
                | Num  Double                     
                  -- String literal 
                | Str  String                     
                  -- Symbol 
                | Sym  String                     
                  -- keyword 
                | Key  String                     
                  -- Native function written in the hosting language 
                | NativeFun ([Expr] -> Expr)     
                   -- Function written in Lisp 
                | LispFunc (environment: Dict<String,Expr>, args: <String>, name: <String>, call:  [Expr] -> Expr)
                

  Example =>> The pair or cons cell '( hello . 100) is reprented as:
  
       Cons( Sym("hello"), Num(100))
       
    Example ->> The list (1 hello "world") is represented as a linked list in the following format:
 
       Cons( Num(1), Cons( Sym("Hello"), Cons( Str("hello"), Nil )))
#+END_SRC  


AST - Abstract Syntax Tree used in this implementation: 

#+BEGIN_SRC text 
             Expression  
                 |
                 |
     +-----------+------------------------+
     |                                    |
     |                                    |
  List of Expr                          Atom - anything that is not alist 
                                          |
                 +-------+---------+------+--+---+--------------+----------+
                 |       |         |         |        |         |          |
                Nil    Number    String   Boolean   Symbol   Keyword   Function 
              Literal  Literal   Literal   Literal          :keyword    object 
                                          #t (true)                       |
                                          #f (false)           +----------+---------------+
                                                               |                          |
                                                        Native Function            Lisp Function 
                                                      written in C or C++         written in Lisp 
                                                      or in the hosting 
                                                         language 
                                                      
  Haskell-like notation:
 
     data Expr =  -- List data structure - can be represented by a linked list or vector  
                  List [Expr]                     
                  -- Nil literal - represents an empty value 
                | Nil                             
                  -- Boolean literal 
                | Bool Bool                       
                  -- Number literal 
                | Num  Double                     
                  -- String literal 
                | Str  String                     
                  -- Symbol 
                | Sym  String                     
                  -- keyword 
                | Key  String                     
                  -- Native function written in the hosting language 
                | NativeFun ([Expr] -> Expr)     
                   -- Function written in Lisp 
                | LispFunc (environment: Dict<String,Expr>, args: <String>, name: <String>, call:  [Expr] -> Expr)
#+END_SRC 

*** Code 

File: _code.lisp_  - Sample Lisp scripting code 

#+BEGIN_SRC lisp 
  ; Lisp test code 
  ;--------------------------------
  
  (comment "Comment special form is evaluated to nil and discarded.")
  
  ;; Create a sample list 
  (set mylist (list 10 #t #f "hello world" 
                'hello 'world
                ; Operation 1
                :keyword1 (+ 10 25 6) '(+ 10 25 6) 
                ; Operation 2
                :keyword2 (* 4 2 6)  '(* 4 2 6) 
  
                ))
  
  ; Factorial function 
  (set code-fact "
        ; Factorial function 
        (def fact (n)
            (if (= n 1)
                1                    ;; Base case 
                (* n (fact (- n 1))) ;; Recursion case 
             )) 
      ")
  
  ;; S-expression for fibbonaci function
  (def fib(n)
     (if (< n 2)
       n 
       (+ (fib (- n 1))  (fib (- n 2)) )
      ))
  
  (def make-adder (k)
      (fn (x) (+ k x)))
  
  ;; Define a function that adds 10 to a number 
  (set add10 (make-adder 10))
  ;; Defines a function that adds 10 to a number 
  (set add50 (make-adder 50))
  
  
  (set func 
    (let (
            (a (sqrt 125))
            (b (+ 20 a))
            (c (* a b))
          )
          (comment "Create  a function using lexical scope. 
                    The variable (a, b and c) are not visible outside the function. 
                    ")
          (fn (x) (/ (+ a b x) c))
     )
   )
  
  ;; Compute many trigonometric properties of an angle 
  (def compute-trig (angle-degrees)
      (let (
            (angle (/ (* angle-degrees PI) 180) )
           )
          (list :angle angle-degrees :cos (cos angle) :sin (sin angle) :tan (tan angle))
       )
   )

#+END_SRC
    
File: _cpplisp.cpp_ (Lisp-like interpreter) - about 1600 lines of code.

#+BEGIN_SRC cpp 
#include <iostream> 
#include <string> 
#include <sstream>
#include <fstream>
#include <cctype>
#include <optional>
#include <cassert>
#include <memory>
#include <vector>
#include <map>
#include <iomanip>
#include <functional>
#include <cmath>
#include <stack>

enum class TokenType {
      SYM    // Symbol 
    , KEYW   // Keyword  Examples => :keyword, :x
    , STR    // String literal 
    , NUM    // Number literal 
    , BOOL   // Boolean 
    , QUOTE  // Quote  
    , RPAREN // '(' Right parenthesis  
    , LPAREN // ')' Left parenthesis 
    , EOFF   //  End of File (It was named 'EOFF' since it conflicts with #define 'EOF')
    , ERR    // Indicates error 
};

struct Token
{
    TokenType   type;
    std::string text;
    int pos;
    int lin;
    int col;

    Token(): 
     type(TokenType::ERR), text(""), pos(0), lin(0), col(0)
    {}

    Token(TokenType type_, std::string const& text_, int pos_, int lin_, int col_):
        type(type_), text(text_), pos(pos_), lin(lin_), col(col_)
    { }

    bool isEOF() { return type == TokenType::EOFF; }
};

bool isNumber(std::string const& text)
{
    if( text[0] != '-' && !std::isdigit(text[0]) )
    { return false; }
    auto n = text.length();
    for(size_t k = 1; k < n; k++){
        if( !std::isdigit( text[k] ) ){ return false;}
    }
    return true;
}

class Tokenizer 
{
    std::istream& _is;
    // Position of cursor in the inout stream 
    int _pos = 0;
    // Current line in the input stream 
    int _lin = 0;
    // Column in the input stream 
    int _col = 0; 
public:
    Tokenizer(std::istream& is): _is(is){ }

    // Read a single character and consumes it from the stream  
    char next() { 
        char chr = _is.get(); 
        _pos++;
        _col++;
        // Assumes that the new line character is just '\n'
        if( chr == '\n' ){
            _col = 0;
            _lin++;    
        }
        return chr;
    }
    // Read next character from input string without reading it 
    char peek(){ 
        return _is.peek();
    } 

    bool isBlankChar(){
        char ch = peek();
        return ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n';
    }

    bool isParenthesis(){
        char ch = peek();
        return ch == '(' || ch == ')';
    }

    // Is end of line     
    bool isEOL(){ return peek() == '\n'; }

    bool isEOF(){ return _is.eof(); }

    void skipBlankChars() {
        while( isBlankChar() ){ next(); }
    }

    void skipLineComment(){
        char ch = peek();
        while( ch != '\n' && !this->isEOF() ){ ch = next(); }
    }


    // Consume stream until a blank character is found 
    std::string consumeUntilBlank()
    {
        // std::fprintf(stderr, " [TRACE] Consuming until blank \n");
        char ch = peek();
        std::string text;
        while( !this->isBlankChar() && !this->isParenthesis()  && !this->isEOF())
        {
            ch = this->next();
            // fprintf(stderr, " [TRACE] ConsumeUntilBlank ch = %d \n", ch);
            text = text + ch;
        }
        // std::fprintf(stderr, " [TRACE] consumeUntilBlank = %s \n", text.c_str());
        return text;
    }

    std::vector<Token> readTokens()
    {
        std::vector<Token> out{};
        Token tok; 
        while( !tok.isEOF() ){
            tok = this->nextToken();
            if( !tok.isEOF() ){ out.push_back(tok); }
        }

        auto stack = std::stack<Token>{};

        // Check if parentheses are balanced 
        for(auto const& tok: out)
        {
            // Push left parentheses to the stack 
            if(tok.type == TokenType::LPAREN){ stack.push(tok);  }
            // If the stack is not empty and current parenthesis is a 
            // right parentheses, if the top of stack is left parentheses 
            // then pop the stack.
            if(tok.type == TokenType::RPAREN )
            {
                if( !stack.empty() && stack.top().type == TokenType::LPAREN )
                     { stack.pop(); }
                else { throw std::runtime_error("Error: unbalanced parentheses."); }
            }
        }
        
        if( !stack.empty() ){ 
            auto tok = stack.top();
            std::fprintf(stderr, " [ERROR] Unbalanced parentheses at line %d and column %d \n", tok.lin, tok.col);
            throw std::runtime_error("Error: unbalanced parentheses."); 
        }

        return out;
    }

    Token nextToken()
    {

        // std::fprintf(stderr, " [TRACE] Removing blank characters \n");
        skipBlankChars();

        char ch = next();
        // std::fprintf(stderr, " [TRACE] nextChar = %c \n", ch);

        if( this->isEOF() ){
            return Token(TokenType::EOFF, "", _pos, _lin, _col);
        }

        // Skip comments 
        if( ch == ';' ){ 
            // std::fprintf(stderr, " [TRACE] Skiping comment \n");
            skipLineComment(); 

            // std::fprintf(stderr, " [TRACE] Skiping comment 2 \n");
            return nextToken();
        }

        if( ch == '(')  { return Token(TokenType::LPAREN, "(", _pos, _lin, _col); }
        if( ch == ')')  { return Token(TokenType::RPAREN, ")", _pos, _lin, _col); }
        if( ch == '\'') { return Token(TokenType::QUOTE, "'",  _pos, _lin, _col); }

        // Boolean value 
        if( ch == '#'){
            auto c = this->next();
            auto text = std::string("#") + c;
            if( c!= 'f' && c !='t' ){
                return Token(TokenType::ERR, std::string("Error - invalid boolean literal => ") + text, _pos, _lin, _col); 
            }
            return Token(TokenType::BOOL, text,  _pos, _lin, _col);
        }

        // String literal 
        if( ch == '"' )
        { 
            // std::fprintf(stderr, " [TRACE] Reading string literal \n");
            std::string out = "";
            int col = _col;
            int pos = _pos;
            int lin = _lin;
            char c = 'x';
            while( c != '"' && !this->isEOF() )
            {
                c  = this->next();
                if(c == '"'){ break; }
                out = out + c;
            }
            if( c!= '"'){ return Token(TokenType::ERR, "Error - non closed quote.", _pos, _lin, _col); }
            else        { return Token(TokenType::STR, out, pos, lin, col); }
        }

        // assert(  )

        int col = _col;
        int pos = _pos;
        int lin = _lin;
        std::string text = ch + this->consumeUntilBlank();

        if( text == ":"){
            return Token(TokenType::ERR, "illegal terminating character after a colon:" ,pos, lin, col); 
        }

        // Keyworkd 
        if( text[0] == ':' )
        {
            // std::fprintf(stderr, " [TRACE] Tokenizer =>> keyword = %s \n", text.c_str() );
            return Token(TokenType::KEYW, text, pos, lin, col);
        }

        if( text == "-"){
            return Token(TokenType::SYM, text, pos, lin, col);
        }

        if( std::isdigit(text[0]) )
        {
            if( isNumber(text) )
                 { return Token(TokenType::NUM, text, pos, lin, col); } 
            else { return Token(TokenType::ERR, std::string("Error - invalid number => ") + text, pos, lin, col); }
        } else if( text[0] == '-' )
        {
            if( isNumber(text) )
                 { return Token(TokenType::NUM, text, pos, lin, col); } 
            else { return Token(TokenType::ERR, std::string("Error - invalid number => ") + text, pos, lin, col); }
        }

        // Anything else is a symbpl 
        return Token(TokenType::SYM, text, pos, lin, col);
    }

};

std::ostream& operator<<(std::ostream& os, TokenType type)
{
    if(type == TokenType::BOOL) { os << "[BOOL]"; }
    if(type == TokenType::EOFF) { os << "[EOF]"; }
    if(type == TokenType::STR) { os << "[STR]"; }
    if(type == TokenType::LPAREN) { os << "[LPAREN]"; }
    if(type == TokenType::RPAREN) { os << "[RPAREN]"; }
    if(type == TokenType::NUM) { os << "[NUM]"; }
    if(type == TokenType::SYM) { os << "[SYM]"; }
    if(type == TokenType::ERR) { os << "[ERR]"; }
    return os;
}

enum class ExprType {
      ERR  // Error  
    , NUM  // Number literal 
    , STR  // String literal 
    , BOOL // Boolean literal 
    , SYM  // Symbol 
    , KEY  // Keyword 
    , NIL  // Nil or Null value 
    , FUN  // Function  
    , LST  // List literal 
};


// Forward declaration 
struct ExprNil;
struct ExprStr;
struct ExprNum;
struct ExprSym;
struct ExprKey;
struct ExprErr;
struct ExprBool;
struct ExprFun;
struct ExprLst;

// Visitor design pattern 
struct IVisitor{
public:
    virtual ~IVisitor() = default;
    virtual void visit(ExprNil& expr) = 0;
    virtual void visit(ExprStr& expr) = 0;
    virtual void visit(ExprNum& expr) = 0;
    virtual void visit(ExprSym& expr) = 0;
    virtual void visit(ExprKey& expr) = 0;
    virtual void visit(ExprBool& expr) = 0;
    virtual void visit(ExprErr& expr) = 0;
    virtual void visit(ExprFun& expr) = 0;
    virtual void visit(ExprLst& expr) = 0;
};

// Lisp-like AST - Abstract syntax tree 
// IEXpr stands for Interface Expression 
struct IExpr 
{
    virtual ~IExpr() = default;
    virtual ExprType type()   const = 0;
    // Returns true if AST node is ATOM
    virtual bool     isAtom() const { return true; }
    // Returns true if AST node is list  
    virtual bool     isList() const { return false; }
    // Returns true if AST node is error  
    virtual bool     isErr()  const { return false; } 
    // Returns true if AST node is symbol 
    virtual bool     isSym()  const { return false; } 
    // Returns true if AST node is string
    virtual bool     isStr()  const { return false; } 
    // Returns true if AST node is keyword
    virtual bool     isKey()  const { return false; } 
    // Returns true if AST node is number  
    virtual bool     isNum()  const { return false; } 
    // Returns true if AST node is boolean 
    virtual bool     isBool()  const { return false; } 
    // Returns true if AST node is nil   
    virtual bool     isNil()  const { return false; } 
    // Returns true if AST node is function 
    virtual bool     isFun()  const { return false; } 

    /// Returns the string value of a node 
    virtual std::string  strValue()  const = 0;
    virtual double       numValue()  const = 0;
    // Evaluates to false if nil or #f and evaluates to true if it is anything else.
    virtual bool         boolValue() const = 0;

    // Method for accepting visitor (Related to visitor design pattern)
    virtual void     accept(IVisitor& v) = 0; 

    // Evaluate AST node and return a value (AST Node) 
    virtual std::shared_ptr<IExpr> eval( std::map<std::string, std::shared_ptr<IExpr>>& env) = 0;
};


// Represents a null value (empty value) equivalent to void 
// In Lisp just as other functional-like programming languages
// everything is evaluated to something and can be replaced be a value.
struct ExprNil: public IExpr
{
    ExprNil(){ } 
    ExprType type() const { return ExprType::NIL; } 
    bool isNil()    const { return true; } 

    std::string  strValue()  const { return "";}
    double       numValue()  const { return 0;   }
    bool         boolValue() const { return false;}

    void accept(IVisitor& v) { v.visit(*this); }

    virtual std::shared_ptr<IExpr> eval( std::map<std::string, std::shared_ptr<IExpr>>& env) 
    {
       return std::make_shared<ExprNil>(); 
    }
};


// Represents a string literal 
struct ExprStr: public IExpr
{
    std::string value;
    ExprStr(std::string const& value_): value(value_){ }
    ExprType type() const { return ExprType::STR; } 


    std::string  strValue()  const { return value;}
    double       numValue()  const { return -1;   }
    bool         boolValue() const { return true;}
    bool        isStr()      const { return true; } 
    void accept(IVisitor& v) { v.visit(*this); }

    std::shared_ptr<IExpr> eval( std::map<std::string, std::shared_ptr<IExpr>>& env) 
    {
       return std::make_shared<ExprStr>(this->value); 
    }
};

// Represents a number 
struct ExprNum: public IExpr
{
    double value;
    ExprNum(double value_): value(value_){ }
    ExprType type() const { return ExprType::NUM; } 
    bool isNum()    const { return true;  }
    std::string  strValue()  const { return "";}
    double       numValue()  const { return value;   }
    bool         boolValue() const { return true;}
    void accept(IVisitor& v) { v.visit(*this); }

    std::shared_ptr<IExpr> eval( std::map<std::string, std::shared_ptr<IExpr>>& env) 
    {
       return std::make_shared<ExprNum>(this->value); 
    }
};

// Represents a boolean literal (logical value)
struct ExprBool: public IExpr  
{
    bool value;
    ExprBool(bool value_): value(value_){ }
    ExprType type() const { return ExprType::BOOL; } 

    bool isBool() const { return true; } 

    std::string  strValue()  const { return "";}
    double       numValue()  const { return -1;   }
    bool         boolValue() const { return value;}
    void accept(IVisitor& v) { v.visit(*this); }

    std::shared_ptr<IExpr> eval( std::map<std::string, std::shared_ptr<IExpr>>& env) 
    {
       return std::make_shared<ExprBool>(this->value); 
    }

};

// Represents a lisp symbol
struct ExprSym: public IExpr  
{
    std::string value;
    ExprSym(std::string value_): value(value_){ }
    ExprType type() const { return ExprType::SYM; } 
    bool isSym()    const { return true;  }
    std::string  strValue()  const { return value;}
    double       numValue()  const { return -1;   }
    bool         boolValue() const { return true;}
    void accept(IVisitor& v) { v.visit(*this); }


    std::shared_ptr<IExpr> eval( std::map<std::string, std::shared_ptr<IExpr>>& env) 
    {

        auto it = env.find(value);
        if (it == env.end())
        {
            throw std::runtime_error(" [ERROR] Unbound variable " + value);
            //return std::make_shared<ExprErr>(10, "Error - unbound variable " + value);
           // return nullptr;
        }
        return it->second;
    }
};


// Represents a lisp keyword such as :x, :y, :keyword1
struct ExprKey: public IExpr  
{
    std::string value;
    ExprKey(std::string value_): value(value_){ }
    ExprType type() const { return ExprType::KEY; } 
    bool isKey()    const { return true; }
    std::string  strValue()  const { return value;}
    double       numValue()  const { return -1;   }
    bool         boolValue() const { return true;}
    void accept(IVisitor& v) { v.visit(*this); }


    std::shared_ptr<IExpr> eval( std::map<std::string, std::shared_ptr<IExpr>>& env) 
    {
       return std::make_shared<ExprKey>(this->value); 
    }

};



// Represents an Error (Reserved for future use)
struct ExprErr: public IExpr  
{
    int         code;
    std::string info;

    ExprErr(){}
    ExprErr(int code_, std::string const& info_)
        : code(code_), info(info_) { }

    ExprType type() const { return ExprType::ERR; } 
    bool isErr()    const { return true; }

    std::string  strValue()  const { return info;}
    double       numValue()  const { return -1;   }
    bool         boolValue() const { return false;}

    void accept(IVisitor& v) { v.visit(*this); }

    std::shared_ptr<IExpr> eval( std::map<std::string, std::shared_ptr<IExpr>>& env) 
    {
       return std::make_shared<ExprErr>(code, info);
    }
};


using LispFunc = std::function<std::shared_ptr<IExpr> (std::vector<std::shared_ptr<IExpr>> const& args)>;
using LispEnv = std::map<std::string, std::shared_ptr<IExpr>>; 


// Represents a function
struct ExprFun: public IExpr
{
    std::string name;
    std::string doc;
    // std::vector<std::string> args;
    // std::shared_ptr<IExpr>   body;
    // ExprFun(std::vector<std::string> const& args_): args(args_) { }
    ExprType type() const { return ExprType::FUN; }
    bool isFun()    const { return true; }
    double       numValue()  const { return -1;   }
    bool         boolValue() const { return true;}

    virtual bool isNativeFun() const = 0;

    void accept(IVisitor& v) { v.visit(*this); }

    virtual std::shared_ptr<IExpr>  call( std::vector<std::shared_ptr<IExpr>>& params
                                        , std::map<std::string, std::shared_ptr<IExpr>>& env_) = 0;

    ~ExprFun() = default;
};


// Non-native lisp function implemented in lisp 
struct ExprFunLisp: public ExprFun 
{
    std::vector<std::string> args;
    std::vector<std::shared_ptr<IExpr>>  body;
    std::map<std::string, std::shared_ptr<IExpr>> env;

    std::string  strValue()  const { return "(function) " + this->name;}
    bool isNativeFun() const { return false; }

    ExprFunLisp(){}
    ExprFunLisp(std::vector<std::string> const& args_, std::vector<std::shared_ptr<IExpr>> const& body_)
        : args(args_), body(body_) {

         }

    std::shared_ptr<IExpr> eval( std::map<std::string, std::shared_ptr<IExpr>>& env) 
    {
        // Invoke copy constructor 
       return std::make_shared<ExprFunLisp>(*this); 
    }

    std::shared_ptr<IExpr> 
    call( std::vector<std::shared_ptr<IExpr>>& params
         ,std::map<std::string, std::shared_ptr<IExpr>>& env_)
    {
        if( params.size() != args.size() )
        { throw std::runtime_error("Error: Function call error. "); }

        // Create local environment 
        auto envv = std::map<std::string, std::shared_ptr<IExpr>>{};
        // Copy global environment to temporary environment 
        for(auto& k : env_){ envv[k.first] = k.second; }

        // Copy local environment to temporary environment 
        for(auto& k : env){ envv[k.first] = k.second; }

        // Pass parameters to local environment 
        for(size_t n = 0; n < args.size(); n++ )
        {
            auto a = args[n];
            envv[a] = params[n];   
        }

        auto N = body.size();
        for(size_t n = 0; n < N - 1; n ++ )
        {
            body[n]->eval(envv);
        }
        auto result = body[N - 1]->eval(envv);

        if( result->isFun() 
            && !std::static_pointer_cast<ExprFun>(result)->isNativeFun() )
        {
            auto func = std::static_pointer_cast<ExprFunLisp>(result);
            for(size_t n = 0; n < args.size(); n++ )
            {
                auto a = args[n];
                func->env[a] = params[n];   
            }
        }

        return result;
    }
                                
};


// Native function implemented in C or C++
struct ExprFunNative: public ExprFun 
{
    LispFunc func; 
    std::string  strValue()  const { return "(native function) " + this->name;}
    bool isNativeFun() const { return true; }
    ExprFunNative(LispFunc func_): func(func_){ } 

    std::shared_ptr<IExpr> eval( std::map<std::string, std::shared_ptr<IExpr>>& env) 
    {
        // Invoke copy constructor 
       return std::make_shared<ExprFunNative>(func); 
    }

    std::shared_ptr<IExpr> 
    call( std::vector<std::shared_ptr<IExpr>>& params
         ,std::map<std::string, std::shared_ptr<IExpr>>& env_)

    {
        // std::fprintf(stderr, " [TRACE] Calling native function \n");
        return this->func(params);
    }

};

// Represents a list 
struct ExprLst: public IExpr  
{

    std::vector<std::shared_ptr<IExpr>> lst; 

    ExprLst(std::vector<std::shared_ptr<IExpr>> const& lst_)
        : lst(lst_){ } 

    ExprType type() const { return ExprType::LST; } 
    bool isAtom()   const { return false; } 
    bool isList()   const { return true; }

    std::string  strValue()  const { return "";}
    double       numValue()  const { return -1;   }
    bool         boolValue() const { return true;}

    void accept(IVisitor& v) { v.visit(*this); }

    std::shared_ptr<IExpr> eval(std::map<std::string, std::shared_ptr<IExpr>>& env)
    {
        if (lst.size() == 0)
        {
            return std::make_shared<ExprNil>();
        }

        auto type = lst[0]->type();

        if ( type != ExprType::SYM && type != ExprType::LST  )
        {
            throw std::runtime_error(" [ERROR] =>> Object is not applicable.");
        }

        std::string symbol = lst[0]->strValue();

        // Ignore comment special form
        if(symbol == "comment")
        { return std::make_shared<ExprNil>(); }

        if (symbol == "set")
        {
            if (lst.size() != 3)
            { throw std::runtime_error("Ill-formed syntax for SET special form"); }
            if (lst[1]->type() != ExprType::SYM)
            { throw std::runtime_error("Ill-formed syntax for SET special form. Expected symbol. "); }
            auto res = lst[2]->eval(env); 
            std::string name = lst[1]->strValue();
            std::fprintf(stderr, " [TRACE] Defining symbol = %s . \n", name.c_str());
            env[name] = res; //;std::make_shared<EnvVal>(res);
            return std::make_shared<ExprNil>();
        }

        // Handle special form (if <cond> <then-expr>) or (if <cond> <then-expr> <else-expr>)
        if( symbol == "if" )
        {
            if( lst.size() != 3 && lst.size() != 4) { throw std::runtime_error("Ill-formed syntax for IF special form"); }

            auto cond = lst[1];
            auto cond_result = cond->eval(env);

            if( lst.size() == 3 && !cond_result->boolValue() ) 
            { return std::make_shared<ExprNil>(); }

            if( lst.size() == 4 && !cond_result->boolValue() )
            {
                // Evaluate the else-expr 
                auto res = lst[3]->eval(env); // this->eval( *lst[3] );
                return res;
            }

            assert( cond_result->boolValue() );
            auto res = lst[2]->eval(env); //this->eval( *lst[2] );
            return res;
        }

        // Handle quote special form 
        if( symbol == "quote" || symbol == "$q")
        {
            if( lst.size() != 2 ) 
            { throw std::runtime_error("Ill-formed syntax for QUOTE special form"); }
            auto arg = lst[1];
            return arg;
        }

        // Equivalent to scheme or lisp lambda or scheme lambda 
        // (fn (a0 a1 ... a[N-1]) (expr1) (expr2) ... (expr[K-1]) )
        if( symbol == "fn" )
        {
            if (lst.size() < 3)
            { throw std::runtime_error("Ill-formed syntax for lambda special form"); }

            if( !lst[1]->isList() )
            { throw std::runtime_error("Ill-formed syntax for lambda. Expected arguments."); }

            // Function/lambda arguments   
            auto args = std::static_pointer_cast<ExprLst>(lst[1]);
            // Function/lambda body (list of expressions)
            auto body = lst;
            // Remove first element ('lambda' symbol)
            body.erase(body.begin()); 
            // Remove frst element - function arguments 
            body.erase(body.begin()); 

            std::vector<std::string> _args{};

            for(auto& a: args->lst)
            {
                if( !a->isSym() )            
                { throw std::runtime_error("Ill-formed syntax for lamba. Arguments must be strings.");  }
                _args.push_back( a->strValue() );
            }

            auto fun = std::make_shared<ExprFunLisp>(_args, body);
            return fun;
        }

        /** Sepcial form def 
         * (def function (a0 a1 ... a[N-1]) (expr1) (expr2) ... (expr[K-1]) )
         * 
         *  Example: 
         *   (def addxy(x  y )
         *             (disp x) 
         *             (disp y)
         *              (+ x y))
         * 
         */
        if( symbol == "def" )
        {
            if (lst.size() < 4)
            { throw std::runtime_error("Ill-formed syntax for def() special form"); }
            if( !lst[1]->isSym() )
            { throw std::runtime_error("Ill-formed syntax for def(). Expected function name."); }
            if( !lst[2]->isList() )
            { throw std::runtime_error("Ill-formed syntax for def(). Expected arguments."); }

            // Function name 
            auto name = lst[1]->strValue();
            // Function/lambda arguments   
            auto args = std::static_pointer_cast<ExprLst>(lst[2]);
            // Function/lambda body (list of expressions)
            auto body = lst;
            // Remove first element ('lambda' symbol)
            body.erase(body.begin()); 
            body.erase(body.begin()); 
            body.erase(body.begin()); 

            std::fprintf(stderr, " [TRACE] Defining function = %s . \n", name.c_str());

            std::vector<std::string> _args{};

            for(auto& a: args->lst)
            {
                if( !a->isSym() )            
                { throw std::runtime_error("Ill-formed syntax for lamba. Arguments must be strings.");  }
                _args.push_back( a->strValue() );
            }
            auto fun = std::make_shared<ExprFunLisp>(_args, body);
            fun->name = name;

            env[name] = fun;

            return std::make_shared<ExprNil>();
        }

        // Handle special form (begin (action1 ....) (action 2) (action N-1)) 
        if( symbol == "begin" )
        {
            // arguments 
            auto args = lst;
            // Remove first element 
            args.erase(args.begin());

            if( args.size() == 0)
            { return std::make_shared<ExprNil>(); }

            for(size_t n = 0; n < args.size() - 1; n++)
            {  args[n]->eval(env); }
            // Revaluate last element 
            auto result = args[ args.size() -1 ]->eval(env);
            return result;
        }
        
        /** (let (binding lists) (exp1) (exp2) .... (expN-1) )
         *     
         *  (let ( (a 20)
         *         (b 30 )) 
         *        (display a) (display b) (+ a b) )
         *  
         *  The previous expression evaluates to 30.
         */
        if( symbol == "let" )
        {

            if( lst.size() < 3 )
            { throw std::runtime_error("Error: ill-formed sytax for let expression."); }
            if( !lst[1]->isList() )
            { throw std::runtime_error("Error: ill-formed sytax for let expression. Expected list of bindings."); }

            auto bindings = std::static_pointer_cast<ExprLst>(lst[1])->lst;

            // Create a new temporary environment 
            auto envv = std::map<std::string, std::shared_ptr<IExpr>>{};
            auto envs = std::map<std::string, std::shared_ptr<IExpr>>{};

            // Copy environment     
            for(auto& k : env){ envv[k.first] = k.second; }

            for(auto const& b: bindings){
                if( !b->isList() )
                    { throw std::runtime_error("Error: ill-formed sytax for let expression. Expected list as binding argument."); }
                auto bb = std::static_pointer_cast<ExprLst>(b)->lst;
                if( bb.size() != 2)
                    { throw std::runtime_error("Error: ill-formed sytax for let expression."); }
                if( !bb[0]->isSym() ) 
                    { throw std::runtime_error("Error: ill-formed sytax for let expression. Expected symbol."); }
                auto sym = bb[0]->strValue();
                auto val = bb[1]->eval(envv);
                // Add symbols from let binding to the new temporary environment
                envv[sym] = val;
                envs[sym] = val;
            }

            for(size_t k = 2; k < lst.size() - 1; k ++)
            { lst[k]->eval(envv); }

            auto result = lst[lst.size() - 1]->eval(envv);
            // Implement closure - function cature variables from local environment 
            if( result->isFun() 
                && !std::static_pointer_cast<ExprFun>(result)->isNativeFun() )
            {
                auto func = std::static_pointer_cast<ExprFunLisp>(result);
                func->env = envs;
            }

            return result;
        }

        /** For-loop similar to common lisp => (repeat 10 n (action n)) */
        if( symbol == "repeat" )
        {
            if( lst.size() != 4 ) 
            { throw std::runtime_error("Error: ill-formed syntax for repeat special form. Expected 4 arguments"); }
            if( !lst[2]->isSym() )
            { throw std::runtime_error("Error: ill-formed syntax for repeat special form. Expected symbol."); }
            auto n = lst[1]->eval(env);
            if( !n->isNum() )
            { throw std::runtime_error("Error: expected number as first argument."); }
            auto ntimes = (int) n->numValue();
            if( ntimes < 0)
            { throw std::runtime_error("Error: ill-formed syntax for repeat special form . Iterations cannot be negative."); }

            auto sym = lst[2]->strValue();

            auto action = lst[3];
            // Copy environment 
            auto envv = env;

            for(int k = 0; k < ntimes; k++)
            {
                envv[sym] = std::make_shared<ExprNum>(k);
                action->eval(envv);
            }
            return std::make_shared<ExprNil>();
        }


        // ---------- Function Application --------------------//

        auto it = lst[0]->eval(env);
        if( !it->isFun() ){ throw std::runtime_error("Error - object not callable.");  }
        auto function = std::static_pointer_cast<ExprFun>(it);

        // Function arguments
        auto args = lst;
        // Remove first element
        args.erase(args.begin());

        std::vector<std::shared_ptr<IExpr>> evaluatedArgs;

        // evaluatedArgs.reserve(args.size());
        for (auto const &arg : args)
        {
            auto res = arg->eval(env); 
            evaluatedArgs.push_back(res);
        }

        auto result = function->call(evaluatedArgs, env);
        return result;
    }
};


// Parser 
auto readTokens(std::vector<Token>& tokens) -> std::shared_ptr<IExpr> 
{
    // auto tokens = tokens_;
    if( tokens.size() == 0){
        throw std::runtime_error("Error: Unexpected EOF - End of File");
    }

    auto tok = tokens[0];    
    // Remove first element of vector 
    tokens.erase(tokens.begin());

    // std::cout << " [readToken] " << tok.type << " ; " << tok.text 
    //           << " ; line = " << tok.lin << " ; col = " << tok.col 
    //           << "\n";

    if( tok.type == TokenType::ERR )
    {
        throw std::runtime_error("[ERROR] " + tok.text);
    }

    if( tok.type == TokenType::QUOTE )
    {
        auto lst = std::vector<std::shared_ptr<IExpr>>{};
        lst.push_back( std::make_shared<ExprSym>("quote") );
        auto next = readTokens(tokens);
        lst.push_back(next);
        return std::make_shared<ExprLst>(lst);
    }

    if( tok.type == TokenType::LPAREN  )
    {
        auto lst = std::vector<std::shared_ptr<IExpr>>{};

        while( tokens[0].type != TokenType::RPAREN )
        {
            auto expr = readTokens(tokens);
            lst.push_back( expr );
        }
        // Drop off ')' right parentheis
        tokens.erase(tokens.begin());

        return std::make_shared<ExprLst>(lst);
    }

    if( tok.type == TokenType::RPAREN  )
    {
        throw std::runtime_error("Error: Unexpected ')' right parenthesis ");
    }

    if( tok.type == TokenType::NUM)
    {
        return std::make_shared<ExprNum>( std::stoi(tok.text) );
    }

    if( tok.type == TokenType::SYM && tok.text == "nil" )
    {
        return std::make_shared<ExprNil>();
    }

    if( tok.type == TokenType::SYM )
    {
        return std::make_shared<ExprSym>( tok.text );
    }

    if( tok.type == TokenType::KEYW )
    {
        return std::make_shared<ExprKey>( tok.text );
    }

    if( tok.type == TokenType::BOOL )
    {
        return std::make_shared<ExprBool>( tok.text == "#t" ? true : false );
    }

    if( tok.type == TokenType::STR )
    {
        return std::make_shared<ExprStr>( tok.text );
    }

    return std::make_shared<ExprErr>(-1, "BUG Found => Edge case found in the parser.");
}


// Parse Lisp-like (scheme-like) S-Expression by reading a string source code 
auto parseSexp(std::string const& code) -> std::shared_ptr<IExpr> 
{
    std::stringstream ss; 
    ss << code; 
    Tokenizer tokenizer(ss);
    auto tokens = tokenizer.readTokens();
    auto result = readTokens(tokens);
    return result;
}

// Parse Lisp-like (scheme-like) S-Expression by reading an input stream 
auto parseSexp(std::istream& is) -> std::shared_ptr<IExpr> 
{
    Tokenizer tokenizer(is);
    auto tokens = tokenizer.readTokens();
    auto result = readTokens(tokens);
    return result;
}


class PrintVisitor: public IVisitor
{
public:

    void visit(ExprNil&  expr)  override { std::cout << "nil"; } 
    void visit(ExprStr&  expr)  override { std::cout << "\"" << expr.value << "\""; }
    void visit(ExprNum&  expr)  override { std::cout << expr.value; }
    void visit(ExprBool& expr)  override { std::cout << (expr.value ? "#t" : "#f"); }
    void visit(ExprSym&  expr)  override { std::cout << expr.value; }
    void visit(ExprKey&  expr) override { std::cout << expr.value; }
    void visit(ExprErr&  expr)  override { std::cout << "<< [ERROR] " << expr.info; }
    void visit(ExprFun&  expr)  override { std::cout << expr.strValue(); }

    void visit(ExprLst& expr) override
    {
        std::cout << "( ";
        for(auto node : expr.lst){ std::cout << " "; node->accept(*this); }
        std::cout << " )";
    }

};

class WriterVisitor: public IVisitor
{
    std::ostream& out;
public:
    WriterVisitor(std::ostream& os_): out(os_){}

    void visit(ExprNil&  expr)  override { out << "nil"; } 
    void visit(ExprStr&  expr)  override { out << "\"" << expr.value << "\""; }
    void visit(ExprNum&  expr)  override { out << expr.value; }
    void visit(ExprBool& expr)  override { out << (expr.value ? "#t" : "#f"); }
    void visit(ExprSym&  expr)  override { out << expr.value; }
    void visit(ExprKey&  expr)  override { out << expr.value; }
    void visit(ExprErr&  expr)  override { out << "<< [ERROR] " << expr.info; }
    void visit(ExprFun&  expr)  override { out << expr.strValue(); }

    void visit(ExprLst& expr) override
    {
        // out << "\n ( ";
        for(auto const& node : expr.lst)
        { 
            out << " "; node->accept(*this);
            //if( node->isList() ){ out << '\n'; }
         }
        out << " )";
    }

};


// Print S-Expression 
void printSexp(IExpr& expr)
{
    PrintVisitor visitor;
    expr.accept(visitor);
    std::cout << std::endl;
}


/// Lisp interpreter's primitive functions 
namespace primitives {

    // All Lisp functions passed to the interpreter must have this type signature 
    // Lisp function primitive 'list' => Example: (list 10 20 (+ 1 2 5) "Hello" #f #t nil)
    std::shared_ptr<IExpr> list(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        return std::make_shared<ExprLst>(args);
    }


    // Return the number of elements of alist 
    std::shared_ptr<IExpr> length(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 )
        { throw std::runtime_error("Error: length() requires 1 argument of type list."); } 
        if( !args[0]->isList() )
        { throw std::runtime_error("Error: length() expects 1 argument of type list."); }

        auto node = static_cast<ExprLst const&>( *args[0] );
        auto lst = node.lst;
        return std::make_shared<ExprNum>(lst.size());
    }

    //  car => Returns first element of the list or nil 
    std::shared_ptr<IExpr> car(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 )
        { throw std::runtime_error("Error: car() requires 1 argument of type list."); } 
        if( !args[0]->isList() )
        { throw std::runtime_error("Error: car() expects 1 argument of type list."); }

        auto node = static_cast<ExprLst const&>( *args[0] );
        auto lst = node.lst;
        if( lst.size() == 0 ){ return std::make_shared<ExprNil>(); }
        return lst[0];
    }

    std::shared_ptr<IExpr> cdr(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 )
        { throw std::runtime_error("Error: cdr() requires 1 argument of type list."); } 
        if( !args[0]->isList() )
        { throw std::runtime_error("Error: cdr() expects 1 argument of type list."); }

        auto node = static_cast<ExprLst const&>( *args[0] );
        auto lst = node.lst;
        if( lst.size() == 0 ){ return std::make_shared<ExprNil>(); }
        // Remove first list argument 
        lst.erase(lst.begin());
        return std::make_shared<ExprLst>(lst);
    }

    // cons => List constructor 
    std::shared_ptr<IExpr> cons(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 2 )
        { throw std::runtime_error("Error: cons() requires 2 arguments."); } 
        if( !args[1]->isList() && !args[1]->isNil() )
        { throw std::runtime_error("Error: pairs construction not allowed. Second argument can only be a list or nil."); }

        if( args[1]->isList() )
        {
            auto lst  = std::static_pointer_cast<ExprLst>( args[1] )->lst;
            lst.insert(lst.begin(), args[0]);
            return std::make_shared<ExprLst>(lst);
        }
        assert( args[1]->isNil() );
        auto lst =  std::vector<std::shared_ptr<IExpr>>{ args[0] };
        return std::make_shared<ExprLst>(lst);
    }

    // Get the nth element of a list
    std::shared_ptr<IExpr> nth(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 2 )
        { throw std::runtime_error("Error: cons() requires 2 arguments."); } 
        if( !args[0]->isNum() ) 
        { throw std::runtime_error("Error: Expected number "); }
        if( !args[1]->isList() && !args[1]->isNil() )
        { throw std::runtime_error("Error: Expected list or nil."); }

        if( args[1]->isNil() )
        { return std::make_shared<ExprNil>(); }

        auto n = (int) args[0]->numValue();    
        auto lst = std::static_pointer_cast<ExprLst>(args[1])->lst;

        if( n < lst.size() && n >= 0 ){ return lst[n]; }
        return std::make_shared<ExprNil>();
    }

    // (= 10 20) => #f ; (= 10 10) => #t
    std::shared_ptr<IExpr> equal_number(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 2 )
        { throw std::runtime_error("Error: = requires 2 arguments."); } 
        if( !args[0]->isNum() && !args[1]->isNum() ) 
        { throw std::runtime_error("Error: Expected number "); }
        auto a = args[0]->numValue();    
        auto b = args[1]->numValue();    
        return std::make_shared<ExprBool>(a == b);
    }

    std::shared_ptr<IExpr> less_than(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 2 )
        { throw std::runtime_error("Error: = requires 2 arguments."); } 
        if( !args[0]->isNum() && !args[1]->isNum() ) 
        { throw std::runtime_error("Error: Expected number "); }
        auto a = args[0]->numValue();    
        auto b = args[1]->numValue();    
        return std::make_shared<ExprBool>(a < b);
    }


    // Parse a string returning a S-Expression 
    std::shared_ptr<IExpr> read(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 )
        { throw std::runtime_error("Error: read() requires 1 argument of type string."); } 
        if( args[0]->type() != ExprType::STR )
        { throw std::runtime_error("Error: read() expects 1 argument of type string."); }
        std::string code  = args[0]->strValue();
        auto result = parseSexp(code);
        return result;
    }

    // Primitive predicate function list? => Return true if the argument is of type list 
    std::shared_ptr<IExpr> is_list(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 )
        { throw std::runtime_error("Error: list?() requires 1 argument."); } 
        return std::make_shared<ExprBool>( args[0]->isList() );
    }

    // Primitive predicate function symbol? => Return true if the argument is of type symbol
    std::shared_ptr<IExpr> is_symbol(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 )
        { throw std::runtime_error("Error: symbol?() requires 1 argument."); } 
        return std::make_shared<ExprBool>( args[0]->type() == ExprType::SYM );
    }

    std::shared_ptr<IExpr> is_keyword(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 )
        { throw std::runtime_error("Error: keyword?() requires 1 argument."); } 
        return std::make_shared<ExprBool>( args[0]->type() == ExprType::KEY );
    }

    // Primitive predicate function number? => Return true if the argument is of type number
    std::shared_ptr<IExpr> is_number(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 )
        { throw std::runtime_error("Error: number?() requires 1 argument."); } 
        return std::make_shared<ExprBool>( args[0]->isNum() );
    }

    // Primitive predicate function boolean? => Return true if the argument is of type number
    std::shared_ptr<IExpr> is_boolean(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 )
        { throw std::runtime_error("Error: boolean?() requires 1 argument."); } 
        return std::make_shared<ExprBool>( args[0]->type() == ExprType::BOOL );
    }

    // Primitive predicate function nil? => Return true if the argument is of type nil
    std::shared_ptr<IExpr> is_nil(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 )
        { throw std::runtime_error("Error: nil?() requires 1 argument."); } 
        return std::make_shared<ExprBool>( args[0]->isNil() );
    }

    // Primitive predicate function string? => Return true if the argument is of type string
    std::shared_ptr<IExpr> is_string(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 )
        { throw std::runtime_error("Error: string?() requires 1 argument."); } 
        return std::make_shared<ExprBool>( args[0]->type() == ExprType::STR );
    }


    // Display an S-Expression 
    std::shared_ptr<IExpr> disp(std::vector<std::shared_ptr<IExpr>> const& args)
    {
        if( args.size() != 1 ){
           throw std::runtime_error("Error: function disp() requires 1 argument.");
        } 
        PrintVisitor visitor;
        args[0]->accept(visitor);
        std::cout << "\n";
        return std::make_shared<ExprNil>();
    }

    // Lisp function (+) => Example: (+ 1 2 3 4 5) = 15
    std::shared_ptr<IExpr> add(std::vector<std::shared_ptr<IExpr>> const& args)
    {
       if( args.size() == 0 ){
           throw std::runtime_error("Error: this function requires at least 1 argument.");
       } 
       double acc = 0.0;
       for(auto const& a: args){
           if( a->type() != ExprType::NUM){
               throw std::runtime_error("Invalid argument. Expected a number");
           }
           acc = acc + a->numValue();
       }
       return std::make_shared<ExprNum>(acc);
    }

    // Lisp function (*) => Example: (* 1 2 3 4 5) = 120
    std::shared_ptr<IExpr> mul(std::vector<std::shared_ptr<IExpr>> const& args)
    {
       if( args.size() == 0 ){
           throw std::runtime_error("Error: this function requires at least 1 argument.");
       } 
       double acc = 1.0;
       for(auto const& a: args){
           if( a->type() != ExprType::NUM){
               throw std::runtime_error("Invalid argument. Expected a number");
           }
           acc = acc * a->numValue();
       }
       return std::make_shared<ExprNum>(acc);
    }

    // List function (-) => Example: (- 100 20 30 ) = 100 - 20 - 30 = 50 
    std::shared_ptr<IExpr> sub(std::vector<std::shared_ptr<IExpr>> const& args)
    {

        // std::fprintf(stderr, " [TRACE] Called Lispfun sub() \n "); 
        if (args.size() == 0)
        {
            throw std::runtime_error("Error: this function requires at least 1 argument.");
        }
        if (args.size() == 1)
        {
            if (args[0]->type() != ExprType::NUM)
            {
                throw std::runtime_error("Error: invalid argument type. Expected number");
            }
            assert(args[0]->type() == ExprType::NUM);
            return std::make_shared<ExprNum>(-args[0]->numValue());
        }

        if (args[0]->type() != ExprType::NUM)
        {
            throw std::runtime_error("Error: invalid argument type. Expected number");
        }
        double acc = args[0]->numValue();

        // std::fprintf(stderr, " [TRACE] acc = %f \n", acc);

        auto args_ = args;
        // Remove first element
        args_.erase(args_.begin());

        for (auto const &a : args_)
        {
            if (a->type() != ExprType::NUM)
            {
                throw std::runtime_error("Invalid argument. Expected a number");
            }
            double x = a->numValue();
            // std::fprintf(stderr, " [TRACE] x = %f \n", x);
            acc = acc - x; 
        }
        return std::make_shared<ExprNum>(acc);
    }

    std::shared_ptr<IExpr> div(std::vector<std::shared_ptr<IExpr>> const& args)
    {

        // std::fprintf(stderr, " [TRACE] Called Lispfun sub() \n "); 
        if (args.size() == 0)
        {
            throw std::runtime_error("Error: this function requires at least 1 argument.");
        }
        if (args.size() == 1)
        {
            if (args[0]->type() != ExprType::NUM)
            {
                throw std::runtime_error("Error: invalid argument type. Expected number");
            }
            assert(args[0]->type() == ExprType::NUM);
            return std::make_shared<ExprNum>(1.0 / args[0]->numValue());
        }

        if (args[0]->type() != ExprType::NUM)
        {
            throw std::runtime_error("Error: invalid argument type. Expected number");
        }
        double acc = args[0]->numValue();

        // std::fprintf(stderr, " [TRACE] acc = %f \n", acc);

        auto args_ = args;
        // Remove first element
        args_.erase(args_.begin());

        for (auto const &a : args_)
        {
            if (a->type() != ExprType::NUM)
            {
                throw std::runtime_error("Invalid argument. Expected a number");
            }
            double x = a->numValue();
            // std::fprintf(stderr, " [TRACE] x = %f \n", x);
            acc = acc / x; 
        }
        return std::make_shared<ExprNum>(acc);
    }


}

class Eval
{
    // Reference to itself in oder to provide code completion
    Eval& self = *this;

public:
    using Env = std::map<std::string, std::shared_ptr<IExpr>>; 

    // Lisp environment 
    Env _env;

    Eval()
    {
        self.addFunction("disp",    &primitives::disp);
        // Primitive list functions 
        self.addFunction("list",    &primitives::list);
        self.addFunction("length",  &primitives::length);
        self.addFunction("car",     &primitives::car);
        self.addFunction("cdr",     &primitives::cdr);
        self.addFunction("cons",    &primitives::cons);
        self.addFunction("nth",     &primitives::nth);
        // Primitive predicate functions  
        self.addFunction("number?",  &primitives::is_number);
        self.addFunction("boolean?", &primitives::is_boolean);
        self.addFunction("symbol?",  &primitives::is_symbol);
        self.addFunction("nil?",     &primitives::is_nil);
        self.addFunction("keyword?", &primitives::is_keyword);
        self.addFunction("list?",    &primitives::is_list);
        // Primtive math functions 
        self.addFunction("=",       &primitives::equal_number);
        self.addFunction("<",       &primitives::less_than);
        self.addFunction("+",       &primitives::add);
        self.addFunction("*",       &primitives::mul); 
        self.addFunction("-",       &primitives::sub);
        self.addFunction("/",       &primitives::div);
        self.addMath1ArgFun("sin", static_cast<double (*) (double)>(&std::sin));
        self.addMath1ArgFun("cos", static_cast<double (*) (double)>(&std::cos));
        self.addMath1ArgFun("tan", static_cast<double (*) (double)>(&std::tan));
        self.addMath1ArgFun("sqrt", static_cast<double (*) (double)>(&std::sqrt));
        self.addMath1ArgFun("inv", [](double x){ return 1.0 / x; });
        self.addVariable("PI", 3.1415);

        // Parse string into a SExp - S-Expression 
        self.addFunction("read", &primitives::read);

        // Evaluate a List (AST - Abstract Syntax Tree) or SEXP returning a SEXP (S-Expression)
        self.addFunction("eval", [=](std::vector<std::shared_ptr<IExpr>> const& args)
        {
            if( args.size() != 1 )
            { throw std::runtime_error("Error: eval(sexp) requires 1 argument of type list."); } 
            if( !args[0]->isList() )
            { throw std::runtime_error("Error: eval(sexpr) expects 1 argument of type list."); }
            auto expr = static_cast<ExprLst const&>( *args[0] );
            return expr.eval(this->_env); 
        });

        // load a file 
        self.addFunction("load-file", [=](std::vector<std::shared_ptr<IExpr>> const& args)
        {
            if( args.size() != 1  && !args[0]->isStr() )
            { throw std::runtime_error("Error: load-file() requires 1 argument of type string."); } 
            auto file = args[0]->strValue(); 
            auto expr = this->evalFile(file); 
            return expr;
        });

        // Read a single S-Expression from file without evaluating it 
        self.addFunction("read-file", [=](std::vector<std::shared_ptr<IExpr>> const& args)
        {
            if( args.size() != 1  && !args[0]->isStr() )
            { throw std::runtime_error("Error: eval(sexp) requires 1 argument of type string."); } 
            auto file = args[0]->strValue(); 
            auto ifs  = std::ifstream(file);
            auto sexp  = parseSexp(ifs);
            return sexp;
        });

        // Write a single S-Expression to a file 
        self.addFunction("write-file", [=](std::vector<std::shared_ptr<IExpr>> const& args)
        {
            if( args.size() != 2  && !args[0]->isStr() )
            { throw std::runtime_error("Error: eval(sexp) requires 1 argument of type string."); } 
            auto file = args[0]->strValue(); 
            auto ofs  = std::ofstream(file);
            WriterVisitor visitor(ofs); 
            args[1]->accept(visitor);
            return std::make_shared<ExprNil>();
        });

        // Read a multiple S-Expression from file without evaluating it 
        self.addFunction("read-file-multiple", [=](std::vector<std::shared_ptr<IExpr>> const& args)
        {
            if( args.size() != 1  && !args[0]->isStr() )
            { throw std::runtime_error("Error: eval(sexp) requires 1 argument of type string."); } 
            auto file = args[0]->strValue(); 
            std::ifstream is(file);
            if( !is.good() ){ throw std::runtime_error("Error: stream has errors."); }
            std::stringstream ss;
            ss << is.rdbuf();
            auto code = "( \n" +  ss.str() + "\n )";
            auto sexp = parseSexp(code);
            return sexp;
        });


        self.addFunction("apply", [=](std::vector<std::shared_ptr<IExpr>> const& args)
        {
            if( args.size() != 2 )
            { throw std::runtime_error("Error: apply() requires 2 arguments."); } 
            if( !args[0]->isFun() )
            { throw std::runtime_error("Error: expected function as first argument."); }
            if( !args[1]->isList() )
            { throw std::runtime_error("Error: expected list as second argument."); }
            auto func = std::static_pointer_cast<ExprFun>(args[0]);
            auto params = std::static_pointer_cast<ExprLst>(args[1]); 
            return func->call(params->lst, this->_env);
        });
  
        self.addFunction("map", [=](std::vector<std::shared_ptr<IExpr>> const& args)
        {
            if( args.size() != 2 )
            { throw std::runtime_error("Error: apply() requires 2 arguments."); } 
            if( !args[0]->isFun() )
            { throw std::runtime_error("Error: expected function as first argument."); }
            if( !args[1]->isList() )
            { throw std::runtime_error("Error: expected list as second argument."); }
            auto func = std::static_pointer_cast<ExprFun>(args[0]);
            auto params = std::static_pointer_cast<ExprLst>(args[1]); 

            auto result = std::vector<std::shared_ptr<IExpr>>{};
            auto args_ = std::vector<std::shared_ptr<IExpr>>{ std::make_shared<ExprNil>() };
            result.reserve( params->lst.size() );
            for(auto const& p: params->lst){
                args_[0] = p; 
                result.push_back( func->call( args_, this->_env ) );
            }
            return std::make_shared<ExprLst>(result);

        });

        self.addFunction("for-each", [=](std::vector<std::shared_ptr<IExpr>> const& args)
        {
            if( args.size() != 2 )
            { throw std::runtime_error("Error: apply() requires 2 arguments."); } 
            if( !args[0]->isFun() )
            { throw std::runtime_error("Error: expected function as first argument."); }
            if( !args[1]->isList() )
            { throw std::runtime_error("Error: expected list as second argument."); }
            auto func = std::static_pointer_cast<ExprFun>(args[0]);
            auto params = std::static_pointer_cast<ExprLst>(args[1]); 
            for(auto const& p: params->lst){ 
                auto args_ = std::vector<std::shared_ptr<IExpr>>{ p };
                func->call( args_, this->_env ); 
            }
            return std::make_shared<ExprNil>();

        });

    }

    void addVariable(std::string const& name, double value)
    {
        auto expr = std::make_shared<ExprNum>(value);
        _env[name] = expr;
    }

    void addVariable(std::string const& name, std::shared_ptr<IExpr> expr) 
    {
        _env[name] = expr;
    }

    void addFunction(std::string const& name, LispFunc func)
    {
        auto fn = std::make_shared<ExprFunNative>(func);
        fn->name = name;
        _env[name] = fn;
    }

    template<typename Func>
    void addMath1ArgFun(std::string const& name, Func funcMath) 
    {
       auto func = [=](std::vector<std::shared_ptr<IExpr>> const& args) {
           if( args.size() != 1){
               throw std::runtime_error(" [ERROR] This function requires exactly one argument.");
           }
           auto x = args[0];
           if( x->type() != ExprType::NUM ){
               throw std::runtime_error(" [ERROR] Invalid arguument type. Number required. ");
           }
           double res = funcMath(x->numValue());
           return std::make_shared<ExprNum>(res);
       };
       auto val = std::make_shared<ExprFunNative>(func);
       val->name = name;
       _env[name] = val;
    }

    std::shared_ptr<IExpr> eval(IExpr& expr)
    {
        return expr.eval( this->_env );
    }

    // Interactive read-print eval loop0 
    void repl()
    {
        std::string line; 
        std::string arg, command; 

        for(;;)
        {
            std::cout << " $ lisp>> ";
            if( !std::getline(std::cin, line) ){ break; }
            if( line == "" ){ continue; }
            std::stringstream ss(line);
            ss >> command >> arg;
            try
            {
                if( command == ":file")
                {
                    auto res = this->evalFile(arg);
                    continue;
                }

                if( command == ":block")
                {
                    std::fprintf(stderr, " [INFO] Type a multi-line s-expression and type (;;) as the last line when you are done. \n");
                    std::string code;

                    while( line != ";;" ){ 
                        std::getline(std::cin, line);
                        code = code + "\n" + line;
                     }
                    auto res = this->evalCode(code);
                    self.addVariable("ans", res);
                    printSexp(*res);
                    continue;

                }
                auto res = this->evalCode(line);
                self.addVariable("ans", res);
                printSexp(*res);
            }
            catch(const std::exception& e)
            {
                std::cerr << e.what() << '\n';
            }

        }
    }

    /// Eval lisp-like code given as string 
    std::shared_ptr<IExpr>  
    evalCode(std::string const& code) 
    {
        auto expr = parseSexp(code);
        auto result = expr->eval(_env); 
        return result;
    }

    std::shared_ptr<IExpr>  
    evalFile(std::string const& file) 
    {
        std::ifstream is(file);
        if( !is.good() ){ throw std::runtime_error("Error: stream has errors."); }
        std::stringstream ss;
        ss << is.rdbuf();
        auto code = "(begin \n" +  ss.str() + "\n )";
        auto expr = parseSexp(code);
        auto result = expr->eval(_env); 
        return result;
    }
};

int main(){

    std::cout << " [TRACE] Testing " << std::endl;
    
    const char* text = R"( 
         ; comment1
         ;   comment 2  
         ; comment 3 
     (  print->list 
         ; comment 4
          " Hello world" A8 B100
          ; Next comment 
          #t #f 
             (+  20 30 -200(* 20 -20 x y z 8000)) ) 
    )";

    std::stringstream ss;
   
    #if 0 
    std::cout << " =========== Tokenizer  ======================== " << std::endl;
    ss << text; 
    ss << "100";
    
    Tokenizer tokenizer(ss);
    Token tok;
    
    while( !tok.isEOF() ){
        tok = tokenizer.nextToken();
        std::cout << " => " << tok.type << " ; " << tok.text 
                  << " ; line = " << tok.lin << " ; col = " << tok.col 
                  << "\n";
    }
    #endif 

    auto expr = parseSexp(text); 

    std::cout <<  std::boolalpha << " [TRACE] expr->isList() = " << expr->isList() << "\n";

    printSexp(*expr);

    std::cout << " ====== Evaluate Code  ======================== " << std::endl;

    const char* code1 = R"( 
        (list 10 #t #f "hello world" 
            ; Operation 1
            (+ 10 25 6) 
            ; Operation 2
            (* 4 2 6) )
     )";

    Eval eval; 

    auto res = eval.evalCode(code1);
    std::cout << " [TRACE] Result = ";
    printSexp(*res);

    std::cout << "============ Start LISP REPL ======================" << std::endl;
    eval.repl(); 


    return 0;
  }

#+END_SRC

Building  the lisp interpreter: 

#+BEGIN_SRC sh 
  $  g++ cpplisp.cpp -o cpplisp.bin -g -Wall -Wextra -std=c++1z
#+END_SRC

Running: 

#+BEGIN_SRC lisp
  $ >> rlwrap ./cpplisp.bin
   [TRACE] Testing 
   [TRACE] expr->isList() = true
  (  print->list " Hello world" A8 B100 #t #f (  + 20 30 -200 (  * 20 -20 x y z 8000 ) ) )
   ====== Evaluate Code  ======================== 
   [TRACE] Result = (  10 #t #f "hello world" 41 48 )
  ============ Start LISP REPL ======================
   
   $ lisp>> (list '(+ 1 2 3 4 5) (+ 1 2 3 4 5) '(* 4 100) (* 4 100) :keyword #t #f nil "Hello world")
  (  (  + 1 2 3 4 5 ) 15 (  * 4 100 ) 400 :keyword #t #f nil "Hello world" )
  
   $ lisp>> '(list (+ 1 2 3 4 5) (+ 1 2 3 4 5) '(* 4 100) (* 4 100) :keyword #t #f nil "Hello world")
  (  list (  + 1 2 3 4 5 ) (  + 1 2 3 4 5 ) (  quote (  * 4 100 ) ) (  * 4 100 ) :keyword #t #f nil "Hello world" )
  
    $ lisp>> (cons 10 20)
  Error: pairs construction not allowed. Second argument can only be a list or nil.
  
   $ lisp>> (cons 20 nil)
  (  20 )
  
   $ lisp>> (cons 10 (cons 20 nil))
  (  10 20 )
  
   $ lisp>> (cons "hello" (cons 10 (cons 20 nil)))
  (  "hello" 10 20 )
   $ lisp>> 
   $ lisp>> (cons 'world (cons "hello" (cons 10 (cons 20 nil))))
  (  world "hello" 10 20 )
  
   $ lisp>> (cons :keyword (cons 'world (cons "hello" (cons 10 (cons 20 nil)))))
  (  :keyword world "hello" 10 20 )
  
   $ lisp>> (cons sqrt (cons :keyword (cons 'world (cons "hello" (cons 10 (cons 20 nil))))))
  (  (native function) sqrt :keyword world "hello" 10 20 )
   $ lisp>> 
  
   $ lisp>> (+ 1 2 3 4 5 6)
  21
   $ lisp>> (* 1 2 3 4 5 6)
  720
   
   $ lisp>> (list 1 2 3 5 6 7 8)
  (  1 2 3 5 6 7 8 )
 
   $ lisp>> (set x 10)
   [TRACE] Defining symbol = x . 
  nil
 
   $ lisp>> ( (if (< x  5) + *)  100 20)
  2000
  
   $ lisp>> ( (if (< x  50) + *)  100 20)
  120
  
  $ lisp>> (set code "(apply + (list 1 3 4 5 6 7))")
   [TRACE] Defining symbol = code . 
  nil
  
   $ lisp>> code
  "(apply + (list 1 3 4 5 6 7))"
  
   $ lisp>> (set expr (read code)); read SExp - S-Expression from string
   [TRACE] Defining symbol = expr . 
  nil
   $ lisp>> expr
  (  apply + (  list 1 3 4 5 6 7 ) )
  
   $ lisp>> (eval expr) ;; Evaluate S-Expression 
  26
  
  $ lisp>> :block
   [INFO] Type a multi-line s-expression and type (;;) as the last line when you are done. 
  ; Execute a let-binding expression
  (let (
        (a 10)
        (b (+ (* a a) 10))
        (c (sqrt (+ a b)))
       )
     (disp a) (disp b) (disp c)
     (list :x a :y b :result3 c :z (+ a b c)))
  ;;
  10
  110
  10.9545
  (  :x 10 :y 110 :result3 10.9545 :z 130.954 )
  
   $ lisp>> a
   [ERROR] Unbound variable a
  
   $ lisp>> b
   [ERROR] Unbound variable b
  
   $ lisp>> c
   [ERROR] Unbound variable c
   $ lisp>> 
  
   $ lisp>> (load-file "code.lisp") ; Load a lisp file
   [TRACE] Defining symbol = mylist . 
   [TRACE] Defining symbol = code-fact . 
   [TRACE] Defining function = fib . 
   [TRACE] Defining function = make-adder . 
   [TRACE] Defining symbol = add10 . 
   [TRACE] Defining symbol = add50 . 
   [TRACE] Defining symbol = func . 
   [TRACE] Defining function = compute-trig . 
  nil
   $ lisp>> 
  
   $ lisp>> mylist
  (  10 #t #f "hello world" hello world :keyword1 41 (  + 10 25 6 ) :keyword2 48 (  * 4 2 6 ) )
  
   $ lisp>> (car mylist)
  10
  
   $ lisp>> (cdr mylist)
  (  #t #f "hello world" hello world :keyword1 41 (  + 10 25 6 ) :keyword2 48 (  * 4 2 6 ) )
  
   $ lisp>> (car (cdr mylist))
  #t
  
  $ lisp>> (nth 5 mylist)
  world
  
   $ lisp>> (add10 20)
  30
  
   $ lisp>> (add50 80)
  130
  
   $ lisp>> (map add10 (list 1 2 3 4 5 6 7 ))
  (  11 12 13 14 15 16 17 )
  
   $ lisp>> (map add50 (list 1 2 3 4 5 6 7 ))
  (  51 52 53 54 55 56 57 )
  
   $ lisp>> (map (fn (x) (* x x)) (list 1 2 3 4 5 6 7 )) ; Map a lambda
  (  1 4 9 16 25 36 49 )
  
   $ lisp>> (compute-trig 45)
  (  :angle 45 :cos 0.707123 :sin 0.70709 :tan 0.999954 )
  
   $ lisp>> (compute-trig 90)
  (  :angle 90 :cos 4.63268e-05 :sin 1 :tan 21585.8 )
  
   $ lisp>> (compute-trig 30)
  (  :angle 30 :cos 0.866033 :sin 0.499987 :tan 0.57733 )
  
   $ lisp>> (map compute-trig (list 30 90 45))
  (  (  :angle 30 :cos 0.866033 :sin 0.499987 :tan 0.57733 ) (  :angle 90 :cos 4.63268e-05 :sin 1 :tan 21585.8 ) (  :angle 45 :cos 0.707123 :sin 0.70709 :tan 0.999954 ) )

   $ lisp>> (func 10)
  0.1502
 
   $ lisp>> (func 1)
  0.124383

   $ lisp>> a
   [ERROR] Unbound variable a

   $ lisp>> b
   [ERROR] Unbound variable b

   $ lisp>> c
   [ERROR] Unbound variable c
   $ lisp>> 

   $ lisp>> (for-each disp (list "Hello" 'world :lisp 100 nil #t #f))
  "Hello"
  world
  :lisp
  100
  nil
  #t
  #f
  
  $ lisp>> (set make-multiplier-function (fn (mult) (fn (x) (* mult x))))
   [TRACE] Defining symbol = make-multiplier-function . 
  nil
  
   $ lisp>> (set mult-by-10 (make-multiplier-function 10))
   [TRACE] Defining symbol = mult-by-10 . 
  nil
  
   $ lisp>> (set mult-by-6 (make-multiplier-function 6))
   [TRACE] Defining symbol = mult-by-6 . 
  nil
  
   $ lisp>> (map mult-by-10 (list 1 2 3 4 5))
  (  10 20 30 40 50 )
  
   $ lisp>> (map mult-by-6 (list 1 2 3 4 5))
  (  6 12 18 24 30 )
  
   $ lisp>> ( (make-multiplier-functon 4) (list 1 2 3 4 5))
   [ERROR] Unbound variable make-multiplier-functon
  
   $ lisp>> (map (make-multiplier-function 4) (list 1 2 3 4 5))
  (  4 8 12 16 20 )
   $ lisp>> 
#+END_SRC

*** Further Reading

 *Scheme and Lisp Introduction:*

  + [[https://beautifulracket.com/appendix/glossary.html#reader][Beautiful Racket: Glossary]]

  + [[https://spritely.institute/static/papers/scheme-primer.html][A Scheme Primer]]
    + Introduction to Scheme programming language.

  + [[http://axisofeval.blogspot.com/2010/08/three-principles-of-lisp.html][The Axis of Eval: Three Principles of Lisp]]

  + [[http://calculist.org/blog/2012/04/17/homoiconicity-isnt-the-point/][Homoiconicity isn’t the point]]

  + [[https://beautifulracket.com/appendix/why-racket-why-lisp.html][Beautiful Racket: Why Racket? Why Lisp?]]

  + [[http://www.paulgraham.com/rootsoflisp.html][The Roots of Lisp]]

  + [[http://www.cs.virginia.edu/~evans/cs655/readings/steele.pdf][Growing a Language - Guy L. Steele Jr.]]

  + [[https://lwn.net/Articles/778550/][Lisp and the foundations of computing - LWN.net]]

  + [[https://gist.github.com/vindarel/c1ef5e043773921e3b11d8f4fe1ca7ac][Common Lisp VS Racket. Feedback from lispers. · GitHub]]

  + [[https://dept-info.labri.fr/~strandh/Teaching/Langages-Enchasses/Common/Strandh-Tutorial/diff-scheme.html][Differences between Scheme and Common Lisp]]

  + [[https://www-users.cse.umn.edu/~gini/4511/lisp/scheme.html][Notes on Lisp ]]

  + [[https://dreamsongs.com/Separation.html][Function Cells and Value Cells]]

  + Book: [[https://people.eecs.berkeley.edu/~bh/ss-toc2.html][Simply Scheme: Introducing Computer Science]] - 1999
   
 *About how to implement Lisp-like dialects:*
 
  + [[https://norvig.com/lispy.html][(How to Write a (Lisp) Interpreter (in Python))]]
    
  + [[http://norvig.com/lispy2.html][(An ((Even Better) Lisp) Interpreter (in Python))]]

  + [[http://fogus.me/fun/lithp/][Lithp - A interpreter for John McCarthy's original Lisp.]]
    + Interpreter written in Python in literate programming style. 

  + BOOK: [[https://en.m.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours][Write Yourself a Scheme in 48 Hours - Wikibooks, open books for an open world]]
    + Scheme implementation in Haskell programming language, that can
      be hard to understand for people not acquainted with Haskell.

  + BOOK: [[https://write-yourself-a-scheme.pangwa.com/#/][Write Yourself a scheme in 48 hours in F# (FSharp)]]

  + BOOK: [[https://wespiser.com/writings/wyas/00_overview.html][Write You A Scheme, Version 2.0]]
    + Scheme implementation in Haskell.

  + BOOK: [[https://www.buildyourownlisp.com][Learn C • Build Your Own Lisp]]

  + BOOK: [[http://t3x.org/lfn/][Lisp from nothing]] 
    + Presents how to build a metacircular LISP interpreter in common
      lisp; a metacircular lisp interpreter in Scheme; a self-hosting
      lisp compiler and garbage collector.

  + BOOK: [[https://lispcookbook.github.io/cl-cookbook/][The Common Lisp Cookbook]]
    
  + BOOK: [[https://sarabander.github.io/sicp/html/][Structure and Interpretation of Computer Programs, 2e: Top]]

  + BOOK: [[https://en.m.wikipedia.org/wiki/Structure_and_Interpretation_of_Classical_Mechanics][Structure and Interpretation of Classical Mechanics]]

  + BOOK: [[https://www.cs.cmu.edu/~dst/LispBook/][Common Lisp: A Gentle Introduction to Symbolic Computation]]

  + [[https://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html][Kwang's Haskell Blog - Write you an interpreter]]
    + Scheme implementation in Haskell.

  + [[http://kflu.github.io/2018/04/15/2018-04-15-implement-scheme/][How to write a Scheme interpreter · hello world ]] 
    + Implementation in .NET
    + Repository: https://github.com/Microsoft/schemy
      
  + [[http://peter.michaux.ca/articles/scheme-from-scratch-introduction][Scheme from Scratch - Introduction]]

  + [[https://swatson555.github.io/posts/2022-05-06-make-a-lisp-2.html][Roll A Lisp In C - Evaluation]] 

  + [[https://github.com/rzubek/CSLisp][rzubek/CSLisp: C# Scheme - Lisp implementation for embedding in .NET projects]]

  + [[https://brianmckenna.org/blog/sexp_scala][S-expression Compiler in Scala]]

  + [[http://www.elizas.website/seax/implementation/secd.html][The SECD Abstract Machine]]

  + [[https://eli.thegreenplace.net/2022/why-is-it-easy-to-implement-a-lisp/][Why is it easy to implement a Lisp? - Eli Bendersky's website]]

  + [[https://www.cs.umd.edu/class/spring2022/cmsc430/Notes.html][CMSC 430:  Design and Implementation of Programming Languages]]


 *Lisp Variants:*

  + [[https://janet-lang.org][Janet Programming Language]] (akin to Clojure)
    
  + [[https://github.com/picolisp/pil21][GitHub - picolisp/pil21: PicoLisp dialect]]

  + [[https://woodrush.github.io/blog/lambdalisp.html][LambdaLisp - A Lisp Interpreter That Runs on Lambda Calculus | Woodrush’s Blog]]

  + [[https://github.com/programming-nu/nu][NU Lisp]]
    + "Nu is an interpreted Lisp that builds on the Objective-C runtime and Foundation framework."

  + [[http://www.newlisp.org/index.cgi?FAQ][newLISP  - FAQ]] 
    + "newLISP is a general purpose scripting language for developing
      web applications and programs in general in the domains of
      artificial intelligence (AI), statistics and machine learning."

  + [[http://www.ulisp.com/show?2XZH][uLisp - ARM Assembler in Lisp]]

  + http://lush.sourceforge.net/
    
  + [[https://ccrma.stanford.edu/software/snd/snd/s7.html][s7 Scheme - Embedded Scripting Language]]

  + [[https://scsh.net/][SCSH Scheme]] - Unix-shell scripting in scheme scripting language
    + "Scsh is an open-source Unix shell embedded within Scheme,
      running on all major Unix platforms including AIX, Cygwin,
      Linux, FreeBSD, GNU Hurd, HP-UX, Irix, Mac OS X, Solaris, and
      some others. Scsh is a variant of Scheme 48 (an R5RS compliant
      new-tech Scheme system) Scsh is designed for writing real-life
      standalone Unix programs and shell scripts. Scsh spans a wide
      range of application, from “script” applications usually handled
      with perl or sh, to more standard systems applications usually
      written in C."

  + [[https://scsh.net/docu/html/man-Z-H-1.html][Scsh - Scheme Unix Shell Scripting - Reference Manual]]
    + "This is the reference manual for scsh, a Unix shell that is
      embedded within Scheme. Scsh is a Scheme system designed for
      writing useful standalone Unix programs and shell scripts -- it
      spans a wide range of application, from ``script'' applications
      usually handled with perl or sh, to more standard systems
      applications usually written in C. Scsh comes built on top of
      Scheme 48, and has two components: a process notation for
      running programs and setting up pipelines and redirections, and
      a complete syscall library for low-level access to the operating
      system. This manual gives a complete description of scsh. A
      general discussion of the design principles behind scsh can be
      found in a companion paper, ``A Scheme Shell.'' "

  + [PDF] [[https://www.ccs.neu.edu/home/shivers/papers/scsh.pdf][A Scheme Shell - MIT - Olin Shivers]]

  + [PDF] [[https://3e8.org/pub/scheme/doc/lisp-pointers/v6i3/p71-petrus.pdf][SKILL: a Lisp Based Extension Language]]

  + [PDF] [[https://community.cadence.com/cfs-file/__key/telligent-evolution-components-attachments/00-28-01-00-00-01-04-75/CadScriptingLanguages_5F00_skill.pdf][A quick tour to skill programming language - Cadence CAD / Lisp.]]

  + [PDF] [[https://perun.pmf.uns.ac.rs/radovanovic/publications/2002-prim-lisp.pdf][An implementation of LISPKIT Lisp in Java]] (SECD Abstract Machine)

  + [[http://www.lispme.de/lispme/doc/lm_hood.htm][LispMe internals]]
    + This implementation uses a SECD Virtual Machine instead of a
      recursive AST evaluator. The code is compiled to SECD machine
      bytecodes and later executed by a SECD virtual machine.

  + [[http://kflu.github.io/2018/04/15/2018-04-15-implement-scheme/][How to write a Scheme interpreter · hello world ]] 
    + Implementation in .NET
    + Repository: https://github.com/Microsoft/schemy

  + [[https://github.com/shikantaza/pLisp][GitHub - shikantaza/pLisp: Don't Lisp, Talk!]]
    
  + [[https://european-lisp-symposium.org/static/2018/jayaprakash.pdf][pLisp: A Friendly Lisp IDE for Beginners]]
    + "pLisp is an integrated development environment for Lisp. While
      it aims to be a friendly Lisp development system for beginners,
      its feature-set is comprehensive enough to address the needs of
      a small-to-medium sized Lisp project."
    + Note: Based on Commonlisp, Scheme and Smalltalk. 

  + [[https://paulhammant.com/2013/03/28/interface-builders-alternative-lisp-timeline/][Interface Builder's Alternative Lisp timeline]]

  + [[https://www.softwarepreservation.org/projects/LISP/le_lisp][Le_Lisp — Software Preservation Group]]

  + [[https://gitlab.com/embeddable-common-lisp/ecl/][Embeddable Common-Lisp / ECL · GitLab]]

  + [[https://www.isi.edu/isd/LOOM/Stella/index.html][STELLA Programming Language / Lisp that compiles to Java or C++ ; lisp]]

  + [[https://github.com/kanaka/mal][GitHub - kanaka/mal: mal - Make a Lisp]]
    + "Each implementation of mal is separated into 11 incremental,
      self-contained (and testable) steps that demonstrate core
      concepts of Lisp. The last step is capable of self-hosting
      (running the mal implementation of mal). See the make-a-lisp
      process guide. Mal is implemented in 87 languages (93 different
      implementations and 115 runtime modes)."

  + [[https://web.archive.org/web/20160324184251/https://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html][Embedding Scheme for a game mission scripting DSL]]

  + [[https://en.m.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp][Game Oriented Assembly Lisp - Wikipedia]]

  + [[https://opengoal.dev][OpenGOAL | OpenGOAL]]

  + [[https://www.gamedeveloper.com/design/postmortem-naughty-dog-s-i-jak-and-daxter-the-precursor-legacy-i-][Postmortem: Naughty Dog's Jak and Daxter: the Precursor Legacy]]

  + [[https://all-things-andy-gavin.com/2011/03/12/making-crash-bandicoot-gool-part-9/][Making Crash Bandicoot – GOOL – part 9 - All Things Andy Gavin]]

  + [PDF] [[https://www.dreamsongs.com/Files/Timrep.pdf][Performance and Evaluation of Lisp Systems]]

  + _AutoLisp_ - Lisp Dialect, based on common lisp, used by Autocad
    software for engineering drawings.
    + [[https://en.wikipedia.org/wiki/AutoLISP][AutoLISP - Wikipedia]]
    + [[https://www.afralisp.net/index.php][Learn AutoLISP for AutoCAD productivity]]
    + [[https://www.cad-notes.com/good-autolisp-programming-techniques/][Good AutoLISP Programming Techniques]]
    + [PDF] [[http://docs.autodesk.com/ACDMAC/2013/ENU/PDFs/acdmac_2013_autolisp_developers_guide.pdf][AutoCAD 2013 AutoLISP Developer's Guide]]
    + https://autocadtips1.com/category/autolisp-3d/


 *Common Lisp:*

  + [[http://www.n-a-n-o.com/lisp/cmucl-tutorials/LISP-tutorial.html][Common LISP Hints - 1993]]

  + [[https://mikelevins.github.io/posts/2020-12-18-repl-driven/][On repl-driven programming - by mikel evins]]

  + [[https://journal.infinitenegativeutility.com/structurally-typed-condition-handling][Structurally-Typed Condition Handling — Infinite Negative Utility]]

  + [[http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html][Condition Handling in the Lisp Language Family'' c by Kent Pitman]]

  + [[https://lisper.in/restarts][Common Lisp: A Tutorial on Conditions and Restarts]]

  + [[https://www.kazimirmajorinc.com/Documents/On-Pitmans-Special-forms-in-Lisp/index.html][On Pitman's „Special forms in Lisp“]]

  + [[https://ostash.dev/posts/2021-06-24-edn-data-notation/][Data notation in Clojure - Ostash.Dev]]

  + [[http://www.lispworks.com/documentation/lw71/COM/html/com-11.htm#pgfId-889564][LispWorks - 1.7 Calling COM interface methods]]

  + [[https://courses.cs.northwestern.edu/325/readings/clos.php][The Common Lisp Object System]]

  + [[https://lisper.in/reader-macros][Reader Macros in Common Lisp]]

  + [[https://gist.github.com/chaitanyagupta/9324402][Reader Macros in Common Lisp · GitHub]]

  + [[https://www.lurklurk.org/cpp_clos.html][C++ and Lisp / multiple dispatch, multimethod, visitor design pattern]]

  + [[https://sodocumentation.net/common-lisp/topic/1369/loop--a-common-lisp-macro-for-iteration][common-lisp Tutorial - LOOP, a Common Lisp macro for iteration]]

  + [[https://borodust.org/delivering-common-lisp][Delivering games written in Common Lisp]]

  + [[https://texdraft.github.io/lisp-compiler/internals.html][Lisp Compiler]]


 *S-Expression Parsing:*

  + [[https://wiki.c2.com/?EssExpressions][Wiki C2 - ESS Expressions]]

  + [[https://rosettacode.org/w/index.php?title=S-expressions&useformat=mobile][S-expressions - Rosetta Code]]

  + [[https://github.com/edn-format/edn][EDN / Clojure - edn-format/edn: Extensible Data Notation]] 
    + Clojure variant of S-Expressions (SExp) - Clojure EDN is easier
      to read and has more rich data types than lisp's SEXP.
    
  + [[https://learnxinyminutes.com/docs/edn/][Clojure EDN - Learn edn in Y Minutes]]

  + [[https://gist.github.com/DmitrySoshnikov/2a434dda67019a4a7c37][S-expression parser · GitHub]] (JavaScript)

  + [[https://wiki.c2.com/?XmlIsaPoorCopyOfEssExpressions][WIKI C2 - Xml Isa Poor Copy Of Ess Expressions]]

  + [[https://eli.thegreenplace.net/2012/03/04/some-thoughts-on-json-vs-s-expressions][Some thoughts on JSON vs. S-expressions]]

  + [[https://wiki.c2.com/?ExampleOfGreenspunsTenthAtWork][Example Of Greenspuns Tenth At Work]]

  + [[https://kitchingroup.cheme.cmu.edu/blog/2017/05/04/An-emacs-lisp-dsl-for-gnuplot/][An Emacs Lisp DSL for GNU Plot]]

  + [[https://macoy.me/blog/programming/CakelispIntro][Cakelisp: a programming language for games]]

  + [[https://people.csail.mit.edu/rivest/Sexp.txt][S-expressions data structure - Ron Rivest]]

  + [[https://github.com/janestreet/sexplib][GitHub - janestreet/sexplib: Automated S-expression conversion]]
    + OCaml S-Expression parser

  + [[https://blog.janestreet.com/s-expressions-in-ruby/][S-Expressions in ruby - Janestreet]]
    + "We use a lot of S-Expressions at Jane Street. Almost every
      system written at Jane Street in OCaml uses sexps for config
      files, and we use it for a lot of IPC (Inter-Process
      Communication) when resources aren’t an issue."

  + [[https://dev.realworldocaml.org/data-serialization.html][Data Serialization with S-Expressions - Real World OCaml]]

  + [[https://github.com/dryruby/sxp.rb][SXP - A universal S-expression parser for Ruby]]
    + "This is a Ruby implementation of a universal S-expression
      parser. Parses S-expressions in universal, Scheme, Common Lisp,
      or SPARQL syntax."

  + [[https://jena.apache.org/documentation/notes/sse.html][SPARQL S-Expressions (or "SPARQL Syntax Expressions")]]

  + https://github.com/BitPuffin/sexpresso
    + C++ S-Expression parser library

  + https://github.com/SuperTux/sexp-cpp
    + C++ S-Expression parser library (GPL 3)

  + [[https://hackage.haskell.org/package/s-cargot][s-cargot: A flexible, extensible s-expression library]]
    + Haskell S-Expression parser. The description of this page also
      tells how SExp can be used as storage format, serialization
      format and data description language.

  + [[https://github.com/drslump/sexp-php][GitHub - drslump/sexp-php: S-expression parser and serializer for PHP]]

  + [[https://srfi.schemers.org/srfi-110/srfi-110.html][SRFI 110: Sweet-expressions (t-expressions)]]


