#+INCLUDE: theme/style.org 
#+TITLE: Embedded Scripting Languages Survery 
#+DESCRIPTION: cpp/c++ embedded scripting languages survey 
#+STARTUP: content 

* Embedded Scripting Languages 
** Reasonable Features of Embedded Scripting Languages

This section lsits some reasonable features that a language designed
to be embedded should have:

   + _Ligthweight_ -  Small footprint, small size and memory requirements. 

   + _Scripting Engine as a library_:
     + Must be available as C or C++ library which exposes the
       interpreter API allowing the client code to evaluate scripting
       code from strings or files and also to retrieve objects from the
       virtual machine memory.

   + _Sandboxing or capability limitations_
     + A reasonable requirement for an embedded scripting language is
       limiting the capabilities and APIs which can be used possibly
       allowing the execution of non-trusted scripts. Example: the
       Javascript engines of most web browsers do not allow the script
       to interact with file systems or operating system APIs.

   + _Permissive License for static linking_ 

   + _Use Cases_
     + DSL - Domain Specific Languages 
     + Game Engines 
     + Configuration files => Data Description language. 
     + User content
     + Allow application runtime changes without recompilation.
     + User extension without modification of source code. 

Examples of embedded scripting languages usage and use-cases: 

     * TCL - Tool Command Language => Used by many EDA - Electronic
       Design Automation Sofware in electronic engineering.

     * JavaScript => Used in Web Browsers, which are written mostly in
       C++, for controlling user interaction, animation and etc. 

     * TinyScheme => Used by GNU GIMP drawing application ans Apple's
       MacOSX sandbox configuration. 

     * Lua language => Used by many game engines and also by
       applications such as: Nginx web server; Linux Conky; Geany
       Editor; NMap editor and so on.

     * Squirrel Language => Used in game engines

     * Python
       + => Python is used as embedded scripting language by GDB - GNU
         Debugger ; WinDBG  - Windows Debugger; IDA - Debugger for
         Reverse Engineering.
       + Disadvantages: Python has a large footprint; it was not
         designed as an embedded scripting language and it is not
         possible to forbid the interpreter from calling file system
         and process creation APIs.

     * AutoLisp [proprietary] => Lisp-like language used in Autocad.

     * SQL (Structured Query Language) => Many databases are
       implemented in C or C++ uses SQL as scripting language and
       domain specific language (DSL) for querying and storing
       data. Example: SQLite, Postgres SQL, ...

     * Emacs Lisp => Emacs core, including the LISP
       engine/interpreter, is written in C and other parts are
       written in Emacs Lisp. This lisp dialect allows extending Emacs
       at with custom extensions (plugins) and also modifying the
       application behavior at runtime.

     * VBA - Visual Basic for Application [proprietary] => Used in
       Microsft Office Suite, specially in Microsft Excel.


Considerations for choosing embedded scripting languages: 

  + Small footprint and small overhead

  + C++ API bindings 

  + Garbage collector implementation 

  + Permissive license for static linking or option of dual license
    for static linking. 

  + Heavy duty computations with significant overhead should be
    performed on the C++-side, specially loops.

  + JIT - Just-In-Time compiler => can increase the performance by
    translating bytecodes into machine code.
    + Example: Lua JIT, Javascript V8 engine used by Chrome browser. 

  + Features for running untrusted scripts or configuration: 

    * Ability for restricting capabilities such as creating process,
      accessing the file system and so on.

    * Non-turing complete => better for configuration 

** Squirrel Scripting Language 
*** Overview 

   + Squirrel is a embedded scripting language, similar to Lua, but with
     C-like syntax, designed to be embedded in larger C or C++
     applications such as game engines. Squirrel is written in C++, but
     it only exposes a C API, which makes binding C++ code
     cumbersome. However, there are many libraries which simplifies the
     embedding of squirrel in C++ codebases.

 *Official Web Site*

   + http://www.squirrel-lang.org/

 *Official Repository* 

   + https://github.com/albertodemichelis/squirrel

 *Squirrel fork with a more C++-like syntax*

 + https://github.com/mingodad/squilu

 *Articles about squirrel language*

  + [[https://developer.electricimp.com/squirrel/squirrelcrib][Squirrel Programming Guide | Dev Center]]

  + [[https://www.ibm.com/developerworks/aix/library/au-spunix_squirrel/index.html][Speaking UNIX: The Squirrel portable shell and scripting language]]

  + http://wiki.ogre3d.org/Squirrel+Scripting+Language

 *Applications using Squirrel*

  * CodeBlocks IDE for C and C++

  * OpenTTD Game - http://www.openttd.org/en/

 
 *Libraries for simplifying embedding squirrel in C++ code* 
 
Libraries for simplifying squirrel embedding in C++ code (binding
C++ code):

     + *SQPlus*
       + http://wiki.squirrel-lang.org/default.aspx/SquirrelWiki/SqPlus.html

     + *SQrat*
       + http://scrat.sourceforge.net/

     + *Squal*
       + https://github.com/jonigata/squall

     + *SimpleSquirrel*
       + https://github.com/matusnovak/simplesquirrel

*** Building Squirrel standalone REPL interpreter 

Download and build: 


#+BEGIN_SRC sh 
  $ mkdir ~/build && cd build 
  $ git clone https://github.com/albertodemichelis/squirrel
  $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug 
  $ cmake --build _build --target
#+END_SRC

Play with squirrel interactive shell (REPL):

#+BEGIN_SRC sh 
  $ _build/bin/sq
  Squirrel 3.1 stable Copyright (C) 2003-2017 Alberto Demichelis (64 bits)

  sq> print(" === Hello world Squirrel === ")
   === Hello world Squirrel === 

  sq> function add_to_10(x){ return x + 10; }

  sq>print(add_to_10(25))
  35

  sq> x <- cos(3.1415 / 2) + 10 

  sq>print(" x = " + x.tostring())
   x = 10

  sq> for(local i = 0; i < 5; i++) print(" \n [TRACE] i = " + i.tostring());

   [TRACE] i = 0 
   [TRACE] i = 1 
   [TRACE] i = 2 
   [TRACE] i = 3 
   [TRACE] i = 4
#+END_SRC

*** Example - embedding Squirrel with Squall Library 

This example demonstrates how to embed the Squirrel programming
language in a C++ application using the Squall header-only library. 

   + Squal Repository: https://github.com/jonigata/squall

   + Note: This project is self-contained, no library needs to be
     installed on the system as Squall automatically fetches Squirrel
     sources using Cmake FetchContent. 

 *Sample Project* 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
   cmake_minimum_required (VERSION 3.11)
   project(squirrel_squall_test)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED on)
   set(BUILD_EXAMPLES off)

   # -----------------------------------------------#
   include(FetchContent)

   FetchContent_Declare(
     squall 
     URL      https://github.com/jonigata/squall/archive/master.zip
     )

   FetchContent_MakeAvailable(squall)

   #-------- TARGET DEFINITIONS --------------------#
   message([TRACE] " squall_SOURCE_DIR = ${squall_SOURCE_DIR}/squall  ")

               add_executable ( squirrel-test squirrel_test.cpp)
        target_link_libraries ( squirrel-test squirrel_static sqstdlib_static)
   target_include_directories ( squirrel-test PUBLIC
                                  ${squirrel_SOURCE_DIR}/include
                                  ${squall_SOURCE_DIR}
                                  )
#+END_SRC

File: squirrel_test.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string>
   #include <algorithm>
   #include <vector> 

   #include <squall/squall_vmstd.hpp>
   #include <squall/squall_klass.hpp>

   void some_cpp_fun(int n )
   {
       for(int i = 0; i < n; i++)
           std::printf("\n   [some_cpp_function] => i = %d ", i);
   }

   class ChartXY
   {
       int m_width; 
       int m_height;
   public:
       ChartXY(): m_width(20), m_height(50) 
       {
           std::cout << " [ChartXY] Ctor() - I was created!. OK. " << std::endl;
       }

       void set_width(int x){ m_width = x; }
       void set_height(int x){ m_height = x; }

       void draw() const 
       { 
           std::printf(" [ChartXY] draw() => Draw chart with: width = %d ; height = %d"
                       , m_width, m_height);
       }
   };

   int main()
   {
       // Create a virtual-machine object for Squirrel language 
       // Note: throws squall::squirrel_error
       squall::VMStd vm; 

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 1] Evaluate scripts provided as strings                     //
       //-------------------------------------------------------------------------//
       std::puts(" =>> [EXPERIMENT] 1 - Evaluating code as string. ");  
       std::puts(" ---------------------------------------------\n");

       try {

           vm.dostring(R"( 
               // --- Squirrel Comment ----- // 
               print(" <SQUIRREL>  =>> Hello world squirrel!");

               function myfunc(x) {  
                   local a = x + 5;
                   local b = 7 * a + x;
                   return b - a + 10;  
               }

               function myfunc2() {
                   print(" \n  <SQUIRREL> I was called by the C++ code ");
               }

               print("\n <SQUIRREL> =>> myfunc(4) = " + myfunc(4).tostring() );

               print("\n\n <SQUIRREL> --- For Loop test ---- ");
               for(local i = 0; i < 5; i++) { 
                    print("\n   i = " + i.tostring() );  
               }
           )");

       } catch( squall::squirrel_error const& ex )
       {
           std::cerr << "\n [SQUIRREL ERROR] Error =>  " << ex.what() << std::endl;        
       }

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 2] Evaluate scripts provided as strings                     //
       //-------------------------------------------------------------------------//
       std::puts("\n =>> [EXPERIMENT] 2 - Getting variables defined in the code.");  
       std::puts(" -----------------------------------------------------------\n");

       {
           vm.dostring(R"( 
               // ---- Global varibles for configuration ------ // 
               ::myvar_width <- 100;
               ::myvar_float <- 122.56161;
               ::myvar_string <- "/path/to/interpreter.exe"; 
           )");

           squall::TableBase table = vm.root_table();
           auto myvar_float = table.get<float>("myvar_float");       
           auto myvar_width = table.get<int>("myvar_width");
           auto myvar_string = table.get<std::string>("myvar_string");
           std::cout << "  =>>  myvar_width = " << myvar_width << std::endl;
           std::cout << "  =>>  myvar_float = " << myvar_float << std::endl;
           std::cout << "  =>> myvar_string = " << myvar_string << std::endl;
       } 

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 3] Call functions defined in the script (Virtual Machine )  //
       //-------------------------------------------------------------------------//    
       std::puts("\n\n =>> [EXPERIMENT] 3 - Calling functions defined in the script (VM)");
       std::puts(" ------------------------------------------------------------------\n");    
       // Throws: 'squall::squirrel_error' 
       int result = vm.call<int>("myfunc", 10);
       std::cout << "   =>>> myfunc(4) = " << result << std::endl;

       vm.call<void>("myfunc2");

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 4] Call C++ functions from the script                       //
       //-------------------------------------------------------------------------//    
       std::puts("\n\n =>> [EXPERIMENT] 4 - Calling functions defined in the script (VM)");
       std::puts(" ------------------------------------------------------------------\n");

       // Register C++ function pointer 
       vm.defun("some_cpp_fun", &some_cpp_fun);

       vm.dostring(R"(
           print(" \n [SQUIRREL] => Call C++ function some_cpp_fun() ");
           some_cpp_fun(5);
        )");


       // Register C++ lambda object 
       vm.defun("call_me", [=](std::string const& param) {
           std::cout << "\n [TRACE] call_me() Parameter = " << param << "\n";
           return  " name = " + param;
       });

       vm.dostring(R"(
           local x = call_me("<SQUIRREL-INTERPRETER>");
           print(" [SQUIRREL] \n x <- " + x);
        )");

       // ------------------------------------------------------------------------//
       // [EXPERIMENT 5] Call C++ classes from Squirrel-side                     //
       //-------------------------------------------------------------------------//    
       std::puts("\n\n =>> [EXPERIMENT] 5 - Calling C++ classes from Squirrel        ");
       std::puts(" ------------------------------------------------------------------\n");

       // Create metaobject 'k' that describes ChartXY class 
       squall::Klass<ChartXY> k(vm, "ChartXY");
       k.func("set_width",  &ChartXY::set_width);
       k.func("set_height", &ChartXY::set_height);
       k.func("draw",       &ChartXY::draw);

       vm.dostring(R"( 
           function manipulate_chart(ch){           
               ch.set_width(25);
               ch.set_height(10);
               ch.draw();
           }

           function draw_with(ch, w, h)
           {
               print(" \n [SQUIRREL LOG] Function draw_with called. OK. \n");
               ch.set_width(w);
               ch.set_height(h);
               ch.draw();
           }
        )");

       ChartXY mychart;
       vm.call<void>("manipulate_chart", &mychart);
       vm.call<void>("draw_with", &mychart, 100, 200);

       std::cout << "\n\n";

       squall::TableBase table = vm.root_table();

       // Pass object to Squirrel side 
       table.set("mychart", mychart);

       vm.dostring(R"(
           mychart.set_width(250);
           mychart.set_width(600);
           mychart.draw();
       )");


   #if 0  
       // Segmentation Falt Coredump if the C++ object 
       // is created on the Squirrel-side.
       vm.dostring(R"(
           local c = ChartXY();
           c.set_width(150);
           c.set_height(175);
           c.draw();
       )");
   #endif 

       return 0;
   }
#+END_SRC

Build: 

#+BEGIN_SRC sh 
   $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug 
   $ cmake --build _build --target 
#+END_SRC

Check executable dependencies: 

#+BEGIN_SRC sh 
 $ ldd _build/squirrel-test 
	linux-vdso.so.1 (0x00007ffe34dd6000)
	libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007fd3ebd2a000)
	libm.so.6 => /lib64/libm.so.6 (0x00007fd3ebbe4000)
	libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007fd3ebbc9000)
	libc.so.6 => /lib64/libc.so.6 (0x00007fd3eb9ff000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fd3ebf3e000)
#+END_SRC

Run application: 

#+BEGIN_SRC sh 
   $ _build/squirrel-test 

   =>> [EXPERIMENT] 1 - Evaluating code as string. 
   ---------------------------------------------

   <SQUIRREL>  =>> Hello world squirrel!
   <SQUIRREL> =>> myfunc(4) = 68

   <SQUIRREL> --- For Loop test ---- 
     i = 0
     i = 1
     i = 2
     i = 3
     i = 4
   =>> [EXPERIMENT] 2 - Getting variables defined in the code.
   -----------------------------------------------------------

    =>>  myvar_width = 100
    =>>  myvar_float = 122.562
    =>> myvar_string = /path/to/interpreter.exe


   =>> [EXPERIMENT] 3 - Calling functions defined in the script (VM)
   ------------------------------------------------------------------

     =>>> myfunc(4) = 110

    <SQUIRREL> I was called by the C++ code 

   =>> [EXPERIMENT] 4 - Calling functions defined in the script (VM)
   ------------------------------------------------------------------


   [SQUIRREL] => Call C++ function some_cpp_fun() 
     [some_cpp_function] => i = 0 
     [some_cpp_function] => i = 1 
     [some_cpp_function] => i = 2 
     [some_cpp_function] => i = 3 
     [some_cpp_function] => i = 4 
   [TRACE] call_me() Parameter = <SQUIRREL-INTERPRETER>
   [SQUIRREL] 
   x <-  name = <SQUIRREL-INTERPRETER>

   =>> [EXPERIMENT] 5 - Calling C++ classes from Squirrel        
   ------------------------------------------------------------------

   [ChartXY] Ctor() - I was created!. OK. 
   [ChartXY] draw() => Draw chart with: width = 25 ; height = 10 
   [SQUIRREL LOG] Function draw_with called. OK. 
   [ChartXY] draw() => Draw chart with: width = 100 ; height = 200

   [ChartXY] draw() => Draw chart with: width = 600 ; height = 200


#+END_SRC
** Duktape - Embeddable Javascript Engine 
*** Overview 

  + Duktape is a small footprint embeddable Javascript (ECMAScript)
    engine, written in C, which can be used for providing scripting
    capabilities for C or C++ applications.

  + License: MIT

  + Possible Use Cases:
    + Configuration
    + Data description language
    + User plugins
    + User extensions
    + Scripting for games 

  + Features:
    + Embeddable, portable, compact: can run on platforms with 160kB
      flash and 64kB RAM 
    + Built-in debugger
    + Built-in regular expression engine
    + Minimal, retargetable platform dependencies
    + Combined reference counting and mark-and-sweep garbage
      collection with finalization 
    + Bytecode dump/load for caching compiled functions
    + Distributable includes an optional logging framework,
      CommonJS-based module loading implementations, etc 

 *Official Website* 

  + https://duktape.org/

  + https://duktape.org/download.html
   
 *Official Repository* 

   + https://github.com/svaarala/duktape 

  *C++ Binding Libraries*  

   + https://github.com/Aloshi/dukglue/    

   + https://github.com/stfwi/duktape-cc
*** Example project with DukGlue C++ binding library 

This following project CMakeLists.txt automatically downloads _dukglue_
binding library and _duktape_ engine sources and builds a C++ demonstration
code embedding duktape JavaScript engine. 

  + DukGlue Binding Library: https://github.com/Aloshi/dukglue
    + Advantage:
      * Easy to use and lots of examples. 
    + Drawbacks:
      * Lack of namespaces which enhances API discoverability
      * Lack of C++ wrappers to some Duktape C-types
      * Lack of a CMakeLists.txt at the top directory. 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.0)
  project(duktap-embed)

  include(FetchContent)

  # Download library archive (zip, *.tar.gz, ...) from URL
  macro(Download_Library_Url NAME URL)
    FetchContent_Declare(${NAME} URL  ${URL})
    FetchContent_GetProperties(${NAME})
    if(NOT ${NAME}_POPULATED)
      FetchContent_Populate(${NAME})
     # add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})
    endif()
  endmacro()


  # ====>> Duktape JavaScript Engine Configuration <<===========#

  Download_Library_Url(duktape
    "https://duktape.org/duktape-2.5.0.tar.xz"
    )

  # FetchContent_MakeAvailable(duktape)

  message( [TRACE] " =>> duktape_SOURCE_DIR = ${duktape_SOURCE_DIR} ")


  file(GLOB_RECURSE duktape_sources "${duktape_SOURCE_DIR}/src/*.c")
  file(GLOB_RECURSE duktape_headers "${duktape_SOURCE_DIR}/src/*.h")

  message( [TRACE] " duktape_sources = ${duktape_sources} ")

                add_library (duktape ${duktape_sources} ${duktape_headers} )
  target_include_directories(duktape PUBLIC ${duktape_SOURCE_DIR}/src  )

  # ----------- DukGlue Library ----------------------------#

  FetchContent_Declare(
    dukglue 
    URL       https://github.com/Aloshi/dukglue/archive/master.zip
    )

  FetchContent_MakeAvailable(dukglue)

  #----- Main Target Definition ----------------------------#
  add_executable(duktape-embed duktape-embed.cpp)
  target_link_libraries(duktape-embed duktape dukglue)

#+END_SRC

File: duktape-embed.cpp 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string>
   #include <vector>
   #include <cassert> 

   // Repository: https://github.com/Aloshi/dukglue
   #include <dukglue/dukglue.h>

   void print_number(int x)
   {
     std::cout << " [TRACE] number passed is = " << x << std::endl;
   }

   void log_text(std::string const& text)
   {
       std::cout <<  " =>> [C++-LOG] - " << text << std::endl;
   }

   int eval_code(duk_context* ctx, std::string const& code)
   {
       return duk_peval_string(ctx, code.c_str());
   }

   void plot_points(std::vector<float> const& points)
   {
     std::cout << "  =>> [TRACE] Plot points  =>> ";
     for(auto const& x: points) { std::cout << " x = " << x; }
     std::cout << " \n";
   }

   class Counter {
   private: 
       std::string m_name;
       int         m_counter;

   public: 

       // Ctor [1] => Default ctor 
       Counter(): Counter("untitled", 0) { }

       // Ctor [2]
       Counter(std::string name, int counter)
         : m_name{std::move(name)}, m_counter{counter}
       { 
           std::cout << " [TRACE] Counter created with =>  { " 
                     <<   " name = " << m_name 
                     << " ; counter = " << m_counter 
                     << " } \n";
       }

       int getCounter() const { return m_counter; }
       void setCounter(int n) {       
         m_counter = n; 
         std::cout << " [TRACE] I was set to value " << n << std::endl;
       }

       void increment() {       
         m_counter++; 
         std::cout << " [TRACE] increment event =>> counter = {  " 
                   << m_name << " ; " << m_counter 
                   << " } " << std::endl;
       }    

   };


   int main()
   {
         // Create Duktape Virtual machine 
         duk_context* ctx = duk_create_heap_default();

         /* ========================== EXPERIMENT 1 =============*/
         std::puts("\n === [EXPERIMENT 1] ==>> Register and call C++ functions <<===== ");
         {
             // Register pointer to functions function (function pointer) in 
             // the JS engine (aka virtual machine)
             dukglue_register_function(ctx, &print_number, "print_number"); 
             dukglue_register_function(ctx, log_text, "log_text");
             dukglue_register_function(ctx, plot_points, "plot_points");

             const char* code1 = R"(
                 print_number(10);
                 log_text(" Hello world from Javascript" ); 
                 log_text(" Toke is equal to " + 100 ); 
                 log_text( " " + 1000 );      

                 plot_points( [ 20.5, 100.23, -125.254, 8.251, 100.0 ]);
             )";

             // Evaluate code, returns false on error 
             auto n = eval_code(ctx, code1);

             if(n) { std::cerr << " [ERROR] A duktape evaluation error has happened. "  << std::endl; }

         }

         /* ========================== EXPERIMENT 2 ====================*/
         std::puts("\n === [EXPERIMENT 2] ==>> Register and call C++ classes <<===== \n");
         {
             // Register class counter 
             dukglue_register_constructor<Counter>(ctx, "Counter");      
             dukglue_register_constructor<Counter, std::string, int>(ctx,  "Counter");     
             dukglue_register_method(ctx, &Counter::getCounter , "getCounter");
             dukglue_register_method(ctx, &Counter::setCounter , "setCounter");
             dukglue_register_method(ctx, &Counter::increment , "increment");

             dukglue_register_property(ctx                   // Pointer to engine (VM)
                                     , &Counter::getCounter  // Getter 
                                     , &Counter::setCounter  // Setter 
                                     , "number"              // Property name 
                                     );

             int ret = eval_code(ctx, R"( 
                 var counter = new Counter("mycounter", 10); 

                 for(i = 0 ; i < 5; i++) { counter.increment(); }

                 var n = counter.getCounter(); 
                 log_text(" [BEFORE] Counter value = " + n );

                 counter.setCounter(100);
                 log_text(" [AFTER 1 ] Counter value = " + counter.getCounter() );

                 counter.number = 400;
                 log_text(" [AFTER 2] Counter value = " + counter.number );
             )");
             assert( ret == 0 );

         }

         /* ======= Calling Javascript Engine from C++ ====================*/
         // Note: It is useful for reading data or user configuration 
         std::puts("\n === [EXPERIMENT 3] ==>> Calling engine objects from C++ <<===== \n");
         {
             const char* code = R"(
               // Global variables for configuration 
               points = 200; 
               asset_path = "C:\\\\Users\\dummy\\data\\graphics";

               function my_js_function(n){
                   log_text( " <my_js_function> =>> n = " + n );
                   var k = 20 * n + 100;
                   return k; 
               }

             )";
             eval_code(ctx, code);

             // Throws error: DukErrorException
             auto points = dukglue_peval<int>(ctx, "points");
             std::cout << "  [*] =>> points = " << points << std::endl;

             // Throws error: DukErrorException
             auto asset_path = dukglue_peval<std::string>(ctx, "asset_path");
             std::cout << "  [*] =>> asset_path = " << asset_path << std::endl;

             auto jsexpr = dukglue_peval<double>(ctx, "3.51 * 10.52 - 8.251 / 100");
             std::cout << "  [*] jsexpr = " << jsexpr << std::endl;

             // Call Javascript function from C++ 
             auto func = dukglue_peval<DukValue>(ctx, "my_js_function");
             int res = dukglue_pcall<int>(ctx, func, 20);
             std::cout << "  [*] res = " << res << std::endl;

         }

       // Release Javascript engine object (aka virtual machine)
       ::duk_destroy_heap(ctx);

       return 0;
   }

#+END_SRC

Build: 

#+BEGIN_SRC sh 
  $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build _build --target 
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
   $ ./build/duktape-embed 

   === [EXPERIMENT 1] ==>> Register and call C++ functions <<===== 
   [TRACE] number passed is = 10
   =>> [C++-LOG] -  Hello world from Javascript
   =>> [C++-LOG] -  Toke is equal to 100
   =>> [C++-LOG] -  1000
    =>> [TRACE] Plot points  =>>  x = 20.5 x = 100.23 x = -125.254 x = 8.251 x = 100 

   === [EXPERIMENT 2] ==>> Register and call C++ classes <<===== 

   [TRACE] Counter created with =>  {  name = mycounter ; counter = 10 } 
   [TRACE] increment event =>> counter = {  mycounter ; 11 } 
   [TRACE] increment event =>> counter = {  mycounter ; 12 } 
   [TRACE] increment event =>> counter = {  mycounter ; 13 } 
   [TRACE] increment event =>> counter = {  mycounter ; 14 } 
   [TRACE] increment event =>> counter = {  mycounter ; 15 } 
   =>> [C++-LOG] -  [BEFORE] Counter value = 15
   [TRACE] I was set to value 100
   =>> [C++-LOG] -  [AFTER 1 ] Counter value = 100
   [TRACE] I was set to value 400
   =>> [C++-LOG] -  [AFTER 2] Counter value = 400

   === [EXPERIMENT 3] ==>> Calling engine objects from C++ <<===== 

    [*] =>> points = 200
    [*] =>> asset_path = C:\\Users\dummy\data\graphics
    [*] jsexpr = 36.8427
   =>> [C++-LOG] -  <my_js_function> =>> n = 20
    [*] res = 500


#+END_SRC
*** Example project with Duktape-CC binding library 

  + Duktape-CC binding library: https://github.com/stfwi/duktape-cc/
    + Benefits 
      + Namespace 
      + RAII for duktape C-API
      + Javascript common known APIs such as console.log()
    + Disadvantage:
      + No possible to bind lambda function. 
      + No possible to bind C++ classes or objects
      + No CMakeLists.txt at top directory, which makes the library
        usage easier, but the following cmake scripts solves this
        problem.


File: CMakeLists.txt 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.0)
  project(duktape-cc-trial)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  include(duktape.cmake)

  #----- Main Target Definition ----------------------------#
         add_executable( duktape-script duktape-script.cpp)
  target_link_libraries( duktape-script duktape-cc )
#+END_SRC

File: duktape.cmake 

#+BEGIN_SRC cmake 
   include(FetchContent)

   # Note: the 'add_subriectory' line was commented becuyase 
   #       library that will be downloaded does not have 
   #       a CMakeListst.txt file at the root directory. 
   macro(Download_Library_Git  NAME TAG REPOSITORY_URL)
       FetchContent_Declare(
           ${NAME}
           GIT_REPOSITORY  ${REPOSITORY_URL}
           GIT_TAG         ${TAG}
       )
       FetchContent_GetProperties(${NAME})
       if(NOT cpputest_POPULATED)
           FetchContent_Populate(${NAME})
           message("${NAME}_SOURCE_DIR} = ${${NAME}_SOURCE_DIR}")        

           # => Disable following line: the library does not have a CMakeLists.txt
           #    at the root directory.
           # add_subdirectory(${${NAME}_SOURCE_DIR} ${${NAME}_BINARY_DIR})
       endif()
   endmacro()


   # ====>> Duktape JavaScript Engine Configuration <<===========#

   Download_Library_Git( duktape-cc 
                         51fed200b0c3353a60fa560aa8a13a480f0ec0c7
                         https://github.com/stfwi/duktape-cc/
                       )

   file(GLOB_RECURSE duktape_sources "${duktape-cc_SOURCE_DIR}/duktape/*.c")
   file(GLOB_RECURSE duktape_headers1 "${duktape-cc_SOURCE_DIR}/duktape/*.hh")
   file(GLOB_RECURSE duktape_headers2 "${duktape-cc_SOURCE_DIR}/duktape/*.h")

                  add_library( duktape-cc ${duktape_sources} ${duktape_headers1} ${duktape_headers2} )
   target_include_directories( duktape-cc PUBLIC ${duktape-cc_SOURCE_DIR} )

#+END_SRC

File: duktape-script.cpp 

#+BEGIN_SRC cpp 
   #include <iostream> 
   #include <string> 
   #include <vector> 
   #include <fstream>

   #include <duktape/duktape.hh>
   #include <duktape/mod/mod.stdio.hh>

   int main()
   {
       std::puts(" [TRACE] Program started Ok. ");

       // Create Duktape Engine object (Virtual Machine)
       auto ctx = duktape::engine{};

       // Load all functions from stdio module 
       // ==> Note: It is necessary for console.log() work 
       duktape::mod::stdio::define_in(ctx);   


       std::puts("\n [EXPERIMENT 1] ======= Evaluate string as code ========");

       ctx.eval<void>(R"( 
           console.log(" [INFO] Hello world Javascript Engine ");

           var i = 0;
           while(i < 5) {
               console.log(" [TRACE] <ducktape>  i = " + i);
               i++;
           }
       )");

       std::puts("\n [EXPERIMENT 2] == Read/write values to the engine the engine =");

       // Write or pass values to the engine. 
       ctx.define("app.version", "0.251");
       ctx.define("user.points", 1000);
       ctx.define("array1", std::vector<double>{ 4.51, 9.25, -25.154, 205.2 });
       ctx.define("array2", std::vector<std::string>{ "C++", "ADA-Spark", "Rust", "Dlang", "OCaml" });

       std::string script_file = "/tmp/myscript.js";

       const char* script_code = R"(
           console.log("  => app.version = " + app.version );
           console.log("  => user.points = " + user.points );
           console.log("  => array1 = " + array1);
           console.log("  => array2 = " + array2);

           myconfig_path = "/Users/data/osx/config";
           user_credits = 1020; 
           vector = [100.25, 90.251, -120.5150];
       )";

       // Write script code to file     
       auto fs = std::ofstream(script_file);
       // Flush forces writing to the IO
       fs << script_code << std::flush;          
       // Execute script from file 
       ctx.include(script_file);

       std::cout << " ---- Read configuration from file " << std::endl; 

       // Throws exception: duktape::detail::basic_script_error<void>
       auto myconfig_path = ctx.eval<std::string>("myconfig_path");
       auto credits       = ctx.eval<int>("user_credits");
       auto vec           = ctx.eval<std::vector<double>>("vector");
       std::cout << "\n\n[*] my_config_path = " << myconfig_path << "\n";
       std::cout << "[*]   user_credits = " << credits << "\n";
       std::cout << "[*] vec[0] = " << vec[0] << " ; vec[1] = " << vec[1] << "\n";    

       return 0;
   }
#+END_SRC

Build: 

#+BEGIN_SRC sh 
  $ cmake -H. -B_build -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build _build --target 
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
   $ _build/duktape-script 
   [TRACE] Program started Ok. 

   [EXPERIMENT 1] ======= Evaluate string as code ========

   [EXPERIMENT 2] == Read/write values to the engine the engine =
   [INFO] Hello world Javascript Engine 
   [TRACE] <ducktape>  i = 0
   [TRACE] <ducktape>  i = 1
   [TRACE] <ducktape>  i = 2
   [TRACE] <ducktape>  i = 3
   [TRACE] <ducktape>  i = 4
    => app.version = 0.251
    => user.points = 1000
    => array1 = 4.51,9.25,-25.154,205.2
    => array2 = C++,ADA-Spark,Rust,Dlang,OCaml
   ---- Read configuration from file 


  [*] my_config_path = /Users/data/osx/config
  [*]   user_credits = 1020
  [*] vec[0] = 100.25 ; vec[1] = 90.251

#+END_SRC
