<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-03-06 Wed 14:29 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CPP / C++ - Videos and Conferences</title>
<meta name="generator" content="Org mode" />
<meta name="description" content="cpp c++ code examples, demonstrations, design pattern and integration."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<link href="theme/org-nav-theme.css" rel="stylesheet">
<script src="theme/org-nav-theme.js"></script>
<link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CPP / C++ - Videos and Conferences</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org50d6638">1. Videos and Conferences</a>
<ul>
<li><a href="#org37abc84">1.1. Fundamentals</a>
<ul>
<li><a href="#org4a3fa19">1.1.1. Move Semantics in Deep - Engineering Distinguished Speaker Series: Howard Hinnant&#xa0;&#xa0;&#xa0;<span class="tag"><span class="bloomberg">bloomberg</span>&#xa0;<span class="performance">performance</span></span></a></li>
<li><a href="#orgfe82217">1.1.2. Series - Dive in C++14 (Game Oriented) - Vittorio Romeo</a></li>
<li><a href="#org36083e1">1.1.3. CppCon 2017: Bryce Adelstein Lelbach "C++17 Features (part 1 of 2)"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="nvidia">nvidia</span></span></a></li>
</ul>
</li>
<li><a href="#orgc9e6553">1.2. Misc</a>
<ul>
<li><a href="#orgf3cb750">1.2.1. Bjarne Stroustrup - The Essence of C++</a></li>
<li><a href="#org45459d6">1.2.2. CppCon 2017: Michael Spencer "My Little Object File: How Linkers Implement C++"</a></li>
<li><a href="#org24575bd">1.2.3. C++NOW 2018: Michael Caisse - Modern C++ in Embedded Systems</a></li>
</ul>
</li>
<li><a href="#orgf90171d">1.3. Generic Programming, Type Erasure and Polymorphism</a>
<ul>
<li><a href="#orgbe36f94">1.3.1. CppCon 2018 - Victor Ciura - Regular Type and Why Do I Care</a></li>
<li><a href="#org49210a3">1.3.2. NDC Conference 2017 - Sean Parent -  Better Code: Runtime Polymorphism</a></li>
<li><a href="#org6f09174">1.3.3. C++Now 2018: Louis Dionne "Runtime Polymorphism: Back to the Basics"</a></li>
<li><a href="#org421132c">1.3.4. ECOOP 2015 - Bjarne Stroustrup - Object Oriented Programming without Inheritance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="embedded">embedded</span></span></a></li>
<li><a href="#org7cbb67f">1.3.5. C++Now 2018: Odin Holmes C++ Mixins: Customization Through Compile Time Composition&#xa0;&#xa0;&#xa0;<span class="tag"><span class="embedded">embedded</span></span></a></li>
<li><a href="#org5108fa7">1.3.6. CppCon 2018: Mateusz Pusz "Effective replacement of dynamic polymorphism with std::variant"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="cpp17">cpp17</span>&#xa0;<span class="hpc">hpc</span>&#xa0;<span class="hft">hft</span>&#xa0;<span class="best">best</span></span></a></li>
</ul>
</li>
<li><a href="#org4cec61f">1.4. Functional</a>
<ul>
<li><a href="#org80f0b8d">1.4.1. CppCon 2015: Stephan T. Lavavej "functional: What's New, And Proper Usage"</a></li>
<li><a href="#org38641e4">1.4.2. CPPCON-2017: Klaus Iglberger - Free Your Functions</a></li>
<li><a href="#org5195594">1.4.3. C++Now 2018: Ben Deane "Easy to Use, Hard to Misuse: Declarative Style in C++"</a></li>
</ul>
</li>
<li><a href="#orgab72219">1.5. Tooling</a>
<ul>
<li><a href="#org905f01c">1.5.1. LVM Euro Conference 2013 - The Clang AST - a Tutorial</a></li>
<li><a href="#orgd687786">1.5.2. CppCon 2018: "Latest and Greatest in the Visual Studio Family for C++ Developers 2018"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tooling">tooling</span></span></a></li>
<li><a href="#orgecab5e6">1.5.3. Rapid Prototyping in C++ - Dmitri Nesteruk - Meeting C++ 2015</a></li>
<li><a href="#org89435b1">1.5.4. CppCon 2018: Steven Simpson "Source Instrumentation for Monitoring C++ in Production"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tooling">tooling</span>&#xa0;<span class="instrumentation">instrumentation</span></span></a></li>
</ul>
</li>
<li><a href="#orgf10360a">1.6. High Performance Computing and Math</a>
<ul>
<li><a href="#org6d53fb7">1.6.1. CPPCON 2016: Klaus Iglberger "The Blaze High Performance Math Library"</a></li>
<li><a href="#org0481770">1.6.2. Statistical scientific programming OO patterns: accumulators - Olivia Quinet - Lightning Talks&#xa0;&#xa0;&#xa0;<span class="tag"><span class="math">math</span>&#xa0;<span class="science">science</span></span></a></li>
<li><a href="#org8964467">1.6.3. Algorithms and Iterators for Multidimensional Arrays - Cem Bassoy - Lightning Talks Meeting C++ 2017&#xa0;&#xa0;&#xa0;<span class="tag"><span class="math">math</span>&#xa0;<span class="science">science</span></span></a></li>
<li><a href="#orgab6db36">1.6.4. Ranges and Iterators for numerical problems - Karsten Ahnert @ Meeting C++ 2014</a></li>
<li><a href="#org7bcca3e">1.6.5. Guy Davidson: Standardizing a Linear Algebra Library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="math">math</span></span></a></li>
</ul>
</li>
<li><a href="#org72b5188">1.7. Allocators</a>
<ul>
<li><a href="#orgf957d10">1.7.1. CppCon 2017: John Lakos Local ('Arena') Memory Allocators (part 1 of 2)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="bloomberg">bloomberg</span>&#xa0;<span class="performance">performance</span></span></a></li>
<li><a href="#orgc8b3a6e">1.7.2. Meeting C++ 20018: Andrea Weis - Taming dynamic memory - An Introduction to Custom Allocators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="BMW_AG">BMW_AG</span>&#xa0;<span class="real_time">real_time</span>&#xa0;<span class="embedded">embedded</span></span></a></li>
<li><a href="#orgb439f36">1.7.3. CppCon 2015: Andrei Alexandrescu "std::allocator&#x2026;"</a></li>
</ul>
</li>
<li><a href="#org1db88a6">1.8. C++ Binary Components + ABI + Reflection</a>
<ul>
<li><a href="#org7d4d301">1.8.1. CPPCON 2016 - C++14 Reflections Without Macros, Markup nor External Tooling&#xa0;&#xa0;&#xa0;<span class="tag"><span class="reflection">reflection</span>&#xa0;<span class="metaprogramming">metaprogramming</span>&#xa0;<span class="templates">templates</span></span></a></li>
<li><a href="#orgb78c2da">1.8.2. NDC Conference - Introduction to C++ Template Metaprogramming - Sasha Goldshtein&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tmp">tmp</span>&#xa0;<span class="templates">templates</span></span></a></li>
<li><a href="#org5a11c68">1.8.3. CppCon 2018: Victor Ciura "These Aren't the COM Objects You're Looking For"</a></li>
<li><a href="#org707e594">1.8.4. BoostCon: John Bandela - Easy Binary Compatible C++ Interfaces Across Compilers</a></li>
<li><a href="#orge2fd490">1.8.5. BoostCon: John Bandela - CppComponents- A Modern Portable C++11 Component System</a></li>
<li><a href="#org6da108a">1.8.6. CppCon 2017: Mathieu Ropert "API &amp; ABI Versioning"</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<ul class="org-ul">
<li><a href='index.html'>Index</a></li>
</ul>

<div id="outline-container-org50d6638" class="outline-2">
<h2 id="org50d6638"><span class="section-number-2">1</span> Videos and Conferences</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org37abc84" class="outline-3">
<h3 id="org37abc84"><span class="section-number-3">1.1</span> Fundamentals</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org4a3fa19" class="outline-4">
<h4 id="org4a3fa19"><span class="section-number-4">1.1.1</span> Move Semantics in Deep - Engineering Distinguished Speaker Series: Howard Hinnant&#xa0;&#xa0;&#xa0;<span class="tag"><span class="bloomberg">bloomberg</span>&#xa0;<span class="performance">performance</span></span></h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=vLinb2fgkHk&amp;feature=youtu.be">Engineering Distinguished Speaker Series: Howard Hinnant - YouTube</a>
<ul class="org-ul">
<li>"Howard Hinnant spoke at Bloomberg presenting everything you need
to know about move semantics."</li>
</ul></li>
</ul>

<p>
Notes: 
</p>

<p>
"Special member functions are those member functions that the compiler
can be asked to automatically generate code for."
</p>

<p>
In C++ 98, there were 4 <span class="underline">special member</span> functions that the compiler
can generate if not specified, namely: 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Member Function</th>
<th scope="col" class="org-left">Signature:</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Default constructor</td>
<td class="org-left">X()</td>
</tr>

<tr>
<td class="org-left">Copy constructor</td>
<td class="org-left">X(const X&amp;)</td>
</tr>

<tr>
<td class="org-left">Destructor</td>
<td class="org-left">~X()</td>
</tr>

<tr>
<td class="org-left">Copy assignment operator.</td>
<td class="org-left">X&amp; X::operator=(const X&amp;)</td>
</tr>
</tbody>
</table>

<p>
In C++11, there 6 are member functions that the compiler can generate:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Member Function</th>
<th scope="col" class="org-left">Signature:</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Default constructor</td>
<td class="org-left">X()</td>
</tr>

<tr>
<td class="org-left">Copy constructor</td>
<td class="org-left">X(const X&amp;)</td>
</tr>

<tr>
<td class="org-left">Destructor</td>
<td class="org-left">~X()</td>
</tr>

<tr>
<td class="org-left">Copy assignment operator.</td>
<td class="org-left">X&amp; X::operator=(const X&amp;)</td>
</tr>

<tr>
<td class="org-left">Move Constructor</td>
<td class="org-left">X(X&amp;&amp;)</td>
</tr>

<tr>
<td class="org-left">Move assignment operator</td>
<td class="org-left">X&amp; X::operator=(X&amp;&amp;)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
A special member function can be: 
</p>

<ul class="org-ul">
<li>not declared</li>

<li>implicitly declared (The compiler can be asked to generate the
function automatically)

<ul class="org-ul">
<li><span class="underline">delete</span> annotation C++11</li>

<li><span class="underline">default</span> annotation C++11</li>
</ul></li>
</ul>

<p>
C++ =&gt; Declaration X Definition (aka implementation)
</p>

<ul class="org-ul">
<li><span class="underline">Declaration</span>: only method signature, class signature &#x2026; without any
definition. Generally in *.hpp files (header files).</li>

<li><span class="underline">Definition</span>: a full definition =&gt; Function Signature + Body =&gt;
Generally in *.cpp files.</li>
</ul>

<p>
User-declared: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">X</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-comment-delimiter">/* </span><span class="org-comment">Default Constructor: User declared =&gt; The definition or implementation </span>
<span class="org-comment">   * is elsewhere, generally in *.cpp file. </span>
<span class="org-comment">   */</span>
  <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{}</span> 

  <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">()</span>;           <span class="org-comment-delimiter">// </span><span class="org-comment">User declared </span>
  <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">User declared</span>
  <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">delete</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">User declared, any attempt to use a deleted member</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">functions yields a compile-time error.</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Default constructor and overload resolution (1): 
</p>

<ul class="org-ul">
<li>If the template has zero arguments, the preferred constructor will
be the CTOR2 since according to C++ standard, the non-templated
function will be preferred in an overload resolution.
<ul class="org-ul">
<li>TL;DR =&gt; Function CTOR2 gets called.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">X</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">===&gt; CTOR1 (Variadic constructor)</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Universal reference </span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">(It can be either, L-value reference or R-value reference.)   </span>
   <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> 
    <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Args</span>&amp;&amp; ... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Implementation is elsewhere </span>

   <span class="org-comment-delimiter">// </span><span class="org-comment">====&gt; CTOR2 (If the template has zero args, this function gets called.)</span>
   <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Default constructor and overload resolution (2): 
</p>

<ul class="org-ul">
<li>deleted members pariticipate in overload resolution.</li>
<li>members not-declared DO NOT pariticipate in overload resolution.</li>
<li>Any attempt to call the default constructor X() (CTOR2) will
result in a compile-time error.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">X</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">===&gt; CTOR1 (Variadic constructor)</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Universal reference </span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">(It can be either, L-value reference or R-value reference.)   </span>
   <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> 
    <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Args</span>&amp;&amp; ... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Implementation is elsewhere </span>

   <span class="org-comment-delimiter">// </span><span class="org-comment">====&gt; CTOR2 (If the template has zero args, this function gets called.)</span>
   <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">delete</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Under what circunstances are special members implicitly provided by
the compiler. 
</p>

<ul class="org-ul">
<li>A user-declared destructor will inhibit the implicit declaration of
the move members.</li>

<li>(Row D) - The implicitly defaulted copy members are deprecated.</li>

<li>(Row D) RULE OF THREE: If any of destructor, copy-ctor or copy-assignment
is declared, all should be declared, even if not necessary,
specially in classes managing resources or heap-memory (free store).</li>

<li>(Row F) A user declared copy-constructor inhibit move members and the
copy-assignment operator is deprecated. It should defined and
declared explicitly. (RULE OF THREE)</li>

<li>(Row H) If only the move constructor is declared, the compiler sets
the copy constructor and copy assignment as deleted and the
constructor is not declared. The underlying class becomes a
<span class="underline">move-only class</span>.
<ul class="org-ul">
<li>Example: std::unique_ptr.</li>
</ul></li>
</ul>


<p>
<b>Compiler Implicitly Declares for C++11</b>
</p>

<ul class="org-ul">
<li>Note: The defaulted functions are only generated if they are
used. It means, invoked in some part of the code.</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">default</th>
<th scope="col" class="org-left">destructor</th>
<th scope="col" class="org-left">copy</th>
<th scope="col" class="org-left">copy</th>
<th scope="col" class="org-left">move</th>
<th scope="col" class="org-left">move</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">constructor</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">constructor</th>
<th scope="col" class="org-left">assignment</th>
<th scope="col" class="org-left">constructore</th>
<th scope="col" class="org-left">assignment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">Nothing</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-left">Any constructor</td>
<td class="org-left"><span class="underline">not declared</span></td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
</tr>

<tr>
<td class="org-left">C</td>
<td class="org-left">Default Constructor</td>
<td class="org-left"><b>user declared</b></td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
</tr>

<tr>
<td class="org-left">D</td>
<td class="org-left">Destructor</td>
<td class="org-left">defaulted</td>
<td class="org-left"><b>user declared</b></td>
<td class="org-left">*defaulted</td>
<td class="org-left">*defaulted</td>
<td class="org-left">not declared</td>
<td class="org-left">not declared</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">Copy constructor</td>
<td class="org-left"><span class="underline">not declared</span></td>
<td class="org-left">defaulted</td>
<td class="org-left"><b>user declared</b></td>
<td class="org-left">*defaulted</td>
<td class="org-left">not declared</td>
<td class="org-left">not declared</td>
</tr>

<tr>
<td class="org-left">G</td>
<td class="org-left">Copy assignment</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left"><b>user declared</b></td>
<td class="org-left">not declared</td>
<td class="org-left">not declared</td>
</tr>

<tr>
<td class="org-left">H</td>
<td class="org-left">Move constructor</td>
<td class="org-left">not declared</td>
<td class="org-left">defaulted</td>
<td class="org-left">deleted</td>
<td class="org-left">deleted</td>
<td class="org-left"><b>user declared</b></td>
<td class="org-left">not declared</td>
</tr>

<tr>
<td class="org-left">I</td>
<td class="org-left">Move assignment</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">deleted</td>
<td class="org-left">deleted</td>
<td class="org-left">not declared</td>
<td class="org-left"><b>user declared</b></td>
</tr>
</tbody>
</table>

<p>
<b>Compiler Implicitly Declares for C++98/03</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">default</th>
<th scope="col" class="org-left">destructor</th>
<th scope="col" class="org-left">copy</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">constructor</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">constructor</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">Nothing</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-left">Any constructor</td>
<td class="org-left"><span class="underline">not declared</span></td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
</tr>

<tr>
<td class="org-left">C</td>
<td class="org-left">Default Constructor</td>
<td class="org-left"><b>user declared</b></td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
</tr>

<tr>
<td class="org-left">D</td>
<td class="org-left">Destructor</td>
<td class="org-left">defaulted</td>
<td class="org-left"><b>user declared</b></td>
<td class="org-left">*defaulted</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">Copy constructor</td>
<td class="org-left"><span class="underline">not declared</span></td>
<td class="org-left">defaulted</td>
<td class="org-left"><b>user declared</b></td>
</tr>

<tr>
<td class="org-left">G</td>
<td class="org-left">Copy assignment</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
<td class="org-left">defaulted</td>
</tr>
</tbody>
</table>

<p>
The function std::move, just casts an L-value (X&amp;) to R-value
(generally temporary objects from which it is not possible to take an
address) (X&amp;&amp;). It has to use, to force the invocation of move
constructor or move assignment operator for transfering resource
ownership.
</p>

<p>
All STL containers have move constructors and move assignment
operator by default which makes efficient to return them by value from
functions. 
</p>

<p>
<b>Can I define one special member function in terms of another?</b>
</p>

<ul class="org-ul">
<li>YES. It turns out that it is possible.</li>
<li>However, the lecturer advises to NOT DO SO. Advice: "Give each
special member function the tender loving care it deserves."
Specially move semantics which can enhance performance
significantly.</li>
<li>The entire point of move semantics is to boost performance.</li>
</ul>


<p>
<b>Copy and Swap Idiom</b> 
</p>

<ul class="org-ul">
<li>Note: This trick is neat, however it has some performance cost. The
code can be optimized by writing both copy-assignment and
move-assignment individually.</li>
<li>Benefit: <span class="underline">Strong exception safety</span></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">X</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
 <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">m_v</span>;
 <span class="org-keyword">public</span>: 
 <span class="org-comment-delimiter">// </span><span class="org-comment">Implements both copy and move assignment operator. </span>
 <span class="org-type">X</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">X</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span>
    m_v.swap<span class="org-rainbow-delimiters-depth-3">(</span>x.m_v<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
 <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Rule of Zero</b> 
</p>

<ul class="org-ul">
<li>If the class only uses STL containers as member functions (not
pointers or unrwapped resources such as socket handlers), most of
the time, it is not necessary to define the special member
functions explicitly and the default generated member functions
already have optimal performance.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">X</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
 <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">m_v</span>;
 <span class="org-keyword">public</span>: 
 <span class="org-comment-delimiter">// </span><span class="org-comment">===&gt; Everything declared explicitly </span>
 <span class="org-comment-delimiter">// </span><span class="org-comment">as explicit is always better than implicit. </span>
 <span class="org-comment-delimiter">//</span><span class="org-comment">----------------------------------</span>

 <span class="org-comment-delimiter">/* </span><span class="org-comment">Default ctor */</span>
 <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>; 
 <span class="org-comment-delimiter">/* </span><span class="org-comment">Default dtor */</span>
~<span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>; 
 <span class="org-comment-delimiter">/* </span><span class="org-comment">Default copy-ctor */</span>
 <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">X</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">default</span>; 
 <span class="org-comment-delimiter">/* </span><span class="org-comment">Default move-ctor */</span>
 <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">X</span>&amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">default</span>;
 <span class="org-comment-delimiter">/* </span><span class="org-comment">Copy assignment operator */</span>
 <span class="org-type">X</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">X</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>  = <span class="org-keyword">default</span>;
 <span class="org-comment-delimiter">/* </span><span class="org-comment">Move assignment operator */</span>
 <span class="org-type">X</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">X</span>&amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">default</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Trick for strong exception sfaety on assignment</b>
</p>

<p>
Note: It is an alternative to copy-and-swap diim. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">C</span>&amp; <span class="org-function-name">strong_assign</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">C</span>&amp; <span class="org-variable-name">dest</span>, <span class="org-type">C</span> <span class="org-variable-name">src</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-constant">std</span>::swap<span class="org-rainbow-delimiters-depth-2">(</span>dest, src<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> dest;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Usage: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Instead of assignment </span>
x = y; 

<span class="org-comment-delimiter">// </span><span class="org-comment">Use - strong_assign where </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">strong exception safety is needed. </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Gets the best of both worlds.</span>
strong_assign<span class="org-rainbow-delimiters-depth-1">(</span>x, y<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>In a hurry?</b> 
</p>

<p>
If there is not time think carefully, the copy members should be
deleted. It disables all the special members, except the destructor
which is implicitly declared. Any attempt to use any of disabled
members functions results in a compile-time error. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">X</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
 <span class="org-keyword">public</span>:
    <span class="org-function-name">X</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">X</span>&amp; <span class="org-variable-name">X</span><span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
    <span class="org-type">X</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">X</span>&amp; <span class="org-variable-name">X</span><span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>What is the state of a moved-from object?</b> 
</p>

<ul class="org-ul">
<li>The state from a moved-from object is often unspecified. It is not
the same as undefined behavior, just the object's state is not
known.</li>
</ul>

<p>
<b>What is a precondition?</b> 
</p>

<ul class="org-ul">
<li>A requirement in the function specification which restricts the
state of the object prior to the call. For instance,
<ul class="org-ul">
<li>std::vector&lt;T&gt;::pop_back()</li>
<li>Requires the PRECONDITION: empty() shall be false before changing
the state of the vector.</li>
</ul></li>
</ul>

<p>
<b>Summary</b> 
</p>

<ul class="org-ul">
<li>Known when the compiler is defaulting or deleting special member
for you, and what defaulted memebrs will do.</li>
<li>Always define or delete special members whn the compiler's implicit
action is not corret.</li>
<li>Give tender lovign care to each of 6 special member functions, even
if the result is to let the compiler handle it.</li>
</ul>
</div>
</div>

<div id="outline-container-orgfe82217" class="outline-4">
<h4 id="orgfe82217"><span class="section-number-4">1.1.2</span> Series - Dive in C++14 (Game Oriented) - Vittorio Romeo</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
<b>Dive into C++11</b>
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=_4K3tsKa1Uc&amp;index=1&amp;list=PLTEcWGdSiQenl4YRPvSqW7UPC6SiGNN7e">Dive into C++11 - &lt;1&gt; - Arkanoid clone in 160~ lines of code (SFML 2.1)</a></li>

<li><a href="https://www.youtube.com/watch?v=tPbrWAbzyTE&amp;index=2&amp;list=PLTEcWGdSiQenl4YRPvSqW7UPC6SiGNN7e">Dive into C++11 - &lt;2&gt; - Frametime, FPS, constexpr, uniform initialization</a></li>

<li><a href="https://www.youtube.com/watch?v=0TGp0o1KnG8&amp;list=PLTEcWGdSiQenl4YRPvSqW7UPC6SiGNN7e&amp;index=3">Dive into C++11 - &lt;3&gt; - Automatic lifetime, pointers, dynamic allocation</a></li>

<li><a href="https://www.youtube.com/watch?v=zMdD-s5_BIY&amp;list=PLTEcWGdSiQenl4YRPvSqW7UPC6SiGNN7e&amp;index=4">Dive into C++11 - &lt;4&gt; - Smart pointers</a></li>

<li><a href="https://www.youtube.com/watch?v=QAmtgvwHInM&amp;index=6&amp;t=0s&amp;list=PLTEcWGdSiQenl4YRPvSqW7UPC6SiGNN7e">Dive into C++11 - &lt;5&gt; - Game entity management basics</a>
<ul class="org-ul">
<li>Entity component system.</li>
</ul></li>
</ul>

<p>
<b>Dive into C++14</b>
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=WZYKzCsACiw&amp;index=6&amp;list=PLTEcWGdSiQenl4YRPvSqW7UPC6SiGNN7e">Dive into C++14 - &lt;1&gt; - Introduction to C++14 core language features</a>
<ul class="org-ul">
<li>Note 1: Contexpr =&gt; Can have loops, for-loops and doesn't need to be
recursive as before. It is useful for computing look-up tables,
hash, CRC32 and checksums at compile-time.</li>

<li>Note 2: Return type deduction =&gt; Return type can be omitted.
However, it can be make the code harder to read.</li>

<li>Note 3: Variable templates. Allows computing numerical constats
at compile-time such as PI with some precision.</li>

<li>Note 4:
<ul class="org-ul">
<li>Lambda functions can have <span class="underline">auto</span> argument or argument type
deduction.</li>
<li>Lambda functions can have variadic parameter pack.</li>
</ul></li>
</ul></li>

<li><a href="https://www.youtube.com/watch?v=Za92Tz_g0zQ&amp;list=PLTEcWGdSiQenl4YRPvSqW7UPC6SiGNN7e&amp;index=7">Dive into C++14 - &lt;2&gt; - `for_each_argument` explained and expanded</a></li>

<li><a href="https://www.youtube.com/watch?v=Ehdl6j3Ace4&amp;index=8&amp;list=PLTEcWGdSiQenl4YRPvSqW7UPC6SiGNN7e">Dive into C++14 - &lt;3&gt; - Generic "unique resource" wrapper</a></li>
</ul>
</div>
</div>

<div id="outline-container-org36083e1" class="outline-4">
<h4 id="org36083e1"><span class="section-number-4">1.1.3</span> CppCon 2017: Bryce Adelstein Lelbach "C++17 Features (part 1 of 2)"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="nvidia">nvidia</span></span></h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=fI2xiUqqH3Q">CppCon 2017: Bryce Adelstein Lelbach “C++17 Features (part 1 of 2)” - YouTube</a>
<ul class="org-ul">
<li>The feature set for the C++17 release is set, and the release of
the standard is just around the corner. In this session, we'll
discuss all the new C++ features in C++17 and how they'll change
the way we write C++ software. We'll explore the new standard in
breath, not width, covering a cornucopia of core language and
library features and fixes:</li>
<li>Language Changes (part 1):
<ul class="org-ul">
<li>Structured bindings</li>
<li>Selection statements with initializers</li>
<li>Compile-time conditional statments</li>
<li>Fold expressions</li>
<li>Class template deduction</li>
<li>auto non-type template parameters</li>
<li>inline variables</li>
<li>constexpr lambdas</li>
<li>Unary static_assert</li>
<li>Guaranteed copy elision</li>
<li>Nested namespace definitions</li>
<li>Preprocessor predicate for header testing</li>
</ul></li>
<li>Library Changes (part 2):
<ul class="org-ul">
<li>string_view</li>
<li>optional</li>
<li>variant</li>
<li>any</li>
<li>Parallel algorithms</li>
<li>Filesystem support</li>
<li>Polymorphic allocators and memory resources</li>
<li>Aligned new</li>
<li>Improved insertion and splicing for associative containers</li>
<li>Math special functions</li>
<li>Variable templates for metafunctions</li>
<li>Boolean logic metafunctions</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc9e6553" class="outline-3">
<h3 id="orgc9e6553"><span class="section-number-3">1.2</span> Misc</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-orgf3cb750" class="outline-4">
<h4 id="orgf3cb750"><span class="section-number-4">1.2.1</span> Bjarne Stroustrup - The Essence of C++</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=86xWVb4XIyE">Bjarne Stroustrup - The Essence of C++</a>
<ul class="org-ul">
<li>"Bjarne Stroustrup, creator and developer of C++, delivers his
talk entitled, The Essence of C++. Stroustrup has held
distinguished posts at Texas A&amp;M University and spent significant
time in the Computer Science Departments of Cambridge, Columbia
and Princeton. C++ is the one of the world's most widely used
technology languages and it has influenced newer languages such
as C# and Java as well as older languages."
<ul class="org-ul">
<li>Applications on System Programming Domains:
<ul class="org-ul">
<li>Device drivers</li>
<li>Network drivers</li>
<li>Embedded Systems</li>
<li>Suitable for hard and soft real time systems.</li>
</ul></li>
<li>C++ Origin: C + Simula (First Object Oriented language)</li>
<li>Main Ideas:
<ul class="org-ul">
<li>Direct map to hardware</li>
<li>Zero-overhead abstraction</li>
<li>Much of inspiration comes from operating systems.</li>
<li>Backward compatibility: Avoid breaking old code.</li>
</ul></li>
<li>Key strengths:
<ul class="org-ul">
<li>A language for building lightweight abstractions.</li>
<li>Software infrastructure.</li>
<li>Resource-constrained application. (May be embedded systems)</li>
<li>Resource Management</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org45459d6" class="outline-4">
<h4 id="org45459d6"><span class="section-number-4">1.2.2</span> CppCon 2017: Michael Spencer "My Little Object File: How Linkers Implement C++"</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=a5L66zguFe4">CppCon 2017: Michael Spencer “My Little Object File: How Linkers Implement C++” - YouTube</a>
<ul class="org-ul">
<li>"Ever wonder how the linker turns your compiled C++ code into an
executable file? Why the One Definition Rule exists? Or why your
debug builds are so large? In this talk we'll take a deep dive
and follow the story of our three adventurers, ELF, MachO, and
COFF as they make their way out of Objectville carrying C++
translation units on their backs as they venture to become
executables. We'll see as they make their way through the tangled
forests of name mangling, climb the cliffs of thread local
storage, and wade through the bogs of debug info. We'll see how
they mostly follow the same path, but each approach the journey
in their own way.  We'll also see that becoming an executable is
not quite the end of their journey, as the dynamic linker awaits
to bring them to yet a higher plane of existence as complete C++
programs running on a machine."</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org24575bd" class="outline-4">
<h4 id="org24575bd"><span class="section-number-4">1.2.3</span> C++NOW 2018: Michael Caisse - Modern C++ in Embedded Systems</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=1l2g2dAobXA">Modern C++ in Embedded Systems - YouTube</a>
<ul class="org-ul">
<li>"For nearly 35 years I have been working with small processors
and there has always been deep divides between practitioners of
languages. When writing assembly we ridiculed those using C and
when I spent years microcoding we scoffed at everyone. However,
nearly all groups continue to wag their heads at the shameful C++
programmers attempting to twist their tools toward the
small. Recent language developments have made C++ the obvious
choice for many embedded projects; nevertheless, the toxic
environment extends past reddit roasts into poor vendor support
of tools and nearly obstructionist chip manufacturers. This
session will use a bare-metal project started in 2018 for a Ciere
client as a case study while we work through the decision process
for using C++, the acrobatics required to support the language,
recent language features that enable goals of size, speed, and
expressiveness, and useful libraries. While the examples will be
based on a concrete project, the extracted lessons-learned should
be applicable to many embedded projects (bare-metal and
small-OS). Attendees will walk away with motivations to use C++
in embedded projects, hints and tips to making tools work, and a
sampling of language features and idioms that improve the quality
of a final product."</li>
</ul></li>
</ul>


<p>
See: <a href="https://arobenko.gitbooks.io/bare_metal_cpp/content/">https://arobenko.gitbooks.io/bare_metal_cpp/content/</a>
</p>


<p>
What is shown:
</p>

<ul class="org-ul">
<li>Case presented: An ARM-based embedded processor is used for
controlling motors and a hydraulic machine.</li>

<li>Processor used: ARM Cortex RC4 connected to a FPGA (Filed
Programmable Gate Array).</li>

<li>Peripherals mentioned: I2C, SPI</li>

<li>Tooling:
<ul class="org-ul">
<li>GCC toolchain for ARM</li>
<li>CMAKE for build automation.</li>
<li>Linker script</li>
</ul></li>

<li>State Machine =&gt; Boost.SML (<a href="https://youtu.be/1l2g2dAobXA?t=4335">https://youtu.be/1l2g2dAobXA?t=4335</a>)
<ul class="org-ul">
<li>Typical state machines used: <span class="underline">Mealy's state</span> machine.</li>
<li><a href="https://github.com/boost-experimental/sml">https://github.com/boost-experimental/sml</a></li>
</ul></li>

<li>LADON - Real time object oriented modelling from 90's (prodecessor for
UML Real time extensions) =&gt; Distributed State Machines.
<ul class="org-ul">
<li>Allows to connect multiple state machines.</li>
</ul></li>

<li>Metaprogramming techniques used:
<ul class="org-ul">
<li>tag dispatching</li>
<li>CRTP =&gt; Curious Recurring Template Pattern for emulating
dynamic polymorphism (runtime poly.) with static polymorphism
at compile time.</li>
<li>Mixins</li>
<li>Variant Polymorphism</li>
<li>Type traits (metafunctions) =&gt; struct which takes list of types
as arguments peforming computations on types.</li>
<li>Type synonyms with 'using' keyword</li>
</ul></li>

<li>Common compiler options disabled on code for embedded systems:
<ul class="org-ul">
<li>Disable RTTI (-fno-rtti)</li>
<li>Disable exceptions (-fno-exceptions)</li>
</ul></li>

<li>How can C++ simplify the project?
<ul class="org-ul">
<li>More declarative.</li>
<li>More correctness and bugs caught at compile-time.</li>
<li>Template metaprogramming is crucial for developing lightweight
abstraction and reducing run-time overhead.</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgf90171d" class="outline-3">
<h3 id="orgf90171d"><span class="section-number-3">1.3</span> Generic Programming, Type Erasure and Polymorphism</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-orgbe36f94" class="outline-4">
<h4 id="orgbe36f94"><span class="section-number-4">1.3.1</span> CppCon 2018 - Victor Ciura - Regular Type and Why Do I Care</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=h60zqdzIelE">CppCon 2018: Victor Ciura "Regular Types and Why Do I Care ?"</a>
<ul class="org-ul">
<li>Description: "“Regular” is not exactly a new concept (pun
intended). If we reflect back on STL and its design principles,
as best described by Alexander Stepanov in his 1998 "Fundamentals
of Generic Programming” paper or his lecture on this topic, from
2002, we see that regular types naturally appear as necessary
foundational concepts in programming. Why do we need to bother
with such taxonomies ? Well, the STL now informally assumes such
properties about the types it deals with and imposes such
conceptual requirements for its data structures and algorithms to
work properly. The new Concepts Lite proposal (hopefully part of
C++20) is based on precisely defined foundational concepts such
as Semiregular, Regular, EqualityComparable,
DefaultConstructible, LessThanComparable (strict weak ordering),
etc. Formal specification of concepts is an ongoing effort in the
ISO C++ Committee and these STL library concepts requirements are
being refined as part of Ranges TS proposal (＜
experimental/ranges/concepts＞). Recent STL additions such as
string_view, tuple, reference_wrapper, as well as new incoming
types for C++20 like std::span raise new questions regarding
values types, reference types and non-owning “borrow”
types. Designing and implementing regular types is crucial in
everyday programing, not just library design. Properly
constraining types and function prototypes will result in
intuitive usage; conversely, breaking subtle contracts for
functions and algorithms will result in unexpected behavior for
the caller. This talk will explore the relation between Regular
types (and other concepts) and STL containers &amp; algorithms with
examples, common pitfalls and guidance."</li>
</ul></li>
</ul>

<p>
Coverage: 
</p>
<ul class="org-ul">
<li>Values</li>
<li>Objects (Not object-oriented programming)</li>
<li>Concepts</li>
<li>Ordering Relations</li>
<li>Requirements</li>
</ul>

<p>
Types:  (Tintus Winters - Modern C++ API Design)
</p>
<ul class="org-ul">
<li>Type Properties
<ul class="org-ul">
<li>What properties can we use to describe types?</li>
</ul></li>
<li>Type Families
<ul class="org-ul">
<li>What combinatons of type properties make useful / good type
design?</li>
</ul></li>
</ul>

<p>
<b>Books References and Papers</b>
</p>

<ul class="org-ul">
<li><b>Elements of Programming</b> - <span class="underline">Alexander Stepanov</span> and Paul Macjones.
<ol class="org-ol">
<li><b>Foundations</b></li>
<li>Transformations and their orbits</li>
<li>Associative operations</li>
<li><b>Linear ordering</b></li>
<li>Order Algebraic Structures</li>
<li>Iterators</li>
<li>Coordinate Structures</li>
<li>Coordinates with Mutable Successors</li>
<li>Copying</li>
<li>Rearrangements</li>
<li>Partitions and merging</li>
<li>Compose Objects</li>
</ol></li>

<li><b>FM2GP</b> <b>From Mathematics to Generic Programming</b> - <span class="underline">Alexander Stepanov</span>
and Daniel E. Rose 
<ul class="org-ul">
<li>Egyptian multiplication - 1900 - 1650 BC</li>
<li>Ancient Greek Numebr Theory</li>
<li>Prime Numbers</li>
<li>Euclid's GCD Algorithm</li>
<li>Abstractions in mathematics</li>
<li><span class="underline">Deriving Generic Algorithms</span></li>
<li>Algebraic Structures</li>
<li>Programming Concepts</li>
<li>Permutations Algorithms</li>
<li>Cryptology (RSA) - 1977 AD</li>
</ul></li>

<li><b>Fundamentals of Generic Programming</b> - James C. Dehert and Alexander
Stepanov 1998
<ul class="org-ul">
<li><a href="http://stepanovpapers.com/DeSt98.pdf">http://stepanovpapers.com/DeSt98.pdf</a></li>
<li>Quote: "Generic Programming depends on the <span class="underline">decomposition</span> of programs
into components which may be developed separately and combined
arbitrarly, subject only to well-defined <span class="underline">interfaces</span>".</li>
<li>Quote: "Among the interfaces of interest, the most pervasively
and unconsciously used, are the fundamental operators common to
al C++ <span class="underline">built-in types</span>, as extended to <span class="underline">user-defined types</span>, e.g
copy constructors, assignment, and equality."</li>
</ul></li>
</ul>

<p>
<b>Mathematic Really Does Matter!!!</b> 
</p>
<ul class="org-ul">
<li>Stepanov on GCD - One simple algorithm refined andimrpoved for
over 2,500 years while advancing human udnerstanding of
mathematics.</li>
<li><a href="http://www.youtube.com/watch?v=fanm5y00joc">http://www.youtube.com/watch?v=fanm5y00joc</a>
<ul class="org-ul">
<li>"This talk by Alexander Stepanov was presented and recorded at
SmartFriends U, September 27, 2003. Originally presented as the
1999 Arthur Schoffstall Lecture in Computer Science and Computer
Engineering at the Rensselaer Polytechnic Institute. Introduction
by Jon Kalb. Uploaded by permission of SmartFriends. Thanks to
Scott Boyd and everyone involved for their production work".</li>
</ul></li>
</ul>

<p>
<b>Terminology</b> 
</p>

<ul class="org-ul">
<li>Datum:
<ul class="org-ul">
<li>Finite sequence of zeros or ones, 0s or 1s.</li>
</ul></li>

<li>Value Type:
<ul class="org-ul">
<li>A value type is a correspondence between a species (abstract /
concrete) and a set of such datums.</li>
</ul></li>

<li>Value:
<ul class="org-ul">
<li>A datum alongside its <span class="underline">interpretation</span>: an  integer in 32-bit
2's two's complement, big endian (byte alignment).
<ul class="org-ul">
<li>min value: -(2^{32 - 1} - 1), max value: 2^{32 - 1};</li>
</ul></li>
<li>A <span class="underline">value cannot change</span></li>
</ul></li>

<li>Valye Type &amp; Equality

<ul class="org-ul">
<li>Lemma 1: If a value is uniquely represented, equality implies
representational equality. (Note: representational equality,
structural equality is the opposite of OOP's identity equality
where two objects are equal if they have the same memory adress,
same identity)</li>

<li>Lemma 2: If a value type is not ambiguous representational
equality implies equality.</li>
</ul></li>

<li>Object:
<ul class="org-ul">
<li>An object is a representation of concrete entity as a <span class="underline">value</span> in
computer <span class="underline">memory</span> (address &amp; length).</li>
<li>An object has a <span class="underline">state</span> that is a <b>value</b> of some value type.</li>
<li>The state of an object can change.</li>
</ul></li>

<li>Type:
<ul class="org-ul">
<li>A type is a set of values with smae interpretation functin and
operations on these values.</li>
</ul></li>

<li><b>Concept</b> (Generic Programming / Template Metaprogramming Concepts)
<ul class="org-ul">
<li>A concept is collection of similar types.</li>
</ul></li>
</ul>


<p>
<b>STL and Its Design Principles</b> (Stepnaov talk)
</p>

<ul class="org-ul">
<li>Parper PDF:
<ul class="org-ul">
<li><a href="http:/stepanovpapers.com/stl.pdf">http:/stepanovpapers.com/stl.pdf</a></li>
</ul></li>

<li>Talk at AdobeSystems:
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=COuHLky7E2Q">https://www.youtube.com/watch?v=COuHLky7E2Q</a></li>
</ul></li>

<li>Provides design guidance on extending the STL (Standard Template
Library).</li>

<li>Fundamental Principles:

<ul class="org-ul">
<li>Sistematically identifying and organizing useful algorithms and
data structures.</li>

<li>Finding the most general representation of algorithms.</li>

<li>Using <span class="underline">whole-part value semantics</span> for data structures.</li>

<li>Using <span class="underline">abstractions of addresses</span> (iterators) as the interface
between algorithms and data structures. (side-note: iterator -
generalization of pointers)</li>

<li>Algorithms are associated with a set of <span class="underline">common properties:</span>
<ul class="org-ul">
<li>Eg. { +, *, min, max} =&gt; <span class="underline">Associative</span> operations</li>
<li>=&gt; Reorder operands</li>
<li>=&gt; parallelize + reduction (std::accumulate)</li>
<li>Natrual extension of 4,000 years of mathematics</li>
<li>existing generic algorithms behind while() or for() loop.</li>
</ul></li>

<li>STL data structures (Note: Based on value semantics)
<ul class="org-ul">
<li>STL data structures extend the semantics of C structures</li>
<li>Two objects never intersec (they are separate entities)</li>
<li>thow objects have separate lifetims</li>
</ul></li>

<li>STL data structures have whole-part semantics
<ul class="org-ul">
<li>Copy of whole, copies the parts</li>
<li>whe the whole is destroyed, all parts are destroyed</li>
<li>two things are equal when they have the same number of parts
and their corresponding parts are equal.</li>
</ul></li>

<li>Generic Programming Drawbacks:
<ul class="org-ul">
<li>abstraction penalty</li>
<li>implementation in the interface</li>
<li>early binding</li>
<li>horrible error message (nor formal specification of
interfaces, yet) [CONCEPTS]</li>
<li>duck typing</li>
<li>algorithm could work on some data types, but fail to
work/compile on some ohter new data structures (different
iterator category, no copy semantics and so on.)</li>
<li><span class="underline">It is necessary to fully specify requirements on algorithm types</span>.</li>
<li>Additional: Hard to communicate the requirements for type arguments.</li>
</ul></li>

<li>Named Requirements - Examples From STL (Generic Programming
<a href="https://en.cppreference.com/w/cpp/language/constraints">concepts</a>) - <a href="http://en.cppreference.com/w/cpp/named_req">http://en.cppreference.com/w/cpp/named_req</a>
<ul class="org-ul">
<li>Constructor:
<ul class="org-ul">
<li>DefautConstructible, MoveConstructible, CopyConstructible</li>
</ul></li>
<li>Destructor:
<ul class="org-ul">
<li>Destructible</li>
</ul></li>
<li>Equality:
<ul class="org-ul">
<li>EqualityComparable, LessThanComparable</li>
</ul></li>
<li>Predicate:
<ul class="org-ul">
<li>Predicate, BinaryPredicate</li>
</ul></li>
<li>Function:
<ul class="org-ul">
<li>FunctionObject</li>
</ul></li>
<li>Container:
<ul class="org-ul">
<li>Container, SequenceContainer, ContiguousContainer,
Associative Container</li>
</ul></li>
<li>Iterator:
<ul class="org-ul">
<li>InputIterator, OutputIterator</li>
<li>ForwardIterator, BidirectionalIterator, RandomAccessIterator</li>
</ul></li>
</ul></li>

<li>What is the point of this?
<ul class="org-ul">
<li>Understand how the STL works and how it was designed.</li>
<li>Using STL algorithms and data structures in a better and safer
way.</li>
<li>Design and expose the API vocabulary types (interfaces, APIs -
Application Programming Interfaces)</li>
<li>Makes easier to read and understand the STL documentation.</li>
</ul></li>
</ul></li>
</ul>

<p>
Example: "GP - Concepts" and type expectations of STL Algorithm <b>std::sort</b> 
</p>

<ul class="org-ul">
<li>Compare Concept: Compare &lt;&lt; BinaryPredicate &lt;&lt; Predicate &lt;&lt; FunctionObject &lt;&lt; Callable</li>
<li>Why is this one special? About 50 STL facilities(algorithms and
data structures) expects some Compare type.</li>
</ul>

<p>
For instance: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">RandomIt</span>, <span class="org-keyword">class</span> <span class="org-type">Compare</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">constexpr</span> <span class="org-type">void</span> <span class="org-function-name">sort</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">RandomIt</span> <span class="org-variable-name">first</span>, <span class="org-type">RandomIt</span> <span class="org-variable-name">last</span>, <span class="org-type">Compare</span> <span class="org-variable-name">comp</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Compare Concept: Ordering relationship needed.
</p>
<ul class="org-ul">
<li></li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Ordering Relationship</th>
<th scope="col" class="org-left">Mathematical Description</th>
</tr>

<tr>
<th scope="col" class="org-left">Axiom</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Irrefexivity</td>
<td class="org-left">∀ a, comp(a, a) == false</td>
</tr>

<tr>
<td class="org-left">Antisymmetry</td>
<td class="org-left">∀ a, b if comp(a, b) == true =&gt; comp(b, a) = false</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Transitivity</td>
<td class="org-left">∀ a, b, c if comp(a, b) <code>==</code> true and comp(b, c) <code>==</code> true</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>=&gt;</code> comp(a, c) <code>==</code> true</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Transitivity of Equivalence</td>
<td class="org-left">∀ a, b if equiv(a, b): comp(a, b) <code>==</code> false AND comp(b, a) <code>==</code> false</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Note: 
</p>
<ul class="org-ul">
<li>The symbol (∀) universal quantifier means "for all" stuffs which
meets some mathematical requirement.</li>
<li>The symbol (=&gt;) arrow means "leas to".</li>
<li>See:
<ul class="org-ul">
<li>Partial ordering: <a href="https://en.wikipedia/wiki/Partially_ordered_set">https://en.wikipedia/wiki/Partially_ordered_set</a></li>
<li>Strict weak ordering:
<a href="https://en.wikipedia/wiki/Weak_ordering#Stric_weak_orderings">https://en.wikipedia/wiki/Weak_ordering#Stric_weak_orderings</a></li>
</ul></li>
</ul>

<p>
Code example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">algorithm</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 

<span class="org-keyword">struct</span> <span class="org-type">Point</span> <span class="org-rainbow-delimiters-depth-1">{</span> 
  <span class="org-type">int</span> <span class="org-variable-name">x</span>; <span class="org-type">int</span> <span class="org-variable-name">y</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-function-name">std</span>::ostream&amp; <span class="org-keyword">operator</span>&lt;&lt;<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-variable-name">Point</span> <span class="org-keyword">const</span>&amp; p<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">return</span> os &lt;&lt; <span class="org-string">"Point{"</span> &lt;&lt; <span class="org-string">" x = "</span> &lt;&lt; p.x &lt;&lt; <span class="org-string">" ; "</span> &lt;&lt; <span class="org-string">" y = "</span> &lt;&lt; p.y &lt;&lt; <span class="org-string">"}"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Element</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">std</span>::<span class="org-type">ostream</span>&amp; 
<span class="org-keyword">operator</span><span class="org-function-name">&lt;&lt;</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Element</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">vec</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    os &lt;&lt; <span class="org-string">"Vector["</span> &lt;&lt; vec.size<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"]{ "</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: vec<span class="org-rainbow-delimiters-depth-2">)</span> os &lt;&lt; x &lt;&lt; <span class="org-string">" ; "</span> ;
    os &lt;&lt; <span class="org-string">" }"</span>;
    <span class="org-keyword">return</span> os;
<span class="org-rainbow-delimiters-depth-1">}</span>   

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){</span>
   <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Point</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">points</span><span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-3">{</span>3, 4<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span>10, 6<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span>8, 9<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span>10, 5<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span>0, 0<span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">{</span>-10, -4<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span>;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; BEFORE: points = "</span> &lt;&lt; points &lt;&lt; <span class="org-constant">std</span>::endl;
   <span class="org-constant">std</span>::sort<span class="org-rainbow-delimiters-depth-2">(</span>points.begin<span class="org-rainbow-delimiters-depth-3">()</span>, points.end<span class="org-rainbow-delimiters-depth-3">()</span>, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-type">Point</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">p1</span>, <span class="org-type">Point</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">p2</span><span class="org-rainbow-delimiters-depth-3">)</span>
   <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>p1.x &lt; p2.x<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>;
      <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-4">(</span>p2.x &lt; p1.x<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>;
      <span class="org-keyword">return</span> p1.y &lt; p2.y;
   <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; AFTER: points = "</span> &lt;&lt; points &lt;&lt; <span class="org-constant">std</span>::endl;    
   <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output:
</p>

<div class="org-src-container">
<pre class="src src-cpp">=&gt; BEFORE: points = Vector<span class="org-rainbow-delimiters-depth-1">[</span>6<span class="org-rainbow-delimiters-depth-1">]{</span> Point<span class="org-rainbow-delimiters-depth-2">{</span> x = 3 ;  y = 4<span class="org-rainbow-delimiters-depth-2">}</span> ; Point<span class="org-rainbow-delimiters-depth-2">{</span> x = 10 ;  y = 6<span class="org-rainbow-delimiters-depth-2">}</span> ; Point<span class="org-rainbow-delimiters-depth-2">{</span> x = 8 ;  y = 9<span class="org-rainbow-delimiters-depth-2">}</span> ; Point<span class="org-rainbow-delimiters-depth-2">{</span> x = 10 ;  y = 5<span class="org-rainbow-delimiters-depth-2">}</span> ; Point<span class="org-rainbow-delimiters-depth-2">{</span> x = 0 ;  y = 0<span class="org-rainbow-delimiters-depth-2">}</span> ; Point<span class="org-rainbow-delimiters-depth-2">{</span> x = -10 ;  y = -4<span class="org-rainbow-delimiters-depth-2">}</span> ;  <span class="org-rainbow-delimiters-depth-1">}</span>
=&gt; AFTER: points = Vector<span class="org-rainbow-delimiters-depth-1">[</span>6<span class="org-rainbow-delimiters-depth-1">]{</span> Point<span class="org-rainbow-delimiters-depth-2">{</span> x = -10 ;  y = -4<span class="org-rainbow-delimiters-depth-2">}</span> ; Point<span class="org-rainbow-delimiters-depth-2">{</span> x = 0 ;  y = 0<span class="org-rainbow-delimiters-depth-2">}</span> ; Point<span class="org-rainbow-delimiters-depth-2">{</span> x = 3 ;  y = 4<span class="org-rainbow-delimiters-depth-2">}</span> ; Point<span class="org-rainbow-delimiters-depth-2">{</span> x = 8 ;  y = 9<span class="org-rainbow-delimiters-depth-2">}</span> ; Point<span class="org-rainbow-delimiters-depth-2">{</span> x = 10 ;  y = 5<span class="org-rainbow-delimiters-depth-2">}</span> ; Point<span class="org-rainbow-delimiters-depth-2">{</span> x = 10 ;  y = 6<span class="org-rainbow-delimiters-depth-2">}</span> ;  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Semiregular Concept</b>
</p>
<ul class="org-ul">
<li>A type which conforms to semiregular concept is:
<ul class="org-ul">
<li>DefaultConstructible</li>
<li>MoveConstructible</li>
<li>CopyConstructible</li>
<li>CopyAssignable</li>
<li>Swappable</li>
<li>Destructible</li>
</ul></li>
</ul>

<p>
<b>Regular Concept</b> (Stepanov's Regular)
</p>
<ul class="org-ul">
<li>Regular = SemiRegular + EqualityComparable</li>
<li>STL assumes <span class="underline">equality</span> is always defined (at leas, equivalence relation)</li>
<li>STL algorithms assumes REGULAR data structures.</li>

<li>Stepanov's concept of equality: "Two objects are equal if their
corresponding parts are equal (applied recursively), including
remote parts (but not comparing their addresses), excluding
inessential components, and excluding which identity related
object." &#x2013; <a href="http://stepanovpapers.com/DeSt98.pdf">http://stepanovpapers.com/DeSt98.pdf</a></li>
</ul>


<p>
Equality Comparable 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Axiom</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Reflexivity</td>
<td class="org-left">∀ a, (a <code>==</code> a) <code>==</code> true</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Symmetry</td>
<td class="org-left">∀ a, b, if (a <code>==~b) = true =&gt; (b ~==</code> a) <code>==</code> true</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Transitivity</td>
<td class="org-left">∀ a, b, c, if (a <code>==</code> b) <code>==</code> true and (b <code>==</code> c) <code>==</code> true</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>=&gt;</code> (a <code>==</code> c) <code>==</code> true</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>The type must work the operator== and the result shoudl have
stadnard semantics.</li>
<li>See:
<ul class="org-ul">
<li><a href="https://en.wikipedia.com/wiki/Equivalence_relation">https://en.wikipedia.com/wiki/Equivalence_relation</a></li>
<li><a href="https://en.cppreference.com/w/cpp/named_req/EqualityComparable">https://en.cppreference.com/w/cpp/named_req/EqualityComparable</a></li>
</ul></li>
</ul>


<p>
<b>C++20 - Three-way comparison</b> - spaceship operator 
</p>

<ul class="org-ul">
<li>Operator &lt;=&gt; - <a href="http://wg21.link/p0515">http://wg21.link/p0515</a></li>
</ul>

<div class="org-src-container">
<pre class="src src-text">(a &lt;=&gt; b) &lt;  0   if  a &lt; b 
(a &lt;=&gt; b) &gt;  0   if  a &gt; b
(a &lt;=&gt; b) == 0   if a and b are equal/equivalent
</pre>
</div>

<p>
<b>Monadic interface proposal</b>  (m-word)
</p>

<ul class="org-ul">
<li>map() / and_then() / or_else()</li>
<li><a href="https://wg21.tartanllama.xyz/monadic-optional">https://wg21.tartanllama.xyz/monadic-optional</a></li>
</ul>


<p>
<b>Borrowed Types like std::string_view</b> 
</p>

<ul class="org-ul">
<li>Borrow types are essentially "borrowed" references to existing objects.</li>
<li>They lack ownership</li>
<li>they are short-lived</li>
<li>they generally cand do without an assignment-operator</li>
<li>they generally apperar only in function parameter list</li>
<li>they gnerally cannot be stored in data structured or be returned
safely from function (no ownership semantics)</li>
<li><a href="https://quuxplusone.github.io/blog/2018/03/27/string-view-is-a-borrowed-type">https://quuxplusone.github.io/blog/2018/03/27/string-view-is-a-borrowed-type</a></li>
</ul>
</div>
</div>


<div id="outline-container-org49210a3" class="outline-4">
<h4 id="org49210a3"><span class="section-number-4">1.3.2</span> NDC Conference 2017 - Sean Parent -  Better Code: Runtime Polymorphism</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=QGcVXgEVMJg">Better Code: Runtime Polymorphism - Sean Parent - YouTube</a>

<ul class="org-ul">
<li>Description: "This talk explains why (and how) to implement
polymorphism without inheritance in C++. The talk contains many
C++ tips and techniques, including many new features from
C++11. During the course of that talk a key feature from
Photoshop will be demonstrated and implemented."</li>

<li>Notes: This talk is about how to preserve value semantics and
polymorphism without using inheritance in the client code. It is
done by using the <b>type erasure</b> design pattern. Actually, the
solution presented do use inheritance, but inside the <code>object_t</code>
class.</li>

<li>Benefits of the presented <b>type erasure</b> implementation:

<ul class="org-ul">
<li>Greater interoperability between software components as classes
doesn't need to inherit froms same base class, the only
requirement is to satisfy the constructor template constraints.</li>

<li>Alows value semantics to cohexist with polymorphism with
minimal performance penalty. It combines the benefits of
dynamic and static polymorphism.</li>

<li>A factory function can return a value rather than a pointer or
smart pointer and still preserve the value semantics.</li>

<li>Non-intrusive for client code. A client code doesn't need to be
aware of polymorphism. For instance, a client code <span class="underline">double describeArea(const Shape&amp; sh)</span> 
cannot be used directly with objects returned by a factory
function, for instance   std::unique_ptr&lt;Shape&gt;. By using 
type erasure, this code  doesn't need to modified as the
factory function can returns a value instead of a pointer and 
still preserve the polymorphism.
<ul class="org-ul">
<li>Less error prone</li>
<li>Client code doesn't need heap allocation. (Actually, the heap
allocation is hidden in the type erasure wrapper)</li>
<li>The client code doesn't need to worry about object ownership
or lifetime.</li>
<li>Exception safe</li>
<li>Thread safe</li>
</ul></li>

<li><span class="underline">Referenced Book</span>: Stepanov, Alexander and Paul McJones -
<b>Elements of Programming</b> - Addison Wesley - Professional 2009.</li>
</ul></li>

<li>Key Moments 

<ul class="org-ul">
<li><a href="https://youtu.be/QGcVXgEVMJg?t=2032">https://youtu.be/QGcVXgEVMJg?t=2032</a>
<ul class="org-ul">
<li>The class structure is composed by concept class (interface),
model classes inheriting the concept and the outter class
that hides the inheritance and wraps any argument which
statifies the template constraints.</li>
</ul></li>

<li><a href="https://youtu.be/QGcVXgEVMJg?t=2072">https://youtu.be/QGcVXgEVMJg?t=2072</a>
<ul class="org-ul">
<li>A virtual copy constructor is used in the concept class for
allowing the wrapper class (outer class) object_t to preserve
copy semantics by performing deep copying, instead of shallow
copying.</li>
</ul></li>

<li><a href="https://youtu.be/QGcVXgEVMJg?t=2136">https://youtu.be/QGcVXgEVMJg?t=2136</a> and <a href="https://youtu.be/QGcVXgEVMJg?t=2156">https://youtu.be/QGcVXgEVMJg?t=2156</a>
<ul class="org-ul">
<li>Templates used at constructor and the model.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org6f09174" class="outline-4">
<h4 id="org6f09174"><span class="section-number-4">1.3.3</span> C++Now 2018: Louis Dionne "Runtime Polymorphism: Back to the Basics"</h4>
<div class="outline-text-4" id="text-1-3-3">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=OtU51Ytfe04">C++Now 2018: Louis Dionne “Runtime Polymorphism: Back to the Basics” - YouTube</a>
<ul class="org-ul">
<li>Description: "C++ solves the problem of runtime polymorphism in a very
specific way. It does so through inheritance, by having all
classes that will be used polymorphically inherit from the same
base class, and then using a table of function pointers (the
virtual table) to perform dynamic dispatch when a method is
called. Polymorphic objects are then accessed through pointers to
their base class, which encourages storing objects on the heap
and accessing them via pointers. This is both inconvenient and
inefficient when compared to traditional value semantics. As Sean
Parent said: Inheritance is the base class of evil. It turns out
that this is only one of many possible designs, each of which has
different tradeoffs and characteristics. This talk will explore
the design space for runtime polymorphism in C++, and in
particular will introduce a policy-based approach to solving the
problem. We will see how this approach enables runtime
polymorphism with stack-allocated storage, heap-allocated
storage, shared storage, no storage at all (reference semantics),
and more. We will also see how we can get fine-grained control
over the dispatch mechanism to beat the performance of classic
virtual tables in some cases. The examples will be based on a
real implementation in the Dyno library [1], but the principles
are independent from the library."

<ul class="org-ul">
<li>Problem: C++ sub-typing polymorphism inevitably requires
pointers to objects allocated on the heap. However by using
pointers, the advantages of value semantics, which C++ is built
on top, are lost. For instance, pointers doesn't play well with
C++ algorithms and functions expecting value or reference
parameters. Another issue is that pointers to objects allocated
on the heap raises questions about memory ownership such as who
should delete the pointer.

<ul class="org-ul">
<li>Ideas =&gt; some possible approaches:
<ul class="org-ul">
<li>Use static polymorphism: <span class="underline">template functions.</span></li>
<li>Use a <span class="underline">proxy object allocated on the stack.</span> The object
inherits the base class and takes a pointer to base class
as argument. Then the proxy object can forward any method
call or message to the wrapped heap object.</li>
<li>Deal with it and accept as it is for performance reasons.</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org421132c" class="outline-4">
<h4 id="org421132c"><span class="section-number-4">1.3.4</span> ECOOP 2015 - Bjarne Stroustrup - Object Oriented Programming without Inheritance&#xa0;&#xa0;&#xa0;<span class="tag"><span class="embedded">embedded</span></span></h4>
<div class="outline-text-4" id="text-1-3-4">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=xcpSLRpOMJM">Bjarne Stroustrup - Object Oriented Programming without Inheritance - ECOOP 2015 - YouTube</a>
<ul class="org-ul">
<li>Explanative talk about generic programming (templates) paradigm
as an alternative to object oriented programming inheritance.</li>
<li>Selected Moments:
<ul class="org-ul">
<li><a href="https://youtu.be/xcpSLRpOMJM?t=619">Deep Roots in earliste C++</a></li>
<li><a href="https://youtu.be/xcpSLRpOMJM?t=794">Resources and resources management</a></li>
<li><a href="https://youtu.be/xcpSLRpOMJM?t=1044">Move Semantics</a></li>
<li><a href="https://youtu.be/xcpSLRpOMJM?t=1249">Generic Programming in C++</a></li>
<li><a href="https://youtu.be/xcpSLRpOMJM?t=1566">An Example of generic interface</a></li>
<li><a href="https://youtu.be/xcpSLRpOMJM?t=2088">C++ 'concepts'</a> (Generic programming.)</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org7cbb67f" class="outline-4">
<h4 id="org7cbb67f"><span class="section-number-4">1.3.5</span> C++Now 2018: Odin Holmes C++ Mixins: Customization Through Compile Time Composition&#xa0;&#xa0;&#xa0;<span class="tag"><span class="embedded">embedded</span></span></h4>
<div class="outline-text-4" id="text-1-3-5">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=wWZi_wPyVvs">C++Now 2018: Odin Holmes “C++ Mixins: Customization Through Compile Time Composition” - YouTube</a>
<ul class="org-ul">
<li>" Working in the embedded domain where 'special cases' are the
norm I often find myself fighting with customization capabilities
and 'canned' (non-customizable) abstractions. std::string often
has a small buffer for small string optimization, std::function
has something similar, why can't I set the size of that buffer,
or more radically why can't I just stick that same buffer in a
std::vector for a 'small vector optimization'. While we're at it
why can't I take .at() out of std::vectors public interface and
call some user-defined function on out of memory, maybe I turned
off exceptions but still want to handle errors properly. Maybe I
want a std::deque interface but have a fixed sized ring buffer
under the hood. Those following the SG14 will notice I am ticking
off proposals, the problem with these proposals is that the
mostly follow a common pattern: "I need X without Y" or "I need X
to have Y" and there are many many combinations of X and Y. Why
do I have to pay for atomic ref counting in a shared_pointer in a
single threaded use case? We could go on all day. In this talk we
will explore the feasibility of building classes from composable
pieces, some concrete proof of concepts as well as the library
infrastructure needed for this task."</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org5108fa7" class="outline-4">
<h4 id="org5108fa7"><span class="section-number-4">1.3.6</span> CppCon 2018: Mateusz Pusz "Effective replacement of dynamic polymorphism with std::variant"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="cpp17">cpp17</span>&#xa0;<span class="hpc">hpc</span>&#xa0;<span class="hft">hft</span>&#xa0;<span class="best">best</span></span></h4>
<div class="outline-text-4" id="text-1-3-6">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=gKbORJtnVu8">CppCon 2018: Mateusz Pusz “Effective replacement of dynamic polymorphism with std::variant” - YouTube</a>
<ul class="org-ul">
<li>This short talk presents how easy it is to replace some cases of
dynamic polymorphism with std::variant. During the lecture, we
will analyze and compare 2 implementations of the same simple
Finite State Machine. It turns up that variant-based code is not
only much faster but also it gives us the opportunity to define
our interfaces and program flow much better. The talk will end up
with the discussion of pros and cons of each approach and will
try to give guidelines on when to use them.</li>
<li><b>Domain:</b> Capital Markets - HFT - High Frequency Trading that
requires super fast low latency applications.</li>
</ul></li>
</ul>

<p>
<b>Latency</b>
</p>

<ul class="org-ul">
<li><span class="underline">Time required to perform some action</span> or to produce some result.</li>
<li>Measured in units of time like hours, minutes, seconds, nanoseconds
or clock periods.</li>
</ul>

<p>
<b>Low Latency</b> 
</p>

<ul class="org-ul">
<li>In capital markets (HFT - High Frequency Trading, makert-makers or
arbitrage operations), the use of algorithm trading to <span class="underline">react ot maker</span>
<span class="underline">events faster than the competion to increase profitability of trades</span></li>

<li>Many use case where <span class="underline">predictability of latency message delivery is</span>
<span class="underline">just as important</span>, if not more than <span class="underline">achieving low average latency</span>.</li>
</ul>


<p>
<b>How not to develop software that have predictable performance?</b> 
</p>

<ul class="org-ul">
<li>In Low Latency system we car a lot about <b>WCET</b> - [W]orst [C]ase  [E]xecution [T]ime.</li>

<li>In order to limit <b>WCET</b> we should <span class="underline">limit the usage of specific C++</span>
<span class="underline">language features.</span>
<ul class="org-ul">
<li>C++ tools that trade performance for usability (e.g
std::shared_ptr, std::function)</li>
<li>Throwing exception on likely code path.</li>
<li><b>Dynamic Polymorphism</b> (focus)</li>
<li>Inheritance</li>
<li>RTTI - Runtime Type Information</li>
<li><b>Dynamic Memory Allocation</b> (focus)</li>
</ul></li>
</ul>

<p>
<b>How?</b> 
</p>

<p>
Typical case of dynamic polymorphism:
</p>

<ul class="org-ul">
<li>Class hierachy:</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">base</span>: <span class="org-type">noncopiable</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">base</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-2">()</span> = 0;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">x</span>: <span class="org-keyword">public</span> <span class="org-type">base</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
  <span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">y</span>: <span class="org-keyword">public</span> <span class="org-type">base</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
 <span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">override</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Dynamic polymorphism:
<ul class="org-ul">
<li>My observation ==&gt; Ability of the client code to use derived
classes as it was the base class without any knowledge of the
derived class being used. The client code can also use any
instance of a derived class as it was an instance of the base
class.</li>
<li>My observation ==&gt; Problem: The dynamic polymorphism incurs on a
run-time overhead since virtual methods are resolved at runtime
rather than at compile-time which cannot be acceptable in some
domains such as real time systems or low latency systems.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>base<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">b</span> = <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-1">&lt;</span>x<span class="org-rainbow-delimiters-depth-1">&gt;()</span>;
 b-&gt;foo<span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-type">void</span> <span class="org-function-name">ClientCode</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Base</span>&amp; <span class="org-variable-name">object</span><span class="org-rainbow-delimiters-depth-1">){</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">use object without nknowing its type </span>
  object-&gt;foo<span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">The client code can work with any implementation without </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">knowing anything about it. </span>
ClientCode<span class="org-rainbow-delimiters-depth-1">(</span>*b<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Alternative Presented: std::variant (from C++17 or Boost.Variant)</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-keyword">struct</span> <span class="org-type">x</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
 <span class="org-comment-delimiter">// </span><span class="org-comment">Or: --------------- </span>
 <span class="org-keyword">class</span> <span class="org-type">x</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">public</span>: 
    <span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-2">()</span>; 
 <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-keyword">struct</span> <span class="org-type">y</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-type">void</span> foo<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-rainbow-delimiters-depth-1">}</span>;

 <span class="org-comment-delimiter">// </span><span class="org-comment">Or =&gt; A struct is class with everything public by default.</span>
 <span class="org-keyword">class</span> <span class="org-type">y</span> <span class="org-rainbow-delimiters-depth-1">{</span> 
  <span class="org-keyword">public</span>:
    <span class="org-type">void</span> <span class="org-function-name">foo</span><span class="org-rainbow-delimiters-depth-2">()</span>; 
 <span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">std</span>::<span class="org-type">variant</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">x</span>, <span class="org-type">y</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> b;
<span class="org-function-name">std</span>::visit<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-keyword">auto</span>&amp;&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>  v.foo<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>, b<span class="org-rainbow-delimiters-depth-1">)</span>;

</pre>
</div>

<p>
Benefits: 
</p>
<ul class="org-ul">
<li>shorter</li>
<li>faster</li>
<li>value semantics</li>
<li>works on unrelated classes</li>
<li>more flexible thanks to duck typing (template metaprogramming +
type erasure =&gt; It still uses inheritance internally.)</li>
</ul>

<p>
<b>Finite State Machine</b> 
</p>

<ul class="org-ul">
<li>Abstract machine that can be in exactly one of a finite number of
states at any given time. &#x2013; Wikipedia.
<ul class="org-ul">
<li>My observation =&gt; Applications: parsers, electronic circuits,
network protocols, embedded systems, industrial automation and
game artificial intelligency,</li>
</ul></li>

<li>State changes to another in a respose to some external inputs
called events. (Mealy's state machine model.)</li>

<li>The change from one state another is called transition.</li>
</ul>

<div class="org-src-container">
<pre class="src src-text">                               +
                               | Initial state
                               |
                               |
                               |
                        +------v----------+
 +----------------------+   state_idle    |
 |                      |                 &lt;-----------------+
 |                      +-------+------+--+                 |
 |timeout                       |      ^                    |
 |[ n &lt; n_max]    connect       |      |                    |
 |                  +-----------+      |timeout             |
 |                  |                  |[ n = n_max ]       | disconnected
 |                  |                  |                    |
 |         +--------v-------------+    |                    |
 |         |                      +----+                    |
++---------&gt; state_connecting     |                         |
           |                      |                         |
           +--------------+-------+                         |
                          |                                 |
                          |                      +----------+------------+
                          |   connected          |                       |
                          +----------------------&gt;    state_connected    |
                                                 |                       |
                                                 +-----------------------+
</pre>
</div>

<p>
<b>Implementation with single dynamic dispatch</b> 
</p>

<ul class="org-ul">
<li>Problem: Slow due to the usage of virtual meber functions.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Event</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">state</span>: <span class="org-type">noncopyable</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">state</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
        <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">on_event</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Event</span><span class="org-rainbow-delimiters-depth-2">)</span> = 0;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Event</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">fsm</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Event</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">state_</span>;
<span class="org-function-name">public</span>:
        <span class="org-keyword">explicit</span> <span class="org-function-name">fsm</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::unique_ptr&lt;<span class="org-type">state</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Event</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> state<span class="org-rainbow-delimiters-depth-2">)</span>
                : state_<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>state<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-type">void</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Event</span> <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">new_state</span> = state_-&gt;on_event<span class="org-rainbow-delimiters-depth-3">(</span>e<span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>new_state<span class="org-rainbow-delimiters-depth-3">)</span>
                        state_ = <span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>new_state<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Connection FSM</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">connection_fsm</span>: <span class="org-keyword">public</span> <span class="org-type">fsm</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>event<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-function-name">connection_fsm</span><span class="org-rainbow-delimiters-depth-2">()</span>:
                fsm<span class="org-rainbow-delimiters-depth-2">&lt;</span>event<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>state_idle<span class="org-rainbow-delimiters-depth-3">&gt;()</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">using</span> <span class="org-type">s</span> = <span class="org-type">state</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>fent<span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-keyword">class</span> <span class="org-type">state_idle</span> <span class="org-keyword">final</span> : <span class="org-keyword">public</span> <span class="org-type">s</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">s</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">on_event</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">event</span> <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">state_connecting</span> <span class="org-keyword">final</span> : <span class="org-keyword">public</span> <span class="org-type">s</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">static</span> <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">n_max</span> = 3;
        <span class="org-type">int</span> <span class="org-variable-name">n</span> = 0;
<span class="org-function-name">public</span>:
        <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">s</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">on_event</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">event</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">state_connected</span> <span class="org-keyword">final</span> : <span class="org-keyword">public</span> <span class="org-type">s</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">s</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">on_event</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">event</span> <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Member function implementations: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>s<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-constant">state_idle</span>::on_event<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">event</span> <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>e == <span class="org-constant">event</span>::connect<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>state_connecting<span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
        <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>s<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-constant">state_connecting</span>::one_vent<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">event</span> <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">switch</span><span class="org-rainbow-delimiters-depth-2">(</span>e<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-keyword">case</span> <span class="org-constant">event</span>::connected:
                <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>state_connected<span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
        <span class="org-keyword">case</span> <span class="org-constant">event</span>::timeout:
                <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">(</span>++n &lt; n_max<span class="org-rainbow-delimiters-depth-3">)</span> ? <span class="org-constant">nullptr</span> : <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>state_idle<span class="org-rainbow-delimiters-depth-3">&gt;()</span>;
        <span class="org-keyword">default</span>:
                <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>s<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-constant">state_connected</span>::one_vent<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">event</span> <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>e == <span class="org-constant">event</span>::disconnect<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>state_idle<span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
        <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The transitions can be tested with C++17 fold expressions which allows
template types parameter packs to be expanded without recursion. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Fsm</span>, <span class="org-keyword">typename</span> ... <span class="org-type">Events</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Fsm</span>&amp; <span class="org-variable-name">fsm</span>, <span class="org-type">Events</span>... <span class="org-variable-name">events</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-rainbow-delimiters-depth-2">(</span>fsm.dispatch<span class="org-rainbow-delimiters-depth-3">(</span>events<span class="org-rainbow-delimiters-depth-3">)</span>, ... <span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Simple message flow: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">connection_fsm</span> <span class="org-variable-name">fsm</span>; 
dispatch<span class="org-rainbow-delimiters-depth-1">(</span>fsm , <span class="org-constant">event</span>::conect, <span class="org-constant">event</span>::timeout, <span class="org-constant">event</span>::connected, <span class="org-constant">event</span>::disconnect<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Problems:
</p>
<ul class="org-ul">
<li>Open to new alternatives:
<ul class="org-ul">
<li>new derived types may be added by client codes at any point of
time (long after base class implementation is finished)</li>
</ul></li>
<li>Closed to new operations:
<ul class="org-ul">
<li>clients cannot add new operations to dynamic dispatch</li>
</ul></li>
<li>Multi-level
<ul class="org-ul">
<li>many levels of inheritance possible</li>
</ul></li>
</ul>


<p>
<b>Double dispatch</b> - aka visitor pattern 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">State</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">event</span> : <span class="org-keyword">private</span> <span class="org-type">noncopyable</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">event</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
        <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">State</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">State</span>&amp; <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> = 0;    
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">State</span>, <span class="org-keyword">typename</span> <span class="org-type">Event</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">fms</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">State</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">state_</span>;
<span class="org-function-name">public</span>:
        <span class="org-keyword">explicit</span> <span class="org-function-name">fsm</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">State</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">state</span><span class="org-rainbow-delimiters-depth-2">)</span>: state_<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>state<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{}</span>

        <span class="org-type">void</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">Event</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">new_state</span> = e.dispatch<span class="org-rainbow-delimiters-depth-3">(</span>*state_<span class="org-rainbow-delimiters-depth-3">)</span>;
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>new_state<span class="org-rainbow-delimiters-depth-3">)</span>
                        state_ = <span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>new_state<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Events: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">event_connect</span> <span class="org-keyword">final</span> : <span class="org-keyword">public</span> <span class="org-type">event</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>state<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::<span class="org-type">unque_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>state<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">state</span>&amp; <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> s.on_event<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">... </span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">event_connected</span> <span class="org-keyword">final</span> : <span class="org-keyword">public</span> <span class="org-type">event</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::<span class="org-type">unque_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">state</span>&amp; <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> s.on_event<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">... </span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">event_disconnect</span> <span class="org-keyword">final</span> : <span class="org-keyword">public</span> <span class="org-type">event</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::<span class="org-type">unque_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">state</span>&amp; <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> s.on_event<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">... </span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">event_timeout</span> <span class="org-keyword">final</span> : <span class="org-keyword">public</span> <span class="org-type">event</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::<span class="org-type">unque_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">state</span>&amp; <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> s.on_event<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">... </span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

</pre>
</div>

<p>
State: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: It is private inheritance</span>
<span class="org-keyword">class</span> <span class="org-type">state</span> : <span class="org-type">noncopyable</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">state</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
        <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">onv_vent</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">event_connect</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">onv_vent</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">event_connected</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>   <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">onv_vent</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">event_disconnect</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">onv_vent</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">event_timeout</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>     <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">class</span> <span class="org-type">state_idle</span> <span class="org-keyword">final</span> : <span class="org-keyword">public</span> <span class="org-type">state</span> <span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
        <span class="org-keyword">using</span> <span class="org-constant">state</span>::<span class="org-type">on_event</span>;
        <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">state</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">on_event</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">event_connect</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">override</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-3">&lt;</span>state_connecting<span class="org-rainbow-delimiters-depth-3">&gt;(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-4">(</span>e.address<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Simplification with CRTP - Curiously Recurring Template Pattern</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">State</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">event</span> : <span class="org-keyword">private</span> <span class="org-type">noncopyable</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">virtual</span> ~<span class="org-function-name">event</span><span class="org-rainbow-delimiters-depth-2">()</span> = <span class="org-keyword">default</span>;
        <span class="org-keyword">virtual</span> <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">State</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">State</span>&amp; <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> = 0;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Child</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">event_crtp</span> : <span class="org-type">event</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>state<span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>state<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">state</span>&amp; <span class="org-variable-name">s</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-keyword">override</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> s.on_event<span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-keyword">static_cast</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-keyword">const</span> <span class="org-type">Child</span>*<span class="org-rainbow-delimiters-depth-4">&gt;(</span><span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">event_connect</span> <span class="org-keyword">final</span>: <span class="org-keyword">public</span> <span class="org-type">event_cretp</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">event_connect</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">explicit</span> <span class="org-constant">event_connect9std</span>::<span class="org-type">string_view</span> <span class="org-function-name">address</span>: address_<span class="org-rainbow-delimiters-depth-2">(</span>address<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-function-name">address</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> address_; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-function-name">private</span>:
        <span class="org-constant">std</span>::<span class="org-type">string_view</span> <span class="org-variable-name">address_</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">struct</span> <span class="org-type">event_conencted</span>    <span class="org-keyword">final</span>: <span class="org-type">publidc</span> <span class="org-type">event_crtp</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>event_connected<span class="org-rainbow-delimiters-depth-1">&gt;</span>    <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">struct</span> <span class="org-type">event_disconnected</span> <span class="org-keyword">final</span>: <span class="org-type">publidc</span> <span class="org-type">event_crtp</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">event_disconnected</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">struct</span> <span class="org-type">event_timeout</span>      <span class="org-keyword">final</span>: <span class="org-type">publidc</span> <span class="org-type">event_crtp</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">event_timeout</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>      <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Transitions: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>state<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">state_idle</span>::on_event<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">event_connect</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>state_connecting<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-3">{</span>e.address<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>state<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">state_connecting</span>::on_event<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">event_connect</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>state_conected<span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>state<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">state_connecting</span>::on_event<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">event_timeout</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> ++n &lt; n_make ?  <span class="org-constant">nullptr</span> : <span class="org-constant">std</span>::<span class="org-type">make_unique</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>state_idle<span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::<span class="org-type">unique_ptr</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>state<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-function-name">state_connected</span>::on_event<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">event_timeout</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>state_idle<span class="org-rainbow-delimiters-depth-2">&gt;()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Testing transitions: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Fsm</span>, <span class="org-keyword">typename</span>..Events<span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Fsm</span>&amp; <span class="org-variable-name">fsm</span>, <span class="org-type">Events</span> <span class="org-keyword">const</span>&amp; ... <span class="org-variable-name">events</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-rainbow-delimiters-depth-2">(</span>fsm.dispatch<span class="org-rainbow-delimiters-depth-3">(</span>&amp;events<span class="org-rainbow-delimiters-depth-3">)</span>, ...<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-1">(</span>fms,
         <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>event_connect<span class="org-rainbow-delimiters-depth-2">&gt;(</span><span class="org-string">"taint-it.eu"</span><span class="org-rainbow-delimiters-depth-2">)</span>,
         <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>event_timeout<span class="org-rainbow-delimiters-depth-2">&gt;()</span>,
         <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>event_connected<span class="org-rainbow-delimiters-depth-2">&gt;()</span>,
         <span class="org-constant">std</span>::make_unique<span class="org-rainbow-delimiters-depth-2">&lt;</span>event_disconnect<span class="org-rainbow-delimiters-depth-2">&gt;()</span><span class="org-rainbow-delimiters-depth-1">)</span>:
</pre>
</div>

<p>
Summary:
</p>
<ul class="org-ul">
<li>Closed to new alternatives
<ul class="org-ul">
<li>one class of fixed at design time and cannot be extended by
clients</li>
</ul></li>
<li>closed to new operations
<ul class="org-ul">
<li>clients cannot add new operations to dynamic dispatch</li>
</ul></li>
<li>Multi-level
<ul class="org-ul">
<li>many levels of inheritance possible</li>
</ul></li>
<li>Object Oriented
<ul class="org-ul">
<li>whole framework is based on objects</li>
</ul></li>
</ul>

<p>
<b>std::variant&lt;Types &#x2026;&gt;</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> ... <span class="org-type">types</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">variant</span>;
</pre>
</div>

<ul class="org-ul">
<li>Represents a type-safe union</li>
<li>At any given point in time eith
<ul class="org-ul">
<li>Holds a value of one of its alternative types</li>
<li>Is in special <b>valueless_by_exception_state</b>  (reached if  an
exception is thrown during contained value initialization or
assingment).</li>
</ul></li>
</ul>

<p>
C++ Standard requirements of the type std:;variant&lt;Types &#x2026;&gt;
</p>
<ul class="org-ul">
<li>Not allowed to allocate dynamic memory.</li>
<li>Not permitted ot hold references, arrays, or void.</li>
<li>Empty variants are <b>ill-formed</b> (std::variant&lt;std::monostate&gt; can be
used instaed)</li>
<li>Permitted to <span class="underline">hold the same type more than once</span>, and to hold
different cv-qualified versions of the same type.</li>
<li><span class="underline">Default-initialized variant</span> holds a value of its first alternatives
unless that alternative is not default-constructible.</li>
</ul>

<p>
Dyamic Dispatch using the index member function: (slower and less performant)
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span>std:;<span class="org-type">variant</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, X<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">switch</span><span class="org-rainbow-delimiters-depth-2">(</span>v.index<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">case</span> 0: <span class="org-constant">std</span>:;cout &lt;&lt; <span class="org-string">"   int: "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-3">&lt;</span>0<span class="org-rainbow-delimiters-depth-3">&gt;(</span>v<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-string">'\n'</span>; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 1: <span class="org-constant">std</span>:;cout &lt;&lt; <span class="org-string">"double: "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-3">&lt;</span>1<span class="org-rainbow-delimiters-depth-3">&gt;(</span>v<span class="org-rainbow-delimiters-depth-3">)</span> &lt;&lt; <span class="org-string">'\n'</span>; <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 2: <span class="org-constant">std</span>:;cout &lt;&lt; <span class="org-string">"     X: "</span> &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-3">&lt;</span>2<span class="org-rainbow-delimiters-depth-3">&gt;(</span>v<span class="org-rainbow-delimiters-depth-3">)</span>.x &lt;&lt; <span class="org-constant">std</span>::get<span class="org-rainbow-delimiters-depth-3">&lt;</span>2<span class="org-rainbow-delimiters-depth-3">&gt;(</span>v<span class="org-rainbow-delimiters-depth-3">)</span>.y &lt;&lt; <span class="org-string">'\n'</span>; <span class="org-keyword">break</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Static dispatching with visitor struct: (faster and more performant,
similar to functional-languages pattern matching.)
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">visitor</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span>     <span class="org-keyword">const</span>  <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"   int: "</span> &lt;&lt; v &lt;&lt; <span class="org-string">'\n'</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span>   <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"double: "</span> &lt;&lt; v &lt;&lt; <span class="org-string">'\n'</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">X</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"     X: "</span> &lt;&lt; v.x &lt;&lt; v.y &lt;&lt; <span class="org-string">'\n'</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">void</span> <span class="org-function-name">print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">variant</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span>, <span class="org-type">X</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-constant">std</span>::visit<span class="org-rainbow-delimiters-depth-2">(</span>visitor<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-rainbow-delimiters-depth-4">{}</span>, x<span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>; <span class="org-rainbow-delimiters-depth-1">}</span>  
</pre>
</div>

<p>
Transitions: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">struct</span> <span class="org-type">transitions</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-constant">std</span>::<span class="org-type">optional</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>state<span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">state_idle</span>&amp;, <span class="org-type">event_connect</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> state_connecting<span class="org-rainbow-delimiters-depth-3">{</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-4">(</span>e.address;<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">}</span>:
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-constant">std</span>::<span class="org-type">optiona</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>state<span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">state_connecting</span>&amp;, <span class="org-type">event_connected</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> state_connected<span class="org-rainbow-delimiters-depth-3">{}</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-constant">std</span>::<span class="org-type">optiona</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>state<span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">state_connecting</span>&amp;, <span class="org-type">event_timeout</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> ++s.n &lt; <span class="org-constant">state_connecting</span>::n_max ?
                                           <span class="org-constant">std</span>::nullopt : <span class="org-type">optional</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>state<span class="org-rainbow-delimiters-depth-3">&gt;(</span>state_idle<span class="org-rainbow-delimiters-depth-4">{}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Default case </span>
        <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">State</span>, <span class="org-keyword">typename</span> <span class="org-type">Event</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-constant">std</span>::<span class="org-type">optional</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>state<span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">State</span>&amp;, <span class="org-type">Event</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> <span class="org-constant">std</span>::nullopt;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
FSM Engine: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">StateVariant</span>, <span class="org-keyword">typename</span> <span class="org-type">EventVariant</span>, <span class="org-keyword">typename</span> <span class="org-type">Transitions</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">fsm</span><span class="org-rainbow-delimiters-depth-1">{</span>
     <span class="org-type">StateVariant</span> <span class="org-variable-name">state_</span>;
<span class="org-function-name">public</span>:
     <span class="org-type">void</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">EventVariant</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">event</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-type">optional</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">StateVariant</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">new_state</span> = <span class="org-constant">std</span>::visit<span class="org-rainbow-delimiters-depth-3">(</span>Transitions<span class="org-rainbow-delimiters-depth-4">{}</span>, state_, event<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>new_state<span class="org-rainbow-delimiters-depth-3">)</span>
           state_ = *<span class="org-constant">std</span>::move<span class="org-rainbow-delimiters-depth-3">(</span>new_state<span class="org-rainbow-delimiters-depth-3">)</span>;      
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">using</span> <span class="org-type">connection_fsm</span> = <span class="org-type">fsm</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>state, event, transitions<span class="org-rainbow-delimiters-depth-1">&gt;</span>;
</pre>
</div>

<p>
Testing transitions: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Fsm</span>, <span class="org-keyword">typename</span> ...<span class="org-type">Event</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">dispatch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Fms</span>&amp; <span class="org-variable-name">fms</span>, <span class="org-type">Events</span>&amp;&amp; ... <span class="org-variable-name">event</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Perfect forwarding (Events&amp;&amp;) is an universal reference, not a</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">R-value reference. </span>
        <span class="org-rainbow-delimiters-depth-2">(</span>fsm.dispatch<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::forward<span class="org-rainbow-delimiters-depth-4">&lt;</span>Event<span class="org-rainbow-delimiters-depth-4">&gt;(</span>events<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>, ...<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

dispatch<span class="org-rainbow-delimiters-depth-1">(</span>
        fsm,
        event_connect<span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"tain-it.eu"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
        event_timeout<span class="org-rainbow-delimiters-depth-2">{}</span>,
        event_connected<span class="org-rainbow-delimiters-depth-2">{}</span>,
        event_disconnected<span class="org-rainbow-delimiters-depth-2">{}</span>
        <span class="org-rainbow-delimiters-depth-1">)</span>;

</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org4cec61f" class="outline-3">
<h3 id="org4cec61f"><span class="section-number-3">1.4</span> Functional</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org80f0b8d" class="outline-4">
<h4 id="org80f0b8d"><span class="section-number-4">1.4.1</span> CppCon 2015: Stephan T. Lavavej "functional: What's New, And Proper Usage"</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=zt7ThwVfap0">CppCon 2015: Stephan T. Lavavej “functional: What's New, And Proper Usage" - YouTube</a>
<ul class="org-ul">
<li>"functional gained lots of machinery in C++11, with further
changes in C++14 and C++17. This talk will cover what's new in
11/14/17, focusing on how to use it properly. For example, you've
probably used std::function, but do you know the criteria for
activating the Small Functor Optimization? (It's not just being
small!) We'll also look at bind(), mem_fn(), C++17's invoke(),
and more."</li>
</ul></li>
</ul>

<p>
<b>C++11 Lambdas Expressions</b>
</p>

<ul class="org-ul">
<li>Lambda expressions are core language features. They aren't ordinary
functions or functions. Actually, lambdas are a special type of
function-object, Functor generated by the compiler. The compiler
converts lambda expressions into unnamed classes.

<ul class="org-ul">
<li>A lambda is just a class with member function:
UnammedClass::operator()(Arguments &#x2026;)</li>
</ul></li>

<li>Lambdas are not std::function. This type is polymorphic type which
works with function-objects (aka callable objects or "functors")
and ordinary function pointers.</li>
</ul>

<p>
<b>Terminology of C++ ISO Standard</b>
</p>

<p>
<span class="underline">Function-Object</span>: Anything that can be used or called like a function: 
</p>

<ul class="org-ul">
<li>Function pointers</li>
<li>Classes with operator()(Args),</li>
<li>C++11 Lambdas</li>
<li>Reference to functions (also called like a function, but the
stdandard does not regard it as an object type)</li>
</ul>

<p>
<b>C++17 std::invoke()</b> 
</p>

<ul class="org-ul">
<li>=&gt; Allows to call anything callable, namely:
<ul class="org-ul">
<li>function pointers</li>
<li>function objects</li>
<li>pointers to member functions (PMFs): (obj.* pmf)(arg)</li>
<li>pointers to data member (PMDs): obj.*pmd</li>
</ul></li>
</ul>

<p>
 <span class="underline">std::invoke</span> provides an uniform syntax for invoking all callable
'objects' in C++.
</p>

<p>
Invoke is particurlarly useful for implementing "higher order
functions" with templates: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Range</span>, <span class="org-keyword">typename</span> <span class="org-type">Callable</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> 
<span class="org-type">void</span> <span class="org-function-name">transform_print</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-type">Range</span>&amp; <span class="org-variable-name">range</span>, <span class="org-type">Callable</span> <span class="org-variable-name">fobj</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span> : range<span class="org-rainbow-delimiters-depth-2">)</span>
      <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-constant">std</span>::invoke<span class="org-rainbow-delimiters-depth-2">(</span>fobj, x<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">cling</span><span class="org-rainbow-delimiters-depth-1">]</span>$ <span class="org-keyword">auto</span> xs = <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-1">&gt;{</span><span class="org-string">"hello"</span>, <span class="org-string">"world"</span>, <span class="org-string">"c++17"</span><span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">cling</span><span class="org-rainbow-delimiters-depth-1">]</span>$ xs
<span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-string">"hello"</span>, <span class="org-string">"world"</span>, <span class="org-string">"c++17"</span> <span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Pass a member fucntion </span>
<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-constant">cling</span><span class="org-rainbow-delimiters-depth-1">]</span>$ transform_print<span class="org-rainbow-delimiters-depth-1">(</span>xs, &amp;<span class="org-constant">std</span>::<span class="org-constant">string</span>::size<span class="org-rainbow-delimiters-depth-1">)</span>;
5
5
5

</pre>
</div>

<p>
<b>C++11 std::bind()</b>  
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor"> #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor"> #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">algorithm</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor"> #include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> 
 <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">placeholders</span>;

 <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">vs</span><span class="org-rainbow-delimiters-depth-1">{</span>1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144<span class="org-rainbow-delimiters-depth-1">}</span>;

 <span class="org-comment-delimiter">// </span><span class="org-comment">Count the number of elements less than 25 </span>
 &gt;&gt; <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"cout = "</span> &lt;&lt; <span class="org-constant">std</span>::count_if<span class="org-rainbow-delimiters-depth-1">(</span>vs.begin<span class="org-rainbow-delimiters-depth-2">()</span>, vs.end<span class="org-rainbow-delimiters-depth-2">()</span>, 
                                            <span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::less<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>, _1, 25<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> 
                           &lt;&lt; <span class="org-constant">std</span>::endl;
 cout = 4
 &gt;&gt; 

&gt;&gt; <span class="org-keyword">auto</span> fn = <span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::less<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>, _1, 25<span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; fn<span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; fn<span class="org-rainbow-delimiters-depth-1">(</span>100<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; fn<span class="org-rainbow-delimiters-depth-1">(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; fn<span class="org-rainbow-delimiters-depth-1">(</span>24<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">true</span>
&gt;&gt; fn<span class="org-rainbow-delimiters-depth-1">(</span>25<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-constant">false</span>
&gt;&gt; 
</pre>
</div>

<p>
<b>Reference wrapper class definition</b> 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">class</span> <span class="org-type">reference_wrapper</span>
<span class="org-rainbow-delimiters-depth-1">{</span> 
<span class="org-function-name">public</span>: 
  <span class="org-keyword">typedef</span> <span class="org-type">T</span> <span class="org-type">type</span>;
  <span class="org-function-name">reference_wrapper</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>  <span class="org-keyword">noexcept</span>;
  <span class="org-function-name">reference_wrapper</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>&amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
  <span class="org-type">reference_wrapper</span> <span class="org-type">T</span>&amp;<span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">noexcept</span>;
  <span class="org-type">T</span>&amp; <span class="org-function-name">get</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span> <span class="org-keyword">noexcept</span>;

  <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span>... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
   <span class="org-constant">std</span>::<span class="org-type">result_of_t</span><span class="org-rainbow-delimiters-depth-2">&lt;</span>T&amp; <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">Args</span>&amp;&amp;...<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
   <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Args</span>&amp;&amp;...<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Recommendations</b> 
</p>

<ul class="org-ul">
<li>Never use the old &lt;functiona&gt; stuff such as mem_fn</li>
<li>Remove any existing usage</li>
<li>C++98/03 algorithms/containers never needed unary_function /
binary_function, ptr_fun() [DEPRECATED, DISCONTINUED]</li>
<li>Also remove: auto_ptr</li>
</ul>

<p>
<b>std::function</b> 
</p>

<ul class="org-ul">
<li>function&lt;Ret (Args) is a wrapper
<ul class="org-ul">
<li>stores a callable ob ject of abitrary type</li>
<li>tempalted on call signature, not callable object type</li>
<li>type erasure, powered by virtual functions (or equivalent)</li>
<li>Useful when code cannot be templated
<ul class="org-ul">
<li>Separately compiled code</li>
<li>Virtual function</li>
<li>Container elements</li>
</ul></li>
<li>Requires copy-constructible function objects</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">using</span> <span class="org-type">Function</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">placeholders</span>;

<span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">bind</span>;
<span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">plus</span>;
<span class="org-keyword">using</span> <span class="org-constant">std</span>::<span class="org-type">multiplies</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">funlist</span> = <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Function</span><span class="org-rainbow-delimiters-depth-1">&gt;{}</span>;

funlist.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-2">(</span>plus<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>, _1, 10<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
funlist.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::bind<span class="org-rainbow-delimiters-depth-2">(</span>multiplies<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;()</span>, _1, 3<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
funlist.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::sin <span class="org-rainbow-delimiters-depth-1">)</span>
funlist.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::cos <span class="org-rainbow-delimiters-depth-1">)</span>
funlist.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-3">(</span>*<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-constant">std</span>::exp <span class="org-rainbow-delimiters-depth-1">)</span>
funlist.emplace_back<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">double</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">return</span> 4 * x + 5;<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-1">)</span>

&gt;&gt; funlist
<span class="org-rainbow-delimiters-depth-1">{</span> @0x2f27b50, @0x2f27b70, @0x2f27b90, @0x2f27bb0, @0x2f27bd0 <span class="org-rainbow-delimiters-depth-1">}</span>
&gt;&gt; 

&gt;&gt; <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">const</span> <span class="org-keyword">auto</span>&amp; <span class="org-variable-name">fn</span>: funlist<span class="org-rainbow-delimiters-depth-1">){</span> <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" =&gt; "</span> &lt;&lt; fn<span class="org-rainbow-delimiters-depth-2">(</span>4.0<span class="org-rainbow-delimiters-depth-2">)</span> &lt;&lt; <span class="org-constant">std</span>::endl; <span class="org-rainbow-delimiters-depth-1">}</span>
 =&gt; 14
 =&gt; 12
 =&gt; -0.756802
 =&gt; -0.653644
 =&gt; 54.5982
 =&gt; 21

</pre>
</div>
</div>
</div>










<div id="outline-container-org38641e4" class="outline-4">
<h4 id="org38641e4"><span class="section-number-4">1.4.2</span> CPPCON-2017: Klaus Iglberger - Free Your Functions</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=WLDT1lDOsb4">CppCon 2017: Klaus Iglberger "Free Your Functions!"</a>
<ul class="org-ul">
<li>Description: "You are devoted to minimize coupling and
duplication? You are taking care to maximize cohesion,
flexibility, extensibility, encapsulation, testability, and even
performance in order to achieve the high goals of
(object-oriented) programming? Awesome!  But wait: You still
favor member functions? Seriously? You have been deceived! You
have been praying at the altar of false promises! Shed the
shackles of Java philosophy! Free your functions!. In this talk I
will demonstrate why in C++ free functions should generally be
preferred to member functions, and why free functions — not
member functions! — provide you with all the aforementioned
advantages you expect from object-oriented programming. Note,
though, that this talk might fundamentally change your perception
of C++ and object-oriented programming in general!"</li>

<li><span class="underline">Summary and notes</span>:
<ul class="org-ul">
<li><span class="underline">Free functions</span> (ordinary functions or non-virtual functions)
abides to object oriented principles such as OCP (Open-Close
Principle) as they can extend a class without requiring
modification or recompilation of the class source code.</li>
<li><span class="underline">Static polymorphism</span> which is a combination of free functions
and <span class="underline">template metaprogramming</span> can make the code more loosely
coupled and more perfomant.
<ul class="org-ul">
<li>Becomes more loosely coupled because it doesn't require that
arguments have any common base class or class hierarchy.</li>
<li>Becomes more performant as template generates overloaded code
for each different type parameters combination what
eliminates virtual function calls and dynamic
polymorphism. The disadvantage of templates are the higher
complexity and larger code size.</li>
</ul></li>
<li>Benefits of Free Functions:
<ul class="org-ul">
<li>Encapsulation</li>
<li>Cohesion (SRP - Single Responsibility Principle)</li>
<li>Reuse (DRY - DO NOT REPEAT YOURSELF)</li>
<li>Overloading (Polymorphism )</li>
<li>Generic Programming (Aka template metaprogramming)</li>
<li>Abstraction</li>
<li>Testability</li>
<li><span class="underline">Performance</span> (Raison d'être of C++).</li>
</ul></li>

<li>Free Functions on standard library:
<ul class="org-ul">
<li>std::begin, std::cbegin &#x2026;</li>
</ul></li>

<li>Use free functions in order to:
<ul class="org-ul">
<li>&#x2026; wrap virtual function calls</li>
<li>&#x2026; get an homogeneous interface.</li>
<li>&#x2026; get more performant code.</li>
<li>&#x2026; more flexible and loosely-coupled code.</li>
</ul></li>

<li>Free functions aren't are multi-paradigm, they can work with
any paradigm. It is not necessarly functional programming.</li>

<li>Potential Problems
<ul class="org-ul">
<li>C++ doens't have a convenient syntax for function application
as ML-based languages like Haskell and OCaml. So, multiple
function applications would be written as f1(f2(f3(f5 &#x2026; fn(x))))</li>

<li><span class="underline">Discoverability</span>: according to the presentation, IDE's may not
help to find them easily as they help to find methods (aka
member functions). However it can mitigated with careful
selection of namespaces which would improve code complexion
and discoverability.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5195594" class="outline-4">
<h4 id="org5195594"><span class="section-number-4">1.4.3</span> C++Now 2018: Ben Deane "Easy to Use, Hard to Misuse: Declarative Style in C++"</h4>
<div class="outline-text-4" id="text-1-4-3">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=2ouxETt75R4">C++Now 2018: Ben Deane “Easy to Use, Hard to Misuse: Declarative Style in C++” - YouTube</a>
<ul class="org-ul">
<li>We say that interfaces should be easy to use and hard to
misuse. But how do we get there? In this talk I will demonstrate
how using declarative techniques in APIs, functions, and plain
old "regular" code can help. We'll look at what is meant by
"declarative style" in C++; explore why declarative interfaces
are desirable and how to construct them; and take an in-depth
look at which features of C++ help us write in a declarative
style. I want to deconstruct C++ a bit, examine what we're doing
and what makes the good parts good, and from that reconstruct
some best practices. Many of us are already writing code
following piecemeal modern advice such as "no raw loops", or
"almost always auto", or C++ core guideline recommendations. In
many cases, this advice translates to writing more declarative
code; being deliberate about exploring and using declarative
techniques gives us insight we can apply more widely.</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgab72219" class="outline-3">
<h3 id="orgab72219"><span class="section-number-3">1.5</span> Tooling</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org905f01c" class="outline-4">
<h4 id="org905f01c"><span class="section-number-4">1.5.1</span> LVM Euro Conference 2013 - The Clang AST - a Tutorial</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=VqCkCDFLSsc">The Clang AST - a Tutorial - YouTube</a>
<ul class="org-ul">
<li>"If you always wanted to know more about about Clang's AST [1],
for example because you want to implement an awesome tool [2, 3]
based on Clang, or simply because you want to start contributing,
this talk is for you."</li>
<li>Note: Clang + LLVM suite provides many services that can be used
to build code automation tools for C++ such as code generators
and reflection metadata code generator.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd687786" class="outline-4">
<h4 id="orgd687786"><span class="section-number-4">1.5.2</span> CppCon 2018: "Latest and Greatest in the Visual Studio Family for C++ Developers 2018"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tooling">tooling</span></span></h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=6NAAuxWNhk4&amp;feature=youtu.be">CppCon 2018: “Latest and Greatest in the Visual Studio Family for C++ Developers 2018” - YouTube</a>
<ul class="org-ul">
<li>"This talk will be modeled on our previously successful talks at
CppCon. We'll give the community an update on how we are doing
in terms of conformance where we'll be announcing the final
conformance state for MSVC for the final 2017 update. We'll be
showing many many demos of new features (not in previous
versions of this talk) that target cross platform developers in
C++. This will include making it easier to bring your code to
Visual Studio, significant improvements to ease of use for
developers using CMake, improvements to unit testing
experiences, a lot of new Linux targeting improvements, an
update on our performance work, and new debugger features for
C++ developers. Developers will learn new tricks they can apply
immediately on leaving the session as well as get a sense of
what is coming in future updates. The main message is that
Visual Studio and Visual Studio Code will make every C++
developer (not just Windows developers) more productive."</li>
</ul></li>

<li>Features:

<ul class="org-ul">
<li>Fredom to target any platform from a single ID:
<ul class="org-ul">
<li>ARM/mBed, Android, Cyngwin, iOS, Linux, UWP, Windows</li>
</ul></li>

<li>CMake compatibility</li>

<li>The VC++ Compiler has full support for C++11/14/15 language features.

<ul class="org-ul">
<li>Process Snapshot - allows to introspect process memory.</li>

<li>Macro expansion - The editor, now can expand macros when the
mouse is hoovered over some macro.</li>

<li>Completion for templates.</li>

<li>Live Sharing =&gt; Collaboration session.</li>

<li>Multiple cursor editing, aka multi caret editing: hold CTRL +
ALT and click at the points where the cursor will be placed
and then type.</li>

<li>Peek definition.</li>

<li>Compiler flags:
<ul class="org-ul">
<li>/std:c++14 (default)</li>
<li>/std:c++17</li>
<li>/std:c++latest</li>
<li>/experimental:external  - Switch to isolate code from
external headers.</li>
</ul></li>

<li>C++ Core Check - <a href="https:/aka.ms/CppCoreCheck">https:/aka.ms/CppCoreCheck</a></li>
</ul></li>

<li>Integratio with other building systems: Make, Ninja, NMake, &#x2026;</li>

<li>Code editing experience:
<ul class="org-ul">
<li>IntelliSense =&gt; Smart Code Completion</li>
<li>Refactoring</li>
<li>Debugging</li>
<li>Reverse Debugging</li>
<li>Debug Visualization</li>
</ul></li>

<li>Integration with other compilers and tools:
<ul class="org-ul">
<li>Clang/LLVM, GCC, Clang-format, Google-test, Boost.Test</li>
</ul></li>

<li>Recommended Package Manger: <b>Vcpakge</b> - cross platform package
manager which works on Linux, MacOSX and Windows. There are over
900 libraries available in that.

<ul class="org-ul">
<li>$ vcpackage install boost sdl zlib gtest</li>
<li><a href="https://aka.ms/vcpkg">https://aka.ms/vcpkg</a></li>
</ul></li>

<li>Can compile and run code in remote machines and also perform
remote debugging.</li>

<li>One of the most valued and loved of feature of Visual Studio is
the <b>debugger</b>.
<ul class="org-ul">
<li>The debugger can attach to process in current or remote
machine through SSH.</li>
</ul></li>

<li><b>CMake target view</b> provides a CMake-centric experience showing
all targets, files and configuration.</li>

<li><b>Open folder experience:</b>
<ul class="org-ul">
<li>Optmized for non-MSBuild projects =&gt; any project using CMake,
make or other C++ building system. Target Windows, MinGW,
Cyngwin, Linux or mBed.</li>
<li>Easy to get started
<ul class="org-ul">
<li>devenv.exe &lt;folder&gt;</li>
<li>File =&gt; Open =&gt; Folder &#x2026; (Ctrl + Alt +Shift + O)</li>
</ul></li>
</ul></li>

<li>Linux Targeting:
<ul class="org-ul">
<li>Visual Studio can connect to any linux distribution with
GDB or GdbServer. Remove VMs, Containers, IoT (RasberryPI, Beaglebone),
Local Windows Subsystem for Linux distros and Cross-Compile.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgecab5e6" class="outline-4">
<h4 id="orgecab5e6"><span class="section-number-4">1.5.3</span> Rapid Prototyping in C++ - Dmitri Nesteruk - Meeting C++ 2015</h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=Ncy4Y-k-vLA">Rapid Prototyping in C++ - Dmitri Nesteruk - Meeting C++ 2015 - YouTube</a>
<ul class="org-ul">
<li>Description: Show several techniques for fast prototyping in C++.</li>
<li>Summary:
<ul class="org-ul">
<li>CERN's ROOT Framework or CLING C++ interpreter. Allows to play
and evaluate C++ code in the same fashion Python interpreter does.</li>
<li>Wrap the C++ library with SWIG wrapper generator to generate a Python binding and
then prototype in the Python REPL.</li>
<li>Use a more suitable tool with fast feedback for prototyping
such as spreadsheet, R language, Python, Matlab, Octave and so
on.</li>
<li>Runtime compiled C++.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org89435b1" class="outline-4">
<h4 id="org89435b1"><span class="section-number-4">1.5.4</span> CppCon 2018: Steven Simpson "Source Instrumentation for Monitoring C++ in Production"&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tooling">tooling</span>&#xa0;<span class="instrumentation">instrumentation</span></span></h4>
<div class="outline-text-4" id="text-1-5-4">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=0WgC5jnrRx8&amp;feature=youtu.be">CppCon 2018: Steven Simpson “Source Instrumentation for Monitoring C++ in Production” - YouTube</a>
<ul class="org-ul">
<li>"It is essential to discuss how modern C++ code can be
effectively instrumented, in order to effectively monitor it
after deployment. <b>This talk will focus on portable source</b>
<b>instrumentation techniques such as logging, tracing and</b>
<b>metrics</b>. Straightforward, but well designed code additions can
drastically ease the troubleshooting of functional issues, and
identification of performance bottlenecks, in production.  Of
course when dealing with C++ performance is often critical, and
so minimizing the cost of any instrumentation is also
critical. Key to this is understanding the trade-off between the
detail of information collected, and the overheads of exposing
that information. It is also important to understand how best to
benefit from advances in contemporary monitoring infrastructure,
popularised by "cloud" environments.  This talk will open with a
brief summary of monitoring goals, infrastructure, benefits, and
existing practise. It will then detail practicalities of building
a set of C++ source instrumentation primitives, based on proven
principles employed in demanding production software."</li>
</ul></li>
</ul>


<ul class="org-ul">
<li>Summary + Notes + Brainstorm:
<ul class="org-ul">
<li>Use a logging library with the following features.
<ul class="org-ul">
<li>Format string (or ostream)</li>
<li>Serverity levels, [INFO], [WARNING], [FAILURE], [CRITICAL], [TRACE] &#x2026;</li>
<li>Enable/disable at runtime</li>
<li>Logs files + rotation</li>
<li>Timestamp</li>
<li>Remote Logging</li>
<li>OS Integration =&gt; Syslog on U*nix, or OutputDebugString on Windows.</li>
</ul></li>

<li>Error messages and exception should have context about the
problem such as the file where it happened, code line, what
caused the exception and so on.</li>

<li>Log Service infrastructure:
<ul class="org-ul">
<li>Should support search, indexing, sorting and filtering.</li>
<li>Structured Logging Format: json, csv, to avoid parsing and
writing complicated regular expressions.</li>
<li>Logging Alert</li>
<li>Logging can be stored in cloud services.</li>
</ul></li>

<li>Logging X Tracing

<ul class="org-ul">
<li>A more detailed logging, showing the internals of some
operation for debugging purposes.</li>

<li>Example about tracing: Unix utility strace which log system
calls perfomed by a program. $ strace -ttT cat hello.txt</li>
</ul></li>

<li>Downsides of logging:
<ul class="org-ul">
<li>Logging may, specially writing to IO, may cause performance
overhead on performance critical code. This is why tracing
logging in this type of code is often disabled on deployment
builds.</li>
<li>Tracing can be implemented with C-preprocessor macros in
order to allow disabling it on debug builds. Using
preprocessor has also the advatange that, when the tracing is
disabled, it will not inccur on any rutime overhead or
performance cost, as string concatenation will not happen and
the code will be discarded.</li>
</ul></li>

<li>Domains where logging is essential:
<ul class="org-ul">
<li><span class="underline">Network Servers and Web Servers</span>. =&gt; Servers are long running
programs which runs in background as daemons without any
graphical user interface. So logging, is the only available
information about what is going on with the sefver.</li>
<li><span class="underline">Databases</span></li>
<li><span class="underline">Embedded Systems</span> =&gt; Usually doesn't have keyboard, monitor
and etc.</li>
<li><span class="underline">Industrial Instrumentation</span> =&gt; Temperature, pressure, speed, &#x2026;</li>
</ul></li>

<li>Closing:
<ul class="org-ul">
<li>By building observable software, the software can become its
own debugger.</li>
</ul></li>

<li><b>Techniques for Program Instrumentation</b> =&gt; My Ideas.
<ul class="org-ul">
<li>Logging with some logging library</li>
<li>Debug Build 
<ul class="org-ul">
<li>Debugging Symbols</li>
<li>Assertions =&gt; Allows to check assumptions during the
development.</li>
<li>Tracing</li>
</ul></li>
<li>Use a proper debugger such as GDB, WindBG, LLDB for
instrospecting the process.</li>
<li>Proper error messages with enough context information.</li>
<li>Unit Tests or some automated testing.</li>
<li>System call logger such as strace.</li>
<li>Memory Leak Detector such as Valgrind.</li>
<li>Profiler =&gt; Mesure performance.</li>
<li>Compiler with non cryptic error messages like Clang++.</li>
<li>Enforce as much correctness as possible at compile-time in
order to catch bugs earlier before runtime and deployment.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf10360a" class="outline-3">
<h3 id="orgf10360a"><span class="section-number-3">1.6</span> High Performance Computing and Math</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org6d53fb7" class="outline-4">
<h4 id="org6d53fb7"><span class="section-number-4">1.6.1</span> CPPCON 2016: Klaus Iglberger "The Blaze High Performance Math Library"</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=w-Y22KrMgFE">CppCon 2016: Klaus Iglberger “The Blaze High Performance Math Library" - YouTube</a>
<ul class="org-ul">
<li>"In this presentation we introduce the Blaze C++ math library, a
hot contender for the linear algebra performance throne. Blaze
is an open-source, high-performance library for dense and sparse
arithmetic. It combines elegance and ease of use with HPC-grade
performance, making it one of the most intuitive and at the same
time fastest C++ math libraries available. We demonstrate its
basic linear algebra functionality by means of several BLAS
level 1 to 3 operations and explain why Blaze outperforms even
well established linear algebra libraries. Additionally, we
present some advanced features that enable users to adapt Blaze
to special circumstances: custom data structures, custom
operations, and the customizable error reporting mechanism."

<ul class="org-ul">
<li>Note: Blaze library uses <span class="underline">Express Template</span> technique for
compile-time generation of high-performance linear algebra
code.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0481770" class="outline-4">
<h4 id="org0481770"><span class="section-number-4">1.6.2</span> Statistical scientific programming OO patterns: accumulators - Olivia Quinet - Lightning Talks&#xa0;&#xa0;&#xa0;<span class="tag"><span class="math">math</span>&#xa0;<span class="science">science</span></span></h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=IwvA7oExmSo">Statistical scientific programming OO patterns: accumulators - Olivia Quinet - Lightning Talks - YouTube</a>
<ul class="org-ul">
<li>"Statistical scientific programming OO patterns: accumulators -
Olivia Quinet - Lightning Talks Meeting C++ 2017"
<ul class="org-ul">
<li>Summary: Accumulators like Boost.Accumulators allows to compute
several statistical properties of a set of values such as a
time series avoiding errors such as <span class="underline">float pointing</span>
<span class="underline">castastrophic cancellation</span> and loss of precision. <span class="underline">The Welford</span>
<span class="underline">statistical formula is shown as a way to implement accumulators</span>
and how it can be used to compute standard deviation and other
statistical properties.</li>
</ul></li>
</ul></li>
</ul>

<p>
See: Welford statiscal formulas &amp; Accumulators =&gt; Incremental statical
computations. 
</p>
</div>
</div>

<div id="outline-container-org8964467" class="outline-4">
<h4 id="org8964467"><span class="section-number-4">1.6.3</span> Algorithms and Iterators for Multidimensional Arrays - Cem Bassoy - Lightning Talks Meeting C++ 2017&#xa0;&#xa0;&#xa0;<span class="tag"><span class="math">math</span>&#xa0;<span class="science">science</span></span></h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=8P-sDH9XJAc">Algorithms and Iterators for Multidimensional Arrays - Cem Bassoy - Lightning Talks Meeting C++ 2017 - YouTube</a></li>
</ul>

<p>
Paper at:  <a href="https://arxiv.org/abs/1711.10912">1711.10912 - TLib: A Flexible C++ Tensor Framework for Numerical Tensor Calculus</a>
</p>

<p>
Abstract:
</p>

<blockquote>
<p>
Numerical tensor calculus comprise basic tensor operations such as the
entrywise addition and contraction of higher-order tensors. We
present, TLib, flexible tensor framework with generic tensor functions
and tensor classes that assists users to implement generic and
flexible tensor algorithms in C++. The number of dimensions, the
extents of the dimensions of the tensors and the contraction modes of
the tensor operations can be runtime variable. Our framework provides
tensor classes that simplify the management of multidimensional data
and utilization of tensor operations using object-oriented and generic
programming techniques. Additional stream classes help the user to
verify and compare of numerical results with MATLAB. Tensor operations
are implemented with generic tensor functions and in terms of
multidimensional iterator types only, decoupling data storage
representation and computation. The user can combine tensor functions
with different tensor types and extend the framework without further
modification of the classes or functions. We discuss the design and
implementation of the framework and demonstrate its usage with
examples that have been discussed in the literature.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orgab6db36" class="outline-4">
<h4 id="orgab6db36"><span class="section-number-4">1.6.4</span> Ranges and Iterators for numerical problems - Karsten Ahnert @ Meeting C++ 2014</h4>
<div class="outline-text-4" id="text-1-6-4">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=qXdPFj-FTcA">Ranges and Iterators for numerical problems - Karsten Ahnert @ Meeting C++ 2014 - YouTube</a></li>
</ul>
</div>
</div>
<div id="outline-container-org7bcca3e" class="outline-4">
<h4 id="org7bcca3e"><span class="section-number-4">1.6.5</span> Guy Davidson: Standardizing a Linear Algebra Library&#xa0;&#xa0;&#xa0;<span class="tag"><span class="math">math</span></span></h4>
<div class="outline-text-4" id="text-1-6-5">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=pq4UEH-DbNs&amp;feature=youtu.be">Guy Davidson: Standardising A Linear Algebra Library</a>
<ul class="org-ul">
<li>Time: 1 hour.</li>
<li>See: <a href="https://groups.google.com/a/isocpp.org/forum/#!forum/sg14">https://groups.google.com/a/isocpp.org/forum/#!forum/sg14</a></li>
</ul></li>
</ul>

<p>
What to expect: 
</p>
<ol class="org-ol">
<li>Representing linear equations [10-67]</li>
<li>I can do better than this [69-67]</li>
<li>Everything you need to know about storage [109-119]</li>
<li>The upsetting story of std::complex [121-190]</li>
<li>Alternative algorithms [192-210]</li>
<li>Assembling the API [212-237]</li>
</ol>

<p>
Goals: 
</p>
<ol class="org-ol">
<li>Provide linear algebra vocabulary types</li>
<li>Parameterize orthogonal aspects of implementation</li>
<li>Default for 90%, customisable for power users</li>
<li>Element access, matrix arithmetics, fundamental operations</li>
<li>Mixed precision and mixed representation expressions</li>
</ol>

<p>
Linear algebra 101: 
</p>
<ul class="org-ul">
<li>"The branch of mathematics concerning linear equations and linear
functions, and their representation through matrices and vectors
spaces"</li>

<li>a1 * x1 + a2 * x2 + &#x2026; an * xn = b  (Linear equation or combination)</li>
</ul>

<p>
Linear algebra applications: 
</p>
<ul class="org-ul">
<li>Solving simultaneous linear equations</li>
<li>Linear regression</li>
<li>Differential equations</li>
<li>Physics</li>
<li>Economics</li>
<li>Statistics</li>
<li>Porforlio modelling</li>
<li>Data science (beutiful name for statistics)</li>
</ul>

<p>
Operations: 
</p>
<ul class="org-ul">
<li>Scaling: Vector or matrix multiplication by a number</li>
<li>Element-wise Sum, Subtraction, Multiplication or division between
vectors or matrices.</li>
<li>Vector dot product (aka inner product)</li>
<li>Vector or matrix transpose</li>
<li>Matrix product</li>
</ul>

<p>
The equations: 
</p>

<div class="org-src-container">
<pre class="src src-text">a11 * x1 + a12 * x2 = b1 
a21 * x2 + a21 * x2 = b2 
</pre>
</div>

<p>
Can be written as <span class="underline">A * x = b</span>: 
</p>

<div class="org-src-container">
<pre class="src src-text">[ a11   a12 ]     [ x1 ]    [ b1 ]
[           ]  x  [    ]  = [    ]
[ a21   a22 ]     [ x2 ]    [ b2 ]
</pre>
</div>

<p>
Where:
</p>

<div class="org-src-container">
<pre class="src src-text">     [ a11   a12 ]  
A =  [           ]  
     [ a21   a22 ]  

b = [ b1 b2 ]^T (transpose)

x = [ x1 x2 ]^T
</pre>
</div>

<p>
The presenter uses linear algebra specialized for games development
with the following optmizations: 
</p>
<ul class="org-ul">
<li>Matrix size is known: 2 and 4 rows and columns</li>
<li>float - all elements are float (32 bits)</li>
<li><b>SIMD</b>  instruction set</li>
<li>Cache line size (cache behavior)</li>
<li>Dense</li>
</ul>

<p>
Prior development: 
</p>

<ul class="org-ul">
<li>BLAS (Basic Linear Algebra Subprograms) - Written in Fortrain 
<ul class="org-ul">
<li>Provides a common set of routines for linear algebra operation.</li>
<li>There are many bindings including C-bindings and other implementation.</li>
</ul></li>

<li>BLAS++ =&gt; 32 functions</li>

<li>Boost.uBLAS - Last update at 2009 (No constexpr, no noexcept &#x2026;)</li>

<li>Eigen -&gt; Template-based library without Fortran runtime dependency
<ul class="org-ul">
<li>Matrix and vector class templates</li>
<li>Dynamic or static sizes</li>
<li>Uses expression-template technique for compile-time optmization.</li>
<li>Span option via Eigen::Map</li>
<li>The API is defined by member function operators</li>
</ul></li>

<li>Dlib =&gt; Uses <span class="underline">expression-templates</span> for compile-time optmization and
higher runtime performance.</li>
</ul>

<p>
Example: Function of BLAS++
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-constant">blas</span>::<span class="org-function-name">axpy</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int64_t</span> <span class="org-variable-name">n</span>, 
                <span class="org-type">float</span> <span class="org-variable-name">alpha</span>, 
                <span class="org-type">float</span> <span class="org-keyword">const</span>* <span class="org-variable-name">x</span>, 
                <span class="org-type">int64_t</span> <span class="org-variable-name">incx</span>, 
                <span class="org-type">float</span>* <span class="org-variable-name">y</span>, 
                <span class="org-type">int64_t</span> <span class="org-variable-name">incy</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Levels of BLAS API: 
</p>

<ul class="org-ul">
<li><b>Level 1</b> - contains vector operations
<ul class="org-ul">
<li>asum  - vector 1 norm (sum)</li>
<li>axpy  - add vectors</li>
<li>copy  - copy vector</li>
<li>dot   - dot product</li>
<li>dotu  - dot product unconjugated</li>
<li>imax  - max element</li>
<li>nrm2  - vector 2 norm</li>
<li>rot   - apply Givens plane rotation</li>
<li>rotg  - generate Givens plane rotation</li>
<li>rotm  - apply modified Givens plane rotation</li>
<li>rotmg - gwnerate modified Givens plane rotation</li>
<li>scal  - scale vector</li>
<li>swap  - swap vectors</li>
</ul></li>

<li><b>Level 2</b> - contains matrix operations
<ul class="org-ul">
<li>gemmm - General matrix multiplication: C = A x B + C</li>
<li>hemm  - Hermitian matrix multiply</li>
<li>herk  - Hermitian rank k update</li>
<li>her2k - Hermitian rank 2k update</li>
<li>symm  - Symmetric matrix multiply</li>
<li>syrk  - Symmetric rank k update</li>
<li>syr2k - Symmetric rank 2k update</li>
<li>trmm  - Triangular matrix multiply</li>
<li>trsm  - Triangular solve matrix</li>
</ul></li>
</ul>

<p>
<b>Problem of member function operators:</b> - <a href="https://youtu.be/pq4UEH-DbNs?t=1135">moment</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">row_vector</span><span class="org-rainbow-delimiters-depth-1">{</span> 
<span class="org-function-name">public</span>:
  <span class="org-function-name">row_vector</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">elements</span><span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">double</span> &amp;<span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">[]</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> <span class="org-rainbow-delimiters-depth-2">)</span>       <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> elems<span class="org-rainbow-delimiters-depth-3">[</span>i<span class="org-rainbow-delimiters-depth-3">]</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">double</span>  <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">[]</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> <span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> elems<span class="org-rainbow-delimiters-depth-3">[</span>i<span class="org-rainbow-delimiters-depth-3">]</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-type">size_t</span>  <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span>                <span class="org-keyword">const</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> elems.size<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-function-name">private</span>:
  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">float</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">elems</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
Operator: (+)
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">row_vector</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">u</span>, <span class="org-type">row_vector</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">v</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; row_vector
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">rwo_vector</span> <span class="org-variable-name">sum</span><span class="org-rainbow-delimiters-depth-2">(</span>u.size<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; u.size<span class="org-rainbow-delimiters-depth-3">()</span>; i++<span class="org-rainbow-delimiters-depth-2">)</span>
     sum<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> = u<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> + v<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span>;
   <span class="org-keyword">return</span> sum;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Efficiency problem: <a href="https://youtu.be/pq4UEH-DbNs?t=1174">moment 19:34</a>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">a</span> = row_vector<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">b</span> = row_vector<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">c</span> = row_vector<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">auto</span> <span class="org-variable-name">d</span> = a + b + c;
</pre>
</div>

<p>
Last operation is equivalent to: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">d</span> = a.<span class="org-keyword">operator</span>+<span class="org-rainbow-delimiters-depth-1">(</span>b.<span class="org-keyword">operator</span>+<span class="org-rainbow-delimiters-depth-2">(</span>c<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
So the computation of d what would could be done in a single loop as
d[i] = a[i] + b[i] + c[i], requires 2 loops and 2 memory allocatiuon
due to the usage of member functions.
</p>

<p>
Solutions: 
</p>
<ul class="org-ul">
<li>Build a function (non-member function - free function) which can
compute d in a single loop.</li>
<li>Expression Templates - Expression trees. (Delayed compile-time evaluation)</li>
</ul>

<p>
Assembling the API: 
</p>
<ul class="org-ul">
<li>fixed_size_matrix&lt;float, 3, 3&gt;</li>
<li>matrix_ops&lt;fixed_size_matrix, 3, 3&gt;&gt;</li>
<li>template&lt;typename REP&gt; class matrix;</li>
<li>template&lt;typename REP&gt; class row_vector;</li>
<li>template&lt;typename REP&gt; class column_vector;</li>
</ul>

<p>
Objects: 
</p>
<ul class="org-ul">
<li>matrix</li>
<li>row_ector</li>
<li>column_vector</li>
<li>matrix_ops</li>
<li>fiexed_size_matrix</li>
<li>dynamic_size_matrix</li>
<li>matrix_view</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org72b5188" class="outline-3">
<h3 id="org72b5188"><span class="section-number-3">1.7</span> Allocators</h3>
<div class="outline-text-3" id="text-1-7">
</div>
<div id="outline-container-orgf957d10" class="outline-4">
<h4 id="orgf957d10"><span class="section-number-4">1.7.1</span> CppCon 2017: John Lakos Local ('Arena') Memory Allocators (part 1 of 2)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="bloomberg">bloomberg</span>&#xa0;<span class="performance">performance</span></span></h4>
<div class="outline-text-4" id="text-1-7-1">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=nZNd5FjSquk">CppCon 2017: John Lakos “Local ('Arena') Memory Allocators (part 1 of 2)” - YouTube</a>
<ul class="org-ul">
<li>Are allocators worth the trouble? What situations merit their
use? How are they applied effectually? What’s the performance
impact? This practical talk by large scale C++ expert Dr. John
Lakos demonstrates that having allocators in your tool box may
lead to orders of magnitude speed improvements.  The runtime
implications of the physical location of allocated memory is
often overlooked, even in the most performance critical code. In
this talk, we will examine how the performance of systems can
degrade when using `new`/`delete` and `std::allocator` . We will
contrast these global allocators, which allocate memory globally
for a system, with local allocators that each allocate memory for
a proper subset of objects in the system. We will also
demonstrate how local allocators can reduce or entirely prevent
the degradation seen in systems that rely on the global
allocator. Six dimensions – fragmentability, allocation density,
variation, locality, utilization, and contention – will be
introduced to depict the potential for performance penalties and
aid the listener in determining which local allocator will offer
the best performance in their subsystems. Evidence will be
presented that identifying these dimensions, and selecting a
local allocator based upon them, can lead to <b>order-of-magnitude</b>
reductions in run time compared to systems using a global allocator.</li>
</ul></li>
</ul>

<p>
Outline: <a href="https://youtu.be/nZNd5FjSquk?t=264">at 4:24</a>
</p>

<ul class="org-ul">
<li>1. Introduction and background
<ul class="org-ul">
<li>What are memory allocators, and why are they useful?</li>
</ul></li>

<li>2. Understand the problem
<ul class="org-ul">
<li>What aspect of software affect allocation strategy?</li>
</ul></li>

<li>3. Analyzing the benchmar data</li>

<li>4. Conclusions
<ul class="org-ul">
<li>What must be remembered about memory allocators.</li>
</ul></li>
</ul>


<p>
<b>1. Introduction and Background - Important Questions</b>
</p>

<p>
Why should we care about memory allocators?
</p>

<ul class="org-ul">
<li>They enable us to "fine-tune" at low level when needed.</li>
<li>They cna help to improve runtime perfomance.</li>
</ul>

<p>
What are the benefits?  <a href="https://youtu.be/nZNd5FjSquk?t=410">at 6:50</a>
</p>

<ul class="org-ul">
<li>Not all memory is alike.
<ul class="org-ul">
<li>Fast</li>
<li>Shared</li>
<li>Protected</li>
<li>Mapped</li>
</ul></li>

<li>Other qualitative benefits: 
<ul class="org-ul">
<li>Testing</li>
<li>Debugging</li>
<li>Measuring (profiling)</li>
</ul></li>

<li>Enable runtim peformance
<ul class="org-ul">
<li>Better locality, less contention</li>
</ul></li>

<li>Anecdotal evidence: Model of memory allocation.

<ul class="org-ul">
<li>Case: <span class="underline">Bear Stearns</span> (circa 1997) -
<ul class="org-ul">
<li>System's (coalescing) allocator optmized for allocation, not deallocation.</li>
</ul></li>

<li>Case: Bloomberg (circa 2002) [<a href="https://youtu.be/nZNd5FjSquk?t=485">at 8:05</a>] - Swapping to disk 
<ul class="org-ul">
<li>Process global static memory saved/restored via <span class="underline">memory-mapped IO</span>.</li>
</ul></li>

<li>Case: Bloomberg (circa 2006) [<a href="https://youtu.be/nZNd5FjSquk?t=579">at 9:39</a>] - Make user interface
zippier
<ul class="org-ul">
<li>User interface observed to be "zippier" when using local
allocator.</li>
</ul></li>
</ul></li>
</ul>

<p>
What are common arguments against?
</p>
<ul class="org-ul">
<li>Require more up-front design effort.</li>
<li>Compicates user itnerfaces.</li>
<li>May actually degrade performance
<ul class="org-ul">
<li>No special allocator needed.</li>
<li>Poorly chosen allocator supplied.</li>
</ul></li>
</ul>

<p>
They can be addressed only with: 
</p>
<ul class="org-ul">
<li>Well-supported facts.</li>
<li>Careful measurement.</li>
</ul>


<p>
<b>Review of Computer Memory</b> - <a href="https://youtu.be/nZNd5FjSquk?t=731">at 12:11</a>
</p>

<p>
Parts: 
</p>
<ul class="org-ul">
<li>CPU - Central Processing Unit</li>
<li>Cache</li>
<li>Cache Line - A chunk of memory which is pulled into the cache all
at once. There can be many cache lines.</li>
<li>Main Memory (RAM memory - Random Acccess Memory)</li>
</ul>

<p>
Main Memory Segments: <a href="https://youtu.be/nZNd5FjSquk?t=862">at 14:22</a>
</p>
<ul class="org-ul">
<li>Stack Memory =&gt; Grows downward</li>
<li>Dynamic Memory =&gt; Grows upward</li>
<li>Executable program</li>
<li>Static Data Segment</li>
<li>Code Segment (text segment)</li>
</ul>

<p>
<b>What is a memory allocator?</b> 
</p>

<p>
Memory allocators allows to control memory allocation like C-Language
CLang allocation utilities: 
</p>

<ul class="org-ul">
<li>General purpose Global Allocator (C-language)</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">malloc.h </span>
<span class="org-type">void</span>* <span class="org-function-name">malloc</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">nBytes</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">void</span>  <span class="org-function-name">free</span>  <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span>  *<span class="org-variable-name">address</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">Special purpose local allocator which allocates memory on the stack</span>
rather than on the heap. Potential problem: The stack size is small
and is generally limited to a few Megabytes. On Linux Kernel, it
can grow up to 8 Mb. More than that crashes the program.
<ul class="org-ul">
<li><a href="https://www.mkssoftware.com/docs/man3/alloca.3.asp">alloca() &#x2013; allocate space in the stack frame</a></li>
<li><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/alloca?view=vs-2017">MSDOcs - alloca</a></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">alloca.h </span>
<span class="org-type">void</span>* <span class="org-function-name">alloca</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">nBytes</span><span class="org-rainbow-delimiters-depth-1">)</span>; 
</pre>
</div>

<p>
Memory Allocator Definition: <a href="https://youtu.be/nZNd5FjSquk?t=938">at 15:38</a> 
</p>
<ul class="org-ul">
<li>A memory allocator organizes a region of computer memory,
dispensing and reclaiming authorized access to a suitable
sub-regions on demand.</li>
</ul>

<p>
General versus Special Allocator: <a href="https://youtu.be/nZNd5FjSquk?t=967">at 16:07</a>
</p>

<ul class="org-ul">
<li>A general purpose allocator:
<ul class="org-ul">
<li>is designed to work reasonably well ofr all use cases.</li>
<li>Satisfies all requirements for memory allocators.</li>
</ul></li>

<li>A Special-Purpose Allocator:
<ul class="org-ul">
<li>Typically works specially well for some use cases.</li>
<li>Need not satisfy all requirements for allocation E.g:
<ul class="org-ul">
<li>May not be safe to use in a multi-threaded program.</li>
<li>May not be reuse individually freed memory</li>
</ul></li>
<li>Requires specific knowledge of the context of use.</li>
</ul></li>
</ul>

<p>
Global versus Local Allocator - <a href="https://youtu.be/nZNd5FjSquk?t=1005">at 16:45</a>
</p>

<ul class="org-ul">
<li>A Global Allocator
<ul class="org-ul">
<li>Operates on a single ubiquitous region of memory</li>
<li>Exists throughout the lifetime of a program</li>
<li>Is inherently accessible from all pars of a progam</li>
</ul></li>

<li>A Local Allocator
<ul class="org-ul">
<li>Operates on a local sub-region("arena") of memory</li>
<li>May exist for less than a lifetime of a progam</li>
<li>Is (typically) supplied for client via a "reference".</li>
<li>Can (tipically) be used to free memory unilaterally.</li>
</ul></li>
</ul>

<p>
Global, General Allocator Utility: <a href="https://youtu.be/nZNd5FjSquk?t=1044">17:25</a>
</p>

<ul class="org-ul">
<li>C-language - those functions are allocators.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">&lt;malloc.h&gt;</span>
<span class="org-type">void</span>* <span class="org-function-name">malloc</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">size_t</span> <span class="org-variable-name">nbytes</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">void</span>  <span class="org-function-name">free</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">void</span>* <span class="org-variable-name">address</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>C++ - language - the following operators are not allocators, they
only provides access to allocators.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">&lt;new&gt;</span>
<span class="org-keyword">namespace</span> <span class="org-constant">std</span> <span class="org-rainbow-delimiters-depth-1">{</span> 
  <span class="org-type">void</span>* <span class="org-keyword">operator</span> <span class="org-keyword">new</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">nbytes</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-type">void</span>  <span class="org-keyword">operator</span> <span class="org-keyword">delete</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">void</span>* <span class="org-variable-name">address</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
General/Special X Global/Local (<a href="http://asciiflow.com/">http://asciiflow.com/</a>)
</p>

<div class="org-src-container">
<pre class="src src-text">               Global                     Local

         +------------------------+----------------------------+
         |                        |                            |
         |  malloc/free           | multipool_allocator        |
         |  new/delete            |                            |
General  |                        | Any general algorithm      |
         |  tcmalloc              | alpplied to a physically   |
         |  jemalloc              | (and temporally) local     |
         |                        | region of memory           |
         |                        |                            |
         |                        |                            |
         +-----------------------------------------------------+
         |                        |                            |
         | A new unsynchronized   |  Alloca                    |
         | tcmalloc allocator     |                            |
 Special | "plugged into"         |  monotonic_allocator       |
         | (i.e used to implement)|                            |
         | malloc/free            |  An unsynchrnonized        |
         |                        |  version of                |
         |                        |  multipool_allocator       |
         |                        |                            |
         +------------------------+----------------------------+

</pre>
</div>

<p>
Definition 2: A memory allocator is a <span class="underline">stateful</span> utility or mechanism
that organizes a region of computer memory, dispensing and reclaiming
authorized access to suitable sub-regions on demand. 
</p>


<p>
Part 1 -  <b>Local Allocator Mechanism</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">LocalAllocator</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Internal data structures</span>
<span class="org-function-name">public</span>:
        <span class="org-function-name">LocalAllocator</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">LocalAllocator</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span>            = <span class="org-keyword">delete</span>;
        <span class="org-type">LocalAllocator</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">LocalAllocator</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">CREATORS</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Constructor: takes the regions of memory that the allocator</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">operates on. </span>
        <span class="org-function-name">LocalAllocator</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">void</span>* <span class="org-variable-name">begin</span>, <span class="org-type">void</span>* <span class="org-variable-name">end</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">MANIPULATORS</span>
        <span class="org-type">void</span>* <span class="org-function-name">aloocate</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">size_t</span> <span class="org-variable-name">nBytes</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-type">void</span> <span class="org-function-name">deallocate</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">void</span>* <span class="org-variable-name">address</span><span class="org-rainbow-delimiters-depth-2">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Local allocators only </span>
        <span class="org-type">void</span> <span class="org-function-name">release</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Part 1 - Memory Allocators Interfaces</b> - <a href="https://youtu.be/nZNd5FjSquk?t=1503">at 25:03</a>
</p>

<p>
Allcoators can be supplied for use in multiple ways: 
</p>
<ul class="org-ul">
<li>1 - As stateful utility functions. Doesn't support allocator objects.</li>
<li>2 - As "reference wrapper" template parameter.
<ul class="org-ul">
<li>Forces a client to be a template in odrder othold the allocator
reference.</li>
<li>Allocator type affects tyhe C++ type of the client object.</li>
</ul></li>
<li>3 - As the address of a pure abstract base class
<ul class="org-ul">
<li>Allocator can be held via base-class reference by a non-template
class.</li>
<li>The choice of allocator does not affect the C++ type of the
client object.</li>
<li>Object must somehow be an extra address even for default case.</li>
</ul></li>
</ul>


<p>
<b>Part 2 - Understanding the problem</b> - <a href="https://youtu.be/nZNd5FjSquk?t=1648">at 27:27</a> 
</p>

<p>
Part 2 - Our tool chest of allocation strategies - <a href="https://youtu.be/nZNd5FjSquk?t=1910">at 31:50</a>
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Label</th>
<th scope="col" class="org-left">Allocator Type</th>
<th scope="col" class="org-left">Allocator Binding</th>
<th scope="col" class="org-left">Destruction of</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Allocated Objects</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">AS1</td>
<td class="org-left">Default Gloabal Allocator</td>
<td class="org-left">Type paraemter</td>
<td class="org-left">Normal destruction</td>
</tr>

<tr>
<td class="org-left">AS2</td>
<td class="org-left">New/Delete Allocator</td>
<td class="org-left">Abstract base</td>
<td class="org-left">Normal destruction</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">AS3</td>
<td class="org-left">Monotonic</td>
<td class="org-left">Type Parameter</td>
<td class="org-left">Normal destruction</td>
</tr>

<tr>
<td class="org-left">AS4</td>
<td class="org-left">Monotonic</td>
<td class="org-left">Type Parameter</td>
<td class="org-left">(magically) "Winked Out"</td>
</tr>

<tr>
<td class="org-left">AS5</td>
<td class="org-left">Monotonic</td>
<td class="org-left">Abstract base</td>
<td class="org-left">Normal destruction</td>
</tr>

<tr>
<td class="org-left">AS6</td>
<td class="org-left">Monotonic</td>
<td class="org-left">Abstract base</td>
<td class="org-left">(magically) "Winked Out"</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">AS7</td>
<td class="org-left">Multiple</td>
<td class="org-left">Type Parameter</td>
<td class="org-left">Normal destruction</td>
</tr>

<tr>
<td class="org-left">AS8</td>
<td class="org-left">Multipool</td>
<td class="org-left">Type Parameter</td>
<td class="org-left">(magically) Winked out</td>
</tr>

<tr>
<td class="org-left">AS9</td>
<td class="org-left">Multipool</td>
<td class="org-left">Abstract Base</td>
<td class="org-left">Normal Destruction</td>
</tr>

<tr>
<td class="org-left">AS10</td>
<td class="org-left">Multipool</td>
<td class="org-left">Abstract Base</td>
<td class="org-left">(maigcally)  Winked Out</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">AS11</td>
<td class="org-left">Multipool&lt;Monotonic&gt;</td>
<td class="org-left">Type Parameter</td>
<td class="org-left">Normal Destruction</td>
</tr>

<tr>
<td class="org-left">AS12</td>
<td class="org-left">Multipool&lt;Monotonic&gt;</td>
<td class="org-left">Type Parameter</td>
<td class="org-left">(magically) "Winked Out"</td>
</tr>

<tr>
<td class="org-left">AS13</td>
<td class="org-left">Multipool&lt;Monotonic&gt;</td>
<td class="org-left">Abstract Base</td>
<td class="org-left">Normal Destruction</td>
</tr>

<tr>
<td class="org-left">AS14</td>
<td class="org-left">Multipool&lt;Monotonic&gt;</td>
<td class="org-left">Abstract Base</td>
<td class="org-left">(magically) "Winked Out</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
<b>Part 2 - AS1 - Standard Allocator std::allocator - Default Global Allocator</b>
</p>

<p>
Global default.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">no data members</span>
<span class="org-function-name">public</span>:
        <span class="org-comment-delimiter">// </span><span class="org-comment">CREATORS</span>

        <span class="org-function-name">allocator</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-function-name">allocator</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-type">allocator</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>
        ~<span class="org-function-name">allocator</span><span class="org-rainbow-delimiters-depth-2">(){</span> <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">MANIPULATORS</span>
        <span class="org-type">allocator</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">allocator</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;

        <span class="org-type">void</span>* <span class="org-function-name">allocate</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">size_t</span> <span class="org-variable-name">nBytes</span><span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> ::<span class="org-keyword">operator</span> <span class="org-keyword">new</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">nBytes</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-type">void</span> <span class="org-function-name">deallocate</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">void</span>* <span class="org-variable-name">address</span><span class="org-rainbow-delimiters-depth-2">)</span>
        <span class="org-rainbow-delimiters-depth-2">{</span>
                ::<span class="org-keyword">operator</span> <span class="org-keyword">delete</span><span class="org-rainbow-delimiters-depth-3">(</span>address<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Free operator (Free function operator function)</span>
<span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">==</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">allocator</span> <span class="org-keyword">const</span>&amp;, <span class="org-type">allocator</span> <span class="org-keyword">const</span>&amp;<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The following two versions of the same function generates the same
object code. All STL containers have an allocator type parameter that
is set to std::allocator by default. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Version 1 - With default allocator type parameter </span>
<span class="org-type">void</span> <span class="org-function-name">myFunction</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">v</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Version 2 - With explicit allocator type paraemter </span>
<span class="org-type">void</span> <span class="org-function-name">myFunction</span><span class="org-rainbow-delimiters-depth-1">(){</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-constant">std</span>::<span class="org-type">allocator</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">v</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc8b3a6e" class="outline-4">
<h4 id="orgc8b3a6e"><span class="section-number-4">1.7.2</span> Meeting C++ 20018: Andrea Weis - Taming dynamic memory - An Introduction to Custom Allocators&#xa0;&#xa0;&#xa0;<span class="tag"><span class="BMW_AG">BMW_AG</span>&#xa0;<span class="real_time">real_time</span>&#xa0;<span class="embedded">embedded</span></span></h4>
<div class="outline-text-4" id="text-1-7-2">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=R3cBbvIFqFk&amp;feature=youtu.be">Taming dynamic memory - Andreas Weis - Meeting C++ 2018 - YouTube</a></li>
</ul>

<p>
Overview: 
</p>
<ul class="org-ul">
<li>What's wrong with global new and delete?</li>
<li>Local allocators</li>
<li>Alternative allocation strategies</li>
<li>Allocator support in C++</li>
</ul>

<p>
Memory Model:  
</p>
<ul class="org-ul">
<li>My observation: The computer memory can be regarded as a giant
collection of of byte cells where every byte has an unique address.
The memory is byte-addressable.</li>
</ul>

<p>
Allocators: 
</p>

<p>
Problems with default allocator: <a href="https://youtu.be/R3cBbvIFqFk?t=290">at 4:50</a> 
</p>

<ul class="org-ul">
<li>Complex runtime behavior
<ul class="org-ul">
<li>What is the maximum memory usage?</li>
<li>What is the wors-case execution time for an allocation or deallocation?</li>
</ul></li>
<li>Shared global state
<ul class="org-ul">
<li>Reasoning about allocator behavior requires global knowledge of
the whole program.</li>
<li>The singular resource global allocator is a potential
bottleneck.</li>
</ul></li>
</ul>

<p>
<b>C++ Standard Library Memory Allocators</b>
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/memory/allocator">std::allocator - cppreference.com</a></li>

<li><a href="https://en.cppreference.com/w/cpp/memory/monotonic_buffer_resource/monotonic_buffer_resource">std::pmr::monotonic_buffer_resource::monotonic_buffer_resource - cppreference.com</a></li>

<li><a href="https://en.cppreference.com/w/cpp/memory">Dynamic memory management - cppreference.com</a></li>

<li><a href="https://en.cppreference.com/w/cpp/memory/c">C memory management library - cppreference.com</a></li>
</ul>

<p>
<b>Dynamic Memory Allocation in Embedded or Real Time Systems</b>
</p>

<p>
My observation: (<a href="https://youtu.be/R3cBbvIFqFk?t=411">at 6:51</a>) Performance is not the only problem to worry about. In
<span class="underline">real time systems</span> like car's computer notwork (CAN Network) or the
ABS - Anti Lock Braking System, a major concern is predictability as
everything in those systems must fulfill <span class="underline">real-time guarantees</span> meeting
time deadlines. This is the reason why dynamic memory allocation is
not allowed in <span class="underline">real time systems</span> or <span class="underline">embedded systems</span>.
</p>

<p>
See: 
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Anti-lock_braking_system">https://en.wikipedia.org/wiki/Anti-lock_braking_system</a></li>
<li><a href="https://www.win.tue.nl/~johanl/educ/RTcourse/RT-course-OOTIs-Introduction.pdf">Design of Real Time Software - Reinder J. Bril</a></li>
<li><a href="https://web.archive.org/web/20190127183522/https://www.win.tue.nl/~johanl/educ/RTcourse/RT-course-OOTIs-Introduction.pdf">Web Archive: Design of Real Time Software - Reinder J. Bril</a></li>
</ul>


<p>
<b>Monotonic Allocator</b> <a href="https://youtu.be/R3cBbvIFqFk?t=582">9:42</a> 
</p>

<p>
The worst and simplest memory allocator found in the C++ ISO standard. 
</p>

<p>
Intial Allocator State: 
</p>
<ul class="org-ul">
<li>The base and free pointer points to the beggining of the free
portion of the memory.</li>
</ul>

<div class="org-src-container">
<pre class="src src-text"> Memory Buffer with N-bytes: Each cell is a byte 

    | Base Pointer = AddrInit
    | Free Pointer = AddrInit                   
   \ /
  b0    b1   b2  b4   b4    b5            b[N-1]
 +----+----+----+----+----+----+          +----+
 |    |    |    |    |    |    | ... ...  |    |
 +----+----+----+----+----+----+          +----+
   |                                         |
   |                                         |
Intial memory address                  End memory address   
AddrInit                               AddEnd 
</pre>
</div>

<p>
Allocator state after memory allocation: 
</p>

<ul class="org-ul">
<li>Allocator</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Allocates 3 bytes, returning a pointer to the first byte </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">and advancing the free pointer 3 bytes.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">-------------------------------------------------</span>
<span class="org-comment-delimiter">//  </span><span class="org-comment">=&gt; free_pointer = free_pointer + 3 </span>
<span class="org-comment-delimiter">//  </span><span class="org-comment">=&gt; free_pointer = addrInit + 3 </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">p1</span> = monot.allocate<span class="org-rainbow-delimiters-depth-1">(</span>3<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; free_pointer = free_pointer + 2</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; free_pointer = addrInit + 5 </span>
<span class="org-keyword">auto</span> <span class="org-variable-name">p2</span> = monot.allocate<span class="org-rainbow-delimiters-depth-1">(</span>2<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; free_pointer = free_pointer + 4</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">=&gt; free_pointer = addrInit + 9</span>
<span class="org-keyword">auto</span> <span class="org-variable-name">p3</span> = monot.allocate<span class="org-rainbow-delimiters-depth-1">(</span>4<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>Allocator state</li>
</ul>

<div class="org-src-container">
<pre class="src src-text">   | Base Pointer = AddrInit               | Free Pointer = AddrInit                   
   |                                       | 
  \ /                                     \ /
  b0    b1   b2  b4   b4    b5   b6   b7   b8    b9  b10       b[N-1]
 +----+----+----+----+----+----+----+----+----+----+----+     +----
 | p1 | p1 | p1 | p2 | p2 | p3 | p3 | p3 | p3 |    |    | ... |    |
 +----+----+----+----+----+----+----+----+----+----+----+     +----+
   |                                                            |
   |                                                            |
Intial memory address                                   End memory address   
AddrInit                                                   AddrEnd 
</pre>
</div>

<p>
After deallocation: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">monot.deallocate<span class="org-rainbow-delimiters-depth-1">(</span>p2<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li>Allocator state after deallocation:
<ul class="org-ul">
<li>The memory allocated to p2 is released, but this memory block
cannot be reused. It is a waste of memory and it is not possible
to get the memory back. <a href="https://youtu.be/R3cBbvIFqFk?t=665">at 11:06</a></li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-text">   | Base Pointer = AddrInit               | Free Pointer = AddrInit                   
   |                                       | 
  \ /                                     \ /
  b0    b1   b2  b4   b4    b5   b6   b7   b8    b9  b10       b[N-1]
 +----+----+----+----+----+----+----+----+----+----+----+     +----
 | p1 | p1 | p1 |    |    | p3 | p3 | p3 | p3 |    |    | ... |    |
 +----+----+----+----+----+----+----+----+----+----+----+     +----+
   |                                                            |
   |                                                            |
Intial memory address                                  End memory address   
AddrInit                                                   AddrEnd 
</pre>
</div>

<p>
<b>Properties of Monotonic Allocator:</b> <a href="https://youtu.be/R3cBbvIFqFk?t=774">at 12:54</a>
</p>

<ul class="org-ul">
<li>Deterministic Runtime Cost</li>
<li>Extremely Efficient</li>
<li>No memory fragmentation - the memory block is a single memory block.</li>
<li>Easy to implement</li>
<li>Trivial to make thread-safe</li>
</ul>

<p>
But:
</p>
<ul class="org-ul">
<li>Memory can only be recalimed all at once through an explicit
release call.</li>
</ul>

<p>
<b>Where is this actually useful ?</b>
</p>

<ul class="org-ul">
<li>Frames in a video game</li>
<li>Handling of a single event in an event-driven system (such as an
web server)</li>
<li>Cyclic execution in a real-time system <a href="https://youtu.be/R3cBbvIFqFk">at 14:41</a>
<ul class="org-ul">
<li>Design patter where there is a big loop that executes a sequence
of actions. A clean state is reached after each loop iteration.</li>
</ul></li>
<li>Containers that are initialized but not changed after</li>
<li>static state - Objects will never be destroyed.</li>
</ul>

<p>
<b>C++ Memory Resources</b> 
</p>

<ul class="org-ul">
<li>std::pmr::memory_resource
<ul class="org-ul">
<li>Abstract class for all wrapped resources that can be wrapped in a
std::pmr::polymorphic_allocator.</li>
</ul></li>

<li>std::pmr::new_delete_resource()
<ul class="org-ul">
<li>Global allocator</li>
</ul></li>

<li>std::pmr::monotonic_buffer_resource
<ul class="org-ul">
<li>Monotonic Allocator</li>
</ul></li>

<li>std::pmr::unsychronized_pool_resource
<ul class="org-ul">
<li>Synchronized resource / multipool</li>
</ul></li>

<li>std::pmr::null_memory_resource()
<ul class="org-ul">
<li>Allocation always fails.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb439f36" class="outline-4">
<h4 id="orgb439f36"><span class="section-number-4">1.7.3</span> CppCon 2015: Andrei Alexandrescu "std::allocator&#x2026;"</h4>
<div class="outline-text-4" id="text-1-7-3">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=LIb3L4vKZ7U">CppCon 2015: Andrei Alexandrescu “std::allocator&#x2026;” - YouTube</a>
<ul class="org-ul">
<li>"std::allocator has an inglorious past, murky present, and
cheerless future. STL introduced allocators as a stop gap for the
now antiquated segmented memory models of the 1990s. Their design
was limited and in many ways wasn't even aiming at helping
allocation that much. Because allocators were there, they simply
continued being there, up to the point they became impossible to
either uproot or make work, in spite of valiant effort spent by
the community. But this talk aims at spending less time on poking
criticism at std::allocator and more on actually defining
allocator APIs that work. Scalable, high-performance memory
allocation is a topic of increasing importance in today's
demanding applications. For such, std::allocator simply doesn't
work. This talk discusses the full design of a memory allocator
created from first principles. It is generic, componentized, and
composable for supporting application-specific allocation
patterns."</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org1db88a6" class="outline-3">
<h3 id="org1db88a6"><span class="section-number-3">1.8</span> C++ Binary Components + ABI + Reflection</h3>
<div class="outline-text-3" id="text-1-8">
</div>
<div id="outline-container-org7d4d301" class="outline-4">
<h4 id="org7d4d301"><span class="section-number-4">1.8.1</span> CPPCON 2016 - C++14 Reflections Without Macros, Markup nor External Tooling&#xa0;&#xa0;&#xa0;<span class="tag"><span class="reflection">reflection</span>&#xa0;<span class="metaprogramming">metaprogramming</span>&#xa0;<span class="templates">templates</span></span></h4>
<div class="outline-text-4" id="text-1-8-1">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=abdeAew3gmQ">CppCon 2016: "C++14 Reflections Without Macros, Markup nor External Tooling.." - YouTube</a>
<ul class="org-ul">
<li>"C++ was lacking the reflections feature for a long time. But a
new metaprogramming trick was discovered recently: we can get
some information about POD structure by probing it's braced
initializes. Combining that trick with variadic templates,
constexpr functions, implicit conversion operators, SFINAE,
decltype and integral constants we can count structure's fields
and even deduce type of each field.  Now the best part:
everything works without any additional markup nor macros
typically needed to implement reflections in C++.  In this talk
I'll explain most of the tricks in detail, starting from a very
basic implementation that is only capable of detecting fields
count and ending up with a fully functional prototype capable of
dealing with nested PODs, const/volatile qualified pointers,
pointers-to-pointers and enum members. Highly useful use-cases
will be shown a the end of the talk. You may start experimenting
right now using the implementation at".</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb78c2da" class="outline-4">
<h4 id="orgb78c2da"><span class="section-number-4">1.8.2</span> NDC Conference - Introduction to C++ Template Metaprogramming - Sasha Goldshtein&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tmp">tmp</span>&#xa0;<span class="templates">templates</span></span></h4>
<div class="outline-text-4" id="text-1-8-2">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=lrziylOWBT4">Introduction to C++ Template Metaprogramming - Sasha Goldshtein</a>
<ul class="org-ul">
<li>"technique in modern C++. First, TMP can be used as a precursor
to C++17 Concepts, in order to check constraints and produce
clear error messages when a template parameter doesn't adhere to
its specified constraints. Second, TMP can be used to pick an
algorithm implementation based on the template type provided &#x2013;
thus enabling optimizations for specific types. Finally, TMP can
be used to introspect C++ types at compile-time and generate
compile-time constructs that save time or enable
fully-compile-time computation. In this talk, we will review a
collection of techniques and examples for using TMP in your
libraries and application code. You are expected to understand
basic template syntax and template specialisation, and we will
build the rest as we go along."</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5a11c68" class="outline-4">
<h4 id="org5a11c68"><span class="section-number-4">1.8.3</span> CppCon 2018: Victor Ciura "These Aren't the COM Objects You're Looking For"</h4>
<div class="outline-text-4" id="text-1-8-3">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=T_1zutIBHs0">CppCon 2018: Victor Ciura “These Aren't the COM Objects You're Looking For” - YouTube</a>
<ul class="org-ul">
<li>Description: "Windows COM is 25 years old. Yet it is relevant
today more than ever, because Microsoft has bet its entire
modern WinRT API on it (starting with Windows 8/10). But, if
you’re familiar with the “old” COM with its idioms and SDK
helper classes, you’re in for a treat. With the advent of modern
C++ 17, using COM objects and new Windows APIs in your
applications feels like a completely new experience. In this
session, we’ll explore how using modern C++ features can
radically transform the shape of your COM code. By eliminating a
lot of boilerplate, your code will be much more readable and
maintainable. Classic COM idioms around activation and
QueryInterface() can feel totally different with modern C++
helpers. A beautiful example of modern COM usage is C++/WinRT
(now part of Windows SDK). This is a standard C++ language
projection for the new Windows Runtime API.  COM memory
management, data marshalling, string handling can all feel quite
mechanical in nature and very error prone, so a little help from
modern C++ facilities would be more than welcomed. Error
handling and debugging can be cumbersome for COM like APIs;
we’ll explore some tricks to improve this experience, as well."</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org707e594" class="outline-4">
<h4 id="org707e594"><span class="section-number-4">1.8.4</span> BoostCon: John Bandela - Easy Binary Compatible C++ Interfaces Across Compilers</h4>
<div class="outline-text-4" id="text-1-8-4">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=BbbqBJ94-_E">John Bandela: Easy Binary Compatible C++ Interfaces Across Compilers - YouTube</a>
<ul class="org-ul">
<li>Description: C++ is often perceived as hard to use and not as
productive as other languages. One of the reasons for this is
the lack of interoperability of binary components. When using a
library, the user then either has to build from source (further
complicated by the fact that there are multiple build systems)
or the creator has to distribute multiple binaries. For example
on Windows, one may have to distribute binaries for GCC Mingw,
Visual C++ 2010 (release and debug, static and dynamic CRT),
Visual C++ 2012, etc. There have been attempts to get around
this problem. Options range from "extern C" functions, COM or
XPCOM, or language extensions such as C++/CX. The above options
either require compiler extensions or feel foreign and low-level
to someone who is used to Modern C++. With C++11 being more
consistently implemented across more compilers, one can take
advantage of features such as lambdas and variadic templates to
create easy to define, use, and implement binary interfaces that
will work across compilers.
<ul class="org-ul">
<li>This presentation will discuss the design and implementation of
a library that has the following benefits:</li>
<li>No external tools to run
<ul class="org-ul">
<li>Define an interface once and use the definition for both implementation and usage</li>
<li>Interfaces are easy to implement and use once defined</li>
<li>Use std::string, std::vector, and std::pair in the interface</li>
<li>Use real return types (not error codes)</li>
<li>Use exceptions both in implementation and usage</li>
<li>Binary compatible with COM</li>
<li>Supports interface inheritance</li>
<li>Supports implementation inheritance</li>
<li>Implementation tested on Windows with Visual C++ executable and GCC .dll</li>
<li>Implementation tested on Linux with GCC executable and Clang .so</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge2fd490" class="outline-4">
<h4 id="orge2fd490"><span class="section-number-4">1.8.5</span> BoostCon: John Bandela - CppComponents- A Modern Portable C++11 Component System</h4>
<div class="outline-text-4" id="text-1-8-5">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=a4iFJuNBx7U">CppComponents- A Modern Portable C++11 Component System - YouTube</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6da108a" class="outline-4">
<h4 id="org6da108a"><span class="section-number-4">1.8.6</span> CppCon 2017: Mathieu Ropert "API &amp; ABI Versioning"</h4>
<div class="outline-text-4" id="text-1-8-6">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=Ia3IDPjA-d0">CppCon 2017: Mathieu Ropert “API &amp; ABI Versioning&#x2026;” - YouTube</a>
<ul class="org-ul">
<li>"Software keeps changing, but not always as fast as its
clients. A key to maintaining a library in the long run is to
ensure a proper versioning of the API and ABI. Not only does this
gives a clear picture of both source and binary compatibility
between the versions, but it also helps design by making breaking
changes explicit to the developer.  In this talk I will define
API and ABI in terms of impacts on compatibility, explain the
difference between breaking and non-breaking changes and present
a few techniques to handle them.  We will quickly explain what
APIs are, with an emphasis on the notion of contracts. Then the
usually lesser known notion of ABI will be explained, going over
the concepts of call syntax, mangling and most importantly sizes,
alignment and offsets in data structures. We will see how to use
semantic versioning (semver) in C++ by considering not only
changes to the API but also to the ABI and offer some advice on
how to change API and ABI over time and how to minimize the
impacts."</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-03-06 Wed 14:29</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
