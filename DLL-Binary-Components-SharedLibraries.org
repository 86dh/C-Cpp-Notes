#+INCLUDE: theme/style.org
#+TITLE: Shared Libraries - Binary Components
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

 - [[wiki:index][Index]]

* Shared Libraries - Binary Components
** Overview 

Shared libraries are compiled object-code exporting functions, data
structures and classes which can be used by many different
programs. They provide many benefits such as: faster compilation time;
less disk space usage since each program using the library do not
need a copy of the library source code or its compiled-code; ability
to update the library and provide security fixes to client
applications without recompilation, just by replacing the library
file. 

On Windows, shared libraries are called DLLs which stands for Dynamic
Linked Libraries, on Unix-like operating systems such as Linux, BSD
and MacOSX, they are called SO - shared objects or DSO - dynamic
shared objects. 

#+CAPTION: Comparison of shared libraries across different operating systems 
| Operating | Long Name               | Short name | File          | Binary Format                         |
| System    |                         |            | Extension     |                                       |
|-----------+-------------------------+------------+---------------+---------------------------------------|
| Windows   | Dynamic Linked Library  | DLL        | .dll          | PE32/PE64 - Portable Executable       |
| Linux     | (Dynamic) Shared Object | DSO or SO  | .so           | ELF or ELF64 (for 64 bits processors) |
| BSD       | (Dynamic) Shared Object | DSO or SO  | .so           | ELF or ELF64                          |
| MacOSX    | -                       | dylib      | .dylib or .so | MachO                                 |
|-----------+-------------------------+------------+---------------+---------------------------------------|

 + Shared libraries are similar to executables, however they do not
   have the main() function entry point.

In addition to C and C++, shared libraries, containing functions with
C-linkage, can also be used as binary components (libraries) and be
consumed from higher level programming languages such as Python, Ruby,
Java or C# through some foreign-function interface. In Python
C-functions can be imported from shared libraries using the [[https://docs.python.org/3/library/ctypes.html][cytpes]]
library; in C# C-functions can be consumed using the P-invoke API and
in Java it is possible to use C-functions from shared libraries using
the JNI (Java Native Interface) or JNA, which is easier to use.


Note: 
 + Shared libraries are specific to a particular operating system and
   are not part of C++ standard.

Use Cases and advantages: 

 + Multiple programs can reuse the same library reducing disk space. 

 + Faster compilation once the shared library is compiled.

 + Changes in the library such as security fixes, updates and new
   features may not require client programs recompilation if the ABI is
   not broken.

 + _Better for security updates_. For instance, if a program is
   statically compiled with open-ssl library, a program
   recompilation would be required to update the library to a new
   version with security fixes for some vulnerability. It could even
   be a greater security problem and waste of space, if all
   application depending on open-ssl were statically liked with this
   library. If a program uses the open-sll shared library, the library
   can be updated just by replacing a file and the program it will not
   need to be recompiled as long as there are no ABI breaking changes.

 + _Plugin system_ => The main program can contain an interface class
   called IInterface and load its implementations from shared
   libraries plugins. The implementation classes provided by the
   plugins or shared library files allow the program to be updated and
   extended at runtime without recompilation.

 + _Cross language interoperability_ => Functions using C-linkage can be
   called from any high level programming language with foreign
   function interface such as Python with ctypes library. C++
   functions and classes cannot be called due to name mangling and
   compiler ABI issues. The workaround to this problem is to create a
   C-interface or functions with C-linkage for classes, functions and
   namespaces. Instances of a class can be passed around as opaque
   pointers (void*). 

Problems: 

 + Due to C++ lack of standard _ABI Application Binary Interface_,
   classes, STL containers, functions without C-linkage and namespaces
   may not be reusable with a client program compiled with different
   compiler than used to build the library. However, even in this
   case, there is still the benefit of faster compilation time if the
   shared library and the client application are part of the same
   project.
   + TL;DR => Classes, STL and functions without C-linkage of shared
     library cannot be used with a different compiler than the one
     used to build the DLL.

 + Cross-compiling interoperability - The only way to ensure that a
   shared library can work with all compilers is by using a functions
   with C-linkage (functions with extern "C") annotation and creating
   C-linkage functions wrappers to classes, STL containers and
   classes.

 + Classes can be made compatible among different compilers by using
   an interface class, a class with only pure virtual member
   functions, using only compatible types in the methods signature or
   declaration, therefore it cannot use STL container types such as
   std::string or std::vector. However, each implementation of an
   interface class can use STL containers internally. 


 *MSDN Documentation*

 + [[https://docs.microsoft.com/en-us/cpp/build/exporting-cpp-functions-for-use-in-c-language-executables?view=vs-2017][Exporting C++ Functions for Use in C-Language Executables]]

 + [[https://docs.microsoft.com/en-us/cpp/build/exporting-c-functions-for-use-in-c-or-cpp-language-executables?view=vs-2017][Exporting C Functions for Use in C or C++ Language Executables]]


 *Further Reading*

 + [[http://moppi.inside.org/demopaja/sdk_help/dll_functions.html][Creating the DLL functions]]

 + [[https://www.codeproject.com/Articles/28969/%2FArticles%2F28969%2FHowTo-Export-C-classes-from-a-DLL][HowTo: Export C++ classes from a DLL - CodeProject]]
 
 + [[http://gernotklingler.com/blog/creating-using-shared-libraries-different-compilers-different-operating-systems/][Creating and using shared libraries with different compilers on different operating systems - Gernot.Klingler]]

 + [[http://bigbang.waterlin.org/bang/using-python-ctypes-to-link-cpp-library/][The Big Bang on Reading Busy » Blog Archive » Using Python ctypes to link C/C++ library]]

** Design Guidelines for C-Interfaces 

 *Macro for C-linkage and exporting symbols*

Instead of: 

#+CAPTION: Non portable C-linkage due to compiler-specifc extension. 
#+BEGIN_SRC cpp 
   // Does not work on Unix-like OSes. 
   // Only works on compilers with supporting this MSVC (Visual VC++) compiler-extension. 
   extern "C" __declspec(dllexport)  
   double SomeFunctionWithCLinkage(const char* name) {
     ... function code ... 
   }
#+END_SRC

Better export the symbol using a macro for ensuring cross-platform
portability:  

  + Note: Names of macros should be unique in order to avoid name
    collisions. This is why the macros are prefixed with library
    name. 
  + Note: ~__declspec(dllexport)~ => MSVC (Visual C++) compiler
    extension only supported on MSVC and Mingw. (No in C++ ISO standard)
  + Note: ~__attribute__ ((visibility ("default")))~ => GCC/Clang
    compiler extension used on Unix-like Oses for making symbols
    hidden by default.

#+CAPTION: Macros for defining C-linkage and exporting symbols in a cross-platform way.
#+BEGIN_SRC cpp 
   #if defined(__cplusplus)
     // Code being compiled with C++ compiler 
     #define MATHTOOLS_EXTERN_C extern "C"
   #else 
     // Code being compiled with C compiler (Not C++ compiler)
     #define MATHTOOLS_EXTERN_C 
   #endif 

   #if defined(_WIN32)
     // MS Windows DLLs (*.dll)
     #define MATHTOOLS_EXPORT_C MATHTOOLS_EXTERN_C __declspec(dllexport)
   #else 
     // Unix-like Shared Object (.so) operating systems and GCC.
     #define MATHTOOLS_EXPORT_C MATHTOOLS_EXTERN_C __attribute__ ((visibility ("default")))
   #endif 
#+END_SRC

So, the function code becomes: 

#+CAPTION: Function with C-linkage exported with cross-platform portability.
#+BEGIN_SRC cpp 
   MATHTOOLS_EXPORT_C
   double SomeFunctionWithCLinkage(const char* name) 
   {
     ... function code ... 
   }
#+END_SRC

 *Name Prefix*

Functions with C-linkage are always in the global namespace, therefore
every function needs an unique name in order to avoid name clashing
which can result in undefined behavior. A good practice to avoid those name
collisions is to use a common prefix before in the name of every
function, for instance: 

Instead of:

#+CAPTION: Name schema prone to name clashes and undefined behavior.
#+BEGIN_SRC cpp   
  MATHTOOLS_EXPORT_C const char* GetVersion();
  MATHTOOLS_EXPORT_C double RootSolver(double x0, double (* function) double);

  // Or in multi-line style:
  MATHTOOLS_EXPORT_C 
  const char* GetVersion();

  MATHTOOLS_EXPORT_C 
  double RootSolver(double x0, double (* function) double);
#+END_SRC 

Better: 

#+CAPTION: Better name schema prefixed by library name.
#+BEGIN_SRC cpp 
  // All functions contains the library name as a prefix in order to avoid 
  // name clashes.
  MATHTOOLS_EXPORT_C const char* mathtools_GetVersion();

  MATHTOOLS_EXPORT_C 
  double mathtools_RootSolver(double x0, double (* function) double);
#+END_SRC

 *Naming Schema for C-wrapers or C-interfaces for C++ classes* 

Sample class: 

#+CATION: Class Plotter declaration;
#+BEGIN_SRC cpp 
  class Plotter{
    struct impl; 
    std::unique_ptr<impl> m_pimpl;    
  public: 
    Plotter();
    Plotter(double width, double height);
    Plotter(Plotter const& rhs) = default;
   ~Plotter() = default;

   void addPoint(double x, double y);
   void clear();
  };
#+END_SRC

C-wrappers schema: 

 + C-interface for default constructor 

#+CAPTION: C-interface for class default constructor. 
#+BEGIN_SRC cpp 
  MATHTOOLS_EXPORT_C
  Plotter* mathtools_Plotter_new() 
  {
     return new (std::nothrow) Plotter();
  }
#+END_SRC


 + C-interface or C-Wrapepr for second constructor: 

#+CAPTION: C-interface for class overload constructor. 
#+BEGIN_SRC cpp
  MATHTOOLS_EXPORT_C
  Plotter* mathtools_Plotter_new2(double width, double height) 
  {
     return new (std::nothrow) Plotter(width, height);
  }
#+END_SRC

 + C-interface for copy constructor: 

#+CAPTION: C-interface for class copy constructor. 
#+BEGIN_SRC cpp 
  // Wrapper for copy constructor 
  MATHTOOLS_EXPORT_C
  Plotter* mathtools_Plotter_new_copy(Plotter* hPlotter) 
  {
     return new (std::nothrow) Plotter(*hPlotter);
  }
#+END_SRC

 + C-interface for destructor:

#+CAPTION: C-interface for class destructor.
#+BEGIN_SRC cpp 
  MATHTOOLS_EXPORT_C
  void mathtools_Plotter_delete(Plotter* hPlotter) 
  {
    delete hPlotter;
  }
#+END_SRC

 + C-interface for class method.
   + As C-interfaces cannot throw exceptions, the last parameter is
     used for returning an error code.

#+CAPTION: C-interface for class ordinary method.
#+BEGIN_SRC cpp 
  // Schema: <Library Name>_<Class Name>_<method>
  MATHTOOLS_EXPORT_C
  void mathtools_Plotter_addPoint(Plotter* hPlotter, double x, double y)
  {
     hPlotter->addPoint(x, y);
  }
#+END_SRC

 *Exceptions and Error Handling* 

 + DO NOT: Throw exceptions in functions with C-linkage (extern "C")
   as exceptions are incompatibles among different compilers. Moreover, the
   C-language cannot handle exceptions.

 + DO: Instead of exceptions, return an error code enumeration as a
   function return value or as function parameter.

Example: If a function throws exceptions such as the function
~mathtools_Plotter_addPoint~, the exceptions should be caught and the
function should return an error code eihter as return value or
function parameter.

#+CAPTION: Error handling for C-interface functions or C-APIs
#+BEGIN_SRC cpp 
  MATHTOOLS_EXPORT_C
  void mathtools_Plotter_addPoint(Plotter* hPlotter, double x, double y, int* ErrorCode)
  {
      ,*ErrorCode = ErrorEnum::OK;
      try { 
         // Method addPoint throws exceptions 
         hPlotter->addPoint(x, y);
      } catch(Exception1 const& ex){
         ,*ErrorCode = ErrorEnum::NO_SPACE_ERROR; // Set with value of some enum 
      } catch(Exception2 const& ex){
         ,*ErrorCode = ErrorEnum::SOME_ERROR_ENUM;
     }
  }
#+END_SRC

 *Passing std::string STL Object across a DLL boundary*

Type synonym:

#+BEGIN_SRC cpp 
  // h prefix stands for handle 
  using hString = std::string*;
#+END_SRC

C-interface for std::string default constructor.

#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C  
  hString libprefix_string_new()
  {
     // std::nothrow => Do not throw std::bad_alloc, just return 
     // a null pointer on failure.
     return new (std::nothrow) std::string();   
  }
#+END_SRC

C-interface for std::string copy-constructor. 

#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C  
  hString libprefix_string_new_copy(hString hstr)
  {
     // std::nothrow => Do not throw std::bad_alloc, just return 
     // a null pointer on failure.
     return new (std::nothrow) std::string(*hstr);   
  }
#+END_SRC

C-interface for std::string overloaded constructor.

#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C  
  hString libprefix_string_new2(const char* text)
  {
     return new (std::nothrow) std::string(text);   
  }
#+END_SRC

C-interface for std::string destructor.

#+BEGIN_SRC cpp 
  // Style 1: 
  LIBRARY_EXPORT_C 
  hString libprefix_string_delete(hString hstr)
  {
     delete hstr;
  }

  // Style 2: 
  LIBRARY_EXPORT_C hString 
  libprefix_string_delete(hString hstr)
  {
     delete hstr;
  }

  // Style 3: 
  LIBRARY_EXPORT_C 
  hString 
  libprefix_string_delete(hString hstr)
  {
     delete hstr;
  }

  // Style 4: Trailing return-type.
  LIBRARY_EXPORT_C 
  auto libprefix_string_delete(hString hstr) -> hString 
  {
     delete hstr;
  }
#+END_SRC

C-interface for std::string getter, returns const char*.


#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C 
  const char*
  libprefix_string_get(hString hstr)
  {
     return hstr->data();
  }
#+END_SRC

C-interface for std::string setter.

#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C 
  void 
  libprefix_string_set(hString hstr, const char* text)
  {
     *hstr = text; 
  }
#+END_SRC

C-interface for std::string concat.

#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C 
  void 
  libprefix_string_conat(hString hstr, const char* text)
  {
     *hstr = *hstr + text; 
  }
#+END_SRC

C-function to print std::string object 

#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C 
  void 
  libprefix_string_print(hString hstr)
  {
     std::cout << *hstr << "\n";
  }
#+END_SRC

C-wrapper to method std::string::clear()

#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C 
  void 
  libprefix_string_clear(hString hstr)
  {
     hstr->clear();
  }
#+END_SRC

 *Passing std::vector<double> across a DLL boundary*

Handle type: 

#+BEGIN_SRC cpp 
  using hVectorD = std::vector<double>*;
#+END_SRC

Constructors: 

#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C 
  hVectorD libprefix_vectorD_new()
  {
    return new (std::nothrow) std::vector<double>();
  }

  LIBRARY_EXPORT_C 
  hVectorD libprefix_vectorD_new2(size_t n, double x)
  {
    return new (std::nothrow) std::vector<double>(n, x);
  }

  LIBRARY_EXPORT_C 
  hVectorD libprefix_vectorD_new3(size_t n, double [] array)
  {
    // Iterator-range constructor 
    return new (std::nothrow) std::vector<double>(array, array + n);
  }
#+END_SRC

Destructor: 

#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C 
  void libprefix_vectorD_delete(hVectorD hvec)
  {
    delete hvec;
  }
#+END_SRC

Get size: 

#+BEGIN_SRC cpp
  LIBRARY_EXPORT_C 
  size_t libprefix_vectorD_size(hVectorD hvec)
  {
    hvec->size();
  }
#+END_SRC

Getter: 

#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C 
  double libprefix_vectorD_get(hVectorD hvec, size_t n)
  {
    return hvec->operator[](n);
  }
#+END_SRC

Setter: 

#+BEGIN_SRC cpp 
  LIBRARY_EXPORT_C 
  void libprefix_vectorD_set(hVectorD hvec, size_t n, double x)
  {
    hvec->operator[](n) = x;
  }
#+END_SRC

Element-wise fundamental math function 'sin()': 

#+BEGIN_SRC cpp 
  // Returns a new vector Out[i],  Out[i] = sin(Input[i]), i = 0, 1, 2... Input.size() 
  LIBRARY_EXPORT_C 
  hVector libprefix_vectorD_sin(hVectorD hvec)
  {
     auto result = new (std::nothrow) std::vector<double>(hvec->size());
     for(size_t i = 0; i <= hvec->size(); i++)
       (*result)[i] = std::sin((*hvec)[i]);
     return result;
  }

  // Returns a new vector Out[i],  Out[i] = exp(Input[i]), i = 0, 1, 2... Input.size() 
  LIBRARY_EXPORT_C 
  hVector libprefix_vectorD_exp(hVectorD hvec)
  {
     auto result = new (std::nothrow) std::vector<double> (hvec->size());
     for(size_t i = 0; i <= hvec->size(); i++)
       (*result)[i] = std::exp((*hvec)[i]);
     return result;
  }
#+END_SRC

Higher order C-function to apply a function to each element: 

#+BEGIN_SRC cpp 
  // Returns a new vector Out[i],  Out[i] = exp(Input[i]), i = 0, 1, 2... Input.size() 
  LIBRARY_EXPORT_C 
  hVector 
  libprefix_vectorD_map( 
               hVectorD hvec              /* Vector handle */
              ,double Function (double))  /* Function pointer to math function */                                      
  {
     auto result = new (std::nothrow) std::vector<double>(hvec->size());
     for(size_t i = 0; i <= hvec->size(); i++)
       (*result)[i] = Function((*hvec)[i]);
     return result;
  }
#+END_SRC


 *See also:*

 + [[https://stackoverflow.com/questions/22797418/how-do-i-safely-pass-objects-especially-stl-objects-to-and-from-a-dll][c++ - How do I safely pass objects, especially STL objects, to and from a DLL? - Stack Overflow]]

** Cross platform Shared Library, C-Interfaces and Language Interoperability
*** Overview 

 *Source:*

Shared library Source Code

 + File: [[file:src/dlls/example-windows1/testlib.cpp][file:src/dlls/example-windows1/testlib.cpp]]
 + File: [[file:src/dlls/example-windows1/testlib.hpp][file:src/dlls/example-windows1/testlib.hpp]]

Sample Client C++ Program:

 + File: [[file:src/dlls/example-windows1/client1.cpp][file:src/dlls/example-windows1/client1.cpp]]  

Sample Python 3 Client code: (Python3 module wrapper library)

 + File: [[file:src/dlls/example-windows1/testlib.py][file:src/dlls/example-windows1/testlib.py]]

GIST - Better for online view: 

 + [[https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71][Gisthub]]

 *Compile the DLL libtest.dll and client program with MSVC* 

Shared Library 

#+BEGIN_SRC cpp 
 $ cl.exe testlib.cpp /EHsc /LD /nologo user32.lib
#+END_SRC

C++ Client program (client code)

#+BEGIN_SRC cpp 
 $ cl.exe /EHsc client1.cpp /Fe:client1.exe testlib.lib && out.exe
#+END_SRC

 *Compile the DLL libtest.dll and client program with Mingw/GCC* 

Shared Library 

#+BEGIN_SRC cpp 
 $ g++ testlib.cpp -o testlib.dll -g -fvisibility=hidden -shared -std=c++14 -Wall
#+END_SRC

C++ Client program 

#+BEGIN_SRC cpp 
 $ g++ client.cpp -o client.exe -g -std=c++14 testlib.dll -Wall
#+END_SRC

 *Compile and run from GIST* 

Clone the GIST ([[https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71][Gisthub]]).

#+BEGIN_SRC sh 
  # Clone GIST: 
  $ git clone https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71 dllex1
  Cloning into 'dllex1'...
  remote: Enumerating objects: 66, done.
  remote: Counting objects: 100% (66/66), done.
  remote: Compressing objects: 100% (47/47), done.
  remote: Total 66 (delta 36), reused 45 (delta 19), pack-reused 0
  Unpacking objects: 100% (66/66), done.

  # Enter directory containing sources
  $ cd dllex1/

  $ tree .
  .
  ├── build.bat
  ├── client1.cpp
  ├── CMakeLists.txt
  ├── Makefile
  ├── pywrapper.py
  ├── testlib.cpp
  └── testlib.hpp

  0 directories, 7 files

#+END_SRC

Build shared library on Linux.

 + For Linux, build DLL and client code with make linux.

#+BEGIN_SRC sh 
   $ make linux
   echo "Build shared library"
   Build shared library
   g++ testlib.cpp -o libtestlib.so  -std=c++14 -fPIC -shared -Wall
   echo "Build client code 1"
   Build client code 1
   g++ client1.cpp -o client1.bin -std=c++14 libtestlib.so 

   $ file libtestlib.so 
   libtestlib.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), 
   dynamically linked, BuildID[sha1]=52a16d16991d7aa71763140e97a1422c1387711d, not stripped

   $ file client1.bin 
   client1.bin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, 
   interpreter /lib64/ld-linux-x86-64.so.2, 
   for GNU/Linux 3.2.0, BuildID[sha1]=1a4885e112f72372cfd66816a564f49a24110c50, not stripped

#+END_SRC

Build shared library on Windows: 
  
 + Just run the batch script build-windows.bat or double click at it.

#+BEGIN_SRC bat 
  $ build-windows.bat
  **********************************************************************
  ** Visual Studio 2017 Developer Command Prompt v15.5.6
  ** Copyright (c) 2017 Microsoft Corporation
  **********************************************************************
  [vcvarsall.bat] Environment initialized for: 'x64'
  testlib.cpp
     Creating library testlib.lib and object testlib.exp
  Microsoft (R) C/C++ Optimizing Compiler Version 19.12.25835 for x64
  Copyright (C) Microsoft Corporation.  All rights reserved.

  client1.cpp
  Microsoft (R) Incremental Linker Version 14.12.25835.0
  Copyright (C) Microsoft Corporation.  All rights reserved.

  /out:client1.exe
  client1.obj
  testlib.lib
     Creating library client1.lib and object client1.exp
   [StaticObject] => Initialize DLL
  testlib.cpp:48: <DllMain> DLL Loaded into the process => PID = 1240
  testlib.cpp:54: <DllMain> DLL attached to process.

  === EXPERIMENT 1 ===> Import C++ functions from DLL
  client1.cpp:38: <main> Main process starts here.
   => Linalg::norm(xs) 7.4162
  => xs = [5]( 1, 2, 3, 4, 5,  )
  === EXPERIMENT 2 ===> Import class from DLL
   Instance created with name = Dummy

   .. ... ...  .. ... ...  .. ... ...  .. ... ... 
#+END_SRC


Run C++ client code:

#+BEGIN_SRC sh 
  $ ./client1.bin 
   [StaticObject] => Initialize DLL

  === EXPERIMENT 1 ===> Import C++ functions from DLL
  client1.cpp:38: <main> Main process starts here.
   => Linalg::norm(xs) 7.4162
  => xs = [5]( 1, 2, 3, 4, 5,  )
  === EXPERIMENT 2 ===> Import class from DLL
   Instance created with name = Dummy
   Counter set to value = 100
  cls.getName() = Dummy
      cls.get() = 100

  ... ... ... 
#+END_SRC

Run Python client code:

#+BEGIN_SRC cpp 
  $ make py
  python3 pywrapper.py
   [INFO] libpath = libtestlib.so
   [StaticObject] => Initialize DLL
  Intializing library
  Library initialized OK.

   .. ... ... ... 
#+END_SRC

*** Header macros 

Sources:
 + File: [[file:src/dlls/example-windows1/testlib.cpp][file:src/dlls/example-windows1/testlib.cpp]]
 + File: [[file:src/dlls/example-windows1/testlib.hpp][file:src/dlls/example-windows1/testlib.hpp]]

 *teslib.hpp / Heade File - Macros*

The header files uses the following macros to reduce the boilerplate
necessary to export the library functions and classes. 

 + file: testlib.hpp => Macros for exporting functions and classes. 


 *Macro: EXPORT_CPP*

#+BEGIN_SRC cpp 
  /** Macro EXPORT_CPP makes a symbol visible. */
  #if defined(_WIN32)
    #define EXPORT_CPP __declspec(dllexport)
  #else
    #define EXPORT_CPP __attribute__ ((visibility ("default")))
    // If not compiled on Windows, remove declspec compiler extension.
    #ifndef __declspec
      // For GCC only - make exported symbol visible symbol 
      #define __declspec(param) __attribute__ ((visibility ("default")))
    #endif
  #endif 
#+END_SRC

The macro EXPORT_CPP annotates the symbol as visible by expanding to:

#+BEGIN_SRC cpp 
    // On Windows EXPORT_CPP becomes 
    __declspec(dllexport)

    // On Unix-like OSes, Linux, BSD, OSX ... 
     __attribute__ ((visibility ("default")))
#+END_SRC

So a function _int SomeFunction(double x, double y)_ becomes:

#+BEGIN_SRC cpp 
    // Makes this symbol visible (exported) in the library (DLL)
    EXPORT_CPP int SomeFunction(double , double);

   // On Windows: 
   __declspec(dllexport) int SomeFunction(double , double);

   // On Unix-like operating systems or Linux: 
   __attribute__ ((visibility ("default"))) int SomeFunction(double , double);
#+END_SRC


 *Macro EXPORT_C:*

#+BEGIN_SRC cpp 
  /* Macro EXPORT_C is used for exporting symbol with C-linkage, it
   ,* means, without name mangling */
  #ifdef __cplusplus
    // extern "C" - Indicates that a given symbol/function has C-linkage and
    // does not have name mangling.
    // 
    // On Linux EXPORT_C becomes
    //  => extern "C" __attribute__ ((visibility ("default")))
    // 
    // On Windows EXPORT_C becomes 
    //  => extern "C" __declspec(dllexport)
    #define EXPORT_C extern "C" EXPORT_CPP
  #else
    // If a C-compiler uses this header, remove 'extern "C"'
    #define EXPORT_C  EXPORT_CPP
  #endif 
#+END_SRC

Export symbols with C-linkage, it means that the function is exported
without name decoration or _name mangling_. The function symbol matches
exactly its name. Functions with C-linkage can be called by C-code;
C++ code compiled with other compilers without ABI issues and foreign
function interfaces of scripting languages such as Python Ctypes or C#
Pinvoke. Note: If a function is defined with C-linkage, it can only use
C-compatible types. So, it is no possible to define functions with
C-linkage with overload, default parameter or non C-compatible
arguments.

 + On Windows, this macro is expanded to:

#+BEGIN_SRC cpp 
   EXPORT_C int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);

   // On Windows it becomes: 
   extern "C" __declspec(dllexport)  int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);

   // This function could also be declared as:
   extern "C" __declspec(dllexport) 
   int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);
#+END_SRC

 + On Unix-like OSes or linux, the macro EXPORT_C expands to: 

#+BEGIN_SRC cpp 
   EXPORT_C int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);

   // On Linux, it becomes:
   extern "C" __attribute__ ((visibility ("default"))) int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);

   // This function could also be declared as:
   extern "C" __attribute__ ((visibility ("default"))) 
   int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);
#+END_SRC

On Unix-like operating system (GCC or Clang compilers), all
functions in an object-code (aka compiled code) becomes visible by
default what can lead to undefined behavior when there are name
clashes due to repeated symbols. With appropriate compiler options
such as -fvisibility=hidden, the symbols can be made private by
default as happens in Windows where is necessary to annotate the
symbol as visible explicitly with __declspec(dllexport). On Unix-like
OSes for GCC and Clang compiler the annotation for making the symbol
visible is ~__attribute__ ((visibility ("default")))~. This statement
has no effect if the appropriate compiler flags are not set.

*** Namespace Linalg 

 *Functions of Namespace Linalg* 

Namespace containing sample linear algebra functions, the function norm
computes an Euclidean norm of a N-dimension vector, the function
linTransform computes a linear transformation performing the
computation v[i] * a + b for each vector element. 

On Windows, all DLL symbols, such as functions, variables and clases,
are private by default, they are not exported by default as happens in
Unix-like OSes shared libraries. Therefore, in order to a function be
exported in a Windows shared library, it is necessary to use the MSVC or visual C++
compiler extension ~__declspec(dllexport)~ before the function declaration.
 
 + Interface => File: *testlib.hpp*

#+BEGIN_SRC cpp 
   #ifdef __cplusplus

   namespace Linalg {
           EXPORT_CPP
           double norm(const std::vector<double>& xs);

           EXPORT_CPP std::vector<double>
           linTransform(
                   double a,
                   double b,
                   std::vector<double>& xs
                   );

           EXPORT_CPP
           std::ostream&
           printVector(std::ostream& os, std::vector<double>& xs);	
   }
   #endif 
#+END_SRC

The compiler directives *#ifdef __cplusplus ... #endif* are used for
disabling this code block when the header is used by a C-compiler as
the C-language does not support classes, namespaces and many other C++
features. 

 + file: *testlib.cpp* - Implementation 

#+BEGIN_SRC cpp 
   // Linear algebra tools 
    namespace Linalg{
            EXPORT_CPP 
             double norm(const std::vector<double>& xs){
                   double sum = 0.0;
                   for(const auto& x : xs) sum += x * x;
                   return std::sqrt(sum);
           }

           EXPORT_CPP
           std::vector<double>
           linTransform(double a, double b, std::vector<double>& xs){
                   std::vector<double> out(xs.size());
                   for(size_t i = 0; i < xs.size(); i++){		
                           out[i] = a * xs[i] + b;
                   }
                   return out;
           }

           EXPORT_CPP
           std::ostream&
           printVector(std::ostream& os, std::vector<double>& xs){
                   os << "[" << xs.size() << "]( ";
                   for(const auto&  x: xs)
                           os << x << ", ";
                   return os << " )";
           }	
   }
#+END_SRC

*** C-interface of Namespace Linalg 

 *C-interface of Namespace Linalg* 

A C-interface is necessary for ensuring that the DLL can be called
from a C-program or a foreign function interface of a higher level
language. 

 + File: *testlib.hpp* => Function declaration. 

#+BEGIN_SRC cpp 
  // ======= C-interface for Linalg namespace =========//

  /** Handle or opaque pointer for std::vector<double> */
  typedef void* hVectorD;

  /* ----- C-Wrappers for Linalg namespace ---- */

  EXPORT_C 
  double testlib_vectorD_Linalg_norm(hVectorD hv);

  EXPORT_C 
  void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv);

#+END_SRC

 + File: *testlib.cpp* => C-interface function implementations. 

The type synonym hVectorD is handle or a opaque poiter for the type
std::vector<double>. It is a workaround, to pass std::vector<double>
accross a DLL functions with C-linkage and use std::vector<double>
from C programs or foreign function interfaces. 

#+BEGIN_SRC cpp 
  //=========== C-wrappers ---------------///
  // Handler for double vector 
  using hVectorD = void*;
  using pVectorD = std::vector<double>*;

  /** C-wrapper for vector<double> constructor */
  EXPORT_C  
  hVectorD testlib_vectorD_make0(size_t n, double x){
      return new std::vector<double>(n, x);
  }

  /** C-wrapper for range constructor */
  EXPORT_C
  hVectorD testlib_vectorD_make1(size_t n, double array []){
      return new std::vector<double>(array, array + n);
  }

  /** C-wrapper for setting elements of vector<double> */
  EXPORT_C 
  void testlib_vectorD_set(hVectorD hv, size_t n, double x){
     reinterpret_cast<pVectorD>(hv)->operator[](n) = x;
  }

  /** C-wrapper for vector<double> destructor */
  EXPORT_C void testlib_vectorD_delete(hVectorD hv){
      delete reinterpret_cast<pVectorD>(hv);
  }

  /** C-wrapepr for Linalg::norm function */
  EXPORT_C 
  double testlib_vectorD_Linalg_norm(hVectorD hv){
      return Linalg::norm(*reinterpret_cast<pVectorD>(hv));
  }

  EXPORT_C 
  void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv){
      std::cout << name << " = ";
      Linalg::printVector(std::cout, *reinterpret_cast<pVectorD>(hv));
      std::cout << std::endl;
  }
#+END_SRC

*** Non-polymorphic Class - SampleClass 

  + File: *testlib.hpp* => Class declaration. 

In order to a class be exported in a Windows' shared library, it
requires the annotation ~__declspec(dllexport)~.

Note: It will not be possible to compiled client program using this
class with a compiler different from the used to build the shared
library libtest.dll. It happens because, the C++ ABI - Application
Binary Interface is not the same accross different compilers. If the
DLL is compiled with MSVC, the only way to use this class from a
program compiled using MingW or even a different version of MSVC is
by using a C-interface (functions with C-linkage) and opaque
pointers (void* pointers). 

#+BEGIN_SRC cpp 
  // ======= Non-polymorphic class exported by DLL =========//

  #ifdef __cplusplus
  // Non-polymorphic class 
  class EXPORT_CPP SampleClass{
  public:
          SampleClass();
          SampleClass(const std::string& name);	
          ~SampleClass();
          std::string getName() const;
          int get();
          void set(int n);	
  private:
          std::string m_name;
          int m_counter;	
  };
  #endif 
#+END_SRC


 + File: *testlib.cpp* => Class implementation. 

#+BEGIN_SRC cpp 
  SampleClass::SampleClass(const std::string& name)
     : m_name(name), m_counter(0)
  {
      std::cout << " Instance created with name = " << m_name << std::endl;
  }
  /** Delegated constructor on right-hand-side */
  SampleClass::SampleClass(): SampleClass("unnamed"){}   
	
  SampleClass::~SampleClass(){
      std::string text = std::string("SampleClass => name = ") + m_name +  " deleted";
      DbgTrace(text);
  }

  std::string SampleClass::getName() const {
      return m_name;
  }
  int SampleClass::SampleClass::get(){		
      return m_counter;
  }
  void SampleClass::set(int n){
      std::cout << " Counter set to value = " << n << std::endl;
      m_counter = n;
  }	
#+END_SRC

*** C-interface for SampleClass

 + File: *testlib.hpp* => Functions declarations. 

#+BEGIN_SRC cpp 
  /* ----- C-Wrappers for SampleClass namespace ---- */
  using hSampleClass = void*;

  /** Nullable constructor zero-arg constructor */
  extern "C" __declspec(dllexport)
  hSampleClass
  testlib_SampleClass_make0();

  /** Other constructor */
  EXPORT_C hSampleClass testlib_SampleClass_make1(const char* name);

  /** Destructor */
  EXPORT_C
  void
  testlib_SampleClass_delete(hSampleClass hnd);

  /** Wrapper for get method */
  EXPORT_C
  int
  testlib_SampleClass_get(hSampleClass hnd);

  /** Wrapper for set method */
  EXPORT_C
  void
  testlib_SampleClass_set(hSampleClass hnd, int n);

  EXPORT_C
  const char*
  testlib_SampleClass_getName(hSampleClass hnd);

#+END_SRC

 + File: *testlib.cpp* => Functions implementation. 

#+BEGIN_SRC cpp 
  /* ----- C-Wrappers for SampleClass namespace ---- */

  using hSampleClass = void*;

  /** Nullable constructor zero-arg constructor */
  EXPORT_C 
  hSampleClass
  testlib_SampleClass_make0();

  /** Other constructor */
  EXPORT_C hSampleClass testlib_SampleClass_make1(const char* name);

  /** Destructor */
  EXPORT_C
  void
  testlib_SampleClass_delete(hSampleClass hnd);

  /** Wrapper for get method */
  EXPORT_C
  int
  testlib_SampleClass_get(hSampleClass hnd);

  /** Wrapper for set method */
  EXPORT_C
  void
  testlib_SampleClass_set(hSampleClass hnd, int n);

  EXPORT_C
  const char*
  testlib_SampleClass_getName(hSampleClass hnd);

#+END_SRC

*** Polymorphic class InterfaceClass 

 + File: *testlib.hpp* => Class declaration. 

As the name implies, this class is an interface class, which is a
class containing only pure virtual functions (abstract methods). As a
result, it is declared only in the header file and cannot be
instatiated directly. 

This class uses only C-types to be binary compatible with different
compilers, if it used STL containers such as string or any other
non-compatible C-type, it would not be possible to compile a C++
program using Mingw/GCC against this DLL built with MSVC.

#+BEGIN_SRC cpp 
  // Polymorphic Interface class binary compatible across different
  // compilers as it does not use any STL container on the interface.
  #ifdef __cplusplus
  struct InterfaceClass{
          /* Returns class unique ID */
          virtual const char* getID()	const = 0;
          /** Set class internal state */
          virtual void setName(const char* name) = 0;
          virtual const char* getName() = 0;

          /** Virtual constructor */
          virtual ~InterfaceClass() = default;
          // virtual ~InterfaceClass();
  };
  #else
    #define InterfaceClass void 
  #endif 
#+END_SRC

 + File: *testlib.cpp* => class ImplementationA of interface InterfaceClass. 

#+BEGIN_SRC cpp 
  class ImplementationA: public InterfaceClass
  {
  private:
      std::string m_name;
  public:
      static constexpr const char* class_id = "ImplementationA";

      ImplementationA(): m_name("Unammed-A"){ }
      ImplementationA(const std::string& name)
         : m_name(name){}	
      ~ImplementationA(){
           std::cout << " [INFO] ImplementationA deleted => name = "
                     << m_name
                     << " ; type = " << class_id
                     << std::endl;
      }
      const char* getID() const {		
          return class_id;
      }
      void setName(const char* name) {
          m_name = name;
      }
      const char* getName() {
          return m_name.c_str();
      }
  };
#+END_SRC

 + File: *testlib.cpp* => class ImplementationB of interface InterfaceClass. 

#+BEGIN_SRC cpp 
  class ImplementationB: public InterfaceClass
  {
  private:
      std::string m_name;
  public:
      static constexpr const char* class_id = "ImplementationB";

      ImplementationB(): m_name("Unammed-B"){ }
      ImplementationB(const std::string& name)
         : m_name(name){}	
      ~ImplementationB(){
          std::cout << " [INFO] ImplementationB deleted => name = "
                    << m_name
                    << " ; type = " << class_id
                    << std::endl;
      }
      const char* getID() const {		
              return class_id;
      }
      void setName(const char* name) {
              m_name = name;
      }
      const char* getName() {
              return m_name.c_str();
      }
  };

#+END_SRC

 + File: *testlib.hpp* => C-interface and factory function to load
   implementations from the DLL.

#+BEGIN_SRC cpp 
  /** Factory function */
  EXPORT_C InterfaceClass* teslib_InterfaceClass_factory(const char* class_id);

  /** C-wrapper for destructor */
  EXPORT_C void testlib_InterfaceClass_delete(InterfaceClass* hinst);

  /** C-wrapper for getID method */
  EXPORT_C const char* testlib_InterfaceClass_getID(InterfaceClass* hinst);

  EXPORT_C void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name);

  EXPORT_C const char* testlib_InterfaceClass_getName(InterfaceClass* hinst);
#+END_SRC

 + File: *testlib.cpp* => C-interfaces and factory functions
   definitions.

#+BEGIN_SRC cpp 
  EXPORT_C InterfaceClass*
  teslib_InterfaceClass_factory(const char* class_id)
  {
      auto s = std::string(class_id);
      if(s == "ImplementationA")
              return new ImplementationA();
      if(s == "ImplementationB")
              return new ImplementationB();
      return nullptr;
  }

  EXPORT_C void testlib_InterfaceClass_delete(InterfaceClass* hinst)
  {
      delete hinst;
  }
  EXPORT_C
  const char* testlib_InterfaceClass_getID(InterfaceClass* hinst)
  {
      return hinst->getID();
  }
  EXPORT_C
  void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name)
  {
      hinst->setName(name);
  }
  EXPORT_C
  const char* testlib_InterfaceClass_getName(InterfaceClass* hinst){
      return hinst->getName();
  }
#+END_SRC
*** DLL startup function DLLMain 

When a Windows shared library is loaded at compile-time or at runtime
by some process, the function DLLMain is always invoked, it is similar
to the function main() from an executable. 

Note: logging statements with printf, std::cout, std::cerr will not
printed if the DLL is loaded by some non-console program, a program
compiled to the _window subsystem_. Therefore, the easiest way to log is
to use the OutputDebugString function which output can viewed by the
DebugView sysinternal tool. 


 + File: *testlib.cpp* => DLL main function. 

#+BEGIN_SRC cpp 
   /** - DLL Entry point - main function of DLL which is executed when 
       the DLL is loaded by some process. 
    */
   #if defined(_WIN32)
   extern "C" __declspec(dllexport)
   BOOL APIENTRY DllMain (HINSTANCE hInst, DWORD reason, LPVOID lpReserved)
   {
       std::string text =
               std::string("DLL Loaded into the process => PID = ")
               + std::to_string(::GetCurrentProcessId());
       WindbgTrace(text);
       DbgTrace(text);

       switch (reason)
       {
       case DLL_PROCESS_ATTACH:
           WindbgTrace("DLL attached to process");
           DbgTrace("DLL attached to process.");			
         break;
       case DLL_PROCESS_DETACH:
            WindbgTrace("=> DLL detached.");
            DbgTrace("=> DLL attached");
         break;
       case DLL_THREAD_ATTACH:
           WindbgTrace("DLL attached to thread");
           DbgTrace("DLL detached to thread.");
         break;
       case DLL_THREAD_DETACH:
           WindbgTrace("DLL detached from thread");
           DbgTrace("DLL detached from thread.");
         break;
       }

     return TRUE;
   }
   #endif 
#+END_SRC


Another more portable way to peform some way action when the DLL is
loaded by a process or unloaded is to use a static object. The startup
task is executed int the object's constructor and the finalization
task, which happens when the process ends, is executed at object's
destructor. This approach may a better replacement for DLLMain
function, which is specific for Windows, as this technique works both
on Windows and any other Unix-like operating system. 

 + File: *testlib.cpp* => Static Object for replacing DLLMain 

The class _StaticObject and a static instance of it is defined within
an anonymous namespace to make them private to the compilation unit
testlib.cpp and not allow them to be used from anywhere else. 

#+BEGIN_SRC cpp 
  // Class private to this compilation unit - cannot be accessed from
  // any other file
  namespace {
     class _StaticObject{		
     public:
         using Action = std::function<void ()>;
         Action m_end;

         _StaticObject(Action init, Action end)
                 :  m_end(end)
         {
                 init();
         }
         ~_StaticObject(){ m_end(); }
     };

     // Static object for replacing DLLMain 
     auto initDLL = _StaticObject(
        []{
              std::cout << " [StaticObject] => Initialize DLL"
                         << std::endl;						
        },
        []{	
             std::cout << " [StaticObject] => Shutdown DLL"
                       << std::endl;								
        });
  }
#+END_SRC
*** DLL entry point for run32dll.exe 

This function is a DLL entry point for the Windows program
rundll32.exe which can execute this function with: 

#+BEGIN_SRC cpp 
 $ rundll32.exe testlib.dll,entryPoint1
 $ rundll32.exe testlib.dll,entryPoint1 arg0 arg1 arg2 ... argn 
#+END_SRC

When the DLL testlib.dll is run with run32dll calling the function
entryPoint1, it will display a message box. 

Note: It is an optional function which could be used for installing
the DLL in the system or creating some entry in Windows' registry. 

 + File: *testlib.cpp*

#+BEGIN_SRC cpp 
  #if defined(_WIN32)
  extern "C" __declspec(dllexport)
  void entryPoint1(HWND hwn, HINSTANCE hinst, LPSTR cmdLine, int nCmdShow){  
       DbgDisp(cmdLine);
       OutputDebugString("Rudll32 called entryPoint1()");
       MessageBoxA(NULL, "DLL ENTRY POINT", "Entry point 1", 0);
  }
  #endif 
#+END_SRC
*** C++ Client program - client1.cpp 

 + File: [[file:src/dlls/example-windows1/client1.cpp][file:src/dlls/example-windows1/client1.cpp]]  

 *File client1.cpp*

Includes: 

 + Note: (#include "testlib.hpp") a header file between quotes,
   indicates to the compiler that the header is in the same directory
   as the source file client1.cpp.

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <ostream>
  #include <vector>
  #include <string>

  #include "testlib.hpp"
#+END_SRC

Declaration of functions with C-linkages not declarated in the header
testlib.hpp

#+BEGIN_SRC cpp 
  extern "C" hVectorD testlib_vectorD_make0(size_t n, double);
  extern "C" hVectorD testlib_vectorD_make1(size_t n, double array []);
  extern "C" void testlib_vectorD_delete(hVectorD hv);
#+END_SRC

Main function - Experiment 1 and Experiment 2:

#+BEGIN_SRC cpp 
  #ifndef DISABLE
  std::cout << "\n=== EXPERIMENT 1 ===> Import C++ functions from DLL" << std::endl;

  DbgTrace("Main process starts here.");
  std::vector<double> xs{1.0, 2.0, 3.0, 4.0, 5.0};
  std::cout << " => Linalg::norm(xs) " << Linalg::norm(xs) << std::endl;
  std::cout << "=> xs = "; Linalg::printVector(std::cout, xs); std::cout << std::endl;

  std::cout << "=== EXPERIMENT 2 ===> Import class from DLL" << std::endl;
  auto cls = SampleClass("Dummy");
  cls.set(100);
  std::cout << "cls.getName() = " << cls.getName() << std::endl;
  std::cout << "    cls.get() = " << cls.get() << std::endl;
  #endif // -- eof DISABLE flag
#+END_SRC

Main Function - Experiment 3 

#+BEGIN_SRC cpp
  //=========>> Load functions and classes using C-interface ==============//

  std::cout << "\n== EXPERIMENT 3 ===> Import C-functions from DLL - C-interface" << std::endl;

  double arr [] = {1, 2, 3, 4, 5};
  hVectorD v1 = testlib_vectorD_make1(5, arr);
  testlib_vectorD_Linalg_printVector("v1", v1);
  std::cout << "norm(v1) = " << testlib_vectorD_Linalg_norm(v1) << std::endl;

  testlib_vectorD_delete(v1);
#+END_SRC

Main Functions - Experiment 4 

#+BEGIN_SRC cpp 
  std::cout << "\n== EXPERIMENT 4 ===> Non-polymorphic class with C-interface " << std::endl;

  hSampleClass hcls = testlib_SampleClass_make1("[EXPERIMENT4]ClassHandle-OOP-C-API");
  std::cout << "[EXPERIMENT 4] hcls.getName() = " << testlib_SampleClass_getName(hcls) << std::endl;
  testlib_SampleClass_set(hcls, 100);
  std::cout << "[EXPERIMENT 4] hcls.get()     = " << testlib_SampleClass_get(hcls) << std::endl;
  testlib_SampleClass_set(hcls, 200);
  std::cout << "[EXPERIMENT 4] hcls.get()     = " << testlib_SampleClass_get(hcls) << std::endl;

  testlib_SampleClass_delete(hcls);	
#+END_SRC

Main Functions - Experiment 5 

#+BEGIN_SRC cpp 
  std::cout << "\n== EXPERIMENT 5 ===> Load polymorphic classes from DLL " << std::endl;

  InterfaceClass* hinstA = teslib_InterfaceClass_factory("ImplementationA");
  InterfaceClass* hinstB = teslib_InterfaceClass_factory("ImplementationB");

  std::cout << " => hinstA->getID() = " << hinstA->getID() << std::endl;
  std::cout << " => hinstA->getID() = " << hinstB->getID() << std::endl;
  hinstA->setName("ClassA-implA");
  hinstB->setName("ClassB-implB");
  std::cout << " => hinstA->getName() = " << hinstA->getID() << std::endl;
  std::cout << " => hinstB->getName() = " << hinstB->getID() << std::endl;

  // Note: If delete is used directly to delete hinstA and hinstB,
  // a segmentatin fault will happen whenc compiling with Mingw/GCC
  testlib_InterfaceClass_delete(hinstA);
  testlib_InterfaceClass_delete(hinstB);

  std::cout << " [INFO] After deleting instances" << std::endl;

  DbgTrace("Program ended OK.");
#+END_SRC

 *Compile and run client code with MSVC*

Note: Both the DLL and the client code are compiled with MSVC-2017 64
bits target.

#+BEGIN_SRC sh 
  $ cl.exe /EHsc client.cpp /nologo /Fe:client1.exe testlib.lib && client1.exe

  # Output: 
  client.cpp
     Creating library client1.lib and object client1.exp
   [StaticObject] => Initialize DLL
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 1112
  testlib.cpp:45: <DllMain> DLL attached to process.

  === EXPERIMENT 1 ===> Import C++ functions from DLL
  client.cpp:33: <main> Main process starts here.
   => Linalg::norm(xs) 7.4162
  => xs = [5]( 1, 2, 3, 4, 5,  )
  === EXPERIMENT 2 ===> Import class from DLL
   Instance created with name = Dummy
   Counter set to value = 100
  cls.getName() = Dummy
      cls.get() = 100

  == EXPERIMENT 3 ===> Import C-functions from DLL - C-interface
  v1 = [5]( 1, 2, 3, 4, 5,  )
  norm(v1) = 7.4162

  == EXPERIMENT 4 ===> Non-polymorphic class with C-interface 
   Instance created with name = [EXPERIMENT4]ClassHandle-OOP-C-API
  [EXPERIMENT 4] hcls.getName() = [EXPERIMENT4]ClassHandle-OOP-C-API
   Counter set to value = 100
  [EXPERIMENT 4] hcls.get()     = 100
   Counter set to value = 200
  [EXPERIMENT 4] hcls.get()     = 200
  testlib.cpp:159: <SampleClass::~SampleClass> SampleClass => name = [EXPERIMENT4]ClassHandle-OOP-C-API deleted

  == EXPERIMENT 5 ===> Load polymorphic classes from DLL 
   => hinstA->getID() = ImplementationA
   => hinstA->getID() = ImplementationB
   => hinstA->getName() = ImplementationA
   => hinstB->getName() = ImplementationB
   [INFO] ImplementationA deleted => name = ClassA-implA ; type = ImplementationA
   [INFO] ImplementationB deleted => name = ClassB-implB ; type = ImplementationB
   [INFO] After deleting instances
  client.cpp:87: <main> Program ended OK.
  testlib.cpp:159: <SampleClass::~SampleClass> SampleClass => name = Dummy deleted
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 1112
  testlib.cpp:49: <DllMain> => DLL attached
   [StaticObject] => Shutdown DLL

#+END_SRC

 *[FAILURE] ABI - Issue - Compile with Mingw client1.cpp against testlib.dll built with MSVC*

The client code is compiled with Mingw and the library was built with
MSVC-2017 for 64 bits target.

Build and run client [FAILURE]:

#+BEGIN_SRC cpp 
  $ g++ client1.cpp -g -o client1-gcc.exe -std=c++14 testlib.dll  && client1-gcc.exe
  C:\Users\archbox\AppData\Local\Temp\cckNg9eZ.o: In function `main':
  client1.cpp:35: undefined reference to `Linalg::norm(std::vector<double, std::allocator<double> > const&)'
  client1.cpp:36: undefined reference to `Linalg::printVector(std::ostream&, std::vector<double, std::allocator<double> >&)'
  client1.cpp:39: undefined reference to `SampleClass::SampleClass(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)'
  client1.cpp:40: undefined reference to `SampleClass::set(int)'
  client1.cpp:41: undefined reference to `SampleClass::getName[abi:cxx11]() const'
  client1.cpp:42: undefined reference to `SampleClass::get()'
  client1.cpp:39: undefined reference to `SampleClass::~SampleClass()'
  client1.cpp:39: undefined reference to `SampleClass::~SampleClass()'
  collect2.exe: error: ld returned 1 exit status
  Compilation exited abnormally with code 1 at Sun Dec 16 17:41:47
#+END_SRC

The compilation fails because C++ does not have a standard and stable
ABI - Application Binary Interface, as a result, it is not possible to
use an object-code (here - any type of compiled code) built by a
different compiler than the current one. The ABI comprises the name
mangling schema or name decoration schema which is compiler-dependent,
padding, class memory layout and so on. In addition to ABI issues, the
STL - Standard Template Library implementations may not be compatible
and also not be the same across different compilers. 

The only way to ensure that a DLL can work with all possible compilers
is to use a functions with C-linkage (extern "C") with opaque pointers
(void*) for passing around classes and wrapped STL containers. Classes
can be used by different compilers, only if they are interface classes
(classes with only pure virtual functions) containing only
C-compatible types in the declaration. 


 *Compile with Mingw client1.cpp against testlib.dll built with MSVC*

The compilation works when compiling with the custom flag -DDISABLE.
The directive _#ifndef DISABLE ... #endif_ removes all usages of the
namespace Linalg and the class SampleClass. This flag makes main the
function use only functions with C-linkage and the interface class
InterfaceClass.

#+BEGIN_SRC cpp 
$ g++ client.cpp -g -o client-gcc.exe -std=c++14 testlib.dll -DDISABLE   && client-gcc.exe

   [StaticObject] => Initialize DLL
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 5724
  testlib.cpp:45: <DllMain> DLL attached to process.

  == EXPERIMENT 3 ===> Import C-functions from DLL - C-interface
  v1 = [5]( 1, 2, 3, 4, 5,  )
  norm(v1) = 7.4162

  == EXPERIMENT 4 ===> Non-polymorphic class with C-interface 
   Instance created with name = [EXPERIMENT4]ClassHandle-OOP-C-API
  [EXPERIMENT 4] hcls.getName() = [EXPERIMENT4]ClassHandle-OOP-C-API
   Counter set to value = 100
  [EXPERIMENT 4] hcls.get()     = 100
   Counter set to value = 200
  [EXPERIMENT 4] hcls.get()     = 200
  testlib.cpp:159: <SampleClass::~SampleClass> SampleClass => name = [EXPERIMENT4]ClassHandle-OOP-C-API deleted

  == EXPERIMENT 5 ===> Load polymorphic classes from DLL 
   => hinstA->getID() = ImplementationA
   => hinstA->getID() = ImplementationB
   => hinstA->getName() = ImplementationA
   => hinstB->getName() = ImplementationB
   [INFO] ImplementationA deleted => name = ClassA-implA ; type = ImplementationA
   [INFO] ImplementationB deleted => name = ClassB-implB ; type = ImplementationB
   [INFO] After deleting instances
  client.cpp:87: <main> Program ended OK.
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 5724
  testlib.cpp:49: <DllMain> => DLL attached
   [StaticObject] => Shutdown DLL
#+END_SRC

*** Load DLL in Python3 REPL 

Functions with C-linkage can be called by Python using the ctypes
library. The following code presents how it can be done: 

 *Table for C types / Python ctypes conversion*

| C-type | Python C-types  | C-type  |                                 |
|--------+-----------------+---------+---------------------------------|
| char   | ctypes.c_char   | char*   | ctypes.POINTER(ctypes.c_char)   |
| int    | ctypes.c_int    | int*    | ctypes.POINTER(ctypes.c_int)    |
| size_t | ctypes.c_int    | -       |                                 |
| double | ctypes.c_double | double* | ctypes.POINTER(ctypes.c_double) |
| void   | None            | void*   | ctypes.c_void_p                 |
|        |                 |         |                                 |
|        |                 |         |                                 |

 + Get a Python string from a _const char* ptr_ or _char* ptr_, use ctypes.string_at(ptr).
 + Pass a python string to an API with const char*
   (ctypes.POINTER(ctypes.c_char)) as argument, use Function("string-argument".encode('utf-8'))

Python C-types documentation and further reading: 

 + [[https://docs.python.org/3/library/ctypes.html][ctypes — A foreign function library for Python — Python 3.7.2rc1 documentation]]
 + [[https://dbader.org/blog/python-ctypes-tutorial][Extending Python With C Libraries and the “ctypes” Module – dbader.org]]
 + [[https://www.programcreek.com/python/example/1108/ctypes.CDLL][ctypes.CDLL Python Example]]
 + [[https://blogs.msdn.microsoft.com/yizhang/2018/01/20/calling-c-functions-from-python-part-1-using-ctypes/][Calling C functions from Python – part 1 – using ctypes – Yi Zhang's MSDN Blog]]
 + [[https://en.wikibooks.org/wiki/Python_Programming/Extending_with_ctypes][Python Programming/Extending with ctypes - Wikibooks, open books for an open world]]
 + [[https://pgi-jcns.fz-juelich.de/portal/pages/using-c-from-python.html][Using C from Python: How to create a ctypes wrapper - Scientific IT-Systems]]

 *Load the library:*

#+BEGIN_SRC python 
  C:\Users\archbox\Desktop\experiments
  λ "C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\python"
  Python 3.6.5 |Anaconda, Inc.| (default, Mar 29 2018, 13:32:41) [MSC v.1900 64 bit (AMD64)] on win32
  Type "help", "copyright", "credits" or "license" for more information.

  >>> import ctypes

  # This messages is print by the DLLMain function 
  >>> lib = ctypes.cdll.LoadLibrary("testlib.dll")
   [StaticObject] => Initialize DLL
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 4280
  testlib.cpp:45: <DllMain> DLL attached to process.
  >>> testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 4280
  testlib.cpp:53: <DllMain> DLL detached to thread.
#+END_SRC

Check whether exported functions with C-linkage exist: 

#+BEGIN_SRC python 
  >>> lib.testlib_vectorD_make0
  <_FuncPtr object at 0x0000021BFCAFF388>

  >>> lib.testlib_vectorD_Linalg_printVector
  <_FuncPtr object at 0x0000021BFCAFF458>
  >>>

  >>> lib.testlib_vectorD_delete
  <_FuncPtr object at 0x0000021BFCAFF528>

  # Function which does not exist.
  >>> lib.testlib_InterfaceClass_do_not_exist
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\lib\ctypes\__init__.py", line 361, in __getattr__
      func = self.__getitem__(name)
    File "C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\lib\ctypes\__init__.py", line 366, in __getitem__
      func = self._FuncPtr((name_or_ordinal, self))
  AttributeError: function 'testlib_InterfaceClass_do_not_exist' not found
#+END_SRC

 *Load std::vector<double> and Linalg namespace wrapper functions*

Set up the std::vector<double> functions to be imported.
 
 + Note: hVectorD => Handle for std::vector<double> is the same as
   void* or an opaque pointer. 

#+BEGIN_SRC python
  # Funciton: hVectorD testlib_vectorD_make0(size_t n, double x)
  # Set function arguments
  lib.testlib_vectorD_make0.argtypes = [ctypes.c_int, ctypes.c_double]
  # Set return type 
  lib.testlib_vectorD_make0.restype  = ctypes.c_void_p
 
  # void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv)
  lib.testlib_vectorD_Linalg_printVector.argtypes = [ctypes.POINTER(ctypes.c_char), ctypes.c_void_p ]
  lib.testlib_vectorD_Linalg_printVector.restype = None 

  # Set vector elements hv[n] = x
  # void testlib_vectorD_set(hVectorD hv, size_t n, double x)
  lib.testlib_vectorD_set.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_double]
  lib.testlib_vectorD_set.restype  = None
#+END_SRC

Testing C-interface functions for std::vector<double>: 

#+BEGIN_SRC python 
  # Creating a std::vector<double> with 4 elements equal to 3.0 
  >>> vec1 = lib.testlib_vectorD_make0(4, 3.0)

  # This number is the memory address held by the opaque pointer,
  # it cannot be used directly. 
  >>> vec1
  2319184200912
  >>>
  # ========== Modify vector elements ======== #
  # Printarray2 the wrapped std::vector<double>
  >>> lib.testlib_vectorD_Linalg_printVector("vec1".encode('utf-8'), vec1)
  vec1 = [4]( 3, 3, 3, 3,  )
  >>>

  >>> lib.testlib_vectorD_set(vec1, 0, 5.0)
  >>> lib.testlib_vectorD_set(vec1, 1, 10.5)
  >>> lib.testlib_vectorD_set(vec1, 2, 4.78)

  >>> lib.testlib_vectorD_Linalg_printVector("vec1".encode('utf-8'), vec1)
  vec1 = [4]( 5, 10.5, 4.78, 3,  )
#+END_SRC

Compute vector Euclidian norm: 

#+BEGIN_SRC python 
  # Wrapper for function 
  # double Linalg::norm(const std::vector<double>& xs)
  # double testlib_vectorD_Linalg_norm(hVectorD hv)
  lib.testlib_vectorD_Linalg_norm.argtypes = [ ctypes.c_void_p ]
  lib.testlib_vectorD_Linalg_norm.restype  = ctypes.c_double

  >>> lib.testlib_vectorD_Linalg_printVector("vec1".encode('utf-8'), vec1)
  vec1 = [4]( 5, 10.5, 4.78, 3,  )

  >>> lib.testlib_vectorD_Linalg_norm(vec1)
  12.926654632966722

  # Check if calculations are right 
  >>> math.sqrt(5 * 5 + 10.5 * 10.5 + 4.78 * 4.78 + 3 * 3)
  12.926654632966722
  >>>
#+END_SRC

Delete vector vec1 using its destructor function: 

#+BEGIN_SRC python 
  # Function: void testlib_vectorD_delete(hVectorD hv)
  lib.testlib_vectorD_delete.argtypes = [ ctypes.c_void_p ]
  lib.testlib_vectorD_delete.restype = None

  >>> lib.testlib_vectorD_delete(vec1)
#+END_SRC

 *Load wrapper function for interface class InterfaceClass*

Load factory function: 
 + void* teslib_InterfaceClass_factory(const char* class_id)

#+BEGIN_SRC python 
   # InterfaceClass* teslib_InterfaceClass_factory(const char* class_id)
   lib.teslib_InterfaceClass_factory.argtypes = [ ctypes.POINTER(ctypes.c_char) ]
   lib.teslib_InterfaceClass_factory.restype  = ctypes.c_void_p

   # const char* testlib_InterfaceClass_getID(InterfaceClass* hinst)
   lib.testlib_InterfaceClass_getID.argtypes = [ ctypes.c_void_p ]
   lib.testlib_InterfaceClass_getID.restype  = ctypes.POINTER(ctypes.c_char)
#+END_SRC

Creating class instances and testing member function C-wrappers:

#+BEGIN_SRC python 
  >>> hinstA = lib.teslib_InterfaceClass_factory("ImplementationA".encode('utf-8'))
  >>> hinstA
  2319184196864
  >>>

  >>> hinstB = lib.teslib_InterfaceClass_factory("ImplementationB".encode('utf-8'))
  >>> hinstB
  2319184198016

  >>> s1 = lib.testlib_InterfaceClass_getID(hinstA)
  >>> s1
  <ctypes.LP_c_char object at 0x0000021BFBBF14C8>
  >>> ctypes.string_at(s1)
  b'ImplementationA'
  >>>

  >>> s2 = lib.testlib_InterfaceClass_getID(hinstB)
  >>> ctypes.string_at(s2)
  b'ImplementationB'

  >>> ctypes.string_at(lib.testlib_InterfaceClass_getID(hinstB))
  b'ImplementationB'
  >>>
#+END_SRC

Load more C-wrappers for member function of class InterfaceClass:

#+BEGIN_SRC python
   # const char* testlib_InterfaceClass_getName(InterfaceClass* hinst) 
   lib.testlib_InterfaceClass_getName.argtypes = [ ctypes.c_void_p ]
   lib.testlib_InterfaceClass_getName.restype  = ctypes.POINTER(ctypes.c_char)

   # void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name)
   >>> lib.testlib_InterfaceClass_setName.argtypes = [ ctypes.c_void_p, ctypes.POINTER(ctypes.c_char) ]
   >>> lib.testlib_InterfaceClass_setName.restype = None

   >>> lib.testlib_InterfaceClass_getName(hinstA)
   <ctypes.LP_c_char object at 0x0000021BFBBF1548>

   >>> ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstA))
   b'Unammed-A'

   >>> ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstB))
   b'Unammed-B'

   >>> lib.testlib_InterfaceClass_setName(hinstA, "Instance-ClassA1".encode('utf-8'))
   >>> ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstA))
   b'Instance-ClassA1'

   >>> lib.testlib_InterfaceClass_setName(hinstB, "Instance-B1".encode('utf-8'))
   >>> ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstB))
   b'Instance-B1'

#+END_SRC

Load C-functions wrappers for the InterfaceClass destructor and
dispose both instances hinstA and hinstB: 

#+BEGIN_SRC python 
  # Destructor function:
  # void testlib_InterfaceClass_delete(InterfaceClass* hinst)
  >>> lib.testlib_InterfaceClass_delete.argtypes = [ ctypes.c_void_p ]
  >>> lib.testlib_InterfaceClass_delete.restype  = None

  # Dispose class hinstA, delete this object 
  >>> lib.testlib_InterfaceClass_delete(hinstA)
   [INFO] ImplementationA deleted => name = Instance-ClassA1 ; type = ImplementationA

  >>> lib.testlib_InterfaceClass_delete(hinstB)
   [INFO] ImplementationB deleted => name = Instance-B1 ; type = ImplementationB
#+END_SRC

Exit python3 REPL:

#+BEGIN_SRC python 
   >>> exit()
   testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 4280
   testlib.cpp:49: <DllMain> => DLL attached
    [StaticObject] => Shutdown DLL
#+END_SRC

*** Python 3 Client Code - Wrapper Module 

All the boilerplate code required to load the shared library
testlib.dll can be eliminated by crafting a python module file and
wrapper classes.

Source:
 + File: [[file:src/dlls/example-windows1/pywrapper.py][file:src/dlls/example-windows1/pywrapper.py]]
 + Gist: [[https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71][Gisthub]]


 *Module Initialization:*

 + File: pywrapper.py

The function _config initializes the wrapper module, loading the DLL -
share library testlib.dll into the current Python3 interpreter process
and setting up the C-functions (functions exported with C-linkage,
without name mangling) exported by the library.

#+BEGIN_SRC python 
  import ctypes

  def _getSharedLibrary(libname):
      import sys
      import os
      libfile = libname 
      if sys.platform == "linux" or sys.platform == "linux2":
          libfile = "lib" + libname + ".so"
      elif sys.platform == "darwin":
          libfile =  libname + ".dylyb"
      elif  sys.platform == "win32":
          libfile = libname + ".dll"
      libpath = os.path.join(os.path.dirname(__file__), libfile)
      print(" [INFO] libpath = " + libpath)
      return libpath

  # _lib = ctypes.cdll.LoadLibrary("testlib")
  _lib = ctypes.cdll.LoadLibrary(_getSharedLibrary("testlib"))

  # Startup ctypes FFI - Foreign Function Interface 
  def _config():
      print("Intializing library")
      # ======= std::vector<double> and Linalg:: namespace ==========##
    
      # hVectorD testlib_vectorD_make0(size_t n, double x)
      _lib.testlib_vectorD_make0.argtypes = [ctypes.c_int, ctypes.c_double]
      _lib.testlib_vectorD_make0.restype  = ctypes.c_void_p

      # hVectorD testlib_vectorD_make1(size_t n, double array [])
      _lib.testlib_vectorD_make1.argtypes = [ctypes.c_int, ctypes.POINTER(ctypes.c_double)]
      _lib.testlib_vectorD_make1.restype  = ctypes.c_void_p    

  _config()
#+END_SRC

The class VectorD is a wrapper class for the STL class
std::vector<double> and the namespace Linalg containing linear algebra
functions. 

#+BEGIN_SRC python 
  class VectorD:
      def __init__(self, handle):
          self.hnd = ctypes.c_void_p(handle)
          self.name = "std::vector<double> vx"

      @classmethod
      def fromValue(cls, size, x):
          return VectorD(_lib.testlib_vectorD_make0(size, x))

      @classmethod
      def fromArray(cls, array):
          carray_size_n = ctypes.c_double * len(array)
          return VectorD(_lib.testlib_vectorD_make1(len(array), carray_size_n(*array)))

      # Destructor 
      def __del__(self):
          print(" [TRACE] - Vector disposed - C++ Destructor invoked Ok.")
          _lib.testlib_vectorD_delete(self.hnd)

      def setName(self, name):
          self.name = name

      # Display vector 
      def disp(self):
          _lib.testlib_vectorD_Linalg_printVector(self.name.encode('utf-8'), self.hnd)

      # Set element at nth position 
      def set(self, idx, x):
          _lib.testlib_vectorD_set(self.hnd, idx, x)

      def norm(self):
          return _lib.testlib_vectorD_Linalg_norm(self.hnd)
#+END_SRC

The class CPPInterfaceClass is a wrapper for the C++ interface class
InterfaceClass exported by the DLL. The python wrapper class contains
factory methods .factory, .makeA for loading the implementation class
ImplementationA and the method .makeB for loading the implementation
ImplementationB. 

#+BEGIN_SRC python 
  # Proxy for C++ Interface class in the shared library 
  class CPPInterfaceClass:
      # Constructor 
      def __init__(self, handle):
          self.hnd = ctypes.c_void_p(handle)

      # Destructor 
      def __del__(self):
          # Call C++ destructor
          # print(" [__del__] => self.hnd = " + str(self.hnd))
          _lib.testlib_InterfaceClass_delete(self.hnd)

      @classmethod
      def factory(cls, classID):
          return CPPInterfaceClass(_lib.teslib_InterfaceClass_factory(classID.encode('utf-8')))

      @classmethod
      def makeA(cls):              
          "Instantiate the class ImplementationA from the DLL."
          return CPPInterfaceClass.factory("ImplementationA")

      @classmethod
      def makeB(cls):              
          "Instantiate the class ImplementationB from the DLL."
          return CPPInterfaceClass.factory("ImplementationB")

      def getType(self):
          return ctypes.string_at(_lib.testlib_InterfaceClass_getID(self.hnd)).decode('utf-8')

      def getName(self):
          return ctypes.string_at(_lib.testlib_InterfaceClass_getName(self.hnd)).decode('utf-8')

      def setName(self, name):
          _lib.testlib_InterfaceClass_setName(self.hnd, name.encode('utf-8'))

      # String representation 
      def __str__(self):
          s   = "CInterfaceClass ; type = " + self.getType()
          s +=  " - name =  " + self.getName() + "\n"
          return s

      # Make class printable in the REPL
      def __repr__(self):
          return self.__str__()    
#+END_SRC

Function test1() runs an example code:

#+BEGIN_SRC python 
  def test1():
      print("\n ========  Test 1 - std::vector<double> wrapper and Linalg module ======")
      v1 = VectorD.fromValue(4, 3.5)
      print(" [*]=> Before changing std::vector<double> object")
      v1.disp()
      print("v1.norm() = " + str(v1.norm()))
      print()
      print(" [*]=> After changing std::vector<double> object")
      v1.set(0, 5); v1.set(1, 2.6); v1.set(2, 9.81); v1.set(3, 3.76)
      v1.disp()
      print("v1.norm() " + str(v1.norm()))
      print()

      print("\n ========  Interface class 'InterfaceClass' ======")
      clsA = CPPInterfaceClass.makeA()
      print("clsA = " + str(clsA))
      print("clsA.getType() = " + clsA.getType())

      clsB = CPPInterfaceClass.makeB()
      print("clsB = " + str(clsB))
      print("clsB.getType() = " + clsB.getType())    

  if __name__ == "__main__":    
      test1()

#+END_SRC

 *Usage in Python3 REPL:*

This step assumes that the shared library file (testlib.dll on Windows
or libtestlib.so on Unix-like OS or Linux) is in the same directory as
the python script pywrapper.py.

 + Import module 

#+BEGIN_SRC python 
  $ C:/Users/archbox/Miniconda3/pkgs/python-3.6.5-h0c2934d_0/python
  Python 3.6.5 |Anaconda, Inc.| (default, Mar 29 2018, 13:32:41) [MSC v.1900 64 bit (AMD64)] on win32
  Type "help", "copyright", "credits" or "license" for more information.
  >>>

  >>> from testlib import VectorD
   [StaticObject] => Initialize DLL
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 5776
  testlib.cpp:45: <DllMain> DLL attached to process.
  Intializing library
  Library initialized OK.

  >>> from testlib import CPPInterfaceClass
#+END_SRC

 + Testing class VectorD - wrapper for std::vector<double> 

#+BEGIN_SRC python
  >>> v1 = VectorD.fromValue(5, 3.0)
  >>> v1.disp()
  std::vector<double> vx = [5]( 3, 3, 3, 3, 3,  )

  >>> v1.setName("v1")
  >>> v1.disp()
  v1 = [5]( 3, 3, 3, 3, 3,  )

  >>> v1.norm()
  6.708203932499369

  >>> v1.set(0, 5)
  >>> v1.set(1, 4.5)
  >>> v1.set(2, 9.8)
  >>> v1.set(3, 18.4)

  >>> v1.disp()
  v1 = [5]( 5, 4.5, 9.8, 18.4, 3,  )
  >>>
  >>> v1.norm()
  22.10995251012539

  >>> v1 = 100
   [TRACE] - Vector disposed - C++ Destructor invoked Ok.

  >>> v2 = VectorD.fromArray([4.0, 10.25, 9.6, 3, 10, 6, 15])
  >>> v2.disp()
  std::vector<doubl> vx = [7]( 4, 10.25, 9.6, 3, 10, 6, 15,  )

  >>> v2.norm()
  24.15

  >>> v2.set(0, 100)
  >>> v2.set(1, 200)

  >>> v2.disp()
  std::vector<double> vx = [7]( 100, 200, 9.6, 3, 10, 6, 15,  )

  >>> v2.norm()
  224.63784186997523
  >>>

#+END_SRC

 + Testing class CPPInterfaceClass, proxy for C++ classes
   InterfaceClass, ImplementationA and ImplementationB.

#+BEGIN_SRC python 
   >>> from testlib import CPPInterfaceClass

   # ======== Load ImplementationA  ============== # 
   #
   >>> a = CPPInterfaceClass.makeA()
   >>> a
   CInterfaceClass ; type = ImplementationA - name =  Unammed-A

   >>> a.getType()
   'ImplementationA'
   >>> a.getName()
   'Unammed-A'
   >>> a.setName("Instance-of-ImplA")
   >>> a
   CInterfaceClass ; type = ImplementationA - name =  Instance-of-ImplA

   # ======== Load ImplementationB  ============== # 
   #
   >>> b = CPPInterfaceClass.makeB()
   >>> b
   CInterfaceClass ; type = ImplementationB - name =  Unammed-B

   >>> b.setName("Instance-of-class-B")
   >>> b.getName()
   'Instance-of-class-B'
   >>>
   >>> b.getType()
   'ImplementationB'

#+END_SRC

 + Exit REPL. 

#+BEGIN_SRC python 
  >>> exit()
   [TRACE] - Vector disposed - C++ Destructor invoked Ok.
   [INFO] ImplementationB deleted => name = Instance-of-class-B ; type = ImplementationB
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 5776
  testlib.cpp:49: <DllMain> => DLL attached
   [StaticObject] => Shutdown DLL
#+END_SRC

*** CSharp Client Code - PInvoke 

The services provided by the DLL can be consumed from C# or any other
.NET language via Pinvoke-API which is the Foreign-Function Interface
of .NET platform. The Pinvoke API can import C-function or C++
demangled functions exported with extern "C". 

C++ classes, namespaces and functions without C-linkage (extern "C")
cannot be loaded directly by P-Invoke or any other Foreign
Function-Interface as C++ does not define a standard and ABI -
Application Binary Interface, every compiler has its own name mangling
schema, padding bytes and class memory layout for non-POD (Plain-Old
data) types. A workaround to call C++ from an FFI is to defined
C-interface comprised of functions with C-linkage and opaque pointers
(void*) for passing class instances around or invoking C++ functions.

 File: [[https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71#file-client-csharp-cs][client-sharp.cs]]

Compiling and running:

#+BEGIN_SRC sh 
  $ csc.exe client-csharp.cs && client-csharp.exe
#+END_SRC

Wrapper for class std::vector<double> and namespace Linalg.

#+BEGIN_SRC cpp
   class VectorD{
           // Constructor Function:
           // hVectorD testlib_vectorD_make0(size_t n, double x)
           // void* testlib_vectorD_make0(size_t n, double x)
           [DllImport("testlib.dll")]
           public static extern
           IntPtr testlib_vectorD_make0(int size, double x);

           [DllImport("testlib.dll")]
           public static extern
           IntPtr testlib_vectorD_make1(int n, double[] x);

           // Destructor function:
           // void testlib_vectorD_delete(hVectorD hv)
           // void testlib_vectorD_delete(void* hv)
           [DllImport("testlib.dll")]
           public static extern
           IntPtr testlib_vectorD_delete(IntPtr hv);

           // void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv)
           // void testlib_vectorD_Linalg_printVector(const char* name, vector* hv)
           [DllImport("testlib.dll")]
           public static extern
           void testlib_vectorD_Linalg_printVector(string name, IntPtr hv);

           // double testlib_vectorD_Linalg_norm(hVectorD hv)
           // double testlib_vectorD_Linalg_norm(void* hv)
           [DllImport("testlib.dll")]
           public static extern
           double testlib_vectorD_Linalg_norm(IntPtr hv);

           // void testlib_vectorD_set(hVectorD hv, size_t n, double x)
           // void testlib_vectorD_set(void* hv, size_t n, double x)
           [DllImport("testlib.dll")]
           public static extern
           void testlib_vectorD_set(IntPtr hv, int n, double x);

           // ------------ Objet Oriented Wrapper --------//

           // Hadle 
           private IntPtr m_handle;

           public VectorD(int size, double x){
                   m_handle = testlib_vectorD_make0(size, x);
           }
           public VectorD(double[] array){
                   m_handle = testlib_vectorD_make1(array.Length, array);
           }        
           // Finalized destructor 
           ~VectorD(){
                   testlib_vectorD_delete(m_handle);
           }
           public void print(string name = "std::vector<double>"){
                   testlib_vectorD_Linalg_printVector(name, m_handle);
           }
           public void set(int n, double x){
                   testlib_vectorD_set(m_handle, n, x);
           }
           public double norm(){
                   return testlib_vectorD_Linalg_norm(m_handle);
           }
   }
#+END_SRC

Wrapper for C++ interface class 'InterfaceClass' and its
implementations, class ImplementationA and ImplementationB:

#+BEGIN_SRC cpp 
   class CPPInterfaceClass{
           // Handle type => Opaque pointer for InterfaceClass instances.
           // using HInterf = IntPtr;

           // Factory function for loading functions from this interface.
           //-----------------------------------------------------------
           // InterfaceClass* teslib_InterfaceClass_factory(const char* class_id)
           // void** teslib_InterfaceClass_factory(const char* class_id)
           [DllImport("testlib.dll")]
           private static extern
           IntPtr teslib_InterfaceClass_factory(string class_id);

           // void testlib_InterfaceClass_delete(InterfaceClass* hinst)
           // void testlib_InterfaceClass_delete(void*)
           [DllImport("testlib.dll")]
           private static extern
           void testlib_InterfaceClass_delete(IntPtr hinst);

           // char* testlib_InterfaceClass_getID(InterfaceClass* hinst)
           [DllImport("testlib.dll")]        
           private static extern IntPtr testlib_InterfaceClass_getID(IntPtr hinst);

           // void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name)
           // Note: Charset.UNICODE does not work as it is UTF16 (Wide Unicode), not UTF-8
           // which is the C++ default unicode type.
           [DllImport("testlib.dll", CharSet = CharSet.Ansi)]
           private static extern
           void testlib_InterfaceClass_setName(IntPtr hinst, string name);

           // char* testlib_InterfaceClass_getName(InterfaceClass* hinst)
           [DllImport("testlib.dll")]
           private static extern
           IntPtr testlib_InterfaceClass_getName(IntPtr hinst);

           private IntPtr m_handle;

           private CPPInterfaceClass(IntPtr handle){
                   m_handle = handle;
           }

           ~CPPInterfaceClass(){
                   testlib_InterfaceClass_delete(m_handle);
           }

           /** Creates an instance of the the C++ implementation ImplementationA (class) from the 
            * C++ interface: 'InterfaceClass' 
            */
           public static CPPInterfaceClass ImplementationA(){
                   return new CPPInterfaceClass(teslib_InterfaceClass_factory("ImplementationA"));
           }
           /** Creates an instance of the C++ implementationa ImplementationB (class) */
           public static CPPInterfaceClass ImplementationB(){
                   return new CPPInterfaceClass(teslib_InterfaceClass_factory("ImplementationB"));
           }

           // Get type of the wrapped C++ class 
           public string GetID(){
                   IntPtr p = testlib_InterfaceClass_getID(m_handle);
                   return Marshal.PtrToStringAnsi(p);
           }

           // Get/Set name of current instance 
           public string Name
           {
                   get{
                           IntPtr p = testlib_InterfaceClass_getName(m_handle);
                           return Marshal.PtrToStringAnsi(p);
                   }
                   set{
                           testlib_InterfaceClass_setName(m_handle, value);
                   }
           }
   }
#+END_SRC

 + Main function - Experiment 1: 

#+BEGIN_SRC cpp 
  Console.WriteLine(" ===== EXPERIMENT 1 = Using C-functions directly ==");
  Console.WriteLine(" [CSharp] Loading Native DLL C++ Shared Library");                
  IntPtr vectorObject = VectorD.testlib_vectorD_make0(5, 3.0);
  Console.WriteLine(" [CSharp] Opaque pointer = ", vectorObject.ToString());
  VectorD.testlib_vectorD_Linalg_printVector("vectorX", vectorObject);


  double x = VectorD.testlib_vectorD_Linalg_norm(vectorObject);
  Console.WriteLine(" [CSharp] Vector norm = " + x.ToString());

  Console.WriteLine(" [CSharp] End application");
  VectorD.testlib_vectorD_delete(vectorObject);
#+END_SRC

Output: 

#+BEGIN_SRC text 
  ===== EXPERIMENT 1 = Using C-functions directly ==
   [CSharp] Loading Native DLL C++ Shared Library
   [StaticObject] => Initialize DLL
  testlib.cpp:48: <DllMain> DLL Loaded into the process => PID = 1320
  testlib.cpp:54: <DllMain> DLL attached to process.
   [CSharp] Opaque pointer = 
  vectorX = [5]( 3, 3, 3, 3, 3,  )
   [CSharp] Vector norm = 6.70820393249937
   [CSharp] End application
#+END_SRC

 + Main function - Experiment 2:

#+BEGIN_SRC cpp 
    Console.WriteLine(" ===== EXPERIMENT 2 = Using OOP wrapper for std::vector ===");
    Console.WriteLine(" ==> Before changing vector");
    VectorD v1 = new VectorD(10, 3.5);
    v1.print();
    v1.print("vector_v1");
    Console.WriteLine("v1.norm() = " + v1.norm().ToString());

    Console.WriteLine(" ==> After changing vector");
    v1.set(1, 10.0); v1.set(2, 5.53); v1.set(3, 8.96);
    v1.set(4, -10.34); v1.set(8, 80.54);
    v1.print("v1_changed");

    Console.WriteLine(" ==> Creating Vector from Array");

    VectorD v2 = new VectorD(new double[] {4.5, -8.84, 78.23, 652.3, 34.56, 45.12});
    v2.print("v2");
    Console.WriteLine("v2.norm() = " + v2.norm().ToString());
#+END_SRC


Output: 

#+BEGIN_SRC text 
   ===== EXPERIMENT 2 = Using OOP wrapper for std::vector ===
   ==> Before changing vector
  std::vector<double> = [10]( 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5,  )
  vector_v1 = [10]( 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5,  )
  v1.norm() = 11.0679718105893
   ==> After changing vector
  v1_changed = [10]( 3.5, 10, 5.53, 8.96, -10.34, 3.5, 3.5, 3.5, 80.54, 3.5,  )
   ==> Creating Vector from Array
  v2 = [6]( 4.5, -8.84, 78.23, 652.3, 34.56, 45.12,  )
  v2.norm() = 659.502711518307
#+END_SRC

 + Main function - Experiment 3:

#+BEGIN_SRC cpp 
    Console.WriteLine(" ===== EXPERIMENT 3 = OOP wrapper for InterfaceClass  ===");
    CPPInterfaceClass instA = CPPInterfaceClass.ImplementationA();
    CPPInterfaceClass instB = CPPInterfaceClass.ImplementationB();

    // Console.WriteLine("instA.Name = " + instA.Name);
    Console.WriteLine("instA.GetID() = " + instA.GetID());
    Console.WriteLine("instB.GetID() = " + instB.GetID());

    Console.WriteLine(" **=> Before changing");
    Console.WriteLine("instA.Name = " + instA.Name);
    Console.WriteLine("instB.Name = " + instB.Name);
    Console.WriteLine("\n **=> Before changing");
    instA.Name = "Instance-of-ImplA";
    instB.Name = "Instance-of-ImplB";
    Console.WriteLine("instA.Name = " + instA.Name);
    Console.WriteLine("instB.Name = " + instB.Name);

    Console.WriteLine(" ===== END  ===========================");
#+END_SRC

Output: 

#+BEGIN_SRC text 
    ===== EXPERIMENT 3 = OOP wrapper for InterfaceClass  ===
   instA.GetID() = ImplementationA
   instB.GetID() = ImplementationB
    **=> Before changing
   instA.Name = Unammed-A
   instB.Name = Unammed-B

    **=> Before changing
   instA.Name = Instance-of-ImplA
   instB.Name = Instance-of-ImplB
    ===== END  ===========================
   testlib.cpp:48: <DllMain> DLL Loaded into the process => PID = 1320
   testlib.cpp:62: <DllMain> DLL detached to thread.
    [INFO] ImplementationB deleted => name = Instance-of-ImplB ; type = ImplementationB
    [INFO] ImplementationA deleted => name = Instance-of-ImplA ; type = ImplementationA
   testlib.cpp:48: <DllMain> DLL Loaded into the process => PID = 1320
   testlib.cpp:58: <DllMain> => DLL attached
    [StaticObject] => Shutdown DLL
#+END_SRC

*** View symbols exported by the shared library 
**** View exported symbols on Windows (dumpbin)

 *Location of dumpbin tool*

The symbols exported by the DLL can viewed with the dumpbin tool
available from the MSVC developer console.

#+BEGIN_SRC sh 
  $ where dumpbin.exe
  C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.12.25827\bin\Hostx64\x64\dumpbin.exe
#+END_SRC

 *Show DLL exported symbols*

#+BEGIN_SRC sh 
 $ dumpbin.exe /exports testlib.dll 
#+END_SRC

Output: 

#+BEGIN_SRC txt 
  Microsoft (R) COFF/PE Dumper Version 14.12.25835.0
  Copyright (C) Microsoft Corporation.  All rights reserved.


  Dump of file testlib.dll

  File Type: DLL

    Section contains the following exports for testlib.dll

      00000000 characteristics
      FFFFFFFF time date stamp
          0.00 version
             1 ordinal base
            31 number of functions
            31 number of names

      ordinal hint RVA      name

            1    0 00005C50 ??0SampleClass@@QEAA@AEBV0@@Z
            2    1 00001650 ??0SampleClass@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
            3    2 000015E0 ??0SampleClass@@QEAA@XZ
            4    3 000016E0 ??1SampleClass@@QEAA@XZ
            5    4 00007280 ??4SampleClass@@QEAAAEAV0@AEBV0@@Z
            6    5 00001880 ?get@SampleClass@@QEAAHXZ
            7    6 00001830 ?getName@SampleClass@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
            8    7 00001370 ?linTransform@Linalg@@YA?AV?$vector@NV?$allocator@N@std@@@std@@NNAEAV23@@Z
            9    8 000012D0 ?norm@Linalg@@YANAEBV?$vector@NV?$allocator@N@std@@@std@@@Z
           10    9 00001480 ?printVector@Linalg@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEAV?$vector@NV?$allocator@N@std@@@3@@Z
           11    A 000018A0 ?set@SampleClass@@QEAAXH@Z
           12    B 00001D50 DllMain
           13    C 00002720 entryPoint1
           14    D 00002800 main
           15    E 00001B10 teslib_InterfaceClass_factory
           16    F 00001C60 testlib_InterfaceClass_delete
           17   10 00001CC0 testlib_InterfaceClass_getID
           18   11 00001D20 testlib_InterfaceClass_getName
           19   12 00001CF0 testlib_InterfaceClass_setName
           20   13 00001A10 testlib_SampleClass_delete
           21   14 00001A60 testlib_SampleClass_get
           22   15 00001AB0 testlib_SampleClass_getName
           23   16 00001900 testlib_SampleClass_make0
           24   17 00001950 testlib_SampleClass_make1
           25   18 00001A80 testlib_SampleClass_set
           26   19 00001560 testlib_vectorD_Linalg_norm
           27   1A 00001580 testlib_vectorD_Linalg_printVector
           28   1B 000026D0 testlib_vectorD_delete
           29   1C 00002590 testlib_vectorD_make0
           30   1D 00002610 testlib_vectorD_make1
           31   1E 00002690 testlib_vectorD_set

    Summary

          3000 .data
          4000 .pdata
         18000 .rdata
          1000 .reloc
         2F000 .text
#+END_SRC

Note that: 

 +  Functions with C-linkage are not mangled, their symbols match
   their names, for instance:

#+BEGIN_SRC sh 
    15    E 00001B10 teslib_InterfaceClass_factory
   16    F 00001C60 testlib_InterfaceClass_delete
   17   10 00001CC0 testlib_InterfaceClass_getID
   18   11 00001D20 testlib_InterfaceClass_getName
   19   12 00001CF0 testlib_InterfaceClass_setName
   20   13 00001A10 testlib_SampleClass_delete
   21   14 00001A60 testlib_SampleClass_get
   22   15 00001AB0 testlib_SampleClass_getName
#+END_SRC

 + Functions, member functions, namespaces and everything without
   C-linkage are mangled, the compiler generate an unique name for the
   generated symbols: 

#+BEGIN_SRC sh 
   1    0 00005C50 ??0SampleClass@@QEAA@AEBV0@@Z
   2    1 00001650 ??0SampleClass@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
   3    2 000015E0 ??0SampleClass@@QEAA@XZ
   4    3 000016E0 ??1SampleClass@@QEAA@XZ
   5    4 00007280 ??4SampleClass@@QEAAAEAV0@AEBV0@@Z
   6    5 00001880 ?get@SampleClass@@QEAAHXZ
   7    6 00001830 ?getName@SampleClass@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
   8    7 00001370 ?linTransform@Linalg@@YA?AV?$vector@NV?$allocator@N@std@@@std@@NNAEAV23@@Z
   9    8 000012D0 ?norm@Linalg@@YANAEBV?$vector@NV?$allocator@N@std@@@std@@@Z
  10    9 00001480 ?printVector@Linalg@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEAV?$vector@NV?$allocator@N@std@@@3@@Z
  11    A 000018A0 ?set@SampleClass@@QEAAXH@Z
#+END_SRC

It is possible to demangle those symbols with the tool - https://demangler.com/

 + Symbol: ??0SampleClass@@QEAA@AEBV0@@Z demangled:

#+BEGIN_SRC sh
  public: __cdecl SampleClass::SampleClass(class SampleClass const & __ptr64) __ptr64
#+END_SRC

 + Symbol: ?get@SampleClass@@QEAAHXZ demangled:

#+BEGIN_SRC sh
  public: int __cdecl SampleClass::get(void) __ptr64
#+END_SRC

 + Symbol: ?linTransform@Linalg@@YA?AV?$vector@NV?$allocator@N@std@@@std@@NNAEAV23@@Z demangled:

#+BEGIN_SRC cpp 
  class std::vector<double,class std::allocator<double> > __cdecl Linalg::linTransform(double,double,class std::vector<double,class std::allocator<double> > & __ptr64)
#+END_SRC

**** View exports symbols on Unix-like OSes (nm)

View exported symbols with nm:

 + Note that only functions annotated with extern "C" such as
   _teslib_InterfaceClass_factory_ are not mangled. 

#+BEGIN_SRC sh 
  $ nm -D libtestlib.so 

  000000000020a3d8 B __bss_start
                   U __cxa_atexit
                   w __cxa_finalize
                   U __cxa_pure_virtual
  000000000020a3d8 D _edata
  000000000020a440 B _end
  000000000000710c T _fini
                   w __gmon_start__
  ... ...   ... ...   ... ...   ... ...   ... ... 
  0000000000005512 T teslib_InterfaceClass_factory
  0000000000005629 T testlib_InterfaceClass_delete
  0000000000005656 T testlib_InterfaceClass_getID
  00000000000056a8 T testlib_InterfaceClass_getName
  0000000000005677 T testlib_InterfaceClass_setName
  000000000000545c T testlib_SampleClass_delete
  000000000000548f T testlib_SampleClass_get
  00000000000054cc T testlib_SampleClass_getName
   
  ... ... ... ...   ... ... ... ... 

  0000000000005076 T _ZN11SampleClassC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
  0000000000005106 T _ZN11SampleClassC2Ev
  0000000000005196 T _ZN11SampleClassD1Ev

#+END_SRC

View exported symbols demangled (without name mangling):

#+BEGIN_SRC sh 
   $ nm -CD libtestlib.so 
   000000000020a3d8 B __bss_start
                    U __cxa_atexit
                    w __cxa_finalize

    ... ... ...  ... ... ...  ... ... ...  ... ... ... 

   0000000000004fe7 T testlib_vectorD_Linalg_norm
   000000000000500f T testlib_vectorD_Linalg_printVector
   0000000000004e52 T testlib_vectorD_make0
   0000000000004ee2 T testlib_vectorD_make1
   0000000000004f80 T testlib_vectorD_set
                    U _Unwind_Resume
                    U operator delete(void*)
                    U operator delete(void*, unsigned long)
   00000000000052fe T SampleClass::get()
   0000000000005310 T SampleClass::set(int)

    ...  ...  ...  ...  ...  ...  ... 

   00000000000070ac W double* std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<double>(double const*, double const*, double*)
   0000000000006cfe W void std::_Destroy_aux<true>::__destroy<double*>(double*, double*)
   0000000000006c74 W std::_Vector_base<double, std::allocator<double> >::_M_allocate(unsigned long)
   0000000000006a44 W std::_Vector_base<double, std::allocator<double> >::_Vector_impl::_Vector_impl(std::allocator<double> const&)
   0000000000006a44 W std::_Vector_base<double, std::allocator<double> >::_Vector_impl::_Vector_impl(std::allocator<double> const&)
   000000000000681a W std::_Vector_base<double, std::allocator<double> >::_Vector_impl::~_Vector_impl()
   000000000000681a W std::_Vector_base<double, std::allocator<double> >::_Vector_impl::~_Vector_impl()
   0000000000006ae8 W std::_Vector_base<double, std::allocator<double> >::_M_deallocate(double*, unsigned long)
   0000000000006a8e W std::_Vector_base<double, std::allocator<double> >::_M_create_storage(unsigned long)
   0000000000006926 W std::_Vector_base<double, std::allocator<double> >::_M_get_Tp_allocator()
   0000000000006836 W std::_Vector_base<double, std::allocator<double> >::_Vector_base(unsigned long, std::allocator<double> const&)
   00000000000069d2 W std::_Vector_base<double, std::allocator<double> >::_Vector_base(std::allocator<double> const&)
   0000000000006836 W std::_Vector_base<double, std::allocator<double> >::_Vector_base(unsigned long, std::allocator<double> const&)
   00000000000069d2 W std::_Vector_base<double, std::allocator<double> >::_Vector_base(std::allocator<double> const&)

  ... ... ... ... ... 

  0000000000006706 W std::function<void ()>::function(std::function<void ()> const&)
  0000000000006706 W std::function<void ()>::function(std::function<void ()> const&)
  00000000000062b2 W std::function<void ()>::~function()
  00000000000062b2 W std::function<void ()>::~function()
                   U std::ios_base::Init::Init()
                   U std::ios_base::Init::~Init()
#+END_SRC

** Return string from a C++ function to Python Ctypes

Example: Create a function with C linkage or C-API which returns a
dynamically allocated string to the caller. 

 + Source:  [[https://gist.github.com/caiorss/fc0e628daf7bbb4e8484491856a07c38][Gist with all files]] 

Necessary C-string functions: 
 + [[https://en.cppreference.com/w/c/experimental/dynamic/strdup][strdup]]
 + [[https://en.cppreference.com/w/c/string/byte/strcpy][strcpy, strcpy_s]]
 + [[http://www.cplusplus.com/reference/cstring/strlen/][strlen]]

Build shared library - DLL (cstr.so):

#+BEGIN_SRC sh 
 $ clang++ cstr.cpp -o cstr.so -std=c++1z -O0 -g -shared -fPIC -std=c++1z 
#+END_SRC

 *File cstr.cpp* 

Headers: 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <sstream>
  #include <cstring>     // std::strncpy
  #include <cmath>

  #if defined(_WIN32)
    //  MS-Windows 
    #define EXPORT_C  extern "C" __declexpec(dllexport)
  #else
    // Unix
    #define EXPORT_C  extern "C" 
  #endif 

#+END_SRC

Function - version A: 

#+BEGIN_SRC cpp 

  /** Design 1: Buffer allocated by the caller.
   ,* @param[in]     x            Float point number 
   ,* @param[in,out] buffer       Buffer allocated by the caller. 
   ,* @param[in]     buffer_size  Size of buffer allocated by the caller in bytes.
   ,* @return                     Size of copied array.
   ,*/
  EXPORT_C size_t 
  square_root_as_stringA(double x, char* buffer, size_t buffer_size)
  {
       std::string ss;
       ss = ss + "The square root of x = " + std::to_string(x)
               + " is equal to " + std::to_string(sqrt(x));
       std::strncpy(buffer, ss.data(), buffer_size);
       return ss.size();
  }

#+END_SRC

Function - version B: 

#+BEGIN_SRC cpp 
  /** Design 2: Buffer allocated by the caller. If the buffer is null, the function 
   ,*            returns the required buffer size.
   ,* @param[in]     x            Float point number 
   ,* @param[in,out] buffer       Buffer allocated by the caller. 
   ,* @param[in]     buffer_size  Size of buffer allocated by the caller in bytes.
   ,* @return                     Size of copied array or required buffer size.                                
   ,*/
  EXPORT_C size_t 
  square_root_as_stringB(double x, char* buffer, size_t buffer_size)
  {
       std::string ss;
       ss = ss + "The square root of x = " + std::to_string(x)
               + " is equal to " + std::to_string(sqrt(x));
       if(buffer == nullptr)
               return ss.size();
       std::strncpy(buffer, ss.data() /* const char* */, buffer_size);
       return ss.size();
  }
#+END_SRC

Function - version C:

#+BEGIN_SRC cpp 
  /** Design3: Buffer allocated by callee (this code) and released by the
   ,* caller. */
  EXPORT_C char* 
  square_root_as_stringC(double x){
       std::string ss;
       ss = ss + "The square root of x = " + std::to_string(x)
               + " is equal to " + std::to_string(sqrt(x));
       return strdup(ss.data());
  }

  EXPORT_C void 
  cstring_delete(char* pCstring)
  {
      std::cout << " [INFO] C-string deleted, memory released. OK." << "\n";
      std::free(pCstring);
  }
#+END_SRC

 *file: cstrp.py* (Python Wrapepr)

Initial configuration: 

#+BEGIN_SRC python 
  import ctypes 

  CString   = ctypes.POINTER(ctypes.c_char)
  STDString = ctypes.c_void_p 
  CVoid     = None 
  dll = ctypes.cdll.LoadLibrary("cstr.so")
#+END_SRC

Wrapper for function A:

#+BEGIN_SRC python 
  print("\n EXPERIMENT1 => Call square_root_as_stringA")
  print("=============================================")
  dll.square_root_as_stringA.argtypes = [ ctypes.c_double,
                                          CString,
                                          ctypes.c_size_t ]
  dll.square_root_as_stringA.restype  = ctypes.c_size_t

  buf_size = 1024 # 1 Kbyte = 1024 bytes
  buf      = ctypes.create_string_buffer(buf_size)
  n_read   = dll.square_root_as_stringA(100.45, buf, buf_size)

  print("Size = ", n_read, " ; RESULT = ", buf.value)
#+END_SRC

Wrapper for function B:

#+BEGIN_SRC python 
  print("\n EXPERIMENT 2 => Call square_root_as_stringB")
  print("=============================================")
  dll.square_root_as_stringB.argtypes = [ ctypes.c_double,
                                          CString,
                                          ctypes.c_size_t ]
  dll.square_root_as_stringB.restype  = ctypes.c_size_t

  x = 200.45
  required_size = dll.square_root_as_stringB(x, ctypes.c_char_p(0), 0)
  buf           = ctypes.create_string_buffer(required_size)
  dll.square_root_as_stringB(x, buf, required_size)
  print(" RESULT = ", buf.value)
#+END_SRC

Wrapper for function C: 

#+BEGIN_SRC python  
  print("\n EXPERIMENT 3 => Call square_root_as_stringC")
  print("=============================================")

  dll.square_root_as_stringC.argtypes = [ ctypes.c_double ]
  dll.square_root_as_stringC.restype  = ctypes.c_char_p

  dll.cstring_delete.argtypes = [ ctypes.c_char_p ]
  dll.cstring_delete.restype  = CVoid

  hCString = dll.square_root_as_stringC(167.42)
  print(" RESULT = ", hCString)
#+END_SRC

 *Program output* 

#+BEGIN_SRC sh 
  $ python3 cstr.py 

   EXPERIMENT1 => Call square_root_as_stringA
  =============================================
  Size =  55  ; RESULT =  b'The square root of x = 100.450000 is equal to 10.022475'

   EXPERIMENT 2 => Call square_root_as_stringB
  =============================================
   RESULT =  b'The square root of x = 200.450000 is equal to 14.158037'

   EXPERIMENT 3 => Call square_root_as_stringC
  =============================================
   RESULT =  b'The square root of x = 167.420000 is equal to 12.939088'
#+END_SRC
** Python native module (shared library)
*** Overview  

Many programming languages provide a C-native interfaces such as
Python C-API or Java Native Interface where it is possible to create
native-code libraries in C without overhead of virtual machine code
interpretation. The advantage of a code for a C native interface
(native API) of some programming language is the easier usage and
better integration with the target language. The drawback for
developing some native library with this approach is that the library
will be tight coupled with the language native C API, as a result, it
will be hard to port or call the code from other programming
language. In addition, it may require deeper knowledge of the native C
API which often is not well documented. 

Other approaches for developing shared libraries for Python native
API:

 + *Pybind11 header-only library* => Provides a C++-friendly syntax and
   interface to the Python native C API. It allows building Python
   native modules and port C++ code in a easier and faster way than
   dealing directly with Python C-API.

 + *SWIG wrapper generator* => SWIG can parse C++ headers and interface
   files and generate C++ binding code to the native API of many
   programming languages such as Python, Ruby, Java and so on.

 + *Cython* => Python-like language that compile to C code (generate
   C-code). The disadvantage is the tight coupling to the Python C-API.

Further documentation and reading: 

Documentation: 
 
 + [[https://docs.python.org/3/howto/cporting.html][Porting Extension Modules to Python 3 — Python 3.7.2 documentation]]
 + [[https://pythonextensionpatterns.readthedocs.io/en/latest/parsing_arguments.html][Parsing Python Arguments — Python Extension Patterns 0.1.0 documentation]]
 + [[http://docs.activestate.com/activepython/3.6/python/c-api/arg.html][ActivePython 3.6.6 Documentation]]
 + [[https://docs.python.org/3/extending/index.html][Extending and Embedding the Python Interpreter — Python 3.7.2 documentation]]

General:

 + [[https://docs.python.org/3/c-api/structures.html][Common Object Structures — Python 3.7.2 documentation]]

 + [[https://docs.scipy.org/doc/numpy/reference/c-api.types-and-structures.html][Python Types and C-Structures — NumPy v1.15 Manual]]

 + [[https://docs.python.org/2.3/api/stringObjects.html][7.3.1 String Objects]]

 + [[https://docs.python.org/2/c-api/code.html][Code Objects — Python 2.7.15 documentation]]

 + [[https://docs.python.org/2/c-api/veryhigh.html#c.PyRun_SimpleFileExFlags][The Very High Level Layer — Python 2.7.15 documentation]]

 + [[https://stackoverflow.com/questions/3789881/create-and-call-python-function-from-string-via-c-api][Create and call python function from string via C API - Stack Overflow]]

 + [[https://www6.software.ibm.com/developerworks/education/l-pythonscript/l-pythonscript-ltr.pdf][Embed Python scripting in C applications]]

 + [[https://stackoverflow.com/questions/4922365/python-c-api-pyeval-callfunction][Python C API: PyEval_CallFunction? - Stack Overflow]]

 + [[http://effbot.org/pyfaq/how-do-i-call-an-object-s-method-from-c.htm][How do I call an object's method from C?]]

Creating a native Python module: 
 + [[https://docs.microsoft.com/en-us/visualstudio/python/working-with-c-cpp-python-in-visual-studio?view=vs-2017][Write C++ extensions for Python - Visual Studio | Microsoft Docs]]
 + [[http://yizhang82.me/python-interop-capi][Calling C functions from Python - part 2 - writing CPython extensions using Python/C API | yizhang82’s blog]]

Python (CPython) debugging with GDB:
 + [[https://devguide.python.org/gdb/][22. gdb Support — Python Developer's Guide]]
 + [[https://docs.microsoft.com/en-us/visualstudio/python/debugging-mixed-mode-c-cpp-python-in-visual-studio?view=vs-2017][Mixed-mode debugging for Python - Visual Studio | Microsoft Docs]]

Reverse engineering: 
 + [[https://recon.cx/2008/a/aaron_portnoy-ali_rizvi_santiago/slides.pdf][Reverse Engineering Dynamic Languages - A Focus on Python]]

*** Module Code 

 *Module Source:*

 + File: [[file:src/dlls/mymodule.cpp][file:src/dlls/mymodule.cpp]]
 + Gist: [[https://gist.github.com/caiorss/bc7dc373d87b828029eb0e0ec048d91e][mymodule.cpp]] 

 *Compilation:*

#+BEGIN_SRC sh 
  # GCC - GNU C/C++ compiler 
  $ g++ mymodule.cpp -o mymodule.so -g -std=c++1z -fPIC -shared -I/usr/include/python3.6m  
  
  # Clang LLVM 
  $ clang++ mymodule.cpp -o mymodule.so -g -std=c++1z -fPIC -shared -I/usr/include/python3.6m  
#+END_SRC

Header files: 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <functional>
  #include <iomanip>

  /// C-API header to Python Native Interface API, similar to Java JNI
  /// (Java Native Interface)
  #include <Python.h>

  #ifdef _WIN32
    #include <process.h> // Exports _getpid()
  #else
    #include <unistd.h>  // Exports getpid()
  #endif 
#+END_SRC


Global object for DLL initialization (optional): 

 + The global object dllinit_hook is used for logging to stdout when
   the DLL is loaded or unloaded by the python process. 

#+BEGIN_SRC cpp 
  struct DLLInitialization
  {
       DLLInitialization(){
           int pid;
           #ifdef _WIN32
              pid = _getpid();
           #else
              pid = getpid();       
           #endif 
           std::cerr << " [TRACE] Python module DLL loaded by process PID = <"
                             << pid << "> "
                             << std::endl;
           std::cerr << " [TRACE] Attach the debugger with: $ gdb -pid=" << pid << "\n";
       }
       ~DLLInitialization(){
           std::cerr << " [TRACE] DLL native DLL unloaded OK." << std::endl;
       }	
  };

  DLLInitialization dllinit_hook;
#+END_SRC

Exposed functions declarations: 

#+BEGIN_SRC cpp 
  PyObject*
  exposedFunction(PyObject* self, PyObject* args);

  PyObject* testArguments(PyObject* self, PyObject* args);

  auto printRange(PyObject* self, PyObject* args) -> PyObject*;
  auto taylorSeriesExp(PyObject* self, PyObject* args) -> PyObject*;
  PyObject* tabulateFunction(PyObject* self, PyObject* args);
#+END_SRC

Table of exported functions to the Python module: 

#+BEGIN_SRC cpp 
  static PyMethodDef ModuleFunctions [] =
  {
       { "exposedFunction", exposedFunction, METH_VARARGS,
         "Documentation or docstring of function exposedFunction1." }

       ,{"testArguments", testArguments, METH_VARARGS,
         "Test python arguments: Signature testArguments(int, float, double, const char*)"}

       // Function without docstring: printRange(int i, double x)
       ,{ "printRange", printRange, METH_VARARGS, nullptr }

       ,{ "taylorSeriesExp", &taylorSeriesExp, METH_VARARGS,
          "taylorSeriesExp(double x, size_t maxiter, double tol) -> double"
          "\n Computes exponential of a given value with taylor serie approximation."
          "\n Formula reference:  https://www.mathsisfun.com/algebra/taylor-series.html"
       }
       ,{"tabulateFunction", tabulateFunction, METH_VARARGS,
           "Tabulate some mathematical function or callable object"}
       // Sentinel value used to indicate the end of function listing.
       // All function listing must end with this value.
       ,{nullptr, nullptr, 0, nullptr}									
  };
#+END_SRC

Module definition: 

#+BEGIN_SRC cpp 
  /* Module definition */
  static struct PyModuleDef ModuleDefinitions {
      PyModuleDef_HEAD_INIT,
     // Module name as string 
     "mymodule",
     // Module documentation (docstring)
     "A sample C++ native-code module for python3.",
     -1,
     // Functions exposed to the module 
     ModuleFunctions
  };

#+END_SRC

Module initialization function: 

 + Note: This function must contain the name in the format
   ~PyInit_<MODULE NAME>~ where module name is the same name as the
   module file name <MODULE NAME>.so (Linux) or <MODULE NAME>.pyd on
   Windows. 

#+BEGIN_SRC cpp 
  /** Module Initialization function: must have this name schema
   ,*  PyInit_<ModuleName> where ModuleName is the same base name of the 
   ,*  shared library ModuleName.so (on Linux) or ModuleName.pyd (on Windows)
   ,*/
  PyMODINIT_FUNC PyInit_mymodule(void)
  {
     Py_Initialize();
     PyObject* pModule = PyModule_Create(&ModuleDefinitions);
     PyModule_AddObject(pModule, "version", Py_BuildValue("s", "version 0.1-Alpha"));
     return pModule;
  }
#+END_SRC

 *Module Functions Implementations*

All functions exposed to the Python C-API must have the same type
signature of the function pointer PyExposedFunction or the same type
signature of the function MyExposedFunction.

#+BEGIN_SRC cpp 
   using PyExposedFunction = PyObject* (*) (PyObject* self, PyObject* args)

   // Example: 
   PyObject* MyExposedFunction(PyObject* self, PyObject* args )
   {
      // On Failure return null 
      return nullptr;  
 
      return /* Some instance of PyObject */;
  }
#+END_SRC

Notes:

  + The function takes always two arguments self, and args (tuple
    object containing arguments passed to the function)
  + The exposed function always return an object PyObject.
  + All Python objects are heap-allocated.
  + In Python everything are objects: integers, double, classes,
    functions and so on.
  + Functions exposed to Python runtime should not throw a C++
    exceptions, instead they should return null (nullptr) that causes
    a runtime error or exception on Python side. 

 *Function: exposedFunction*

  + Function that takes a void argument and returns nothing.

#+BEGIN_SRC cpp 
  PyObject*
  exposedFunction(PyObject* self, PyObject* args)
  {
       std::cout << " =>> Hello word Python from C++ side." << "\n";
       // All python functions that returns anything
       // should end with this macro 
       Py_RETURN_NONE;
  }
#+END_SRC

 *Function: testArguments*

 + Function that takes many arguments used to demonstrate how to
   extract tuple arguments. 

#+BEGIN_SRC cpp 
  PyObject* testArguments(PyObject* self, PyObject* args)
  {
        int         abool;
        int         aint;
        float       afloat;
        double      adouble;
        const char* aword;
        // Parse function arguments 
        if(!PyArg_ParseTuple(args, "pifds", &abool, &aint, &afloat, &adouble, &aword))
            return nullptr;

        std::cerr << " Function: [" << __FUNCTION__ << "]" 
                  << " ==> Number of arguments = " << PyTuple_GET_SIZE(args) << "\n";

        std::string str = aword;
        str = "'Received string = " + str + "'";

        std::cout << " Received Python Arguments " << "\n";
        std::cout << std::boolalpha;
        std::cout << "abool[bool] = " << (bool) abool << "\n"
                          << " abool[int] = " << abool << "\n"
                          << "      aint  = " << aint << "\n"
                          << "     afloat = " << afloat << "\n"
                          << "    adouble = " << adouble << "\n"
                          << "    aword   = " << str << "\n"
                          << "\n";		
        return Py_BuildValue("s", str.data());
  }

#+END_SRC

Function PyArg_ParseTuple:

 + The function PyArg_ParseTuple is used for extracting function
   arguments from the tuple object (args).

 + The letters in the string parameter "pifds" means:
   + p => Extract first argument from tuple object as boolean (integer 0 or 1)
   + i => Extract second argument from tuple object as integer
   + f => Extract third argument as float (float point 32 bits)
   + d => Extract fourth argument as double (float point 64 bits)
   + s => Extract fith argument as string.

 + If the function fails, it must return null which causes a runtime
   error on Python side. 

#+BEGIN_SRC cpp 
   int         abool;
   int         aint;
   float       afloat;
   double      adouble;
   const char* aword;
   // Parse function arguments 
   if(!PyArg_ParseTuple(args, "pifds", &abool, &aint, &afloat, &adouble, &aword))
       return nullptr;
#+END_SRC

Function Py_BuildValue("s", str.data());

 + This function is used for building return values to the python
   side. It can return one or more values as tuple. 
 
#+BEGIN_SRC cpp 
  // Return string 
  return Py_BuildValue("s", str.data());

  // Return integer 
  return Py_BuildValue("i", 1000);

  // Return float  
  return Py_BuildValue("f", 3.465);

  // Return double   
  return Py_BuildValue("d", 140.346);
#+END_SRC

 *Function: printRange*
 
 + Pseudo-Python signature: printRange(int n, float x) => void

#+BEGIN_SRC cpp 
   auto printRange(PyObject* self, PyObject* args) -> PyObject*
   {
       std::cerr << " =>> Printing numeric range " << "\n";	
       int    n;
       float  x;
       // Extract function argument from tuple argument object
       // "if" => i - Extract integer
       //      => f - Extract float (IEEE754 32 bits float point)
       if(!PyArg_ParseTuple(args, "if", &n, &x)){
           PyErr_SetString(PyExc_RuntimeError, "Invalid argument");
           // Always return null on failure 
           return nullptr; 
       }

       if(n <= 0){
           PyErr_SetString( PyExc_RuntimeError
                           ,"Invalid argument: n supposed to be greater than zero.");
           return nullptr;
       }	

       for(int k = 0; k < n; k++)
          std::cout << " k[" << k << "] = " << 3 * k + x << "\n";	
       Py_RETURN_NONE;
   }

#+END_SRC

 *Function: taylorSeriesExp*

 + This function computes the exponential function approximation using its taylor
   series expansion. Formula at: [[https://www.mathsisfun.com/algebra/taylor-series.html][taylor series]]

#+BEGIN_SRC cpp 
  auto taylorSeriesExp(PyObject* self, PyObject* args) -> PyObject*
  {
       double x;
       size_t maxiter;  // Maximum number of iterations 
       double tol;      // Tolerance

       // Parse function arguments 
       if(!PyArg_ParseTuple(args, "did", &x, &maxiter, &tol))
               return nullptr;

       // Validate function arguments

       if(tol <= 0 || tol > 1.0){
               PyErr_SetString( PyExc_RuntimeError
                              ,"Invalid tolerance, expected in range (0, 1]");
               return nullptr;
       }

       // Compute exponential taylor series available at
       // https://www.mathsisfun.com/algebra/taylor-series.html
       unsigned long factorial = 1;
       double        xpower    = 1.0;
       double        sum       = 0.0;
       double        term      = 0.0;
       size_t        idx       = 1;
       do{
            term      = xpower / factorial;
            sum       = sum + term;
            xpower    = xpower * x ;
            factorial = factorial * idx;		
            idx++;
       } while(idx <= maxiter && std::abs(term) > std::abs(sum) * tol );
       // Return float point constnat NAN (Not a Number)
       if(idx >= maxiter){
               std::cerr << " [ERROR] Series does not converge." << "\n";
               return Py_BuildValue("d", NAN);
       }
       return Py_BuildValue("d", sum);
  }
#+END_SRC

 *Function: tabulateFunction* 

 + This function takes a callable object (callback) which can be a
   function, lambda function, callable object (object with method ~__call__~) and so on.

Pseudo Python method signature using C++ notation: 

#+BEGIN_SRC cpp 
  using Callback = std::function<double (double)>;
  void tabulateFunction(Callback callback, double xmin, double xmax, double step)
#+END_SRC

Function code: 

#+BEGIN_SRC cpp 
  PyObject* tabulateFunction(PyObject* self, PyObject* args)
  {
       PyObject* pObj = nullptr;
       double xmin, xmax, xstep;

       if(!PyArg_ParseTuple(args, "Oddd", &pObj, &xmin, &xmax, &xstep))
            return nullptr;
       if(pObj == nullptr) {
            PyErr_SetString(PyExc_RuntimeError, "Error: invalid None object.");
            return nullptr;
       }
       PyObject* pArgs  = nullptr;
       PyObject* pResult = nullptr;
       double y = 0.0;

       std::cout << std::fixed << std::setprecision(4);

       std::cout << "Tabulating range: "
                 << " ; xmin = " << xmin
                 << " ; xmax = " << xmax
                 << " ; step = " << xstep
                 << "\n";

       for(double x = xmin; x <= xmax; x += xstep )
       {
            pArgs  = Py_BuildValue("(d)", x);
            pResult = PyEval_CallObject(pObj, pArgs);
            y = PyFloat_AsDouble(pResult);
            if(PyErr_Occurred() != nullptr){
                    PyErr_SetString(PyExc_RuntimeError, "Error: Invalid float point.");
                    return nullptr;
            }
            std::cout << std::setw(8) << x << std::setw(10) << y  << "\n";
       }
       Py_RETURN_NONE;
  }

#+END_SRC

Extract python callable object (callback) pObj and the parameters
xmin, xmax and xstep: 

#+BEGIN_SRC cpp 
    PyObject* pObj = nullptr;
    double xmin, xmax, xstep;
    // Extract parameters 
    // O => pObj 
    // d => xmin 
    // d => xmax 
    if(!PyArg_ParseTuple(args, "Oddd", &pObj, &xmin, &xmax, &xstep))
         return nullptr;
#+END_SRC

Annotated code block in the for-loop: 

#+BEGIN_SRC cpp 
  // Argument (tuple object) of callable object 
  pArgs  = Py_BuildValue("(d)", x);

  // Call callable object (method __call__)
  pResult = PyEval_CallObject(pObj, pArgs);

  // Try extracting result as double 
  y = PyFloat_AsDouble(pResult);

  // Check whether any error has happened and abort the operation in this case. 
  if(PyErr_Occurred() != nullptr){
       PyErr_SetString(PyExc_RuntimeError, "Error: Invalid float point.");
       return nullptr;
  }
  // Display table row 
  std::cout << std::setw(8) << x << std::setw(10) << y  << "\n";
#+END_SRC
*** Loading the native module 

Compile the native module: [[https://gist.github.com/caiorss/bc7dc373d87b828029eb0e0ec048d91e][mymodule.cpp]] => Generate file mymodule.so 

#+BEGIN_SRC sh 
 $ clang++ mymodule.cpp -o mymodule.so -g -std=c++1z -fPIC -shared -I/usr/include/python3.6m  
#+END_SRC

Check generated file: 

#+BEGIN_SRC sh 
  $ file mymodule.so 

  $ du -h mymodule.so 
  136K	mymodule.so
  136K	total
#+END_SRC

View symbols: 

#+BEGIN_SRC sh 
  $ nm  mymodule.so 
  0000000000209518 B __bss_start
  0000000000005500 t __clang_call_terminate
  0000000000209518 b completed.7347
                   U __cxa_atexit@@GLIBC_2.2.5
                   U __cxa_begin_catch@@CXXABI_1.3
                   U __cxa_call_unexpected@@CXXABI_1.3
                   U __cxa_end_catch@@CXXABI_1.3
                   w __cxa_finalize@@GLIBC_2.2.5
                   U __cxa_rethrow@@CXXABI_1.3
  0000000000004160 t __cxx_global_var_initmymodule.cpp_
  00000000000041a0 t __cxx_global_var_initmymodule.cpp_.1
  00000000000041f0 t deregister_tm_clones
  000000000020951a B dllinit_hook
  .. ... ... ... ... ... ... ... 
#+END_SRC

Load module in Python 3 REPL:

#+BEGIN_SRC python 
  $ python3
  Python 3.7.1 (default, Dec 14 2018, 19:28:38) 
  [GCC 7.3.0] :: Anaconda, Inc. on linux
  Type "help", "copyright", "credits" or "license" for more information.
  >>> 
  >>> import mymodule as a
   [TRACE] Python module DLL loaded by process PID = <5236> 
   [TRACE] Attach the debugger with: $ gdb -pid=5236
  >>> 
  >>> 
#+END_SRC

Module Docstring (documentation): 

#+BEGIN_SRC python 
  >>> help(a)
  Help on module mymodule:

  NAME
      mymodule - A sample C++ native-code module for python3.

  FUNCTIONS
      exposedFunction(...)
          Documentation or docstring of function exposedFunction1.

      printRange(...)

      tabulateFunction(...)
          Tabulate some mathematical function or callable object

      taylorSeriesExp(...)
          taylorSeriesExp(double x, size_t maxiter, double tol) -> double
          Computes exponential of a given value with taylor serie approximation.
          Formula reference:  https://www.mathsisfun.com/algebra/taylor-series.html

      testArguments(...)
          Test python arguments: Signature testArguments(int, float, double, const char*)

  DATA
      version = 'version 0.1-Alpha'

  FILE
      /home/archbox/Documents/projects/cpp-programming.cpp/src/dlls/mymodule.so
#+END_SRC

Module version: 

#+BEGIN_SRC python
  >>> a.version
  'version 0.1-Alpha'
  >>> 
#+END_SRC

Call function exposedFunction()

#+BEGIN_SRC python 
  >>> a.exposedFunction()
   =>> Hello word Python from C++ side.
  >>> 
#+END_SRC

Call function testArguments:

#+BEGIN_SRC python 
  >>> s1 = a.testArguments(False, 100, 10.9361, 0.344, "from Python to C++")
   Function: [testArguments] ==> Number of arguments = 5
   Received Python Arguments 
  abool[bool] = false
   abool[int] = 0
        aint  = 100
       afloat = 10.9361
      adouble = 0.344
      aword   = 'Received string = from Python to C++'

  >>> s1
  "'Received string = from Python to C++'"
  >>> 

  >>> 
  >>> s2 = a.testArguments(True, 90, -0.56e6, 9.344e5, "something else more")
   Function: [testArguments] ==> Number of arguments = 5
   Received Python Arguments 
  abool[bool] = true
   abool[int] = 1
        aint  = 90
       afloat = -560000
      adouble = 934400
      aword   = 'Received string = something else more'

  >>> s2
  "'Received string = something else more'"
#+END_SRC

Call function printRange()

#+BEGIN_SRC python
  >>> a.printRange(5, 4.5)
   =>> Printing numeric range 
   k[0] = 4.5
   k[1] = 7.5
   k[2] = 10.5
   k[3] = 13.5
   k[4] = 16.5
  >>> 
  >>> a.printRange(-5, 4.5)
   =>> Printing numeric range 
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  RuntimeError: Invalid argument: n supposed to be greater than zero.
  >>> 
  >>> a.printRange(0, 4.5)
   =>> Printing numeric range 
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  RuntimeError: Invalid argument: n supposed to be greater than zero.
  >>> 
  >>> 
#+END_SRC

Call function taylorSerieExp: 

#+BEGIN_SRC python 
  >>> help(a.taylorSeriesExp)
  Help on built-in function taylorSeriesExp in module mymodule:

  taylorSeriesExp(...)
      taylorSeriesExp(double x, size_t maxiter, double tol) -> double
      Computes exponential of a given value with taylor serie approximation.
      Formula reference:  https://www.mathsisfun.com/algebra/taylor-series.html

  >>> import math

  # Exact value 
  >>> math.exp(3.5)
  33.11545195869231

  # Approximation 
  >>> a.taylorSeriesExp(3.5, 10, 0.001)
   [ERROR] Series does not converge.
  nan
  >>> a.taylorSeriesExp(3.5, 100, 0.001)
  33.10588185071678
  >>> 

  # Exact value 
  >>> math.exp(5.0)
  148.4131591025766

  # Approximation 
  >>> a.taylorSeriesExp(5.0, 100, 0.001)
  148.37958007973663

  >>> a.taylorSeriesExp(5.0, 100, 0.0001)
  148.41021027504306
  >>> 
#+END_SRC

Call function: tabulateFunction which takes a callable object as
argumet. 

#+BEGIN_SRC python 
>>> help(a.tabulateFunction)
Help on built-in function tabulateFunction in module mymodule:

tabulateFunction(...)
    Tabulate some mathematical function or callable object
#+END_SRC

Pass ordinary functions: 
 + Note: Python ordinary functions are objects with ~__call__~ method: 

#+BEGIN_SRC cpp 
  import math 

  >>> math.sqrt.__call__(25)
  5.0

  >>> math.sqrt.__call__(125)
  11.180339887498949
  >>> 

  >>> a.tabulateFunction(math.exp, -5.0, 5.0, 1.0)
  Tabulating range:  ; xmin = -5.0000 ; xmax = 5.0000 ; step = 1.0000
   -5.0000    0.0067
   -4.0000    0.0183
   -3.0000    0.0498
   -2.0000    0.1353
   -1.0000    0.3679
    0.0000    1.0000
    1.0000    2.7183
    2.0000    7.3891
    3.0000   20.0855
    4.0000   54.5982
    5.0000  148.4132
  >>> 

  >>> a.tabulateFunction(math.sqrt, 0.0, 25.0, 5.0)
  Tabulating range:  ; xmin = 0.0000 ; xmax = 25.0000 ; step = 5.0000
    0.0000    0.0000
    5.0000    2.2361
   10.0000    3.1623
   15.0000    3.8730
   20.0000    4.4721
   25.0000    5.0000
#+END_SRC

Pass lambda functions: 

#+BEGIN_SRC cpp 
  >>> a.tabulateFunction(lambda x: x, 0.0, 25.0, 4.0)
  Tabulating range:  ; xmin = 0.0000 ; xmax = 25.0000 ; step = 4.0000
    0.0000    0.0000
    4.0000    4.0000
    8.0000    8.0000
   12.0000   12.0000
   16.0000   16.0000
   20.0000   20.0000
   24.0000   24.0000
  >>> 

  >>> a.tabulateFunction(lambda x: 3 * x + 5, 0.0, 25.0, 4.0)
  Tabulating range:  ; xmin = 0.0000 ; xmax = 25.0000 ; step = 4.0000
    0.0000    5.0000
    4.0000   17.0000
    8.0000   29.0000
   12.0000   41.0000
   16.0000   53.0000
   20.0000   65.0000
   24.0000   77.0000
#+END_SRC

Class LinearFun: 

#+BEGIN_SRC python 
  class LinearFun:
      def __init__(self, a, b):
          self.a = a
          self.b = b
      def __call__(self, x):
          return self.a * x + self.b
      def eval(self, x):
          return self.a * x + self.b
#+END_SRC

Pass a callable object: 

#+BEGIN_SRC python   
  >>> lfun = LinearFun(5, 4)
  >>> lfun(3)
  19
  >>> lfun(6)
  34
  >>> lfun.eval(3)
  19
  >>> lfun.eval(6)
  34

  >>> a.tabulateFunction(lfun, 0.0, 25.0, 4.0)
  Tabulating range:  ; xmin = 0.0000 ; xmax = 25.0000 ; step = 4.0000
    0.0000    4.0000
    4.0000   24.0000
    8.0000   44.0000
   12.0000   64.0000
   16.0000   84.0000
   20.0000  104.0000
   24.0000  124.0000
  >>> 
  >>> 

  >>> a.tabulateFunction(lfun.eval, 0.0, 25.0, 4.0)
  Tabulating range:  ; xmin = 0.0000 ; xmax = 25.0000 ; step = 4.0000
    0.0000    4.0000
    4.0000   24.0000
    8.0000   44.0000
   12.0000   64.0000
   16.0000   84.0000
   20.0000  104.0000
   24.0000  124.0000

  >>> lfun.a 
  5
  >>> lfun.a  = 0
  >>> 
  >>> a.tabulateFunction(lfun.eval, 0.0, 25.0, 4.0)
  Tabulating range:  ; xmin = 0.0000 ; xmax = 25.0000 ; step = 4.0000
    0.0000    4.0000
    4.0000    4.0000
    8.0000    4.0000
   12.0000    4.0000
   16.0000    4.0000
   20.0000    4.0000
   24.0000    4.0000
#+END_SRC



