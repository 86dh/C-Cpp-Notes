#+INCLUDE: theme/style.org
#+TITLE: Shared Libraries - Binary Components
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

 - [[wiki:index][Index]]

* Shared Libraries - Binary Components
** Overview 

Shared libraries are compiled object-code exporting functions, data
structures and classes which can be used by many different
programs. They provide many benefits such as: faster compilation time;
less disk space usage since each program using the library do not
need a copy of the library source code or its compiled-code; ability
to update the library and provide security fixes to client
applications without recompilation, just by replacing the library
file. 

On Windows, shared libraries are called DLLs which stands for Dynamic
Linked Libraries, on Unix-like operating systems such as Linux, BSD
and MacOSX, they are called SO - shared objects or DSO - dynamic
shared objects. 

#+CAPTION: Comparison of shared libraries across different operating systems 
| Operating | Long Name               | Short name | File          | Binary Format                         |
| System    |                         |            | Extension     |                                       |
|-----------+-------------------------+------------+---------------+---------------------------------------|
| Windows   | Dynamic Linked Library  | DLL        | .dll          | PE32/PE64 - Portable Executable       |
| Linux     | (Dynamic) Shared Object | DSO or SO  | .so           | ELF or ELF64 (for 64 bits processors) |
| BSD       | (Dynamic) Shared Object | DSO or SO  | .so           | ELF or ELF64                          |
| MacOSX    | -                       | dylib      | .dylib or .so | MachO                                 |
|-----------+-------------------------+------------+---------------+---------------------------------------|

 + Shared libraries are similar to executables, however they do not
   have the main() function entry point.

In addition to C and C++, shared libraries, containing functions with
C-linkage, can also be used as binary components (libraries) and be
consumed from higher level programming languages such as Python, Ruby,
Java or C# through some foreign-function interface. In Python
C-functions can be imported from shared libraries using the [[https://docs.python.org/3/library/ctypes.html][cytpes]]
library; in C# C-functions can be consumed using the P-invoke API and
in Java it is possible to use C-functions from shared libraries using
the JNI (Java Native Interface) or JNA, which is easier to use.

Note: 
 + Shared libraries are specific to a particular operating system and
   are not part of C++ standard.

** Example 1 - Shared Library libtest.dll - DLLs on Windows
*** Overview 

 *Source:*

Shared library Source Code

 + File: [[file:dll-shared-library/example-windows1/libtest.cpp][file:dll-shared-library/example-windows1/libtest.cpp]]
 + File: [[file:dll-shared-library/example-windows1/libtest.hpp][file:dll-shared-library/example-windows1/libtest.hpp]]

Sample Client C++ Program:

 + File: [[file:dll-shared-library/example-windows1/client1.cpp][file:dll-shared-library/example-windows1/client1.cpp]]  

*** Header macros 

Sources:
 + File: [[file:dll-shared-library/example-windows1/libtest.cpp][file:dll-shared-library/example-windows1/libtest.cpp]]
 + File: [[file:dll-shared-library/example-windows1/libtest.hpp][file:dll-shared-library/example-windows1/libtest.hpp]]

 *teslib.hpp / Heade File - Macros*

The header files uses the following macros to reduce the boilerplate
necessary to export the library functions and classes. 

 + file: libstes.hpp => Macros for exporting functions and classes. 

#+BEGIN_SRC cpp
  #ifndef _WIN32
    // If not compiled for Windows, remove declspec directive.
    #define __declspec(param)  
  #endif 

  #define EXPORT_CPP 	__declspec(dllexport)
 
  #ifdef __cplusplus
    // Indicat that a given symbol/function has C-linkage and
    // does not have name mangling. 
    #define EXPORT_C extern "C" __declspec(dllexport)
  #else
    // If a C-compiler uses this header, remove 'extern "C"'
    #define EXPORT_C  __declspec(dllexport)
  #endif 
#+END_SRC

*** Namespace Linalg 

 *Functions of Namespace Linalg* 

Namespace containing sample linear algebra functions, the function norm
computes an Euclidean norm of a N-dimension vector, the function
linTransform computes a linear transformation performing the
computation v[i] * a + b for each vector element. 

On Windows, all DLL symbols, such as functions, variables and clases,
are private by default, they are not exported by default as happens in
Unix-like OSes shared libraries. Therefore, in order to a function be
exported in a Windows shared library, it is necessary to use the MSVC or visual C++
compiler extension ~__declspec(dllexport)~ before the function declaration.
 
 + Interface => File: *libtest.hpp*

#+BEGIN_SRC cpp 
  /** The macro __cplusplus is used for allowing this 
   ,* header to be used from 'C'. If a C compiler is used
   ,* all definitions inside this #ifdef are discarded.
   ,*/
  #ifdef __cplusplus
  namespace Linalg {
          EXPORT_CPP double norm(const std::vector<double>& xs);

          EXPORT_CPP std::vector<double> linTransform(
                  double a,
                  double b,
                  std::vector<double>& xs
                  );

          EXPORT_CPP
          std::ostream&
          printVector(std::ostream& os, std::vector<double>& xs);	
  }
  #endif 
#+END_SRC

The macro ~EXPORT_CPP~ expands to: 

#+BEGIN_SRC cpp
  EXPORT_CPP double norm(const std::vector<double>& xs);
  // Macro EXPORT_CPP expansion 
  __declspec(dllexport) double norm(const std::vector<double>& xs);
#+END_SRC

The compiler directives *#ifdef __cplusplus ... #endif* are used for
disabling this code block when the header is used by a C-compiler as
the C-language does not support classes, namespaces and many other C++
features. 

 + Implementation => file: *libtest.cpp*

#+BEGIN_SRC cpp 
   // Linear algebra tools 
   namespace Linalg{
        __declspec(dllexport)
        double norm(const std::vector<double>& xs){
           double sum = 0.0;
           for(const auto& x : xs) sum += x * x;
               return std::sqrt(sum);
        }

         __declspec(dllexport)
        std::vector<double>
        linTransform(double a, double b, std::vector<double>& xs){
            std::vector<double> out(xs.size());
            ... ... .... 
        }

       ... ... 
   }
#+END_SRC

*** C-interface of Namespace Linalg 

 *C-interface of Namespace Linalg* 

A C-interface is necessary for ensuring that the DLL can be called
from a C-program or a foreign function interface of a higher level
language. 

 + File: *libtest.hpp* => Function declaration. 

#+BEGIN_SRC cpp 
  // ======= C-interface for Linalg namespace =========//
  /* ----- C-Wrappers for Linalg namespace ---- */

  /** Handle or opaque pointer for std::vector<double> */
  typedef void* hVectorD;

  extern "C"  __declspec(dllexport)
  double testlib_vectorD_Linalg_norm(hVectorD hv);

  extern "C"  __declspec(dllexport)
  void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv);
#+END_SRC

The *extern "C"* statements are necessary to compile the functions with
_C-linkage_, it means without _name mangling_ (aka name decoration). In
every C program, the function symbols are generally the same as their
names. However, as C++ supports templates and function overloading,
many functions can have the same, with different type signatures,
C++ compiler mangles or decorates function names with a different
schema to make the symbol unique. 

Functions with C-linkage, can only use C-compatible types or PODs
types (Plain Old Data). Therefore, they cannot use STL container,
std::vector, std::string and so on. 

The statement ~__declspec(dllexport)~ is necessary to make annotated
functions' symbols visible. On Unix-like systems and Linux, it is not
necessary as it is MSVC (cl.exe) compiler extension. 


 + File: *libtest.cpp* => C-interface function implementations. 

The type synonym hVectorD is handle or a opaque poiter for the type
std::vector<double>. It is a workaround, to pass std::vector<double>
accross a DLL functions with C-linkage and use std::vector<double>
from C programs or foreign function interfaces. 

#+BEGIN_SRC cpp 
  // Handler for double vector 
  using hVectorD = void*;
  using pVectorD = std::vector<double>*;

  /** C-wrapper for vector<double> constructor */
  extern "C" __declspec(dllexport)
  hVectorD
  testlib_vectorD_make0(size_t n, double x){
     return new std::vector<double>(n, x);
  }
    ... ... ...     ... ... ...     ... ... ... 

  /** C-wrapper for vector<double> destructor */
  extern "C" __declspec(dllexport)
  void
  testlib_vectorD_delete(hVectorD hv){
    delete reinterpret_cast<pVectorD>(hv);
  }

  /** C-wrapepr for Linalg::norm function */
  extern "C" __declspec(dllexport)
  double
  testlib_vectorD_Linalg_norm(hVectorD hv){
     return Linalg::norm(*reinterpret_cast<pVectorD>(hv));
  }
    ... ... ...     ... ... ...     ... ... ... 

#+END_SRC






*** Non-polymorphic Class - SampleClass 

 + File: *libtest.hpp* => Class declaration. 

In order to a class be exported in a Windows' shared library, it
requires the annotation ~__declspec(dllexport)~.

Note: It will not be possible to compiled client program using this
class with a compiler different from the used to build the shared
library libtest.dll. It happens because, the C++ ABI - Application
Binary Interface is not the same accross different compilers. If the
DLL is compiled with MSVC, the only way to use this class from a
program compiled using MingW or even a different version of MSVC is
by using a C-interface (functions with C-linkage) and opaque
pointers (void* pointers). 

#+BEGIN_SRC cpp 
  // ======= Non-polymorphic class exported by DLL =========//
  #ifdef __cplusplus
  // Non-polymorphic class 
  class __declspec(dllexport) SampleClass{
  public:
          SampleClass();
          SampleClass(const std::string& name);	
          ~SampleClass();
          std::string getName() const;
          int get();
          void set(int n);	
  private:
          std::string m_name;
          int m_counter;	
  };
  #endif 
#+END_SRC

 + File: *libtest.cpp* => Class implementation. 

#+BEGIN_SRC cpp 
  SampleClass::SampleClass(const std::string& name)
     : m_name(name), m_counter(0)
  {
      std::cout << " Instance created with name = " << m_name << std::endl;
  }
  /** Delegated constructor on right-hand-side */
  SampleClass::SampleClass(): SampleClass("unnamed"){}   
	
  SampleClass::~SampleClass(){
      std::string text = std::string("SampleClass => name = ") + m_name +  " deleted";
      DbgTrace(text);
  }

  std::string SampleClass::getName() const {
      return m_name;
  }
  int SampleClass::SampleClass::get(){		
      return m_counter;
  }
  void SampleClass::set(int n){
      std::cout << " Counter set to value = " << n << std::endl;
      m_counter = n;
  }	
#+END_SRC



** Shared Libraries on Linux 
