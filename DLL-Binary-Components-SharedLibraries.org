#+INCLUDE: theme/style.org
#+TITLE: Shared Libraries - Binary Components
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

 - [[wiki:index][Index]]

* Shared Libraries - Binary Components
** Overview 

Shared libraries are compiled object-code exporting functions, data
structures and classes which can be used by many different
programs. They provide many benefits such as: faster compilation time;
less disk space usage since each program using the library do not
need a copy of the library source code or its compiled-code; ability
to update the library and provide security fixes to client
applications without recompilation, just by replacing the library
file. 

On Windows, shared libraries are called DLLs which stands for Dynamic
Linked Libraries, on Unix-like operating systems such as Linux, BSD
and MacOSX, they are called SO - shared objects or DSO - dynamic
shared objects. 

#+CAPTION: Comparison of shared libraries across different operating systems 
| Operating | Long Name               | Short name | File          | Binary Format                         |
| System    |                         |            | Extension     |                                       |
|-----------+-------------------------+------------+---------------+---------------------------------------|
| Windows   | Dynamic Linked Library  | DLL        | .dll          | PE32/PE64 - Portable Executable       |
| Linux     | (Dynamic) Shared Object | DSO or SO  | .so           | ELF or ELF64 (for 64 bits processors) |
| BSD       | (Dynamic) Shared Object | DSO or SO  | .so           | ELF or ELF64                          |
| MacOSX    | -                       | dylib      | .dylib or .so | MachO                                 |
|-----------+-------------------------+------------+---------------+---------------------------------------|

 + Shared libraries are similar to executables, however they do not
   have the main() function entry point.

In addition to C and C++, shared libraries, containing functions with
C-linkage, can also be used as binary components (libraries) and be
consumed from higher level programming languages such as Python, Ruby,
Java or C# through some foreign-function interface. In Python
C-functions can be imported from shared libraries using the [[https://docs.python.org/3/library/ctypes.html][cytpes]]
library; in C# C-functions can be consumed using the P-invoke API and
in Java it is possible to use C-functions from shared libraries using
the JNI (Java Native Interface) or JNA, which is easier to use.

Note: 
 + Shared libraries are specific to a particular operating system and
   are not part of C++ standard.

** Example 1 - Shared Library libtest.dll - DLLs on Windows
*** Overview 

 *Source:*

Shared library Source Code

 + File: [[file:dll-shared-library/example-windows1/libtest.cpp][file:dll-shared-library/example-windows1/libtest.cpp]]
 + File: [[file:dll-shared-library/example-windows1/libtest.hpp][file:dll-shared-library/example-windows1/libtest.hpp]]

Sample Client C++ Program:

 + File: [[file:dll-shared-library/example-windows1/client1.cpp][file:dll-shared-library/example-windows1/client1.cpp]]  

*** Header macros 

Sources:
 + File: [[file:dll-shared-library/example-windows1/libtest.cpp][file:dll-shared-library/example-windows1/libtest.cpp]]
 + File: [[file:dll-shared-library/example-windows1/libtest.hpp][file:dll-shared-library/example-windows1/libtest.hpp]]

 *teslib.hpp / Heade File - Macros*

The header files uses the following macros to reduce the boilerplate
necessary to export the library functions and classes. 

 + file: libstes.hpp => Macros for exporting functions and classes. 

#+BEGIN_SRC cpp
  #ifndef _WIN32
    // If not compiled for Windows, remove declspec directive.
    #define __declspec(param)  
  #endif 

  #define EXPORT_CPP 	__declspec(dllexport)
 
  #ifdef __cplusplus
    // Indicat that a given symbol/function has C-linkage and
    // does not have name mangling. 
    #define EXPORT_C extern "C" __declspec(dllexport)
  #else
    // If a C-compiler uses this header, remove 'extern "C"'
    #define EXPORT_C  __declspec(dllexport)
  #endif 
#+END_SRC

*** Namespace Linalg 

 *Functions of Namespace Linalg* 

Namespace containing sample linear algebra functions, the function norm
computes an Euclidean norm of a N-dimension vector, the function
linTransform computes a linear transformation performing the
computation v[i] * a + b for each vector element. 

On Windows, all DLL symbols, such as functions, variables and clases,
are private by default, they are not exported by default as happens in
Unix-like OSes shared libraries. Therefore, in order to a function be
exported in a Windows shared library, it is necessary to use the MSVC or visual C++
compiler extension ~__declspec(dllexport)~ before the function declaration.
 
 + Interface => File: *libtest.hpp*

#+BEGIN_SRC cpp 
  /** The macro __cplusplus is used for allowing this 
   ,* header to be used from 'C'. If a C compiler is used
   ,* all definitions inside this #ifdef are discarded.
   ,*/
  #ifdef __cplusplus
  namespace Linalg {
          EXPORT_CPP double norm(const std::vector<double>& xs);

          EXPORT_CPP std::vector<double> linTransform(
                  double a,
                  double b,
                  std::vector<double>& xs
                  );

          EXPORT_CPP
          std::ostream&
          printVector(std::ostream& os, std::vector<double>& xs);	
  }
  #endif 
#+END_SRC

The macro ~EXPORT_CPP~ expands to: 

#+BEGIN_SRC cpp
  EXPORT_CPP double norm(const std::vector<double>& xs);
  // Macro EXPORT_CPP expansion 
  __declspec(dllexport) double norm(const std::vector<double>& xs);
#+END_SRC

The compiler directives *#ifdef __cplusplus ... #endif* are used for
disabling this code block when the header is used by a C-compiler as
the C-language does not support classes, namespaces and many other C++
features. 

 + Implementation => file: *libtest.cpp*

#+BEGIN_SRC cpp 
   // Linear algebra tools 
   namespace Linalg{
        __declspec(dllexport)
        double norm(const std::vector<double>& xs){
           double sum = 0.0;
           for(const auto& x : xs) sum += x * x;
               return std::sqrt(sum);
        }

         __declspec(dllexport)
        std::vector<double>
        linTransform(double a, double b, std::vector<double>& xs){
            std::vector<double> out(xs.size());
            ... ... .... 
        }

       ... ... 
   }
#+END_SRC

*** C-interface of Namespace Linalg 

 *C-interface of Namespace Linalg* 

A C-interface is necessary for ensuring that the DLL can be called
from a C-program or a foreign function interface of a higher level
language. 

 + File: *libtest.hpp* => Function declaration. 

#+BEGIN_SRC cpp 
  // ======= C-interface for Linalg namespace =========//
  /* ----- C-Wrappers for Linalg namespace ---- */

  /** Handle or opaque pointer for std::vector<double> */
  typedef void* hVectorD;

  extern "C"  __declspec(dllexport)
  double testlib_vectorD_Linalg_norm(hVectorD hv);

  extern "C"  __declspec(dllexport)
  void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv);
#+END_SRC

The *extern "C"* statements are necessary to compile the functions with
_C-linkage_, it means without _name mangling_ (aka name decoration). In
every C program, the function symbols are generally the same as their
names. However, as C++ supports templates and function overloading,
many functions can have the same, with different type signatures,
C++ compiler mangles or decorates function names with a different
schema to make the symbol unique. 

Functions with C-linkage, can only use C-compatible types or PODs
types (Plain Old Data). Therefore, they cannot use STL container,
std::vector, std::string and so on. 

The statement ~__declspec(dllexport)~ is necessary to make annotated
functions' symbols visible. On Unix-like systems and Linux, it is not
necessary as it is MSVC (cl.exe) compiler extension. 


 + File: *libtest.cpp* => C-interface function implementations. 

The type synonym hVectorD is handle or a opaque poiter for the type
std::vector<double>. It is a workaround, to pass std::vector<double>
accross a DLL functions with C-linkage and use std::vector<double>
from C programs or foreign function interfaces. 

#+BEGIN_SRC cpp 
  // Handler for double vector 
  using hVectorD = void*;
  using pVectorD = std::vector<double>*;

  /** C-wrapper for vector<double> constructor */
  extern "C" __declspec(dllexport)
  hVectorD
  testlib_vectorD_make0(size_t n, double x){
     return new std::vector<double>(n, x);
  }
    ... ... ...     ... ... ...     ... ... ... 

  /** C-wrapper for vector<double> destructor */
  extern "C" __declspec(dllexport)
  void
  testlib_vectorD_delete(hVectorD hv){
    delete reinterpret_cast<pVectorD>(hv);
  }

  /** C-wrapepr for Linalg::norm function */
  extern "C" __declspec(dllexport)
  double
  testlib_vectorD_Linalg_norm(hVectorD hv){
     return Linalg::norm(*reinterpret_cast<pVectorD>(hv));
  }
    ... ... ...     ... ... ...     ... ... ... 

#+END_SRC





*** Non-polymorphic Class - SampleClass 

  + File: *libtest.hpp* => Class declaration. 

In order to a class be exported in a Windows' shared library, it
requires the annotation ~__declspec(dllexport)~.

Note: It will not be possible to compiled client program using this
class with a compiler different from the used to build the shared
library libtest.dll. It happens because, the C++ ABI - Application
Binary Interface is not the same accross different compilers. If the
DLL is compiled with MSVC, the only way to use this class from a
program compiled using MingW or even a different version of MSVC is
by using a C-interface (functions with C-linkage) and opaque
pointers (void* pointers). 

#+BEGIN_SRC cpp 
  // ======= Non-polymorphic class exported by DLL =========//
  #ifdef __cplusplus
  // Non-polymorphic class 
  class __declspec(dllexport) SampleClass{
  public:
          SampleClass();
          SampleClass(const std::string& name);	
          ~SampleClass();
          std::string getName() const;
          int get();
          void set(int n);	
  private:
          std::string m_name;
          int m_counter;	
  };
  #endif 
#+END_SRC

 + File: *libtest.cpp* => Class implementation. 

#+BEGIN_SRC cpp 
  SampleClass::SampleClass(const std::string& name)
     : m_name(name), m_counter(0)
  {
      std::cout << " Instance created with name = " << m_name << std::endl;
  }
  /** Delegated constructor on right-hand-side */
  SampleClass::SampleClass(): SampleClass("unnamed"){}   
	
  SampleClass::~SampleClass(){
      std::string text = std::string("SampleClass => name = ") + m_name +  " deleted";
      DbgTrace(text);
  }

  std::string SampleClass::getName() const {
      return m_name;
  }
  int SampleClass::SampleClass::get(){		
      return m_counter;
  }
  void SampleClass::set(int n){
      std::cout << " Counter set to value = " << n << std::endl;
      m_counter = n;
  }	
#+END_SRC

*** C-interface for SampleClass

 + File: *libtest.hpp* => Functions declarations. 

#+BEGIN_SRC cpp 
  /* ----- C-Wrappers for SampleClass namespace ---- */
  using hSampleClass = void*;

  /** Nullable constructor zero-arg constructor */
  extern "C" __declspec(dllexport)
  hSampleClass
  testlib_SampleClass_make0();

  /** Other constructor */
  EXPORT_C hSampleClass testlib_SampleClass_make1(const char* name);

  /** Destructor */
  EXPORT_C
  void
  testlib_SampleClass_delete(hSampleClass hnd);

  /** Wrapper for get method */
  EXPORT_C
  int
  testlib_SampleClass_get(hSampleClass hnd);

  /** Wrapper for set method */
  EXPORT_C
  void
  testlib_SampleClass_set(hSampleClass hnd, int n);

  EXPORT_C
  const char*
  testlib_SampleClass_getName(hSampleClass hnd);

#+END_SRC

 + File: *libtest.cpp* => Functions implementation. 

#+BEGIN_SRC cpp 
  using hSampleClass = void*;

  /** Nullable constructor zero-arg constructor */
  extern "C" __declspec(dllexport)
  hSampleClass
  testlib_SampleClass_make0(){
     return new SampleClass();
  }

  /** Other constructor */
  extern "C" __declspec(dllexport)
  hSampleClass
  testlib_SampleClass_make1(const char* name){
     return new SampleClass(name);
  }

  /** Destructor */
  extern "C" __declspec(dllexport)
  void
  testlib_SampleClass_delete(hSampleClass hnd){
     delete reinterpret_cast<SampleClass*>(hnd);
  }

  /** Wrapper for get method */
  extern "C" __declspec(dllexport)
  int
  testlib_SampleClass_get(hSampleClass hnd){
     return reinterpret_cast<SampleClass*>(hnd)->get();
  }
#+END_SRC

*** Polymorphic class InterfaceClass 

 + File: *libtest.hpp* => Class declaration. 

As the name implies, this class is an interface class, which is a
class containing only pure virtual functions (abstract methods). As a
result, it is declared only in the header file and cannot be
instatiated directly. 

This class uses only C-types to be binary compatible with different
compilers, if it used STL containers such as string or any other
non-compatible C-type, it would not be possible to compile a C++
program using Mingw/GCC against this DLL built with MSVC.

#+BEGIN_SRC cpp 
  // Polymorphic Interface class binary compatible across different
  // compilers as it does not use any STL container on the interface.
  #ifdef __cplusplus
  struct InterfaceClass{
          /* Returns class unique ID */
          virtual const char* getID()	const = 0;
          /** Set class internal state */
          virtual void setName(const char* name) = 0;
          virtual const char* getName() = 0;

          /** Virtual constructor */
          virtual ~InterfaceClass() = default;
          // virtual ~InterfaceClass();
  };
  #else
    #define InterfaceClass void 
  #endif 
#+END_SRC

 + File: *libtest.cpp* => class ImplementationA of interface InterfaceClass. 

#+BEGIN_SRC cpp 
  class ImplementationA: public InterfaceClass
  {
  private:
      std::string m_name;
  public:
      static constexpr const char* class_id = "ImplementationA";

      ImplementationA(): m_name("Unammed-A"){ }
      ImplementationA(const std::string& name)
         : m_name(name){}	
      ~ImplementationA(){
           std::cout << " [INFO] ImplementationA deleted => name = "
                     << m_name
                     << " ; type = " << class_id
                     << std::endl;
      }
      const char* getID() const {		
          return class_id;
      }
      void setName(const char* name) {
          m_name = name;
      }
      const char* getName() {
          return m_name.c_str();
      }
  };
#+END_SRC

 + File: *libtest.cpp* => class ImplementationB of interface InterfaceClass. 

#+BEGIN_SRC cpp 
  class ImplementationB: public InterfaceClass
  {
  private:
      std::string m_name;
  public:
      static constexpr const char* class_id = "ImplementationB";

      ImplementationB(): m_name("Unammed-B"){ }
      ImplementationB(const std::string& name)
         : m_name(name){}	
      ~ImplementationB(){
          std::cout << " [INFO] ImplementationB deleted => name = "
                    << m_name
                    << " ; type = " << class_id
                    << std::endl;
      }
      const char* getID() const {		
              return class_id;
      }
      void setName(const char* name) {
              m_name = name;
      }
      const char* getName() {
              return m_name.c_str();
      }
  };

#+END_SRC

 + File: *libtest.hpp* => C-interface and factory function to load
   implementations from the DLL.

#+BEGIN_SRC cpp 
  /** Factory function */
  EXPORT_C InterfaceClass* teslib_InterfaceClass_factory(const char* class_id);

  /** C-wrapper for destructor */
  EXPORT_C void testlib_InterfaceClass_delete(InterfaceClass* hinst);

  /** C-wrapper for getID method */
  EXPORT_C const char* testlib_InterfaceClass_getID(InterfaceClass* hinst);

  EXPORT_C void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name);

  EXPORT_C const char* testlib_InterfaceClass_getName(InterfaceClass* hinst);
#+END_SRC

 + File: *libtest.cpp* => C-interfaces and factory functions
   definitions.

#+BEGIN_SRC cpp 
  EXPORT_C InterfaceClass*
  teslib_InterfaceClass_factory(const char* class_id)
  {
      auto s = std::string(class_id);
      if(s == "ImplementationA")
              return new ImplementationA();
      if(s == "ImplementationB")
              return new ImplementationB();
      return nullptr;
  }

  EXPORT_C void testlib_InterfaceClass_delete(InterfaceClass* hinst)
  {
      delete hinst;
  }
  EXPORT_C
  const char* testlib_InterfaceClass_getID(InterfaceClass* hinst)
  {
      return hinst->getID();
  }
  EXPORT_C
  void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name)
  {
      hinst->setName(name);
  }
  EXPORT_C
  const char* testlib_InterfaceClass_getName(InterfaceClass* hinst){
      return hinst->getName();
  }
#+END_SRC
*** DLL startup function DLLMain 

When a Windows shared library is loaded at compile-time or at runtime
by some process, the function DLLMain is always invoked, it is similar
to the function main() from an executable. 

Note: logging statements with printf, std::cout, std::cerr will not
printed if the DLL is loaded by some non-console program, a program
compiled to the _window subsystem_. Therefore, the easiest way to log is
to use the OutputDebugString function which output can viewed by the
DebugView sysinternal tool. 


 + File: *libtest.cpp* => DLL main function. 

#+BEGIN_SRC cpp 
  /** - DLL Entry point - main function of DLL which is executed when
      the DLL is loaded by some process.
   ,*/
  extern "C" __declspec(dllexport)
  BOOL APIENTRY DllMain (HINSTANCE hInst, DWORD reason, LPVOID lpReserved)
  {
     std::string text =
             std::string("DLL Loaded into the process => PID = ")
             + std::to_string(::GetCurrentProcessId());
     WindbgTrace(text);
     DbgTrace(text);	   	
      switch (reason)
      {
      case DLL_PROCESS_ATTACH:
          WindbgTrace("DLL attached to process");
          DbgTrace("DLL attached to process.");			
        break;
      case DLL_PROCESS_DETACH:
          WindbgTrace("=> DLL detached.");
          DbgTrace("=> DLL attached");
        break;
      case DLL_THREAD_ATTACH:
          WindbgTrace("DLL attached to thread");
          DbgTrace("DLL detached to thread.");
          break;
      case DLL_THREAD_DETACH:
          WindbgTrace("DLL detached from thread");
          DbgTrace("DLL detached from thread.");
        break;
      }

    return TRUE;
  }
#+END_SRC

Another more portable way to peform some way action when the DLL is
loaded by a process or unloaded is to use a static object. The startup
task is executed int the object's constructor and the finalization
task, which happens when the process ends, is executed at object's
destructor. 

 + File: *libtest.cpp* => Static Object for replacing DLLMain 

The class _StaticObject and a static instance of it is defined within
an anonymous namespace to make them private to the compilation unit
libtest.cpp and not allow them to be used from anywhere else. 

#+BEGIN_SRC cpp 
  // Class private to this compilation unit - cannot be accessed from
  // any other file
  namespace {
     class _StaticObject{		
     public:
         using Action = std::function<void ()>;
         Action m_end;

         _StaticObject(Action init, Action end)
                 :  m_end(end)
         {
                 init();
         }
         ~_StaticObject(){ m_end(); }
     };

     // Static object for replacing DLLMain 
     auto initDLL = _StaticObject(
        []{
              std::cout << " [StaticObject] => Initialize DLL"
                         << std::endl;						
        },
        []{	
             std::cout << " [StaticObject] => Shutdown DLL"
                       << std::endl;								
        });
  }
#+END_SRC
*** DLL entry point for run32dll.exe 

This function is a DLL entry point for the Windows program
rundll32.exe which can execute this function with: 

#+BEGIN_SRC cpp 
 $ rundll32.exe testlib.dll,entryPoint1
 $ rundll32.exe testlib.dll,entryPoint1 arg0 arg1 arg2 ... argn 
#+END_SRC

When the DLL testlib.dll is run with run32dll calling the function
entryPoint1, it will display a message box. 

Note: It is an optional function which could be used for installing
the DLL in the system or creating some entry in Windows' registry. 

 + File: *libtest.cpp*

#+BEGIN_SRC cpp 
  extern "C" __declspec(dllexport)
  void entryPoint1(HWND hwn, HINSTANCE hinst, LPSTR cmdLine, int nCmdShow){  
       DbgDisp(cmdLine);
       OutputDebugString("Rudll32 called entryPoint1()");
       MessageBoxA(NULL, "DLL ENTRY POINT", "Entry point 1", 0);
  }
#+END_SRC
** Shared Libraries on Linux 
