#+INCLUDE: theme/style.org
#+TITLE: Shared Libraries - Binary Components
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

 - [[wiki:index][Index]]

* Shared Libraries - Binary Components
** Overview 

Shared libraries are compiled object-code exporting functions, data
structures and classes which can be used by many different
programs. They provide many benefits such as: faster compilation time;
less disk space usage since each program using the library do not
need a copy of the library source code or its compiled-code; ability
to update the library and provide security fixes to client
applications without recompilation, just by replacing the library
file. 

On Windows, shared libraries are called DLLs which stands for Dynamic
Linked Libraries, on Unix-like operating systems such as Linux, BSD
and MacOSX, they are called SO - shared objects or DSO - dynamic
shared objects. 

#+CAPTION: Comparison of shared libraries across different operating systems 
| Operating | Long Name               | Short name | File          | Binary Format                         |
| System    |                         |            | Extension     |                                       |
|-----------+-------------------------+------------+---------------+---------------------------------------|
| Windows   | Dynamic Linked Library  | DLL        | .dll          | PE32/PE64 - Portable Executable       |
| Linux     | (Dynamic) Shared Object | DSO or SO  | .so           | ELF or ELF64 (for 64 bits processors) |
| BSD       | (Dynamic) Shared Object | DSO or SO  | .so           | ELF or ELF64                          |
| MacOSX    | -                       | dylib      | .dylib or .so | MachO                                 |
|-----------+-------------------------+------------+---------------+---------------------------------------|

 + Shared libraries are similar to executables, however they do not
   have the main() function entry point.

In addition to C and C++, shared libraries, containing functions with
C-linkage, can also be used as binary components (libraries) and be
consumed from higher level programming languages such as Python, Ruby,
Java or C# through some foreign-function interface. In Python
C-functions can be imported from shared libraries using the [[https://docs.python.org/3/library/ctypes.html][cytpes]]
library; in C# C-functions can be consumed using the P-invoke API and
in Java it is possible to use C-functions from shared libraries using
the JNI (Java Native Interface) or JNA, which is easier to use.


Note: 
 + Shared libraries are specific to a particular operating system and
   are not part of C++ standard.

Use Cases and advantages: 

 + Multiple programs can reuse the same library reducing disk space. 

 + Faster compilation once the shared library is compiled.

 + Changes in the library such as security fixes, updates and new
   features may not require client programs recompilation if the ABI is
   not broken.

 + _Better for security updates_. For instance, if a program is
   statically compiled with open-ssl library, a program
   recompilation would be required to update the library to a new
   version with security fixes for some vulnerability. It could even
   be a greater security problem and waste of space, if all
   application depending on open-ssl were statically liked with this
   library. If a program uses the open-sll shared library, the library
   can be updated just by replacing a file and the program it will not
   need to be recompiled as long as there are no ABI breaking changes.

 + _Plugin system_ => The main program can contain an interface class
   called IInterface and load its implementations from shared
   libraries plugins. The implementation classes provided by the
   plugins or shared library files allow the program to be updated and
   extended at runtime without recompilation.

 + _Cross language interoperability_ => Functions using C-linkage can be
   called from any high level programming language with foreign
   function interface such as Python with ctypes library. C++
   functions and classes cannot be called due to name mangling and
   compiler ABI issues. The workaround to this problem is to create a
   C-interface or functions with C-linkage for classes, functions and
   namespaces. Instances of a class can be passed around as opaque
   pointers (void*). 

Problems: 

 + Due to C++ lack of standard _ABI Application Binary Interface_,
   classes, STL containers, functions without C-linkage and namespaces
   may not be reusable with a client program compiled with different
   compiler than used to build the library. However, even in this
   case, there is still the benefit of faster compilation time if the
   shared library and the client application are part of the same
   project.
   + TL;DR => Classes, STL and functions without C-linkage of shared
     library cannot be used with a different compiler than the one
     used to build the DLL.

 + Cross-compiling interoperability - The only way to ensure that a
   shared library can work with all compilers is by using a functions
   with C-linkage (functions with extern "C") annotation and creating
   C-linkage functions wrappers to classes, STL containers and
   classes.

 + Classes can be made compatible among different compilers by using
   an interface class, a class with only pure virtual member
   functions, using only compatible types in the methods signature or
   declaration, therefore it cannot use STL container types such as
   std::string or std::vector. However, each implementation of an
   interface class can use STL containers internally. 


 *MSDN Documentation*

 + [[https://docs.microsoft.com/en-us/cpp/build/exporting-cpp-functions-for-use-in-c-language-executables?view=vs-2017][Exporting C++ Functions for Use in C-Language Executables]]

 + [[https://docs.microsoft.com/en-us/cpp/build/exporting-c-functions-for-use-in-c-or-cpp-language-executables?view=vs-2017][Exporting C Functions for Use in C or C++ Language Executables]]


 *Further Reading*

 + [[http://moppi.inside.org/demopaja/sdk_help/dll_functions.html][Creating the DLL functions]]

 + [[https://www.codeproject.com/Articles/28969/%2FArticles%2F28969%2FHowTo-Export-C-classes-from-a-DLL][HowTo: Export C++ classes from a DLL - CodeProject]]
 
 + [[http://gernotklingler.com/blog/creating-using-shared-libraries-different-compilers-different-operating-systems/][Creating and using shared libraries with different compilers on different operating systems - Gernot.Klingler]]

 + [[http://bigbang.waterlin.org/bang/using-python-ctypes-to-link-cpp-library/][The Big Bang on Reading Busy » Blog Archive » Using Python ctypes to link C/C++ library]]

** Example 1 - Cross platform Shared Library
*** Overview 

 *Source:*

Shared library Source Code

 + File: [[file:src/dlls/example-windows1/testlib.cpp][file:src/dlls/example-windows1/testlib.cpp]]
 + File: [[file:src/dlls/example-windows1/testlib.hpp][file:src/dlls/example-windows1/testlib.hpp]]

Sample Client C++ Program:

 + File: [[file:src/dlls/example-windows1/client1.cpp][file:src/dlls/example-windows1/client1.cpp]]  

Sample Python 3 Client code: (Python3 module wrapper library)

 + File: [[file:src/dlls/example-windows1/testlib.py][file:src/dlls/example-windows1/testlib.py]]

GIST - Better for online view: 

 + [[https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71][Gisthub]]

 *Compile the DLL libtest.dll and client program with MSVC* 

Shared Library 

#+BEGIN_SRC cpp 
 $ cl.exe testlib.cpp /EHsc /LD /nologo user32.lib
#+END_SRC

C++ Client program (client code)

#+BEGIN_SRC cpp 
 $ cl.exe /EHsc client.cpp /Fe:out.exe testlib.lib && out.exe
#+END_SRC

 *Compile the DLL libtest.dll and client program with Mingw/GCC* 

Shared Library 

#+BEGIN_SRC cpp 
 $ g++ testlib.cpp -o testlib.dll -g -fvisibility=hidden -shared -std=c++14 -Wall
#+END_SRC

C++ Client program 

#+BEGIN_SRC cpp 
 $ g++ client.cpp -o client.exe -g -std=c++14 testlib.dll -Wall
#+END_SRC

*** Header macros 

Sources:
 + File: [[file:src/dlls/example-windows1/testlib.cpp][file:src/dlls/example-windows1/testlib.cpp]]
 + File: [[file:src/dlls/example-windows1/testlib.hpp][file:src/dlls/example-windows1/testlib.hpp]]

 *teslib.hpp / Heade File - Macros*

The header files uses the following macros to reduce the boilerplate
necessary to export the library functions and classes. 

 + file: testlib.hpp => Macros for exporting functions and classes. 


 *Macro: EXPORT_CPP*

#+BEGIN_SRC cpp 
  /** Macro EXPORT_CPP makes a symbol visible. */
  #if defined(_WIN32)
    #define EXPORT_CPP __declspec(dllexport)
  #else
    #define EXPORT_CPP __attribute__ ((visibility ("default")))
    // If not compiled on Windows, remove declspec compiler extension.
    #ifndef __declspec
      // For GCC only - make exported symbol visible symbol 
      #define __declspec(param) __attribute__ ((visibility ("default")))
    #endif
  #endif 
#+END_SRC

The macro EXPORT_CPP annotates the symbol as visible by expanding to:

#+BEGIN_SRC cpp 
    // On Windows EXPORT_CPP becomes 
    __declspec(dllexport)

    // On Unix-like OSes, Linux, BSD, OSX ... 
     __attribute__ ((visibility ("default")))
#+END_SRC

So a function _int SomeFunction(double x, double y)_ becomes:

#+BEGIN_SRC cpp 
    // Makes this symbol visible (exported) in the library (DLL)
    EXPORT_CPP int SomeFunction(double , double);

   // On Windows: 
   __declspec(dllexport) int SomeFunction(double , double);

   // On Unix-like operating systems or Linux: 
   __attribute__ ((visibility ("default"))) int SomeFunction(double , double);
#+END_SRC


 *Macro EXPORT_C:*

#+BEGIN_SRC cpp 
  /* Macro EXPORT_C is used for exporting symbol with C-linkage, it
   ,* means, without name mangling */
  #ifdef __cplusplus
    // extern "C" - Indicates that a given symbol/function has C-linkage and
    // does not have name mangling.
    // 
    // On Linux EXPORT_C becomes
    //  => extern "C" __attribute__ ((visibility ("default")))
    // 
    // On Windows EXPORT_C becomes 
    //  => extern "C" __declspec(dllexport)
    #define EXPORT_C extern "C" EXPORT_CPP
  #else
    // If a C-compiler uses this header, remove 'extern "C"'
    #define EXPORT_C  EXPORT_CPP
  #endif 
#+END_SRC

Export symbols with C-linkage, it means that the function is exported
without name decoration or _name mangling_. The function symbol matches
exactly its name. Functions with C-linkage can be called by C-code;
C++ code compiled with other compilers without ABI issues and foreign
function interfaces of scripting languages such as Python Ctypes or C#
Pinvoke. Note: If a function is defined with C-linkage, it can only use
C-compatible types. So, it is no possible to define functions with
C-linkage with overload, default parameter or non C-compatible
arguments.

 + On Windows, this macro is expanded to:

#+BEGIN_SRC cpp 
   EXPORT_C int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);

   // On Windows it becomes: 
   extern "C" __declspec(dllexport)  int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);

   // This function could also be declared as:
   extern "C" __declspec(dllexport) 
   int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);
#+END_SRC

 + On Unix-like OSes or linux, the macro EXPORT_C expands to: 

#+BEGIN_SRC cpp 
   EXPORT_C int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);

   // On Linux, it becomes:
   extern "C" __attribute__ ((visibility ("default"))) int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);

   // This function could also be declared as:
   extern "C" __attribute__ ((visibility ("default"))) 
   int functionWith_C_linkage(MyClass* pointerToClass, int x, double z);
#+END_SRC

On Unix-like operating system (GCC or Clang compilers), all
functions in an object-code (aka compiled code) becomes visible by
default what can lead to undefined behavior when there are name
clashes due to repeated symbols. With appropriate compiler options
such as -fvisibility=hidden, the symbols can be made private by
default as happens in Windows where is necessary to annotate the
symbol as visible explicitly with __declspec(dllexport). On Unix-like
OSes for GCC and Clang compiler the annotation for making the symbol
visible is ~__attribute__ ((visibility ("default")))~. This statement
has no effect if the appropriate compiler flags are not set.

*** Namespace Linalg 

 *Functions of Namespace Linalg* 

Namespace containing sample linear algebra functions, the function norm
computes an Euclidean norm of a N-dimension vector, the function
linTransform computes a linear transformation performing the
computation v[i] * a + b for each vector element. 

On Windows, all DLL symbols, such as functions, variables and clases,
are private by default, they are not exported by default as happens in
Unix-like OSes shared libraries. Therefore, in order to a function be
exported in a Windows shared library, it is necessary to use the MSVC or visual C++
compiler extension ~__declspec(dllexport)~ before the function declaration.
 
 + Interface => File: *testlib.hpp*

#+BEGIN_SRC cpp 
   #ifdef __cplusplus

   namespace Linalg {
           EXPORT_CPP
           double norm(const std::vector<double>& xs);

           EXPORT_CPP std::vector<double>
           linTransform(
                   double a,
                   double b,
                   std::vector<double>& xs
                   );

           EXPORT_CPP
           std::ostream&
           printVector(std::ostream& os, std::vector<double>& xs);	
   }
   #endif 
#+END_SRC

The compiler directives *#ifdef __cplusplus ... #endif* are used for
disabling this code block when the header is used by a C-compiler as
the C-language does not support classes, namespaces and many other C++
features. 

 + file: *testlib.cpp* - Implementation 

#+BEGIN_SRC cpp 
   // Linear algebra tools 
    namespace Linalg{
            EXPORT_CPP 
             double norm(const std::vector<double>& xs){
                   double sum = 0.0;
                   for(const auto& x : xs) sum += x * x;
                   return std::sqrt(sum);
           }

           EXPORT_CPP
           std::vector<double>
           linTransform(double a, double b, std::vector<double>& xs){
                   std::vector<double> out(xs.size());
                   for(size_t i = 0; i < xs.size(); i++){		
                           out[i] = a * xs[i] + b;
                   }
                   return out;
           }

           EXPORT_CPP
           std::ostream&
           printVector(std::ostream& os, std::vector<double>& xs){
                   os << "[" << xs.size() << "]( ";
                   for(const auto&  x: xs)
                           os << x << ", ";
                   return os << " )";
           }	
   }
#+END_SRC

*** C-interface of Namespace Linalg 

 *C-interface of Namespace Linalg* 

A C-interface is necessary for ensuring that the DLL can be called
from a C-program or a foreign function interface of a higher level
language. 

 + File: *testlib.hpp* => Function declaration. 

#+BEGIN_SRC cpp 
  // ======= C-interface for Linalg namespace =========//

  /** Handle or opaque pointer for std::vector<double> */
  typedef void* hVectorD;

  /* ----- C-Wrappers for Linalg namespace ---- */

  EXPORT_C 
  double testlib_vectorD_Linalg_norm(hVectorD hv);

  EXPORT_C 
  void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv);

#+END_SRC

 + File: *testlib.cpp* => C-interface function implementations. 

The type synonym hVectorD is handle or a opaque poiter for the type
std::vector<double>. It is a workaround, to pass std::vector<double>
accross a DLL functions with C-linkage and use std::vector<double>
from C programs or foreign function interfaces. 

#+BEGIN_SRC cpp 
  //=========== C-wrappers ---------------///
  // Handler for double vector 
  using hVectorD = void*;
  using pVectorD = std::vector<double>*;

  /** C-wrapper for vector<double> constructor */
  EXPORT_C  
  hVectorD testlib_vectorD_make0(size_t n, double x){
      return new std::vector<double>(n, x);
  }

  /** C-wrapper for range constructor */
  EXPORT_C
  hVectorD testlib_vectorD_make1(size_t n, double array []){
      return new std::vector<double>(array, array + n);
  }

  /** C-wrapper for setting elements of vector<double> */
  EXPORT_C 
  void testlib_vectorD_set(hVectorD hv, size_t n, double x){
     reinterpret_cast<pVectorD>(hv)->operator[](n) = x;
  }

  /** C-wrapper for vector<double> destructor */
  EXPORT_C void testlib_vectorD_delete(hVectorD hv){
      delete reinterpret_cast<pVectorD>(hv);
  }

  /** C-wrapepr for Linalg::norm function */
  EXPORT_C 
  double testlib_vectorD_Linalg_norm(hVectorD hv){
      return Linalg::norm(*reinterpret_cast<pVectorD>(hv));
  }

  EXPORT_C 
  void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv){
      std::cout << name << " = ";
      Linalg::printVector(std::cout, *reinterpret_cast<pVectorD>(hv));
      std::cout << std::endl;
  }
#+END_SRC

*** Non-polymorphic Class - SampleClass 

  + File: *testlib.hpp* => Class declaration. 

In order to a class be exported in a Windows' shared library, it
requires the annotation ~__declspec(dllexport)~.

Note: It will not be possible to compiled client program using this
class with a compiler different from the used to build the shared
library libtest.dll. It happens because, the C++ ABI - Application
Binary Interface is not the same accross different compilers. If the
DLL is compiled with MSVC, the only way to use this class from a
program compiled using MingW or even a different version of MSVC is
by using a C-interface (functions with C-linkage) and opaque
pointers (void* pointers). 

#+BEGIN_SRC cpp 
  // ======= Non-polymorphic class exported by DLL =========//

  #ifdef __cplusplus
  // Non-polymorphic class 
  class EXPORT_CPP SampleClass{
  public:
          SampleClass();
          SampleClass(const std::string& name);	
          ~SampleClass();
          std::string getName() const;
          int get();
          void set(int n);	
  private:
          std::string m_name;
          int m_counter;	
  };
  #endif 
#+END_SRC


 + File: *testlib.cpp* => Class implementation. 

#+BEGIN_SRC cpp 
  SampleClass::SampleClass(const std::string& name)
     : m_name(name), m_counter(0)
  {
      std::cout << " Instance created with name = " << m_name << std::endl;
  }
  /** Delegated constructor on right-hand-side */
  SampleClass::SampleClass(): SampleClass("unnamed"){}   
	
  SampleClass::~SampleClass(){
      std::string text = std::string("SampleClass => name = ") + m_name +  " deleted";
      DbgTrace(text);
  }

  std::string SampleClass::getName() const {
      return m_name;
  }
  int SampleClass::SampleClass::get(){		
      return m_counter;
  }
  void SampleClass::set(int n){
      std::cout << " Counter set to value = " << n << std::endl;
      m_counter = n;
  }	
#+END_SRC

*** C-interface for SampleClass

 + File: *testlib.hpp* => Functions declarations. 

#+BEGIN_SRC cpp 
  /* ----- C-Wrappers for SampleClass namespace ---- */
  using hSampleClass = void*;

  /** Nullable constructor zero-arg constructor */
  extern "C" __declspec(dllexport)
  hSampleClass
  testlib_SampleClass_make0();

  /** Other constructor */
  EXPORT_C hSampleClass testlib_SampleClass_make1(const char* name);

  /** Destructor */
  EXPORT_C
  void
  testlib_SampleClass_delete(hSampleClass hnd);

  /** Wrapper for get method */
  EXPORT_C
  int
  testlib_SampleClass_get(hSampleClass hnd);

  /** Wrapper for set method */
  EXPORT_C
  void
  testlib_SampleClass_set(hSampleClass hnd, int n);

  EXPORT_C
  const char*
  testlib_SampleClass_getName(hSampleClass hnd);

#+END_SRC

 + File: *testlib.cpp* => Functions implementation. 

#+BEGIN_SRC cpp 
  /* ----- C-Wrappers for SampleClass namespace ---- */

  using hSampleClass = void*;

  /** Nullable constructor zero-arg constructor */
  EXPORT_C 
  hSampleClass
  testlib_SampleClass_make0();

  /** Other constructor */
  EXPORT_C hSampleClass testlib_SampleClass_make1(const char* name);

  /** Destructor */
  EXPORT_C
  void
  testlib_SampleClass_delete(hSampleClass hnd);

  /** Wrapper for get method */
  EXPORT_C
  int
  testlib_SampleClass_get(hSampleClass hnd);

  /** Wrapper for set method */
  EXPORT_C
  void
  testlib_SampleClass_set(hSampleClass hnd, int n);

  EXPORT_C
  const char*
  testlib_SampleClass_getName(hSampleClass hnd);

#+END_SRC

*** Polymorphic class InterfaceClass 

 + File: *testlib.hpp* => Class declaration. 

As the name implies, this class is an interface class, which is a
class containing only pure virtual functions (abstract methods). As a
result, it is declared only in the header file and cannot be
instatiated directly. 

This class uses only C-types to be binary compatible with different
compilers, if it used STL containers such as string or any other
non-compatible C-type, it would not be possible to compile a C++
program using Mingw/GCC against this DLL built with MSVC.

#+BEGIN_SRC cpp 
  // Polymorphic Interface class binary compatible across different
  // compilers as it does not use any STL container on the interface.
  #ifdef __cplusplus
  struct InterfaceClass{
          /* Returns class unique ID */
          virtual const char* getID()	const = 0;
          /** Set class internal state */
          virtual void setName(const char* name) = 0;
          virtual const char* getName() = 0;

          /** Virtual constructor */
          virtual ~InterfaceClass() = default;
          // virtual ~InterfaceClass();
  };
  #else
    #define InterfaceClass void 
  #endif 
#+END_SRC

 + File: *testlib.cpp* => class ImplementationA of interface InterfaceClass. 

#+BEGIN_SRC cpp 
  class ImplementationA: public InterfaceClass
  {
  private:
      std::string m_name;
  public:
      static constexpr const char* class_id = "ImplementationA";

      ImplementationA(): m_name("Unammed-A"){ }
      ImplementationA(const std::string& name)
         : m_name(name){}	
      ~ImplementationA(){
           std::cout << " [INFO] ImplementationA deleted => name = "
                     << m_name
                     << " ; type = " << class_id
                     << std::endl;
      }
      const char* getID() const {		
          return class_id;
      }
      void setName(const char* name) {
          m_name = name;
      }
      const char* getName() {
          return m_name.c_str();
      }
  };
#+END_SRC

 + File: *testlib.cpp* => class ImplementationB of interface InterfaceClass. 

#+BEGIN_SRC cpp 
  class ImplementationB: public InterfaceClass
  {
  private:
      std::string m_name;
  public:
      static constexpr const char* class_id = "ImplementationB";

      ImplementationB(): m_name("Unammed-B"){ }
      ImplementationB(const std::string& name)
         : m_name(name){}	
      ~ImplementationB(){
          std::cout << " [INFO] ImplementationB deleted => name = "
                    << m_name
                    << " ; type = " << class_id
                    << std::endl;
      }
      const char* getID() const {		
              return class_id;
      }
      void setName(const char* name) {
              m_name = name;
      }
      const char* getName() {
              return m_name.c_str();
      }
  };

#+END_SRC

 + File: *testlib.hpp* => C-interface and factory function to load
   implementations from the DLL.

#+BEGIN_SRC cpp 
  /** Factory function */
  EXPORT_C InterfaceClass* teslib_InterfaceClass_factory(const char* class_id);

  /** C-wrapper for destructor */
  EXPORT_C void testlib_InterfaceClass_delete(InterfaceClass* hinst);

  /** C-wrapper for getID method */
  EXPORT_C const char* testlib_InterfaceClass_getID(InterfaceClass* hinst);

  EXPORT_C void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name);

  EXPORT_C const char* testlib_InterfaceClass_getName(InterfaceClass* hinst);
#+END_SRC

 + File: *testlib.cpp* => C-interfaces and factory functions
   definitions.

#+BEGIN_SRC cpp 
  EXPORT_C InterfaceClass*
  teslib_InterfaceClass_factory(const char* class_id)
  {
      auto s = std::string(class_id);
      if(s == "ImplementationA")
              return new ImplementationA();
      if(s == "ImplementationB")
              return new ImplementationB();
      return nullptr;
  }

  EXPORT_C void testlib_InterfaceClass_delete(InterfaceClass* hinst)
  {
      delete hinst;
  }
  EXPORT_C
  const char* testlib_InterfaceClass_getID(InterfaceClass* hinst)
  {
      return hinst->getID();
  }
  EXPORT_C
  void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name)
  {
      hinst->setName(name);
  }
  EXPORT_C
  const char* testlib_InterfaceClass_getName(InterfaceClass* hinst){
      return hinst->getName();
  }
#+END_SRC
*** DLL startup function DLLMain 

When a Windows shared library is loaded at compile-time or at runtime
by some process, the function DLLMain is always invoked, it is similar
to the function main() from an executable. 

Note: logging statements with printf, std::cout, std::cerr will not
printed if the DLL is loaded by some non-console program, a program
compiled to the _window subsystem_. Therefore, the easiest way to log is
to use the OutputDebugString function which output can viewed by the
DebugView sysinternal tool. 


 + File: *testlib.cpp* => DLL main function. 

#+BEGIN_SRC cpp 
   /** - DLL Entry point - main function of DLL which is executed when 
       the DLL is loaded by some process. 
    */
   #if defined(_WIN32)
   extern "C" __declspec(dllexport)
   BOOL APIENTRY DllMain (HINSTANCE hInst, DWORD reason, LPVOID lpReserved)
   {
       std::string text =
               std::string("DLL Loaded into the process => PID = ")
               + std::to_string(::GetCurrentProcessId());
       WindbgTrace(text);
       DbgTrace(text);

       switch (reason)
       {
       case DLL_PROCESS_ATTACH:
           WindbgTrace("DLL attached to process");
           DbgTrace("DLL attached to process.");			
         break;
       case DLL_PROCESS_DETACH:
            WindbgTrace("=> DLL detached.");
            DbgTrace("=> DLL attached");
         break;
       case DLL_THREAD_ATTACH:
           WindbgTrace("DLL attached to thread");
           DbgTrace("DLL detached to thread.");
         break;
       case DLL_THREAD_DETACH:
           WindbgTrace("DLL detached from thread");
           DbgTrace("DLL detached from thread.");
         break;
       }

     return TRUE;
   }
   #endif 
#+END_SRC


Another more portable way to peform some way action when the DLL is
loaded by a process or unloaded is to use a static object. The startup
task is executed int the object's constructor and the finalization
task, which happens when the process ends, is executed at object's
destructor. This approach may a better replacement for DLLMain
function, which is specific for Windows, as this technique works both
on Windows and any other Unix-like operating system. 

 + File: *testlib.cpp* => Static Object for replacing DLLMain 

The class _StaticObject and a static instance of it is defined within
an anonymous namespace to make them private to the compilation unit
testlib.cpp and not allow them to be used from anywhere else. 

#+BEGIN_SRC cpp 
  // Class private to this compilation unit - cannot be accessed from
  // any other file
  namespace {
     class _StaticObject{		
     public:
         using Action = std::function<void ()>;
         Action m_end;

         _StaticObject(Action init, Action end)
                 :  m_end(end)
         {
                 init();
         }
         ~_StaticObject(){ m_end(); }
     };

     // Static object for replacing DLLMain 
     auto initDLL = _StaticObject(
        []{
              std::cout << " [StaticObject] => Initialize DLL"
                         << std::endl;						
        },
        []{	
             std::cout << " [StaticObject] => Shutdown DLL"
                       << std::endl;								
        });
  }
#+END_SRC
*** DLL entry point for run32dll.exe 

This function is a DLL entry point for the Windows program
rundll32.exe which can execute this function with: 

#+BEGIN_SRC cpp 
 $ rundll32.exe testlib.dll,entryPoint1
 $ rundll32.exe testlib.dll,entryPoint1 arg0 arg1 arg2 ... argn 
#+END_SRC

When the DLL testlib.dll is run with run32dll calling the function
entryPoint1, it will display a message box. 

Note: It is an optional function which could be used for installing
the DLL in the system or creating some entry in Windows' registry. 

 + File: *testlib.cpp*

#+BEGIN_SRC cpp 
  #if defined(_WIN32)
  extern "C" __declspec(dllexport)
  void entryPoint1(HWND hwn, HINSTANCE hinst, LPSTR cmdLine, int nCmdShow){  
       DbgDisp(cmdLine);
       OutputDebugString("Rudll32 called entryPoint1()");
       MessageBoxA(NULL, "DLL ENTRY POINT", "Entry point 1", 0);
  }
  #endif 
#+END_SRC
*** C++ Client program - client1.cpp 

 + File: [[file:src/dlls/example-windows1/client1.cpp][file:src/dlls/example-windows1/client1.cpp]]  

 *File client1.cpp*

Includes: 

 + Note: (#include "testlib.hpp") a header file between quotes,
   indicates to the compiler that the header is in the same directory
   as the source file client1.cpp.

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <ostream>
  #include <vector>
  #include <string>

  #include "testlib.hpp"
#+END_SRC

Declaration of functions with C-linkages not declarated in the header
testlib.hpp

#+BEGIN_SRC cpp 
  extern "C" hVectorD testlib_vectorD_make0(size_t n, double);
  extern "C" hVectorD testlib_vectorD_make1(size_t n, double array []);
  extern "C" void testlib_vectorD_delete(hVectorD hv);
#+END_SRC

Main function - Experiment 1 and Experiment 2:

#+BEGIN_SRC cpp 
  #ifndef DISABLE
  std::cout << "\n=== EXPERIMENT 1 ===> Import C++ functions from DLL" << std::endl;

  DbgTrace("Main process starts here.");
  std::vector<double> xs{1.0, 2.0, 3.0, 4.0, 5.0};
  std::cout << " => Linalg::norm(xs) " << Linalg::norm(xs) << std::endl;
  std::cout << "=> xs = "; Linalg::printVector(std::cout, xs); std::cout << std::endl;

  std::cout << "=== EXPERIMENT 2 ===> Import class from DLL" << std::endl;
  auto cls = SampleClass("Dummy");
  cls.set(100);
  std::cout << "cls.getName() = " << cls.getName() << std::endl;
  std::cout << "    cls.get() = " << cls.get() << std::endl;
  #endif // -- eof DISABLE flag
#+END_SRC

Main Function - Experiment 3 

#+BEGIN_SRC cpp
  //=========>> Load functions and classes using C-interface ==============//

  std::cout << "\n== EXPERIMENT 3 ===> Import C-functions from DLL - C-interface" << std::endl;

  double arr [] = {1, 2, 3, 4, 5};
  hVectorD v1 = testlib_vectorD_make1(5, arr);
  testlib_vectorD_Linalg_printVector("v1", v1);
  std::cout << "norm(v1) = " << testlib_vectorD_Linalg_norm(v1) << std::endl;

  testlib_vectorD_delete(v1);
#+END_SRC

Main Functions - Experiment 4 

#+BEGIN_SRC cpp 
  std::cout << "\n== EXPERIMENT 4 ===> Non-polymorphic class with C-interface " << std::endl;

  hSampleClass hcls = testlib_SampleClass_make1("[EXPERIMENT4]ClassHandle-OOP-C-API");
  std::cout << "[EXPERIMENT 4] hcls.getName() = " << testlib_SampleClass_getName(hcls) << std::endl;
  testlib_SampleClass_set(hcls, 100);
  std::cout << "[EXPERIMENT 4] hcls.get()     = " << testlib_SampleClass_get(hcls) << std::endl;
  testlib_SampleClass_set(hcls, 200);
  std::cout << "[EXPERIMENT 4] hcls.get()     = " << testlib_SampleClass_get(hcls) << std::endl;

  testlib_SampleClass_delete(hcls);	
#+END_SRC

Main Functions - Experiment 5 

#+BEGIN_SRC cpp 
  std::cout << "\n== EXPERIMENT 5 ===> Load polymorphic classes from DLL " << std::endl;

  InterfaceClass* hinstA = teslib_InterfaceClass_factory("ImplementationA");
  InterfaceClass* hinstB = teslib_InterfaceClass_factory("ImplementationB");

  std::cout << " => hinstA->getID() = " << hinstA->getID() << std::endl;
  std::cout << " => hinstA->getID() = " << hinstB->getID() << std::endl;
  hinstA->setName("ClassA-implA");
  hinstB->setName("ClassB-implB");
  std::cout << " => hinstA->getName() = " << hinstA->getID() << std::endl;
  std::cout << " => hinstB->getName() = " << hinstB->getID() << std::endl;

  // Note: If delete is used directly to delete hinstA and hinstB,
  // a segmentatin fault will happen whenc compiling with Mingw/GCC
  testlib_InterfaceClass_delete(hinstA);
  testlib_InterfaceClass_delete(hinstB);

  std::cout << " [INFO] After deleting instances" << std::endl;

  DbgTrace("Program ended OK.");
#+END_SRC

 *Compile and run client code with MSVC*

Note: Both the DLL and the client code are compiled with MSVC-2017 64
bits target.

#+BEGIN_SRC sh 
  $ cl.exe /EHsc client.cpp /nologo /Fe:client1.exe testlib.lib && client1.exe

  # Output: 
  client.cpp
     Creating library client1.lib and object client1.exp
   [StaticObject] => Initialize DLL
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 1112
  testlib.cpp:45: <DllMain> DLL attached to process.

  === EXPERIMENT 1 ===> Import C++ functions from DLL
  client.cpp:33: <main> Main process starts here.
   => Linalg::norm(xs) 7.4162
  => xs = [5]( 1, 2, 3, 4, 5,  )
  === EXPERIMENT 2 ===> Import class from DLL
   Instance created with name = Dummy
   Counter set to value = 100
  cls.getName() = Dummy
      cls.get() = 100

  == EXPERIMENT 3 ===> Import C-functions from DLL - C-interface
  v1 = [5]( 1, 2, 3, 4, 5,  )
  norm(v1) = 7.4162

  == EXPERIMENT 4 ===> Non-polymorphic class with C-interface 
   Instance created with name = [EXPERIMENT4]ClassHandle-OOP-C-API
  [EXPERIMENT 4] hcls.getName() = [EXPERIMENT4]ClassHandle-OOP-C-API
   Counter set to value = 100
  [EXPERIMENT 4] hcls.get()     = 100
   Counter set to value = 200
  [EXPERIMENT 4] hcls.get()     = 200
  testlib.cpp:159: <SampleClass::~SampleClass> SampleClass => name = [EXPERIMENT4]ClassHandle-OOP-C-API deleted

  == EXPERIMENT 5 ===> Load polymorphic classes from DLL 
   => hinstA->getID() = ImplementationA
   => hinstA->getID() = ImplementationB
   => hinstA->getName() = ImplementationA
   => hinstB->getName() = ImplementationB
   [INFO] ImplementationA deleted => name = ClassA-implA ; type = ImplementationA
   [INFO] ImplementationB deleted => name = ClassB-implB ; type = ImplementationB
   [INFO] After deleting instances
  client.cpp:87: <main> Program ended OK.
  testlib.cpp:159: <SampleClass::~SampleClass> SampleClass => name = Dummy deleted
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 1112
  testlib.cpp:49: <DllMain> => DLL attached
   [StaticObject] => Shutdown DLL

#+END_SRC

 *[FAILURE] ABI - Issue - Compile with Mingw client1.cpp against testlib.dll built with MSVC*

The client code is compiled with Mingw and the library was built with
MSVC-2017 for 64 bits target.

Build and run client [FAILURE]:

#+BEGIN_SRC cpp 
  $ g++ client1.cpp -g -o client1-gcc.exe -std=c++14 testlib.dll  && client1-gcc.exe
  C:\Users\archbox\AppData\Local\Temp\cckNg9eZ.o: In function `main':
  client1.cpp:35: undefined reference to `Linalg::norm(std::vector<double, std::allocator<double> > const&)'
  client1.cpp:36: undefined reference to `Linalg::printVector(std::ostream&, std::vector<double, std::allocator<double> >&)'
  client1.cpp:39: undefined reference to `SampleClass::SampleClass(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)'
  client1.cpp:40: undefined reference to `SampleClass::set(int)'
  client1.cpp:41: undefined reference to `SampleClass::getName[abi:cxx11]() const'
  client1.cpp:42: undefined reference to `SampleClass::get()'
  client1.cpp:39: undefined reference to `SampleClass::~SampleClass()'
  client1.cpp:39: undefined reference to `SampleClass::~SampleClass()'
  collect2.exe: error: ld returned 1 exit status
  Compilation exited abnormally with code 1 at Sun Dec 16 17:41:47
#+END_SRC

The compilation fails because C++ does not have a standard and stable
ABI - Application Binary Interface, as a result, it is not possible to
use an object-code (here - any type of compiled code) built by a
different compiler than the current one. The ABI comprises the name
mangling schema or name decoration schema which is compiler-dependent,
padding, class memory layout and so on. In addition to ABI issues, the
STL - Standard Template Library implementations may not be compatible
and also not be the same across different compilers. 

The only way to ensure that a DLL can work with all possible compilers
is to use a functions with C-linkage (extern "C") with opaque pointers
(void*) for passing around classes and wrapped STL containers. Classes
can be used by different compilers, only if they are interface classes
(classes with only pure virtual functions) containing only
C-compatible types in the declaration. 


 *Compile with Mingw client1.cpp against testlib.dll built with MSVC*

The compilation works when compiling with the custom flag -DDISABLE.
The directive _#ifndef DISABLE ... #endif_ removes all usages of the
namespace Linalg and the class SampleClass. This flag makes main the
function use only functions with C-linkage and the interface class
InterfaceClass.

#+BEGIN_SRC cpp 
$ g++ client.cpp -g -o client-gcc.exe -std=c++14 testlib.dll -DDISABLE   && client-gcc.exe

   [StaticObject] => Initialize DLL
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 5724
  testlib.cpp:45: <DllMain> DLL attached to process.

  == EXPERIMENT 3 ===> Import C-functions from DLL - C-interface
  v1 = [5]( 1, 2, 3, 4, 5,  )
  norm(v1) = 7.4162

  == EXPERIMENT 4 ===> Non-polymorphic class with C-interface 
   Instance created with name = [EXPERIMENT4]ClassHandle-OOP-C-API
  [EXPERIMENT 4] hcls.getName() = [EXPERIMENT4]ClassHandle-OOP-C-API
   Counter set to value = 100
  [EXPERIMENT 4] hcls.get()     = 100
   Counter set to value = 200
  [EXPERIMENT 4] hcls.get()     = 200
  testlib.cpp:159: <SampleClass::~SampleClass> SampleClass => name = [EXPERIMENT4]ClassHandle-OOP-C-API deleted

  == EXPERIMENT 5 ===> Load polymorphic classes from DLL 
   => hinstA->getID() = ImplementationA
   => hinstA->getID() = ImplementationB
   => hinstA->getName() = ImplementationA
   => hinstB->getName() = ImplementationB
   [INFO] ImplementationA deleted => name = ClassA-implA ; type = ImplementationA
   [INFO] ImplementationB deleted => name = ClassB-implB ; type = ImplementationB
   [INFO] After deleting instances
  client.cpp:87: <main> Program ended OK.
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 5724
  testlib.cpp:49: <DllMain> => DLL attached
   [StaticObject] => Shutdown DLL
#+END_SRC


*** Load DLL in Python3 REPL 

Functions with C-linkage can be called by Python using the ctypes
library. The following code presents how it can be done: 

 *Table for C types / Python ctypes conversion*

| C-type | Python C-types  | C-type  |                                 |
|--------+-----------------+---------+---------------------------------|
| char   | ctypes.c_char   | char*   | ctypes.POINTER(ctypes.c_char)   |
| int    | ctypes.c_int    | int*    | ctypes.POINTER(ctypes.c_int)    |
| size_t | ctypes.c_int    | -       |                                 |
| double | ctypes.c_double | double* | ctypes.POINTER(ctypes.c_double) |
| void   | None            | void*   | ctypes.c_void_p                 |
|        |                 |         |                                 |
|        |                 |         |                                 |

 + Get a Python string from a _const char* ptr_ or _char* ptr_, use ctypes.string_at(ptr).
 + Pass a python string to an API with const char*
   (ctypes.POINTER(ctypes.c_char)) as argument, use Function("string-argument".encode('utf-8'))

Python C-types documentation and further reading: 

 + [[https://docs.python.org/3/library/ctypes.html][ctypes — A foreign function library for Python — Python 3.7.2rc1 documentation]]
 + [[https://dbader.org/blog/python-ctypes-tutorial][Extending Python With C Libraries and the “ctypes” Module – dbader.org]]
 + [[https://www.programcreek.com/python/example/1108/ctypes.CDLL][ctypes.CDLL Python Example]]
 + [[https://blogs.msdn.microsoft.com/yizhang/2018/01/20/calling-c-functions-from-python-part-1-using-ctypes/][Calling C functions from Python – part 1 – using ctypes – Yi Zhang's MSDN Blog]]
 + [[https://en.wikibooks.org/wiki/Python_Programming/Extending_with_ctypes][Python Programming/Extending with ctypes - Wikibooks, open books for an open world]]
 + [[https://pgi-jcns.fz-juelich.de/portal/pages/using-c-from-python.html][Using C from Python: How to create a ctypes wrapper - Scientific IT-Systems]]

 *Load the library:*

#+BEGIN_SRC python 
  C:\Users\archbox\Desktop\experiments
  λ "C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\python"
  Python 3.6.5 |Anaconda, Inc.| (default, Mar 29 2018, 13:32:41) [MSC v.1900 64 bit (AMD64)] on win32
  Type "help", "copyright", "credits" or "license" for more information.

  >>> import ctypes

  # This messages is print by the DLLMain function 
  >>> lib = ctypes.cdll.LoadLibrary("testlib.dll")
   [StaticObject] => Initialize DLL
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 4280
  testlib.cpp:45: <DllMain> DLL attached to process.
  >>> testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 4280
  testlib.cpp:53: <DllMain> DLL detached to thread.
#+END_SRC

Check whether exported functions with C-linkage exist: 

#+BEGIN_SRC python 
  >>> lib.testlib_vectorD_make0
  <_FuncPtr object at 0x0000021BFCAFF388>

  >>> lib.testlib_vectorD_Linalg_printVector
  <_FuncPtr object at 0x0000021BFCAFF458>
  >>>

  >>> lib.testlib_vectorD_delete
  <_FuncPtr object at 0x0000021BFCAFF528>

  # Function which does not exist.
  >>> lib.testlib_InterfaceClass_do_not_exist
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\lib\ctypes\__init__.py", line 361, in __getattr__
      func = self.__getitem__(name)
    File "C:\Users\archbox\Miniconda3\pkgs\python-3.6.5-h0c2934d_0\lib\ctypes\__init__.py", line 366, in __getitem__
      func = self._FuncPtr((name_or_ordinal, self))
  AttributeError: function 'testlib_InterfaceClass_do_not_exist' not found
#+END_SRC

 *Load std::vector<double> and Linalg namespace wrapper functions*

Set up the std::vector<double> functions to be imported.
 
 + Note: hVectorD => Handle for std::vector<double> is the same as
   void* or an opaque pointer. 

#+BEGIN_SRC python
  # Funciton: hVectorD testlib_vectorD_make0(size_t n, double x)
  # Set function arguments
  lib.testlib_vectorD_make0.argtypes = [ctypes.c_int, ctypes.c_double]
  # Set return type 
  lib.testlib_vectorD_make0.restype  = ctypes.c_void_p
 
  # void testlib_vectorD_Linalg_printVector(const char* name, hVectorD hv)
  lib.testlib_vectorD_Linalg_printVector.argtypes = [ctypes.POINTER(ctypes.c_char), ctypes.c_void_p ]
  lib.testlib_vectorD_Linalg_printVector.restype = None 

  # Set vector elements hv[n] = x
  # void testlib_vectorD_set(hVectorD hv, size_t n, double x)
  lib.testlib_vectorD_set.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_double]
  lib.testlib_vectorD_set.restype  = None
#+END_SRC

Testing C-interface functions for std::vector<double>: 

#+BEGIN_SRC python 
  # Creating a std::vector<double> with 4 elements equal to 3.0 
  >>> vec1 = lib.testlib_vectorD_make0(4, 3.0)

  # This number is the memory address held by the opaque pointer,
  # it cannot be used directly. 
  >>> vec1
  2319184200912
  >>>
  # ========== Modify vector elements ======== #
  # Printarray2 the wrapped std::vector<double>
  >>> lib.testlib_vectorD_Linalg_printVector("vec1".encode('utf-8'), vec1)
  vec1 = [4]( 3, 3, 3, 3,  )
  >>>

  >>> lib.testlib_vectorD_set(vec1, 0, 5.0)
  >>> lib.testlib_vectorD_set(vec1, 1, 10.5)
  >>> lib.testlib_vectorD_set(vec1, 2, 4.78)

  >>> lib.testlib_vectorD_Linalg_printVector("vec1".encode('utf-8'), vec1)
  vec1 = [4]( 5, 10.5, 4.78, 3,  )
#+END_SRC

Compute vector Euclidian norm: 

#+BEGIN_SRC python 
  # Wrapper for function 
  # double Linalg::norm(const std::vector<double>& xs)
  # double testlib_vectorD_Linalg_norm(hVectorD hv)
  lib.testlib_vectorD_Linalg_norm.argtypes = [ ctypes.c_void_p ]
  lib.testlib_vectorD_Linalg_norm.restype  = ctypes.c_double

  >>> lib.testlib_vectorD_Linalg_printVector("vec1".encode('utf-8'), vec1)
  vec1 = [4]( 5, 10.5, 4.78, 3,  )

  >>> lib.testlib_vectorD_Linalg_norm(vec1)
  12.926654632966722

  # Check if calculations are right 
  >>> math.sqrt(5 * 5 + 10.5 * 10.5 + 4.78 * 4.78 + 3 * 3)
  12.926654632966722
  >>>
#+END_SRC

Delete vector vec1 using its destructor function: 

#+BEGIN_SRC python 
  # Function: void testlib_vectorD_delete(hVectorD hv)
  lib.testlib_vectorD_delete.argtypes = [ ctypes.c_void_p ]
  lib.testlib_vectorD_delete.restype = None

  >>> lib.testlib_vectorD_delete(vec1)
#+END_SRC

 *Load wrapper function for interface class InterfaceClass*

Load factory function: 
 + void* teslib_InterfaceClass_factory(const char* class_id)

#+BEGIN_SRC python 
   # InterfaceClass* teslib_InterfaceClass_factory(const char* class_id)
   lib.teslib_InterfaceClass_factory.argtypes = [ ctypes.POINTER(ctypes.c_char) ]
   lib.teslib_InterfaceClass_factory.restype  = ctypes.c_void_p

   # const char* testlib_InterfaceClass_getID(InterfaceClass* hinst)
   lib.testlib_InterfaceClass_getID.argtypes = [ ctypes.c_void_p ]
   lib.testlib_InterfaceClass_getID.restype  = ctypes.POINTER(ctypes.c_char)
#+END_SRC

Creating class instances and testing member function C-wrappers:

#+BEGIN_SRC python 
  >>> hinstA = lib.teslib_InterfaceClass_factory("ImplementationA".encode('utf-8'))
  >>> hinstA
  2319184196864
  >>>

  >>> hinstB = lib.teslib_InterfaceClass_factory("ImplementationB".encode('utf-8'))
  >>> hinstB
  2319184198016

  >>> s1 = lib.testlib_InterfaceClass_getID(hinstA)
  >>> s1
  <ctypes.LP_c_char object at 0x0000021BFBBF14C8>
  >>> ctypes.string_at(s1)
  b'ImplementationA'
  >>>

  >>> s2 = lib.testlib_InterfaceClass_getID(hinstB)
  >>> ctypes.string_at(s2)
  b'ImplementationB'

  >>> ctypes.string_at(lib.testlib_InterfaceClass_getID(hinstB))
  b'ImplementationB'
  >>>
#+END_SRC

Load more C-wrappers for member function of class InterfaceClass:

#+BEGIN_SRC python
   # const char* testlib_InterfaceClass_getName(InterfaceClass* hinst) 
   lib.testlib_InterfaceClass_getName.argtypes = [ ctypes.c_void_p ]
   lib.testlib_InterfaceClass_getName.restype  = ctypes.POINTER(ctypes.c_char)

   # void testlib_InterfaceClass_setName(InterfaceClass* hinst, const char* name)
   >>> lib.testlib_InterfaceClass_setName.argtypes = [ ctypes.c_void_p, ctypes.POINTER(ctypes.c_char) ]
   >>> lib.testlib_InterfaceClass_setName.restype = None

   >>> lib.testlib_InterfaceClass_getName(hinstA)
   <ctypes.LP_c_char object at 0x0000021BFBBF1548>

   >>> ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstA))
   b'Unammed-A'

   >>> ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstB))
   b'Unammed-B'

   >>> lib.testlib_InterfaceClass_setName(hinstA, "Instance-ClassA1".encode('utf-8'))
   >>> ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstA))
   b'Instance-ClassA1'

   >>> lib.testlib_InterfaceClass_setName(hinstB, "Instance-B1".encode('utf-8'))
   >>> ctypes.string_at(lib.testlib_InterfaceClass_getName(hinstB))
   b'Instance-B1'

#+END_SRC

Load C-functions wrappers for the InterfaceClass destructor and
dispose both instances hinstA and hinstB: 

#+BEGIN_SRC python 
  # Destructor function:
  # void testlib_InterfaceClass_delete(InterfaceClass* hinst)
  >>> lib.testlib_InterfaceClass_delete.argtypes = [ ctypes.c_void_p ]
  >>> lib.testlib_InterfaceClass_delete.restype  = None

  # Dispose class hinstA, delete this object 
  >>> lib.testlib_InterfaceClass_delete(hinstA)
   [INFO] ImplementationA deleted => name = Instance-ClassA1 ; type = ImplementationA

  >>> lib.testlib_InterfaceClass_delete(hinstB)
   [INFO] ImplementationB deleted => name = Instance-B1 ; type = ImplementationB
#+END_SRC

Exit python3 REPL:

#+BEGIN_SRC python 
   >>> exit()
   testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 4280
   testlib.cpp:49: <DllMain> => DLL attached
    [StaticObject] => Shutdown DLL
#+END_SRC

*** Python 3 Client Code - Wrapper Module 

All the boilerplate code required to load the shared library
testlib.dll can be eliminated by crafting a python module file and
wrapper classes.

Source:
 + File: [[file:src/dlls/example-windows1/pywrapper.py][file:src/dlls/example-windows1/pywrapper.py]]
 + Gist: [[https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71][Gisthub]]


 *Module Initialization:*

 + File: pywrapper.py

The function _config initializes the wrapper module, loading the DLL -
share library testlib.dll into the current Python3 interpreter process
and setting up the C-functions (functions exported with C-linkage,
without name mangling) exported by the library.

#+BEGIN_SRC python 
  import ctypes

  def _getSharedLibrary(libname):
      import sys
      import os
      libfile = libname 
      if sys.platform == "linux" or sys.platform == "linux2":
          libfile = "lib" + libname + ".so"
      elif sys.platform == "darwin":
          libfile =  libname + ".dylyb"
      elif  sys.platform == "win32":
          libfile = libname + ".dll"
      libpath = os.path.join(os.path.dirname(__file__), libfile)
      print(" [INFO] libpath = " + libpath)
      return libpath

  # _lib = ctypes.cdll.LoadLibrary("testlib")
  _lib = ctypes.cdll.LoadLibrary(_getSharedLibrary("testlib"))

  # Startup ctypes FFI - Foreign Function Interface 
  def _config():
      print("Intializing library")
      # ======= std::vector<double> and Linalg:: namespace ==========##
    
      # hVectorD testlib_vectorD_make0(size_t n, double x)
      _lib.testlib_vectorD_make0.argtypes = [ctypes.c_int, ctypes.c_double]
      _lib.testlib_vectorD_make0.restype  = ctypes.c_void_p

      # hVectorD testlib_vectorD_make1(size_t n, double array [])
      _lib.testlib_vectorD_make1.argtypes = [ctypes.c_int, ctypes.POINTER(ctypes.c_double)]
      _lib.testlib_vectorD_make1.restype  = ctypes.c_void_p    

  _config()
#+END_SRC

The class VectorD is a wrapper class for the STL class
std::vector<double> and the namespace Linalg containing linear algebra
functions. 

#+BEGIN_SRC python 
  class VectorD:
      def __init__(self, handle):
          self.hnd = ctypes.c_void_p(handle)
          self.name = "std::vector<double> vx"

      @classmethod
      def fromValue(cls, size, x):
          return VectorD(_lib.testlib_vectorD_make0(size, x))

      @classmethod
      def fromArray(cls, array):
          carray_size_n = ctypes.c_double * len(array)
          return VectorD(_lib.testlib_vectorD_make1(len(array), carray_size_n(*array)))

      # Destructor 
      def __del__(self):
          print(" [TRACE] - Vector disposed - C++ Destructor invoked Ok.")
          _lib.testlib_vectorD_delete(self.hnd)

      def setName(self, name):
          self.name = name

      # Display vector 
      def disp(self):
          _lib.testlib_vectorD_Linalg_printVector(self.name.encode('utf-8'), self.hnd)

      # Set element at nth position 
      def set(self, idx, x):
          _lib.testlib_vectorD_set(self.hnd, idx, x)

      def norm(self):
          return _lib.testlib_vectorD_Linalg_norm(self.hnd)
#+END_SRC

The class CPPInterfaceClass is a wrapper for the C++ interface class
InterfaceClass exported by the DLL. The python wrapper class contains
factory methods .factory, .makeA for loading the implementation class
ImplementationA and the method .makeB for loading the implementation
ImplementationB. 

#+BEGIN_SRC python 
  # Proxy for C++ Interface class in the shared library 
  class CPPInterfaceClass:
      # Constructor 
      def __init__(self, handle):
          self.hnd = ctypes.c_void_p(handle)

      # Destructor 
      def __del__(self):
          # Call C++ destructor
          # print(" [__del__] => self.hnd = " + str(self.hnd))
          _lib.testlib_InterfaceClass_delete(self.hnd)

      @classmethod
      def factory(cls, classID):
          return CPPInterfaceClass(_lib.teslib_InterfaceClass_factory(classID.encode('utf-8')))

      @classmethod
      def makeA(cls):              
          "Instantiate the class ImplementationA from the DLL."
          return CPPInterfaceClass.factory("ImplementationA")

      @classmethod
      def makeB(cls):              
          "Instantiate the class ImplementationB from the DLL."
          return CPPInterfaceClass.factory("ImplementationB")

      def getType(self):
          return ctypes.string_at(_lib.testlib_InterfaceClass_getID(self.hnd)).decode('utf-8')

      def getName(self):
          return ctypes.string_at(_lib.testlib_InterfaceClass_getName(self.hnd)).decode('utf-8')

      def setName(self, name):
          _lib.testlib_InterfaceClass_setName(self.hnd, name.encode('utf-8'))

      # String representation 
      def __str__(self):
          s   = "CInterfaceClass ; type = " + self.getType()
          s +=  " - name =  " + self.getName() + "\n"
          return s

      # Make class printable in the REPL
      def __repr__(self):
          return self.__str__()    
#+END_SRC

Function test1() runs an example code:

#+BEGIN_SRC python 
  def test1():
      print("\n ========  Test 1 - std::vector<double> wrapper and Linalg module ======")
      v1 = VectorD.fromValue(4, 3.5)
      print(" [*]=> Before changing std::vector<double> object")
      v1.disp()
      print("v1.norm() = " + str(v1.norm()))
      print()
      print(" [*]=> After changing std::vector<double> object")
      v1.set(0, 5); v1.set(1, 2.6); v1.set(2, 9.81); v1.set(3, 3.76)
      v1.disp()
      print("v1.norm() " + str(v1.norm()))
      print()

      print("\n ========  Interface class 'InterfaceClass' ======")
      clsA = CPPInterfaceClass.makeA()
      print("clsA = " + str(clsA))
      print("clsA.getType() = " + clsA.getType())

      clsB = CPPInterfaceClass.makeB()
      print("clsB = " + str(clsB))
      print("clsB.getType() = " + clsB.getType())    

  if __name__ == "__main__":    
      test1()

#+END_SRC

 *Usage in Python3 REPL:*

This step assumes that the shared library file (testlib.dll on Windows
or libtestlib.so on Unix-like OS or Linux) is in the same directory as
the python script pywrapper.py.

 + Import module 

#+BEGIN_SRC python 
  $ C:/Users/archbox/Miniconda3/pkgs/python-3.6.5-h0c2934d_0/python
  Python 3.6.5 |Anaconda, Inc.| (default, Mar 29 2018, 13:32:41) [MSC v.1900 64 bit (AMD64)] on win32
  Type "help", "copyright", "credits" or "license" for more information.
  >>>

  >>> from testlib import VectorD
   [StaticObject] => Initialize DLL
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 5776
  testlib.cpp:45: <DllMain> DLL attached to process.
  Intializing library
  Library initialized OK.

  >>> from testlib import CPPInterfaceClass
#+END_SRC

 + Testing class VectorD - wrapper for std::vector<double> 

#+BEGIN_SRC python
  >>> v1 = VectorD.fromValue(5, 3.0)
  >>> v1.disp()
  std::vector<double> vx = [5]( 3, 3, 3, 3, 3,  )

  >>> v1.setName("v1")
  >>> v1.disp()
  v1 = [5]( 3, 3, 3, 3, 3,  )

  >>> v1.norm()
  6.708203932499369

  >>> v1.set(0, 5)
  >>> v1.set(1, 4.5)
  >>> v1.set(2, 9.8)
  >>> v1.set(3, 18.4)

  >>> v1.disp()
  v1 = [5]( 5, 4.5, 9.8, 18.4, 3,  )
  >>>
  >>> v1.norm()
  22.10995251012539

  >>> v1 = 100
   [TRACE] - Vector disposed - C++ Destructor invoked Ok.

  >>> v2 = VectorD.fromArray([4.0, 10.25, 9.6, 3, 10, 6, 15])
  >>> v2.disp()
  std::vector<doubl> vx = [7]( 4, 10.25, 9.6, 3, 10, 6, 15,  )

  >>> v2.norm()
  24.15

  >>> v2.set(0, 100)
  >>> v2.set(1, 200)

  >>> v2.disp()
  std::vector<double> vx = [7]( 100, 200, 9.6, 3, 10, 6, 15,  )

  >>> v2.norm()
  224.63784186997523
  >>>

#+END_SRC

 + Testing class CPPInterfaceClass, proxy for C++ classes
   InterfaceClass, ImplementationA and ImplementationB.

#+BEGIN_SRC python 
   >>> from testlib import CPPInterfaceClass

   # ======== Load ImplementationA  ============== # 
   #
   >>> a = CPPInterfaceClass.makeA()
   >>> a
   CInterfaceClass ; type = ImplementationA - name =  Unammed-A

   >>> a.getType()
   'ImplementationA'
   >>> a.getName()
   'Unammed-A'
   >>> a.setName("Instance-of-ImplA")
   >>> a
   CInterfaceClass ; type = ImplementationA - name =  Instance-of-ImplA

   # ======== Load ImplementationB  ============== # 
   #
   >>> b = CPPInterfaceClass.makeB()
   >>> b
   CInterfaceClass ; type = ImplementationB - name =  Unammed-B

   >>> b.setName("Instance-of-class-B")
   >>> b.getName()
   'Instance-of-class-B'
   >>>
   >>> b.getType()
   'ImplementationB'

#+END_SRC

 + Exit REPL. 

#+BEGIN_SRC python 
  >>> exit()
   [TRACE] - Vector disposed - C++ Destructor invoked Ok.
   [INFO] ImplementationB deleted => name = Instance-of-class-B ; type = ImplementationB
  testlib.cpp:39: <DllMain> DLL Loaded into the process => PID = 5776
  testlib.cpp:49: <DllMain> => DLL attached
   [StaticObject] => Shutdown DLL
#+END_SRC
*** View symbols exported by the shared library 
**** View exported symbols on Windows (dumpbin)

 *Location of dumpbin tool*

The symbols exported by the DLL can viewed with the dumpbin tool
available from the MSVC developer console.

#+BEGIN_SRC sh 
  $ where dumpbin.exe
  C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.12.25827\bin\Hostx64\x64\dumpbin.exe
#+END_SRC

 *Show DLL exported symbols*

#+BEGIN_SRC sh 
 $ dumpbin.exe /exports testlib.dll 
#+END_SRC

Output: 

#+BEGIN_SRC txt 
  Microsoft (R) COFF/PE Dumper Version 14.12.25835.0
  Copyright (C) Microsoft Corporation.  All rights reserved.


  Dump of file testlib.dll

  File Type: DLL

    Section contains the following exports for testlib.dll

      00000000 characteristics
      FFFFFFFF time date stamp
          0.00 version
             1 ordinal base
            31 number of functions
            31 number of names

      ordinal hint RVA      name

            1    0 00005C50 ??0SampleClass@@QEAA@AEBV0@@Z
            2    1 00001650 ??0SampleClass@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
            3    2 000015E0 ??0SampleClass@@QEAA@XZ
            4    3 000016E0 ??1SampleClass@@QEAA@XZ
            5    4 00007280 ??4SampleClass@@QEAAAEAV0@AEBV0@@Z
            6    5 00001880 ?get@SampleClass@@QEAAHXZ
            7    6 00001830 ?getName@SampleClass@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
            8    7 00001370 ?linTransform@Linalg@@YA?AV?$vector@NV?$allocator@N@std@@@std@@NNAEAV23@@Z
            9    8 000012D0 ?norm@Linalg@@YANAEBV?$vector@NV?$allocator@N@std@@@std@@@Z
           10    9 00001480 ?printVector@Linalg@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEAV?$vector@NV?$allocator@N@std@@@3@@Z
           11    A 000018A0 ?set@SampleClass@@QEAAXH@Z
           12    B 00001D50 DllMain
           13    C 00002720 entryPoint1
           14    D 00002800 main
           15    E 00001B10 teslib_InterfaceClass_factory
           16    F 00001C60 testlib_InterfaceClass_delete
           17   10 00001CC0 testlib_InterfaceClass_getID
           18   11 00001D20 testlib_InterfaceClass_getName
           19   12 00001CF0 testlib_InterfaceClass_setName
           20   13 00001A10 testlib_SampleClass_delete
           21   14 00001A60 testlib_SampleClass_get
           22   15 00001AB0 testlib_SampleClass_getName
           23   16 00001900 testlib_SampleClass_make0
           24   17 00001950 testlib_SampleClass_make1
           25   18 00001A80 testlib_SampleClass_set
           26   19 00001560 testlib_vectorD_Linalg_norm
           27   1A 00001580 testlib_vectorD_Linalg_printVector
           28   1B 000026D0 testlib_vectorD_delete
           29   1C 00002590 testlib_vectorD_make0
           30   1D 00002610 testlib_vectorD_make1
           31   1E 00002690 testlib_vectorD_set

    Summary

          3000 .data
          4000 .pdata
         18000 .rdata
          1000 .reloc
         2F000 .text
#+END_SRC

Note that: 

 +  Functions with C-linkage are not mangled, their symbols match
   their names, for instance:

#+BEGIN_SRC sh 
    15    E 00001B10 teslib_InterfaceClass_factory
   16    F 00001C60 testlib_InterfaceClass_delete
   17   10 00001CC0 testlib_InterfaceClass_getID
   18   11 00001D20 testlib_InterfaceClass_getName
   19   12 00001CF0 testlib_InterfaceClass_setName
   20   13 00001A10 testlib_SampleClass_delete
   21   14 00001A60 testlib_SampleClass_get
   22   15 00001AB0 testlib_SampleClass_getName
#+END_SRC

 + Functions, member functions, namespaces and everything without
   C-linkage are mangled, the compiler generate an unique name for the
   generated symbols: 

#+BEGIN_SRC sh 
   1    0 00005C50 ??0SampleClass@@QEAA@AEBV0@@Z
   2    1 00001650 ??0SampleClass@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
   3    2 000015E0 ??0SampleClass@@QEAA@XZ
   4    3 000016E0 ??1SampleClass@@QEAA@XZ
   5    4 00007280 ??4SampleClass@@QEAAAEAV0@AEBV0@@Z
   6    5 00001880 ?get@SampleClass@@QEAAHXZ
   7    6 00001830 ?getName@SampleClass@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
   8    7 00001370 ?linTransform@Linalg@@YA?AV?$vector@NV?$allocator@N@std@@@std@@NNAEAV23@@Z
   9    8 000012D0 ?norm@Linalg@@YANAEBV?$vector@NV?$allocator@N@std@@@std@@@Z
  10    9 00001480 ?printVector@Linalg@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEAV?$vector@NV?$allocator@N@std@@@3@@Z
  11    A 000018A0 ?set@SampleClass@@QEAAXH@Z
#+END_SRC

It is possible to demangle those symbols with the tool - https://demangler.com/

 + Symbol: ??0SampleClass@@QEAA@AEBV0@@Z demangled:

#+BEGIN_SRC sh
  public: __cdecl SampleClass::SampleClass(class SampleClass const & __ptr64) __ptr64
#+END_SRC

 + Symbol: ?get@SampleClass@@QEAAHXZ demangled:

#+BEGIN_SRC sh
  public: int __cdecl SampleClass::get(void) __ptr64
#+END_SRC

 + Symbol: ?linTransform@Linalg@@YA?AV?$vector@NV?$allocator@N@std@@@std@@NNAEAV23@@Z demangled:

#+BEGIN_SRC cpp 
  class std::vector<double,class std::allocator<double> > __cdecl Linalg::linTransform(double,double,class std::vector<double,class std::allocator<double> > & __ptr64)
#+END_SRC

**** View exports symbols on Unix-like OSes (nm)

View exported symbols with nm:

 + Note that only functions annotated with extern "C" such as
   _teslib_InterfaceClass_factory_ are not mangled. 

#+BEGIN_SRC sh 
  $ nm -D libtestlib.so 

  000000000020a3d8 B __bss_start
                   U __cxa_atexit
                   w __cxa_finalize
                   U __cxa_pure_virtual
  000000000020a3d8 D _edata
  000000000020a440 B _end
  000000000000710c T _fini
                   w __gmon_start__
  ... ...   ... ...   ... ...   ... ...   ... ... 
  0000000000005512 T teslib_InterfaceClass_factory
  0000000000005629 T testlib_InterfaceClass_delete
  0000000000005656 T testlib_InterfaceClass_getID
  00000000000056a8 T testlib_InterfaceClass_getName
  0000000000005677 T testlib_InterfaceClass_setName
  000000000000545c T testlib_SampleClass_delete
  000000000000548f T testlib_SampleClass_get
  00000000000054cc T testlib_SampleClass_getName
   
  ... ... ... ...   ... ... ... ... 

  0000000000005076 T _ZN11SampleClassC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
  0000000000005106 T _ZN11SampleClassC2Ev
  0000000000005196 T _ZN11SampleClassD1Ev

#+END_SRC

View exported symbols demangled (without name mangling):

#+BEGIN_SRC sh 
   $ nm -CD libtestlib.so 
   000000000020a3d8 B __bss_start
                    U __cxa_atexit
                    w __cxa_finalize

    ... ... ...  ... ... ...  ... ... ...  ... ... ... 

   0000000000004fe7 T testlib_vectorD_Linalg_norm
   000000000000500f T testlib_vectorD_Linalg_printVector
   0000000000004e52 T testlib_vectorD_make0
   0000000000004ee2 T testlib_vectorD_make1
   0000000000004f80 T testlib_vectorD_set
                    U _Unwind_Resume
                    U operator delete(void*)
                    U operator delete(void*, unsigned long)
   00000000000052fe T SampleClass::get()
   0000000000005310 T SampleClass::set(int)

    ...  ...  ...  ...  ...  ...  ... 

   00000000000070ac W double* std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<double>(double const*, double const*, double*)
   0000000000006cfe W void std::_Destroy_aux<true>::__destroy<double*>(double*, double*)
   0000000000006c74 W std::_Vector_base<double, std::allocator<double> >::_M_allocate(unsigned long)
   0000000000006a44 W std::_Vector_base<double, std::allocator<double> >::_Vector_impl::_Vector_impl(std::allocator<double> const&)
   0000000000006a44 W std::_Vector_base<double, std::allocator<double> >::_Vector_impl::_Vector_impl(std::allocator<double> const&)
   000000000000681a W std::_Vector_base<double, std::allocator<double> >::_Vector_impl::~_Vector_impl()
   000000000000681a W std::_Vector_base<double, std::allocator<double> >::_Vector_impl::~_Vector_impl()
   0000000000006ae8 W std::_Vector_base<double, std::allocator<double> >::_M_deallocate(double*, unsigned long)
   0000000000006a8e W std::_Vector_base<double, std::allocator<double> >::_M_create_storage(unsigned long)
   0000000000006926 W std::_Vector_base<double, std::allocator<double> >::_M_get_Tp_allocator()
   0000000000006836 W std::_Vector_base<double, std::allocator<double> >::_Vector_base(unsigned long, std::allocator<double> const&)
   00000000000069d2 W std::_Vector_base<double, std::allocator<double> >::_Vector_base(std::allocator<double> const&)
   0000000000006836 W std::_Vector_base<double, std::allocator<double> >::_Vector_base(unsigned long, std::allocator<double> const&)
   00000000000069d2 W std::_Vector_base<double, std::allocator<double> >::_Vector_base(std::allocator<double> const&)

  ... ... ... ... ... 

  0000000000006706 W std::function<void ()>::function(std::function<void ()> const&)
  0000000000006706 W std::function<void ()>::function(std::function<void ()> const&)
  00000000000062b2 W std::function<void ()>::~function()
  00000000000062b2 W std::function<void ()>::~function()
                   U std::ios_base::Init::Init()
                   U std::ios_base::Init::~Init()
#+END_SRC

** TODO Shared Libraries on Linux 
