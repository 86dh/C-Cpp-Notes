#+TITLE: CPP / C++ Review
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 
#+AUTHOR: Caio Rodrigues 

* STL - Standard Library Reference Card 
** STL Sequential Container Methods - Cheat Sheet  


| Method of Container<T> | Return type | Description                                              | vector | deque | list | array |
|------------------------+-------------+----------------------------------------------------------+--------+-------+------+-------|
| *Element Access*         |             |                                                          |        |       |      |       |
| operator[](int n)      | T&          | return nth-element, doesn't throw exception.             | yes    | yes   | no   | yes   |
| at(int n)              | T&          | return nth-element, but throws exception.                | yes    | yes   | no   | yes   |
| front()                | T&          | return first element                                     | yes    | yes   | yes  | yes   |
| back()                 | T&          | return last element                                      | yes    | yes   | yes  | yes   |
| data()                 | T*          | Return pointer to first element of container.            | yes    | no    | no   | yes   |
|                        |             |                                                          |        |       |      |       |
| *Capacity*               |             |                                                          |        |       |      |       |
| size()                 | size_t      | Return number of container elements.                     | yes    | yes   | yes  | yes   |
| max_size()             | size_t      | Return maximum container size.                           | yes    | yes   | yes  | yes   |
| empty()                | bool        | Return true if container is empty                        | yes    | yes   | yes  | yes   |
| reserve(size_t n)      | void        | Reserve a minimum storage for vectors.                   | yes    | no    | no   | no    |
| resize(size_t n)       | void        | Resize container to n elements.                          | yes    | yes   | yes  | no    |
|                        |             |                                                          |        |       |      |       |
| *Modifiers*              |             |                                                          |        |       |      |       |
| ~push_back(T t)~         | void        | Add element at the end of container                      | yes    | yes   | yes  | no    |
| ~push_front(T t)~        | void        | Add element at the beggining of container.               | yes    | yes   | yes  | no    |
| ~pop_back()~             | void        | Delete element at the end of container.                  | yes    | yes   | yes  | no    |
| ~pop_front()~            | void        | Delete element at beginning of container.                | yes    | yes   | yes  | no    |
| emplace_back           | void        | Construct and insert element at the end without copying. | yes    | yes   | yes  | no    |
| clear()                | void        | Remove all elements.                                     | yes    | yes   | yes  | no    |
| fill(T t)              | void        | Fill all elements                                        | no     | no    | no   | yes   |
|                        |             |                                                          |        |       |      |       |
| *Iterator*               |             |                                                          |        |       |      |       |
| begin()                | iterator    | Return iterator to beggining                             |        |       |      |       |
| end()                  | iterator    | Return iterator to end                                   |        |       |      |       |
| rbegin()               | iterator    | Return reverse iterator to beggining                     |        |       |      |       |
| rend()                 | iterator    | Return reverse iterator to end                           |        |       |      |       |
| cbegin()               | iterator    | Return const iterator to beginning                       |        |       |      |       |
| cend()                 | iterator    | Return const iterator to end                             |        |       |      |       |
| crebegin()             | iterator    | Return const iterator to beginning                       |        |       |      |       |
| crend()                | iterator    | Return const iterator to end                             |        |       |      |       |

Use Cases: 
 + _vector_
   + Operations where the vector size is known in advance and it is
     necessary constant access time for random access to any
     element. Example of use case: linear algebra and numerical
     algorithms. Insertion of elements at end or at the front is
     efficient, however it less efficient than the deque container and
     whenever a new element is added. Vectors are not ideal for
     operations where the number of elements is not known because its
     elements are stored in C-array allocated in the heap, as result,
     all elements are reallocated whenever a new element is added or
     removed.
   + Use cases:
     + General sequential container
     + Linear algebra and numerical algorithms 
     + C++ replacement for C-arrays 
     + C-arrays interoperability
 + _deque_
   + Operations with requires fast random access time and fast
     insertion or deletion of elements at both ends. Unlike vectors,
     deque is not stored internally as a C-array and unlike vectors,
     whenever an element is inserted, any reallocation happens which
     means that deques are more efficient than vectors when the size
     of container is not known in advance.
   + Use Case:
     + General sequential container
     + Fast random access
     + Number of elements aren't known in advance. 

Vector constructors: 

#+BEGIN_SRC cpp 
  // Empty vector 
  >> std::vector<double> xs1
  (std::vector<double> &) {}

  // Intialize vector with a given size
  >> std::vector<double> xs2(5, 3.0)
  (std::vector<double> &) { 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000 }

  // Constructor with uniform initialization 
  >> std::vector<double> xs4 {1.0, -2.0, 1.0, 10 }
  (std::vector<double> &) { 1.0000000, -2.0000000, 1.0000000, 10.000000 }

  // =========== Constructors with C++11 auto keyword =============//

  >> auto xs1 = vector<double>()
  (std::vector<double, std::allocator<double> > &) {}
  >> 
  >> auto xs2 = vector<double>(5, 3.0)
  (std::vector<double, std::allocator<double> > &) { 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000 }
  >> 
  >> auto xs3 = vector<double>{1, -2, 1, 1}
  (std::vector<double, std::allocator<double> > &) { 1.0000000, -2.0000000, 1.0000000, 1.0000000 }
  >> 
#+END_SRC

Deque constructors: 

#+BEGIN_SRC cpp 
  >> std::deque<int> ds1
  (std::deque<int> &) {}
  >> 
  >> std::deque<int> ds2(5, 2)
  (std::deque<int> &) { 2, 2, 2, 2, 2 }
  >> 
  >> std::deque<int> ds3 {2, -10, 20, 100, 20}
  (std::deque<int> &) { 2, -10, 20, 100, 20 }
  >> 
  // ======== Constructors with auto type inference ========== //
  >> auto ds1 = std::deque<int>()
  (std::deque<int, std::allocator<int> > &) {}
  >> 
  >> auto ds2 = std::deque<int>(5, 2)
  (std::deque<int, std::allocator<int> > &) { 2, 2, 2, 2, 2 }
  >> 
  >> auto ds3 = std::deque<int>{2, -10, 20, 100, 20}
  (std::deque<int, std::allocator<int> > &) { 2, -10, 20, 100, 20 }
  >> 
#+END_SRC

References: 
 + [[http://www.cplusplus.com/reference/vector/vector/][vector - C++ Reference]]  
 + [[http://www.cplusplus.com/reference/stl/][Containers - C++ Reference]] 
 + [[https://embeddedartistry.com/blog/2017/9/11/choosing-the-right-stl-container-sequential-containers][Choosing the Right Container: Sequential Containers â€” Embedded Artistry]]
 + [[http://cs.stmarys.ca/~porter/csc/ref/stl/containers_sequential.html][STL Sequential Container Member Function Summary]] 
	 
