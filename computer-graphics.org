#+INCLUDE: theme/style.org
#+TITLE: Computer Graphics 
#+DESCRIPTION: cpp/c++ interoperability ffi shim qt5 widgets gui library wrapper julia dlang
#+STARTUP: content


* Computer Graphics 
** Main Computer Graphics APIs 

 *Native Graphics APIs* (exposed as C-subroutines)

  + [[https://www.opengl.org//][OpenGL]] (Khronos Group) - Main OpenGL specification
    + => Open standard, cross-platform and vendor-independent API for
      rendering 2D or 3D computer graphics with GPU (Graphics
      Processing Unit) acceleration. OpenGL can be used for
      implementing computer graphics, games, scientific vizualization,
      virtual reality and CADs - Computer Aided Design
      software. OpenGL API specificiation is maintained as an
      open-standard by the Krhonos Group industry consortium.

    + => OpenGL has two modes, _immediate mode_ (a.k.a fixed-function
      pipeline, legacy-OpenGL) which is being depreacted, and _retained_
      _mode_ (modern OpenGL) that delivers more performance and is based
      on buffer-objects and shaders.

    + => OpenGL Official Specification: [[https://www.khronos.org/registry/OpenGL/index_gl.php][Khronos OpenGL® Registry]]

  + _OpenGL ES_  (Khronos Group)
    + => OpenGL for embedded systems, mobile devices and touch screen
      devices and so on. This API (Application Programming Interface)
      is widely used by many mobile games. 

    + => Similar to OpenGL specfication, but supports only the
      _retained-mode_. OpenGL ES does not support _immediate-mode_. As a
      result, calls to legacy OpenGL subroutines such as glBegin(),
      glEnd(), glRotate(), glTranslate(), ..., are not supported.

  + [[https://www.khronos.org/vulkan/][Vulkan]]_(Khronos Group)
    + => Graphics API with GPU acceleration that provides more
      low-level GPU control and less overhead than OpenGL. This API is
      designed for taking more advantag of multi-core CPU
      architectures and performing tasks in parallel.

  + [[https://en.wikipedia.org/wiki/DirectX][DirectX]] / Direct3D (Microsoft inc.) - Windows-only
    + => Microsoft's graphics API for accessing the GPU hardware. It
      is only available on operating systems based Windows-NT kernel
      and Windows-CE kernel (embedded version of Windows-NT).

  + [[https://developer.apple.com/metal/][Metal]] (Apple inc.) 
    + => Apple-only API for rendering 2D or 3D computer graphics with
      GPU acceleration. This API is available only on iOS and MacOSX
      operating systems. On iOS and MacOSX, Apple is deprecating and
      phasing out OpenGL in favor of its own  API.

 *Web Computer Graphics APIs* (exposed as Javascript/ECMAScript subroutines)

  + [[https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL][WebGL]] (Khronos Group)  / Html5 API 
    + => Based on OpenGL ES and implemented by major web
      browsers. Unlike OpenGL or OpenGL ES, which are exposed via C
      subroutines, WebGL is exposed to calling codes via JavaScript
      (ECMAScript) and Html5 canvas.

    + => Note: This API does not support OpenGL immediate-mode or
      legacy OpenGL. WebGL only supports _retained-mode_. 

  + [[https://en.wikipedia.org/wiki/WebGPU][WebGPU]] (W3C Consortium) - Upcoming Html5 standard. 
    + => Upcoming graphics API for web browser, based on Vulkan,
      Metal and DirectX which intends to deliver more low level GPU
      control and higher performance. Unlike WebGL, this API is not a
      direct port of any native graphics API such as Vulkan, Metal and
      DirectX. 
    + [[https://gpuweb.github.io/gpuweb/][WebGPU - Editor’s Draft]] 
    + [[https://github.com/gpuweb/gpuweb/wiki/Implementation-Status][Implementation Status · gpuweb/gpuweb Wiki · GitHub]]
    + [[https://github.com/gpuweb/gpuweb][GitHub - gpuweb/gpuweb: Where the GPU for the Web work happens!]]
    + [[https://kvark.github.io/web/gpu/native/2020/05/03/point-of-webgpu-native.html][Point of WebGPU on native]]
    + [[https://hacks.mozilla.org/2020/04/experimental-webgpu-in-firefox/][A Taste of WebGPU in Firefox - Mozilla Hacks - the Web developer blog]]


 *Further Reading* 

  + [[https://vulkan.gpuinfo.org/listdevices.php][Devices - Vulkan Hardware Database by Sascha Willems]] 

  + [[https://github.com/KhronosGroup/MoltenVK][GitHub - KhronosGroup/MoltenVK]]
    + "MoltenVK is a Vulkan Portability implementation. It layers a
      subset of the high-performance, industry-standard Vulkan
      graphics and compute API over Apple's Metal graphics framework,
      enabling Vulkan applications to run on iOS and macOS."

  + [[https://www.pcgamer.com/doom-benchmarks-return-vulkan-vs-opengl/][Doom benchmarks return: Vulkan vs. OpenGL | PC Gamer]]

  + [[https://linuxhint.com/vulkan-for-linux-users/][Vulkan for Linux Users – Linux Hint]] 

  + [[https://stackoverflow.com/questions/56766983/what-can-vulkan-do-specifically-that-opengl-4-6-cannot][What can Vulkan do specifically that OpenGL 4.6+ cannot? - Stack]]

  + [[https://softwareengineering.stackexchange.com/questions/380832/opengl-and-global-state][design - OpenGL and global state - Software Engineering Stack Exchange]]

** OpenGL companion libraries 

  *OpenGL Companion Libraries* 

Core Libraries:

  + _GL_  - OpenGL Graphics API 

OpenGL Loaders:

  + Libraries that abstracts OpenGL function pointers loading in a
    platform-independent way. 

  + [[http://glew.sourceforge.net/index.html][GLEW]] - OpenGL Extension Wrangler [MOST USED]
    + "The OpenGL Extension Wrangler Library (GLEW) is a
      cross-platform open-source C/C++ extension loading library. GLEW
      provides efficient run-time mechanisms for determining which
      OpenGL extensions are supported on the target platform. OpenGL
      core and extension functionality is exposed in a single header
      file. GLEW has been tested on a variety of operating systems,
      including Windows, Linux, Mac OS X, FreeBSD, Irix, and Solaris."

  + [[https://glad.dav1d.de/][GLAD]] - [MOST-USED] Multi-Language GL/GLES/EGL/GLX/WGL
    Loader-Generator based on the official specs.

  + [[https://github.com/cginternals/glbinding][GitHub - cginternals/glbinding]]
    + "A C++ binding for the OpenGL API, generated using the gl.xml
      specification." 

  + [[https://github.com/anholt/libepoxy][GitHub - anholt/libepoxy]]
    + "Epoxy is a library for handling OpenGL function pointer
      management for you."

  + [[https://github.com/imakris/glatter][GitHub - imakris/glatter]]
    + "An OpenGL loading library, with support for GL, GLES, EGL, GLX and WGL"

  + [[https://galogen.gpfault.net/][Galogen OpenGL Loader Generator]]
    + "Galogen is an OpenGL loader generator. Given an API version and
      a list of extensions, Galogen will produce corresponding headers
      and code that load the exact OpenGL entry points you need. The
      produced code can then be used directly by your C or C++
      application, without having to link against any additional
      libraries." 

  + [[https://github.com/SFML/SFML-glLoadGen][GitHub - SFML/SFML-glLoadGen]]
    + Customized glLoadGen for SFML

Libraries for window systems, event handling and OpenGL context abstraction: 
 
  + Abstract platform-specific window system and event handling. 

  + [[https://www.glfw.org/][GLFW]] [BEST] [MOST-USED]
    * C library that provides graphics windows for OpenGL, Vulkan,
      OpenGL ES and deals with event handling.

  + [[https://www.libsdl.org/][SDL]] (Simple Direct Media Layer) [BEST] [MOST-USED]
    * Cross-platform C library that provides windows and event
      handling for many computer graphics APIs such as OpenGL, Vulkan
      and DirectX. SLD also has facilities for dealing with audio,
      joystick, CD-ROM, network and threads.

  + [[http://freeglut.sourceforge.net/][GLUT]] (FreeGlut) - OpenGL Utility Toolkit
    * Deals with window creation, OpenGL initialization, event
      handling and  so on.
    * Docs: https://www.glfw.org/documentation.html


OpenGL Math and Matrix Transformations: 

  + [[https://glm.g-truc.net/0.9.5/api/index.html][GLM]] (OpenGL Mathematics Library) [MOST-USED]
    + Source code: https://github.com/g-truc/glm
    + Header-only C++ library that provides classes for computer
      graphics mathematics such as: 2D, 3D and homogeneous coordinate
      vector; 2D, 3D and homogeneous coordinate transformation
      matrices; quaternions and subroutines for computing camera,
      perspective or orthogonal transformation matrices.

  + [[https://github.com/Kazade/kazmath][GitHub - Kazade/kazmath]] - A C math library targeted at games
    + "Kazmath is a simple 3D maths library written in C. It was
      initially coded for use in my book, Beginning OpenGL Game
      Programming - Second edition, but rapidly gained a life of its
      own. Kazmath is now used by many different projects, and
      apparently is used in 25% of the worlds mobile games (yeah, I
      don't believe it either - but it's used in Cocos2d-x)." 

  + [[https://github.com/recp/cglm][GitHub - recp/cglm]] -  Highly Optimized Graphics Math (glm) for C

  + See: [[https://github.com/chunkyguy/Math-Library-Test][GitHub - chunkyguy/Math-Library-Test]] - A comparison of the
    various major math libraries for speed and ease of use. 


 *See also:*

  + [[https://www.khronos.org/opengl/wiki/OpenGL_Loading_Library][OpenGL Loading Library - OpenGL Wiki]] / Khronos Group
    + "An OpenGL Loading Library is a library that loads pointers to
      OpenGL functions at runtime, core as well as extensions. This is
      required to access functions from OpenGL versions above 1.1 on
      most platforms. Extension loading libraries also abstracts away
      the difference between the loading mechanisms on different
      platforms."

  + [[https://stackoverflow.com/questions/27873784/when-do-i-need-to-use-an-opengl-function-loader][When do I need to use an OpenGL function loader? - Stack Overflow]]

  + [[https://keyj.emphy.de/glext/][KeyJ's Blog : Blog Archive » Modern OpenGL with lcc-win32, the hard way]]

  + [[https://apoorvaj.io/loading-opengl-without-glew/][Loading OpenGL without GLEW]] 

  + [[https://www.libsdl.org/release/SDL-1.2.15/docs/html/guidevideoopengl.html][Using OpenGL With SDL]] - LibSDL

  + [[https://www.khronos.org/opengl/wiki/Tutorial1:_Creating_a_Cross_Platform_OpenGL_3.2_Context_in_SDL_(C_/_SDL)][Tutorial1: Creating a Cross Platform OpenGL 3.2 Context in SDL (C / SDL) - OpenGL Wiki]]
** OpenGL Terminology

  + _OpenGL_ - Open Graphics Library

  + [[http://glew.sourceforge.net/index.html][GLEW]] - OpenGL Extension Wrangler

  + ARB - Architecture Review Board 

  + OpenGL _Immediate Mode_ (Fixed-Function Pipeline, Legacy OpenGL)
    * Also known as: Legacy OpenGL, Fixed-Function Pipeline 
    * Drawing is mostly performed without storing data on GPU and by
      using subroutines calls to glScale(), glRotate(), glPush(), glPop(),
      glTranslate(), glBegin(), glEnd() and so on.
    * Immediate-mode is not supported by OpenGL ES or WebGL.

  + OpenGL _restrained mode_ (Programmable Pipeline, Modern OpenGL)
    * Also known as: Modern OpenGL, Programmable Pipeline 
    * New and modern OpenGL API => Drawing is performed by storing
      data on the GPU via VBO (Vertex Buffer Objects) and by using
      _shaders_, programs that runs on GPU, for performing geometric
      vertex transformations, color and texturing computations.
    * More peformant than _immediate-mode_ as the data is not sent to
      the GPU every frame. 

  + _GPU_ - Graphics Processing Unit

  + _GPGPU_ - General Purpose Computing on GPU
    + APIs: OpenGL, Cuda, and so on. 
    + Parallel non-graphics computations on GPU. GPGPU APIs take
      advantage of GPU parallel computing features for high
      performance computing.

  + _Vertex_ - 2D or 3D coordinates representing a point in the space.

  + _2D_ - 2 dimensions (plane) / 2 coordinates (X, Y)

  + _3D_ - 3 dimensions (space) / 3 coordinates (X, Y, Z)

  + _Homogenous Coordinate_ - Coordinate system using an extra dimension
    for encoding translation coordinate transformation in the same way
    as rotation matrices transformations.
    + 2D homogeneous coordinates: (X, Y, W = 1)
    + 3D homogeneous coordinates: (X, Y, Z, W = 1)

  + _NDC_ - Normalized Device Coordinate
    + Default coordinates used by OpenGL (-1.0 to 1.0) for each
      axis. Any vertex that falls out of this range will not be visible
      on the screen. 

  + _VBO_ - Vertex Buffer Object

  + _VAO_ - Vertex Array Object

  + _FBO_ - Framebuffer Object

  + _IBO_ - Index Buffer Object

  + _UBO_ - Uniform Buffer Object 

  + _FPS_ - Frame Per Seconds 

  + _Shader_ - Program that runs on the GPU and performs vertex
    computations such as coordinate transformations (matrix
    multiplications), colors and texture computations.

  + _GLSL_ - OpenGL shading programming language - for performing
    computer graphics calculations on the GPU hardware.

  + _HLSL_ (High-Level Shader Language) - Microsft DirectX shading language.

** Legacy OpenGL Subroutines

The following OpenGL subroutines are from the OpenGL immediate mode
(fixed-function pipeline) and are useful for identifying codes using
immediate-mode. 

  + Vertex:
    + glVertex2f() 
    + glVertex2f()
    + glVertex3f()

  + Begin/End:
    + glEnd()
    + glBegin()

  + Colors
    + glColor()
    + glMaterial()
    + glVertexPointer() 

  + Coordinate Transformation
    + glLoadIdentity()
    + glRotate()
    + glTranslate()
    + glScale()
    + glRotate3f()
    + glMatrixMode()
    + glFrustum()
    + gluLookAt()
    + gluPerspective() 

  + Save Context 
    + glPop()
    + glPush()
    + glPushMatrix()
    + glPopMatrix()
** Library GLM - OpenGL Math 

The library GLM (OpenGL math library) contains many classes and
subroutines for computer graphics computations, such as: homogeneous
coordinates; quaternios; 1D, 2D, 3D and homogeneous coordinates
vectors; vector-matrix operations and so on. Aside those facilities,
the library also provides the subroutines _glm::lookAt()_, for computing
view matrix transform, that turns world coordinates into camera
coordinates; _glm::perspective()_ - for computing the projection matrix,
that turns camera coordinates into clip-space coordinates (NDC
coordinates with range -1.0 to 1.0) and also _glm::ortho_ for computing
the orthogonal perspective matrix.

Web Site: 

  + [[https://glm.g-truc.net/0.9.9/index.html][OpenGL Mathematics]] 

Repository:

  + https://github.com/g-truc/glm


Type signature of most relevant GLM functions: 

#+BEGIN_SRC cpp 
   // ------ Basic Matrix Transformation =>> Useful for model matrix ---------------//
   float     glm::radians(foat  degrees);
   glm::mat4 glm::rotate   ( glm::mat4 const & m, float angle, glm::vec3 const & axis );
   glm::mat4 glm::scale    ( glm::mat4 const & m, glm::vec3 const & factors           );
   glm::mat4 glm::translate( glm::mat4 const & m, glm::vec3 const & translation       );


   // ---- Camera and  Perspective transformation matrices -------------//
   glm::mat4 glm::lookAt( glm::vec3 const & eye, glm::vec3 const & look, glm::vec3 const & up ); 
   glm::mat4 glm::ortho( float left, float right, float bottom, float top, float near, float far );
   glm::mat4 glm::ortho( float left, float right, float bottom, float top );
   glm::mat4 glm::frustum( float left, float right, float bottom, float top, float near, float far );
   glm::mat4 glm::perspective( float fovy, float aspect, float near, float far);
#+END_SRC


 *Downloading* 

#+BEGIN_SRC sh 
   $ mkdir -p /tmp/temp && cd /temp
  
   # Download source code archive 
   $ >> curl -o glm.zip -L https://github.com/g-truc/glm/archive/master.zip

   # Extract code 
   $ >> unzip  glm.zip
 
   # Enter the in the extracted directory 
   $ >> cd glm-master/

   # List directory content 
   $ >> ls
   cmake/  CMakeLists.txt  copying.txt  doc/  glm/  manual.md  readme.md  test/  util/
#+END_SRC

 *Load the library in CERN's ROOT repl* 

#+BEGIN_SRC cpp 
    $ >> ~/Applications/root/bin/root 
   ERROR in cling::CIFactory::createCI(): cannot extract standard library include paths!
   Invoking:
     LC_ALL=C ccache  -O2 -DNDEBUG -xc++ -E -v /dev/null 2>&1 | sed -n -e '/^.include/,${' -e '/^ \/.*++/p' -e '}'
   Results was:
   With exit code 0
      ------------------------------------------------------------------
     | Welcome to ROOT 6.22/02                        https://root.cern |
     | (c) 1995-2020, The ROOT Team; conception: R. Brun, F. Rademakers |
     | Built for linuxx8664gcc on Aug 17 2020, 12:46:52                 |
     | From tags/v6-22-02@v6-22-02                                      |
     | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q'       |
      ------------------------------------------------------------------

   root [0] 

   root [0] .I . 

   root [0] .I . 
   root [1] #include <glm/glm.hpp>
   root [2] #include <glm/gtc/matrix_transform.hpp>
   root [3] #include <glm/gtc/type_ptr.hpp>
   root [4] #include <glm/gtx/string_cast.hpp>

   // Note: GLM matrices are stored in Column-major order 
   void show_matrix(const char* label, glm::mat4 const& m){
       std::cout << "\n [MATRIX] " << label << " = " << '\n';
       std::cout << std::fixed << std::setprecision(3);
       for(size_t i = 0; i < 4; i++)
       {
           for(size_t j = 0; j < 4; j++)
           {
               std::cout << std::setw(8) << m[j][i];
           }
           std::cout << '\n';
       }
   }
#+END_SRC

Define a 4x4 homogenous coordinate matrix: 

#+BEGIN_SRC cpp 
   root [18] glm::mat4 mat{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
   root [19] 
   root [19] mat
   (glm::mat4 &) @0x7f904e6c2008


   // Matrix is not what user expects as it is written in Column-major order 
   root [20] show_matrix("mat", mat)

    [MATRIX] mat = 
      1.000   5.000   9.000  13.000
      2.000   6.000  10.000  14.000
      3.000   7.000  11.000  15.000
      4.000   8.000  12.000  16.000
   root [21] 

   root [21] mat[0][0]
   (float) 1.00000f

   root [22] mat[0][1]
   (float) 2.00000f

   root [23] mat[0][2]
   (float) 3.00000f

   root [24] mat[0][3]
   (float) 4.00000f

   root [25] mat[3][3]
   (float) 16.0000f

   root [26] mat[2][0]
   (float) 9.00000f

   root [27] mat[2][1]
   (float) 10.0000f
#+END_SRC

Obtain transpose matrix: 

#+BEGIN_SRC cpp 
  root [28] auto tmat = glm::transpose(mat)
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2058

  root [29] show_matrix("tmat", tmat)

   [MATRIX] tmat = 
     1.000   2.000   3.000   4.000
     5.000   6.000   7.000   8.000
     9.000  10.000  11.000  12.000
    13.000  14.000  15.000  16.000

  root [33] tmat[0][0]
  (float) 1.00000f

  root [34] tmat[1][0]
  (float) 2.00000f

  root [35] tmat[2][0]
  (float) 3.00000f

  root [36] tmat[3][0]
  (float) 4.00000f


  root [37] tmat[0][0]
  (float) 1.00000f

  root [38] tmat[0][1]
  (float) 5.00000f

  root [39] tmat[0][2]
  (float) 9.00000f

  root [40] tmat[0][3]
  (float) 13.0000f
#+END_SRC

Get pointer to first element: 

#+BEGIN_SRC cpp 
  root [41] float* ptr = glm::value_ptr(tmat)
  (float *) 0x7f904e6c2058

  root [42] ptr[0]
  (float) 1.00000f

  root [43] ptr[1]
  (float) 5.00000f

  root [44] ptr[2]
  (float) 9.00000f

  root [45] ptr[3]
  (float) 13.0000f

  root [46] ptr[4]
  (float) 2.00000f

  root [47] ptr[5]
  (float) 6.00000f

  root [48] ptr[6]
  (float) 10.0000f

  root [49] ptr[7]
  (float) 14.0000f

  root [50] ptr[8]
  (float) 3.00000f
#+END_SRC

Null 4x4 matrix: 

#+BEGIN_SRC cpp 
   root [53] auto zero_4x4 = glm::mat4()
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c20e0

   root [54] show_matrix("zero_4x4", zero_4x4)

    [MATRIX] zero_4x4 = 
      0.000   0.000   0.000   0.000
      0.000   0.000   0.000   0.000
      0.000   0.000   0.000   0.000
      0.000   0.000   0.000   0.000
#+END_SRC

Identity matrix: 

#+BEGIN_SRC cpp 
  root [55] auto id_4x4 = glm::mat4(1.0)
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2120
  root [56] 
  root [56] show_matrix("id_4x4", id_4x4)

   [MATRIX] id_4x4 = 
     1.000   0.000   0.000   0.000
     0.000   1.000   0.000   0.000
     0.000   0.000   1.000   0.000
     0.000   0.000   0.000   1.000
#+END_SRC

Matrix translation coordinate transform: 

#+BEGIN_SRC cpp 
  root [58] auto t1 = glm::translate(id_4x4, glm::vec3(2.0, 10.0, 30.0))
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2160

  root [59] show_matrix("t1", t1)

   [MATRIX] t1 = 
     1.000   0.000   0.000   2.000
     0.000   1.000   0.000  10.000
     0.000   0.000   1.000  30.000
     0.000   0.000   0.000   1.000


  root [62] auto t2 = glm::translate(t1, glm::vec3(-10, 100.0, 200.0))
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c21a0

  root [63] show_matrix("t2", t2)

   [MATRIX] t2 = 
     1.000   0.000   0.000  -8.000
     0.000   1.000   0.000 110.000
     0.000   0.000   1.000 230.000
     0.000   0.000   0.000   1.000
#+END_SRC

Rotation around Z axis of 90 degrees: 

  + glm::mat4 glm::rotate(glm::mat4 const& matrix, float angle_radians, glm::vec3 const& axis)
  + Rotate around a given axis. The angle is given in radians.

#+BEGIN_SRC cpp 
  root [65] const auto axis_z = glm::vec3(0.0f, 0.0f, 1.0f);
  root [66] const auto axis_y = glm::vec3(0.0f, 1.0f, 0.0f);
  root [67] const auto axis_x = glm::vec3(1.0f, 0.0f, 0.0f);


  /*          | cos(t)  -sin(t)   0   0  |
   *          | sin(t)   cos(t)   0   0  |
   *  Rz(t) = |  0        0       1   0  |
   *          |  0        0       0   1  |
   * 
   *  
   *  t_rotZ = Rz(90) x id_4x4 = Rz(90)
   */
  root [71] auto t_rotZ = glm::rotate(id_4x4, glm::radians(90.0f), axis_z)
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2204

  root [72] show_matrix("t_rotZ", t_rotZ)

   [MATRIX] t_rotZ = 
    -0.000  -1.000   0.000   0.000
     1.000  -0.000   0.000   0.000
     0.000   0.000   1.000   0.000
     0.000   0.000   0.000   1.000
  root [73] 

   root [96] glm::to_string(t_rotZ)
   (std::string) "mat4x4((-0.000000, 1.000000, 0.000000, 0.000000), ... "
   root [97] 
#+END_SRC

Scaling transformation: 

#+BEGIN_SRC cpp 
   root [75] auto s1 = glm::scale(id_4x4, glm::vec3(2.0, 2.0, 2.0))
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2244

   root [76] show_matrix("s1", s1)

    [MATRIX] s1 = 
      2.000   0.000   0.000   0.000
      0.000   2.000   0.000   0.000
      0.000   0.000   2.000   0.000
      0.000   0.000   0.000   1.000

   root [78] s1 = glm::scale(s1, glm::vec3(5.0, 5.0, 5.0))
   (glm::mat &) @0x7f904e6c2244

   root [79] show_matrix("s1", s1)

    [MATRIX] s1 = 
     10.000   0.000   0.000   0.000
      0.000  10.000   0.000   0.000
      0.000   0.000  10.000   0.000
      0.000   0.000   0.000   1.000
   root [80] 

   // Apply transform to vector: 

   root [82] auto res = s1 * glm::vec4(2.0, 5.0, 10.0, 1.0)
   (glm::vec<4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2284

   root [91] glm::to_string(res)
   (std::string) "vec4(20.000000, 50.000000, 100.000000, 1.000000)"

   root [92] res[0]
   (float) 20.0000f

   root [93] res[1]
   (float) 50.0000f

   root [94] res[2]
   (float) 100.000f

   root [95] res[3]
   (float) 1.00000f
#+END_SRC

Scaling transformation: 

#+BEGIN_SRC cpp 
   root [97] auto s = glm::scale(id_4x4, glm::vec3(4.0, 5.0, 6.0))
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c22a4

   root [98] show_matrix("s", s)

    [MATRIX] s = 
      4.000   0.000   0.000   0.000
      0.000   5.000   0.000   0.000
      0.000   0.000   6.000   0.000
      0.000   0.000   0.000   1.000
   root [99] 
   root [99] s = glm::translate(s, glm::vec3(4, -5, 9))
   (glm::mat &) @0x7f904e6c22a4


   root [100] show_matrix("s", s)

    [MATRIX] s = 
      4.000   0.000   0.000  16.000
      0.000   5.000   0.000 -25.000
      0.000   0.000   6.000  54.000
      0.000   0.000   0.000   1.000
   root [101] 


   root [105] s = glm::scale(s, glm::vec3(5.0, 2.0, 3.0))
   (glm::mat &) @0x7f904e6c22a4


   root [106] show_matrix("s", s)

    [MATRIX] s = 
     25.000   0.000   0.000  20.000
      0.000   4.000   0.000 -10.000
      0.000   0.000   9.000  27.000
      0.000   0.000   0.000   1.000
#+END_SRC

Inverse matrix: 

#+BEGIN_SRC cpp 
   root [111] show_matrix("s", s)

    [MATRIX] s = 
     25.000   0.000   0.000  20.000
      0.000   4.000   0.000 -10.000
      0.000   0.000   9.000  27.000
      0.000   0.000   0.000   1.000

   root [112] inv_s = glm::inverse(s)
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2324

   root [113] show_matrix("inv_s", inv_s)

    [MATRIX] inv_s = 
      0.040  -0.000   0.000  -0.800
     -0.000   0.250  -0.000   2.500
      0.000  -0.000   0.111  -3.000
     -0.000   0.000  -0.000   1.000
   root [114] 
   root [114] 

#+END_SRC
** Simple 2D draphics - no VBO abstraction 

The following code draws a square and a triangle using the OpenGL
retained mode API. Before the rendering takes place, data must be
upload to the VBO (Vertex Buffer Object), allocated on the GPU-side,
via _glBufferData()_ call that sends the data to the previous bound VBO
through _glBindBuffer()_ call. Then, on the rendering loop and on every
frame, the buffer data layout must described with
_glVertexAttribPointer()_ before drawing via call to _glDrawArrays()_
subroutine, which draw vertices from the current bound buffer. 

Subroutines that modifies global state may cause unintended behavior,
so it is a good practice to unset the affected global state when the
current global state is no longer needed. For instance, if the current
VBO no longer needs to be bound, this global state can be disabled by
calling /glBindBuffer(GL_ARRAY_BUFFER, 0)/.


OpenGL subroutines used: 

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml][glGenBuffers()]] => Instantiate a buffer object. 

#+BEGIN_SRC cpp 
  void glGenBuffers(GLsizei n, GLuint* buffers);
#+END_SRC

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml][glBindBuffer()]] => Bind some buffer object, a.k.a enable, only one
   buffer can be bound at a time. (The VBO is a global state). 

#+BEGIN_SRC cpp 
  void glBindBuffer(GLenum target,nt buffer);
#+END_SRC

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml][glBufferData()]]  =>> Send data to current bound buffer object that
   was bound via glBindBuffer() call. 

#+BEGIN_SRC cpp 
  void glBufferData( GLenum      target,
                     GLsizeiptr  size,
                     const void* data,
                     GLenum      usage
                     );
#+END_SRC

  + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml][glEnableVertexAttribArray()]] 

#+BEGIN_SRC cpp 
  void glEnableVertexAttribArray(GLuint index);
#+END_SRC

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml][glVertexAttribPointer()]]
   + Describes the data layout of current bound buffer. 

#+BEGIN_SRC cpp 
     void glVertexAttribPointer( GLuint      index,
                                 GLint       size,
                                 GLenum      type,
                                 GLboolean   normalized,
                                 GLsizei     stride,
                                 const void* pointer);
#+END_SRC

  + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml][glDrawArrays()]] => Render OpenGL primitives from current bound
    buffer object's data. Those primitives are: lines, triangles or
    quads and so on.  

#+BEGIN_SRC cpp 
  void glDrawArrays(GLenum mode, GLint first, GLsizei count);
#+END_SRC


  *Screenshot* 

[[file:images/opengl-draw2d-raw.png][file:images/opengl-draw2d-raw.png]]

  *Source Code* 

File: _CMakeLists.txt_ 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.5)
  project(GLFW_project)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #================ GLFW Settings  ===============#

  find_package(OpenGL REQUIRED)

  include(FetchContent)

  # Set GLFW Options before FectchContent_MakeAvailable 
  set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

  # Donwload GLFW library
  FetchContent_Declare(
    glfwlib
    URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
  )
  FetchContent_MakeAvailable(glfwlib)

         add_executable( draw2d-raw  draw2d-raw.cpp )
  target_link_libraries( draw2d-raw  glfw OpenGL::GL GLU)
#+END_SRC

File: _draw2d-raw.cpp_ 

#+BEGIN_SRC cpp 
  // Draw curve mapping buffer to the GPU.
  #include <iostream>
  #include <vector> 
  #include <array>
  #include <cmath>
  #include <cassert>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>
  #include <GL/glut.h>


  struct Vertex2D
  {
      GLfloat x;
      GLfloat y;
  };

  int main(int argc, char** argv)
  {
      GLFWwindow* window;

      /* Initialize the library */
      if (!glfwInit())
          return -1;

      glutInit(&argc, argv);

      /* Create a windowed mode window and its OpenGL context */
      window = glfwCreateWindow(640, 480, "2D Drawing raw VBO buffers", NULL, NULL);
      if (!window)
      {
          glfwTerminate();
          return -1;
      }

      /* Make the window's context current */
      glfwMakeContextCurrent(window);
      // glClearColor(0.0f, 0.5f, 0.6f, 1.0f);
      glClearColor(0.0f, 0.0f, 0.0, 1.0f);


      Vertex2D triangle_points[3] = {
          Vertex2D{-0.25,   -0.25}
        , Vertex2D{ 0.00,   0.25}
        , Vertex2D{ 0.25,  -0.25}
      };

      Vertex2D square_points[4] = {
          { -0.3,  -0.3 }
        , { -0.3,   0.3 }
        , {  0.3,   0.3 }
        , {  0.3,  -0.3 }
      };

      // ================== Triangle Buffer ====================//
      //

      GLuint vbo_triangle_ = 0;
    
      // Create an OpenGL VBO buffer 
      // =>> void glGenBuffers (GLsizei n, GLuint *buffers);
      glGenBuffers(  1                // Number of buffers that will be instantiated
                   , &vbo_triangle_   // Address of first element or address of array 
                                      // that results will be written to.
                   );
      assert( vbo_triangle_ != 0 );

      // Set this buffer as the current buffer - Only one buffer can be bound at a time. 
      // =>> void glBindBuffer (GLenum target, GLuint buffer)
      glBindBuffer(GL_ARRAY_BUFFER, vbo_triangle_);

      // Upload data to current VBO buffer in GPU 
      glBufferData(GL_ARRAY_BUFFER, sizeof(triangle_points), triangle_points, GL_STATIC_DRAW);   

      // Unbind current buffer in order to avoid unintended behaviors
      // as the subroutine glBindBuffer() modifies has a global state.
      glBindBuffer(GL_ARRAY_BUFFER, 0);

      // ================ Square / Vertex Buffer Object 2 ==================//
      //      

      GLuint vbo_square_ = 0;
      // Instiate buffer - gets a handle or token for 
      // a buffer allocated on GPU-side.
      glGenBuffers(1, &vbo_square_);
      // Check for error 
      assert( vbo_square_ != 0);
      // Bind Current buffer (Affects global state)
      glBindBuffer(GL_ARRAY_BUFFER, vbo_square_);
      // Upload data to the GPU 
      glBufferData(GL_ARRAY_BUFFER, sizeof(square_points), square_points, GL_STATIC_DRAW);   
      // Unbind buffer 
      glBindBuffer(GL_ARRAY_BUFFER, 0);

      GLint shader_attr = 0;

      //  ======= R E N D E R  - L O O P ============//
      //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//

              // ------------ Draw triangle --------------//
              //
              glBindBuffer(GL_ARRAY_BUFFER, vbo_triangle_);
              glEnableVertexAttribArray(shader_attr);

              // Describe buffer data layout (binary layout)
              // =>> glVertexAttribPointer ( GLuint index, GLint size, GLenum type
              //                           , GLboolean normalized, GLsizei stride, const void *pointer);
              //
              glVertexAttribPointer(shader_attr // GLint  index         => Shader attribute location, 0 for now 
                                  , 2           // GLint  size          => 2 components (X, Y) of type GLfloat
                                  , GL_FLOAT    // GLemum type          => Type of each component  
                                  , GL_FALSE    // GLboolean normalized  
                                  , 0           // GLsizei stride
                                  , nullptr     // const void* pointer 
                                  );
              // Draw arrays using the content of buffer 
              // Plot 1 triangle (each triangle has 3 vertices)
              glDrawArrays(GL_TRIANGLES, 0, 3);

              // Disable global state 
              glBindBuffer(GL_ARRAY_BUFFER, 0);
              glDisableVertexAttribArray(0);
            
              //------------ Draw Square -------------------------//
              //
            
              #if 1
              glBindBuffer(GL_ARRAY_BUFFER, vbo_square_);
              glEnableVertexAttribArray(shader_attr);
              glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);
              // Plot 4 vertices 
              glDrawArrays(GL_LINE_LOOP, 0, 4);

              // Disable global state 
              glBindBuffer(GL_ARRAY_BUFFER, 0);
              glDisableVertexAttribArray(shader_attr);            
              #endif 

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwPollEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }
      }

      glfwTerminate();
      return 0;
  }
#+END_SRC

** Simple 2D graphics - using VBO abstraction

This sample code draws a square, triangle and a chart using 2D
coordinates and ignoring the Z axis. 

Unlike legacy OpenGL (fixed-pipeline) that requires the calling code
to call primitive rendering subroutines on every frame, which has a
significant overhead, Modern OpenGL or retained-mode, uses buffer
objects for storing data on the GPU memory and shaders, programs that
runs on the GPU-side for processing vertexes and colors. The following
code uses _VertexBufferObject_ class for encapsulating VBO - Vertex
Buffer Objects. The challenging of dealing with VBOs is that, many of
subroutines applicable to VBO modify global state or assume that some
global state should be set before calling the subroutine. The effect
of calling the many OpenGL subroutines depends on the state and the
order that they were called.

The code was tested on Ubuntu Linux 64 bits. On Windows, it requires
GLEW for loading OpenGL function pointers. 

 *Screenshot:*

#+CAPTION: OpenGL simple 2D redering with VBO. 
[[file:images/opengl-draw2d.png][file:images/opengl-draw2d.png]]


 *Source Code* 


File: _CMakeLists.txt_ 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.5)
  project(GLFW_project)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #================ GLFW Settings  ===============#

  find_package(OpenGL REQUIRED)

  include(FetchContent)

  # Set GLFW Options before FectchContent_MakeAvailable 
  set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

  # Donwload GLFW library
  FetchContent_Declare(
    glfwlib
    URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
  )
  FetchContent_MakeAvailable(glfwlib)

         add_executable( draw2d  draw2d.cpp )
  target_link_libraries( draw2d  glfw OpenGL::GL GLU)
#+END_SRC

File: _draw2d.cpp_ 

#+BEGIN_SRC cpp 
  // Draw curve mapping buffer to the GPU.
  #include <iostream>
  #include <vector> 
  #include <array>
  #include <cmath>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>
  #include <GL/glut.h>

  // Makes a class non copiable. 
  // Auomates the boilerplate code for 
  // declaring a class as non-copiable 
  #define CL_NON_COPIABLE( className )                  \
      public:                                           \
      className( className const&) = delete;            \
      className& operator= (className const&) = delete; \
      private:


  // Class for encapsulating VBO - Vertex-Buffer Objects 
  class VertexBufferObject
  {
      // Handle for Vertex-Buffer Object (Allocated on GPU memory)
      GLuint  m_vbo = 0;
      // Shader attribute location variable 
      GLuint m_attr_location;

      // Type of single component 
      GLenum  m_type;
      // Number of elements m_type of single component 
      GLsizei m_size;    

      CL_NON_COPIABLE(VertexBufferObject)
  public:

      VertexBufferObject(GLuint shader_attr_loc = 0)
      { 
          m_attr_location = shader_attr_loc;
          ::glGenBuffers(1, &m_vbo);  

          // --- Buffer Object Data Layout parameters ------//
          //
          // Type of single component 
          GLenum  m_type;
          // Number of elements m_type of single component 
          GLsizei m_size;        
      }

      // Destructor 
      ~VertexBufferObject(){ this->dispose();  }

      GLuint id() const { return m_vbo; }

      // Delete current buffer when no longer in use 
      void dispose() 
      {
          ::glDeleteBuffers(1, &m_vbo);
          m_vbo = 0;
      }

      // Make this buffer active only one buffer can be active at a time.
      void bind() 
      { 
          glBindBuffer(GL_ARRAY_BUFFER, m_vbo); 
          glEnableVertexAttribArray(m_attr_location);
       }

      // Unbind current buffer in order to avoid unintended behavior 
      // due to the global state. 
      void unbind() 
      { 
          glBindBuffer(GL_ARRAY_BUFFER, 0); 
          glDisableVertexAttribArray(m_attr_location);
      }

      // Upload data to GPU - the data is often an array of POD types 
      // POD (Plain-Old-Data) - any contiguous data without any internal pointer.
      void send_data(void* pData, GLsizeiptr size)
      {
          this->bind();    
          glBufferData(GL_ARRAY_BUFFER, size, pData, GL_STATIC_DRAW);
          this->unbind();
      }

      // Map buffer to GPU memory. This method allows sending data directly 
      // to the VBO by writing to the returned pointer.
      // 
      // @param size - Byte amount of memory allocated on the GPU-side.
      void* map_buffer(GLsizeiptr size)
      {
          this->bind();
          // Just reserver data, do not copy vertex points to GPU memory. 
          glBufferData(GL_ARRAY_BUFFER, size, nullptr, GL_STATIC_DRAW);   
          // Obtain pointer to buffer mapped to GPU memory.
          void* ptr = glMapBuffer( GL_ARRAY_BUFFER, GL_WRITE_ONLY );
          this->unbind();
          return ptr;
      }

      template<typename T>
      T* map_buffer_t(GLsizeiptr size)
      { 
          return reinterpret_cast<T*>(this->map_buffer(size));
      }

      // Note: It is assumed that shader program is bound before 
      // calling this function. 
      //
      // shader_attr_location => Is attribute location of the Vertex Shader
      // that will process the vertices.
      void set_data_layout( GLenum type, GLint size) 
      {
          m_type = type; 
          m_size = size;
      }

      void draw_arrays(GLenum draw_type, GLuint count)
      {
          this->bind();
          // Describe data layout - binary format.
          glVertexAttribPointer( m_attr_location, m_size, m_type, GL_FALSE, 0, nullptr);
          // Performs drawing 
          glDrawArrays( draw_type, 0, count);
          this->unbind();
      }
  };

  struct Vertex2D
  {
      GLfloat x;
      GLfloat y;
  };

  int main(int argc, char** argv)
  {
      GLFWwindow* window;

      /* Initialize the library */
      if (!glfwInit())
          return -1;

      glutInit(&argc, argv);

      /* Create a windowed mode window and its OpenGL context */
      window = glfwCreateWindow(640, 480, "Sample 2D Drawing", NULL, NULL);
      if (!window)
      {
          glfwTerminate();
          return -1;
      }

      /* Make the window's context current */
      glfwMakeContextCurrent(window);
      // glClearColor(0.0f, 0.5f, 0.6f, 1.0f);
      glClearColor(0.0f, 0.0f, 0.0, 1.0f);

      constexpr size_t NPOINTS = 2000;

      //------------- Vertex Buffer Object 1 -----------//
      // => Note: anything vertex should be within the range -1.0 to 1.0 

      VertexBufferObject vbo_chart{};
      // Describe layout.
      // Each vertex has 2 components (X, Y) of type GL_FLOAT 
      vbo_chart.set_data_layout(GL_FLOAT, 2);

      Vertex2D* chart = vbo_chart.map_buffer_t<Vertex2D>( NPOINTS * sizeof(Vertex2D) );

      float x = 0.0;

      //  Write data directly on GPU memory without copying any 
      //  pre-allocated buffer on main-memory.
      for(size_t k = 0; k < NPOINTS; k++)
      {
          x = (k - 1000.0) / 100.0;
          chart[k].x = x;
          chart[k].y = sin(x * 10.0) / (1.0 + x * x);
      }

      // ------------- Triangle / Vertex Buffer Object 2 ------------//
      //      
    
      Vertex2D triangle_points[3] = {
          Vertex2D{-0.25,   -0.25 }
        , Vertex2D{ 0.00,    0.25 }
        , Vertex2D{ 0.25,   -0.25 }
      };

      VertexBufferObject vbo_triangle{};
      // Each vertex has 2 coordinates of type GL_FLOAT 
      vbo_triangle.set_data_layout(GL_FLOAT, 2);
      // Upload data to GPU 
      vbo_triangle.send_data(triangle_points, sizeof(triangle_points));


      // ---------- Square / Vertex Buffer Object 2 ------------//
      //      
    
      Vertex2D square_points[4] = {
          { -0.3,  -0.3 }
        , { -0.3,   0.3 }
        , {  0.3,   0.3 }
        , {  0.3,  -0.3 }
      };

      auto vbo_square = VertexBufferObject{};
      vbo_square.set_data_layout(GL_FLOAT, 2);
      // Upload data to GPU 
      vbo_square.send_data(square_points, sizeof(square_points));


      //  ======= R E N D E R  - L O O P ============//
      //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//
        
          vbo_chart.draw_arrays(GL_LINE_STRIP, NPOINTS);
          vbo_triangle.draw_arrays(GL_TRIANGLES, 3);
          vbo_square.draw_arrays(GL_LINE_LOOP, 4);

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwPollEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }
      }

      glfwTerminate();
      return 0;
  }
#+END_SRC
