#+HTML_MATHJAX: align:left font:Neo-Euler scale:100  path:"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_SVG"

#+INCLUDE: theme/style.org
#+TITLE: Computer Graphics 
#+DESCRIPTION: cpp/c++ interoperability ffi shim qt5 widgets gui library wrapper julia dlang
#+STARTUP: content


* Computer Graphics 
** Main Computer Graphics APIs 

 *Native Graphics APIs* (exposed as C-subroutines)

  + [[https://www.opengl.org//][OpenGL]] (Khronos Group) - Main OpenGL specification
    + => Open standard, cross-platform and vendor-independent API for
      rendering 2D or 3D computer graphics with GPU (Graphics
      Processing Unit) acceleration. OpenGL can be used for
      implementing computer graphics, games, scientific vizualization,
      virtual reality and CADs - Computer Aided Design
      software. OpenGL API specificiation is maintained as an
      open-standard by the Krhonos Group industry consortium.

    + => OpenGL has two modes, _immediate mode_ (a.k.a fixed-function
      pipeline, legacy-OpenGL) which is being depreacted, and _retained_
      _mode_ (modern OpenGL) that delivers more performance and is based
      on buffer-objects and shaders.

    + => OpenGL Official Specification: [[https://www.khronos.org/registry/OpenGL/index_gl.php][Khronos OpenGL® Registry]]

  + _OpenGL ES_  (Khronos Group)
    + => OpenGL for embedded systems, mobile devices and touch screen
      devices and so on. This API (Application Programming Interface)
      is widely used by many mobile games. 

    + => Similar to OpenGL specfication, but supports only the
      _retained-mode_. OpenGL ES does not support _immediate-mode_. As a
      result, calls to legacy OpenGL subroutines such as glBegin(),
      glEnd(), glRotate(), glTranslate(), ..., are not supported.

  + [[https://www.khronos.org/vulkan/][Vulkan]]_(Khronos Group)
    + => Graphics API with GPU acceleration that provides more
      low-level GPU control and less overhead than OpenGL. This API is
      designed for taking more advantag of multi-core CPU
      architectures and performing tasks in parallel.

  + [[https://en.wikipedia.org/wiki/DirectX][DirectX]] / Direct3D (Microsoft inc.) - Windows-only
    + => Microsoft's graphics API for accessing the GPU hardware. It
      is only available on operating systems based Windows-NT kernel
      and Windows-CE kernel (embedded version of Windows-NT).

  + [[https://developer.apple.com/metal/][Metal]] (Apple inc.) 
    + => Apple-only API for rendering 2D or 3D computer graphics with
      GPU acceleration. This API is available only on iOS and MacOSX
      operating systems. On iOS and MacOSX, Apple is deprecating and
      phasing out OpenGL in favor of its own  API.

 *Web Computer Graphics APIs* (exposed as Javascript/ECMAScript subroutines)

  + [[https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL][WebGL]] (Khronos Group)  / Html5 API 
    + => Based on OpenGL ES and implemented by major web
      browsers. Unlike OpenGL or OpenGL ES, which are exposed via C
      subroutines, WebGL is exposed to calling codes via JavaScript
      (ECMAScript) and Html5 canvas.

    + => Note: This API does not support OpenGL immediate-mode or
      legacy OpenGL. WebGL only supports _retained-mode_. 

  + [[https://en.wikipedia.org/wiki/WebGPU][WebGPU]] (W3C Consortium) - Upcoming Html5 standard. 
    + => Upcoming graphics API for web browser, based on Vulkan,
      Metal and DirectX which intends to deliver more low level GPU
      control and higher performance. Unlike WebGL, this API is not a
      direct port of any native graphics API such as Vulkan, Metal and
      DirectX. 
    + [[https://gpuweb.github.io/gpuweb/][WebGPU - Editor’s Draft]] 
    + [[https://github.com/gpuweb/gpuweb/wiki/Implementation-Status][Implementation Status · gpuweb/gpuweb Wiki · GitHub]]
    + [[https://github.com/gpuweb/gpuweb][GitHub - gpuweb/gpuweb: Where the GPU for the Web work happens!]]
    + [[https://kvark.github.io/web/gpu/native/2020/05/03/point-of-webgpu-native.html][Point of WebGPU on native]]
    + [[https://hacks.mozilla.org/2020/04/experimental-webgpu-in-firefox/][A Taste of WebGPU in Firefox - Mozilla Hacks - the Web developer blog]]


 *Further Reading* 

  + [[https://vulkan.gpuinfo.org/listdevices.php][Devices - Vulkan Hardware Database by Sascha Willems]] 

  + [[https://github.com/KhronosGroup/MoltenVK][GitHub - KhronosGroup/MoltenVK]]
    + "MoltenVK is a Vulkan Portability implementation. It layers a
      subset of the high-performance, industry-standard Vulkan
      graphics and compute API over Apple's Metal graphics framework,
      enabling Vulkan applications to run on iOS and macOS."

  + [[https://www.pcgamer.com/doom-benchmarks-return-vulkan-vs-opengl/][Doom benchmarks return: Vulkan vs. OpenGL | PC Gamer]]

  + [[https://linuxhint.com/vulkan-for-linux-users/][Vulkan for Linux Users – Linux Hint]] 

  + [[https://stackoverflow.com/questions/56766983/what-can-vulkan-do-specifically-that-opengl-4-6-cannot][What can Vulkan do specifically that OpenGL 4.6+ cannot? - Stack]]

  + [[https://softwareengineering.stackexchange.com/questions/380832/opengl-and-global-state][design - OpenGL and global state - Software Engineering Stack Exchange]]
** OpenGL Documentation 

 *OpenGL:*

   * [[http://docs.gl/][docs.gl]] [BEST]
     + Allows searching and quickly browsing the OpenGL
       documentation.

   * [[https://www.khronos.org/registry/OpenGL/index_gl.php][Khronos OpenGL® Registry]]
     * OpenGL Official Specification.

   * [[https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)][Core Language (GLSL) - OpenGL Wiki]] / Khronos Group 
     * Official Documentation of OpenGL shading language.

   * [[https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)][Data Type (GLSL) - OpenGL Wiki]] / Khronos Group
     * Data types of GLSL - OpenGL Shading Language.

   * [[https://thebookofshaders.com/][The Book of Shaders]] - (Patricio Gonzalez and Jen Love)

   * [[https://web.archive.org/web/20190629031543/http://antongerdelan.net/teaching/3dprog1/maths_cheat_sheet.pdf][3D Maths Cheat Sheet]] - Reference Card for computer graphics
     linear algebra. (homogeneous coordinates, rotation matrices,
     translation matrices and etc.)

 *WebGL:*

   * [[https://www.khronos.org/webgl/][WebGL Overview - The Khronos Group Inc]]
     * "WebGL is a cross-platform, royalty-free web standard for a
       low-level 3D graphics API based on OpenGL ES, exposed to
       ECMAScript via the HTML5 Canvas element. Developers familiar
       with OpenGL ES 2.0 will recognize WebGL as a Shader-based API
       using GLSL, with constructs that are semantically similar to
       those of the underlying OpenGL ES API. It stays very close to
       the OpenGL ES specification, with some concessions made for
       what developers expect out of memory-managed languages such as
       JavaScript. WebGL 1.0 exposes the OpenGL ES 2.0 feature set;
       WebGL 2.0 exposes the OpenGL ES 3.0 API." 

   * [[https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial][WebGL tutorial - Web APIs | MDN]]

   * [[https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL][Getting started with WebGL - Web APIs | MDN]] - WebGL Documentation.

   * [[https://webglfundamentals.org/][WebGL Fundamentals]]

** OpenGL Terminology

  + _OpenGL_ - Open Graphics Library

  + [[https://www.khronos.org/opengl/wiki/OpenGL_Context][OpenGL Context]] 

  + [[http://glew.sourceforge.net/index.html][GLEW]] - OpenGL Extension Wrangler

  + ARB - Architecture Review Board 

  + OpenGL _Immediate Mode_ (Fixed-Function Pipeline, Legacy OpenGL)
    + Also known as: Legacy OpenGL, Fixed-Function Pipeline 
    + Drawing is mostly performed without storing data on GPU and by
      using subroutines calls to glScale(), glRotate(), glPush(), glPop(),
      glTranslate(), glBegin(), glEnd() and so on.
    + Immediate-mode is not supported by OpenGL ES or WebGL.
    + See: [[https://www.khronos.org/opengl/wiki/Fixed_Function_Pipeline][Fixed Function Pipeline - OpenGL Wiki]]

  + OpenGL _retained mode_ (Programmable Pipeline, Modern OpenGL)
    + Also known as: Modern OpenGL, Programmable Pipeline 
    + New and modern OpenGL API => Drawing is performed by storing
      data on the GPU via VBO (Vertex Buffer Objects) and by using
      _shaders_, programs that runs on GPU, for performing geometric
      vertex transformations, color and texturing computations.
    + More peformant than _immediate-mode_ as the data is not sent to
      the GPU every frame. 

  + _GPU_ - Graphics Processing Unit

  + _GPGPU_ - General Purpose Computing on GPU
    + APIs: OpenGL, Cuda, and so on. 
    + Parallel non-graphics computations on GPU. GPGPU APIs take
      advantage of GPU parallel computing features for high
      performance computing.

  + [[https://www.khronos.org/opengl/wiki/Direct_State_Access][DSA]] - Direct State Access

  + _Vertex_ - 2D or 3D coordinates representing a point in the space.

  + _2D_ - 2 dimensions (plane) / 2 coordinates (X, Y)

  + _3D_ - 3 dimensions (space) / 3 coordinates (X, Y, Z)

  + _Homogenous Coordinate_ - Coordinate system using an extra dimension
    for encoding translation coordinate transformation in the same way
    as rotation matrices transformations.
    + 2D homogeneous coordinates: (X, Y, W = 1)
    + 3D homogeneous coordinates: (X, Y, Z, W = 1)

  + _NDC_ - Normalized Device Coordinate
    + Default coordinates used by OpenGL (-1.0 to 1.0) for each
      axis. Any vertex that falls out of this range will not be visible
      on the screen.

  + _MCS_ - Model Coordinate System

  + _CTM_ - Current Transform Matrix 

  + [[https://www.khronos.org/opengl/wiki/Buffer_Object][Buffer Object]] 

  + _VBO_ - Vertex Buffer Object

  + _VAO_ - Vertex Array Object

  + _FBO_ - Framebuffer Object

  + _IBO_ - Index Buffer Object

  + _UBO_ - Uniform Buffer Object 

  + _FPS_ - Frame Per Seconds 

  + _Shader_ - Program that runs on the GPU and performs vertex
    computations such as coordinate transformations (matrix
    multiplications), colors and texture computations.

  + _GLSL_ - OpenGL shading programming language - for performing
    computer graphics calculations on the GPU hardware.

  + _HLSL_ (High-Level Shader Language) - Microsft DirectX shading language.

** OpenGL companion libraries 

  *OpenGL Companion Libraries* 

Core Libraries:

  + _GL_  - OpenGL Graphics API 

OpenGL Loaders:

  + Libraries that abstracts OpenGL function pointers loading in a
    platform-independent way. 

  + [[http://glew.sourceforge.net/index.html][GLEW]] - OpenGL Extension Wrangler [MOST USED]
    + "The OpenGL Extension Wrangler Library (GLEW) is a
      cross-platform open-source C/C++ extension loading library. GLEW
      provides efficient run-time mechanisms for determining which
      OpenGL extensions are supported on the target platform. OpenGL
      core and extension functionality is exposed in a single header
      file. GLEW has been tested on a variety of operating systems,
      including Windows, Linux, Mac OS X, FreeBSD, Irix, and Solaris."

  + [[https://glad.dav1d.de/][GLAD]] - [MOST-USED] Multi-Language GL/GLES/EGL/GLX/WGL
    Loader-Generator based on the official specs.

  + [[https://github.com/cginternals/glbinding][GitHub - cginternals/glbinding]]
    + "A C++ binding for the OpenGL API, generated using the gl.xml
      specification." 

  + [[https://github.com/anholt/libepoxy][GitHub - anholt/libepoxy]]
    + "Epoxy is a library for handling OpenGL function pointer
      management for you."

  + [[https://github.com/imakris/glatter][GitHub - imakris/glatter]]
    + "An OpenGL loading library, with support for GL, GLES, EGL, GLX and WGL"

  + [[https://galogen.gpfault.net/][Galogen OpenGL Loader Generator]]
    + "Galogen is an OpenGL loader generator. Given an API version and
      a list of extensions, Galogen will produce corresponding headers
      and code that load the exact OpenGL entry points you need. The
      produced code can then be used directly by your C or C++
      application, without having to link against any additional
      libraries." 

  + [[https://github.com/SFML/SFML-glLoadGen][GitHub - SFML/SFML-glLoadGen]]
    + Customized glLoadGen for SFML

Libraries for window systems, event handling and OpenGL context abstraction: 
 
  + Abstract platform-specific window system and event handling. 

  + [[https://www.glfw.org/][GLFW]] [BEST] [MOST-USED]
    * C library that provides graphics windows for OpenGL, Vulkan,
      OpenGL ES and deals with event handling.

  + [[https://www.libsdl.org/][SDL]] (Simple Direct Media Layer) [BEST] [MOST-USED]
    * Cross-platform C library that provides windows and event
      handling for many computer graphics APIs such as OpenGL, Vulkan
      and DirectX. SLD also has facilities for dealing with audio,
      joystick, CD-ROM, network and threads.

  + [[http://freeglut.sourceforge.net/][GLUT]] (FreeGlut) - OpenGL Utility Toolkit
    * Deals with window creation, OpenGL initialization, event
      handling and  so on.
    * Docs: https://www.glfw.org/documentation.html


OpenGL Math and Computer Graphics Math: 


  + [[https://glm.g-truc.net/0.9.5/api/index.html][GLM]] (OpenGL Mathematics Library) [MOST-USED]
    + Source code: https://github.com/g-truc/glm
    + Header-only C++ library that provides classes for computer
      graphics mathematics such as: 2D, 3D and homogeneous coordinate
      vector; 2D, 3D and homogeneous coordinate transformation
      matrices; quaternions and subroutines for computing camera,
      perspective or orthogonal transformation matrices.

  + [[https://github.com/Kazade/kazmath][GitHub - Kazade/kazmath]] - A C math library targeted at games
    + "Kazmath is a simple 3D maths library written in C. It was
      initially coded for use in my book, Beginning OpenGL Game
      Programming - Second edition, but rapidly gained a life of its
      own. Kazmath is now used by many different projects, and
      apparently is used in 25% of the worlds mobile games (yeah, I
      don't believe it either - but it's used in Cocos2d-x)." 

  + [[https://github.com/recp/cglm][GitHub - recp/cglm]] -  Highly Optimized Graphics Math (glm) for C

  + See: [[https://github.com/chunkyguy/Math-Library-Test][GitHub - chunkyguy/Math-Library-Test]] - A comparison of the
    various major math libraries for speed and ease of use. 


Text and Font Rendering: 

  + [[https://www.freetype.org/][The FreeType Project]]
    * Brief: "It is written in C, designed to be small, efficient,
      highly customizable, and portable while capable of producing
      high-quality output (glyph images) of most vector and bitmap
      font formats."

  + [[http://oglft.sourceforge.net/][OGLFT: OpenGL-FreeType Library]]
    * Brief: "This C++ library supplies an interface between the fonts
      on your system and an OpenGL or Mesa application. It uses the
      excellent FreeType library to read font faces from their files
      and renders text strings as OpenGL primitives."

  + [[https://github.com/vallentin/glText][GitHub - vallentin/glText]] - [HEADER-ONLY-LIBRARY]
    * Brief: "glText is a simple cross-platform single header text
      rendering library for OpenGL. glText requires no additional
      files (such as fonts or textures) for drawing text, everything
      comes pre-packed in the header."

  + [[https://github.com/MartinPerry/OpenGL-Font-Rendering][GitHub - MartinPerry/OpenGL-Font-Rendering]] 
    + Brief: "Rendering UNICODE fonts with OpenGL This library is
      still work-in-progress. This is a working beta version."

  + [[http://nuclear.mutantstargoat.com/sw/libdrawtext/][libdrawtext - OpenGL text rendering library]]
    + Brief: "Libdrawtext uses freetype2 for glyph rasterization. If
      you would rather avoid having freetype2 as a dependency, you can
      optionally compile libdrawtext without it, and use pre-rendered
      glyphmaps. Glyphmaps can be generated by the included
      font2glyphmap tool, or by calling dtx_save_glyphmap."

  + [[https://github.com/codetiger/Font23D][GitHub - codetiger/Font23D]] - Convert any text to a 3d mesh using any font style
    + Brief: "Font23D is a C++ library for creating a 3d mesh of any
      Text in the given True type font." 

Non-categorized / Miscellaneous: 

  + [[http://glsdk.sourceforge.net/docs/html/index.html][GLSDK - Unofficial OpenGL Software Development Kit]]
    + Brief: "The Unofficial OpenGL Software Development Kit is a
      collection of libraries and utilities that will help you get
      started working with OpenGL. It provides a unified,
      cross-platform build system to make compiling the disparate
      libraries easier. Many of the components of the SDK are C++
      libraries. Each component of the SDK specifies the terms under
      which they are distributed. All licenses used by components are
      approximately like the MIT license in permissivity. The parts of
      the SDK responsible for maintaining the build, as well as all
      examples, are distributed under the MIT License."


 *See also:*

  + [[https://www.khronos.org/opengl/wiki/OpenGL_Loading_Library][OpenGL Loading Library - OpenGL Wiki]] / Khronos Group
    + Brief: "An OpenGL Loading Library is a library that loads
      pointers to OpenGL functions at runtime, core as well as
      extensions. This is required to access functions from OpenGL
      versions above 1.1 on most platforms. Extension loading
      libraries also abstracts away the difference between the loading
      mechanisms on different platforms."

  + [[https://www.khronos.org/opengl/wiki/Load_OpenGL_Functions][Load OpenGL Functions - OpenGL Wiki]]  / Khronos Group 
    + Brief: "Loading OpenGL Functions is an important task for
      initializing OpenGL after creating an OpenGL context. You are
      strongly advised to use an OpenGL Loading Library instead of a
      manual process. However, if you want to know how it works
      manually, read on."

  + [[https://www.khronos.org/opengl/wiki/Image_Libraries][Image Libraries - OpenGL Wiki]]  / Khronos Group 

  + [[https://stackoverflow.com/questions/27873784/when-do-i-need-to-use-an-opengl-function-loader][When do I need to use an OpenGL function loader? - Stack Overflow]]

  + [[https://keyj.emphy.de/glext/][KeyJ's Blog : Blog Archive » Modern OpenGL with lcc-win32, the hard way]]

  + [[https://apoorvaj.io/loading-opengl-without-glew/][Loading OpenGL without GLEW]] 

  + [[https://www.libsdl.org/release/SDL-1.2.15/docs/html/guidevideoopengl.html][Using OpenGL With SDL]] - LibSDL

  + [[https://www.khronos.org/opengl/wiki/Tutorial1:_Creating_a_Cross_Platform_OpenGL_3.2_Context_in_SDL_(C_/_SDL)][Tutorial1: Creating a Cross Platform OpenGL 3.2 Context in SDL (C / SDL) - OpenGL Wiki]]

** Legacy/Obsolete OpenGL Subroutines

The following OpenGL subroutines are from the OpenGL _immediate mode_
(fixed-function pipeline), which are obsolete and should be avoided as
they incur on a significant overhead and they lack portability due to
not be available at OpenGL ES.

  + Vertex:
    + => Modern OpenGL replacement: VBO (Vertex Buffer Object) and VAO (Vertex Array Object)
    + glVertex2f() 
    + glVertex2f()
    + glVertex3f()

  + Begin/End:
    + glEnd()
    + glBegin()

  + Colors
    + glColor()   => Modern OpenGL replacement: Fragement shader 
    + glMaterial()
    + glVertexPointer() 

  + Coordinate Transformation
    + glLoadIdentity()  => Modern OpenGL replacement: glm::mat4(1.0);
    + glRotate()        => Modern OpenGL replacement: glm::rotate();
    + glTranslate()     => Modern OpenGL replacement: glm::translate();
    + glScale()         => Modern OpenGL replacement: glm::scale();
    + glRotate3f()
    + glMatrixMode()
    + glFrustum()       => Modern OpenGL replacement: glm::frustum();
    + gluLookAt()       => Modern OpenGL replacement: glm::lookAt();
    + gluPerspective()  => Modern OpenGL replacement: glm::perspective(); 

  + Save Context 
    + glPop()          
    + glPush()
    + glPushMatrix()
    + glPopMatrix()
** Computer Graphics Math 
*** Vector Algebra 

Given 2 3D vectors $\vec{A} = [ x_A, y_A, z_A ]$ and $\vec{B} = [ x_B, y_B, z_B ]$ 
, the following properties can be defined: 


 *Vector Norm* 

The _norm_ or _magnitude_ of A, $|| \vec{A} ||$ is given by: 

\begin{equation}
   || \vec{A} || = \sqrt{ x_A^2 + y_A^2 + z_A^2 }
\end{equation}


\begin{equation}
   || \vec{A} ||^2 = \vec{A} \cdot \vec{A}
\end{equation}

 *Normalized Vector / Unit Vector* 

A _normalized vector_, is a vector with the same direction than a given
vector, but with norm equal to one. A normalized vector of A can be
computed as: 

\begin{equation}
    \text{normalized}( \vec{A} ) 
       = \frac{ \vec{A} }{ || A || }  
       = \frac{1}{ \sqrt{ x_A^2 + y_A^2 + z_A^2 } } . \vec{A}
\end{equation}

\begin{equation}
    || \text{normalized}( \vec{A} ) || = 1 
\end{equation}


 *Distance between two position (point) vectors* 

Given two vectors A and B which represent the position relative to the
coordinate system origin or point. (0, 0, 0). The distance between A
and B, or the length of the vector difference between A and B is
determined by the following relation. 

\begin{eqnarray*} 
   \text{distance}( \vec{A}, \vec{B}) &=& || \vec{A}  - \vec{B} || = || \vec{B}  - \vec{A} || \\
   \text{distance}( \vec{A}, \vec{B}) &=& \sqrt{ (x_A - x_B)^2 + (y_A - y_B)^2 + (z_A - z_B)^2 }
\end{eqnarray*}

 *Dot Product* 

The vector _dot product_ is:  

  + Where:
    + $|| \vec{A} ||$ is the norm of vector A
    + $|| \vec{B} ||$ is the norm of vector B
    + $\theta$ is the angle between vectors A and B.

  + The vectros $\vec{A}$ and $\vec{B}$ are _orthogonal_, the angle
    between them is 90 degrees, when the dot product is zero. 

\begin{equation} 
  \text{dot}( \vec{A}, \vec{B} ) 
    = \vec{A} \cdot \vec{B} 
    = x_A \cdot x_B + y_A \cdot y_B + z_A \cdot z_B 
    = || \vec{A} || \cdot || \vec{B} || \cdot \cos \theta 
\end{equation}

If the vectors $\vec{A}$ and $\vec{B}$ are expressed as column
matrices, the product can be computed as a matrix multiplication.

  + In the following equations. $A^T$ is the transpose of matrix A. 

\begin{equation}
  A = \begin{bmatrix} x_A \\ y_A \\ z_A  \end{bmatrix}
\end{equation}

\begin{equation}
  B = \begin{bmatrix} x_B \\ y_B \\ z_B  \end{bmatrix}
\end{equation}


\begin{equation}
  dot(\vec{A}, \vec{B})  
     = \vec{A} \cdot \vec{B}
     = A^T \cdot B 
     =  
        \begin{bmatrix} x_A & y_A & z_A  \end{bmatrix}
        \cdot 
        \begin{bmatrix} x_B \\ y_B \\ z_B  \end{bmatrix}
\end{equation}

 *Cross Product* / *Vector product* 

The cross product between two vectors $\vec{A}$ and $\vec{B}$ results
in a vector which is perpendicular (orthogonal) to both A and B. 

\begin{equation}
   \text{cross}( \vec{A}, \vec{B} ) 

        = \vec{A} \times \vec{B} 

        = \begin{bmatrix} 
             y_A \cdot z_B - z_A \cdot y_B   \\
             z_A \cdot x_B - x_A \cdot z_B   \\
             x_A \cdot y_B - y_A \cdot x_B   \\
          \end{bmatrix}

       = [A]_{\times} \cdot B       
\end{equation}


Where $[A]_{\times}$ is the following matrix: 

\begin{equation} 
  [A]_{\times} =
     \begin{bmatrix}
          0   & -z_A  &  y_A  \\
          z_A &  0    & -x_A  \\
         -y_A &  x_A  &  0    \\
     \end{bmatrix}
\end{equation}

The cross product have the following properties: 

  + Where:
    + $\vec{n}$ is unit vector with the same direction as the cross
      product vector.
    + $\theta$ is the angle between the two underlying vectors. 

\begin{equation}
   \vec{A} \times \vec{B} = || \vec{A} || \cdot || \vec{B} || \cdot \sin \theta \times \vec{n}
\end{equation}

\begin{equation}
   \vec{A} \times \vec{B} = - \vec{B} \times \vec{A}
\end{equation}

  *Vector Triple Product* 

\begin{equation} 
   ( \vec{u} \times \vec{v} ) \times \vec{w} 
         = ( \vec{v} \cdot \vec{w} ) \vec{u} + ( \vec{u} \cdot \vec{w}) \vec{v}
         = \text{dot}( \vec{v}, \vec{w} ) \vec{u} + \text{dot}( \vec{u}, \vec{w}) \vec{v}
\end{equation}

*** Affine Transforms

Affine transforms, which are represented by matrices, are a particular
class of linear transforms which preserves ratios between distances,
colinearity and parallelism. Affine transforms has many applications
that includes, computer graphics, computer vision, image processing,
CAD (Computer Aided Design) and robotics. 

Outline of properties preserved by affine transforms: 

  + Ratios between distances.

  + Colinearity
    + => Points in the same line, remains in the same line, after the
      transform was applied. 

  + Parallelism
    + => Lines that are parallels, remains parallel.


Types of geometric linear transforms: 
 
  * Affine Transforms
    + => Preserves ratios, colinearity and parallelism. 

  * Projection Transforms
    + => Does not preserver parallelism. However, it preservers
      colinearity. Affine transforms are a particular case of
      projection transforms.
    + => Some projection transforms are:
      + Orthogonal view transform
      + Projection view transform 

  * Rigid body transforms
    + => Are a particular case of affine transforms. The set of rigid
      body transforms comprises: identity, translation and
      rotation. However, this set does not include shear and scaling. 


Some affine transforms are: 

  + Identity (Identity matrix) => Represents no transform, all points
    or vertices remain the same.

  + Translation 

  + Scaling

  + Reflection 

  + Rotation

  + Shear


   *General form of 2D affine transforms* 

2D affine transforms, including translation, rotation and scaling can
be represented by matrices with the following format, that transforms
homogeneous coordinates from one coordinate system to
another. _Homogeneous coordinates_, are 2D or 3D coordinates with an
extra pseudo-coordinate, often designated by 'w', for representing
translations affine transforms in the same way as rotations and
scaling. 


\begin{equation}
  A = 
   \begin{bmatrix} 
     a_{11}   & a_{12}   &  a_{13} \\
     a_{21}   & a_{22}   &  a_{23} \\  
     0        & 0        &  1 \\  
   \end{bmatrix}
\end{equation}

This affine transform performs the coordinate transformation from the
coordinate frame C2 (which axis are x, y), which could an object
local-space coordinate, to coordinate frame C1 (which axis are x', y')
which could be a world-coordinate system. The matrix transforms
homogenous coordinates, which are coordinates with an extra parameter
w = 1 for allowing translation transformation to be expressed in the
same way as rotation transformations.


\begin{equation}
     \begin{bmatrix} 
       x' \\ y' \\ w' = 1
      \end{bmatrix}
  = 
    \begin{bmatrix} 
      a_{11}   & a_{12}   &  a_{13} \\
      a_{21}   & a_{22}   &  a_{23} \\
      0        & 0        &  1      \\
   \end{bmatrix}

     \cdot 

     \begin{bmatrix} 
       x \\ y \\ w = 1
     \end{bmatrix}

    = 

    \begin{bmatrix} 
        a_{11} \cdot x + a_{12}  \cdot y + a_{13}  \\
        a_{21} \cdot x + a_{22}  \cdot y + a_{23}  \\
        1 
    \end{bmatrix}
\end{equation}


  *3D Affine Transforms* 

3D affine transforms can be represented by matrices with following
format. 

\begin{equation}
  A = 
   \begin{bmatrix} 
     a_{11}   & a_{12}   &  a_{13} & a_{14}  \\
     a_{21}   & a_{22}   &  a_{23} & a_{24}  \\
     a_{32}   & a_{32}   &  a_{33} & a_{34}  \\
     0        & 0        &  0      & 1       \\
   \end{bmatrix}
\end{equation}

An affine transformation maps the coordinate system (X, Y, Z), which
could be an object local coordinate system, to the coordinate system
(X', Y', Z'), which could be a world coordinate system. In a similar
manner to 2D homogeneous coordinates, an extra pseudo-coordinate w = 1
is added for expressing translations transformations as matrix
multiplications, in the same way as rotations.


\begin{equation}
     \begin{bmatrix} 
       x' \\ y' \\ z' \\ w' = 1
      \end{bmatrix}
  = 
    \begin{bmatrix} 
      a_{11}   & a_{12}   &  a_{13} & a_{14} \\
      a_{21}   & a_{22}   &  a_{23} & a_{24} \\
      a_{31}   & a_{32}   &  a_{33} & a_{34} \\
      0        & 0        &  0      &   1    \\
   \end{bmatrix}

     \cdot 

     \begin{bmatrix} 
       x \\ y \\ z \\ w = 1
     \end{bmatrix}

    = 

    \begin{bmatrix} 
        a_{11} \cdot x + a_{12}  \cdot y + a_{13} \cdot z + a_{14}  \\
        a_{21} \cdot x + a_{22}  \cdot y + a_{23} \cdot z + a_{24}  \\
        a_{31} \cdot x + a_{32}  \cdot y + a_{33} \cdot z + a_{34}  \\
        1
    \end{bmatrix}
\end{equation}


  *Furthere Reading* 

  + [[http://graphics.cs.cmu.edu/nsp/course/15-462/Spring04/slides/04-transform.pdf][CMU - Transformations]]

  + [[http://www.cs.cornell.edu/courses/cs4620/2013fa/lectures/04transforms2d.pdf][Cornell CS4620 - 2D Geometric Transformations]]

  + [[https://web.iitd.ac.in/~hegde/cad/lecture/L6_3dtrans.pdf][AML170 CAD - 3D Transformations - Lecture 6]]

  + [[https://mycourses.aalto.fi/pluginfile.php/352115/mod_resource/content/1/01_transform.pdf][CS_CS3100 (Introduction to) Computer Graphics]] 

  + [[https://en.m.wikipedia.org/wiki/Coordinate_system][Coordinate system - Wikipedia]]
    + Brief: "n geometry, a coordinate system is a system that uses
      one or more numbers, or coordinates, to uniquely determine the
      position of the points or other geometric elements on a manifold
      such as Euclidean space."

  + [[https://en.m.wikipedia.org/wiki/Homogeneous_coordinates][Homogeneous coordinates - Wikipedia]]
    + Brief: "Homogeneous coordinates have a range of applications,
      including computer graphics and 3D computer vision, where they
      allow affine transformations and, in general, projective
      transformations to be easily represented by a matrix." 

  + [[https://en.m.wikipedia.org/wiki/Right-hand_rule][Right-hand rule - Wikipedia]]
    + Brief: "In mathematics and physics, the right-hand rule is a
      common mnemonic for understanding orientation of axes in
      three-dimensional space."

  + [[https://en.m.wikipedia.org/wiki/Rotation_matrix][Rotation matrix - Wikipedia]]
    + Brief: "In linear algebra, a rotation matrix is a transformation
      matrix that is used to perform a rotation in Euclidean space."

  + [[https://en.m.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions][Rotation formalisms in three dimensions - Wikipedia]]
    + Brief: "In geometry, various formalisms exist to express a
      rotation in three dimensions as a mathematical
      transformation. In physics, this concept is applied to classical
      mechanics where rotational (or angular) kinematics is the
      science of quantitative description of a purely rotational
      motion."

  + [[https://en.m.wikipedia.org/wiki/Axes_conventions][Axes conventions - Wikipedia]]
    + Brief: "In ballistics and flight dynamics, axes conventions are
      standardized ways of establishing the location and orientation
      of coordinate axes for use as a frame of reference." 

  + [[https://en.m.wikipedia.org/wiki/Euler_angles][Euler angles - Wikipedia]]
    + Brief: "The Euler angles are three angles introduced by Leonhard
      Euler to describe the orientation of a rigid body with respect
      to a fixed coordinate system."

  + [[https://en.m.wikipedia.org/wiki/Aircraft_principal_axes][Yaw, Pitch, Roll angles - Aircraft principal axes - Wikipedia]]
    + Brief: Rotation angles convention for aircrafts.

  + [[https://en.m.wikipedia.org/wiki/Celestial_coordinate_system][Celestial coordinate system - Wikipedia]]
    + Brief: "In astronomy, a celestial coordinate system (or
      celestial reference system) is a system for specifying positions
      of satellites, planets, stars, galaxies, and other celestial
      objects relative to physical reference points available to a
      situated observer (e.g. the true horizon and north cardinal
      direction to an observer situated on the Earth's surface)"

  + [[https://en.m.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles][Conversion between quaternions and Euler angles - Wikipedia]]
    + Brief: "Spatial rotations in three dimensions can be
      parametrized using both Euler angles and unit quaternions. This
      article explains how to convert between the two
      representations. Actually this simple use of "quaternions" was
      first presented by Euler some seventy years earlier than
      Hamilton to solve the problem of magic squares." 

*** 2D Canonical Affine Transforms


Identity matrix

\begin{equation}
  I = 
   \begin{bmatrix} 
     1   & 0   &  0 \\
     0   & 1   &  0 \\  
     0   & 0   &  1 \\  
   \end{bmatrix}
\end{equation}

Translation: 

\begin{equation}
  T = 
   \begin{bmatrix} 
     1   & 0   &  \Delta_x \\
     0   & 1   &  \Delta_y \\  
     0   & 0   &  1        \\  
   \end{bmatrix}
\end{equation}


\begin{equation}
     \begin{bmatrix} 
       x' \\ y' \\ 1 
      \end{bmatrix}
  = 

   \begin{bmatrix} 
     1   & 0   &  \Delta_x \\
     0   & 1   &  \Delta_y \\  
     0   & 0   &  1        \\  
   \end{bmatrix}

     \cdot 

   \begin{bmatrix} 
       x \\ y \\ w = 1
   \end{bmatrix}

  = 
   \begin{bmatrix} 
       x + \Delta_x \\ y + \Delta_y \\ 1
   \end{bmatrix}
\end{equation}


Scaling:
 
  + Where: $s_x$ is the scale for X axis and $s_y$ is the scale for
    the y axis.

\begin{equation}
  S = 
   \begin{bmatrix} 
     s_x   & 0     &  0 \\
     0     & s_y   &  0 \\  
     0     & 0     &  1 \\  
   \end{bmatrix}
\end{equation}


\begin{equation}
     \begin{bmatrix} 
       x' \\ y' \\ 1 
      \end{bmatrix}
  = 

   \begin{bmatrix} 
     s_x   & 0     &  0 \\
     0     & s_y   &  0 \\  
     0     & 0     &  1 \\  
   \end{bmatrix}
     \cdot 

   \begin{bmatrix} 
       x \\ y \\ w = 1
   \end{bmatrix}

  = 
   \begin{bmatrix} 
       s_x \cdot x \\ s_y \cdot y \\ 1
   \end{bmatrix}
\end{equation}


Shear: 

\begin{equation}
  H = 
   \begin{bmatrix} 
     1     & h_x  &  0 \\
     h_y   & 1    &  0 \\  
     0     & 0    &  1 \\  
   \end{bmatrix}
\end{equation}


Rotation around Z axis: 

  + Where $\theta$ is the angle of counterclockwise rotation around Z
    axis. 

\begin{equation}
  R  = 
   \begin{bmatrix} 
     \cos \theta     & -\sin \theta  &  0 \\
     \sin \theta     &  \cos \theta  &  0 \\  
     0               &  0            &  1 \\  
   \end{bmatrix}
\end{equation}


\begin{equation}
     \begin{bmatrix} x' \\ y' \\ 1  \end{bmatrix} 

    = 
      \begin{bmatrix} 
        \cos \theta     & -\sin \theta  &  0 \\
        \sin \theta     &  \cos \theta  &  0 \\  
        0               &  0            &  1 \\  
      \end{bmatrix}

     \begin{bmatrix} x \\ y \\ 1  \end{bmatrix} 
    = 
     \begin{bmatrix} 
          x \cos \theta - y \sin \theta  \\ 
          x \sin \theta + y \cos \theta \\ 
          1
     \end{bmatrix} 
\end{equation}

*** 3D Canonical Affine Transforms 

 _Translation:_

  + Where: $T^{-1}$ is the inverse transform. 

\begin{equation}
  T = 
   \begin{bmatrix} 
     1   & 0   &  0 &  \Delta_x \\
     0   & 1   &  0 &  \Delta_y \\  
     0   & 0   &  1 &  \Delta_z \\  
     0   & 0   &  0 &   1      \\
   \end{bmatrix}
\end{equation}


\begin{equation}
     \begin{bmatrix} 
       x' \\ y' \\ z' \\ w' = 1
      \end{bmatrix}
  = 

   \begin{bmatrix} 
     1   & 0   & 0 &  \Delta_x \\
     0   & 1   & 0 &  \Delta_y \\  
     0   & 0   & 1 &  \Delta_z \\  
     0   & 0   & 0 &    1      \\
   \end{bmatrix}

     \cdot 

   \begin{bmatrix} 
       x \\ y \\ z \\ w = 1
   \end{bmatrix}

  = 
   \begin{bmatrix} 
       x + \Delta_x \\ y + \Delta_y \\ z + \Delta_z \\ 1
   \end{bmatrix}
\end{equation}


\begin{equation}
  T^{-1} = 
   \begin{bmatrix} 
     1   & 0   &  0 &  -\Delta_x \\
     0   & 1   &  0 &  -\Delta_y \\  
     0   & 0   &  1 &  -\Delta_z \\  
     0   & 0   &  0 &   1        \\
   \end{bmatrix}
\end{equation}

 _Scaling:_ 

  + Where: $s_x$,  $s_y$, $s_z$ are the scale factors for axis x, y, z
    and  $S^{-1}$ is the inverse transform (inverse matrix). 

\begin{equation}
  S = 
   \begin{bmatrix} 
     s_x   & 0     &  0   &  0 \\
     0     & s_y   &  0   &  0 \\  
     0     & 0     &  s_z &  0 \\  
     0     & 0     &  0   &  1  \\
   \end{bmatrix}
\end{equation}


\begin{equation}
  S^{-1} = 
   \begin{bmatrix} 
     1 / s_x   & 0     &  0       &  0 \\
     0     & 1 / s_y   &  0       &  0 \\  
     0     &    0      &  1 / s_z &  0 \\  
     0     &    0      &  0       &  1 \\
   \end{bmatrix}
\end{equation} 


 _Rotation around x axis_ 

 + $R_x^{-1} = R_x^T$ => The inverse is equal to the transpose.

\begin{equation}
 R_x(\alpha) = 
   \begin{bmatrix} 
     1   & 0            &  0              & 0  \\ 
     0   & \cos{\alpha} & -\sin{\alpha}   & 0  \\ 
     0   & \sin{\alpha} &  \cos{\alpha}   & 0  \\ 
     0   & 0            &  0              & 1  \\ 
   \end{bmatrix}
\end{equation}

 
 _Rotation around y axis_

  + $R_y^{-1} = R_y^T$ 

\begin{equation}
 R_y(\beta) = 
   \begin{bmatrix} 
     \cos{\beta}    & 0   & \sin{\beta} & 0 \\ 
     0              & 1   & 0           & 0 \\
    -\sin{\beta}    & 0   & \sin{\beta} & 0 \\
    0               & 0   & 0           & 1 
   \end{bmatrix}
\end{equation}


 _Rotation around z axis_

  + $R_z^{-1} = R_z^T$ 

\begin{equation}
 R_z(\theta) = 
   \begin{bmatrix} 
      \cos{\theta}  & -\sin{\theta} &  0 & 0 \\ 
      \sin{\theta}  &  \cos{\theta} &  0 & 0 \\ 
     0              & 0             &  1 & 0 \\
     0              & 0             &  0 & 1 \\
   \end{bmatrix}
\end{equation}


 _Rotation around arbirtary axis_ 

  + Formula 1 : The axis is defined by unit vector $\hat{n}$
    + References:  [[http://www.chrobotics.com/library/understanding-quaternions][(Chrobotics)]], [[https://www.weizmann.ac.il/sci-tea/benari/sites/sci-tea.benari/files/uploads/softwareAndLearningMaterials/quaternion-tutorial-2-0-1.pdf][(Ben-Ari - Weizmann)]] - derived from
      quaternion equations. 

\begin{equation} 
   T_n = \begin{bmatrix}

             a^2 + b^2 - c^2 - d^2  
          &  2 (b \cdot c -  a \cdot d)
          &  2 (b \cdot d +  a \cdot c)  
          &  0                            \\

             2 (b \cdot c +  a \cdot d )
          &  a^2 - b^2 + c^2 -d^2                   
          &  2 ( c \cdot d -  a \cdot b ) 
          &  0                            \\

             2 ( b \cdot d -  a \cdot c  )
          &  2 ( c \cdot d +  a \cdot b )
          &  a^2 - b^2 - c^2 + d^2     
          &  0                            \\

             0 & 0 & 0 & 1 \\ 
         \end{bmatrix}
\end{equation}

Where: 
  + $\hat{n}$ is a unit vector that designates the direction, thus: $\hat{n} = 1$
  + $\hat{n} = [x_n \quad y_n \quad z_n]^T$
    + $x_n$, $y_n$, $z_n$ are the components of vector $\hat{n}$.
  + $a = \cos( \theta / 2)$
  + $b = x_n \cdot \sin (\theta / 2)$
  + $c = y_n \cdot \sin (\theta / 2)$
  + $d = z_n \cdot \sin (\theta / 2)$


 _Rotation around arbirtary axis_ [[https://cseweb.ucsd.edu/classes/wi18/cse169-a/slides/CSE169_03.pdf][(Steve Rotenberg - Computer Animation)]]


\begin{equation} 
  T_n = \begin{bmatrix}
             x_n^2 + C \cdot (1 - x_n^2)  
          &  x_n \cdot y_n \cdot (1 - C) - z_n \cdot S 
          &  x_n \cdot z_n \cdot (1 - C)  + y_n \cdot S  
          &  1
          \\

             x_n \cdot y_n \cdot (1 - C) + z_n \cdot S 
          &  y_n^2 + C \cdot (1 - y_n^2) 
          &  y_n \cdot z_n \cdot (1 - C) - x_n \cdot S   
          &  1       
          \\
               x_n \cdot z_n \cdot (1 - C) - y_n \cdot S 
           &   y_n \cdot z_n \cdot (1 - C) +  x_n \cdot S 
           &  z_n^2 + C \cdot (1 - z_n^2) 
           &  1
           \\

           0 & 0 & 0 & 1 
         
        \end{bmatrix}
\end{equation}

Where: 
  + $\theta$ is the rotation angle around the unit vector $\hat{n}$
  + $C = \sin \theta$
  + $S = \cos \theta$
  + $\hat{n}$ is a unit vector that designates the direction, thus: $\hat{n} = 1$
  + $\hat{n} = [x_n \quad y_n \quad z_n]^T$
    + $x_n$, $y_n$, $z_n$ are the components of vector $\hat{n}$.


Testing formula in [[https://www.sympy.org/en/index.html][Sympy]] - Python CAS (Computer Algebra System): 

#+BEGIN_SRC python 
  import sympy 

  # t represents the angle theta 
  x, y, z, t = symbols('x y z t') 
  C, S = symbols("C S")

  row1 = [ x**2 + C * (1 - x**2), x * y * (1 - C) - z * S, x * z * (1 - C)  + y * S ]
  row2 = [ x * y * (1 - C) + z * S, y**2 + C * (1 - y**2), y * z * (1 - C) - x * S ]
  row3 = [ x * z * (1 - C) - y * S,  y * z * (1 - C) +  x * S, z**2 + C * (1 - z**2) ]

  m = Matrix([row1, row2, row3])

  # C = cos(t)
  # S = sin(t)

  In [7]: m
  Out[7]: 
  ⎡   ⎛     2⎞    2                                          ⎤
  ⎢ C⋅⎝1 - x ⎠ + x     -S⋅z + x⋅y⋅(1 - C)  S⋅y + x⋅z⋅(1 - C) ⎥
  ⎢                                                          ⎥
  ⎢                       ⎛     2⎞    2                      ⎥
  ⎢S⋅z + x⋅y⋅(1 - C)    C⋅⎝1 - y ⎠ + y     -S⋅x + y⋅z⋅(1 - C)⎥
  ⎢                                                          ⎥
  ⎢                                           ⎛     2⎞    2  ⎥
  ⎣-S⋅y + x⋅z⋅(1 - C)  S⋅x + y⋅z⋅(1 - C)    C⋅⎝1 - z ⎠ + z   ⎦

  # --- Determine rotation matrix around Z axis (Particular case) ------#
  #

  In [8]: m.subs({x: 0, y: 0, z: 1})
  Out[8]: 
  ⎡C  -S  0⎤
  ⎢        ⎥
  ⎢S  C   0⎥
  ⎢        ⎥
  ⎣0  0   1⎦

  In [11]: rotZ = m.subs({x: 0, y: 0, z: 1, C: cos(t), S: sin(t) })

  In [12]: rotZ
  Out[12]: 
  ⎡cos(t)  -sin(t)  0⎤
  ⎢                  ⎥
  ⎢sin(t)  cos(t)   0⎥
  ⎢                  ⎥
  ⎣  0        0     1⎦


  #---- Determine rotation matrix around X axis (Particular case) ------#
  #
  In [14]: rotX = m.subs({x: 1, y: 0, z: 0, C: cos(t), S: sin(t) })

  In [15]: rotX
  Out[15]: 
  ⎡1    0        0   ⎤
  ⎢                  ⎥
  ⎢0  cos(t)  -sin(t)⎥
  ⎢                  ⎥
  ⎣0  sin(t)  cos(t) ⎦

  #---- Determine rotation matrix around Y axis (Particular case) ------#
  #
  In [16]: rotY = m.subs({x: 0, y: 1, z: 0, C: cos(t), S: sin(t) })

  In [17]: rotY
  Out[17]: 
  ⎡cos(t)   0  sin(t)⎤
  ⎢                  ⎥
  ⎢   0     1    0   ⎥
  ⎢                  ⎥
  ⎣-sin(t)  0  cos(t)⎦

#+END_SRC

*** Concatenating Affine Transforms 

  *Concatenating / Combinating of affine transforms* 

Multiple affine transforms can be combined or concatenated as a single
affine transform, just by multiplying matrices. Considering the
following sequence of 3D affine transforms, such as:

   1. scale(3, 3, 3) - scale by 3 on all axis.
   2. translate(x = 25, y = 10, z = 20) - translate to point (25, 30, 2)
   3. rotX(30) - rotate 30 degrees around X axis
   4. rotZ(54) - rotate by 54 degrees around Z axis.

Let V = [ x y z 1 ]' to be (4 x 1 - 4 rows and 1 column) a column
vector containing the current vertice homogeneous coordinates.

Those transforms can be combined in the following way: 

  + Node: the symnol (·) means multiplication.

#+BEGIN_SRC js 
    // Where:
    //  =>  scale(3, 3, 3) is the scaling affine transform matrix.
    //  =>  Va is the vertex coordinate after applying the scale transform.
    // 
    Va = scale(3, 3, 3) · V
    
    // Where: 
    // => translate(25, 10, 20) is the translation affine transfom matrix. 
    // => Vb is the result, vertex coodinate after the transform was applied.
    Vb = translate(25, 10, 20)  · Va 

    Vc = rotX(30) · Vb
    Vd = rotZ(54) · Vc

    // V' (V - prime) - overall transformation result (end result)
    V' = Vd 
#+END_SRC

By performing algebraics substitution, the overall transform result
becomes: 

#+BEGIN_SRC text
   STEP 1: 
    Vb = translate(25, 10, 20) · Va 
    Vb = translate(25, 10, 20) · ( scale(3, 3, 3) · V )

   STEP 2:     
     Vc = rotX(30) · Vb 
     Vc = rotX(30) · ( translate(25, 10, 20) · ( scale(3, 3, 3) · V ) )

   STEP 3: 
     Vd = rotZ(54) · vc 
     Vd = rotZ(54) · ( rotX(30) · ( translate(25, 10, 20) · ( scale(3, 3, 3) · V ) ) )
    
   STEP 4:  - End result 
     V' = Vd
     V' = rotZ(54) · ( rotX(30) · ( translate(25, 10, 20) · ( scale(3, 3, 3) · V ) ) )          
#+END_SRC

The final vertex position can be stated as:

#+BEGIN_SRC text 
     V' = rotZ(54) · rotX(30) · translate(25, 10, 20) · scale(3, 3, 3) · V 

  OR:

     V' =  [ rotZ(54) · rotX(30) · translate(25, 10, 20) · scale(3, 3, 3) ] · V 
#+END_SRC

All the sequence of transformations can be combined as a single
transform, designated by T, which is the multiplication between all
transforms in reverse order that they were applied. The last transform
is multiplied first and first transform is multiplied last. In the
same that matrix multiplication is not commutative, the operation
result depends on the order that of matrices, transform combinations
are not commutative, they also depends on the order that transforms
were applied. 

#+BEGIN_SRC text 
  V' = T · V 
    
  Where: 
     T =  rotZ(54) · rotX(30) · translate(25, 10, 20) · scale(3, 3, 3)  
#+END_SRC

Multiple transforms can be combined as: 

#+BEGIN_SRC text    
    Tranform_combined = Transform_N · Transform_N-1 · ... · Transform_2 · Transform_1
#+END_SRC


  *Combining 2D canonical transforms in Sympy - Python CAS*

Sympy - Python CAS (Computer Algebra System) can be used for debugging
and testing affine transforms in a symbolic way. 

Define 2D canonical affine transforms: 

#+BEGIN_SRC python 
   from sympy import *

   x,  y  = symbols("x y")
   dx, dy = symbols("dx dy")
   sx, sy = symbols("sx sy")
   t      = symbols("t")  # t represents the rotation angle theta (θ)


   # Column vector representing - generic Vertex (aka point) in homogeneous coordinate
   # 
   v = Matrix([x, y, 1])

   >>> pprint(v)
   ⎡x⎤
   ⎢ ⎥
   ⎢y⎥
   ⎢ ⎥
   ⎣1⎦

   # Translation of (dx, dy) coordinate transform 
   >>> Translate = Matrix([[1, 0, dx], [0, 1, dy], [0, 0, 1]])

   >>> pprint(Translate)
   ⎡1  0  dx⎤
   ⎢        ⎥
   ⎢0  1  dy⎥
   ⎢        ⎥
   ⎣0  0  1 ⎦


   # Scale affine transform 
   >>> Scale = Matrix([[sx, 0, 0], [0, sy, 0], [0, 0, 1]])

   >>> pprint(Scale)
   ⎡sx  0   0⎤
   ⎢         ⎥
   ⎢0   sy  0⎥
   ⎢         ⎥
   ⎣0   0   1⎦


   # Rotation around Z axis 
   >>> RotZ  = Matrix([[ cos(t), -sin(t), 0], [ sin(t), cos(t), 0], [0, 0, 1]])

   >>> pprint( RotZ )
   ⎡cos(t)  -sin(t)  0⎤
   ⎢                  ⎥
   ⎢sin(t)  cos(t)   0⎥
   ⎢                  ⎥
   ⎣  0        0     1⎦

#+END_SRC

Apply single transforms to vertex *v*. 

#+BEGIN_SRC python 
  # Apply translation affine transform to vertex V 
  #-------------------------------------------
  >>> pprint( Translate * v )
  ⎡dx + x⎤
  ⎢      ⎥
  ⎢dy + y⎥
  ⎢      ⎥
  ⎣  1   ⎦

  # Apply scale to vertex v 
  #-------------------------------------------

  >>> Scale * v
  Matrix([
  [sx*x],
  [sy*y],
  [   1]])

  >>> pprint( Scale * v )
  ⎡sx⋅x⎤
  ⎢    ⎥
  ⎢sy⋅y⎥
  ⎢    ⎥
  ⎣ 1  ⎦

  >>> pprint( (Scale * v).subs({sx: 10, sy: 10}) )
  ⎡10⋅x⎤
  ⎢    ⎥
  ⎢10⋅y⎥
  ⎢    ⎥
  ⎣ 1  ⎦


  >>> pprint( (Scale * v).subs({sx: 10, sy: 20}) )
  ⎡10⋅x⎤
  ⎢    ⎥
  ⎢20⋅y⎥
  ⎢    ⎥
  ⎣ 1  ⎦


  # Apply rotation to vertex v 
  #------------------------------

  >>> v_rot = RotZ * v

  >>> pprint( v_rot )
  ⎡x⋅cos(t) - y⋅sin(t)⎤
  ⎢                   ⎥
  ⎢x⋅sin(t) + y⋅cos(t)⎥
  ⎢                   ⎥
  ⎣         1         ⎦

  >>> pprint( v_rot.subs(t, 0) )
  ⎡x⎤
  ⎢ ⎥
  ⎢y⎥
  ⎢ ⎥
  ⎣1⎦

  # Rotate by 90 degrees (pi / 2 radians)
  >>> pprint( v_rot.subs(t, pi / 2) )
  ⎡-y⎤
  ⎢  ⎥
  ⎢x ⎥
  ⎢  ⎥
  ⎣1 ⎦

  # Rotate by 60 degreees (pi / 3)
  >>> pprint( v_rot.subs(t, pi / 3) )
  ⎡x   √3⋅y⎤
  ⎢─ - ────⎥
  ⎢2    2  ⎥
  ⎢        ⎥
  ⎢√3⋅x   y⎥
  ⎢──── + ─⎥
  ⎢ 2     2⎥
  ⎢        ⎥
  ⎣   1    ⎦
#+END_SRC

Combine 2 tranforms in multiple orders and check the outcome. 

#+BEGIN_SRC python 
  # Combine transforms: 1st - translation; 2nd - scale. 
  #--------------------------------------------------

    >>> T = Scale * Translate

    >>> pprint(T)
    ⎡sx  0   dx⋅sx⎤
    ⎢             ⎥
    ⎢0   sy  dy⋅sy⎥
    ⎢             ⎥
    ⎣0   0     1  ⎦


    # Apply to vertex
    >>> pprint( T * v ) 
    ⎡dx⋅sx + sx⋅x⎤
    ⎢            ⎥
    ⎢dy⋅sy + sy⋅y⎥
    ⎢            ⎥
    ⎣     1      ⎦


  # Combine transforms: 1st - scale; 2nd - translation. 
  #--------------------------------------------------

     >>> T = Translate * Scale

     >>> pprint( T )
     ⎡sx  0   dx⎤
     ⎢          ⎥
     ⎢0   sy  dy⎥
     ⎢          ⎥
     ⎣0   0   1 ⎦

     # Apply to vertex
     >>> pprint(T * v) 
     ⎡dx + sx⋅x⎤
     ⎢         ⎥
     ⎢dy + sy⋅y⎥
     ⎢         ⎥
     ⎣    1    ⎦


  # Combine transforms: 1st - rotation; 2nd - translation. 
  #--------------------------------------------------

     >>> T = Translate * RotZ

     >>> pprint( T )
     ⎡cos(t)  -sin(t)  dx⎤
     ⎢                   ⎥
     ⎢sin(t)  cos(t)   dy⎥
     ⎢                   ⎥
     ⎣  0        0     1 ⎦


     # Apply to vertex
     >>> pprint( T * v ) 
     ⎡dx + x⋅cos(t) - y⋅sin(t)⎤
     ⎢                        ⎥
     ⎢dy + x⋅sin(t) + y⋅cos(t)⎥
     ⎢                        ⎥
     ⎣           1            ⎦

  # Combine transforms: 1st - translation ; 2nd - rotation 
  #------------------------------------------------------

     >>> T = RotZ * Translate

     >>> pprint( T )
     ⎡cos(t)  -sin(t)  dx⋅cos(t) - dy⋅sin(t)⎤
     ⎢                                      ⎥
     ⎢sin(t)  cos(t)   dx⋅sin(t) + dy⋅cos(t)⎥
     ⎢                                      ⎥
     ⎣  0        0               1          ⎦


     # Apply to vertex
     >>> pprint( T * v ) 
     ⎡dx⋅cos(t) - dy⋅sin(t) + x⋅cos(t) - y⋅sin(t)⎤
     ⎢                                           ⎥
     ⎢dx⋅sin(t) + dy⋅cos(t) + x⋅sin(t) + y⋅cos(t)⎥
     ⎢                                           ⎥
     ⎣                     1                     ⎦


#+END_SRC

Combine transforms in the following order: 1st - rotation; 2nd -
scaling; 3rd - translation: 

#+BEGIN_SRC python 
   >>> T = Translate * Scale * RotZ

   >>> pprint( T )
   ⎡sx⋅cos(t)  -sx⋅sin(t)  dx⎤
   ⎢                         ⎥
   ⎢sy⋅sin(t)  sy⋅cos(t)   dy⎥
   ⎢                         ⎥
   ⎣    0          0       1 ⎦

   >>> pprint( T * v )
   ⎡dx + sx⋅x⋅cos(t) - sx⋅y⋅sin(t)⎤
   ⎢                              ⎥
   ⎢dy + sy⋅x⋅sin(t) + sy⋅y⋅cos(t)⎥
   ⎢                              ⎥
   ⎣              1               ⎦
#+END_SRC

*** Quaternions 

Quaternions are a generalization of complex numbers, that was proposed
and formulated by the irish mathematician and physicist William Rowan
Hamilton, in 1843. This mathematical construct provides a convenient
notation for expressing rotation and has a broad range of
applications, including computer graphics, computer vision, robotics,
orbital mechanics, aerospace and flight dynamics.

A quaternion *q* is defined as: 
 
  + Where:
    + w, x, y, z are real numbers.
    + w => is the quaternion's real (scalar) component.
    + [x, y, z] => is the quaternion's vector componet 
    + i, j, k are unit vectors (basis elements) that satisfies a set
      of properties. 

\begin{equation}
   q = w + x \cdot i + y \cdot j + z \cdot k
\end{equation}

The quaternion *q* can be represented as: 

   + Where:
     + $\vec{v} = [x, y, z]$ is the quaternion vector component.

\begin{align*}
    q &= [w, x, y, z]  \quad & \text{Tuple representation}         \\
    q &= (u, \vec{v})  \quad & \text{Scalar/vector representation} \\
\end{align*}


The quaternion unit vectors or basis elements satifies the following
properties: 

\begin{equation}
   i^1 = j^2 = k^2 = i \cdot j \cdot k = -1 
\end{equation}

And also:

\begin{align*}
    i \cdot j = k  & \quad & j \cdot i =  k  \\
    j \cdot k = i  & \quad & k \cdot j = -i  \\
    k \cdot i = j  & \quad & i \cdot k = -j  \\
\end{align*}

 
 *Types of Quaternion* 

 + Real quaternion 

Real quaternion, is a quaterion which all elements of vector
components are zero. 

\begin{equation} 
   q = w + 0 \cdot i + 0 \cdot j + 0 \cdot k 
\end{equation}

 + Pure quaternion 

A pure quaternion, has the real part equal to zero. It can represent a
vector in the space. 

\begin{equation} 
  q = 0 + x \cdot i + y \cdot j + z \cdot k
\end{equation}

 + Unit quaternion 

A quaternion which the norm or magnitude is equal to one. 

\begin{equation} 
  || q || = 1
\end{equation}

 *Quaternion Conjugate* 

The conjugate of a quaternion, $q^*$, is defined as:

\begin{equation}
  q^{*} = w - \vec{v} 
        = w - (x \cdot i + y \cdot j + z \cdot k)
        = w + (-x) i + (-y) j + (-z) k         
\end{equation}
 
 *Inverse Quaternion* $q^{-1}$

\begin{equation}
  q^{-1} = \frac{q^{*}}{ || q ||^2 }
\end{equation}

The inverse quaternion satifies the following equality: 

\begin{equation}
  q^{-1} \cdot q = q \cdot q^{-1} = 1 
\end{equation}

 *Quaternion Norm* 

The norm (magnitude) of a quaternion is given by: 

\begin{equation}
   || q ||^2 = q \cdot q^{*} =  w^2 + x^2 + y^2 + z^2
\end{equation}

 *Unit quaternion* 

An unit quaternion $q_u$ has norm equal to one.

\begin{equation}
   || q_u || = 1 
\end{equation}

An unit quaternion is equal to its conjugate: 

\begin{equation} 
   q^* = q^{-1}
\end{equation}

 *Quaternion Dot Product* 

A quaternion dot product is similar to vector dot product. The
quaternion dot product between two quaternions q1 and q2 is defined as
the sum of the product between the quaternions components. 

\begin{equation} 
   \text{dotquat}(q_1, q_2) = q_1 \cdot q_2 = w_1 \cdot w_2 + x_1 \cdot x_2 + y_1 \cdot y_2 + z_1 \cdot z_2 
\end{equation}

 *Angle between two quaternion* 

The angle between two quaternions q1 and q2 is defined as: 

\begin{equation} 
    \cos \theta = \frac{ q_1 \cdot q_2 }{ || q_1 || \cdot || q_2 ||  }
                = \frac{ \text{dotquat}(q_1, q_2) }{ \text{norm}( q_1) \cdot \text{norm}(q_2)  }
                = \frac{  w_1 \cdot w_2 + x_1 \cdot x_2 + y_1 \cdot y_2 + z_1 \cdot z_2  }{  || q_1 || \cdot || q_2 ||  }
\end{equation}

 *Quaternion Sum* 

The sum of two quaternions q1 and q2 is: 

\begin{equation}
   q_1 + q_2 = (w_1 + w_2) + (x_1 + x_2) i + (y_1 + y_2)j + (z_1 + z_2) k
\end{equation}

 *Quaternion Product* (a.k.a Hamilton Product)

The product *p* of two quaternons q1 and q2 can be computed as: 

  + Where:
    + p is the quaternion product between q1 and q2
    + $\vec{v_1} \cdot \vec{v_2}$ is the scalar product between $\vec{v_1}$ and $\vec{v_2}$.
    + $\vec{v1} \times \vec{v_2}$ is the cross product between  $\vec{v_1}$ and $\vec{v_2}$.
    + $p_v$ is the vector component of p
    + $p_w$ is the scalar/real component of p.

\begin{align*}
  p &= q_1 \cdot q_2 = ( w_1 \cdot w_2 - \vec{v_1} \cdot \vec{v_2} \quad ; \quad
                       w_1 \cdot \vec{v_2} + w_2 \cdot \vec{v_1} + \vec{v1} \times \vec{v_2} )  \\

    &= ( w_1 \cdot w_2 - \vec{v_1} \cdot \vec{v_2} )  + 
                      ( w_1 \cdot \vec{v_2} + w_2 \cdot \vec{v_1} + \vec{v1} \times \vec{v_2} )
\end{align*}

The components of vector p are: 

\begin{align*}
    p_w &= w_1 \cdot w_2 - \vec{v_1} \cdot \vec{v_2}                             \\
    p_v &= w_1 \cdot \vec{v_2} + w_2 \cdot \vec{v_1} + \vec{v1} \times \vec{v_2} \\
\end{align*}

The quaternion product is non commuative, as a result, the following
holds: 

\begin{equation}
      q_1 \cdot q_2 \neq q_2 \cdot q_2 
\end{equation}

The quaternion product satifies the following properties: 

\begin{align*}
    || q_1 \cdot q_2 ||  &= ||q_1|| \cdot || q_2 ||   \\
     (q_1 \cdot q_2)^* &= q_2^* \cdot q_1^*
\end{align*}

  *Quaternion product between pure quaternions* 

The product between two pure quaternions yields the dot product and
cross simultaneously, the dot product as the real part of the
operation result and cross product as the vector part of the result.

\begin{equation} 
    p \cdot q = - (p \cdot q) + (p \times q)
\end{equation}

Where: 
  + Note: A pure quaternion, is the same as space vector, the real
    part is zero, w = 0.
  + $p = 0 + x_p \cdot i + y_p \cdot j + z_p \cdot k$
  + $q = 0 + x_q \cdot i + y_q \cdot j + z_q \cdot k$
  + $p \cdot q$ is the dot product between the vector parts of p and q.
  + $p \times q$ is the cross product (vector product) between p and q.

 
  *Quaternion division* ([[http://www.math.umd.edu/~immortal/MATH431/lecturenotes/ch_quaternions.pdf][MATH432]] - page 11)

The division between two quaternions q1 and q2 is defined as: 

\begin{equation} 
   \frac{q_1}{q_2} = \frac{q_1 \cdot q_2^* }{ || q_2 ||^2 } = \frac{1}{ || q_2 ||^2 } ( q_1 \cdot q_2^* )
\end{equation}

  *Quaternion product using matrices representation*

The product of two quaternions q1 and q2 can be computed 
in a more convenient and faster way by using matrices and column
vectors multiplication, instead of dot product and cross product. 

Let $[q]_v$ be the vector column representation of a quaternion: 

\begin{equation} 
  [q]_v = \begin{bmatrix} w \\ x \\ y \\ z  \end{bmatrix}
\end{equation}

Let $[q]_m$ be the following matrix representation of a quaternion: 

\begin{equation} 
  [q]_m = \begin{bmatrix} 
               w  & -x & -y & -z  \\ 
               x  &  w & -z &  y  \\
               y  &  z &  w & -x  \\
               z  & -y &  x &  w  \\
          \end{bmatrix}
\end{equation}

The quaternion product between q1 and q2, designated by $[q_r]_v$, can
be expressed as a matrix-column vector multiplication, which is best
suitable for a computer implementation.

\begin{equation} 
  [q_r]_v = q_1 \cdot q_2 = [q_1]_m \cdot [q_2]_v 
          =           
          \begin{bmatrix} 
               w_1  & -x_1 & -y_1 & -z_1  \\ 
               x_1  &  w_1 & -z_1 &  y_1  \\
               y_1  &  z_1 &  w_1 & -x_1  \\
               z_1  & -y_1 &  x_1 &  w_1  \\
          \end{bmatrix}

          \begin{bmatrix} 
              w_2 \\ x_2 \\ y_2 \\ z_2 \\
          \end{bmatrix}
\end{equation}

By performing the previous matrix multiplication, the quaternion
product becomes: 

\begin{equation} 
     [q_r]_v = q_1 \cdot q_2 = 
       \begin{bmatrix} 
            w_1 \cdot w_2 - x_1 \cdot x_2 - y_1 \cdot y_2 - z_1 \cdot z_2  \\ 
            w_1 \cdot x_2 + w_2 \cdot x_1 + y_1 \cdot z_2 - y_2 \cdot z_1  \\
            w_1 \cdot y_2 + w_2 \cdot y_1 - x_1 \cdot z_2 + x_2 \cdot z_1  \\ 
            w_1 \cdot z_2 + w_2 \cdot z_1 + x_1 \cdot y_2 - x_2 \cdot y_1  \\
       \end{bmatrix}
\end{equation}


  *Rotation Quaternion*

A rotation around an axis $\hat{n}$ (unit vector) by angle $\theta$
can be encoded by quaternion $q_r$: 

\begin{equation} 
   q_r = \cos \frac{\theta}{2}  + \sin \frac{\theta}{2} \cdot \hat{n}
       = \cos \frac{\theta}{2}  + \sin \frac{\theta}{2} ( x_n \cdot i + y_n \cdot j + z_n \cdot k  )
\end{equation}

 + Where:
   + $\hat{n}$ is a unit vector.
   + $\hat{n} = x_n \cdot i + y_n \cdot j + z_n \cdot k$ 
   + $|| \hat{n} || = 1$

The norm of quaternion $q_r = 1$, thus the following holds: 

\begin{equation} 
  || q_r || = 1 
\end{equation}

The coordinate transformation from a vector in reference frame A to a
reference frame B, obtained by the rotation of coordinate frame A
around a unit vector $\hat{n}$ can be computed as:

\begin{equation} 
   q_B = q_r \cdot q_A \cdot q_r^{-1}
       = q_r \cdot q_A \cdot q_r^{*}
\end{equation}

Where: 
  + $q_A$ is the coordinate of a vector in the reference frame A (aka
    coordinate system, aka coordinate frame).
  + $q_B$ is the coordinate of a the same vector in the reference frame B.  
  + $q_A = 0 + x_A \cdot i + y_A \cdot j + z_A \cdot k$
  + $q_B = 0 + x_B \cdot i + y_B \cdot j + z_B \cdot k$


The previous rotation coordinate transformation can be determined in a
more efficient way by applying the following algorithm. [[https://fgiesen.wordpress.com/2019/02/09/rotating-a-single-vector-using-a-quaternion/][(The-Ryg-Blog)]]


\begin{eqnarray*} 
   v_t &=& 2 ( v_r \times v_a)                    \\
   q_B &=&  v_A + w_r \cdot v_t + v_r \times v_t 
\end{eqnarray*}

Where: 
  + $[ Q ]_w$ - real part of a quaternion Q 
  + $[ Q ]_v$ - vector part of a quaterion Q
  + $w_r = \cos ( \theta / 2)$ - real part of rotation quaternion $q_r$
  + $v_r = \hat{n} \cdot \sin( \theta / 2 )$ - vector part of rotation quaternion $q_r$
  + $v_B$ - vector part of quaternion $q_B$
  + $v_A$ - Vector part of quaternion $q_A$
  + $v_r \times v_a$ - Cross product between those two vectors.

  *Quaternion to rotation matrix* 

The rotation matrix that transforms coordinates from reference frame A
to reference frame B can be computed as:  [[https://www.weizmann.ac.il/sci-tea/benari/sites/sci-tea.benari/files/uploads/softwareAndLearningMaterials/quaternion-tutorial-2-0-1.pdf][(Moti Ben-Ari - Wizmann)]], [[http://barbic.usc.edu/cs520-s12/quaternions/quaternions-cs520.pdf][(Jernej Barbic)]]

\begin{equation} 
   R_n = \begin{bmatrix}

             a^2 + b^2 - c^2 - d^2  
          &  2 (b \cdot c -  a \cdot d)
          &  2 (b \cdot d +  a \cdot c)  \\

             2 (b \cdot c +  a \cdot d )
          &  a^2 - b^2 + c^2 -d^2                   
          &  2 ( c \cdot d -  a \cdot b ) \\

             2 ( b \cdot d -  a \cdot c  )
          &  2 ( c \cdot d +  a \cdot b )
          &  a^2 - b^2 - c^2 + d^2     \\

         \end{bmatrix}
\end{equation}

Where: 
  + a, b, c, d are the components of the unit quaternion $q_r$ 
  + $a = \cos( \theta / 2)$
  + $b = x_n \cdot \sin (\theta / 2)$
  + $c = y_n \cdot \sin (\theta / 2)$
  + $d = z_n \cdot \sin (\theta / 2)$

The matrix $R_n$ can also be simplified to: [[https://www.weizmann.ac.il/sci-tea/benari/sites/sci-tea.benari/files/uploads/softwareAndLearningMaterials/quaternion-tutorial-2-0-1.pdf][(Moti Ben-Ari - Wizmann)]]

\begin{equation} 
   R_n = 2 \begin{bmatrix}
              a^2 + b^2 - 1/2  & 
              b \cdot c - a \cdot d  & 
              a \cdot c + b \cdot d  \\ 

              a \cdot d + b \cdot c  &
              a^2  + c^2 - 1/2 & 
              c \cdot d - a \cdot b  \\

              b \cdot d - a \cdot c &
              a \cdot b + c \cdot d &
              a^2 + d^2 - 1/2 \\
           
          \end{bmatrix}
\end{equation}

Coordinates from frame A can be turned into coordinates from frame B
by performing the following  matrix multiplication.

\begin{equation} 
    \begin{bmatrix} x_B \\ y_B \\ z_B \end{bmatrix}
    = R_n  \begin{bmatrix} x_A \\ y_A \\ z_A \end{bmatrix}
\end{equation}


From the previous matrix $R_n$ it is possible to determine the
yaw-pitch-roll (Z-X-Y) Euler's angles. [[http://www.chrobotics.com/library/understanding-quaternions][(chrobotics)]]

\begin{eqnarray*}
    \phi   &=&  \arctan\left( \frac{ 2 a \cdot b + 2 c \cdot d } { a^2 - b^2 - c^2 + d^2 } \right )  \\ 
    \theta &=& -\arcsin\left( 2 b \cdot d - 2 a \cdot c  \right )                                    \\
    \psi   &=&  \arctan\left( \frac{ 2 a \cdot d + 2 b \cdot c}{ a^2 + b^2 - c^2 - d^2 } \right )    \\
\end{eqnarray*}

Where: 
  + $\phi$   - is the yaw angle
  + $\theta$ - is the pitch angle
  + $\psi$   -is the roll angle 


  *Quaternion to homogeneous coordinate rotation matrix* 

The matrix $R_n$ can be converted to a homogenous coordinate form,
$T_n$, which is more convenient, since homogenous coordinate allows
expressing translations in a similar fashion to rotation
transformations, just as vector-matrix multiplication.


\begin{equation} 
   T_n = \begin{bmatrix}

             a^2 + b^2 - c^2 - d^2  
          &  2 (b \cdot c -  a \cdot d)
          &  2 (b \cdot d +  a \cdot c)  
          &  0                            \\

             2 (b \cdot c +  a \cdot d )
          &  a^2 - b^2 + c^2 -d^2                   
          &  2 ( c \cdot d -  a \cdot b ) 
          &  0                            \\

             2 ( b \cdot d -  a \cdot c  )
          &  2 ( c \cdot d +  a \cdot b )
          &  a^2 - b^2 - c^2 + d^2     
          &  0                            \\

             0 & 0 & 0 & 1 \\ 
         \end{bmatrix}
\end{equation}


\begin{equation} 
   T_n = 2 \begin{bmatrix}
              a^2 + b^2 - 1/2  & 
              b \cdot c - a \cdot d  & 
              a \cdot c + b \cdot d  & 
              0                      \\ 

              a \cdot d + b \cdot c  &
              a^2  + c^2 - 1/2       & 
              c \cdot d - a \cdot b  & 
              0                     \\ 

              b \cdot d - a \cdot c &
              a \cdot b + c \cdot d &
              a^2 + d^2 - 1/2       & 
              0                     \\ 

              0 & 0 & 0 & 1 \\
           
          \end{bmatrix}
\end{equation}

Homogeneous coordinates from frame A can be turned into coordinates of
frame B by using the following expression: 

\begin{equation} 
    \begin{bmatrix} x_B \\ y_B \\ z_B \\ 1 \end{bmatrix}
    = T_n  \begin{bmatrix} x_A \\ y_A \\ z_A \\ 1 \end{bmatrix}
\end{equation}

  *Further Reading* 

General: 

   + [[https://en.wikipedia.org/wiki/Quaternion][Quaternions]] - Wikipedia

   + [[https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation][Quaternions and spatial rotation]] 

   + [[https://en.wikipedia.org/wiki/History_of_quaternions][History of Quaternions]]

   + [[https://arxiv.org/pdf/2009.00425.pdf][An algorithm for dividing quaternions]] [PAPER]

   + [[http://www.chrobotics.com/library/understanding-quaternions][Understanding Quaternions]]  - ChRobotics

   + [[http://www.chrobotics.com/library/understanding-euler-angles][Understanding Euler Angles]] - ChRobotics

   + [[https://www.energid.com/resources/orientation-calculator][Quaternion Calculator]] - Energid / Actin Advanced Control For Robotics
     + Note: Online calculator for Quaternions.

   + [[https://www.weizmann.ac.il/sci-tea/benari/sites/sci-tea.benari/files/uploads/softwareAndLearningMaterials/quaternion-tutorial-2-0-1.pdf][A Tutorial on Euler Angles and Quaternions]] - Weizmann Institute of Science

   + [[http://www.math.umd.edu/~immortal/MATH431/lecturenotes/ch_quaternions.pdf][Chapter 5 - Quaternions]]

   + [[http://wiki.ogre3d.org/Quaternion+and+Rotation+Primer][Quaternion Rotation Primer / Ogre3D Game Engine]]

   + https://web.cs.ucdavis.edu/~amenta/3dphoto/quaternion.pdf

   + [[http://www2.cs.uregina.ca/~anima/408/Notes/Quaternions/Quaternions.htm][Quaternion - in computer animation]]  

Quaternion Computer Implementations: 

   + [[http://docs.ros.org/en/kinetic/api/tf/html/c++/classtf_1_1Quaternion.html][t::Quaternion - ROS Framework]] (C++)

   + [[https://doc.qt.io/qt-5/qquaternion.html][Qt5 C++ Framework - QQuaternion class]] (C++)

   + [[https://doc.qt.io/qt-5/qtdatavisualization-rotations-example.html][Qt5 - Rotation Example]]

   + [[https://ivlab.github.io/MinGfx/classmingfx_1_1_quaternion.html][MinGfx C++ - OpenGL Wrapper]] (C++)

   + [[https://doc.magnum.graphics/magnum/classMagnum_1_1Math_1_1Quaternion.html][Magnum Graphics Library - Quaternion]] (C++)

   + [[https://docs.microsoft.com/en-us/dotnet/api/system.numerics.quaternion?view=net-5.0][Quaternion Struct]] - Dotnet (C#)

   + [[https://octave.sourceforge.io/quaternion/overview.html][Octave - Quaternion Library]] (OCtave Language, akin to Matlab)

   + [[https://docs.blender.org/api/2.33/Mathutils-module.html][Blender - MathUtils module]] 

*** Quaternion Implementation in Julia Language

It is worth prototyping quaternion math in a numerically-oriented programming
language such as [[https://en.wikipedia.org/wiki/Julia_(programming_language)][Julia Language]] is helpful for understanding and
validating the inner works of quaternion computations. This
implementation of quaternion math represents quaternion as an array of
four elements and uses a matrix representation for implemeting
quaternion multiplication. 

#+BEGIN_SRC julia 
   # Struct for storing quaternion 
   # q = w + x·i + y·j + z·k 
   struct quatp
      arr::Array{Float64,1}
   end 

   function quat(x, y, z, w)
     return quatp([x ; y; z; w])
   end 

   # Turns a quaternion into 4x4 matrix representation
   function quat_to_mat4x4(q::quatp)
       w, x, y, z  = q.arr 
       mat = [  w -x -y -z 
              ; x  w -z  y 
              ; y  z  w -x 
              ; z -y x w ] 
       return mat 
    end 

   function Base.getproperty(q::quatp, sym::Symbol)
       if sym == :arr 
           return getfield(q, :arr)
       elseif sym == :w 
           return getfield(q, :arr)[1]
       elseif sym == :x 
           return getfield(q, :arr)[2]
       elseif sym == :y
           return getfield(q, :arr)[3]
       elseif sym == :z 
           return getfield(q, :arr)[4]
       elseif sym == :v  
           # Return only the quaternion (vector part)
           return getfield(q, :arr)[2:end]
       end 
   end

   # Norm - quaternion magnitude, akin to vector norm 
   function norm(q::quatp)
      w, x, y, z = q.arr 
      return sqrt(w * w + x * x + y * y + z * z)
   end 

   # Conjugate of a quaternion 
   function conj(q::quatp)
     return quat(q.w, -q.x, -q.y, -q.z)
   end 

   # Inverse of quaternion q^-1
   function Base.:inv(q::quatp)
      w, x, y, z = q.arr 
      norm_square =  w * w +  x * x + y * y + z * z 
      return  quat(w, -x, -y, -z) / norm_square
   end 

   # Quaternion sum 
   Base.:+(q1::quatp, q2::quatp) = quat(q1.w + q2.w, q1.x + q2.x, q1.y + q2.y, q1.z + q2.z) 
   Base.:-(q1::quatp, q2::quatp) = quat(q1.w - q2.w, q1.x - q2.x, q1.y - q2.y, q1.z - q2.z) 

   Base.:+(q::quatp,   w::Float64) = quat(w + q.w, q.x, q.y, q.z)
   Base.:+(w::Float64, q::quatp  ) = quat(w + q.w, q.x, q.y, q.z)
   Base.:-(q::quatp,   w::Float64) = quat(q.w - w, q.x, q.y, q.z)

   # Mutliplication => scalar X quaternion 
   Base.:*(a::Float64, q::quatp) = quat( a * q.w, a * q.x, a * q.y, a * q.z)
   Base.:*(q::quatp, a::Float64) = quat( a * q.w, a * q.x, a * q.y, a * q.z)

   Base.:/(q::quatp, a::Float64) = quat( q.w / a, q.x / a, q.y / a, q.z / a)

   # Quaternion multiplication / product
   Base.:*(q1::quatp, q2::quatp) = begin 
        A = quat_to_mat4x4(q1)
        return quatp( A * q2.arr )
   end 

   # Unit quaternions i, j, k 
   const i = quat(0.0, 1.0, 0.0, 0.0)
   const j = quat(0.0, 0.0, 1.0, 0.0)
   const k = quat(0.0, 0.0, 0.0, 1.0)


   # Obtain a rotation quaternion that represents a rotation 
   # by some angle around some direction (normalized vector 'vec') 
   # => The angle is given in degrees.
   function rot_quat(angle::Float64, vec)
      # Normalize vector vec and store the result in v
      xv, yv, zv = vec 
      x, y, z = vec / sqrt( xv * xv + yv * yv + zv * zv )
      S = cosd(angle / 2)
      C = sind(angle / 2)
      return quat(C, S * x, S * y, S * z)   
   end 

   ## Vector cross product VA x VB of two column vectors (3 x 1)
   function cross(va, vb)
        x, y, z = va
        T = [ 0 -z y ; z 0 -x; -y x 0]
        T * vb 
    end

   ## Apply a rotation quaternion to a vector (column vector 3 x 1)
   ##  =>> Vector 3 rows and 1 column 
   ## Algorithm from: 
   #     =>> https://fgiesen.wordpress.com/2019/02/09/rotating-a-single-vector-using-a-quaternion/
   function apply_rot(qr::quatp, va)
      wr = qr.w # Scalar/real part of rotation quaternion 
      vr = qr.v # Vector part of rotation quaternion 
      vt = 2 * cross(vr, va)
      vb = va + wr * vt + cross(vr, vt)
      return vb 
   end

   # Obtain a rotation matrix - that represents rotation
   # around an arbitrary axis (vector)
   # Note: The angle is should be in degrees.
   # 
   function make_rotmat(angle::Float64, vec)
      # Normalize vector vec and store components in x, y, z
      x, y, z = vec 
      x, y, z = vec / sqrt( x * x + y * y + z * z )
      # sin and cos caching 
      C = cosd(angle / 2)
      S = sind(angle / 2)
      # Parameters a, b, c, d => Components of the rotation 
      # quaternion 
      a = C 
      b = x * S 
      c = y * S 
      d = z * S 
      # rotation matrix 
      mat = [
           ( a^2 + b^2 - c^2 - d^2 )  ( 2 * (b * c - a * d )  ) ( 2 * (b * d + a * c)   )  0 
        ;  ( 2 * (b * c + a * d)   )  ( a^2 - b^2 + c^2 - d^2 ) ( 2 * (c * d - a * b)   )  0
        ;  ( 2 * (b * d - a * c)   )  ( 2 * (c * d + a * b)   ) ( a^2 - b^2 - c^2 + d^2 )  0 
        ;  0                          0                         0                          1
      ] 
      return mat 
   end 
#+END_SRC

Quaternion components: 

#+BEGIN_SRC julia 
  # Construct a quaternion 

  julia> q = quat(10.5, -25.1, 4.5, 5.6)
  quatp([10.5, -25.1, 4.5, 5.6])

  julia> q.w # Real part 
  10.5

  julia> q.x # Imaginary part - i axis component
  -25.1

  julia> q.y # Imaginary part - j axis component
  4.5

  julia> q.z # Imaginary part - k axis component (Z axis)
  5.6

  julia> q.arr # Internal array data representation
  4-element Array{Float64,1}:
    10.5
   -25.1
     4.5
     5.6

  julia> q.v # Vector component (i, j, k) components only
  3-element Array{Float64,1}:
   -25.1
     4.5
     5.6
#+END_SRC

Quaternion conjugate and inverse: 

#+BEGIN_SRC julia 
   julia> q = quat(1.0, 2.0, 3.0, 4.0)
   quatp([1.0, 2.0, 3.0, 4.0])

   julia> inv(q)
   quatp([0.03333333333333333, -0.06666666666666667, -0.1, -0.13333333333333333])
   
   # Expected (-1.0)
   julia> q * inv(q)
   quatp([1.0, 0.0, 0.0, 0.0])

   # Expected (-1.0)
   julia> inv(q) * q
   quatp([1.0, -5.551115123125783e-17, -6.938893903907228e-18, 5.551115123125783e-17])
#+END_SRC

Normalize a quaternion: 

#+BEGIN_SRC julia 
  # Expected normalized to be: (w = 0.18257, x = 0.36515, y = 0.54772, z = 0.7303)
  # Test case from: Matlab Robotics Toolbox - https://www.mathworks.com/help/robotics/ref/quaternion.normalize.html

   julia> q = quat(1.0, 2.0, 3.0, 4.0)
   quatp([1.0, 2.0, 3.0, 4.0])

   julia> qn = normalize(q)
   quatp([0.18257418583505536, 0.3651483716701107, 0.5477225575051661, 0.7302967433402214])

   julia> norm(qn)
   0.9999999999999999

#+END_SRC

Test case 1 - for quaternion multiplication: 

  + Test quaternion laws:
  + Expected: i * i = j * j = k * k = -1
  + Expected: i * j = k
  + Expected: j * k = i
  + Expected: k * i = j
  + Expected: j * i = -k

#+BEGIN_SRC julia 
   # ---- Show components i, j, k --------#

   julia> i 
   quatp([0.0, 1.0, 0.0, 0.0])

   julia> j
   quatp([0.0, 0.0, 1.0, 0.0])

   julia> k
   quatp([0.0, 0.0, 0.0, 1.0])

   # ----- Check multiplication of i, j, k by themselves -----------#
   # 

   julia> i * i # Expected -1 or (-1) + 0·i + 0·j + 0·k
   quatp([-1.0, 0.0, 0.0, 0.0])

   julia> j * j # Expected -1 
   quatp([-1.0, 0.0, 0.0, 0.0])

   julia> k * k # Expected -1 
   quatp([-1.0, 0.0, 0.0, 0.0])

   #------- Check multiplication i * j, j * k, k * i and j * i 
   #
   julia> i * j # Expected k 
   quatp([0.0, 0.0, 0.0, 1.0])

   julia> j * i # Expected -k 
   quatp([0.0, 0.0, 0.0, -1.0])

   julia> k * i # Expected j 
   quatp([0.0, 0.0, 1.0, 0.0])

   julia> i * k # Expected -j
   quatp([0.0, 0.0, -1.0, 0.0])

#+END_SRC

Test case 2 - for quaternion multiplication: 

  + From:  [[https://www.mathworks.com/help/aerotbx/ug/quatmultiply.html][Matlab Aerospace Toolbox]]
  + q1 = [ 1.0 0.0 1.0 0.00 ]
  + q2 = [ 1.0 0.5 0.5 0.75 ]
  + Expected result =>> q1 * q2 = [ 0.5 1.25 1.5 0.25 ]

#+BEGIN_SRC julia 
  # -------- Test A ------------------------#
  julia> q1 = quat(1.0, 0.0, 1.0, 0.0) 
  quatp([1.0, 0.0, 1.0, 0.0])

  julia> q2 = quat(1.0, 0.5, 0.5, 0.75)
  quatp([1.0, 0.5, 0.5, 0.75])
 
  # ------- Test B ---------------------#

  julia> q1 = 1.0 + 0.0i + 1.0j + 0.0k
  quatp([1.0, 0.0, 1.0, 0.0])

  julia> q2 = 1.0 + 0.5i + 0.5j + 0.75k
  quatp([1.0, 0.5, 0.5, 0.75])

  julia> q1 * q2
  quatp([0.5, 1.25, 1.5, 0.25])
#+END_SRC

Test case 3 - for quaternion multiplication:

  + From: [[https://www.maplesoft.com/applications/view.aspx?SID=4886&view=html][Maplesoft - Quaternion]]
  + q1 = ( -6) +  (-8)i +  (-5)j +     7k
  + q2 = (-14) + (-12)i + (-19)j + (-17)k
  + Expected: q1 * q2 = 12 +   402i + (-36)j +   96k
  + Expected: q2 * q1 = 12 + (-34)i +   404j + (-88)k
  + Expected: q2 + q1 = (-20) + (-20)i + (-24)j + (-10)k

#+BEGIN_SRC julia 
  julia> q1 = -6.0 + -8.0i + -5.0j + 7.0k
  quatp([-6.0, -8.0, -5.0, 7.0])

  julia> q2 = -14.0 + -12.0i + -19.0j + -17.0k
  quatp([-14.0, -12.0, -19.0, -17.0])

  julia> q1 * q2
  quatp([12.0, 402.0, -36.0, 96.0])

  julia> q2 * q1
  quatp([12.0, -34.0, 404.0, -88.0])

  julia> q1 + q2
  quatp([-20.0, -20.0, -24.0, -10.0])

  julia> q2 + q1
  quatp([-20.0, -20.0, -24.0, -10.0])


#+END_SRC

 *Test algorithm - make_rotmat* that computes rotation matrices around
 an arbitrary axis: 

Define functions for computing rotation matrices: 

#+BEGIN_SRC julia
   # Rotation around X axis 
   function rot_x(angle::Float64) 
      C = cosd(angle)
      S = sind(angle)
      return [  1   0   0  0
              ; 0   C  -S  0 
              ; 0   S   C  0 
              ; 0   0   0  1
             ]
   end

   # Rotation around X axis 
   function rot_y(angle::Float64) 
      c = cosd(angle)
      s = sind(angle)
      return [  c   0   s  0
              ; 0   1   0  0 
              ;-s   0   c  0 
              ; 0   0   0  1
             ]
   end

   # Returns homogeneous rotation matrix around Z axis 
   # => The angle must be in degrees, not radians
   function rot_z(angle::Float64) 
      c = cosd(angle)
      s = sind(angle)
      return [  c  -s  0  0
              ; s   c  0  0 
              ; 0   0  1  0 
              ; 0   0  0  1
             ]
   end
#+END_SRC  

Test rotation matrices: 

#+BEGIN_SRC julia 
   const axis_x = [1.0 0.0 0.0]';
   const axis_y = [0.0 1.0 0.0]';
   const axis_z = [0.0 0.0 1.0]';

   # -------- Rotation around Z axis ---------- #
   # 

   julia> rot_z(90.0)
   4×4 Array{Float64,2}:
    0.0  -1.0  0.0  0.0
    1.0   0.0  0.0  0.0
    0.0   0.0  1.0  0.0
    0.0   0.0  0.0  1.0

   julia> make_rotmat(90.0, axis_z)
   4×4 Array{Float64,2}:
    0.0  -1.0  0.0  0.0
    1.0   0.0  0.0  0.0
    0.0   0.0  1.0  0.0
    0.0   0.0  0.0  1.0


   julia> rot_z(45.0)
   4×4 Array{Float64,2}:
    0.707107  -0.707107  0.0  0.0
    0.707107   0.707107  0.0  0.0
    0.0        0.0       1.0  0.0
    0.0        0.0       0.0  1.0

   julia> make_rotmat(45.0, axis_z)
   ]4×4 Array{Float64,2}:
    0.707107  -0.707107  0.0  0.0
    0.707107   0.707107  0.0  0.0
    0.0        0.0       1.0  0.0
    0.0        0.0       0.0  1.0

   julia> rot_z(125.0)
   4×4 Array{Float64,2}:
    -0.573576  -0.819152  0.0  0.0
     0.819152  -0.573576  0.0  0.0
     0.0        0.0       1.0  0.0
     0.0        0.0       0.0  1.0

   julia> make_rotmat(125.0, axis_z)
   4×4 Array{Float64,2}:
    -0.573576  -0.819152  0.0  0.0
     0.819152  -0.573576  0.0  0.0
     0.0        0.0       1.0  0.0
     0.0        0.0       0.0  1.0


   # ----- Rotation around X axis ------------#
   # 
   julia> rot_x(0.0)
   4×4 Array{Float64,2}:
    1.0  0.0   0.0  0.0
    0.0  1.0  -0.0  0.0
    0.0  0.0   1.0  0.0
    0.0  0.0   0.0  1.0

   julia> make_rotmat(0.0, axis_x)
   4×4 Array{Float64,2}:
    1.0  0.0  0.0  0.0
    0.0  1.0  0.0  0.0
    0.0  0.0  1.0  0.0
    0.0  0.0  0.0  1.0


   julia> rot_x(45.0)
   4×4 Array{Float64,2}:
    1.0  0.0        0.0       0.0
    0.0  0.707107  -0.707107  0.0
    0.0  0.707107   0.707107  0.0
    0.0  0.0        0.0       1.0

   julia> make_rotmat(45.0, axis_x)
   4×4 Array{Float64,2}:
    1.0  0.0        0.0       0.0
    0.0  0.707107  -0.707107  0.0
    0.0  0.707107   0.707107  0.0
    0.0  0.0        0.0       1.0


   julia> rot_x(90.0)
   4×4 Array{Float64,2}:
    1.0  0.0   0.0  0.0
    0.0  0.0  -1.0  0.0
    0.0  1.0   0.0  0.0
    0.0  0.0   0.0  1.0

   julia> make_rotmat(90.0, axis_x)
   4×4 Array{Float64,2}:
    1.0  0.0   0.0  0.0
    0.0  0.0  -1.0  0.0
    0.0  1.0   0.0  0.0
    0.0  0.0   0.0  1.0

#+END_SRC

Test rotation quaternions: 

#+BEGIN_SRC julia 
  # Rotation around X axis 
  function rot_xx(angle::Float64) 
     C = cosd(angle)
     S = sind(angle)
     return [ 1  0  0  ; 0   C  -S   ; 0   S   C     ]
  end

  julia> va = [6.0 10.5 2.56]'
  3×1 LinearAlgebra.Adjoint{Float64,Array{Float64,2}}:
    6.0
   10.5
    2.56

  angle = 60.0 # 60 degrees 

  julia> vb_rotmat = rot_xx(angle) * va
  3×1 Array{Float64,2}:
    6.0
    3.032974966311837
   10.373266739736605

  # Rotation quaternion that represents rotation of 60 degrees around X axis.
  julia> qr = rot_quat(60.0, [1.0 0.0 0.0]')
  quatp([0.8660254037844386, 0.5, 0.0, 0.0])

  # Apply transform to vector va 
  julia> vb_qr = apply_rot(qr, va)
  3×1 Array{Float64,2}:
    6.0
    3.032974966311837
   10.373266739736607

#+END_SRC

** Library GLM - OpenGL Math 
*** Overview 

The library GLM (OpenGL math library) contains many classes and
subroutines for computer graphics computations, such as: homogeneous
coordinates; quaternios; 1D, 2D, 3D and homogeneous coordinates
vectors; vector-matrix operations and so on. Aside those facilities,
the library also provides the subroutines _glm::lookAt()_, for computing
view matrix transform, that turns world coordinates into camera
coordinates; _glm::perspective()_ - for computing the projection matrix,
that turns camera coordinates into clip-space coordinates (NDC
coordinates with range -1.0 to 1.0) and also _glm::ortho_ for computing
the orthogonal perspective matrix.

Web Site: 

  + [[https://glm.g-truc.net/0.9.9/index.html][OpenGL Mathematics]] 

Repository:

  + https://github.com/g-truc/glm


  *Type signature of most relevant GLM functions:*

#+BEGIN_SRC cpp 

   // Converts an input angle in degrees to radians. 
   // 
   //  angle_radians = angle_degrees * (PI / 180.0 )
   // 
   float glm::radians(foat  degrees);

   // ------ Basic Matrix Transformation =>> Useful for model matrix ---------------//
   glm::mat4 glm::rotate   ( glm::mat4 const & m, float angle, glm::vec3 const & axis );
   glm::mat4 glm::scale    ( glm::mat4 const & m, glm::vec3 const & factors           );
   glm::mat4 glm::translate( glm::mat4 const & m, glm::vec3 const & translation       );


   // ---- Camera and  Perspective transformation matrices -------------//
   glm::mat4 glm::lookAt( glm::vec3 const & eye, glm::vec3 const & look, glm::vec3 const & up ); 
   glm::mat4 glm::ortho( float left, float right, float bottom, float top, float near, float far );
   glm::mat4 glm::ortho( float left, float right, float bottom, float top );
   glm::mat4 glm::frustum( float left, float right, float bottom, float top, float near, float far );
   glm::mat4 glm::perspective( float fovy, float aspect, float near, float far);
#+END_SRC

 *GLM functions - transform matrix order*  

Consider the subroutine, glm::translate() - which translate a
coordinate system.

#+BEGIN_SRC 
   glm::mat4 SOURCE_MATRIX = something(); 
   glm::mat4 OUTPUT_MATRIX =  glm::translate( SOURCE_MATRIX, glm::vec3(DX, DY, DZ));
#+END_SRC

GLM computes the OUTPUT_MATRIX by performming affine matrix
multiplication in the following way. The same logic is applicable to
the subroutines: glm::rotate, glm::scale and so on.

#+BEGIN_SRC cpp
    OUTPUT_MATRIX = SOURCE_MATRIX * Translate_Transform(DX, DY, DZ)

                                    | 1  0  0  DX |
    OUTPUT_MATRIX = SOURCE_MATRIX * | 0  1  0  DY |
                                    | 0  0  0  DZ |
                                    | 0  0  0  1  |
#+END_SRC

Consider the following sequence of operations: 

#+BEGIN_SRC cpp 
    const glm::vec4 axis_Z = glm::vec3(0, 0, 1);
 
   // Reset model matrix to identity matrix 
    glm::mat4 model(1.0);

    // Move to (X, Y) position 
    // model = model * T_translate(_x, y, 0.0)
    // model = identity * T_translate(_x, y, 0.0) = T_translate(_x, y, 0.0)
    model = glm::translate( model, glm::vec3(_x, _y, 0.0)  ); 

    // Scale object (increase or decrease object size)
    // model = model * T_scale
    // model = T_translate * T_scale
    model =  glm::scale( model, glm::vec3(_scale, _scale, _scale) );

    // Rotate from a given angle around Z axis at current object X, Y  postion
    // model = model * T_rotation
    // model =  (T_translate * T_scale) * T_rot 
    model = glm::rotate( model, glm::radians(_angle),  axis_Z);
#+END_SRC

The final value of the model matrix, is product between the following
affine transforms: 

#+BEGIN_SRC text 
   model  =  Identity * T_translate * T_scale * T_rotation
   model  =  T_translate * T_scale * T_rotation
#+END_SRC

*** Testing in CERN's Root REPL  

  *Download Library Source* 

#+BEGIN_SRC sh 
   $ mkdir -p /tmp/temp && cd /temp
  
   # Download source code archive 
   $ >> curl -o glm.zip -L https://github.com/g-truc/glm/archive/master.zip

   # Extract code 
   $ >> unzip  glm.zip
 
   # Enter the in the extracted directory 
   $ >> cd glm-master/

   # List directory content 
   $ >> ls
   cmake/  CMakeLists.txt  copying.txt  doc/  glm/  manual.md  readme.md  test/  util/
#+END_SRC

 *Load the library in CERN's ROOT repl* 

#+BEGIN_SRC cpp 
    $ >> ~/Applications/root/bin/root 
   ERROR in cling::CIFactory::createCI(): cannot extract standard library include paths!
   Invoking:
     LC_ALL=C ccache  -O2 -DNDEBUG -xc++ -E -v /dev/null 2>&1 | sed -n -e '/^.include/,${' -e '/^ \/.*++/p' -e '}'
   Results was:
   With exit code 0
      ------------------------------------------------------------------
     | Welcome to ROOT 6.22/02                        https://root.cern |
     | (c) 1995-2020, The ROOT Team; conception: R. Brun, F. Rademakers |
     | Built for linuxx8664gcc on Aug 17 2020, 12:46:52                 |
     | From tags/v6-22-02@v6-22-02                                      |
     | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q'       |
      ------------------------------------------------------------------

   root [0] 

   root [0] .I . 

   root [0] .I . 
   root [1] #include <glm/glm.hpp>
   root [2] #include <glm/gtc/matrix_transform.hpp>
   root [3] #include <glm/gtc/type_ptr.hpp>
   root [4] #include <glm/gtx/string_cast.hpp>

   // Note: GLM matrices are stored in Column-major order 
   void show_matrix(const char* label, glm::mat4 const& m){
       std::cout << "\n [MATRIX] " << label << " = " << '\n';
       std::cout << std::fixed << std::setprecision(3);
       for(size_t i = 0; i < 4; i++)
       {
           for(size_t j = 0; j < 4; j++)
           {
               std::cout << std::setw(8) << m[j][i];
           }
           std::cout << '\n';
       }
   }
#+END_SRC

Define a 4x4 homogenous coordinate matrix: 

#+BEGIN_SRC cpp 
   root [18] glm::mat4 mat{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
   root [19] 
   root [19] mat
   (glm::mat4 &) @0x7f904e6c2008


   // This matrix is not in the way the user expects as it is stored in column-major order 
   // (data layout used by Fortran) and not row-major order (data layout used by C and C++).
   root [20] show_matrix("mat", mat)

    [MATRIX] mat = 
      1.000   5.000   9.000  13.000
      2.000   6.000  10.000  14.000
      3.000   7.000  11.000  15.000
      4.000   8.000  12.000  16.000
   root [21] 

   root [21] mat[0][0]
   (float) 1.00000f

   root [22] mat[0][1]
   (float) 2.00000f

   root [23] mat[0][2]
   (float) 3.00000f

   root [24] mat[0][3]
   (float) 4.00000f

   root [25] mat[3][3]
   (float) 16.0000f

   root [26] mat[2][0]
   (float) 9.00000f

   root [27] mat[2][1]
   (float) 10.0000f
#+END_SRC

Obtain transpose matrix: 

#+BEGIN_SRC cpp 
  root [28] auto tmat = glm::transpose(mat)
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2058

  root [29] show_matrix("tmat", tmat)

   [MATRIX] tmat = 
     1.000   2.000   3.000   4.000
     5.000   6.000   7.000   8.000
     9.000  10.000  11.000  12.000
    13.000  14.000  15.000  16.000

  root [33] tmat[0][0]
  (float) 1.00000f

  root [34] tmat[1][0]
  (float) 2.00000f

  root [35] tmat[2][0]
  (float) 3.00000f

  root [36] tmat[3][0]
  (float) 4.00000f


  root [37] tmat[0][0]
  (float) 1.00000f

  root [38] tmat[0][1]
  (float) 5.00000f

  root [39] tmat[0][2]
  (float) 9.00000f

  root [40] tmat[0][3]
  (float) 13.0000f
#+END_SRC

Get pointer to first element: 

#+BEGIN_SRC cpp 
  root [41] float* ptr = glm::value_ptr(tmat)
  (float *) 0x7f904e6c2058

  root [42] ptr[0]
  (float) 1.00000f

  root [43] ptr[1]
  (float) 5.00000f

  root [44] ptr[2]
  (float) 9.00000f

  root [45] ptr[3]
  (float) 13.0000f

  root [46] ptr[4]
  (float) 2.00000f

  root [47] ptr[5]
  (float) 6.00000f

  root [48] ptr[6]
  (float) 10.0000f

  root [49] ptr[7]
  (float) 14.0000f

  root [50] ptr[8]
  (float) 3.00000f
#+END_SRC

Null 4x4 matrix: 

#+BEGIN_SRC cpp 
   root [53] auto zero_4x4 = glm::mat4()
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c20e0

   root [54] show_matrix("zero_4x4", zero_4x4)

    [MATRIX] zero_4x4 = 
      0.000   0.000   0.000   0.000
      0.000   0.000   0.000   0.000
      0.000   0.000   0.000   0.000
      0.000   0.000   0.000   0.000
#+END_SRC

Identity matrix: 

#+BEGIN_SRC cpp 
  root [55] auto id_4x4 = glm::mat4(1.0)
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2120
  root [56] 
  root [56] show_matrix("id_4x4", id_4x4)

   [MATRIX] id_4x4 = 
     1.000   0.000   0.000   0.000
     0.000   1.000   0.000   0.000
     0.000   0.000   1.000   0.000
     0.000   0.000   0.000   1.000
#+END_SRC

Matrix translation coordinate transform: 

#+BEGIN_SRC cpp 
  root [58] auto t1 = glm::translate(id_4x4, glm::vec3(2.0, 10.0, 30.0))
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2160

  root [59] show_matrix("t1", t1)

   [MATRIX] t1 = 
     1.000   0.000   0.000   2.000
     0.000   1.000   0.000  10.000
     0.000   0.000   1.000  30.000
     0.000   0.000   0.000   1.000


  root [62] auto t2 = glm::translate(t1, glm::vec3(-10, 100.0, 200.0))
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c21a0

  root [63] show_matrix("t2", t2)

   [MATRIX] t2 = 
     1.000   0.000   0.000  -8.000
     0.000   1.000   0.000 110.000
     0.000   0.000   1.000 230.000
     0.000   0.000   0.000   1.000
#+END_SRC

Rotation around Z axis of 90 degrees: 

  + glm::mat4 glm::rotate(glm::mat4 const& matrix, float angle_radians, glm::vec3 const& axis)
  + Rotate around a given axis. The angle is given in radians.

#+BEGIN_SRC cpp 
  root [65] const auto axis_z = glm::vec3(0.0f, 0.0f, 1.0f);
  root [66] const auto axis_y = glm::vec3(0.0f, 1.0f, 0.0f);
  root [67] const auto axis_x = glm::vec3(1.0f, 0.0f, 0.0f);


  /*          | cos(t)  -sin(t)   0   0  |
   *          | sin(t)   cos(t)   0   0  |
   *  Rz(t) = |  0        0       1   0  |
   *          |  0        0       0   1  |
   * 
   *  
   *  t_rotZ = Rz(90) x id_4x4 = Rz(90)
   */
  root [71] auto t_rotZ = glm::rotate(id_4x4, glm::radians(90.0f), axis_z)
  (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2204

  root [72] show_matrix("t_rotZ", t_rotZ)

   [MATRIX] t_rotZ = 
    -0.000  -1.000   0.000   0.000
     1.000  -0.000   0.000   0.000
     0.000   0.000   1.000   0.000
     0.000   0.000   0.000   1.000
  root [73] 

   root [96] glm::to_string(t_rotZ)
   (std::string) "mat4x4((-0.000000, 1.000000, 0.000000, 0.000000), ... "
   root [97] 
#+END_SRC

Scaling transformation: 

#+BEGIN_SRC cpp 
   root [75] auto s1 = glm::scale(id_4x4, glm::vec3(2.0, 2.0, 2.0))
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2244

   root [76] show_matrix("s1", s1)

    [MATRIX] s1 = 
      2.000   0.000   0.000   0.000
      0.000   2.000   0.000   0.000
      0.000   0.000   2.000   0.000
      0.000   0.000   0.000   1.000

   root [78] s1 = glm::scale(s1, glm::vec3(5.0, 5.0, 5.0))
   (glm::mat &) @0x7f904e6c2244

   root [79] show_matrix("s1", s1)

    [MATRIX] s1 = 
     10.000   0.000   0.000   0.000
      0.000  10.000   0.000   0.000
      0.000   0.000  10.000   0.000
      0.000   0.000   0.000   1.000
   root [80] 

   // Apply transform to vector: 

   root [82] auto res = s1 * glm::vec4(2.0, 5.0, 10.0, 1.0)
   (glm::vec<4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2284

   root [91] glm::to_string(res)
   (std::string) "vec4(20.000000, 50.000000, 100.000000, 1.000000)"

   root [92] res[0]
   (float) 20.0000f

   root [93] res[1]
   (float) 50.0000f

   root [94] res[2]
   (float) 100.000f

   root [95] res[3]
   (float) 1.00000f
#+END_SRC

Scaling transformation: 

#+BEGIN_SRC cpp 
   root [97] auto s = glm::scale(id_4x4, glm::vec3(4.0, 5.0, 6.0))
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c22a4

   root [98] show_matrix("s", s)

    [MATRIX] s = 
      4.000   0.000   0.000   0.000
      0.000   5.000   0.000   0.000
      0.000   0.000   6.000   0.000
      0.000   0.000   0.000   1.000
   root [99] 
   root [99] s = glm::translate(s, glm::vec3(4, -5, 9))
   (glm::mat &) @0x7f904e6c22a4


   root [100] show_matrix("s", s)

    [MATRIX] s = 
      4.000   0.000   0.000  16.000
      0.000   5.000   0.000 -25.000
      0.000   0.000   6.000  54.000
      0.000   0.000   0.000   1.000
   root [101] 


   root [105] s = glm::scale(s, glm::vec3(5.0, 2.0, 3.0))
   (glm::mat &) @0x7f904e6c22a4


   root [106] show_matrix("s", s)

    [MATRIX] s = 
     25.000   0.000   0.000  20.000
      0.000   4.000   0.000 -10.000
      0.000   0.000   9.000  27.000
      0.000   0.000   0.000   1.000
#+END_SRC

Inverse matrix: 

#+BEGIN_SRC cpp 
   root [111] show_matrix("s", s)

    [MATRIX] s = 
     25.000   0.000   0.000  20.000
      0.000   4.000   0.000 -10.000
      0.000   0.000   9.000  27.000
      0.000   0.000   0.000   1.000

   root [112] inv_s = glm::inverse(s)
   (glm::mat<4, 4, float, glm::qualifier::packed_highp> &) @0x7f904e6c2324

   root [113] show_matrix("inv_s", inv_s)

    [MATRIX] inv_s = 
      0.040  -0.000   0.000  -0.800
     -0.000   0.250  -0.000   2.500
      0.000  -0.000   0.111  -3.000
     -0.000   0.000  -0.000   1.000
   root [114] 
   root [114] 

#+END_SRC
** 2D graphics - no VBO abstraction 

The following code draws a square and a triangle using the OpenGL
retained mode API. Before the rendering takes place, data must be
upload to the VBO (Vertex Buffer Object), allocated on the GPU-side,
via _glBufferData()_ call that sends the data to the previous bound VBO
through _glBindBuffer()_ call. Then, on the rendering loop and on every
frame, the buffer data layout must described with
_glVertexAttribPointer()_ before drawing via call to _glDrawArrays()_
subroutine, which draw vertices from the current bound buffer. 

Subroutines that modifies global state may cause unintended behavior,
so it is a good practice to unset the affected global state when the
current global state is no longer needed. For instance, if the current
VBO no longer needs to be bound, this global state can be disabled by
calling /glBindBuffer(GL_ARRAY_BUFFER, 0)/.


OpenGL subroutines used: 

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml][glGenBuffers()]] => Instantiate a buffer object. 

#+BEGIN_SRC cpp 
  void glGenBuffers(GLsizei n, GLuint* buffers);
#+END_SRC

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml][glBindBuffer()]] => Bind some buffer object, a.k.a enable, only one
   buffer can be bound at a time. (The VBO is a global state). 

#+BEGIN_SRC cpp 
  void glBindBuffer(GLenum target,nt buffer);
#+END_SRC

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml][glBufferData()]]  =>> Send data to current bound buffer object that
   was bound via glBindBuffer() call. 

#+BEGIN_SRC cpp 
  void glBufferData( GLenum      target,
                     GLsizeiptr  size,
                     const void* data,
                     GLenum      usage
                     );
#+END_SRC

  + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml][glEnableVertexAttribArray()]] 

#+BEGIN_SRC cpp 
  void glEnableVertexAttribArray(GLuint index);
#+END_SRC

 + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml][glVertexAttribPointer()]]
   + Describes the data layout of current bound buffer. 

#+BEGIN_SRC cpp 
     void glVertexAttribPointer( GLuint      index,
                                 GLint       size,
                                 GLenum      type,
                                 GLboolean   normalized,
                                 GLsizei     stride,
                                 const void* pointer);
#+END_SRC

  + [[https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml][glDrawArrays()]] => Render OpenGL primitives from current bound
    buffer object's data. Those primitives are: lines, triangles or
    quads and so on.  

#+BEGIN_SRC cpp 
  void glDrawArrays(GLenum mode, GLint first, GLsizei count);
#+END_SRC


  *Screenshot* 

[[file:images/opengl-draw2d-raw.png][file:images/opengl-draw2d-raw.png]]

  *Source Code* 

File: _CMakeLists.txt_ 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.5)
  project(GLFW_project)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #================ GLFW Settings  ===============#

  find_package(OpenGL REQUIRED)

  include(FetchContent)

  # Set GLFW Options before FectchContent_MakeAvailable 
  set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

  # Donwload GLFW library
  FetchContent_Declare(
    glfwlib
    URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
  )
  FetchContent_MakeAvailable(glfwlib)

         add_executable( draw2d-raw  draw2d-raw.cpp )
  target_link_libraries( draw2d-raw  glfw OpenGL::GL GLU)
#+END_SRC

File: _draw2d-raw.cpp_ 

#+BEGIN_SRC cpp 
  // Draw curve mapping buffer to the GPU.
  #include <iostream>
  #include <vector> 
  #include <array>
  #include <cmath>
  #include <cassert>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>
  #include <GL/glut.h>


  struct Vertex2D
  {
      GLfloat x;
      GLfloat y;
  };

  int main(int argc, char** argv)
  {
      GLFWwindow* window;

      /* Initialize the library */
      if (!glfwInit())
          return -1;

      glutInit(&argc, argv);

      /* Create a windowed mode window and its OpenGL context */
      window = glfwCreateWindow(640, 480, "2D Drawing raw VBO buffers", NULL, NULL);
      if (!window)
      {
          glfwTerminate();
          return -1;
      }

      /* Make the window's context current */
      glfwMakeContextCurrent(window);
      // glClearColor(0.0f, 0.5f, 0.6f, 1.0f);
      glClearColor(0.0f, 0.0f, 0.0, 1.0f);


      Vertex2D triangle_points[3] = {
          Vertex2D{-0.25,   -0.25}
        , Vertex2D{ 0.00,   0.25}
        , Vertex2D{ 0.25,  -0.25}
      };

      Vertex2D square_points[4] = {
          { -0.3,  -0.3 }
        , { -0.3,   0.3 }
        , {  0.3,   0.3 }
        , {  0.3,  -0.3 }
      };

      // ================== Triangle Buffer ====================//
      //

      GLuint vbo_triangle_ = 0;
    
      // Create an OpenGL VBO buffer 
      // =>> void glGenBuffers (GLsizei n, GLuint *buffers);
      glGenBuffers(  1                // Number of buffers that will be instantiated
                   , &vbo_triangle_   // Address of first element or address of array 
                                      // that results will be written to.
                   );
      assert( vbo_triangle_ != 0 );

      // Set this buffer as the current buffer - Only one buffer can be bound at a time. 
      // =>> void glBindBuffer (GLenum target, GLuint buffer)
      glBindBuffer(GL_ARRAY_BUFFER, vbo_triangle_);

      // Upload data to current VBO buffer in GPU 
      glBufferData(GL_ARRAY_BUFFER, sizeof(triangle_points), triangle_points, GL_STATIC_DRAW);   

      // Unbind current buffer in order to avoid unintended behaviors
      // as the subroutine glBindBuffer() modifies has a global state.
      glBindBuffer(GL_ARRAY_BUFFER, 0);

      // ================ Square / Vertex Buffer Object 2 ==================//
      //      

      GLuint vbo_square_ = 0;
      // Instiate buffer - gets a handle or token for 
      // a buffer allocated on GPU-side.
      glGenBuffers(1, &vbo_square_);
      // Check for error 
      assert( vbo_square_ != 0);
      // Bind Current buffer (Affects global state)
      glBindBuffer(GL_ARRAY_BUFFER, vbo_square_);
      // Upload data to the GPU 
      glBufferData(GL_ARRAY_BUFFER, sizeof(square_points), square_points, GL_STATIC_DRAW);   
      // Unbind buffer 
      glBindBuffer(GL_ARRAY_BUFFER, 0);

      GLint shader_attr = 0;

      //  ======= R E N D E R  - L O O P ============//
      //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//

              // ------------ Draw triangle --------------//
              //
              glBindBuffer(GL_ARRAY_BUFFER, vbo_triangle_);
              glEnableVertexAttribArray(shader_attr);

              // Describe buffer data layout (binary layout)
              // =>> glVertexAttribPointer ( GLuint index, GLint size, GLenum type
              //                           , GLboolean normalized, GLsizei stride, const void *pointer);
              //
              glVertexAttribPointer(shader_attr // GLint  index         => Shader attribute location, 0 for now 
                                  , 2           // GLint  size          => 2 components (X, Y) of type GLfloat
                                  , GL_FLOAT    // GLemum type          => Type of each component  
                                  , GL_FALSE    // GLboolean normalized  
                                  , 0           // GLsizei stride
                                  , nullptr     // const void* pointer 
                                  );
              // Draw arrays using the content of buffer 
              // Plot 1 triangle (each triangle has 3 vertices)
              glDrawArrays(GL_TRIANGLES, 0, 3);

              // Disable global state 
              glBindBuffer(GL_ARRAY_BUFFER, 0);
              glDisableVertexAttribArray(0);
            
              //------------ Draw Square -------------------------//
              //
            
              #if 1
              glBindBuffer(GL_ARRAY_BUFFER, vbo_square_);
              glEnableVertexAttribArray(shader_attr);
              glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);
              // Plot 4 vertices 
              glDrawArrays(GL_LINE_LOOP, 0, 4);

              // Disable global state 
              glBindBuffer(GL_ARRAY_BUFFER, 0);
              glDisableVertexAttribArray(shader_attr);            
              #endif 

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwPollEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }
      }

      glfwTerminate();
      return 0;
  }
#+END_SRC

** 2D graphics - using VBO abstraction

This sample code draws a square, triangle and a chart using 2D
coordinates and ignoring the Z axis. 

Unlike legacy OpenGL (fixed-pipeline) that requires the calling code
to call primitive rendering subroutines on every frame, which has a
significant overhead, Modern OpenGL or retained-mode, uses buffer
objects for storing data on the GPU memory and shaders, programs that
runs on the GPU-side for processing vertexes and colors. The following
code uses _VertexBufferObject_ class for encapsulating VBO - Vertex
Buffer Objects. The challenging of dealing with VBOs is that, many of
subroutines applicable to VBO modify global state or assume that some
global state should be set before calling the subroutine. The effect
of calling the many OpenGL subroutines depends on the state and the
order that they were called.

The code was tested on Ubuntu Linux 64 bits. On Windows, it requires
GLEW for loading OpenGL function pointers. 

 *Screenshot:*

#+CAPTION: OpenGL simple 2D redering with VBO. 
[[file:images/opengl-draw2d.png][file:images/opengl-draw2d.png]]


 *Source Code* 


File: _CMakeLists.txt_ 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.5)
  project(draw2d)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_CXX_STANDARD_REQUIRED ON)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #================ GLFW Settings  ===============#

  find_package(OpenGL REQUIRED)

  include(FetchContent)

  # Set GLFW Options before FectchContent_MakeAvailable 
  set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
  set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

  # Donwload GLFW library
  FetchContent_Declare(
    glfwlib
    URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
  )
  FetchContent_MakeAvailable(glfwlib)

         add_executable( draw2d  draw2d.cpp )
  target_link_libraries( draw2d  glfw OpenGL::GL GLU)
#+END_SRC

File: _draw2d.cpp_ 

#+BEGIN_SRC cpp 
  // Draw curve mapping buffer to the GPU.
  #include <iostream>
  #include <vector> 
  #include <array>
  #include <cmath>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>
  #include <GL/glut.h>

  // Makes a class non copiable. 
  // Auomates the boilerplate code for 
  // declaring a class as non-copiable 
  #define CL_NON_COPIABLE( className )                  \
      public:                                           \
      className( className const&) = delete;            \
      className& operator= (className const&) = delete; \
      private:


  // Class for encapsulating VBO - Vertex-Buffer Objects 
  class VertexBufferObject
  {
      // Handle for Vertex-Buffer Object (Allocated on GPU memory)
      GLuint  m_vbo = 0;
      // Shader attribute location variable 
      GLuint m_attr_location;

      // Type of single component 
      GLenum  m_type;
      // Number of elements m_type of single component 
      GLsizei m_size;    

      CL_NON_COPIABLE(VertexBufferObject)
  public:

      VertexBufferObject(GLuint shader_attr_loc = 0)
      { 
          m_attr_location = shader_attr_loc;
          ::glGenBuffers(1, &m_vbo);  

          // --- Buffer Object Data Layout parameters ------//
          //
          // Type of single component 
          GLenum  m_type;
          // Number of elements m_type of single component 
          GLsizei m_size;        
      }

      // Destructor 
      ~VertexBufferObject(){ this->dispose();  }

      GLuint id() const { return m_vbo; }

      // Delete current buffer when no longer in use 
      void dispose() 
      {
          ::glDeleteBuffers(1, &m_vbo);
          m_vbo = 0;
      }

      // Make this buffer active only one buffer can be active at a time.
      void bind() 
      { 
          glBindBuffer(GL_ARRAY_BUFFER, m_vbo); 
          glEnableVertexAttribArray(m_attr_location);
       }

      // Unbind current buffer in order to avoid unintended behavior 
      // due to the global state. 
      void unbind() 
      { 
          glBindBuffer(GL_ARRAY_BUFFER, 0); 
          glDisableVertexAttribArray(m_attr_location);
      }

      // Upload data to GPU - the data is often an array of POD types 
      // POD (Plain-Old-Data) - any contiguous data without any internal pointer.
      void send_data(void* pData, GLsizeiptr size)
      {
          this->bind();    
          glBufferData(GL_ARRAY_BUFFER, size, pData, GL_STATIC_DRAW);
          this->unbind();
      }

      // Map buffer to GPU memory. This method allows sending data directly 
      // to the VBO by writing to the returned pointer.
      // 
      // @param size - Byte amount of memory allocated on the GPU-side.
      void* map_buffer(GLsizeiptr size)
      {
          this->bind();
          // Just reserver data, do not copy vertex points to GPU memory. 
          glBufferData(GL_ARRAY_BUFFER, size, nullptr, GL_STATIC_DRAW);   
          // Obtain pointer to buffer mapped to GPU memory.
          void* ptr = glMapBuffer( GL_ARRAY_BUFFER, GL_WRITE_ONLY );
          this->unbind();
          return ptr;
      }

      template<typename T>
      T* map_buffer_t(GLsizeiptr size)
      { 
          return reinterpret_cast<T*>(this->map_buffer(size));
      }

      // Note: It is assumed that shader program is bound before 
      // calling this function. 
      //
      // shader_attr_location => Is attribute location of the Vertex Shader
      // that will process the vertices.
      void set_data_layout( GLenum type, GLint size) 
      {
          m_type = type; 
          m_size = size;
      }

      void draw_arrays(GLenum draw_type, GLuint count)
      {
          this->bind();
          // Describe data layout - binary format.
          glVertexAttribPointer( m_attr_location, m_size, m_type, GL_FALSE, 0, nullptr);
          // Performs drawing 
          glDrawArrays( draw_type, 0, count);
          this->unbind();
      }
  };

  struct Vertex2D
  {
      GLfloat x;
      GLfloat y;
  };

  int main(int argc, char** argv)
  {
      GLFWwindow* window;

      /* Initialize the library */
      if (!glfwInit())
          return -1;

      glutInit(&argc, argv);

      /* Create a windowed mode window and its OpenGL context */
      window = glfwCreateWindow(640, 480, "Sample 2D Drawing", NULL, NULL);
      if (!window)
      {
          glfwTerminate();
          return -1;
      }

      /* Make the window's context current */
      glfwMakeContextCurrent(window);
      // glClearColor(0.0f, 0.5f, 0.6f, 1.0f);
      glClearColor(0.0f, 0.0f, 0.0, 1.0f);

      constexpr size_t NPOINTS = 2000;

      //------------- Vertex Buffer Object 1 -----------//
      // => Note: anything vertex should be within the range -1.0 to 1.0 

      VertexBufferObject vbo_chart{};
      // Describe layout.
      // Each vertex has 2 components (X, Y) of type GL_FLOAT 
      vbo_chart.set_data_layout(GL_FLOAT, 2);

      Vertex2D* chart = vbo_chart.map_buffer_t<Vertex2D>( NPOINTS * sizeof(Vertex2D) );

      float x = 0.0;

      //  Write data directly on GPU memory without copying any 
      //  pre-allocated buffer on main-memory.
      for(size_t k = 0; k < NPOINTS; k++)
      {
          x = (k - 1000.0) / 100.0;
          chart[k].x = x;
          chart[k].y = sin(x * 10.0) / (1.0 + x * x);
      }

      // ------------- Triangle / Vertex Buffer Object 2 ------------//
      //      
    
      Vertex2D triangle_points[3] = {
          Vertex2D{-0.25,   -0.25 }
        , Vertex2D{ 0.00,    0.25 }
        , Vertex2D{ 0.25,   -0.25 }
      };

      VertexBufferObject vbo_triangle{};
      // Each vertex has 2 coordinates of type GL_FLOAT 
      vbo_triangle.set_data_layout(GL_FLOAT, 2);
      // Upload data to GPU 
      vbo_triangle.send_data(triangle_points, sizeof(triangle_points));


      // ---------- Square / Vertex Buffer Object 2 ------------//
      //      
    
      Vertex2D square_points[4] = {
          { -0.3,  -0.3 }
        , { -0.3,   0.3 }
        , {  0.3,   0.3 }
        , {  0.3,  -0.3 }
      };

      auto vbo_square = VertexBufferObject{};
      vbo_square.set_data_layout(GL_FLOAT, 2);
      // Upload data to GPU 
      vbo_square.send_data(square_points, sizeof(square_points));


      //  ======= R E N D E R  - L O O P ============//
      //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//
        
          vbo_chart.draw_arrays(GL_LINE_STRIP, NPOINTS);
          vbo_triangle.draw_arrays(GL_TRIANGLES, 3);
          vbo_square.draw_arrays(GL_LINE_LOOP, 4);

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwPollEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }
      }

      glfwTerminate();
      return 0;
  }
#+END_SRC
** 2D graphics - using VAO 

A VAO (Vertex Array Object) is an object that stores all the
information necessary to render a VBO (Vertex Buffer Object). For
instance, a VAO allows rendering the data, by performing the following
set of operations only once: 1 - binding the VAO; 2 - binding the
buffer via glBindBuffer() call; 3 - enabling the vertex attribute via
glEnableVertexAttribArray(); 4 - setting the data layout by calling
glVertexAttribPointer() subroutine. Without a VAO, all those
subroutines would need to be called on every frame rendering.

Algorithm for VAO usage: 

 + Setup 

#+BEGIN_SRC cpp 
   // Shader attribute location 
   GLint shader_attr = 1;

   // -------------- Setup VAO --------------------// 
   // 
   GLuint vao;
   glGenVertexArrays(1, &vao); // Instantiate VAO 

   GLuint vbo;
   glGenBuffers(1, &vbo);              
   // Bind VBO (Recorded by VAO)
   glBindBuffer(GL_ARRAY_BUFFER, vbo); 

   // Upload data to GPU 
   glBufferData(GL_ARRAY_BUFFER, buffer_size, buffer, GL_STATIC_DRAW);  

   glEnableVertexAttribArray(shader_attr);

   // Set buffer data layout (Recorded by VAO)
   glVertexAttribPointer(shader_attr, size, type, GL_FALSE, 0, nullptr);    

   // ------- Disable Global state ---------// 

   // Unbind VAO 
   glBindVertexArray(0);
   // Unbind VBO 
   glBindBuffer(GL_ARRAY_BUFFER, vbo);
   // Disable current shader attribute 
   glDisableVertexAttribArray(shader_attr);
#+END_SRC

 + Rendering loop 

#+BEGIN_SRC cpp 
         ... ...         ... ...         ... ...
         ... ...         ... ...         ... ...      

    //  ======= R E N D E R  - L O O P ============//
    //                                             //
    while ( !glfwWindowShouldClose(window) )
    {
        glClear(GL_COLOR_BUFFER_BIT);
         ... ...         ... ...         ... ...
         ... ...         ... ...         ... ...

         glBindVertexArray(vao);
         glDrawArrays(GL_LINE_LOOP, 0, NUMBER_OF_VERTICES);

         glBindVertexArray(vao1);
         glDrawArrays(GL_LINE_TRIANGLES, 0, NUMBER_OF_VERTICES_1);

         glBindVertexArray(vao2);
         glDrawArrays(GL_LINES, 0, NUMBER_OF_VERTICES_2);

         ... ...         ... ...         ... ...
         ... ...         ... ...         ... ...

        /* Swap front and back buffers */
        glfwSwapBuffers(window);
        /* Poll for and process events */
        glfwPollEvents();
    }
#+END_SRC


 *Further Reading* 

  + [[https://www.khronos.org/opengl/wiki/Tutorial2:_VAOs,_VBOs,_Vertex_and_Fragment_Shaders_(C_/_SDL)][Tutorial2: VAOs, VBOs, Vertex and Fragment Shaders (C / SDL) - OpenGL Wiki]]

  + [[https://android-developers.googleblog.com/2015/10/game-performance-vertex-array-objects.html][Android Developers Blog: Game Performance: Vertex Array Objects]]

  + [[https://android-developers.googleblog.com/2015/03/today-we-want-to-share-some-best.html][Android Developers Blog: Game Performance: Layout Qualifiers]]

  + [[https://stackoverflow.com/questions/28270954/process-of-setting-up-a-vao-in-opengl][c++ - Process of setting up a VAO in OpenGL - Stack Overflow]]

  + [[https://stackoverflow.com/questions/8923174/opengl-vao-best-practices][OpenGL VAO best practices - Stack Overflow]]

  + [[https://computergraphics.stackexchange.com/questions/5895/what-is-an-opengl-vao-in-a-nutshell][vertex buffer object - What is an OpenGL VAO in a nutshell?]]  -
    Computer Graphics Stack Exchange 

  + [[https://gamedev.stackexchange.com/questions/92832/in-opengl-whats-quicker-lots-of-smaller-vaos-or-one-large-one-updated-each-fr][performance - In OpenGL what's quicker]] - , lots of smaller VAOs,
    or one large one updated each frame? - Game Development Stack
    Exchange.

  + [[https://stackoverflow.com/questions/18485381/opengl-how-many-vaos][OpenGL How Many VAOs - Stack Overflow]] 

 
  *Screenshot* 

#+CAPTION: 2D OpenGL draw using VAO - Vertex Array Object 
[[file:images/opengl-draw2-vao.png][file:images/opengl-draw2-vao.png]]
 
  *Sample Code* 

File: CMakeLists.txt 

#+BEGIN_SRC cmake 
    cmake_minimum_required(VERSION 3.5)
    project(draw2d)

    set(CMAKE_CXX_STANDARD 17)
    set(CMAKE_CXX_STANDARD_REQUIRED ON)
    set(CMAKE_VERBOSE_MAKEFILE ON)

    #================ GLFW Settings  ===============#

    find_package(OpenGL REQUIRED)

    include(FetchContent)

    # Set GLFW Options before FectchContent_MakeAvailable 
    set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
    set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
    set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
    set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

    # Donwload GLFW library
    FetchContent_Declare(
      glfwlib
      URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
    )
    FetchContent_MakeAvailable(glfwlib)

           add_executable( draw2d-vao  draw2d-vao.cpp )
    target_link_libraries( draw2d-vao  glfw OpenGL::GL GLU)
#+END_SRC

File: _draw2d-vao.cpp_ 

#+BEGIN_SRC cpp 
  // Draw curve mapping buffer to the GPU.
  #include <iostream>
  #include <vector> 
  #include <array>
  #include <cmath>
  #include <cassert>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>
  #include <GL/glut.h>


  struct Vertex2D
  {
      GLfloat x;
      GLfloat y;
  };

  // Upload buffer from main memory to GPU VBO 
  // =>> Parameters VAO, VBO are allocated by the caller. 
  void send_buffer(   GLuint* pVao        // Pointer to VAO (Vertex Array Object) - allocated by caller 
                    , GLuint* pVbo        // Pointer to VBO (Vertex Buffer Object) - allocated by caller
                    , GLsizei sizeBuffer  // Total buffer size in bytes
                    , void*   pBufffer    // Pointer to buffer 
                    , GLint   shader_attr // Shader attribute location 
                    , GLint   size        // Number of coordinates of a given vertex                  
                    , GLenum  type        // Type of each element coordinate 
                    );

  void* map_buffer( GLuint* pVao         // Pointer to VAO - allocated by calling code.
                  , GLuint* pVbo         // Pointer to VBO - allocated by calling code.
                  , GLsizei data_size    // Total size in bytes that is allocated to buffer 
                  , GLint   shader_attr  // Shadder attribute location id (0 - zero) is there is no shader.
                  , GLint   size         // Number of component of each vertex 
                  , GLenum  type         // Type of each vertex element 
                  );


  int main(int argc, char** argv)
  {
      GLFWwindow* window;

      /* Initialize the library */
      if (!glfwInit())
          return -1;

      glutInit(&argc, argv);

      /* Create a windowed mode window and its OpenGL context */
      window = glfwCreateWindow(640, 480, "2D Drawing using VAO", NULL, NULL);
      if (!window)
      {
          glfwTerminate();
          return -1;
      }

      /* Make the window's context current */
      glfwMakeContextCurrent(window);
      // glClearColor(0.0f, 0.5f, 0.6f, 1.0f);
      glClearColor(0.0f, 0.0f, 0.0, 1.0f);

      // Shader attribute location (default 0)
      GLint shader_attr = 0;

    
      // ================ Square / Vertex Buffer Object 2 ==================//
      //      

      Vertex2D square_points[4] = {
          { -0.3,  -0.3 }
        , { -0.3,   0.3 }
        , {  0.3,   0.3 }
        , {  0.3,  -0.3 }
      };

      GLuint vao_square = 0; 
      GLuint vbo_square = 0;

      // Upload square_points buffer data to GPU 
      send_buffer( &vao_square, &vbo_square, sizeof(square_points)
                  , square_points, shader_attr, 2, GL_FLOAT );
    
      assert( vao_square != 0 );
      assert( vbo_square != 0 );    
    
      std::fprintf( stderr, " [TRACE] vao_square = %d, vbo_square = %d \n"
                   , vao_square, vbo_square);


      // ============== Circle / Vertex Buffer Object 3 ==================//
      //      
      GLuint vao_circle = 0; 
      GLuint vbo_circle = 0;
    
      // Number of vertices to used to render the circle. 
      constexpr size_t N_CIRCLE = 100;
      constexpr float  PI       = 3.1415927;
      const     float  radius   = 0.75;

      // C-style cast should not be used here 
      Vertex2D* pCursor = (Vertex2D*) map_buffer( &vao_circle, &vbo_circle, N_CIRCLE * sizeof(Vertex2D)
                                                , shader_attr, 2, GL_FLOAT );

      float angle = 0.0;
      const float step = 2 * PI / N_CIRCLE;

      for(size_t n = 0; n < N_CIRCLE; n++)
      {
          pCursor[n].x = radius * cosf( angle );
          pCursor[n].y = radius * sinf( angle );
          angle = angle + step;
      }
 

      //  ======= R E N D E R  - L O O P ============//
      //                                             //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//

              //------------ Draw Square -------------------------//
              //            
               glBindVertexArray(vao_square);
              // Plot 4 vertices 
              glDrawArrays(GL_LINE_LOOP, 0, 4);
              // Unbind vao (restore global state to default value)
              glBindVertexArray(0);

              //------------ Draw Circle -------------------------//
              //            
              glBindVertexArray(vao_circle);
              glDrawArrays(GL_LINE_LOOP, 0, N_CIRCLE);
              glBindVertexArray(0);

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwPollEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }
      }

      // ---------- Dispose Buffer Objects ---------// 
      glDeleteBuffers(1, &vbo_square);
      glDeleteBuffers(1, &vbo_circle);

      glfwTerminate();
      return 0;
  }

  // ---------- I M P L E M E N T A T I O N S ------------------// 
  //                                                            // 

  // Upload buffer from main memory to GPU VBO 
  // =>> Parameters VAO, VBO are allocated by the caller. 
  void send_buffer(   GLuint* pVao        // Pointer to VAO (Vertex Array Object) - allocated by caller 
                    , GLuint* pVbo        // Pointer to VBO (Vertex Buffer Object) - allocated by caller
                    , GLsizei sizeBuffer  // Total buffer size in bytes
                    , void*   pBufffer    // Pointer to buffer 
                    , GLint   shader_attr // Shader attribute location id 
                    , GLint   size        // Number of coordinates of a given vertex
                    , GLenum  type        // Type of each element coordinate                   
                    )
  {
      assert(pVao != nullptr);
      assert(pVbo != nullptr);
      GLuint& vao = *pVao;
      GLuint& vbo = *pVbo;

      // Generate and bind current VAO (Vertex Array Object)
      glGenVertexArrays(1, &vao);
      glBindVertexArray(vao);

      // Generate and bind current VBO (Vertex Buffer Object)
      glGenBuffers(1, &vbo);
      glBindBuffer(GL_ARRAY_BUFFER, vbo);

      // Upload data to current VBO buffer in GPU 
      glBufferData(GL_ARRAY_BUFFER, sizeBuffer, pBufffer, GL_STATIC_DRAW);   

      glEnableVertexAttribArray(shader_attr);
    
      // Set data layout - how data will be interpreted.
      glVertexAttribPointer(shader_attr, size, type, GL_FALSE, 0, nullptr);

      // ------ Disable Global state set by this function -----//
      // 
      // Unbind VAO 
      glBindVertexArray(0);
      // Unbind VBO 
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Disable current shader attribute 
      glDisableVertexAttribArray(shader_attr);

  }

  void* map_buffer( GLuint* pVao         // Pointer to VAO - allocated by calling code.
                  , GLuint* pVbo         // Pointer to VBO - allocated by calling code.
                  , GLsizei data_size    // Total size in bytes that is allocated to buffer 
                  , GLint   shader_attr  // Shadder attribute location id (0 - zero) is there is no shader.
                  , GLint   size         // Number of component of each vertex 
                  , GLenum  type         // Type of each vertex element 
                  )
  {
      GLuint& vao = *pVao;
      GLuint& vbo = *pVbo;

      // Generate and bind current VAO (Vertex Array Object)
      glGenVertexArrays(1, &vao);
      glBindVertexArray(vao);

      // Generate and bind current VBO (Vertex Buffer Object)
      glGenBuffers(1, &vbo);
      glBindBuffer(GL_ARRAY_BUFFER, vbo);

      /** See: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml
       ,*  Khronos Group: "glMapBuffer and glMapNamedBuffer map the entire data store of 
       ,*  a specified buffer object into the client's address space. The data can then be directly 
       ,*  read and/or written relative to the returned pointer, 
       ,*  depending on the specified access policy."
       ,*/
      glBufferData(GL_ARRAY_BUFFER, data_size, nullptr, GL_STATIC_DRAW);   
      void* pbuffer = glMapBuffer( GL_ARRAY_BUFFER, GL_WRITE_ONLY );

      glEnableVertexAttribArray(shader_attr);
      // Set data layout - how data will be interpreted.
      glVertexAttribPointer(shader_attr, size, type, GL_FALSE, 0, nullptr);    

      // ------ Disable Global state set by this function -----//
      // 
      // Unbind VAO 
      glBindVertexArray(0);
      // Unbind VBO 
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Disable current shader attribute 
      glDisableVertexAttribArray(shader_attr);

      // ------- Return --------------------------------------//
      return pbuffer;
  }
#+END_SRC
** 2D graphics - using shaders

OpenGL retained mode (programmable pipeline) uses shaders, which are
programs that uses GLSL (OpenGL shading language) programming
language, runs on the GPU (Graphics Processing Unit). A vertex shader
performs vertex coordinate transformations on all vertices and colors
received from VBO - Vertex Buffer Objects. The fragment shader runs
after the vertex shader and deals with vertice texture and color
computations.

A vertex shader has the following features: 

 + Data types:
   + float => Float IEEE754 32 bits floating point scalar. 
   + vec2 => Vector of 2 coordinates
   + vec3 => Vector of 3 coordinates 
   + vec4 => Vector of 4 coordinates 
   + mat2 => 2x2 matrix 
   + mat4 => 4x4 homogeneous coordinate matrix
   + mat3 => 3x3 matrix

 + _uniform variables_ => Shader variables declared with _uniform_ storage
   qualifier. They allow passing data, such as transformation
   matrices, vectors or scalar values, from the C++-side to the shader
   program. Uniform variables can be used for passing the model matrix,
   camera matrix and projection matrix to the shader.
   * Declaration example: 'uniform mat4 u_model;' 

 + _attribute variables_ => Used for passing vertices or color
   coordinates from VBOs (Vertex Buffer Objects). Those variables are
   only accessible in the shader.
   * Declaration example: 'layout ( location = 2)  in vec2 position;'

 + _Output_ => Shader programs uses pre-defined global variables for
   output, for instance, _gl_Position_, which sets the current vertex
   position in clip-space (NDC - Normalized Device Coordinates). 



 *Documentation*

  + [[https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)][Core Language (GLSL) - OpenGL Wiki]] / Khronos Group.
    + Syntax of GLSL (OpenGL shading language)

  + [[https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)][Data Type (GLSL) - OpenGL Wiki]] / Khronos Group

  + [[https://en.wikipedia.org/wiki/OpenGL_Shading_Language][OpenGL Shading Language - Wikipedia]]

  + [[https://www.khronos.org/opengl/wiki/Shader][Shader - OpenGL Wiki]] / Khronos Group

  + [[https://www.khronos.org/opengl/wiki/Vertex_Shader][Vertex Shader - OpenGL Wiki]] / Khronos Group

  + [[https://www.khronos.org/opengl/wiki/Fragment_Shader][Fragment Shader - OpenGL Wiki]] / Khronos Group

  + [[https://www.khronos.org/opengl/wiki/Uniform_(GLSL)][Uniform (GLSL) - OpenGL Wiki]] / Khronos Group
    + Discusses shader uniform variables.

  + [[https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)][Layout Qualifier (GLSL) - OpenGL Wiki]] / Khronos Group
    + Shader attribute index (attribute location)

  + [[https://www.khronos.org/opengl/wiki/Geometry_Shader][Geometry Shader - OpenGL Wiki]] / Khronos Group.

  + [[https://www.khronos.org/opengl/wiki/Shader_Compilation][Shader Compilation - OpenGL Wiki]] / Khronos Group.

  + [[https://www.khronos.org/opengl/wiki/Vertex_Rendering][Vertex Rendering - OpenGL Wiki]]

  + [[https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Data][Data in WebGL - Web APIs | MDN]] / Mozilla 
    + Explanation of shader's attribute variables and shader's uniform
      variables. 

  *Source Code*  

Summary:

 + This sample application, draws many 4 triangles from a 2 VBO
   (Vertex Buffer Object) and a single VAO (Vertex Array Object). The
   application uses a vertex shader for performing coordinate
   transformation for every triangle and drawing them at different
   position with different rotation angles around Z axis. The triangle
   'triangleD' follows the mouse position while the triangle
   'triangleB' rotates acoording to the mouse position.

 + The vertex shader has two attributes variables ('position' and
   'color') and two uniform variables u_model, that contains the model
   matrix from every rendered object, and u_projection, which contains
   the projection matrix. 

Screenshot: 

[[file:images/opengl-draw2d-shader.png][file:images/opengl-draw2d-shader.png]]


_Vertex Shader_ - Source Code (Extraced from _draw2d-shader.cpp_)

#+BEGIN_SRC cpp 
    #version 330 core 

    // Supplied by GPU - attribute location (id = 2) 
    // contains a (X, Y) vertex
    layout ( location = 2)  in vec2 position;
    layout ( location = 1 ) in vec3 color;     // Contains (Red, Green, Blue) components

    // Output to fragment shader 
    out vec3 out_color;

    // Model matrix => projection coordinates from the local space (model space)
    // to view space .
    // Transform 4x4 matrix - supplied by the C++ side. 
    uniform mat4 u_model;

    // Projection matrix => projections camera-space coordinates 
    // to clip-space coordinates. (-1.0 to 1.0) range.
    uniform mat4 u_projection;

    void main()
    {
        // gl_Position => Global output variable that holds the 
        // the current vertex position. It is a vector of 
        // components (X, Y, Z = 0, W = ignored)
        gl_Position = u_projection * u_model * vec4(position, 0, 1.0);

        // Forward to fragment shader 
        out_color = color;
    }
#+END_SRC

_Fragment Shader_ -  Source Code (Extracted from _draw2d-shader.cpp_)


#+BEGIN_SRC cpp 
   #version 330 

   // This color comes from Vertex shader 
   in vec3 out_color;

   void main()
   {
       // Set vertex colors
       gl_FragColor = vec4(out_color, 1.0);

   }
#+END_SRC

File: _CMakeLists.txt_

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.5)
   project(GLFW_project)

   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   set(CMAKE_VERBOSE_MAKEFILE ON)

   #================ GLFW Settings  ===============#

   find_package(OpenGL REQUIRED)

   include(FetchContent)

   # Set GLFW Options before FectchContent_MakeAvailable 
   set( GLFW_BUILD_EXAMPLES OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_TESTS    OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_DOCS     OFF CACHE BOOL  "GLFW lib only" )
   set( GLFW_BUILD_INSTALL  OFF CACHE BOOL  "GLFW lib only" )

   # Donwload GLFW library
   FetchContent_Declare(
     glfwlib
     URL   https://github.com/glfw/glfw/releases/download/3.3.2/glfw-3.3.2.zip
   )
   FetchContent_MakeAvailable(glfwlib)

   # Download GLM (OpenGL math library for matrix and vectors transformation)
   FetchContent_Declare(
     glm  
     URL  https://github.com/g-truc/glm/archive/0.9.8.zip
   )
   FetchContent_MakeAvailable(glm)

   message( [DEBUG] " glm_SOURCE_DIR = ${glm_SOURCE_DIR} ")
   include_directories(${glm_SOURCE_DIR})

     # ======= TARGETS ===========================#

          add_executable( draw2d-shader  draw2d-shader.cpp   )
   target_link_libraries( draw2d-shader  glfw OpenGL::GL GLU )
#+END_SRC

File: _draw2d-shader.cpp_ 

#+BEGIN_SRC cpp 
  // Draw many colored triangles from a single VBO (Vertex Buffer Object)
  #include <iostream>
  #include <vector> 
  #include <array>
  #include <cmath>
  #include <functional>

  // -------- OpenGL headers ---------//
  //
  #define GL_GLEXT_PROTOTYPES 1 // Necessary for OpenGL >= 3.0 functions
  #define GL3_PROTOTYPES      1 // Necessary for OpenGL >= 3.0 functions

  #include <GL/gl.h>
  #include <GLFW/glfw3.h>

  // #include <GL/glew.h>
  #include <GL/glu.h>

  // --------- OpenGL Math Librar ------------//
  #include <glm/glm.hpp>
  #include <glm/gtc/matrix_transform.hpp>
  #include <glm/gtc/type_ptr.hpp>
  #include <glm/gtx/string_cast.hpp>


  // Compile some  shader 
  void compile_shader(GLuint m_program, const char* code, GLenum type);

  // Send data from memory to GPU VBO memory 
  void send_buffer(   GLuint* pVao        // Pointer to VAO (Vertex Array Object) - allocated by caller 
                    , GLuint* pVbo        // Pointer to VBO (Vertex Buffer Object) - allocated by caller
                    , GLsizei sizeBuffer  // Total buffer size in bytes
                    , void*   pBufffer    // Pointer to buffer 
                    , GLint   shader_attr // Shader attribute location id 
                    , GLint   size        // Number of coordinates of a given vertex
                    , GLenum  type        // Type of each element coordinate                   
                    );

  // ------------ Basic Data Structures -----------// 

  // Wrapper for 2D vertex coordinates 
  struct Vertex2D{  GLfloat x, y;  };
  // Wrapper for RGB colors 
  struct ColorRGB { GLfloat r, g, b; };

  constexpr ColorRGB COLOR_R = { 1.0, 0.0, 0.0  }; // Red 
  constexpr ColorRGB COLOR_G = { 0.0, 1.0, 0.0  }; // Green 
  constexpr ColorRGB COLOR_B = { 0.0, 0.0, 1.0  }; // Blue 


  class Model_Triangle
  {
      // Object position in World Coordinates
      float _x = 0.0, _y = 0.0; 
      // Scale 
      float _scale = 1.0;
      // Rotation angle around z axis
      float _angle = 0.0;
    
  public:
      Model_Triangle(float scale = 1.0){   }
      void rotate(float angle)          { _angle = angle; }
      void translate(float x , float y) { _x = x; _y = y; }
      void scale(float scale)           { _scale = scale; }
      void zoom(float factor)           {  _scale = factor + _scale; }

      // Render/draw this object 
      void render(GLuint vao, GLint  u_model)
      {
        
          // Reset model matrix to indentiy matrix 
          glm::mat4 _model(1.0);
          // Scale object (increase or decrease object size)
          _model =  glm::scale( _model, glm::vec3(_scale, _scale, _scale) );
          // Move to (X, Y) position 
          _model = glm::translate( _model, glm::vec3(_x, _y, 0.0)  ); 
          // Rotate from a given angle around Z axis at current object X, Y  postion
          _model = glm::rotate( _model, glm::radians(_angle), glm::vec3(0, 0, 1) );

          // Set shader uniform variable.
          glUniformMatrix4fv( 
              // Shader uniform variable location 
              u_model  
              // Number of matrices that will be set 
              , 1
              // GL_FALSE => Matrix is in column-major order (Fortran matrix layout)
              // GL_TRUE  => Matrix is in row-major order (C, C++ array, matrix layout)
              , GL_FALSE
              // Pointer to first element transform matrix (homogeneous coordinate)
              , glm::value_ptr(_model) 
          );
          glBindVertexArray(vao);        
          // Draw 3 vertices 
          glDrawArrays(GL_TRIANGLES, 0, 3);        
          // Disable global state 
          glBindVertexArray(0);        
      }
  };


  // Global variable [WARNING] - Vulnerable to global "initialization fiasco" 
  // undefined behavior.
  auto Cursor_Callback = std::function<void (GLFWwindow* window, double xpos, double ypos)>();

  int main(int argc, char** argv)
  {

      /* Initialize the library */
      if (!glfwInit()){ return -1; }

      // OpenGL Core Profile 
      glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
      glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
      glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

      glfwSetErrorCallback([](int error, const char* description)
                           {
                              std::cerr << " [GLFW ERROR] " << error 
                                        << ": " << description 
                                        << std::endl;
                           });

      GLFWwindow* window = glfwCreateWindow(640, 480, "2D Drawing with Shader", NULL, NULL);
      if (!window){ glfwTerminate(); return -1; }

      // OpenGL context 
      glfwMakeContextCurrent(window);
      glClearColor(0.0f, 0.5f, 0.6f, 1.0f);

      // Mouse move callback 
      // Note: It is only possible to pass non-capturing lambda to this callback.
      glfwSetCursorPosCallback( window
                              , [](GLFWwindow* window, double xpos, double ypos)
                                {
                                    // Forward call to global variable std::function<> 
                                    // (Function object)
                                    Cursor_Callback(window, xpos, ypos);
                                });

      // ====== S H A D E R - C O M P I L A T I O N ====//
      //                                                // 

      // Note: The shader source code is at the end of file.
      extern const char* code_vertex_shader;
      extern const char* code_frag_shader;

      GLuint prog = glCreateProgram();
      // Compile shader code 
      compile_shader(prog, code_vertex_shader, GL_VERTEX_SHADER  ) ;    
      compile_shader(prog, code_frag_shader,   GL_FRAGMENT_SHADER );

      // Bind current shader (enable it). Only one shader of the same type can 
      // be bound at a time. For instance, only a single vertex shader can 
      // be enabled at a time
      glUseProgram(prog);

      // Get shader uniform variable location for projection matrix
      // See shader code: "uniform mat4 projection;"
      const GLint u_proj  = glGetUniformLocation(prog, "u_projection");
      assert( u_proj >= 0 && "Failed to find uniform variable" );

      // Get shader uniform variable  location for model matrix.
      const GLint u_model  = glGetUniformLocation(prog, "u_model");
      assert( u_model >= 0 && "Failed to find uniform variable" );    

      // Get shader attribute location - the function glGetAttribLocation - returns (-1) on error.
      const GLint attr_position = glGetAttribLocation(prog, "position");
      assert( attr_position >= 0 && "Failed to get attribute location" );
      std::fprintf(stderr, " [TRACE] Attribute location attr_position = %d \n"
                  , attr_position);

      // Get shader index of color attribute variable.
      const GLint attr_color = glGetAttribLocation(prog, "color");
      assert( attr_color >= 0);


      // ====== U P L O A D - TO - G P U =========================// 
      //                                                          //

      constexpr size_t NUM_VERTICES = 3;

      // Array of triangle vertex coordinates (X, Y)
      Vertex2D vertices[NUM_VERTICES] = { 
        {  0.0,   0.2} // Vertex 0  (x =  0.0 ; y =  0.5)
      , { -0.2,  -0.2} // Vertex 1  (x = -0.5 ; y = -0.5)
      , {  0.2,  -0.2} // Vertex 2  (x =  0.5 ; y = -0.5)
      };

      ColorRGB colors[NUM_VERTICES] = { 
            COLOR_R   // Color of vertex 0
          , COLOR_B   // Color of vertex 1 
          , COLOR_G   // Color of vertex 2 
      };

      // Always initialize with zero (0), otherwise, the values
      // of those variables will be undefined. (Undefine Behavior)
      GLuint vao_triangle = 0;
      GLuint vbo_vertices = 0;
      GLuint vbo_colors   = 0;

      // Send vertices to GPU VBO (vbo_vertices)
      send_buffer(  &vao_triangle    // Ponter to VAO [OUTPUT]
                  , &vbo_vertices    // Pointer VBO   [OUTPUT]
                  , sizeof(vertices) // Size of buffer sent to GPU (VBO memory)
                  , vertices         // Pointer to buffer 
                  , attr_position    // Shader attribute location 
                  , 2                // Each vertex has 2 coordinates (X, Y)
                  , GL_FLOAT         // Each vertex coordinate has type GLfloat (float)
                  );

      // Send colors to GPU VBO (vbo_colors)
      send_buffer(  &vao_triangle   // Pointer Vertex Array object
                  , &vbo_colors     // Pointer Vertex buffer object handle (aka token)
                  , sizeof(colors)  // Buffer size 
                  , colors          // Pointer to buffer (addrress of first buffer element)
                  , attr_color      // Shader attribute location 
                  , 3               // Each color has 3 coordinates (R, G, B)
                  , GL_FLOAT        // Each color coordiante has type GLfloat
                  );

      // ============== Set Shader Uniform Variables =============// 
      //                                                          // 

      int width, height;
      glfwGetWindowSize(window, &width, &height);
    
      // Window aspect ratio
      float aspect = static_cast<float>(width) / height;

      // Identity matrix 
      const auto identity = glm::mat4(1.0);
    
      // Projection matrix - orthogonal projection for compensating 
      // the aspect ratio.
      glm::mat4 Tproj = glm::ortho(-aspect, aspect, -1.0f, 1.0f, -1.0f, 1.0f);

      // Set projection matrix uniform variable
      glUniformMatrix4fv(u_proj, 1, GL_FALSE, glm::value_ptr(Tproj) );
      // Set model matrix uniform variable
      glUniformMatrix4fv(u_model, 1, GL_FALSE, glm::value_ptr(identity) );

      // Instatiate objects that will be rendered 
      auto triangleA = Model_Triangle{};
      triangleA.scale(0.50);
      triangleA.rotate(122);

      auto triangleB = Model_Triangle{};
      triangleB.translate(-0.20, 0.30);
      triangleB.rotate(50);
      triangleB.scale(1.8);

      auto triangleC = Model_Triangle{};
      triangleC.translate(0.20, 0.20);
      triangleC.rotate(35);

      // Follows mouse coordinate 
      auto triangleD = Model_Triangle{};
      triangleD.translate(-0.60, -0.50);
      triangleD.scale(1.50);
      // triangleD.scale(1.2);
      // triangleD.rotate(40);    

      // --------- Set mouse callback ----------// 

      constexpr float PI = 3.1415926536f;
      constexpr float FACTOR_RAD_TO_DEG = 180.0 / PI;

      Cursor_Callback = [&](GLFWwindow* window, double xpos, double ypos)
      {
          // Mouse normalized coordinate 
          // =>> see: https://stackoverflow.com/questions/23870750/
          float xMouse = -1.0f + 2.0f * xpos / width;
          float yMouse =  1.0f - 2.0f * ypos / height;

          // Angle in degrees between X axis vector(1, 0, 0) and poit (xMouse, yMouse, 0) position.
          // Note: atan2f() returns angle in radians. 
          float angle = atan2f(yMouse, xMouse) * FACTOR_RAD_TO_DEG ;
          fprintf(stderr, " [TRACE] Angle = %f \n", angle);

          // Triangle D follows mouse position
          triangleD.translate(xMouse, yMouse);
          triangleD.rotate(angle);

          triangleB.rotate(angle);
        
          // Show mouse position
           // std::fprintf(stderr, " [MOUSE] x = %f ; y = %f \n", xMouse, yMouse);
      };

      //  ======= R E N D E R  - L O O P ============//
      //                                             //
      while ( !glfwWindowShouldClose(window) )
      {
          glClear(GL_COLOR_BUFFER_BIT);

          // ====== BEGIN RENDERING ============//
        
              triangleA.render(vao_triangle, u_model);
              triangleB.render(vao_triangle, u_model);
              triangleC.render(vao_triangle, u_model);
              triangleD.render(vao_triangle, u_model);

              //std::fprintf(stderr, " [TRACE] Redraw screen \n");

          // ====== END RENDERING ==============//

          /* Swap front and back buffers */
          glfwSwapBuffers(window);
          /* Poll for and process events */
          glfwPollEvents();

          if( glfwGetKey(window, 'Q' ) == GLFW_PRESS )
          {
               std::cout << " [TRACE] User typed Q =>> Shutdown program. Ok. " << '\n';
               break;
          }

          // Increase scale by 10%
          if( glfwGetKey(window, 'A' ) == GLFW_PRESS ){ triangleD.zoom(+0.10); }
          // Decrease scale by 10%
          if( glfwGetKey(window, 'B' ) == GLFW_PRESS ){ triangleD.zoom(-0.10); }


      }

      glfwTerminate();
      return 0;

  } // --- End of main() -----//


  // Minimal vertex shader =>> Runs on the GPU and processes each vertex.
  const char* code_vertex_shader = R"(    
      #version 330 core 

      // Supplied by GPU - attribute location (id = 2) 
      // contains a (X, Y) vertex
      layout ( location = 2)  in vec2 position;
      layout ( location = 1 ) in vec3 color;     // Contains (Red, Green, Blue) components

      // Output to fragment shader 
      out vec3 out_color;

      // Model matrix => projection coordinates from the local space (model space)
      // to view space .
      // Transform 4x4 matrix - supplied by the C++ side. 
      uniform mat4 u_model;

      // Projection matrix => projections camera-space coordinates 
      // to clip-space coordinates. (-1.0 to 1.0) range.
      uniform mat4 u_projection;

      void main()
      {
          // gl_Position => Global output variable that holds the 
          // the current vertex position. It is a vector of 
          // components (X, Y, Z = 0, W = ignored)
          gl_Position = u_projection * u_model * vec4(position, 0, 1.0);

          // Forward to fragment shader 
          out_color = color;
      }

  )";

  // Fragment shader source code 
  const char* code_frag_shader = R"(
      #version 330 

      // This color comes from Vertex shader 
      in vec3 out_color;

      void main()
      {
          // Set vertex colors
          gl_FragColor = vec4(out_color, 1.0);

      }
  )";

      // ====== I M P L E M E N T A T I O N S ==========// 

  void compile_shader(GLuint m_program, const char* code, GLenum type)
  {
      GLint shader_id = glCreateShader( type );
      glShaderSource(shader_id, 1, &code, nullptr);
      glCompileShader(shader_id);
    
      GLint is_compiled = GL_FALSE;
      // Check shader compilation result 
      glGetShaderiv(shader_id, GL_COMPILE_STATUS, &is_compiled);

      // If there is any shader compilation result, 
      // print the error message.
      if( is_compiled == GL_FALSE)
      {
          GLint length;
          glGetShaderiv(shader_id, GL_INFO_LOG_LENGTH, &length);
          assert( length > 0 );

          std::string out(length + 1, 0x00);
          GLint chars_written;
          glGetShaderInfoLog(shader_id, length, &chars_written, out.data());
          std::cerr << " [SHADER ERROR] = " << out << '\n';
          // Abort the exection of current process. 
          std::abort();
      }          

      glAttachShader(m_program, shader_id);   
      glDeleteShader(shader_id);
      glLinkProgram(m_program);
      GLint link_status = GL_FALSE;
      glGetProgramiv(m_program, GL_LINK_STATUS, &link_status);
      assert( link_status != GL_FALSE );   
      // glUseProgram(m_program);         
  }

  // Upload buffer from main memory to GPU VBO 
  // =>> Parameters VAO, VBO are allocated by the caller. 
  void send_buffer( GLuint* pVao, GLuint* pVbo, GLsizei sizeBuffer
                  , void* pBufffer, GLint   shader_attr, GLint size
                  , GLenum type)
  {
      assert(pVao != nullptr);
      assert(pVbo != nullptr);
      GLuint& vao = *pVao;
      GLuint& vbo = *pVbo;

      // Generate and bind current VAO (Vertex Array Object)
      if(vao == 0){ glGenVertexArrays(1, &vao); }
      glBindVertexArray(vao);

      // Generate and bind current VBO (Vertex Buffer Object)
      glGenBuffers(1, &vbo);
      glBindBuffer(GL_ARRAY_BUFFER, vbo);

      // Upload data to current VBO buffer in GPU 
      glBufferData(GL_ARRAY_BUFFER, sizeBuffer, pBufffer, GL_STATIC_DRAW);   

      glEnableVertexAttribArray(shader_attr);
    
      // Set data layout - how data will be interpreted.
      glVertexAttribPointer(shader_attr, size, type, GL_FALSE, 0, nullptr);

      // ------ Disable Global state set by this function -----//
      // 
      // Unbind VAO 
      glBindVertexArray(0);
      // Unbind VBO 
      glBindBuffer(GL_ARRAY_BUFFER, vbo);
      // Disable current shader attribute 
      glDisableVertexAttribArray(shader_attr);

  }
#+END_SRC

