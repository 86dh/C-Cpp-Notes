<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-21 Thu 08:34 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Multithreading and concurrency</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Caio Rodrigues Soares - caiorss [DOT] rodrigues [AT] gmail [DOT] COM" />
<meta name="description" content="cpp/c++ thread concurrency std::thread modern cpp c++"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
<link href="theme/org-nav-theme.css" rel="stylesheet">
<script src="theme/org-nav-theme.js"></script>
<link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Multithreading and concurrency</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org893fa3e">1. Multithreading and concurrency</a>
<ul>
<li><a href="#org2244b6d">1.1. Fundamental Concepts</a></li>
<li><a href="#org4d9f799">1.2. Concepts Reference Map</a></li>
<li><a href="#org3b9d5f7">1.3. Standard Library Reference</a></li>
<li><a href="#orgc207429">1.4. Papers from WG21 Working Group</a></li>
<li><a href="#orgd813597">1.5. Class std::thread</a></li>
<li><a href="#org127417d">1.6. Functions of namespace std::this_thread</a></li>
<li><a href="#org3ca7cc8">1.7. Thread - std::thread usage and synchronization primitives</a>
<ul>
<li><a href="#orgd6ebb17">1.7.1. Race condition</a></li>
<li><a href="#org9296347">1.7.2. Debugging Race Conditions with CLang's Sanitizers</a></li>
<li><a href="#org47f8d04">1.7.3. Mutex solution</a></li>
<li><a href="#org78bb4fa">1.7.4. Atomic variable solution</a></li>
</ul>
</li>
<li><a href="#org3572087">1.8. Thread - Returning values from std::thread</a>
<ul>
<li><a href="#org7c0c47e">1.8.1. Return value from thread</a></li>
<li><a href="#orgc9bc662">1.8.2. Catch exceptions in threads</a></li>
<li><a href="#orga8c5559">1.8.3. Example: Returning values and catching exceptions</a></li>
</ul>
</li>
<li><a href="#org53b903e">1.9. Thread Local Variables and TLS - Thread Local Storage</a></li>
<li><a href="#orgae337ae">1.10. Task-based APIs =&gt; Futures and Promises</a>
<ul>
<li><a href="#org56e029a">1.10.1. Futures overview</a></li>
<li><a href="#orga80369c">1.10.2. Futures Usage</a></li>
<li><a href="#orgbad28f3">1.10.3. Example</a></li>
</ul>
</li>
<li><a href="#orgfafbabf">1.11. Condition Variables and Producer Consumer Problem</a></li>
<li><a href="#org14ed0b5">1.12. Messaging Passing Concurrency and Message Queue</a>
<ul>
<li><a href="#orgd7e7077">1.12.1. Overview</a></li>
<li><a href="#orge3001e7">1.12.2. Producer/consumer problem with messague queue</a></li>
<li><a href="#org97ad178">1.12.3. References</a></li>
</ul>
</li>
<li><a href="#orgde4fd7e">1.13. Thread Pools</a>
<ul>
<li><a href="#org89eb614">1.13.1. Overview</a></li>
<li><a href="#orgfeaba94">1.13.2. Some thread pool implementations</a></li>
<li><a href="#org0d799f3">1.13.3. Example: Simple thread pool implementation</a></li>
<li><a href="#org5f61b3c">1.13.4. Further Reading</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org893fa3e" class="outline-2">
<h2 id="org893fa3e"><span class="section-number-2">1</span> Multithreading and concurrency</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org2244b6d" class="outline-3">
<h3 id="org2244b6d"><span class="section-number-3">1.1</span> Fundamental Concepts</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<b>Processes and Threads</b>
</p>

<p>
Processes: 
</p>

<ul class="org-ul">
<li>A process is a running program with its own virtual memory,
address space, unique process identifier ID and context (CPU
registers - IP - Instruction Pointer and SP - Stack Pointer)</li>

<li>A single <span class="underline">CPU core</span> is only capable of executing a single process
at a time. However, users have the illusion that multiple
processes are being run simultaneously because the <span class="underline">operating system's</span>
<span class="underline">scheduler</span> multiplexes the CPU execution time between all
processes. As a result, each process is run sequentially by a
single CPU core during a short <span class="underline">time slice</span> (time sharing). When the
scheduler switches to another process, it saves the <span class="underline">process' state</span>
(current directory, CPU registers, &#x2026;) and loads the state of the
next process (context switching).</li>
</ul>

<p>
Threads: 
</p>

<ul class="org-ul">
<li>A thread is a independent flow of execution or task within a
single process. The purpose of threads is to allow a process to
execute multiple independent simultaneous tasks, such as running
the user interface dispatch thread, handling socket connections,
performing the download in a different thread and so on.</li>

<li>For an operating system, a thread is a <span class="underline">lightweight process</span> or a
stripped down process with its own stack, local data, CPU
registers (specially IP - Instruction Pointer and SP - Stack
Pointer), but without its own address space and virtual memory,
instead it only can access to the virtual memory of the process
that thread belongs to.</li>

<li>Threads are also known as (aka):
<ul class="org-ul">
<li>Lightweight process</li>
<li>Native thread</li>
<li>Kernel-thread</li>
<li>Operating system thread or OS thread</li>
</ul></li>
</ul>

<p>
Benefits of multi-threading:
</p>

<ul class="org-ul">
<li>Increase application responsiviness, specially GUI - Graphical
User Interface Applications.</li>

<li>Take advantage of multi-core processor</li>

<li>Speed up heavy math computations. Multi-threading allows to
split a heavy matrix calculation into multiple threads running
in different CPU cores.</li>

<li>Fewer system resources usage. Using multiple threads for running
multiple tasks is cheaper than running multiple processes for
each task. Note: before multi-threading, it was common in
Unix-like operating system to use the <span class="underline">fork()</span> system call to fork
(copy) the current process for handling client socket
connections in network server appliocations.</li>
</ul>


<p>
Synchronization Primitives
</p>

<ul class="org-ul">
<li>Mutex</li>

<li>Semaphore</li>

<li>Condition variables</li>

<li>Barriers</li>

<li>Atomic variables</li>
</ul>

<p>
Potential Problems of Concurrency and Multi-threading
</p>

<ul class="org-ul">
<li>Race condition, aka data race</li>

<li>Deadlock</li>

<li>Starvation</li>

<li>Oversubscription</li>

<li>Load balancing</li>

<li>Thread exaustion</li>
</ul>

<p>
<b>Low Level Multithreading APIs:</b>
</p>

<p>
Threads and processes require operating system support, therefore
programming languages do not provide threads, they just provide high
level wrapper APIs for calling operating systems' low level APIs. The
most common of those low level APIs are: 
</p>

<ul class="org-ul">
<li><span class="underline">pthread (Posix threads)</span> - POSIX API (C-API)
<ul class="org-ul">
<li>The posix thread API is implemented by most Unix-like operating
systems such Linux, MacOsx, iOS, Android, BSD and some embedded
real time systems such as RTEMS, QNX and VxWorks.</li>
</ul></li>

<li><span class="underline">Windows Win32 Thread API</span>
<ul class="org-ul">
<li>Available only for Windows NT and Windows CE kernels.</li>
</ul></li>
</ul>


<p>
<b>Concurrency X Parallelism</b>
</p>

<ul class="org-ul">
<li><span class="underline">Concurrency</span>

<ul class="org-ul">
<li>=&gt; Multiple threads run sharing resources (shared memory) in the
same process. It is not possible to run them safely without
synchronization promitives, specially locks such as mutexes and
semaphores.</li>

<li>Note: concurrency is possible in a system with just one processor
and one core.</li>

<li>Main purpose: <span class="underline">Increase system responsiviness.</span>
<ul class="org-ul">
<li>Avoid blocking main threads of user interface's event loop by
running a computation with significant delay in a new thread;
handle multiple client requests of a web server in another
thread or in a thread pool and so on..</li>
</ul></li>

<li>Better for:

<ul class="org-ul">
<li>GUI - Graphical User Interfaces, increase responsiviness
avoiding freezing the UI.</li>

<li>Network Servers with lots IO.</li>

<li>Games and computer graphics =&gt; Tasks with long delay that could
block the game loop can be executed in another thread.</li>
</ul></li>
</ul></li>

<li><span class="underline">Parallel Computing</span>

<ul class="org-ul">
<li>=&gt; Multiple threads are running in different processing units
without any communication or shared data. Parallelism  require at
least more than one processing unit, which can be multiple CPU
cores, multiple CPU chips/sockets, multiple computers or a GPU
card.</li>

<li>=&gt; Parallelism is not possible with a single core CPU, it
requires multiple cores or multiple processing units.</li>

<li>=&gt; Parallism is also possible without threads with SIMD CPU
instructions (data parallelism).</li>

<li>=&gt; Better for:
<ul class="org-ul">
<li>HPC - High Performance Computing</li>
<li>Math intensive computation</li>
<li>CPU-bound tasks</li>
<li>Math, Physics, Science and Engineering</li>
</ul></li>

<li>Hardware for Parallel Computing 
<ul class="org-ul">
<li>Multi-core CPUs</li>
<li>Multi processor servers with multi-core CPUs.</li>
<li>GPU</li>
<li>Computer cluster (distributed systems)</li>
</ul></li>

<li>APIs - Application Programming Interfaces for Parallel Computing

<ul class="org-ul">
<li>OpenMP =&gt; Useful for parallelizing existing algorithms and loops.</li>

<li>MPI - Message Passing Interface.</li>

<li>GPU =&gt; Cuda, OpenCL, Sycl &#x2026;</li>

<li>SIMD Libraries</li>
</ul></li>
</ul></li>
</ul>

<p>
<b>Computation bottlenecks</b>
</p>

<ul class="org-ul">
<li>IO-bound computations 

<ul class="org-ul">
<li>=&gt; Most of the time of an IO-bound computation is spent waiting,
reading and writing IO. The speed of the task is limited by the
IO speed.</li>

<li>Example: Processing big files, web servers, FTP servers &#x2026;</li>

<li>Solutions:

<ul class="org-ul">
<li>Thread-pools + non-blocking IO based on operating system APIs:
epool (Linux);  Kqueue (BSD and Mac OSX) and IOCP (Windows).
<ul class="org-ul">
<li>Some libraries: Boost ASIO or LibUV used by NodeJS. &#x2026;</li>
</ul></li>

<li>User-space threads (aka fibers, greenthreads or coroutines) +
Non-blocking IO such as <span class="underline">epoll</span> (Linux); <span class="underline">kqueue</span>  (MacOSX and
BSD-variants) and <span class="underline">IOCP</span> on Windows.
<ul class="org-ul">
<li>Some libraries: Boost Asio + Boost Coroutines or C++20 Coroutines.</li>
</ul></li>
</ul></li>
</ul></li>

<li>CPU-bound computations 
<ul class="org-ul">
<li>=&gt; A CPU-bound computations is CPU intensive and its speed is
limited by the CPU speed. As the CPU clock is no longer
increasing as before, the only way to boost performance when no
further optimization is possible is by using multithreading and
parallel programming for taking advantage of multicore CPUs.</li>

<li>Example: Heavy mathematical computation; matrix computations;
linear algebra; solving PDEs partial differential equations;
computer vision &#x2026;</li>

<li>Solutions:
<ul class="org-ul">
<li>Find better algorithms</li>
<li>Select suitable data structures</li>
<li>Cache-friendly data structures</li>
<li>Parallize algorithms for running a chunck on N threads on
different cores. APIs: C++ STL parallel algorithms; Intel TBB;
OpenMP &#x2026;</li>
<li>Use a CPU with more cores or higher clock "if possible".</li>
<li>Use a server with multiple multi-core CPUs.</li>
<li>Use a cluster or distributed computer.</li>
</ul></li>
</ul></li>

<li>IO-bound and CPU-bound.

<ul class="org-ul">
<li>The speed of the task is limited both by CPU speed and time spent
waiting, reading or writing IO.</li>
</ul></li>
</ul>


<p>
<b>Hardware and Multicore</b> 
</p>

<p>
The days where manufacturers would keep increasing the CPU frequency
are over as a technology limit was reached, an increase in the CPU
clock speed, increases the CPU power consumption in a cubic rate,
therefore the CPU heat rises dramatically requiring even more
cooling. The solution found was to design CPU chips with more cores
instead of keep increasing the CPU frequency. However, it crates new
challenges for developers as the only way to boost the performance and
speed of CPU-bound applications is by taking advantage of the
multicore processors which means using multithreading and parallel
programming tehcniques.
</p>

<p>
Terminology:
</p>

<ul class="org-ul">
<li>Physical Processor, aka CPU (Central Processing Unit) or socket
<ul class="org-ul">
<li>=&gt; Chip visible in the computer's motherboard. A single modern
chip can contain multiple processing units inside of it, called
<span class="underline">CPU core</span>. Note: some <span class="underline">server computers</span> may have multiple physical
processors or CPU chips.</li>
</ul></li>

<li>CPU Core and Multicore CPUs 

<ul class="org-ul">
<li>=&gt; A CPU core is a <span class="underline">processing unit</span> or the device that executes
the machine code instructions. Nowadays most processors chips
are <span class="underline">multicore</span>, a single CPU chip contain multiple cores. A CPU
with N cores is capable of executing at least N stream of
instruction simultaneously or at least N <span class="underline">hardware threads</span>.</li>
</ul></li>

<li>Hyper Thread
<ul class="org-ul">
<li>=&gt; <span class="underline">Hyper threading</span> is a Intel's proprietary technology which
allows a single CPU core to run process multiple streams of
instructions as it was multiple processors. In other words, a
single core is capable of running multiple threads in parallel.</li>
</ul></li>

<li>Total number of hardware threads or <span class="underline">logical processors</span>
<ul class="org-ul">
<li>=&gt; NHW = TOTAL NUMBER OF LOGICAL PROCESSORS = TOTAL NUMBER OF THREADS</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-text">NHW = (Number of CPUs) * (Number of Cores per CPU) * ( Number of HW threads per core ) 
</pre>
</div>

<p>
A server computer with 2 physical processors or CPU sockets, 4
processing cores per CPU and 2 threads per core has a total of 
</p>

<ul class="org-ul">
<li>NHW = 2 x 2 x 4 = 16 threads or 16 logical processors</li>
</ul>
</div>
</div>

<div id="outline-container-org4d9f799" class="outline-3">
<h3 id="org4d9f799"><span class="section-number-3">1.2</span> Concepts Reference Map</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<b>Multitasking</b> 
</p>

<p>
Ability to perform multiple actions at the same time: 
</p>

<ul class="org-ul">
<li><span class="underline">Multi processing</span> (Multi-process)

<ul class="org-ul">
<li>=&gt; Spawn, fork new process for handling new requests or
performing other tasks. Example: POSIX system call <span class="underline">fork</span> - before
threads become widespread, servers handled new incoming client
sockets requests by forking a new process by calling <span class="underline">fork</span> which
creates a child process which is a copy of the current process.</li>

<li>=&gt; Processes communicate through IPC - Interprocess
Communication primitives such as shared memory, message passing,
synchronization primitives or sockets.</li>

<li>=&gt; Advantages:
<ul class="org-ul">
<li>Better robustness: the crashing or abnormal termination of any
process does not affect others.</li>
</ul></li>

<li>=&gt; Disadvantage:
<ul class="org-ul">
<li>Higher overhead, creating processes is more expensive than
creating threads.</li>
<li>More complicated communication: unlike threads, processes
cannot easily share data and variables without IPC inter
process communication.</li>
</ul></li>

<li>=&gt; Note: Web browsers such as Chrome and Firefox spawns a new
process for dealing with a new created tab or window.</li>

<li>=&gt; Note: Some programming languages, such as Python, OCaml, and
Ruby suffer from the <a href="https://en.wikipedia.org/wiki/Global_interpreter_lock">GIL</a> - <span class="underline">Global Interpreter Lock</span> problem which
allows only a single <span class="underline">native thread</span> run at a time due to
concurrency reasons and design choices. The GILs makes the
language unable to achieve true concurrency and parallelism by
taking advantage of multicore processors. The solution to this
issue is to use <b>multi-processing</b>, spawn multiple processes for
harness the multicore processors capabilities.</li>

<li>=&gt; Note: Python and other languages with the GIL issue can
overcome the GIL limitation by using libraries written in native
code in Rust, C, C++ such as Numpy for Python.</li>
</ul></li>

<li><span class="underline">Multi threading</span> (Kernel threads)
<ul class="org-ul">
<li>=&gt; Use multiple threads for dealing with concurrency and running
multiple independent taks control flows within a single process.</li>

<li>=&gt; Advantages:
<ul class="org-ul">
<li>Creating new threads is less expensive than creating
processes, although spawning a kernel threads is still expensive.</li>
<li>Threads can communicate through shared memory (process virtual
memory) and thread synchronization primitives.</li>
<li>Unlike, threads can easily share variables and data.</li>
</ul></li>

<li>=&gt; Disadvantages:
<ul class="org-ul">
<li>Threads</li>
</ul></li>
</ul></li>

<li><span class="underline">Multi threading</span> (User Space threads)

<ul class="org-ul">
<li>User-space threads (_fibers_, aka <span class="underline">coroutines</span>, aka <span class="underline">greenthreads</span>,
<span class="underline">lightweight threads</span>) are similar to native threads which are
provided by the kernel. However, unlike kernel threads,
user-space threads are emulated by a runtime, interpreter or library in
the user-space. Note: languages withotu user-space threads, can
overcome the thread overhead by using <span class="underline">thread pools</span> and
non-blocking IO just like Nginx web server and NodeJS. The
problem of this approach is the non-friendly <b>callbacks</b> and
possible "callback-hell".</li>

<li>Advantages:

<ul class="org-ul">
<li>Faster context switch than kernel-threads.</li>

<li>It is possible to run multiple user-space threads in a single
threads.</li>

<li>Scalability: It is expensive to spawn multiple kernel threads
for handling every incoming connection of some web server due
to the memory and context switch overhead of kernel
threads. However, it is  cheap and faster to spawn hundreds or
thousands of <span class="underline">user-space</span> <span class="underline">threads</span> for handling incoming connections.</li>
</ul></li>

<li>Disadvantages: 

<ul class="org-ul">
<li>Cooperative multithreading: All fibers or user-space threads
can only use <span class="underline">non-blocking IO</span> and non-blocking system calls
(epoll, select, kqueue, &#x2026;), otherwise all other user-space
threads will be stalled.</li>

<li>User-space threads are not suitable for <span class="underline">CPU-bound</span> (CPU
intensive), numerical computations and <span class="underline">parallel computations</span>.</li>
</ul></li>

<li>Programming Languages with <span class="underline">user-space threads:</span>
<ul class="org-ul">
<li>Golang (Goroutines are user-space threads)</li>
<li>Haskell</li>
<li>Erlang</li>
<li>OCaml</li>
<li>Python</li>
<li>Ruby</li>
<li>C++20, until C++20 is not released there is the</li>
</ul></li>
</ul></li>
</ul>

<p>
<b>Concurrency Primitives</b> 
</p>

<ul class="org-ul">
<li>Threads (kernel threads)</li>

<li>Thread-local store</li>

<li>Lock synchronization primitives
<ul class="org-ul">
<li>mutex</li>
<li>recursive mutex</li>
<li>semaphore</li>
<li>barriers</li>
<li>spinlocks</li>
</ul></li>

<li>Non-lock synchronization primitives
<ul class="org-ul">
<li>atomic variables</li>
</ul></li>

<li>Coordination synchronization primnitives 
<ul class="org-ul">
<li>condition variables</li>
</ul></li>
</ul>

<p>
<b>Thread Operations</b> 
</p>

<ul class="org-ul">
<li>fork()/spawn()
<ul class="org-ul">
<li>Create a new thread.</li>
</ul></li>

<li>join()
<ul class="org-ul">
<li>Wait for thread termination.</li>
</ul></li>

<li>get_id()
<ul class="org-ul">
<li>Get unique thread identifier nunber, similar to process ID (PID).</li>
</ul></li>

<li>cancel()
<ul class="org-ul">
<li>aka trhead cancellation =&gt; Abnormally terminate a thread
(similar to std::terminate), not supported by C++ standard
library.</li>
</ul></li>
</ul>

<p>
<b>Concurrency Hazards</b> 
</p>

<ul class="org-ul">
<li>Data races, race conditions</li>

<li>Deadlock</li>

<li>Livelock</li>

<li>Starvation</li>
</ul>

<p>
<b>Concurrency Concepts</b> 
</p>

<ul class="org-ul">
<li>Mutual exclusion
<ul class="org-ul">
<li>locks</li>
<li>race conditions (a.k.a: data races)</li>
</ul></li>

<li>Producer/consumer problems</li>

<li>Thread local storage</li>
</ul>

<p>
<b>High Level Concurrency Constructs</b> 
</p>

<ul class="org-ul">
<li><span class="underline">Message queue</span> (aka blocking queue or mailbox)
<ul class="org-ul">
<li>Construct used for implementing <span class="underline">message passing concurrency</span> and
coordinates producer/consumer threads without explicit use of
locks and shared state.</li>
<li>Example: Java's BlockingQueue</li>
</ul></li>

<li><span class="underline">Thread Pools</span>
<ul class="org-ul">
<li>Construct used for recycling and avoiding creating too much
threads in IO intensive applications such as web
servers. A thread pool is comprised of a task queue and a set
of long-running worker threads that runs taks from the task
queue submited by the client code.  Thread pools can also be
used for parallel computing.</li>

<li>Servers such as Nginx, the NodeJS (JavaScript runtime) and
Boost.Asio library use thread pools alongside <span class="underline">non blocking IO</span>
for achieving scalability.</li>
</ul></li>

<li><span class="underline">Executors</span>
<ul class="org-ul">
<li>Abstraction for decoupling tasks from the execution
method. It allows changing the execution mechanism without much
effort. For instance, it makes possible to run a set of tasks
from a task queue (message queue) serially in the same thread,
serially in a another thread or in a thread pool.</li>
</ul></li>

<li><span class="underline">Futures</span> (Task-based API)
<ul class="org-ul">
<li>Allows the calling to get the return value from an asynchrnous
computation. It does not block the calling thread unti
Future.get() is called for retrieving the value from the async
computation. Note: The computation wrapped by the future object
can run in a new thread or in a thread pool (better).</li>
<li>Note: The C++11 std::future runs in a new thread which has a
big overhead if too much future objects are created in a short
time.</li>
</ul></li>

<li><span class="underline">Promises</span> (Task-based API)</li>

<li><b>Lock-free</b> data structures</li>

<li><span class="underline">Thread-safe containers/data structures or collections</span>
<ul class="org-ul">
<li>Collections such as hashmaps, arrays, sets  tha encapsulates
synchronization primitives such as locks and are safe to use
from multiples threads.</li>
</ul></li>
</ul>

<p>
<b>Concurrency Models</b> 
</p>

<ul class="org-ul">
<li>CSP - Concurrent Sequential Process (Tony Hoare)
<ul class="org-ul">
<li>Languages with CSP: Go (aka Golang), Clojure</li>
</ul></li>

<li>Actor Model
<ul class="org-ul">
<li>Languages with actor model: Erlang, Scala (Akka)</li>
<li>Types: 
<ul class="org-ul">
<li>Active Objects</li>
<li>Agents</li>
</ul></li>
</ul></li>

<li>STM - Software Transaction Memory
<ul class="org-ul">
<li>Languages with STM: Haskell.</li>
</ul></li>
</ul>

<p>
<b>Parallelism</b> 
</p>

<ul class="org-ul">
<li>Goal: speed up computations and improve the overall performance
by splitting a big computation into multiple smaller computations
tha runs simulatenously in multiple processing units.</li>

<li>Hardware: Multicore CPUs; CPU SIMD instructions (aka vector
instructions); server computers with many multicores CPU chips;
clusters of many computers; supercomputers with thousands of
cores; GPUs - Graphical Processing Unit.</li>

<li>APIs:

<ul class="org-ul">
<li>OpenMP (Language extension for C, C++ or Fortran + Runtime library)
<ul class="org-ul">
<li>Parallelize for-loops of numerical algorithms without
explicitly dealing with threads.</li>
</ul></li>

<li>MPI - Message Passing Interface</li>

<li>Intel Cilk Language extension for C or C++</li>

<li>Intel TBB - Thread Building Blocks</li>

<li>Microsoft PPL - Parallel Patterns Library (Windows-Only)</li>

<li>STL - C++17 Standard Library Parallel Algorithms</li>

<li>Intel Parallel STL (Reference implementation of C++
Standard-Library parallel algorithms)</li>

<li>GPU APIs:
<ul class="org-ul">
<li>CUDA (proprieteary, Nvidia)</li>
<li>OpenCL (open source, Khronos Group)</li>
<li>SYCL (open source, Khronos Group)</li>
</ul></li>
</ul></li>
</ul>

<p>
<b>See:</b> 
</p>

<p>
User-Space Threads, Coroutines, Fibers, &#x2026; 
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Fiber_(computer_science)">Fiber (computer science) - Wikipedia</a></li>

<li><a href="https://c9x.me/articles/gthreads/intro.html">Green threads explained (intro)</a></li>

<li><a href="https://en.cppreference.com/w/cpp/language/coroutines">Coroutines (C++20) - cppreference.com</a></li>

<li><a href="https://www.modernescpp.com/index.php/coroutines">Coroutines - ModernesCpp.com</a></li>

<li><a href="https://stackoverflow.com/questions/43503656/what-are-coroutines-in-c20">c++ - What are coroutines in C++20? - Stack Overflow</a></li>

<li>Library: <a href="https://www.boost.org/doc/libs/1_71_0/libs/coroutine/doc/html/index.html">Boost.Coroutine</a></li>

<li>Library: <a href="https://www.boost.org/doc/libs/1_71_0/libs/coroutine2/doc/html/index.html">Boost.Coroutine2</a>
<ul class="org-ul">
<li>Boost coroutine library.</li>
</ul></li>

<li>Library: <a href="https://www.boost.org/doc/libs/1_71_0/libs/fiber/doc/html/index.html">Boost.Fiber</a></li>

<li>Library: <a href="https://www.boost.org/doc/libs/1_71_0/doc/html/boost_asio/reference/coroutine.html">Boost.Asion - coroutines</a>
<ul class="org-ul">
<li>Coroutines support in Boost Asio network socket server/client framework</li>
</ul></li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0158r0.html">P0158R0 - Coroutines belong in a TS</a></li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1364r0.pdf">P13564R0 - Fibers under the magnifying glass</a> - Gor Nishanov [BEST, MUST READ]</li>

<li><a href="https://isocpp.org/files/papers/N4402.pdf">N4402 - Resumable Functions</a> - Gor Nishanov</li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0866r0.pdf">P08066: Response to "Fibers Under Magnifying glass"</a></li>

<li><a href="https://nullprogram.com/blog/2019/03/28/">Fibers: the Most Elegant Windows API « null program</a></li>

<li><a href="https://jrebel.com/rebellabs/what-are-fibers-and-why-you-should-care/">What are fibers and why should you care? | JRebel &amp; XRebel</a></li>

<li><a href="https://rcoh.me/posts/why-you-can-have-a-million-go-routines-but-only-1000-java-threads/">Why you can have millions of Goroutines but only thousands of Java Threads</a></li>

<li><a href="http://tleyden.github.io/blog/2014/10/30/goroutines-vs-threads/">Goroutines vs Threads - Seven Story Rabbit Hole</a></li>

<li><a href="https://crates.io/crates/corona">corona - crates.io: Rust Package Registry</a> (Rust Coroutines)</li>
</ul>

<p>
Web Browser Multi-processing: 
</p>

<ul class="org-ul">
<li><a href="https://blog.chromium.org/2008/09/multi-process-architecture.html">Chromium Blog: Multi-process Architecture</a></li>

<li><a href="https://www.chromium.org/developers/design-documents/multi-process-architecture">Multi-process Architecture - The Chromium Projects</a></li>

<li><a href="https://helgeklein.com/blog/2019/01/modern-multi-process-browser-architecture/">Modern Multi-Process Browser Architecture • Helge Klein</a></li>

<li><a href="https://stackoverflow.com/questions/4263124/which-is-better-choice-for-browsers-tab-multi-thread-or-multi-process">c - Which is better choice for browser's tab: multi-thread or multi-process? - Stack Overflow</a></li>
</ul>

<p>
GIL =&gt; Global Interpreter Lock: 
</p>

<ul class="org-ul">
<li><a href="https://realpython.com/python-gil/">What is the Python Global Interpreter Lock (GIL)? – Real Python</a></li>

<li><a href="https://wiki.python.org/moin/GlobalInterpreterLock">GlobalInterpreterLock - Python Wiki</a></li>

<li><a href="https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/">What is the Python Global Interpreter Lock (GIL) - GeeksforGeeks</a></li>

<li><a href="https://www.dabeaz.com/python/UnderstandingGIL.pdf">Understanding the Python GIL</a> - David Beazley</li>
</ul>

<p>
Executor Design Pattern: 
</p>

<ul class="org-ul">
<li><b>The Executor Design Pattern</b> - Decoupling Tasks from Execution -
Eric Crahen - VikingPLOP 2002 - page 55
<ul class="org-ul">
<li><a href="http://www.hillside.net/vikingplop/vikingplop2002/VikingPLoP2002_Proceedings.pdf">http://www.hillside.net/vikingplop/vikingplop2002/VikingPLoP2002_Proceedings.pdf</a></li>
</ul></li>

<li><b>Concurrency Patterns</b> - Douglas C. Schmidt
<ul class="org-ul">
<li><a href="https://www.dre.vanderbilt.edu/~schmidt/POSA/POSA2/conc-patterns.html">https://www.dre.vanderbilt.edu/~schmidt/POSA/POSA2/conc-patterns.html</a></li>
<li>Note: "Other patterns in the literature that address
concurrency-related issues include Master-Slave [POSA1],
Producer-Consumer [Grand98], Scheduler [Lea99a], and Two-phase
Termination [Grand98]."</li>
</ul></li>

<li><a href="https://gitee.com/iOceanPlus_Forked/CppCon2015/raw/master/Presentations/Executors%20for%20C++%20-%20A%20Long%20Story/Executors%20for%20C++%20-%20A%20Long%20Story%20-%20Detlef%20Vollmann%20-%20CppCon%202015.pdf">Executors for C++ - A long History</a> - Strugling for a Base for
Concurrency Building Block - Detlef Vollman.</li>

<li><a href="https://github.com/executors/executors">GitHub - executors/executors: A proposal for a executor programming model for ISO C++</a></li>

<li><a href="https://www.modernescpp.com/index.php/a-short-detour-executors">A Short Detour: Executors - ModernesCpp.com</a></li>

<li><b>Java Executor Framework</b>
<ul class="org-ul">
<li><a href="http://technicalstack.com/java-executor-framework-thread-pool/">http://technicalstack.com/java-executor-framework-thread-pool/</a></li>
</ul></li>

<li><b>WG21 - N4046 - Executors and Asynchronous Operations</b> - Christopher Kohlhoff

<ul class="org-ul">
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4046.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4046.pdf</a></li>

<li><p>
Note: Reference implementation of executors library:
</p>

<p>
<a href="http://github.com/chriskohlhoff/executors">http://github.com/chriskohlhoff/executors</a>
</p></li>

<li>Presentation:
<ul class="org-ul">
<li><a href="http://think-async.com/executors/Executors_and_Asynchronous_Operations_Slides.pdf">http://think-async.com/executors/Executors_and_Asynchronous_Operations_Slides.pdf</a></li>
</ul></li>

<li>"This proposal is the asynchronous model that underpins the
P0112R0 Networking Library proposal, and the proposed wording
below is taken from the corresponding sections of P0112R0. In
doing so, it takes design concepts from Boost.Asio, many of
which have been unchanged since its inclusion in Boost, and
repackages them in a way that is more suited to C++14 language
facilities."</li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-org3b9d5f7" class="outline-3">
<h3 id="org3b9d5f7"><span class="section-number-3">1.3</span> Standard Library Reference</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<b>Technical Specifications</b> 
</p>

<ul class="org-ul">
<li>P0159 - Technical Specifiction for Concurrency</li>

<li>P0024 - Technical Specifiction for Parallelism</li>

<li>C++17 Concurrency TS (Technical Specification)</li>
</ul>


<p>
<b>C++11/14 Thread API</b>
</p>

<ul class="org-ul">
<li>std::threads (C++11)</li>
</ul>

<p>
<b>Task Based API</b>
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/promise-class?view=vs-2019">std::promise</a> (Microsoft)</li>

<li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/future?view=vs-2019">std::future</a> (Microsoft)</li>

<li>std::future&lt;&gt;, std::shared_future&lt;&gt;, std::atomic_future&lt;&gt;</li>

<li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/packaged-task-class?view=vs-2019">std::packaged_task</a> (Microsft)</li>

<li>std::async</li>

<li>Function: <a href="https://docs.microsoft.com/en-us/cpp/standard-library/future-functions?view=vs-2019">std::async</a> (Microsft)</li>

<li>std::launch</li>
</ul>

<p>
C++17 Additions: 
</p>

<ul class="org-ul">
<li>Concurrent TS (Nonblocking futures (.then), executors, await)</li>
<li>future::when_any</li>
<li>future::when_all()</li>
<li>future::then()</li>
<li>future::unwrap()</li>
</ul>

<p>
<b>Syncronization Primitives:</b>
</p>

<ul class="org-ul">
<li>Locks 
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a></li>
<li>std::condition_variable</li>
</ul></li>

<li>RAII Wrappers for locks 
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/unique_lock">std::unique_lock&lt;&gt;</a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/lock_guard">std::lock_guard</a> - RAII Wrapper for locks</li>
</ul></li>

<li>Atomic Operations =&gt; Header: <a href="https://en.cppreference.com/w/c/atomic">&lt;atomic&gt;</a>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/atomic/atomic">std::atomic</a></li>
<li>std::atomic_xxx, std::atomic&lt;&gt;, std::atomic_thread_fence()</li>
</ul></li>
</ul>

<p>
<b>Implementations of C++11 Standard Library</b>
</p>

<ul class="org-ul">
<li>Clang LLVM</li>

<li>GNU GCC/G++</li>

<li>MSVC - Microsft Visual C++ Compiler (aka Visual Studio Compiler)</li>

<li>just::thread - commercial implementation by Just Software
Solution for MSVC, GNU GCC/G++ and CLang.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc207429" class="outline-3">
<h3 id="orgc207429"><span class="section-number-3">1.4</span> Papers from WG21 Working Group</h3>
<div class="outline-text-3" id="text-1-4">
<p>
<b>C++11 Thread Local Storage</b>
</p>

<ul class="org-ul">
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm">WG21 - N2659 Thread-Local Storage</a> (C++ Standard Proposal)
<ul class="org-ul">
<li>"Proposal that defines the <span class="underline">thread_local</span> storage class specifier
for C++11."</li>
</ul></li>
</ul>

<p>
<b>Executors and thread-pools</b>
</p>

<ul class="org-ul">
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0761r2.pdf">P0761R2</a> - <b>Executors Design Documentation</b>
<ul class="org-ul">
<li>"This paper is a companion to P0443R4 anddescribes the
executors programming model itspecifies. This paper is directed
toward readers whowant to understand in detail the mechanics
ofP0443’s programming model, and the rationaleunderpinning the
choices of that model’s design."</li>
</ul></li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0443r9.html">P0443r9</a> -  <b>A Unified Executors Proposal for C++</b>
<ul class="org-ul">
<li>"This paper proposes a programming model for executors, which
are modular components for creating execution. The design of
this proposal is described in paper P0761."</li>
</ul></li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3562.pdf">N3562</a> - <b>Executors and Schedulers, Revision1</b>
<ul class="org-ul">
<li>"This paper is a proposal for executors, objects that can
execute units of work packaged asfunction objects, in the form
of an abstract base class and several concrete classes that
inheritfrom it. It is based on components that are heavily used
in internal Google and Microsoft code,with changes to better
match the style of the C++ standard."</li>
</ul></li>
</ul>

<p>
<b>Task-based concurrency API: Futures, Promises, Packaged-task</b>
</p>

<ul class="org-ul">
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3857.pdf">N3857</a> - <b>Improvements to std::future&lt;T&gt; and Related APIs</b>
<ul class="org-ul">
<li>"This proposal is anevolution of the functionality of
std::future/std::shared_future. It details additions which can
enable wait free compositions of asynchronous operations.This
document supersedes N3784. Several typos in the code samples
have been fixed, and a small editorial change made in the
Technical Specification section."</li>
</ul></li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2276.html">N2276</a> - <b>Thread Pools and Futures</b>
<ul class="org-ul">
<li>"At Oxford, the combined EWG and LWG voted to proceed with work
on Thread Pools and Futures for C++0x, even though this work
had previously been destined for TR2. This paper is provided to
further discussions in this area. It draws heavily on N2094 and
N2185."</li>
<li>Note: Provides basic explanation about futures, promises,
packaged_tasks and thread pools concurrency constructs.</li>
</ul></li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2709.html#n2709_packaging_tasks_for_asynchronous_execution.reference.packaged_task">N2709</a> - <b>N2709 Packaging Tasks for Asynchronous Execution</b>
<ul class="org-ul">
<li>"This proposal is based on the proposal for std::packaged_task
in N2561 and N2627. It has been separated from the futures
proposal at the request of the LWG, and revised in light of LWG
comments at the Sophia-Antipolis meeting in June 2008. A
std::packaged_task provides a means of binding a function to an
asynchronous future values so that when the function is
invoked, the asynchronous future value becomes populated,
rather than the return value or exception being propagated to
the caller.. &#x2026;"</li>
</ul></li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2561.html">N2561</a> - <b>N2561: An Asynchronous Future Value</b>
<ul class="org-ul">
<li>"This is a proposal to implement the "Kona concurrency
compromise", i.e. motion SP2 in N2452 and N2453: 'WG21 resolves
that for this revision of the C++ standard (aka "C++0x") the
scope of concurrency extensions shall be constrained as
follows: Include a memory model, atomic operations, threads,
locks, condition variables, and asynchronous future
values. Exclude thread pools, task launching, and reader-writer
locks.'"</li>
</ul></li>
</ul>

<p>
<b>User-space threads, fibers, coroutines</b> 
</p>

<ul class="org-ul">
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf">N4024</a> - <b>Distinguishing coroutines and fibers</b>
<ul class="org-ul">
<li>"The purpose of this paper is to foreshadow a forthcoming
proposal to introduce fibers to the C++ standard library;to
briefly describe the features in the proposed fiber library; and
to contrast it with the coroutine library proposed inN39856.It
is hoped that this comparison will help to clarify the feature
set of the proposed coroutine library. Certain fea-tures
properly belong in the coroutine library; other
conceptually-related features more properly belong in the
fiber library."</li>
</ul></li>
</ul>

<p>
<b>Parallelism and Parallel Algorithms</b> 
</p>

<ul class="org-ul">
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4071.htm">N4071</a> - <b>Working Draft, Technical Specification for C++ Extensions for Parallelism</b>
<ul class="org-ul">
<li>"This Technical Specification describes requirements for
implementations of an interface that computer programs written
in the C++ programming language may use to invoke algorithms
with parallel execution. The algorithms described by this
Technical Specification are realizable across a broad class of
computer architecturesThis Technical Specification is
non-normative. Some of the functionality described by this
Technical Specification may be considered for standardization in
a future version of C++, but it is not currently part of any C++
standard. Some of the functionality in this Technical
Specification may never be standardized, and other functionality
may be standardized in a substantially changed form. The goal of
this Technical Specification is to build widespread existing
practice for parallelism in the C++ standard algorithms
library. It gives advice on extensions to those vendors who wish
to provide them."</li>
</ul></li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4167.pdf">N4167</a> - <b>Transform Reduce, and Additional Algorithm for C++ *Extensions for Parallelism</b>
<ul class="org-ul">
<li>"The goal of this paper is to widen the range of problems that
the C++ standards proposal N4071, A Technical Specification for
C++ Extensions for Parallelism, Revision 1 may
encompass. Offering a greater use case for these algorithms may
help further extend the significanceof this Technical
Specification.This  document describes and  outlines  the
problems  we  have  encountered  with  the  current algorithm
requirements, as specified in standards proposal N4071. The
algorithm described in this document is a solution to a general
set of problems that the current algorithms do not
support. Transform Reduceis to be considered as an addition to
the current set of algorithms in proposal N4071, not a
replacement."</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgd813597" class="outline-3">
<h3 id="orgd813597"><span class="section-number-3">1.5</span> Class std::thread</h3>
<div class="outline-text-3" id="text-1-5">
<p>
The class std::threads <span class="underline">is not thread</span>, it is a proxy for a native
thread and encapsulates a native thread or a kernel thread which the
documentation calls <span class="underline">thread of execution</span>.  
</p>

<p>
Header: 
</p>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/header/thread">&lt;thread&gt;</a></li>
</ul>

<p>
Documentation: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/thread/thread">std::thread</a>  - cppreference</li>

<li><a href="https://docs.microsoft.com/en-us/cpp/standard-library/thread-class?view=vs-2019">std::thread</a> - Microsft MSFT, MSVC</li>

<li><a href="https://www.boost.org/doc/libs/1_71_0/doc/html/thread.html">boost:thread</a>  - Predecessor of the standard library threads</li>

<li><a href="https://www.boost.org/doc/libs/1_71_0/doc/html/thread/thread_management.html">Thread Management - 1.71.0</a> (Boost docs)</li>
</ul>

<p>
Papers related to the standard library implementation: 
</p>

<ul class="org-ul">
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2094.html">WG21 - N2093</a>  - Multithreading API for C++0X - A Layered Approach - 2006-09-09</li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2139.html">WG21 - N2139</a> - Thoughts on a Thread Library for C++ - 2006-11-06</li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html">WG21 - N2184</a> - Thread Launching for C++0X - 2007-03-09</li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2497.html">WG21 - N2497</a> - Multi-threading Library for Standard C++ (Revision 1) - 2008-01-07</li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2320.html">WG21 - N2320</a> - Multi-threading Library for Standard C++ - 2007-06-24</li>
</ul>


<p>
<b>Type of signature of std::thread member functions</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">thread</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">types:</span>
    <span class="org-keyword">class</span> <span class="org-type">id</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">typedef implementation-defined native_handle_type; // See [thread.native]</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">construct/copy/destroy:</span>
    <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">F</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-keyword">explicit</span> <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">F</span> <span class="org-variable-name">f</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">F</span>, <span class="org-keyword">class</span> ...<span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">F</span>&amp;&amp; <span class="org-variable-name">f</span>, <span class="org-type">Args</span>&amp;&amp;... <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    ~<span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">thread</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;

    <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">thread</span>&amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-type">thread</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">thread</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;

    <span class="org-type">thread</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">thread</span>&amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">members:</span>
    <span class="org-type">void</span> <span class="org-function-name">swap</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">thread</span>&amp;&amp;<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-type">bool</span> <span class="org-function-name">joinable</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
    <span class="org-type">void</span> <span class="org-function-name">join</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-type">void</span> <span class="org-function-name">detach</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-type">id</span> <span class="org-function-name">get_id</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>;
    <span class="org-type">native_handle_type</span> <span class="org-function-name">native_handle</span><span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">See [thread.native]</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">static members:</span>
    <span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-function-name">hardware_concurrency</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Detailed Member Functions of class std::thread</b>
</p>

<ul class="org-ul">
<li><span class="underline">Default and move constructors</span></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Default constructor - without any thread of execution </span>
thread<span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">noexcept</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Move constructor </span>
thread<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">thread</span>&amp;&amp; <span class="org-variable-name">Other</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">noexcept</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">Other Constructors</span>
<ul class="org-ul">
<li>The following constructor can take as agument (type parameter
Fn): any function pointer; callable object (aka "functor") or
lambda expression. The thread of execution associated to the
constructed object starts its execution immediately.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Fn</span>, <span class="org-keyword">class</span>... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">explicit</span> <span class="org-function-name">thread</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">Fn</span>&amp;&amp; <span class="org-variable-name">F</span>, <span class="org-type">Args</span>&amp;&amp;... <span class="org-variable-name">A</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Example: Construct thread out of function pointer: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">//</span><span class="org-comment">========= Create thread out of function pointer =======// </span>
<span class="org-type">void</span> <span class="org-function-name">do_forever</span><span class="org-rainbow-delimiters-depth-1">()</span> 
<span class="org-rainbow-delimiters-depth-1">{</span> 
  <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-2">(</span>every 10 seconds<span class="org-rainbow-delimiters-depth-2">){</span> println<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" 10 second elapsed!"</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>  

<span class="org-type">void</span> <span class="org-function-name">action_sleep</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">N</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span> 
   <span class="org-comment-delimiter">// </span><span class="org-comment">.... sleep for N seconds ....</span>
   print<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [INFO] Thread wake up! OK"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">thread</span> <span class="org-variable-name">th1</span> <span class="org-rainbow-delimiters-depth-1">{</span>do_forever<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">thread</span> <span class="org-variable-name">th2</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;do_forever<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-type">thread</span> <span class="org-variable-name">th3</span> <span class="org-rainbow-delimiters-depth-1">{</span>action_sleep, 10<span class="org-rainbow-delimiters-depth-1">}</span>; 
<span class="org-type">thread</span> <span class="org-variable-name">th4</span> <span class="org-rainbow-delimiters-depth-1">{</span>&amp;action_sleep, 1<span class="org-rainbow-delimiters-depth-1">}</span>;   
</pre>
</div>

<p>
Example: construct threads out of function object, aka callable
objects or functors. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Functor</span>
<span class="org-keyword">struct</span> <span class="org-type">LoopMessage</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">message</span>;
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">delay</span>;

    <span class="org-function-name">LoopMessage</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">message</span>, <span class="org-type">int</span> <span class="org-variable-name">delay</span><span class="org-rainbow-delimiters-depth-2">)</span>:
        message<span class="org-rainbow-delimiters-depth-2">(</span>message<span class="org-rainbow-delimiters-depth-2">)</span>
      , delay<span class="org-rainbow-delimiters-depth-2">(</span>delay<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Function-call operator called by the thread class. </span>
    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-type">seconds</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-variable-name">delay</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] thread id = "</span> &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::get_id<span class="org-rainbow-delimiters-depth-4">()</span>
                      &lt;&lt; <span class="org-string">" ; "</span> &lt;&lt; message &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">thread</span> <span class="org-variable-name">thread_messageA</span> <span class="org-rainbow-delimiters-depth-2">{</span>LoopMessage, <span class="org-string">"Hello world"</span>, 10<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">thread_messageB</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">{</span>LoopMessage, <span class="org-string">"Hello world"</span>, 10<span class="org-rainbow-delimiters-depth-2">}</span>; 
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Example: construct thread object out of lambda expressions. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::thread threadA <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](){</span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::seconds<span class="org-rainbow-delimiters-depth-5">(</span>1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>;
       <span class="org-comment-delimiter">// </span><span class="org-comment">... action .... // </span>
    <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">th4</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">N</span><span class="org-rainbow-delimiters-depth-2">){</span>
    <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::seconds<span class="org-rainbow-delimiters-depth-5">(</span>1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">.... action ... // </span>
    <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="org-rainbow-delimiters-depth-2">}</span>, 10<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Note: Before a given std::thread object goes out of scope, it is
necessary to call the methods .join() for waiting for the completion
of associated thread of execution or std::thread::detach() for
detaching the thread of execution. If neither of those functions are
called, the C++ runtime calls <span class="underline">std::terminate</span> and <span class="underline">std::abort()</span>
indirectly which causes abnormal termination of the current
application.  
</p>

<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Failure =&gt; Te runtime will call std::terminate </span>
<span class="org-type">int</span> <span class="org-function-name">Function_error</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::<span class="org-type">thread</span> <span class="org-variable-name">threadA</span> <span class="org-rainbow-delimiters-depth-2">{</span>&amp;functionPointer, 10, <span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
   <span class="org-comment-delimiter">// </span><span class="org-comment">Error: Missing call to methods .detach() or .join() </span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">The runtime will call std::terminate() causing abnormal terminatoon!!</span>
   <span class="org-keyword">return</span> 1;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">OK =&gt; Does not call std::terminate. </span>
<span class="org-type">int</span> <span class="org-function-name">Function_join</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::<span class="org-type">thread</span> <span class="org-variable-name">threadA</span> <span class="org-rainbow-delimiters-depth-2">{</span>&amp;functionPointer, 10, <span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
   <span class="org-comment-delimiter">// </span><span class="org-comment">Ok </span>
   threadA.join<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Wait for completion of threadA. </span>
   <span class="org-keyword">return</span> 1;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">ThreaA out of scope here! </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">OK =&gt; Does not call std::terminate.</span>
<span class="org-type">int</span> <span class="org-function-name">Function_detach</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::<span class="org-type">thread</span> <span class="org-variable-name">threadA</span> <span class="org-rainbow-delimiters-depth-2">{</span>&amp;functionPointer, 10, <span class="org-string">"Hello world"</span><span class="org-rainbow-delimiters-depth-2">}</span>;
   <span class="org-comment-delimiter">// </span><span class="org-comment">Ok </span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Detach, no longer control or manage threadA. </span>
   threadA.detach<span class="org-rainbow-delimiters-depth-2">()</span>; 
   <span class="org-keyword">return</span> 1;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> 
<span class="org-rainbow-delimiters-depth-1">{</span> 
   Function_error<span class="org-rainbow-delimiters-depth-2">()</span>; 
   Function_join<span class="org-rainbow-delimiters-depth-2">()</span>; 
   Function_detach<span class="org-rainbow-delimiters-depth-2">()</span>;

   <span class="org-keyword">return</span> 10; 
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<ul class="org-ul">
<li><span class="underline">joinable()</span>
<ul class="org-ul">
<li>=&gt; Returns true if the thread is <span class="underline">joinable</span>, in other words, if the
thread of execution associated to the called object is running.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">bool</span> <span class="org-function-name">joinable</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">const</span> <span class="org-keyword">noexcept</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">join()</span>
<ul class="org-ul">
<li>=&gt; Blocks the current thread waiting for the completion of the
called object thread. For instance, calling threadA.join() will
block the current thread waiting until the thread of execution of
threadA object finishes.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-constant">thread</span>::<span class="org-function-name">join</span><span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">detach()</span> 
<ul class="org-ul">
<li>=&gt; Detaches the associated thread of execution from a given
std::thread object. After this function is called, it is no
longer possible to control the detached thread of execution or
joining it (waiting for its completion). Then, the std::thread
object no longer represents the detached execution thread.</li>
<li>=&gt; A thread of execution that was detached is also called <span class="underline">daemon thread</span>.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-constant">thread</span>::<span class="org-function-name">detach</span><span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">id()</span>
<ul class="org-ul">
<li>=&gt; Returns the unique ID indentifier number for each thread.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-constant">thread</span>::<span class="org-function-name">id</span> <span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">noexcept</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">hardware_concurrency()</span>
<ul class="org-ul">
<li>=&gt; Returns an estimate for the number of threads that can be run
in parallel. The result is often equal to the number of <span class="underline">logical CPU cores</span>.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">static</span> <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-constant">thread</span>::<span class="org-function-name">hardware_concurrency</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-keyword">noexcept</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-org127417d" class="outline-3">
<h3 id="org127417d"><span class="section-number-3">1.6</span> Functions of namespace std::this_thread</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Utilities functions for currrent thread of execution: 
</p>

<p>
Header: 
</p>
<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread">&lt;header&gt;</a></li>
</ul>

<p>
Function Documentation: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/yield">this_thread::yield</a></li>

<li><a href="https://en.cppreference.com/w/cpp/thread/get_id">this_thread::get_id</a></li>

<li><a href="https://en.cppreference.com/w/cpp/thread/sleep_for">this_thread::sleep_for</a></li>

<li><a href="https://en.cppreference.com/w/cpp/thread/sleep_until">this_thread::sleep_until</a></li>
</ul>

<p>
Signature of functions in namespace this_thread. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Namespace: std::this_thread. </span>
<span class="org-keyword">namespace</span> <span class="org-constant">std</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">namespace</span> <span class="org-constant">this_thread</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns the id of the current thread.</span>
    <span class="org-constant">std</span>::<span class="org-constant">thread</span>::<span class="org-type">id</span> <span class="org-function-name">get_id</span><span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-keyword">noexcept</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Provides a hint to the implementation to reschedule the</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">execution of threads, allowing other threads to run.</span>
    <span class="org-type">void</span>            <span class="org-function-name">yield</span><span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-keyword">noexcept</span>;      
    <span class="org-comment-delimiter">// </span><span class="org-comment">Blocks the execution of the current thread for at least the specified sleep_duration.</span>
    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-3">&lt;</span> <span class="org-keyword">class</span> <span class="org-type">Rep</span>, <span class="org-keyword">class</span> <span class="org-type">Period</span> <span class="org-rainbow-delimiters-depth-3">&gt;</span>
    <span class="org-type">void</span>            <span class="org-function-name">sleep_for</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-type">duration</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Rep</span>, <span class="org-type">Period</span><span class="org-rainbow-delimiters-depth-4">&gt;</span>&amp; <span class="org-variable-name">sleep_duration</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Blocks the execution of the current thread until specified</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">sleep_time has been reached.</span>
    <span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-3">&lt;</span> <span class="org-keyword">class</span> <span class="org-type">Clock</span>, <span class="org-keyword">class</span> <span class="org-type">Duration</span> <span class="org-rainbow-delimiters-depth-3">&gt;</span>
    <span class="org-type">void</span>           <span class="org-function-name">sleep_until</span><span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-type">time_point</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-type">Clock</span>,<span class="org-type">Duration</span><span class="org-rainbow-delimiters-depth-4">&gt;</span>&amp; <span class="org-variable-name">sleep_time</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
 <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org3ca7cc8" class="outline-3">
<h3 id="org3ca7cc8"><span class="section-number-3">1.7</span> Thread - std::thread usage and synchronization primitives</h3>
<div class="outline-text-3" id="text-1-7">
</div>
<div id="outline-container-orgd6ebb17" class="outline-4">
<h4 id="orgd6ebb17"><span class="section-number-4">1.7.1</span> Race condition</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
When the a race condition happens, the outcome of the computation with
a shared resource depends precisely on the order of execution of the
threads. Race condition bugs are hard to trace and debug. The solution
to this flaw is to coordinate the thread access to shared resources
through synchronization primitives, namely, mutex (mutual exclusion
locks), atomic variables, and so on.
</p>

<p>
Most common types of shared resources: 
</p>
<ul class="org-ul">
<li>Global variable or objects such as: std::cout, std::cerr, std::cin</li>
<li>Shared variables between threads</li>
<li>Singleton objects - class with an unique global instance.</li>
</ul>

<p>
C++ Standard definition about <b>Data Race</b> (aka race condition): 
</p>

<blockquote>
<p>
The execution of a program contains a <b>data race</b> if it conains two
potential concurrent conflicting actions, at least one of which is
not atomic, and neither happens before the other, except of the
special case for singnal handlers described below. <b>Any such data</b>
<b>race results</b> in <b>undefined behavior</b>.
</p>
</blockquote>

<p>
C++ Standard about Undefined Behavior: 
</p>

<blockquote>
<p>
A conforming implementation executing a well-formaed program shall
reproduce the same observable behavior as one of the possible
executions of the corresponding instances of the abstract machien
with the smae program and the same input. However, if any such
exeuction contains an undefined operation, this International
Standard places no requirement on the implementation executing that
program with that input.
</p>
</blockquote>

<p>
<b>Example about race condition:</b>
</p>

<p>
Race condition: 
</p>

<ul class="org-ul">
<li>File: race_condtion.cpp</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">struct</span> <span class="org-type">Worker</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span>;

    <span class="org-function-name">Worker</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">acc</span><span class="org-rainbow-delimiters-depth-2">(</span>acc<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::milliseconds<span class="org-rainbow-delimiters-depth-4">(</span>500<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        acc = acc + x * x;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">result</span> = 0;

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">thread_list</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        thread_list.push_back<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-4">{</span>Worker<span class="org-rainbow-delimiters-depth-5">(</span>result<span class="org-rainbow-delimiters-depth-5">)</span>, i<span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: thread_list<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> t.join<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" result   = "</span> &lt;&lt; result &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ thread1.cpp -o <span class="org-keyword">thread1.bin</span> -std=c++1z -Wall -Wextra -O0 -g -lpthread 
</pre>
</div>

<p>
Running: 
</p>
<ul class="org-ul">
<li>The expected result is 385. However, the program sometimes yields
an incorrect result due to a <span class="underline">race condition</span> bug (aka data
race).</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ ./thread1.bin 
 result   = 385

$ ./thread1.bin 
 result   = 384

$ ./thread1.bin 
 result   = 385

$ ./thread1.bin 
 result   = 368

$ ./thread1.bin 
 result   = 385

./thread1.bin 
 result   = 376
</pre>
</div>
</div>
</div>
<div id="outline-container-org9296347" class="outline-4">
<h4 id="org9296347"><span class="section-number-4">1.7.2</span> Debugging Race Conditions with CLang's Sanitizers</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
It is well known that Race condition (aka data races) are hard to
reproduce, trace and debug due to the nondeterminism of concurrent
systems and the result in race condition be dependent on the order
that threads were run. For instance, multiple executions with the same
inputs may lead to different outcomes. 
</p>

<p>
Clang compiler has some <span class="underline">sanitizers</span> and static analysis tools that
helps to debug undefined behavior, memory and race condition. 
</p>

<p>
Clang Sanitizer Tools: 
</p>

<ul class="org-ul">
<li><a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html">Thread Safety Analysis</a> (Static analysis tool =&gt; compiler warning)
<ul class="org-ul">
<li>Compiler switch:  <b>-Wthread-safety</b></li>
<li>Warns about potential race conditions in the code at compile-time.</li>
</ul></li>

<li><a href="https://clang.llvm.org/docs/ThreadSanitizer.html">Thread Sanitizer</a>
<ul class="org-ul">
<li>Compiler switch: <b>-fsanitize=thread</b></li>
<li>Can detect:
<ul class="org-ul">
<li>Race conditions or data races at runtime.</li>
</ul></li>
</ul></li>

<li><a href="https://clang.llvm.org/docs/AddressSanitizer.html">Address Sanitizer</a>
<ul class="org-ul">
<li>Compiler switch: <b>-fsanitize=address</b></li>
<li>Can detect:
<ul class="org-ul">
<li>Out-of-bounds accesses to heap, stack and globals</li>
<li>Use-after-free</li>
<li>Use-after-return (runtime flag ASAN_OPTIONS=detect_stack_use_after_return=1)</li>
<li>Double-free, invalid free</li>
<li>Memory leaks (experimental)</li>
</ul></li>
</ul></li>

<li><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">Undefined Behavior Sanitizer</a>
<ul class="org-ul">
<li>Compiler switch: <b>-fsanitize=undefined</b></li>
<li>Can detect:
<ul class="org-ul">
<li>Using misaligned or null pointer</li>
<li>Signed integer overflow</li>
<li>Conversion to, from, or between floating-point types which
would overflow the destination.</li>
</ul></li>
</ul></li>

<li><a href="https://clang.llvm.org/docs/MemorySanitizer.html">Memory Sanitizer</a>
<ul class="org-ul">
<li>Compiler switch: <b>-fsanitize=memory</b></li>
<li>Can detect:
<ul class="org-ul">
<li>Uninitialized reads (reading of unitialized variables)</li>
</ul></li>
</ul></li>
</ul>

<p>
Example: Using Clang sanitizer tools for race condition detection: 
</p>

<ul class="org-ul">
<li>File: flawed-program.cpp</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">struct</span> <span class="org-type">Worker</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span>;

    <span class="org-function-name">Worker</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span><span class="org-rainbow-delimiters-depth-2">)</span>: <span class="org-function-name">acc</span><span class="org-rainbow-delimiters-depth-2">(</span>acc<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::milliseconds<span class="org-rainbow-delimiters-depth-4">(</span>500<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        acc = acc + x * x;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span> <span class="org-variable-name">result</span> = 0;

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">thread_list</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        thread_list.push_back<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-4">{</span>Worker<span class="org-rainbow-delimiters-depth-5">(</span>result<span class="org-rainbow-delimiters-depth-5">)</span>, i<span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: thread_list<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> t.join<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" result   = "</span> &lt;&lt; result &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Compiler swiches: </span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">=&gt;&gt; -O0                  Disable optimization </span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">=&gt;&gt; -g                   Enable debug building </span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">=&gt;&gt; -Wthread-safety      Enable Clang compiler warning for race conditions</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">=&gt;&gt; -fsanitize=thread    Enable thread sanitizer </span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">=&gt;&gt; -fsanitize=undefined Eanble undefined behavior sanitizer </span>
$ clang++ flawed-program.cpp -o <span class="org-keyword">out.bin</span> -O0 -g -lpthread -Wall -Wextra -pedantic <span class="org-sh-escaped-newline">\</span>
    -Wthread-safety <span class="org-sh-escaped-newline">\</span>
    -fsanitize=thread <span class="org-sh-escaped-newline">\</span>
    -fsanitize=undefined 
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./out.bin 

==================
<span class="org-function-name">WARNING</span>: ThreadSanitizer: data race (<span class="org-variable-name">pid</span>=22979)
  Read of size 4 at 0x7ffdb2ae1b78 by thread T2:
    <span class="org-comment-delimiter">#</span><span class="org-comment">0 Worker::operator()(int) /Users/dummy/projects/cmake-experiment/flawed-program.cpp:16:17 (out.bin+0x4b7516)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">1 void std::__invoke_impl&lt;void, Worker, int&gt;(std::__invoke_other, Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:60:14 (out.bin+0x4b7421)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">2 std::__invoke_result&lt;Worker, int&gt;::type std::__invoke&lt;Worker, int&gt;(Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:95:14 (out.bin+0x4b7026)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">3 _ZNSt6thread8_InvokerISt5tupleIJ6WorkeriEEE9_M_invokeIJLm0ELm1EEEEDTclsr3stdE8__invokespcl10_S_declvalIXT_EEEEESt12_Index_tupleIJXspT_EEE /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:244:13 (out.bin+0x4b6eb6)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">4 std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt;::operator()() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:253:11 (out.bin+0x4b6ca8)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">5 std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt; &gt;::_M_run() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:196:13 (out.bin+0x4b5fe7)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">6 &lt;null&gt; &lt;null&gt; (libstdc++.so.6+0xbf5c2)</span>

  Previous write of size 4 at 0x7ffdb2ae1b78 by thread T1:
    <span class="org-comment-delimiter">#</span><span class="org-comment">0 Worker::operator()(int) /Users/dummy/projects/cmake-experiment/flawed-program.cpp:16:15 (out.bin+0x4b75c6)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">1 void std::__invoke_impl&lt;void, Worker, int&gt;(std::__invoke_other, Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:60:14 (out.bin+0x4b7421)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">2 std::__invoke_result&lt;Worker, int&gt;::type std::__invoke&lt;Worker, int&gt;(Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:95:14 (out.bin+0x4b7026)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">3 _ZNSt6thread8_InvokerISt5tupleIJ6WorkeriEEE9_M_invokeIJLm0ELm1EEEEDTclsr3stdE8__invokespcl10_S_declvalIXT_EEEEESt12_Index_tupleIJXspT_EEE /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:244:13 (out.bin+0x4b6eb6)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">4 std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt;::operator()() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:253:11 (out.bin+0x4b6ca8)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">5 std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt; &gt;::_M_run() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:196:13 (out.bin+0x4b5fe7)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">6 &lt;null&gt; &lt;null&gt; (libstdc++.so.6+0xbf5c2)</span>

  As if synchronized via sleep:
    <span class="org-comment-delimiter">#</span><span class="org-comment">0 nanosleep &lt;null&gt; (out.bin+0x43565e)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">1 void std::this_thread::sleep_for&lt;long, std::ratio&lt;1l, 1000l&gt; &gt;(std::chrono::duration&lt;long, std::ratio&lt;1l, 1000l&gt; &gt; const&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:379:9 (out.bin+0x4b7798)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">2 Worker::operator()(int) /Users/dummy/projects/cmake-experiment/flawed-program.cpp:15:11 (out.bin+0x4b74ef)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">3 void std::__invoke_impl&lt;void, Worker, int&gt;(std::__invoke_other, Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:60:14 (out.bin+0x4b7421)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">4 std::__invoke_result&lt;Worker, int&gt;::type std::__invoke&lt;Worker, int&gt;(Worker&amp;&amp;, int&amp;&amp;) /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/bits/invoke.h:95:14 (out.bin+0x4b7026)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">5 _ZNSt6thread8_InvokerISt5tupleIJ6WorkeriEEE9_M_invokeIJLm0ELm1EEEEDTclsr3stdE8__invokespcl10_S_declvalIXT_EEEEESt12_Index_tupleIJXspT_EEE /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:244:13 (out.bin+0x4b6eb6)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">6 std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt;::operator()() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:253:11 (out.bin+0x4b6ca8)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">7 std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Worker, int&gt; &gt; &gt;::_M_run() /usr/bin/../lib/gcc/x86_64-redhat-linux/8/../../../../include/c++/8/thread:196:13 (out.bin+0x4b5fe7)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">8 &lt;null&gt; &lt;null&gt; (libstdc++.so.6+0xbf5c2)</span>

  Location is stack of main thread.

  Location is global <span class="org-string">'??'</span> at 0x7ffdb2ac4000 ([stack]+0x00000001db78)

  Thread T2 (<span class="org-variable-name">tid</span>=22982, running) created by main thread at:
    <span class="org-comment-delimiter">#</span><span class="org-comment">0 pthread_create &lt;null&gt; (out.bin+0x425eba)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">1 std::thread::_M_start_thread(std::unique_ptr&lt;std::thread::_State, std::default_delete&lt;std::thread::_State&gt; &gt;, void (*)()) &lt;null&gt; (libstdc++.so.6+0xbf8a8)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">2 main /Users/dummy/projects/cmake-experiment/flawed-program.cpp:27:34 (out.bin+0x4b3304)</span>

  Thread T1 (<span class="org-variable-name">tid</span>=22981, finished) created by main thread at:
    <span class="org-comment-delimiter">#</span><span class="org-comment">0 pthread_create &lt;null&gt; (out.bin+0x425eba)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">1 std::thread::_M_start_thread(std::unique_ptr&lt;std::thread::_State, std::default_delete&lt;std::thread::_State&gt; &gt;, void (*)()) &lt;null&gt; (libstdc++.so.6+0xbf8a8)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">2 main /Users/dummy/projects/cmake-experiment/flawed-program.cpp:27:34 (out.bin+0x4b3304)</span>

<span class="org-function-name">SUMMARY</span>: ThreadSanitizer: data race /Users/dummy/projects/cmake-experiment/flawed-program.cpp:16:17<span class="org-keyword"> in</span> Worker::operator()(int)
==================
 result   = 304
<span class="org-function-name">ThreadSanitizer</span>: reported 1 warnings

</pre>
</div>

<p>
The santizer found a <span class="underline">data race</span> in the line 16 and column 17 of the
file: flawed-program.cpp 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-function-name">SUMMARY</span>: ThreadSanitizer: data race /Users/... ..../flawed-program.cpp:16:17<span class="org-keyword"> in</span> Worker::operator()(int)
</pre>
</div>

<p>
The data race is in the following line where a reference to a variable
is modified by multiple threads without any lock or mutex. 
</p>

<div class="org-src-container">
<pre class="src src-cpp">acc = acc + x * x;
</pre>
</div>
</div>
</div>

<div id="outline-container-org47f8d04" class="outline-4">
<h4 id="org47f8d04"><span class="section-number-4">1.7.3</span> Mutex solution</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
The race condition can be solved by using <b>mutex</b> - mutual exclusion
synchronization primitive which allows only a single thread at a time
to access the critical section, portion of the code with a shared
resource.   
</p>

<p>
File: thread2.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;

<span class="org-keyword">struct</span> <span class="org-type">Worker</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Requires &lt;mutex&gt; header</span>
    <span class="org-constant">std</span>::<span class="org-type">mutex</span>&amp; <span class="org-variable-name">m</span>;

    <span class="org-function-name">Worker</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span>&amp; <span class="org-variable-name">acc</span>, <span class="org-constant">std</span>::<span class="org-type">mutex</span>&amp; <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-2">)</span>: acc<span class="org-rainbow-delimiters-depth-2">(</span>acc<span class="org-rainbow-delimiters-depth-2">)</span>, m<span class="org-rainbow-delimiters-depth-2">(</span>m<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::milliseconds<span class="org-rainbow-delimiters-depth-4">(</span>500<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">--- Start of critical section ---- //</span>
        m.lock<span class="org-rainbow-delimiters-depth-3">()</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">Curren thread acquire locks</span>
        acc = acc + x * x;
        m.unlock<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Current thread releases lock</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">--- End of critical section ---- //</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Shared resource</span>
    <span class="org-type">int</span> <span class="org-variable-name">result</span> = 0;
    <span class="org-constant">std</span>::<span class="org-type">mutex</span> <span class="org-variable-name">m</span>;

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">thread_list</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        thread_list.push_back<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-4">{</span><span class="org-variable-name">Worker</span><span class="org-rainbow-delimiters-depth-5">(</span>result, m<span class="org-rainbow-delimiters-depth-5">)</span>, <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: thread_list<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> t.join<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" result   = "</span> &lt;&lt; result &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ thread2.cpp -o <span class="org-keyword">thread2.bin</span> -std=c++1z -Wall -Wextra -O0 -g -lpthread 
</pre>
</div>

<p>
Running:  
</p>

<ul class="org-ul">
<li>The computation becomes reproducible and predictable due to the
mutex allow only a single thread at atime access the shared
resource (variable result).</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">$ ./thread2.bin 
 result   = 385

$ ./thread2.bin 
 result   = 385

$ ./thread2.bin 
 result   = 385

$ ./thread2.bin 
 result   = 385


$ ./thread2.bin 
 result   = 385
</pre>
</div>

<p>
Note: The current code is not exception safe and error prone, as a
result if an exception happens or if the lock releasing code is
missing, the outcome will be a <span class="underline">deadlock.</span> It is better to use the
std::mutex_guard which is an RAII (Resource Acquisition Is
Initialization) wrapper for locks. When the mutex guard object is
constructed, the current thread acquires the lock and when the guard
goes out of scope, the mutex lock is released. So, by using a
<span class="underline">scope_guard</span>, the code becomes:
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-1">()</span></span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::milliseconds<span class="org-rainbow-delimiters-depth-3">(</span>500<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">--- Start of critical section ---- //</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Acquires lock </span>
    <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">mutex_guard</span><span class="org-rainbow-delimiters-depth-2">(</span>m<span class="org-rainbow-delimiters-depth-2">)</span>;
    acc = acc + x * x;
    <span class="org-comment-delimiter">// </span><span class="org-comment">--- End of critical section ---- //</span>
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">Releases lock here, when the mutex_guard goes out of scope and is destroyed. </span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org78bb4fa" class="outline-4">
<h4 id="org78bb4fa"><span class="section-number-4">1.7.4</span> Atomic variable solution</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
Another way to solve the race condition (aka data race) problem is
using <span class="underline">atomic variables and atomic operations</span>. 
</p>

<p>
File: thread3.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">atomic</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;

<span class="org-keyword">struct</span> <span class="org-type">Worker</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">atomic</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>&amp; <span class="org-variable-name">acc</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Requires &lt;mutex&gt; header</span>
    <span class="org-constant">std</span>::<span class="org-type">mutex</span>&amp; <span class="org-variable-name">m</span>;

    <span class="org-function-name">Worker</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">atomic</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">acc</span>, <span class="org-constant">std</span>::<span class="org-type">mutex</span>&amp; <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-2">)</span>
       : acc<span class="org-rainbow-delimiters-depth-2">(</span>acc<span class="org-rainbow-delimiters-depth-2">)</span>, m<span class="org-rainbow-delimiters-depth-2">(</span>m<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name"><span class="org-rainbow-delimiters-depth-2">()</span></span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::milliseconds<span class="org-rainbow-delimiters-depth-4">(</span>500<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        acc += x * x;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Shared resource</span>
    <span class="org-constant">std</span>::<span class="org-type">atomic</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">result</span> = 0;
    <span class="org-constant">std</span>::<span class="org-type">mutex</span> <span class="org-variable-name">m</span>;

    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">thread_list</span><span class="org-rainbow-delimiters-depth-2">{}</span>;
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 1; i &lt;= 10; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        thread_list.push_back<span class="org-rainbow-delimiters-depth-3">(</span> <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-4">{</span><span class="org-variable-name">Worker</span><span class="org-rainbow-delimiters-depth-5">(</span>result, m<span class="org-rainbow-delimiters-depth-5">)</span>, <span class="org-variable-name">i</span><span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">t</span>: thread_list<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> t.join<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" result   = "</span> &lt;&lt; result &lt;&lt; <span class="org-constant">std</span>::endl;

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./thread3.bin 
 result   = 385

$ ./thread3.bin 
 result   = 385

$ ./thread3.bin 
 result   = 385

$ ./thread3.bin 
 result   = 385
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3572087" class="outline-3">
<h3 id="org3572087"><span class="section-number-3">1.8</span> Thread - Returning values from std::thread</h3>
<div class="outline-text-3" id="text-1-8">
</div>
<div id="outline-container-org7c0c47e" class="outline-4">
<h4 id="org7c0c47e"><span class="section-number-4">1.8.1</span> Return value from thread</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
There is no way to return a value from a std::thread computaiton, if a
function used for instantiating std::thread has any returning value it
is ignored.  
</p>

<p>
Example: 
</p>

<div class="org-src-container">
<pre class="src src-cpp">  <span class="org-type">double</span> <span class="org-function-name">heavy_computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">doube</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-rainbow-delimiters-depth-1">{</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">do something .... heavy calculation </span>
      <span class="org-keyword">return</span> output; 
  <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-comment-delimiter">// </span><span class="org-comment">Return value ignored. </span>
 <span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-1">(</span> &amp;heavy_computation, 10<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">... ... ... </span>

 th.join<span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<p>
The workaround for returning a value out of std::thread is to set a
variable defined outside of the thread or set a parameter passed as
pointer or reference.
</p>

<ul class="org-ul">
<li>Return value from thread by setting a variable defined outside of
the thread.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-type">double</span> <span class="org-variable-name">output</span> = 0.0;

 <span class="org-comment-delimiter">// </span><span class="org-comment">Return value ignored. </span>
 <span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-1">(</span> &amp;<span class="org-rainbow-delimiters-depth-2">[</span>&amp;<span class="org-rainbow-delimiters-depth-2">]</span>
          <span class="org-rainbow-delimiters-depth-2">{</span> 
             <span class="org-comment-delimiter">// </span><span class="org-comment">perform heavy computation // </span>
              .... 
             <span class="org-comment-delimiter">/* </span><span class="org-comment">set output */</span>
             output =  .... 
          <span class="org-rainbow-delimiters-depth-2">}</span>, 10<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">... ... ... </span>

 th.join<span class="org-rainbow-delimiters-depth-1">()</span>;
 printf<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">" output = %f"</span>, output<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>


<ul class="org-ul">
<li>Return value from thread by setting the function parameters passed
by reference or pointer.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">void</span> <span class="org-function-name">heavy_computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">doube</span> <span class="org-variable-name">input</span>, <span class="org-type">double</span>&amp; <span class="org-variable-name">output1</span>, <span class="org-type">double</span>* <span class="org-variable-name">output2</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">do something .... heavy calculation </span>
    output1 =  .... ;
    *output2 = <span class="org-string">"Something else ...."</span>; 
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">double</span>      <span class="org-variable-name">output1</span> = 0.0; 
<span class="org-function-name">std</span>::string output2 = <span class="org-string">""</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-1">(</span>&amp;heavy_computation, <span class="org-constant">std</span>::ref<span class="org-rainbow-delimiters-depth-2">(</span>output1<span class="org-rainbow-delimiters-depth-2">)</span>, &amp;output2<span class="org-rainbow-delimiters-depth-1">)</span>;
th.join<span class="org-rainbow-delimiters-depth-1">()</span>;

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" output1 = "</span> &lt;&lt; output1 <span class="org-string">" ; "</span> &lt;&lt; <span class="org-string">" output2 = "</span> &lt;&lt; output2 &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc9bc662" class="outline-4">
<h4 id="orgc9bc662"><span class="section-number-4">1.8.2</span> Catch exceptions in threads</h4>
<div class="outline-text-4" id="text-1-8-2">
<p>
If any exception is thrown in a std::thread, the exception is not
propagated to the try &#x2026; catch block outside of the thread, instead
the C++ runtime calls std::terminate causing abonormal termination. 
</p>

<p>
<b>Example: code does not work =&gt; calls std::terminate</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">auto</span> <span class="org-variable-name">do_something</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">....  .... // </span>
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>input &lt; 0 <span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::logic_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Invalid input"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
   <span class="org-comment-delimiter">//</span><span class="org-comment">.... ... ... ... //</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">DOES NOT WORK =&gt;&gt;&gt; C++ runtime calls std::terminate !!!</span>
<span class="org-keyword">try</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span>do_something, -10<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">logic_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Error: "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>.;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<b>Example: Solution</b> 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-function-name">std</span>::exception_ptr exptr = <span class="org-constant">nullptr</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">do_something</span> = <span class="org-rainbow-delimiters-depth-1">[</span>&amp;<span class="org-rainbow-delimiters-depth-1">](</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-2">{</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">....  .... // </span>
   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>input &lt; 0 <span class="org-rainbow-delimiters-depth-3">){</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::logic_error<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Invalid input"</span><span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
   <span class="org-comment-delimiter">//</span><span class="org-comment">.... ... ... ... //</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Catch all exceptions </span>
  <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-2">(</span>...<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
      exception_ptr = <span class="org-constant">std</span>::current_exception<span class="org-rainbow-delimiters-depth-3">()</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">try</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span>do_something, -10<span class="org-rainbow-delimiters-depth-2">)</span>;
   th.join<span class="org-rainbow-delimiters-depth-2">()</span>; 
   <span class="org-constant">std</span>::rethrow_exception<span class="org-rainbow-delimiters-depth-2">(</span>exptr<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">logic_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Error: "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>.;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orga8c5559" class="outline-4">
<h4 id="orga8c5559"><span class="section-number-4">1.8.3</span> Example: Returning values and catching exceptions</h4>
<div class="outline-text-4" id="text-1-8-3">
<p>
File: return-thread.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Experiment returning results from threads</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">---------------------------------------------</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;
<span class="org-keyword">namespace</span> <span class="org-constant">cr</span> = <span class="org-constant">std</span>::chrono;

<span class="org-keyword">struct</span> <span class="org-type">Timer</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">cr</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-variable-name">start</span>;

    <span class="org-function-name">Timer</span><span class="org-rainbow-delimiters-depth-2">(){</span>  start = <span class="org-constant">cr</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span>;  <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">Timer</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">end</span> = <span class="org-constant">cr</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">duration</span> = <span class="org-constant">cr</span>::duration_cast<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">cr</span>::seconds<span class="org-rainbow-delimiters-depth-3">&gt;(</span>end - start<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Elapsed time: "</span> &lt;&lt; duration.count<span class="org-rainbow-delimiters-depth-3">()</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-type">double</span> <span class="org-function-name">heavy_computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">string_literals</span>;

    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>4s<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>input &lt; 0<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Error: invalid input: "</span>s + <span class="org-constant">std</span>::to_string<span class="org-rainbow-delimiters-depth-4">(</span>input<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> input * 3.815 + 5.6;
<span class="org-rainbow-delimiters-depth-1">}</span>


<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>* <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>         <span class="org-variable-name">inputs</span><span class="org-rainbow-delimiters-depth-2">{</span>2, 10, 5<span class="org-rainbow-delimiters-depth-2">}</span>;
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>      <span class="org-variable-name">results</span><span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">threads</span>;
    threads.reserve<span class="org-rainbow-delimiters-depth-2">(</span>3<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Note: A std::thread will never return anything from a function</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">passed as argument, even if has non-void return type.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">The only to return a value from a thread is to set an</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">argument passed by pointer or reference or set a global object.</span>
    <span class="org-keyword">auto</span> <span class="org-variable-name">thread_adapter</span> = <span class="org-rainbow-delimiters-depth-2">[</span>&amp;<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">size_t</span> <span class="org-variable-name">index</span>, <span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        results<span class="org-rainbow-delimiters-depth-3">[</span>index<span class="org-rainbow-delimiters-depth-3">]</span> = heavy_computation<span class="org-rainbow-delimiters-depth-3">(</span>input<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>;

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n ===== Experiment 1 - Return value from threads (Parallel Computing) ==== \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-rainbow-delimiters-depth-2">{</span>   <span class="org-comment-delimiter">// </span><span class="org-comment">Shows elapsed time at end of this scope</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">timer</span> = Timer<span class="org-rainbow-delimiters-depth-3">{}</span>;

        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; 3; i++<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            threads.push_back<span class="org-rainbow-delimiters-depth-4">(</span> <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-5">(</span>thread_adapter, i, inputs<span class="org-rainbow-delimiters-depth-6">[</span>i<span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [INFO] Waiting for thread completion"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Wait for the completion of all threads</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; 3; i++<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> threads<span class="org-rainbow-delimiters-depth-4">[</span>i<span class="org-rainbow-delimiters-depth-4">]</span>.join<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Show results</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; 3; i++<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::printf<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">" Result[%lu] = %f\n"</span>, i, results<span class="org-rainbow-delimiters-depth-5">[</span>i<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">///</span><span class="org-comment">---------------------------------------------------------------//</span>
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n ===== Dealing with exceptions from threads ==== \n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-type">double</span> <span class="org-variable-name">output</span> = 0.0;
    <span class="org-constant">std</span>::<span class="org-type">exception_ptr</span> <span class="org-variable-name">exptr</span> = <span class="org-constant">nullptr</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">thread_adapter2</span> = <span class="org-rainbow-delimiters-depth-2">[</span>&amp;<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" [TRACE] Inside thread_adapter2"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Note: if an exception is not caught,</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">it will not be propagated to the parent thread.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Instead, the C++ runtime will call std::terminate</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">causing abonormal temrination.</span>
        <span class="org-keyword">try</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            output = heavy_computation<span class="org-rainbow-delimiters-depth-4">(</span>input<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-3">(</span>...<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">Catch all exceptions from the computation that</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">should run in a new thread and set a shared memory variable</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">set only once by this thread.</span>
            exptr = <span class="org-constant">std</span>::current_exception<span class="org-rainbow-delimiters-depth-4">()</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span>thread_adapter2, -10<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">" [TRACE] Waiting thread_adapter2 thread termination."</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    th.join<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-negation-char">!</span>exptr<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Result of thread_adapter2 is: "</span> &lt;&lt; output &lt;&lt; <span class="org-string">"\n"</span>;

    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-keyword">else</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">try</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::rethrow_exception<span class="org-rainbow-delimiters-depth-4">(</span>exptr<span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-type">runtime_error</span>&amp; <span class="org-variable-name">err</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [ERROR] "</span> &lt;&lt; err.what<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>

</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ return-thread.cpp -o <span class="org-keyword">out.bin</span> -std=c++1z -O0 -g -lpthread
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./out.bin 

 ===== Experiment 1 - Return value from threads (Parallel Computing) ==== 

 [INFO] Waiting for thread completion
 Result[0] = 13.230000
 Result[1] = 43.750000
 Result[2] = 24.675000
 [TRACE] Elapsed time: 4

 ===== Dealing with exceptions from threads ==== 

 [TRACE] Waiting thread_adapter2 thread termination.
 [TRACE] Inside thread_adapter2
 [ERROR] Error: invalid input: -10

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org53b903e" class="outline-3">
<h3 id="org53b903e"><span class="section-number-3">1.9</span> Thread Local Variables and TLS - Thread Local Storage</h3>
<div class="outline-text-3" id="text-1-9">
<p>
The keyword <b>thread local</b>, added in C+11, ensures that a new instance of a
global or static variable is created for every thread using the
variable. 
</p>

<ul class="org-ul">
<li>A variable with this annotation is implicitly static and has <span class="underline">thread</span>
<span class="underline">_storage duration</span>, its lifetime is bound to the thread lifetime.</li>

<li>Every using a variable annotated as <span class="underline">thread local</span> has its own copy
of it, therefore any modification to the variable inside the thread
will not have any effect for other threads.</li>

<li>Allocation and memory release:
<ul class="org-ul">
<li>Variables declared with <span class="underline">thread_local</span> storage class specifier are
allocated on a per-thread base, instantiated when the thread is
created and destroyed when its thread terminates.</li>
</ul></li>

<li>Thread local variables can be declared:

<ul class="org-ul">
<li>Globally</li>

<li>In namespaces</li>

<li>As class static member variable</li>

<li>Inside functions. It has the same effect as variables allocated
with <span class="underline">static</span> keyword that persist the variable value between
function calls.</li>
</ul></li>

<li>Thread local storage is implemented by the operating system and is
o.s. specific. The <b>thrad_local</b> keyword provide a uniform way to use
<span class="underline">thread local storage</span> (TLS) capabilities of many operating systems
and avoid compiler-specific language extensions for accessing the
TLS feature.

<ul class="org-ul">
<li>Windows API TLS: TlsSetValue(), TlsGetValue(), TlsFree() &#x2026;</li>

<li>MSVC Compiler language extension: __declspec(thread)</li>

<li>GCC Compiler language extension for TLS: __thread int var = 0;</li>
</ul></li>

<li>If use of a C++11 compiler is not possible, the Boost library
provides the container <a href="https://www.boost.org/doc/libs/1_71_0/doc/html/thread/thread_local_storage.html">boost:thread_specific_ptr</a> which provides
portable thread local storage.</li>
</ul>

<p>
<b>Example:</b>
</p>

<p>
File: thread-local.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cassert</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-warning">thread_local</span> <span class="org-type">int</span> tls_variable = 100;

<span class="org-function-name">std</span>::mutex cout_mutex;

<span class="org-type">void</span> <span class="org-function-name">worker_function</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">offset</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    tls_variable = tls_variable + offset;
    <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::lock_guard<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-2">&gt;(</span>cout_mutex<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Thread ID = "</span>           &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::get_id<span class="org-rainbow-delimiters-depth-2">()</span>
              &lt;&lt; <span class="org-string">" ; &amp;tls_variable = "</span>     &lt;&lt; &amp;tls_variable
              &lt;&lt; <span class="org-string">" ; VALUE(tls_variable) "</span> &lt;&lt; tls_variable
              &lt;&lt; <span class="org-constant">std</span>::endl;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Note: 'thread_local' is similar to declare 'static int n = 0'</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">that persist the variable n state between function</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">calls. However, unlike 'static', the thread_local annotation</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">ensure that there will be a copy of the variable 'n' for</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">every thread.</span>
<span class="org-type">void</span> <span class="org-function-name">log_counter</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">bool</span> <span class="org-variable-name">show_counter</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">thread_name</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Same as declaring: 'static thread_local int n = 0;'</span>
    <span class="org-warning">thread_local</span> <span class="org-type">int</span> n = 0;
    n++;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>show_counter<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::lock_guard<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-3">&gt;(</span>cout_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [LOGGER] Called by THREAD_ID = "</span>
                  &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::get_id<span class="org-rainbow-delimiters-depth-3">()</span>
                  &lt;&lt; <span class="org-string">" ; THREAD_NAME = "</span> &lt;&lt; thread_name
                  &lt;&lt; <span class="org-string">" ; ADDRESS(n) = "</span>  &lt;&lt; &amp;n
                  &lt;&lt; <span class="org-string">" ; COUNTER  = "</span>    &lt;&lt; n
                  &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>** <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n=== EXPERIMENT A ========================================\n"</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Only modified for the main thread</span>
    tls_variable = 25;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Before =&gt; MAIN Thread ID = "</span> &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::get_id<span class="org-rainbow-delimiters-depth-2">()</span>
              &lt;&lt; <span class="org-string">" ; &amp;tls_variable = "</span>                 &lt;&lt; &amp;tls_variable
              &lt;&lt; <span class="org-string">" ; VALUE(tls_variable) "</span>             &lt;&lt; tls_variable
              &lt;&lt; <span class="org-constant">std</span>::endl;


    <span class="org-keyword">auto</span> <span class="org-variable-name">t1</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span>worker_function, 15<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">t2</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span>worker_function, 20<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">t3</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span>worker_function, 90<span class="org-rainbow-delimiters-depth-2">)</span>;

    t1.join<span class="org-rainbow-delimiters-depth-2">()</span>;
    t2.join<span class="org-rainbow-delimiters-depth-2">()</span>;
    t3.join<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] After =&gt; MAIN Thread ID = "</span> &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::get_id<span class="org-rainbow-delimiters-depth-2">()</span>
              &lt;&lt; <span class="org-string">" ; &amp;tls_variable = "</span>                 &lt;&lt; &amp;tls_variable
              &lt;&lt; <span class="org-string">" ; VALUE(tls_variable) "</span>             &lt;&lt; tls_variable
              &lt;&lt; <span class="org-constant">std</span>::endl;

    assert<span class="org-rainbow-delimiters-depth-2">(</span>tls_variable == 25<span class="org-rainbow-delimiters-depth-2">)</span>;


    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n=== EXPERIMENT B == Thread local storage and functions ====\n"</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">th1</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[]{</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 10; ++i<span class="org-rainbow-delimiters-depth-4">)</span> log_counter<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">false</span>, <span class="org-string">"th1"</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-4">(</span>2s<span class="org-rainbow-delimiters-depth-4">)</span>;
        log_counter<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">true</span>, <span class="org-string">"th1"</span><span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">th2</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[]{</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 20; ++i<span class="org-rainbow-delimiters-depth-4">)</span> log_counter<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">false</span>, <span class="org-string">"th2"</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-4">(</span>1s<span class="org-rainbow-delimiters-depth-4">)</span>;
        log_counter<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">true</span>, <span class="org-string">"th2"</span><span class="org-rainbow-delimiters-depth-4">)</span>;
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    log_counter<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">false</span>, <span class="org-string">"main"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    log_counter<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">false</span>, <span class="org-string">"main"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    log_counter<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">false</span>, <span class="org-string">"main"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    log_counter<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">true</span>,  <span class="org-string">"main"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    th1.join<span class="org-rainbow-delimiters-depth-2">()</span>;
    th2.join<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ thread-local.cpp -o <span class="org-keyword">out.bin</span> -std=c++1z -O0 -g -lpthread -Wall -Wextra
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./out.bin 

=== EXPERIMENT A ========================================
 [INFO] Before =&gt; MAIN Thread ID = 140391161767744 ; &amp;tls_variable = 0x7faf5d53a738 ; VALUE(tls_variable) 25
 [INFO] Thread ID = 140391143909120 ; &amp;tls_variable = 0x7faf5c4326f8 ; VALUE(tls_variable) 115
 [INFO] Thread ID = 140391135516416 ; &amp;tls_variable = 0x7faf5bc316f8 ; VALUE(tls_variable) 120
 [INFO] Thread ID = 140391127123712 ; &amp;tls_variable = 0x7faf5b4306f8 ; VALUE(tls_variable) 190
 [INFO] After =&gt; MAIN Thread ID = 140391161767744 ; &amp;tls_variable = 0x7faf5d53a738 ; VALUE(tls_variable) 25

=== EXPERIMENT B == Thread local storage and functions ====
 [LOGGER] Called by THREAD_ID = 140391161767744 ; THREAD_NAME = main ; ADDRESS(n) = 0x7faf5d53a73c ; COUNTER  = 4
 [LOGGER] Called by THREAD_ID = 140391135516416 ; THREAD_NAME = th2 ; ADDRESS(n) = 0x7faf5bc316fc ; COUNTER  = 21
 [LOGGER] Called by THREAD_ID = 140391127123712 ; THREAD_NAME = th1 ; ADDRESS(n) = 0x7faf5b4306fc ; COUNTER  = 11
</pre>
</div>


<p>
<b>References:</b>
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/language/storage_duration">Storage class specifiers - cppreference.com</a></li>

<li><a href="https://docs.microsoft.com/en-us/cpp/cpp/storage-classes-cpp?view=vs-2019">Storage classes (C++) | Microsoft Docs</a></li>

<li><a href="https://docs.microsoft.com/en-us/cpp/parallel/thread-local-storage-tls?view=vs-2019">Thread Local Storage (TLS) | Microsoft Docs</a></li>

<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm">WG21 - N2659 Thread-Local Storage</a> (C++ Standard Proposal)
<ul class="org-ul">
<li>"Proposal that defines the <span class="underline">thread_local</span> storage class specifier
for C++11."</li>
</ul></li>

<li><a href="https://sites.google.com/site/sireeshajakku/cpp/tls---thread-local-storage">TLS - Thread Local Storage - sireeshajakku</a></li>

<li><a href="https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_74/rzahw/rzahwdatco.htm">Data that is private to a thread</a></li>

<li><a href="https://www.installsetupconfig.com/win32programming/windowsthreadsprocessapis7_23.html">The Win32 Windows Thread Local Storage Program Example</a></li>

<li><a href="https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html">Chapter 8 Thread-Local Storage (Linker and Libraries Guide)</a></li>
</ul>

<p>
<b>Further Reading:</b>
</p>

<ul class="org-ul">
<li><a href="http://david-grs.github.io/tls_performance_overhead_cost_linux/">TLS performance overhead and cost on GNU/Linux</a></li>

<li><a href="https://testbit.eu/2015/thread-local-storage-benchmark">Thread-Local-Storage Benchmark | Timj’s bits and tests</a></li>

<li><a href="https://software.intel.com/en-us/blogs/2011/05/02/the-hidden-performance-cost-of-accessing-thread-local-variables">The hidden performance cost of accessing thread-local variables |Intel® Software</a></li>

<li><a href="https://blog.knatten.org/2012/06/15/avoiding-heap-allocations-with-static-thread-locals/">Avoiding Heap Allocations With Static Thread Locals – C++ on a Friday</a></li>

<li><a href="https://www.codeproject.com/Tips/875963/Multi-Instance-Thread-Local-Storage">Multi Instance Thread Local Storage - CodeProject</a></li>
</ul>

<p>
<b>Questions:</b>
</p>

<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/3734512/how-does-a-c-compiler-implement-thread-local-storage-in-c0x">c++11 - How does a C++ compiler implement thread local storage in C++0x? - Stack Overflow</a></li>

<li><a href="https://stackoverflow.com/questions/10999131/can-you-use-thread-local-variables-inside-a-class-or-structure">c++ - Can you use thread local variables inside a class or structure - Stack Overflow</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgae337ae" class="outline-3">
<h3 id="orgae337ae"><span class="section-number-3">1.10</span> Task-based APIs =&gt; Futures and Promises</h3>
<div class="outline-text-3" id="text-1-10">
</div>
<div id="outline-container-org56e029a" class="outline-4">
<h4 id="org56e029a"><span class="section-number-4">1.10.1</span> Futures overview</h4>
<div class="outline-text-4" id="text-1-10-1">
<p>
Overview: 
</p>

<ul class="org-ul">
<li>The std::future class encapsulates a value that will eventually
become available from an asynchronous computation.</li>

<li>This class makes easier to run functions or anything callable that
returns value in a new thread and get this value without any
global variables. Another benefit is that is much easier to handle
exceptions from another thread than the class std::thread.</li>

<li>Use cases:
<ul class="org-ul">
<li>Short computations that returns a value such as a network request.</li>
<li>Implement parallel algorithms and parallel computations.</li>
</ul></li>

<li>Not good for: 
<ul class="org-ul">
<li>Long running thread, threads that run in an infinite loop or
worker thread.</li>
</ul></li>

<li>Problems:
<ul class="org-ul">
<li>Many other implementations of futures run the tasks in a
thread-pool, a pre-allocated set of threads used for avoiding
spawning too much threads that would increase the memory
footprint, reducing the performance and throughput.</li>

<li>The C++ standard library's std::future API does not use thread
pools.</li>
</ul></li>
</ul>

<p>
<b>Documentation</b>
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/promise">std::promise</a></li>

<li><a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a></li>
</ul>

<p>
<b>Other Implementations of Futures and Promises</b>
</p>

<ul class="org-ul">
<li><a href="https://www.boost.org/doc/libs/1_71_0/doc/html/thread/synchronization.html#thread.synchronization.futures">boost::future</a></li>

<li><a href="https://github.com/facebook/folly/blob/master/folly/docs/Futures.md">folly::Future</a></li>

<li><a href="http://stlab.cc/libraries/concurrency/future/future/">stlab::future</a></li>

<li><a href="https://github.com/bloomen/transwarp">transwarp</a> - A header-only C++ library for task concurrency.</li>

<li>hpx::future</li>
</ul>
</div>
</div>
<div id="outline-container-orga80369c" class="outline-4">
<h4 id="orga80369c"><span class="section-number-4">1.10.2</span> Futures Usage</h4>
<div class="outline-text-4" id="text-1-10-2">
<p>
The function <a href="https://en.cppreference.com/w/cpp/thread/async">std::async</a> is used for creating  <a href="https://en.cppreference.com/w/cpp/thread/future">std::future</a> objects out of
functions that return values.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Note: simplified pseudo-signature =&gt; </span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Overload 1: </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Callable</span>, <span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">async</span><span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-type">Function</span>&amp;&amp; <span class="org-variable-name">f</span>, <span class="org-type">Args</span>&amp;&amp;... <span class="org-variable-name">args</span> <span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">future</span><span class="org-rainbow-delimiters-depth-1">&lt;</span>Return<span class="org-rainbow-delimiters-depth-1">&gt;</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Overload 2: </span>
<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Return</span>, <span class="org-keyword">typename</span> <span class="org-type">Callable</span>, <span class="org-keyword">typename</span> ... <span class="org-type">Args</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">auto</span> <span class="org-function-name">async</span><span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-constant">std</span>::<span class="org-type">launch</span> <span class="org-variable-name">policy</span>, <span class="org-type">Function</span>&amp;&amp; <span class="org-variable-name">f</span>, <span class="org-type">Args</span>&amp;&amp;... <span class="org-variable-name">args</span> <span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-constant">std</span>::<span class="org-type">future</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">Return</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>;
</pre>
</div>

<p>
Usage example: 
</p>

<ul class="org-ul">
<li>The object futA represents the return value or the result of the
computation heavy_computation that is run in a new thread not
blocking the thread that called std::async.</li>

<li>The parameter <span class="underline">std::launch::async</span> =&gt; or launch policy is necessary
to run the computation in a new thread.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-type">double</span> <span class="org-function-name">heavy_computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">size</span>, <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">label</span>, <span class="org-type">bool</span> <span class="org-variable-name">flag</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">{</span> 
   <span class="org-comment-delimiter">// </span><span class="org-comment">Sleep blocking the current thread for 10 seconds.</span>
   <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>10s<span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-comment-delimiter">// </span><span class="org-comment">... ... ... .. </span>
   <span class="org-keyword">return</span> output; 
<span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-constant">std</span>::<span class="org-type">future</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">futA</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async, heavy_computation, 100, <span class="org-string">"calc1"</span>, <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-1">)</span>;

 <span class="org-keyword">auto</span> <span class="org-variable-name">futB</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async, <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span>
            <span class="org-rainbow-delimiters-depth-2">{</span> 
               <span class="org-comment-delimiter">// </span><span class="org-comment">.... heavy CPU bound computation ... // </span>
               <span class="org-type">double</span> <span class="org-variable-name">output</span> = ...; 
                 ... ... ... 
               <span class="org-keyword">return</span> output;
            <span class="org-rainbow-delimiters-depth-2">}</span>, 200<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">std::future&lt;T&gt;::get()</span>
<ul class="org-ul">
<li>The member function .get() from <a href="https://en.cppreference.com/w/cpp/thread/future">std::future</a> blocks the current
thread (similar to std::thread::join) waiting for the completion
of the computation and then returns its result.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Block current thread - similar to std::thread::join()</span>
<span class="org-type">double</span> <span class="org-variable-name">resultA</span> = futA.get<span class="org-rainbow-delimiters-depth-1">()</span>; 
<span class="org-type">double</span> <span class="org-variable-name">resultB</span> = futB.get<span class="org-rainbow-delimiters-depth-1">()</span>; 

<span class="org-function-name">std</span>::cout &lt;&lt; <span class="org-string">" resultA = "</span> &lt;&lt; resultA &lt;&lt; <span class="org-string">" ; "</span> &lt;&lt; resultB &lt;&lt; <span class="org-string">"\n"</span>;
</pre>
</div>

<ul class="org-ul">
<li><span class="underline">std::future&lt;T&gt;::wait()</span>
<ul class="org-ul">
<li>The member function .wait() blocks the current thread waiting the
std::future's thread termination.</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Wait for the computation completion blocking current thread.</span>
futB.wait<span class="org-rainbow-delimiters-depth-1">()</span>; 
</pre>
</div>

<ul class="org-ul">
<li>Catching exceptions.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"> <span class="org-type">double</span> <span class="org-function-name">computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">{</span> 
   ... .... ... ... 

   <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>bad_input<span class="org-rainbow-delimiters-depth-3">(</span>input<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> 
       <span class="org-keyword">throw</span> <span class="org-constant">std</span>::runtime_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"Invalid input, try again ..."</span><span class="org-rainbow-delimiters-depth-3">)</span>; 
   <span class="org-rainbow-delimiters-depth-2">}</span>

   ... .... ... ... 
   <span class="org-keyword">return</span> result; 
<span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-comment-delimiter">// </span><span class="org-comment">Type: std::future&lt;double&gt;</span>
 <span class="org-keyword">auto</span> <span class="org-variable-name">afuture</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async, computation, 10<span class="org-rainbow-delimiters-depth-1">)</span>;

 <span class="org-keyword">try</span>
 <span class="org-rainbow-delimiters-depth-1">{</span> 
   <span class="org-type">double</span> <span class="org-variable-name">result</span> = afuture.get<span class="org-rainbow-delimiters-depth-2">()</span>; 
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Result = "</span> &lt;&lt; result &lt;&lt; <span class="org-string">"\n"</span>;
 <span class="org-rainbow-delimiters-depth-1">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-constant">std</span>::<span class="org-type">runtime_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-1">)</span>
 <span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [ERROR] "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n"</span>:
 <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<ul class="org-ul">
<li>Run computations in parallel</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">  <span class="org-type">double</span> <span class="org-function-name">computation</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">input</span><span class="org-rainbow-delimiters-depth-1">)</span>
  <span class="org-rainbow-delimiters-depth-1">{</span> 
    ... .... ... ... 
    <span class="org-comment-delimiter">// </span><span class="org-comment">Sleep blocking this thread for 8 seconds </span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">for simulating a heavy CPU-bound computation.</span>
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>8s<span class="org-rainbow-delimiters-depth-2">)</span>;
    ... .... ... ... 
    <span class="org-keyword">return</span> result; 
 <span class="org-rainbow-delimiters-depth-1">}</span>

 <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">future</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">futures</span>; 
 futures.reserver<span class="org-rainbow-delimiters-depth-1">(</span>3<span class="org-rainbow-delimiters-depth-1">)</span>;
 <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">int</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">inputs</span> <span class="org-rainbow-delimiters-depth-1">{</span>10, 20, 25<span class="org-rainbow-delimiters-depth-1">}</span>;
 <span class="org-constant">std</span>::<span class="org-type">vector</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">outputs</span>; 

<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">x</span>: inputs<span class="org-rainbow-delimiters-depth-1">){</span> 
   futures.push_back<span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async, computation, x<span class="org-rainbow-delimiters-depth-3">)</span>;   <span class="org-rainbow-delimiters-depth-2">)</span> 
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">Block current thread waiting all computations finish. </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">If every computation takes 8 seconds, the total time waiting </span>
<span class="org-comment-delimiter">// </span><span class="org-comment">will be 8 seconds since they are all run in parallel. </span>
<span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">fut</span>: futures<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
   <span class="org-type">double</span> <span class="org-variable-name">x</span> = fut.get<span class="org-rainbow-delimiters-depth-2">()</span>; 
   outputs.push_back<span class="org-rainbow-delimiters-depth-2">(</span>x<span class="org-rainbow-delimiters-depth-2">)</span>;
   <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Result = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbad28f3" class="outline-4">
<h4 id="orgbad28f3"><span class="section-number-4">1.10.3</span> Example</h4>
<div class="outline-text-4" id="text-1-10-3">
<p>
File: future1.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">queue</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">--- Concurrency Headers ---- //</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">future</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">type_traits</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">optional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">namespace</span> <span class="org-constant">cr</span> = <span class="org-constant">std</span>::chrono;
<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;

<span class="org-preprocessor">#define</span> <span class="org-function-name">LOG_FUNCTION_ENTRY</span><span class="org-rainbow-delimiters-depth-1">()</span> \
          <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [TRACE-ENTRY] Function = "</span> &lt;&lt; __FUNCTION__  \
          &lt;&lt; <span class="org-string">" ; threadID "</span> &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::get_id<span class="org-rainbow-delimiters-depth-1">()</span> &lt;&lt; <span class="org-constant">std</span>::endl


<span class="org-keyword">struct</span> <span class="org-type">TimeCounter</span>
<span class="org-rainbow-delimiters-depth-1">{</span>


    <span class="org-keyword">decltype</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-variable-name">start</span>;
    <span class="org-function-name">TimeCounter</span><span class="org-rainbow-delimiters-depth-2">(){</span>  start = <span class="org-constant">cr</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span>;  <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">report</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-keyword">const</span>&amp; <span class="org-variable-name">label</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">end</span> = <span class="org-constant">cr</span>::<span class="org-constant">steady_clock</span>::now<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">duration</span> = <span class="org-constant">cr</span>::duration_cast<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">cr</span>::seconds<span class="org-rainbow-delimiters-depth-3">&gt;(</span>end - start<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Elapsed time: {"</span> &lt;&lt; label &lt;&lt; <span class="org-string">"} = "</span> &lt;&lt; duration.count<span class="org-rainbow-delimiters-depth-3">()</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-function-name">std</span>::mutex mu;

<span class="org-type">double</span> <span class="org-function-name">expensive_computationA</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">--- Start of critical section --- */</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Protect std::cout from race condition</span>
        <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">guard</span><span class="org-rainbow-delimiters-depth-3">(</span>mu<span class="org-rainbow-delimiters-depth-3">)</span>;
        LOG_FUNCTION_ENTRY<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">--- End of critical section --- */</span>
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>4s<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> 4.0 * n + 5;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-type">double</span> <span class="org-function-name">expensive_computationB</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">--- Start of critical section --- */</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Protect std::cout from race condition</span>
        <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">guard</span><span class="org-rainbow-delimiters-depth-3">(</span>mu<span class="org-rainbow-delimiters-depth-3">)</span>;
        LOG_FUNCTION_ENTRY<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>   <span class="org-comment-delimiter">/* </span><span class="org-comment">--- End of critical section --- */</span>
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>8s<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">return</span> 2.515 * n + 15.8714;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-function-name">std</span>::string
computatio_with_exception<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    LOG_FUNCTION_ENTRY<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-2">(</span>1s<span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>n &lt; 0<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">throw</span> <span class="org-constant">std</span>::logic_error<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">" Error: not allowed negative N"</span><span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
    <span class="org-keyword">return</span> <span class="org-string">"Hello world"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>



<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>** <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Number of hardware threads = "</span>
              &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">thread</span>::hardware_concurrency<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;

<span class="org-preprocessor">#if</span> 1

    LOG_FUNCTION_ENTRY<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n ==== EXPERIMENT 1 &gt;&gt;  without std::future =&gt; Run Serially ==== "</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"-----------------------------------------------------------------\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-type">TimeCounter</span> <span class="org-variable-name">tc</span>;
        <span class="org-type">double</span> <span class="org-variable-name">resultA</span> = expensive_computationA<span class="org-rainbow-delimiters-depth-3">(</span>10<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-type">double</span> <span class="org-variable-name">resultB</span> = expensive_computationB<span class="org-rainbow-delimiters-depth-3">(</span>10<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Completed =&gt;&gt; resultA = "</span> &lt;&lt; resultA
                  &lt;&lt; <span class="org-string">" ; resultB = "</span> &lt;&lt; resultB
                  &lt;&lt; <span class="org-constant">std</span>::endl;
        tc.report<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"EXPERIMENT1"</span><span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n ==== EXPERIMENT 2 &gt;&gt; with std::futures - Run in Parallel ===== "</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"-----------------------------------------------------------------\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-type">TimeCounter</span> <span class="org-variable-name">tc</span>;


        <span class="org-comment-delimiter">// </span><span class="org-comment">Function runs in another thread when the future object</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">is instantiated.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">The default policy of std::async is (async | deferred) which</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">would let the C++ runtime decide when run the thread.</span>
        <span class="org-constant">std</span>::<span class="org-type">future</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-variable-name">futA</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async
                                              , &amp;expensive_computationA, 10<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Function runs only when the std::future&lt;T&gt;::get() method is called.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">The function expensive_computationB is not run at the moment futB object</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">is created.</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">futB</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-constant">launch</span>::async, expensive_computationB, 10<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Protect std::cout from race condition (aka data race)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-4">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-4">&gt;</span> <span class="org-variable-name">guard</span><span class="org-rainbow-delimiters-depth-4">(</span>mu<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Waiting futures results "</span> &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">Calls to .get() method blocks the current thread and waits</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">for the completion of the computations wrapped in the future object.</span>
        <span class="org-type">double</span> <span class="org-variable-name">resultB</span> = futB.get<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-type">double</span> <span class="org-variable-name">resultA</span> = futA.get<span class="org-rainbow-delimiters-depth-3">()</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Completed =&gt;&gt; resultA = "</span> &lt;&lt; resultA
                  &lt;&lt; <span class="org-string">" ; resultB = "</span> &lt;&lt; resultB
                  &lt;&lt; <span class="org-constant">std</span>::endl;

        tc.report<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"EXPERIMENT2"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">The method can only be used only once!!</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">otherwise, it calls std::termiante causing abnormal termination.</span>
        <span class="org-comment-delimiter">//</span><span class="org-comment">---------------------------------</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">double resultAA = futA.get(); // DO NOT!</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"\n ==== EXPERIMENT 3 &gt;&gt; Exceptions handling ====================== "</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-constant">std</span>::puts<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"-----------------------------------------------------------------\n"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"Future Created"</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">fut1</span> = <span class="org-constant">std</span>::async<span class="org-rainbow-delimiters-depth-3">(</span>computatio_with_exception, -10<span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">result1</span> = fut1.get<span class="org-rainbow-delimiters-depth-4">()</span>;
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [INFO] Result1 = "</span> &lt;&lt; result1 &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span> <span class="org-keyword">catch</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-type">logic_error</span>&amp; <span class="org-variable-name">ex</span><span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::cerr &lt;&lt; <span class="org-string">" [ERROR] "</span> &lt;&lt; ex.what<span class="org-rainbow-delimiters-depth-4">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>

    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-preprocessor">#endif</span>

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">clang++ future1.cpp -o <span class="org-keyword">future1.bin</span> -std=c++1z -lpthread -Wall -Wextra -O0 -g
</pre>
</div>

<p>
Output: 
</p>

<div class="org-src-container">
<pre class="src src-sh"> $ ./future1.bin 

 Number of hardware threads = 4

 ==== EXPERIMENT 1 &gt;&gt;  without std::future =&gt; Run Serially ==== 
-----------------------------------------------------------------

 [TRACE-ENTRY] Function = main ; threadID 139662702782272
 [TRACE-ENTRY] Function = expensive_computationA ; threadID 139662702782272
 [TRACE-ENTRY] Function = expensive_computationB ; threadID 139662702782272
 [TRACE] Completed =&gt;&gt; resultA = 45 ; resultB = 41.0214
 [TRACE] Elapsed time: {EXPERIMENT1} = 12

 ==== EXPERIMENT 2 &gt;&gt; with std::futures - Run<span class="org-keyword"> in</span> Parallel ===== 
-----------------------------------------------------------------

 [TRACE] Waiting futures results 
 [TRACE-ENTRY] Function = expensive_computationA ; threadID 139662684923648
 [TRACE-ENTRY] Function = expensive_computationB ; threadID 139662676530944
 [TRACE] Completed =&gt;&gt; resultA = 45 ; resultB = 41.0214
 [TRACE] Elapsed time: {EXPERIMENT2} = 8

 ==== EXPERIMENT 3 &gt;&gt; Exceptions handling ====================== 
-----------------------------------------------------------------

Future Created
 [TRACE-ENTRY] Function = computatio_with_exception ; threadID 139662684923648
 [ERROR]  Error: not allowed negative N
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfafbabf" class="outline-3">
<h3 id="orgfafbabf"><span class="section-number-3">1.11</span> Condition Variables and Producer Consumer Problem</h3>
<div class="outline-text-3" id="text-1-11">
<ul class="org-ul">
<li>A condition variable is a synchronization primitive which allows
one or more threads to wait for a event, signal from another
thread, without wasting CPU cycles.</li>

<li>Mechanism: several threads wait on a condition variable, until
another thread notifies this synchronization primitive.</li>

<li>Note: Condition variables do not provide locking such as Mutexes,
so they must be used alongside condition variables in order to
avoid race conditions.</li>

<li>Operations of condition Variables:

<ul class="org-ul">
<li>ConditionVar.wait(MutexLock)
<ul class="org-ul">
<li>=&gt; Makes current thread (waiting thread) sleep waiting from a signal</li>
</ul></li>

<li>ConditionVar.notify_one()
<ul class="org-ul">
<li>=&gt; Wakes up a waiting thread. If there is no waiting thread,
the operation does nothing.</li>
</ul></li>

<li>ConditionVar.notify_all()
<ul class="org-ul">
<li>=&gt; Wake up all waiting threads.</li>
</ul></li>
</ul></li>
</ul>

<p>
<b>Condition Variable Method Signatures</b>
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-keyword">class</span> <span class="org-type">condition_variable</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
 <span class="org-keyword">public</span>:
    <span class="org-function-name">condition_variable</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    ~<span class="org-function-name">condition_variable</span><span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-function-name">condition_variable</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">condition_variable</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;
    <span class="org-type">condition_variable</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">=</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-type">condition_variable</span>&amp;<span class="org-rainbow-delimiters-depth-2">)</span> = <span class="org-keyword">delete</span>;

    <span class="org-comment-delimiter">/** </span><span class="org-comment">Wake up only one sleeping thread */</span>
    <span class="org-type">void</span> <span class="org-function-name">notify_one</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">noexcept</span>;

    <span class="org-comment-delimiter">/** </span><span class="org-comment">Wake up all sleeping threads that are waiting for this signal */</span>      
    <span class="org-type">void</span> <span class="org-function-name">notify_all</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">noexcept</span>;

    <span class="org-comment-delimiter">/** </span><span class="org-comment">Make thread which alls this method sleep (wait for signal)</span>
<span class="org-comment">      * without waste CPU cycles */</span>  
    <span class="org-type">void</span> <span class="org-function-name">wait</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Predicate</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-type">void</span> <span class="org-function-name">wait</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span>, <span class="org-type">Predicate</span> <span class="org-variable-name">pred</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Clock</span>, <span class="org-keyword">class</span> <span class="org-type">Duration</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-type">cv_status</span> <span class="org-function-name">wait_until</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span>, <span class="org-keyword">const</span> <span class="org-constant">chrono</span>::<span class="org-type">time_point</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Clock</span>, <span class="org-type">Duration</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">abs_time</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Clock</span>, <span class="org-keyword">class</span> <span class="org-type">Duration</span>, <span class="org-keyword">class</span> <span class="org-type">Predicate</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-type">bool</span> <span class="org-function-name">wait_until</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span>, <span class="org-keyword">const</span> <span class="org-constant">chrono</span>::<span class="org-type">time_point</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Clock</span>, <span class="org-type">Duration</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">abs_time</span>, <span class="org-type">Predicate</span> <span class="org-variable-name">pred</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Rep</span>, <span class="org-keyword">class</span> <span class="org-type">Period</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-type">cv_status</span> <span class="org-function-name">wait_for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span>, <span class="org-keyword">const</span> <span class="org-constant">chrono</span>::<span class="org-type">duration</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Rep</span>, <span class="org-type">Period</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">rel_time</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">class</span> <span class="org-type">Rep</span>, <span class="org-keyword">class</span> <span class="org-type">Period</span>, <span class="org-keyword">class</span> <span class="org-type">Predicate</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
    <span class="org-type">bool</span> <span class="org-function-name">wait_for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span>mutex<span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">lock</span>, <span class="org-keyword">const</span> <span class="org-constant">chrono</span>::<span class="org-type">duration</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">Rep</span>, <span class="org-type">Period</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>&amp; <span class="org-variable-name">rel_time</span>, <span class="org-type">Predicate</span> <span class="org-variable-name">pred</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">typedef</span> <span class="org-type">implementation</span>-defined native_handle_type;
    <span class="org-type">native_handle_type</span> <span class="org-function-name">native_handle</span><span class="org-rainbow-delimiters-depth-2">()</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<p>
<b>Example: Usage of Conditions Variables in Producer/Consumer problem</b> 
</p>

<p>
The producer consumer problem is classical synchronization problem
where a producer puts data into a data structure and another thread, called
consumer, removes data from the data structure. Only a single thread
should be able to access the data structure at any atime. 
</p>

<p>
Sample implementation: <a href="https://gist.github.com/iikuy/8115191">https://gist.github.com/iikuy/8115191</a>
</p>

<p>
Example: 
</p>

<ul class="org-ul">
<li>File: producer-consumer.cpp</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">queue</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">--- Concurrency Headers ---- //</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">threads</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>  <span class="org-comment-delimiter">// </span><span class="org-comment">mutex, lock_guard, unique_lock</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">future</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">conditional_variables</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;

<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>** <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Number of hardware threads = "</span>
              &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">thread</span>::hardware_concurrency<span class="org-rainbow-delimiters-depth-2">()</span> &lt;&lt; <span class="org-string">"\n\n"</span>;

    <span class="org-constant">std</span>::<span class="org-type">condition_variable</span> <span class="org-variable-name">cond</span>;
    <span class="org-constant">std</span>::<span class="org-type">mutex</span> <span class="org-variable-name">m</span>;
    <span class="org-constant">std</span>::<span class="org-type">queue</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">buffer</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">finished</span> = <span class="org-constant">false</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">producer_thread</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[</span>&amp;<span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [PRODUCER] Producer thread started."</span> &lt;&lt; <span class="org-string">"\n"</span>;
            <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 5; i++<span class="org-rainbow-delimiters-depth-4">)</span>
            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-5">(</span>1s<span class="org-rainbow-delimiters-depth-5">)</span>;
                <span class="org-rainbow-delimiters-depth-5">{</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">-- start of critical section ----//</span>
                    <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-constant">std</span>::<span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-6">&gt;{</span>m<span class="org-rainbow-delimiters-depth-6">}</span>;
                    <span class="org-type">double</span> <span class="org-variable-name">x</span> = 5 * i + 10;
                    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"\n [PRODUCER] Send data to buffer x = "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
                    buffer.push<span class="org-rainbow-delimiters-depth-6">(</span>x<span class="org-rainbow-delimiters-depth-6">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Mutex protects the buffer fron race condition</span>
                  <span class="org-comment-delimiter">// </span><span class="org-comment">--- End of ciritical section ---- //</span>
                <span class="org-rainbow-delimiters-depth-5">}</span>

                <span class="org-comment-delimiter">// </span><span class="org-comment">Send signal notifying consumer thread to proceed.</span>
                cond.notify_all<span class="org-rainbow-delimiters-depth-5">()</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>

            <span class="org-rainbow-delimiters-depth-4">{</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-5">&gt;{</span>m<span class="org-rainbow-delimiters-depth-5">}</span>;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [PRODUCER] End of transmission"</span> &lt;&lt; <span class="org-constant">std</span>::endl;
                finished = <span class="org-constant">true</span>;
            <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">consumer_thread</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[</span>&amp;<span class="org-rainbow-delimiters-depth-3">]{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Consumer thread started."</span> &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>            
            <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::<span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-5">&lt;</span><span class="org-constant">std</span>::<span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-5">&gt;{</span>m<span class="org-rainbow-delimiters-depth-5">}</span>;

            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Waiting input "</span> &lt;&lt; <span class="org-string">"\n"</span>;

            <span class="org-comment-delimiter">// </span><span class="org-comment">The condition variable waits for cond.notify_one() signal</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">from the producer thread. Before this signal is sent, this</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">thread sleeps until receives it.</span>
            cond.wait<span class="org-rainbow-delimiters-depth-5">(</span>lock, <span class="org-rainbow-delimiters-depth-6">[</span>&amp;<span class="org-rainbow-delimiters-depth-6">]{</span> <span class="org-keyword">return</span> <span class="org-negation-char">!</span>buffer.empty<span class="org-rainbow-delimiters-depth-7">()</span>; <span class="org-rainbow-delimiters-depth-6">}</span><span class="org-rainbow-delimiters-depth-5">)</span>;

            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Processing data ... wait"</span> &lt;&lt; <span class="org-string">"\n"</span>;
            <span class="org-comment-delimiter">// </span><span class="org-comment">Delay for simulating processing time</span>
            <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-5">(</span>5s<span class="org-rainbow-delimiters-depth-5">)</span>;

            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Received value "</span> &lt;&lt; buffer.front<span class="org-rainbow-delimiters-depth-5">()</span> &lt;&lt; <span class="org-string">"\n"</span>;
            buffer.pop<span class="org-rainbow-delimiters-depth-5">()</span>;

            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span>finished<span class="org-rainbow-delimiters-depth-5">){</span>
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Stop consumer thread. Ok"</span> &lt;&lt; <span class="org-string">"\n"</span>;
                <span class="org-keyword">break</span>;
            <span class="org-rainbow-delimiters-depth-5">}</span>

            <span class="org-comment-delimiter">// </span><span class="org-comment">Unlock in order to avoid deadlock</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">lock.unlock();</span>
        <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Waiting thread completion"</span> &lt;&lt; <span class="org-string">"\n"</span>;
    producer_thread.join<span class="org-rainbow-delimiters-depth-2">()</span>;
    consumer_thread.join<span class="org-rainbow-delimiters-depth-2">()</span>;

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building and Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ g++ producer-consumer.cpp -o <span class="org-keyword">out.bin</span> -std=c++1z -O0 -g -Wall -lpthread
</pre>
</div>

<p>
Running: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ ./out.bin 
 Number of hardware threads = 4

 [PRODUCER] Producer thread started.
 [TRACE] Waiting thread completion
 [CONSUMER] Consumer thread started.
 [CONSUMER] Waiting input 

 [PRODUCER] Send data to buffer x = 10
 [CONSUMER] Processing data ... wait
 [CONSUMER] Received value 10
 [CONSUMER] Waiting input 

 [PRODUCER] Send data to buffer x = 15
 [CONSUMER] Processing data ... wait
 [CONSUMER] Received value 15
 [CONSUMER] Waiting input 

 [PRODUCER] Send data to buffer x = 20
 [CONSUMER] Processing data ... wait
 [CONSUMER] Received value 20
 [CONSUMER] Waiting input 

 [PRODUCER] Send data to buffer x = 25
 [CONSUMER] Processing data ... wait
 [CONSUMER] Received value 25
 [CONSUMER] Waiting input 

 [PRODUCER] Send data to buffer x = 30
 [PRODUCER] End of transmission
 [CONSUMER] Processing data ... wait
 [CONSUMER] Received value 30
 [CONSUMER] Stop consumer thread. Ok

</pre>
</div>
</div>
</div>

<div id="outline-container-org14ed0b5" class="outline-3">
<h3 id="org14ed0b5"><span class="section-number-3">1.12</span> Messaging Passing Concurrency and Message Queue</h3>
<div class="outline-text-3" id="text-1-12">
</div>
<div id="outline-container-orgd7e7077" class="outline-4">
<h4 id="orgd7e7077"><span class="section-number-4">1.12.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-12-1">
<p>
Message Passing Concurrency
</p>

<ul class="org-ul">
<li>In Message passing concurrency threads communicate by sending
messages to each other through a <span class="underline">message queue</span> FIFO buffer,
instead of communicating through explicit locks and mutating the
shared memory.</li>

<li>The mosft fundamental construct of message passing concurrency is
the <span class="underline">message queue</span>, that allows communication between <span class="underline">producers</span>
(aka senders) and <span class="underline">consumers</span> (aka receivers) threads running at
different speeds.</li>

<li><span class="underline">Message queues</span> are also called mailbox, channels or concurrent queue.</li>

<li><span class="underline">Message queues</span> are used for the from implementing the following
messaging passing design patterns: 

<ul class="org-ul">
<li><span class="underline">CSP</span> - Concurrent Sequential Process - proposed by Tony Hoare and
used in GO/Golang and Clojure.</li>

<li><span class="underline">Actor Model</span> - Proposed by Carl Hewitt and used in Erlang and
Scala's Akka.</li>

<li><span class="underline">Active Object</span></li>

<li><span class="underline">Thread Pools</span></li>
</ul></li>
</ul>

<p>
Producer Consumer Problem: 
</p>

<ul class="org-ul">
<li>The most basic use case of <span class="underline">message queues</span> is solving the producer
consumer/problem inter-thread communication problem where a
producer and consumer thread communicates through a buffer,
generally a queue. There are two scenarios, if the buffer is empty,
the consumer thread gets blocked (suspended) and is only resumed
when the producer puts some item in the buffer. If the queue has a
limited size and is full, the producer thread gets blocked
(suspended) until the consumer removes the item from the queue.</li>

<li>Note: <span class="underline">Message queues</span> can be implemented as a class that
encapsulates the queue data structure and synchronization
primitives: condition variables and mutexes.</li>
</ul>

<p>
Other uses of <span class="underline">message passing</span> and <span class="underline">message queues</span> 
</p>

<ul class="org-ul">
<li>Message passing is not only used for inter-thread communication,
this approach is also applicable for process communication through
IPC - Inter Process Communication and distributed systems where
multiple processes communicates over the network through sockets.</li>
</ul>

<p>
Sample Implementations of <span class="underline">message queue</span> 
</p>

<ul class="org-ul">
<li>Java:

<ul class="org-ul">
<li>LinkedBlockingQueue (Bounded buffer)
<ul class="org-ul">
<li>=&gt; Linked list of unlimited size that blocks/suspends the
consumer thread if the queue is empty until the producer puts
some element in the queue.</li>
</ul></li>

<li>ArrayBlockingQueue (Bounded buffer)
<ul class="org-ul">
<li>=&gt; Fixed size queue that blocks/suspends the consumer thread
(aka receiver) if the queue is empty until the producer thread
(aka sender) adds an element to the queue. The producer thread
gets blocked if the queue is full until the consumer thread
pops an element from the queue.</li>
</ul></li>
</ul></li>

<li><a href="https://github.com/cameron314/concurrentqueue">cameron314/concurrentqueue</a>
<ul class="org-ul">
<li>"A fast multi-producer,  multi-consumer lock-free concurrent queue for C++11"</li>
</ul></li>

<li>Facebook's Folly - <a href="https://github.com/facebook/folly/blob/master/folly/docs/ProducerConsumerQueue.md">ProducerConsumerQueue</a> (documentation) - Code: <a href="https://github.com/facebook/folly/blob/master/folly/ProducerConsumerQueue.h">ProducerConsumerQueue.h</a></li>

<li><a href="https://juanchopanzacpp.wordpress.com/2013/02/26/concurrent-queue-c11/">Concurrent queue – C++11 | Juan's C++ blog</a></li>
</ul>


<p>
Example of Message Queue Behavior in Pseudocode: 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-comment-delimiter">// </span><span class="org-comment">Message queue of fixed size 10 </span>
<span class="org-type">fixed_message_queue</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-variable-name">buffer</span><span class="org-rainbow-delimiters-depth-1">(</span>10<span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">consumer_thread</span> = thread<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[</span>&amp;<span class="org-rainbow-delimiters-depth-2">]{</span>
   <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-3">(</span>buffer.is_closed<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span>
      sleep<span class="org-rainbow-delimiters-depth-4">(</span>2<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">Block current thread if the queue is empty </span>
      <span class="org-type">double</span> <span class="org-variable-name">next</span> = buffer.take<span class="org-rainbow-delimiters-depth-4">()</span>;   
      print<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Received message x = %.3f"</span>, next<span class="org-rainbow-delimiters-depth-4">)</span>;
   <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-keyword">auto</span> <span class="org-variable-name">producer_thread</span> = thread<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[</span>&amp;<span class="org-rainbow-delimiters-depth-2">]{</span>
   <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">double</span> <span class="org-variable-name">x</span> = 0.0; x &lt; 100.0; x += 2.0<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span>
      sleep<span class="org-rainbow-delimiters-depth-4">(</span>10<span class="org-rainbow-delimiters-depth-4">)</span>;
      <span class="org-type">double</span> <span class="org-variable-name">y</span> = 4 * x + 10;
      <span class="org-comment-delimiter">// </span><span class="org-comment">Block current thread if the queue is full (has 10 elements)</span>
      <span class="org-type">double</span> <span class="org-variable-name">next</span> = buffer.put<span class="org-rainbow-delimiters-depth-4">(</span>x<span class="org-rainbow-delimiters-depth-4">)</span>;   
      print<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">"Received message x = %.3f"</span>, next<span class="org-rainbow-delimiters-depth-4">)</span>;
   <span class="org-rainbow-delimiters-depth-3">}</span>
   <span class="org-comment-delimiter">// </span><span class="org-comment">Indicates that messages will no longer be sent </span>
   queue.close<span class="org-rainbow-delimiters-depth-3">()</span>;
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
<b>Message Passing Concurrency in other languages</b> 
</p>

<ul class="org-ul">
<li><a href="https://golang.org/doc/effective_go.html#concurrency">Effective Go - The Go Programming Language</a> - Concurrency</li>

<li><a href="https://bartoszmilewski.com/2009/07/16/on-actors-and-casting/">On Actors and Casting |   Bartosz Milewski's Programming Cafe</a></li>
</ul>

<p>
<b>C++ Implementations of Message Passing</b> (Message Queue / Actor Model and CSP)
</p>

<ul class="org-ul">
<li><a href="https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/dd492627(v=vs.100)?redirectedfrom=MSDN">Asynchronous Agents Library | Microsoft Docs</a> - PPL Library</li>

<li><a href="https://github.com/Himmele/Mindroid.ecpp">Mindroid.ecpp: Mindroid.ecpp</a> - is an embedded application
framework inspired by Google's Android operating system</li>

<li><a href="http://web.archive.org/web/20090303231159/http://www.ddj.com/hpc-high-performance-computing/210604448">Writing Lock-Free Code: A Corrected Queue</a> - Herb Sutter</li>

<li><a href="https://stackoverflow.com/questions/26489876/what-is-the-best-practice-for-passing-data-between-threads-queues-messages-or">c++ - What is the best practice for passing data between threads? Queues, messages or others?</a></li>

<li><a href="https://github.com/cameron314/concurrentqueue">cameron314/concurrentqueue</a>
<ul class="org-ul">
<li>"A fast multi-producer,  multi-consumer lock-free concurrent queue for C++11"</li>
</ul></li>

<li>Facebook's Folly - <a href="https://github.com/facebook/folly/blob/master/folly/docs/ProducerConsumerQueue.md">ProducerConsumerQueue</a> (documentation) - Code: <a href="https://github.com/facebook/folly/blob/master/folly/ProducerConsumerQueue.h">ProducerConsumerQueue.h</a></li>

<li><a href="https://juanchopanzacpp.wordpress.com/2013/02/26/concurrent-queue-c11/">Concurrent queue – C++11 | Juan's C++ blog</a></li>

<li><a href="https://www.boost.org/doc/libs/1_70_0/doc/html/thread/sds.html#thread.sds.synchronized_queues">Boost Synchronized Data Structure - Synchronized Queue</a></li>

<li><a href="https://docs.microsoft.com/en-us/cpp/parallel/concrt/reference/concurrent-queue-class?view=vs-2019">concurrent_queue Class | Microsoft Docs</a></li>

<li><a href="https://codereview.stackexchange.com/questions/128832/c11-blocking-queue-learning-exercise">c++ - C++11 Blocking Queue learning exercise - Code Review Stack Exchange</a></li>

<li><a href="https://gist.github.com/thelinked/6997598">C++11 blocking queue using the standard library. · GitHub</a></li>

<li><a href="https://github.com/Balnian/ChannelsCPP">GitHub - Balnian/ChannelsCPP: C++ implementation of the Go (GoLang) Channel and Select structure</a></li>

<li><a href="https://gist.github.com/vmrob/e4fde208302ae8979b57">Go channels in C++ · GitHub</a></li>
</ul>
</div>
</div>

<div id="outline-container-orge3001e7" class="outline-4">
<h4 id="orge3001e7"><span class="section-number-4">1.12.2</span> Producer/consumer problem with messague queue</h4>
<div class="outline-text-4" id="text-1-12-2">
<p>
The producer consumer synchronization problem can be simplified with a
message queue (aka concurrent blocking queue) which encapsulates the
data structure implementation and the all synchronization promitives.
</p>

<p>
Requirements: 
</p>

<ul class="org-ul">
<li>The <span class="underline">producer thread</span> puts an element in the queue and signals the
condition variable what wakes up the <span class="underline">consumer thread</span>.</li>

<li>When the queue is empty, the <span class="underline">consumer thread</span> gets in sleep state
and waits for some element to be put into the queue.</li>

<li>The access to the queue must be thread-safe.</li>
</ul>

<p>
Parts of standard library used: 
</p>

<ul class="org-ul">
<li><a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable</a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex</a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/unique_lock">std::unique_lock</a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/lock_guard">lock:guard</a></li>
<li><a href="https://en.cppreference.com/w/cpp/container/queue">queue</a></li>
</ul>

<p>
<b>Example:</b> Simple Blocking Queue Implementation for consumer/producer problem. 
</p>

<p>
File: concurrent_queue.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">queue</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">--- Concurrency Headers ---- //</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">threads</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>  <span class="org-comment-delimiter">// </span><span class="org-comment">mutex, lock_guard, unique_lock</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">future</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span> <span class="org-comment-delimiter">// </span><span class="org-comment">conditional_variables</span>

<span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;

<span class="org-keyword">template</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">T</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">class</span> <span class="org-type">MessageQueue</span> 
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">using</span> <span class="org-type">guard</span> = <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-2">&gt;</span>;

    <span class="org-constant">std</span>::<span class="org-type">queue</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">T</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>           <span class="org-variable-name">m_queue</span>;
    <span class="org-constant">std</span>::<span class="org-type">condition_variable</span> <span class="org-variable-name">m_cvar</span>;
    <span class="org-keyword">mutable</span> <span class="org-constant">std</span>::<span class="org-type">mutex</span>      <span class="org-variable-name">m_mutex</span>;

<span class="org-function-name">public</span>:
    <span class="org-function-name">MessageQueue</span><span class="org-rainbow-delimiters-depth-2">(){}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Called by producer thread</span>
    <span class="org-type">void</span> <span class="org-function-name">push</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = guard<span class="org-rainbow-delimiters-depth-3">(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_queue.push<span class="org-rainbow-delimiters-depth-3">(</span>value<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_cvar.notify_one<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">void</span> <span class="org-function-name">push</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">T</span>&amp;&amp; <span class="org-variable-name">value</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = guard<span class="org-rainbow-delimiters-depth-3">(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_queue.push<span class="org-rainbow-delimiters-depth-3">(</span>value<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_cvar.notify_one<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>


    <span class="org-comment-delimiter">// </span><span class="org-comment">Called by consumer thread.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">blocks consumer thread making</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">it sleep when the queue is empty</span>
    <span class="org-type">void</span> <span class="org-function-name">pop</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = guard<span class="org-rainbow-delimiters-depth-3">(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_queue.pop<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Called by consumer thread</span>
    <span class="org-type">T</span>&amp; <span class="org-function-name">front</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::unique_lock<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">The second argument of m_cvar.wait, a lambda function is</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">passed as predicate to prevent spurious thread wake up.</span>
        m_cvar.wait<span class="org-rainbow-delimiters-depth-3">(</span>lock, <span class="org-rainbow-delimiters-depth-4">[</span>&amp;<span class="org-rainbow-delimiters-depth-4">]{</span> <span class="org-keyword">return</span> <span class="org-negation-char">!</span>m_queue.empty<span class="org-rainbow-delimiters-depth-5">()</span>; <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-type">T</span>&amp; <span class="org-variable-name">result</span> = m_queue.front<span class="org-rainbow-delimiters-depth-3">()</span>;
        lock.unlock<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">return</span> result;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Called by consumer thread</span>
    <span class="org-keyword">const</span> <span class="org-type">T</span>&amp; <span class="org-function-name">front</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::unique_lock<span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::<span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-3">&gt;(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        m_cvar.wait<span class="org-rainbow-delimiters-depth-3">(</span>lock, <span class="org-rainbow-delimiters-depth-4">[</span>&amp;<span class="org-rainbow-delimiters-depth-4">]{</span> <span class="org-keyword">return</span> <span class="org-negation-char">!</span>m_queue.empty<span class="org-rainbow-delimiters-depth-5">()</span>; <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-type">T</span>&amp; <span class="org-variable-name">result</span> = m_queue.front<span class="org-rainbow-delimiters-depth-3">()</span>;
        lock.unlock<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-keyword">return</span> result;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-type">bool</span> <span class="org-function-name">empty</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = guard<span class="org-rainbow-delimiters-depth-3">(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">return</span> m_queue.front<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-constant">std</span>::<span class="org-type">size_t</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">g</span> = guard<span class="org-rainbow-delimiters-depth-3">(</span>m_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">return</span>  m_queue.size<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

<span class="org-rainbow-delimiters-depth-1">}</span>;



<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>* <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-2">[]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>

    <span class="org-type">MessageQueue</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">queue</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Mutex used for protecting std::cout from frace condition</span>
    <span class="org-constant">std</span>::<span class="org-type">mutex</span> <span class="org-variable-name">output_mutex</span>;
    <span class="org-constant">std</span>::<span class="org-type">atomic_bool</span> <span class="org-variable-name">finished</span> = <span class="org-constant">false</span>;

    <span class="org-keyword">auto</span> <span class="org-variable-name">consumer_thread</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">(</span> <span class="org-rainbow-delimiters-depth-3">[</span>&amp;<span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">{</span>
      <span class="org-rainbow-delimiters-depth-4">{</span>
          <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::lock_guard<span class="org-rainbow-delimiters-depth-5">(</span>output_mutex<span class="org-rainbow-delimiters-depth-5">)</span>;
          <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Consumer thread started."</span> &lt;&lt; <span class="org-string">"\n"</span>;
      <span class="org-rainbow-delimiters-depth-4">}</span>
        <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">{</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">value</span> = queue.front<span class="org-rainbow-delimiters-depth-5">()</span>;
            <span class="org-rainbow-delimiters-depth-5">{</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::lock_guard<span class="org-rainbow-delimiters-depth-6">(</span>output_mutex<span class="org-rainbow-delimiters-depth-6">)</span>;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Wait input ..."</span> &lt;&lt; <span class="org-string">"\n"</span>;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [CONSUMER] Received value = "</span> &lt;&lt; value &lt;&lt; <span class="org-string">"\n"</span>;
            <span class="org-rainbow-delimiters-depth-5">}</span>
            queue.pop<span class="org-rainbow-delimiters-depth-5">()</span>;
            <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-negation-char">!</span>queue.empty<span class="org-rainbow-delimiters-depth-6">()</span> &amp;&amp; finished<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">break</span>; <span class="org-rainbow-delimiters-depth-5">}</span>
        <span class="org-rainbow-delimiters-depth-4">}</span>
    <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;

     <span class="org-comment-delimiter">// </span><span class="org-comment">Protect cout from race condition</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::lock_guard<span class="org-rainbow-delimiters-depth-3">(</span>output_mutex<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Start interactive SHELL OK."</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">The producer thread is the current one (main thread)</span>
    <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 5; i++<span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-3">(</span>1s<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-type">double</span> <span class="org-variable-name">x</span> = i * i - 4 * i + 10.0 ;
        <span class="org-rainbow-delimiters-depth-3">{</span>
            <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::lock_guard<span class="org-rainbow-delimiters-depth-4">(</span>output_mutex<span class="org-rainbow-delimiters-depth-4">)</span>;
            <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [PRODUCER] =&gt; Sending number: "</span> &lt;&lt; x &lt;&lt; <span class="org-string">"\n"</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        queue.push<span class="org-rainbow-delimiters-depth-3">(</span>x<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    finished = <span class="org-constant">true</span>;
    consumer_thread.join<span class="org-rainbow-delimiters-depth-2">()</span>;
    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ message_queue.cpp -o <span class="org-keyword">out.bin</span> -std=c++1z -O0 -Wall -g -lpthread
</pre>
</div>

<p>
Running:
</p>

<div class="org-src-container">
<pre class="src src-sh">$ out.bin  
 [TRACE] Start interactive SHELL OK.
 [CONSUMER] Consumer thread started.
 [PRODUCER] =&gt; Sending number: 10
 [CONSUMER] Wait input ...
 [CONSUMER] Received value = 10
 [PRODUCER] =&gt; Sending number: 7
 [CONSUMER] Wait input ...
 [CONSUMER] Received value = 7
 [PRODUCER] =&gt; Sending number: 6
 [CONSUMER] Wait input ...
 [CONSUMER] Received value = 6
 [PRODUCER] =&gt; Sending number: 7
 [CONSUMER] Wait input ...
 [CONSUMER] Received value = 7
 [PRODUCER] =&gt; Sending number: 10
 [CONSUMER] Wait input ...
 [CONSUMER] Received value = 10
</pre>
</div>
</div>
</div>

<div id="outline-container-org97ad178" class="outline-4">
<h4 id="org97ad178"><span class="section-number-4">1.12.3</span> References</h4>
<div class="outline-text-4" id="text-1-12-3">
<ul class="org-ul">
<li><b>Chapter 10 - Concurrency - Message Passing</b>
<ul class="org-ul">
<li><a href="https://www.doc.ic.ac.uk/~jnm/book/firstbook/pdf/ch10.pdf">https://www.doc.ic.ac.uk/~jnm/book/firstbook/pdf/ch10.pdf</a></li>
</ul></li>

<li><b>Reading 22: Queues and Message-Passing</b> - MIT 
<ul class="org-ul">
<li><a href="http://web.mit.edu/6.031/www/fa17/classes/22-queues/">http://web.mit.edu/6.031/www/fa17/classes/22-queues/</a></li>
<li>Note: contains "Implementing message passing with queues"</li>
</ul></li>

<li><b>Two models for concurrent programming</b> - MIT 
<ul class="org-ul">
<li><a href="http://web.mit.edu/6.031/www/fa17/classes/19-concurrency/#two_models_for_concurrent_programming">http://web.mit.edu/6.031/www/fa17/classes/19-concurrency/#two_models_for_concurrent_programming</a></li>
</ul></li>

<li><b>Android Style Message Passing</b> - Communicating between Threads using Message Queues.
<ul class="org-ul">
<li><a href="http://blog.coldflake.com/posts/Android-style-Message-Passing/">http://blog.coldflake.com/posts/Android-style-Message-Passing/</a></li>
<li>Coverage: Message queue, active object.</li>
</ul></li>

<li><b>Programming with Trheads - Synchronization and Communication</b> [PAPER]
<ul class="org-ul">
<li><a href="https://cms.uni-konstanz.de/fileadmin/archive/deussen/fileadmin/informatik/ag-deussen/2011/heck2011-programming_with_threads.pdf">https://cms.uni-konstanz.de/fileadmin/archive/deussen/fileadmin/informatik/ag-deussen/2011/heck2011-programming_with_threads.pdf</a></li>
</ul></li>

<li><b>Producer consumer design pattern</b> - DZone 
<ul class="org-ul">
<li><a href="https://dzone.com/articles/producer-consumer-pattern">https://dzone.com/articles/producer-consumer-pattern</a></li>
</ul></li>

<li><b>A Thread-Safe Message Queue</b>
<ul class="org-ul">
<li><a href="https://wiki.tcl-lang.org/page/A+Thread-Safe+Message+Queue">https://wiki.tcl-lang.org/page/A+Thread-Safe+Message+Queue</a></li>
</ul></li>

<li><b>How to use wait, nitifyAll in Java - Producer Consumer Example</b>
<ul class="org-ul">
<li><a href="https://javarevisited.blogspot.com/2015/07/how-to-use-wait-notify-and-notifyall-in.html">https://javarevisited.blogspot.com/2015/07/how-to-use-wait-notify-and-notifyall-in.html</a></li>
</ul></li>

<li><b>5. Message Passing</b>
<ul class="org-ul">
<li><a href="https://cs.gmu.edu/~rcarver/ModernMultithreading/LectureNotes/chapter5notes-2up.pdf">https://cs.gmu.edu/~rcarver/ModernMultithreading/LectureNotes/chapter5notes-2up.pdf</a></li>
</ul></li>

<li>Paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0260r3.html">WG21 - C++ Concurrent Queues</a> - Lawerence Crwol, Chris Mysen
<ul class="org-ul">
<li>"Concurrent queues are a fundamental structuring tool for
concurrent programs. We propose a concurrent queue concept and a
concrete implementation. We propose a set of communication types
that enable loosely bound program components to dynamically
construct and safely share concurrent queues."</li>
</ul></li>

<li><a href="https://www.baeldung.com/java-blocking-queue">Guide to java.util.concurrent.BlockingQueue | Baeldung</a>
<ul class="org-ul">
<li>Shows how a concurrent queue works and solves the
producer/consumer problem.</li>
</ul></li>

<li><a href="https://vorbrodt.blog/2019/02/03/blocking-queue/">Blocking queue – Vorbrodt's C++ Blog</a></li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgde4fd7e" class="outline-3">
<h3 id="orgde4fd7e"><span class="section-number-3">1.13</span> Thread Pools</h3>
<div class="outline-text-3" id="text-1-13">
</div>
<div id="outline-container-org89eb614" class="outline-4">
<h4 id="org89eb614"><span class="section-number-4">1.13.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-13-1">
<ul class="org-ul">
<li>A thread pool is a widely used technique for executing many short
living tasks by reusing pre-existing long running worker threads
without creating and destroying too many threads what would
increase the system latency and reduce its throughput.</li>

<li>Use Cases: 
<ul class="org-ul">
<li>Run short running tasks without creating too many threads.</li>
<li>Execute future/promise computations.</li>
<li>Network Servers</li>
<li>Web Servers</li>
<li>Run parallel algorithms</li>
<li>Note: NodeJS and Nginx web server uses <span class="underline">thread pools</span> behind the
scenes for handling incoming network requests and running
asynchronous computations without blocking the main thread.</li>
</ul></li>

<li>Benefits
<ul class="org-ul">
<li>Reduce the overhead of creation and destruction of too many threads.</li>
<li>Reuse threads.</li>
<li>More lightweight task-based concurrency (future and promises).</li>
</ul></li>

<li>Implementation Parts:

<ul class="org-ul">
<li><span class="underline">Task Queue</span>: (Message Queue)
<ul class="org-ul">
<li>A message queue which is possible to code submits tasks to.</li>
</ul></li>

<li><span class="underline">Tasks</span> (aka jobs)
<ul class="org-ul">
<li>In C++ a task could be represented by a function, object,
callable object or lambda. In Java, the task could an object
implementating the Runnable interface.</li>
</ul></li>

<li><span class="underline">Worker Threads</span>
<ul class="org-ul">
<li>N amount of long-running worker threads. Each thread takes a
task from the task queue and get blocked when if the task
queue is empty.</li>
</ul></li>
</ul></li>

<li>Functionalities of a thread pool
<ul class="org-ul">
<li>Parts
<ul class="org-ul">
<li>central task queue</li>
<li>N worker threads</li>
<li>completion queue [optional]</li>
</ul></li>
<li>Actions 
<ul class="org-ul">
<li>add thread</li>
<li>submit task or job</li>
<li>return a future object representing the return value of the
taks submited to the thread pool.</li>
<li>shutdown queue =&gt; stop all threads</li>
</ul></li>
</ul></li>

<li>Considerations:

<ul class="org-ul">
<li>A suitable size for the thread pool is the total number <span class="underline">hardware</span>
<span class="underline">threads</span>, number of threads that can be run in different
processing units. This number is generally the number of logical
CPUs (total number CPU cores).</li>

<li>Thread starvation =&gt; A single CPU intensive or long running task
will make a thread unable to handle other pending tasks.</li>

<li>The tasks should not block any worker thread, they must be short
living. Otherwise the blocked worker thread may not be able to
handle other tasks from the task queue.</li>

<li>It is wise to use IO and socket with timeouts in operations that
may block the task queue.</li>
</ul></li>

<li>Usage for network and web servers:
<ul class="org-ul">
<li>Thread pools are scalable to handle network request when used
alongside <span class="underline">non-blocking IO</span> such as <span class="underline">epoll</span> on Linux, <span class="underline">IOCP</span> on
Windows and <span class="underline">kqueue</span> on MacOSX and BSD-variants. Nginx web server
and NodeJS uses thread pool and non blocking IO for reaching
high scalability and performance.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgfeaba94" class="outline-4">
<h4 id="orgfeaba94"><span class="section-number-4">1.13.2</span> Some thread pool implementations</h4>
<div class="outline-text-4" id="text-1-13-2">
<ul class="org-ul">
<li><a href="https://www.javacodegeeks.com/2016/12/implement-thread-pool-java.html">How to implement Thread pool in Java | Java Code Geeks - 2019</a> [JAVA] [BEST]
<ul class="org-ul">
<li>Java implementation: Internally it uses a LinkedBlockingQueue as
a task queue (message queue) and a group of worker threads
taking tasks from the queue and executing them in an infinite
loop. The tasks or jobs submited to the thread pool are
represented by the Runnable interface.</li>
</ul></li>

<li><a href="https://kezunlin.me/post/f241bd30/">boost thread pool example | KeZunLin's Blog</a>
<ul class="org-ul">
<li>Thread pool built on top of Boost.Asio.</li>
</ul></li>

<li><a href="http://progsch.net/wordpress/?p=71">A Thread Pool with Boost.Threads and Boost.Asio | Jakob's Devlog</a></li>

<li><a href="https://github.com/yc2prime/ThreadPool">GitHub -  yc2prime/ThreadPool</a>
<ul class="org-ul">
<li>A C++ thread pool implementation base on Boost.Asio.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0d799f3" class="outline-4">
<h4 id="org0d799f3"><span class="section-number-4">1.13.3</span> Example: Simple thread pool implementation</h4>
<div class="outline-text-4" id="text-1-13-3">
<p>
File: thread-pool-simple.cpp 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">iostream</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">functional</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">vector</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">string</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Concurrency headers</span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">deque</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">queue</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">thread</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">mutex</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">atomic</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">condition_variable</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">chrono</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">cassert</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-keyword">class</span> <span class="org-type">ThreadPool</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-function-name">public</span>:
    <span class="org-keyword">using</span> <span class="org-type">Task</span> = <span class="org-constant">std</span>::<span class="org-type">function</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">void</span> <span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Create a thread pool with N worker threads</span>
    <span class="org-function-name">ThreadPool</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">size_t</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] Created thread pool with N = "</span>
                  &lt;&lt; n &lt;&lt; <span class="org-string">" worker threads"</span> &lt;&lt; <span class="org-constant">std</span>::endl;

        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; n; ++i<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">this</span>-&gt;add_worker<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-function-name">ThreadPool</span><span class="org-rainbow-delimiters-depth-2">()</span>: ThreadPool<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-constant">std</span>::<span class="org-constant">thread</span>::hardware_concurrency<span class="org-rainbow-delimiters-depth-3">()</span><span class="org-rainbow-delimiters-depth-2">){</span> <span class="org-rainbow-delimiters-depth-2">}</span>

    ~<span class="org-function-name">ThreadPool</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] &lt;Destructor&gt; Waiting for termination of all threads"</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-keyword">this</span>-&gt;shutdown<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] &lt;Destructor&gt; All Worker threads were shutdown. OK"</span>
                  &lt;&lt; <span class="org-constant">std</span>::endl;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Return the number of worker threads</span>
    <span class="org-type">size_t</span> <span class="org-function-name">size</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-keyword">const</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">return</span> m_workers.size<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Submit a task to the thread pool</span>
    <span class="org-type">void</span> <span class="org-function-name">submit</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">Task</span> <span class="org-variable-name">task</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-3">&gt;{</span>m_qmutex<span class="org-rainbow-delimiters-depth-3">}</span>;
        m_queue.push<span class="org-rainbow-delimiters-depth-3">(</span>task<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Wake up a single worker thread signaling it.</span>
        m_qvar.notify_one<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Force ThreadPool shutdown</span>
    <span class="org-type">void</span> <span class="org-function-name">shutdown</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Set the flag to false for indicating to worker threads that</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">there nor further tasks(jobs) will be submited.</span>
        m_is_active = <span class="org-constant">false</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Signal all threads, wake up all worker threads</span>
        m_qvar.notify_all<span class="org-rainbow-delimiters-depth-3">()</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Wait for completion of all threads.</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">auto</span>&amp; <span class="org-variable-name">worker</span>: m_workers<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> worker.join<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Remove all worker threads</span>
        m_workers.clear<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Block the calling thread and waits for the completion of all tasks.</span>
    <span class="org-type">void</span> <span class="org-function-name">wait_tasks</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::<span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-3">&gt;{</span>m_qmutex<span class="org-rainbow-delimiters-depth-3">}</span>;
        m_qempty.wait<span class="org-rainbow-delimiters-depth-3">(</span>lock, <span class="org-rainbow-delimiters-depth-4">[</span>&amp;<span class="org-rainbow-delimiters-depth-4">]{</span> <span class="org-keyword">return</span> m_queue.empty<span class="org-rainbow-delimiters-depth-5">()</span>; <span class="org-rainbow-delimiters-depth-4">}</span> <span class="org-rainbow-delimiters-depth-3">)</span>;
        lock.unlock<span class="org-rainbow-delimiters-depth-3">()</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Pop a task from queue =&gt; blocking the calling thread</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">if the queue is empty.</span>
    <span class="org-type">Task</span> <span class="org-function-name">pop_task</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">auto</span> <span class="org-variable-name">lock</span> = <span class="org-constant">std</span>::<span class="org-type">unique_lock</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-3">&gt;{</span>m_qmutex<span class="org-rainbow-delimiters-depth-3">}</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Block current thread if the queue is empty or until</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">the condition variable is signaled from the queue</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">thread.</span>
        m_qvar.wait<span class="org-rainbow-delimiters-depth-3">(</span>lock, <span class="org-rainbow-delimiters-depth-4">[</span>&amp;<span class="org-rainbow-delimiters-depth-4">]{</span> <span class="org-keyword">return</span> <span class="org-negation-char">!</span>m_queue.empty<span class="org-rainbow-delimiters-depth-5">()</span>; <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-keyword">auto</span> <span class="org-variable-name">task</span> = m_queue.front<span class="org-rainbow-delimiters-depth-3">()</span>;
        m_queue.pop<span class="org-rainbow-delimiters-depth-3">()</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Wake up thread that called .wait_tasks()</span>
        <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-3">(</span>m_queue.empty<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">){</span> m_qempty.notify_all<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">lock.unlock();</span>
        <span class="org-keyword">return</span> task;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Add new worker thread</span>
    <span class="org-type">void</span> <span class="org-function-name">add_worker</span><span class="org-rainbow-delimiters-depth-2">()</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>

        <span class="org-keyword">auto</span> <span class="org-variable-name">th</span> = <span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">[</span><span class="org-keyword">this</span><span class="org-rainbow-delimiters-depth-4">]{</span>
            <span class="org-keyword">while</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-5">)</span>
            <span class="org-rainbow-delimiters-depth-5">{</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">std::puts(" [INFO] Waiting task");</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">task</span> = pop_task<span class="org-rainbow-delimiters-depth-6">()</span>;
                task<span class="org-rainbow-delimiters-depth-6">()</span>;

                <span class="org-comment-delimiter">// </span><span class="org-comment">Shutdown worker thread when the flag m_is_active</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">is set to false and the queue is empty</span>
                <span class="org-keyword">auto</span> <span class="org-variable-name">guard</span> = <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-6">&lt;</span><span class="org-constant">std</span>::mutex<span class="org-rainbow-delimiters-depth-6">&gt;{</span>m_qmutex<span class="org-rainbow-delimiters-depth-6">}</span>;
                <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-6">(</span><span class="org-negation-char">!</span>m_is_active &amp;&amp; m_queue.empty<span class="org-rainbow-delimiters-depth-7">()</span><span class="org-rainbow-delimiters-depth-6">){</span> <span class="org-keyword">return</span>; <span class="org-rainbow-delimiters-depth-6">}</span>
            <span class="org-rainbow-delimiters-depth-5">}</span>

        <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] &lt;add_worker&gt; - Created worker thread ID = "</span>
                  &lt;&lt; th.get_id<span class="org-rainbow-delimiters-depth-3">()</span> &lt;&lt; <span class="org-constant">std</span>::endl;

        m_workers.push_back<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-constant">std</span>::<span class="org-type">move</span><span class="org-rainbow-delimiters-depth-4">(</span><span class="org-variable-name">th</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>;

    <span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-comment-delimiter">// </span><span class="org-comment">--- End of add_worker() --- //</span>

<span class="org-function-name">private</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">Flag indicating that the thread pool is active (running)</span>
    <span class="org-constant">std</span>::<span class="org-type">atomic</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">bool</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>       <span class="org-variable-name">m_is_active</span> = <span class="org-constant">true</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Task queue (message queue)</span>
    <span class="org-constant">std</span>::<span class="org-type">queue</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Task</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>        <span class="org-variable-name">m_queue</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Worker threads</span>
    <span class="org-constant">std</span>::<span class="org-type">deque</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::thread<span class="org-rainbow-delimiters-depth-2">&gt;</span> <span class="org-variable-name">m_workers</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Mutex for protecting the queue</span>
    <span class="org-constant">std</span>::<span class="org-type">mutex</span>              <span class="org-variable-name">m_qmutex</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Condition variable for signaling that</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">there are tasks in the queue</span>
    <span class="org-constant">std</span>::<span class="org-type">condition_variable</span> <span class="org-variable-name">m_qvar</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Condition variable for signaling that the task queue is empty</span>
    <span class="org-constant">std</span>::<span class="org-type">condition_variable</span> <span class="org-variable-name">m_qempty</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;


<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span>** <span class="org-variable-name">argv</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">std</span>::<span class="org-constant">chrono_literals</span>;


    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>argc &lt; 3<span class="org-rainbow-delimiters-depth-2">){</span>
        <span class="org-constant">std</span>::cerr&lt;&lt; <span class="org-string">" Error: invalid command line switch."</span> &lt;&lt; <span class="org-constant">std</span>::endl;
        <span class="org-keyword">return</span> EXIT_FAILURE;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">auto</span> <span class="org-variable-name">cmd</span> = <span class="org-constant">std</span>::string<span class="org-rainbow-delimiters-depth-2">(</span>argv<span class="org-rainbow-delimiters-depth-3">[</span>1<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    <span class="org-keyword">auto</span> <span class="org-variable-name">size</span> = <span class="org-constant">std</span>::stoi<span class="org-rainbow-delimiters-depth-2">(</span>argv<span class="org-rainbow-delimiters-depth-3">[</span>2<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">)</span>;
    assert<span class="org-rainbow-delimiters-depth-2">(</span>size &gt; 0<span class="org-rainbow-delimiters-depth-2">)</span>;

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>cmd == <span class="org-string">"serial"</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size; i++<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
                <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::seconds<span class="org-rainbow-delimiters-depth-5">(</span>2<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>;
                <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Task id = "</span> &lt;&lt; i
                          &lt;&lt; <span class="org-string">" thread id = "</span> &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::get_id<span class="org-rainbow-delimiters-depth-4">()</span>
                          &lt;&lt; <span class="org-string">" completed OK. \n"</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-keyword">return</span> EXIT_FAILURE;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">if</span><span class="org-rainbow-delimiters-depth-2">(</span>cmd == <span class="org-string">"parallel"</span><span class="org-rainbow-delimiters-depth-2">)</span>
    <span class="org-rainbow-delimiters-depth-2">{</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Get thread pool size from environemnt variable</span>
        <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">thsize</span> = <span class="org-constant">std</span>::getenv<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">"THREAD_POOL_SIZE"</span><span class="org-rainbow-delimiters-depth-3">)</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">std::cout &lt;&lt; " thsize = " &lt;&lt; thsize &lt;&lt; std::endl;</span>

        <span class="org-type">int</span> <span class="org-variable-name">n_workers</span> = thsize != <span class="org-constant">nullptr</span>
                            ? <span class="org-constant">std</span>::stoi<span class="org-rainbow-delimiters-depth-3">(</span>thsize<span class="org-rainbow-delimiters-depth-3">)</span> : <span class="org-constant">std</span>::<span class="org-constant">thread</span>::hardware_concurrency<span class="org-rainbow-delimiters-depth-3">()</span>;

        <span class="org-type">ThreadPool</span> <span class="org-variable-name">thp</span><span class="org-rainbow-delimiters-depth-3">(</span>n_workers<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Mutex used for protecting std::cout from data race</span>
        <span class="org-constant">std</span>::<span class="org-type">mutex</span> <span class="org-variable-name">cout_mutex</span>;

        <span class="org-comment-delimiter">// </span><span class="org-comment">Run</span>
        <span class="org-keyword">for</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; size; i++<span class="org-rainbow-delimiters-depth-3">)</span>
        <span class="org-rainbow-delimiters-depth-3">{</span>
            thp.submit<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-rainbow-delimiters-depth-5">[</span>=, &amp;<span class="org-variable-name">cout_mutex</span><span class="org-rainbow-delimiters-depth-5">]{</span>
                <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::sleep_for<span class="org-rainbow-delimiters-depth-6">(</span><span class="org-constant">std</span>::<span class="org-constant">chrono</span>::seconds<span class="org-rainbow-delimiters-depth-7">(</span>2<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>;

                <span class="org-rainbow-delimiters-depth-6">{</span>
                    <span class="org-constant">std</span>::<span class="org-type">lock_guard</span><span class="org-rainbow-delimiters-depth-7">&lt;</span><span class="org-constant">std</span>::<span class="org-type">mutex</span><span class="org-rainbow-delimiters-depth-7">&gt;</span> <span class="org-variable-name">guard</span><span class="org-rainbow-delimiters-depth-7">(</span>cout_mutex<span class="org-rainbow-delimiters-depth-7">)</span>;
                    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" Task id = "</span> &lt;&lt; i
                              &lt;&lt; <span class="org-string">" thread id = "</span> &lt;&lt; <span class="org-constant">std</span>::<span class="org-constant">this_thread</span>::get_id<span class="org-rainbow-delimiters-depth-7">()</span>
                              &lt;&lt; <span class="org-string">" completed OK. \n"</span>;
                <span class="org-rainbow-delimiters-depth-6">}</span>

            <span class="org-rainbow-delimiters-depth-5">}</span><span class="org-rainbow-delimiters-depth-4">)</span>;
        <span class="org-rainbow-delimiters-depth-3">}</span>
        <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">" [TRACE] &lt;main&gt; Waiting tasks execution ..."</span> &lt;&lt; <span class="org-string">"\n"</span>;
    <span class="org-rainbow-delimiters-depth-2">}</span>

    <span class="org-keyword">return</span> 0;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Building: 
</p>

<div class="org-src-container">
<pre class="src src-sh">$ clang++ thread-pool-simple.cpp -o <span class="org-keyword">out.bin</span> -std=c++1z -lpthread -O0 -g -Wall -Wextra -fsanitize=thread -fsanitize=undefined
</pre>
</div>

<p>
Run 20 tasks serially: (40 seconds)
</p>

<div class="org-src-container">
<pre class="src src-sh">$ time ./out.bin serial 20
 Task id = 0 thread id = 140386475086592 completed OK. 
 Task id = 1 thread id = 140386475086592 completed OK. 
 Task id = 2 thread id = 140386475086592 completed OK. 
 Task id = 3 thread id = 140386475086592 completed OK. 
  ... ...   ... ...   ... ...   ... ...   ... ... 
  ... ...   ... ...   ... ...   ... ...   ... ... 
 Task id = 17 thread id = 140386475086592 completed OK. 
 Task id = 18 thread id = 140386475086592 completed OK. 
 Task id = 19 thread id = 140386475086592 completed OK. 

real    0m40.086s
user    0m0.037s
sys     0m0.045s

</pre>
</div>

<p>
Run 20 tasks with thread pool of 4 threads. (10 seconds)
</p>

<div class="org-src-container">
<pre class="src src-sh">$ time ./out.bin parallel 20
 [TRACE] Created thread pool with N = 4 worker threads
 [TRACE] &lt;add_worker&gt; - Created worker thread ID = 139760855148288
 [TRACE] &lt;add_worker&gt; - Created worker thread ID = 139760846755584
 [TRACE] &lt;add_worker&gt; - Created worker thread ID = 139760836278016
 [TRACE] &lt;add_worker&gt; - Created worker thread ID = 139760827885312
 [TRACE] &lt;main&gt; Waiting tasks execution ...
 [TRACE] &lt;Destructor&gt; Waiting for termination of all threads
 Task id = 0 thread id = 139760846755584 completed OK. 
 Task id = 3 thread id = 139760827885312 completed OK. 
 Task id = 1 thread id = 139760855148288 completed OK. 
 Task id = 2 thread id = 139760836278016 completed OK. 

 ... ... ...      ... ... ...      ... ... ...      ... ... ...  

 Task id = 17 thread id = 139760827885312 completed OK. 
 Task id = 18 thread id = 139760836278016 completed OK. 
 Task id = 19 thread id = 139760846755584 completed OK. 
 [TRACE] &lt;Destructor&gt; All Worker threads were shutdown. OK

real    0m10.103s
user    0m0.050s
sys     0m0.062s

</pre>
</div>
</div>
</div>
<div id="outline-container-org5f61b3c" class="outline-4">
<h4 id="org5f61b3c"><span class="section-number-4">1.13.4</span> Further Reading</h4>
<div class="outline-text-4" id="text-1-13-4">
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Thread_pool">Thread pool - Wikipedia</a></li>

<li><a href="https://www.javacodegeeks.com/2016/12/implement-thread-pool-java.html">How to implement Thread pool in Java | Java Code Geeks - 2019</a> [BEST]</li>

<li><a href="https://www.geeksforgeeks.org/thread-pools-java/">Thread Pools in Java - GeeksforGeeks</a> [BEST]
<ul class="org-ul">
<li>Shows some potential problems of thread pools, namely, deadlock,
thread leakage and resource trashing.</li>
</ul></li>

<li><a href="http://zhidko.net/threadpool.html">How Thread Pool design pattern works</a> - Zhidko</li>

<li><a href="https://stackify.com/java-thread-pools/">Finally Getting the Most out of the Java Thread Pool</a></li>

<li><a href="https://thispointer.com/designing-a-thread-pool-framework-part-1-whats-the-need-of-a-thread-pool/">Designing a Thread Pool Framework Part 1: What’s the need of a Thread Pool – thispointer.com</a></li>

<li><a href="https://www.codeproject.com/Articles/3631/A-Method-of-Worker-Thread-Pooling">A Method of Worker Thread Pooling - CodeProject</a></li>

<li><a href="https://stackoverflow.com/questions/11191501/design-pattern-for-threadpooling">java - Design pattern for threadpooling - Stack Overflow</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Caio Rodrigues Soares - caiorss [DOT] rodrigues [AT] gmail [DOT] COM</p>
<p class="date">Created: 2020-05-21 Thu 08:34</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
