#+INCLUDE: theme/style.org
#+TITLE: CPP/C++ Compiler Flags and Options 
#+DESCRIPTION: cpp c++ compiler flags command line options 
#+STARTUP: content 

- [[wiki:index][Index]]

* Compiler flags and invocation 
** GCC, GCC/Mingw and Clang++
*** Overview

 *Search Path and Library Linking Flags* 

 * -l[linalg]
   + => Links to shared library or shared object - Specifically, it
     links to linalg.dll on Windows, liblinalg.so (on Unix-like oses like
     Linux, BSD, AIX, ...) or linalg.dylib on MacOSX.

 * -L[/path/to/shared-libraries]
   + => Add search path to shared libraries, directory containing
     *.so, *.dll or *.dlyb files such as libLinearAlgebra.so depending
     on the current operating system.

 * -I[/path/to/header-files]
   * Add search path to header files (.h) or (.hpp).

 * -D[FLAG] or -D[FLAG]=VALUE
   * Pass preprocessor flag #if FLAG ... 


 *GCC and Clang* Most common compiler flags: 

 + std - Specify the C++ version or ISO standard version.
   + -std=c++11 (ISO C++11)
   + -std=c++14 (ISO C++14)
   + -std=c++1z (ISO C++17)
   + -std=c++20 (C++20 experimental)
   + -std=gnu++ (ISO C++ with GNU extensions)

 + Verbosity - [W stands for warning]
   + _-Wall_
     + Turns on lots of compiler warning flags, specifically
       (-Waddress, -Wcomment, -Wformat, -Wbool-compare,
       -Wuninitialized, -Wunknown-pragmas, -Wunused-value,
       -Wunused-value ...)

   + _-Werror_
     + Turn any warning into a _compilation error_. 

   + -Wextra or just -W ([[https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html][see more]])
     + Enables extra flags not enabled by -Wall, such as
       -Wsign-compare (C only), -Wtype-limits, -Wuninitialized ...

   + -pendantic or -Wpendantic
     + Issue all warning required by ISO C and ISO C++ standard, it
       issues warning whenever there are compiler extensions non
       compliant to ISO C or C++ standard.
   + -Wconversion
   + -Wcast-align
   + -Wunnused
   + -Wshadow
   + -Wold-style-cast
   + -Wpointer-arith -Wcast-qual -Wmissing-prototypes -Wno-missing-braces 

 + Output file: -o <outputfile>
   + g++ file.cpp -o file.bin

 + Common library flags
   + -lm - Compiles against the shared library libm (basic math
     library, mostly C only)
   + -lpthread  - Compile against Posix threads shared library

 + Include Path - Directories containing headers files.
   + -I/path/to/include1 -I/path/to/include2 ... 

 + Compilation flags *-D<flag name>*
   + ~-DCOMPILE_VAR~ -> Enable flag COMPILE_VAR - It is equivalent to
     add to the code (#define COMPILE_VAR)
   + ~-DDO_SOMETHING=1~  - Equivalent to add to the code _#define DO_SOMETHING = 1_
   + ~-DDISABLE_DEPRECATED_FUNCTIONS=0~

 + *Optmization* - [[https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html][docs]]
   + -O0
     + No optmization, faster compilation time, better for debugging builds. 
   + -O2 
   + -O3
     + Higher level of optmization. Slower compile-time, better for
       production builds.
   + -OFast
     + Enables higher level of optmization than (-O3). It enables lots
       of flags as can be seen [[https://stackoverflow.com/questions/3005564/gcc-options-for-fastest-code][src]] (-ffloat-store, -ffsast-math,
       -ffinite-math-only, -O3 ...)
   + -finline-functions
   + -m64
   + -funroll-loops
   + -fvectorize
   + -fprofile-generate

 + Misc
   + -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4

 + *Special Options* 

   + _-g_
     + => Builds executable with debugging symbols for GDB GNU
       Debugger or LLDB Clang/LLVM Debugger. It should only be used
       during development for debugging builds.

   + -c
     + => Compiler source(s) to object-code (input to linker). This
       option is better for incremental compilation when using
       multiple files. 

   + _-pie_
     + => Builds a dynamically linked position independent executable.

   + _-static-pie_
     + => Builds a staticlaly linked position independent executable.

   + _-shared_
     + => Build a shared library (.so or .dylib on U*nix-like Oses) or
       .dll on MS-Windows.

   + _-fno-exceptions_ 
     + => Disable C++ exceptions (it may be better for embedded systems
       or anything where exceptiions may not be acceptable).

   + _-fno-rtti_
     + => Disable RTTI (Runtime Type Information) - There many
       texts around where game and embedded systems developers report
       that they disable RTTI due to performance concerns.

   + _-fvisibility=hidden_
     + => Make library symbols hidden by default, in a similar way to
       what happens in Windows DLLs where exported symbols must have
       the prefix __declspec(dllexport) or __declspec(dllimport). When
       all symbols are exported by default, it may increase the
       likelyhood of undefined behavior if there a multiple
       definitions of same symbol during linking. See more at:
     + [[https://labjack.com/news/simple-cpp-symbol-visibility-demo][Simple C++ Symbol Visibility Demo | LabJack]]
     + 

   + https://wiki.debian.org/Hardening
     + => Lots of compiler flags for hardening security.


 *Files Generated by the Compiler* 
 + Object Files
   + *.o -> Generated on *NIX - Linux, MacOSX ... by GCC or Clang
   + *.obj -> Windows
 + Binary Native Executable - Object Code
   + *NIX: Linux, MacOSX, FreeBSD -> Without extension.
   + Windows: *.exe
   + *.hex -> Extension of many compiled firmwares generated by
     embedded systems compilers such as proprietary compilers for
     Microcontrollers.  
 + Shared Objects - Shared Libraries
   + *.dll -> Called dynamic linked libraries on Windows -> libplot.dll
   + *.so  -> Called shared Object on Linux -> libplot.so
   + *.dylib -> Extension used on MacOSX.
 + Static Library
   + *.a - extension 

Review See: 

 + [[https://gist.github.com/gubatron/32f82053596c24b6bec6][Things to remember when compiling and linking C/C++ programs Â· GitHub]]

 + [[https://msdn.microsoft.com/en-us/library/y0zzbyt4.aspx][Linker Options]]

C++ Compiler Online: 

 + http://rextester.com/FCCXK65881

*** Compiler invocation examples
*** Example - Build executable with unified compilation

Compile file1.cpp, file.cpp, file2.cpp into the executable app.bin 

 - Option 1: Compile and link once in a single command. The
   disadvantage of this way is the slower compile time rather than
   separate compilation and linking. 

#+BEGIN_SRC sh 
  # CC=gcc 
  CC=clang++

  $ clang++ file1.cpp file2.cpp file3.cpp \
    -std=c++14  -o app.bin -O3 -g \
    -Wall -Wextra -pendantic \
    -lpthread -lblas -lboost_system -lboost_filesystem \
    -I./include/path1/with/headers1 -I./include2 -L./path/lib1 -L./pathLib2
#+END_SRC
 
Explanation: 

 + -std=c++14 -> Set the C++ version. This flag can be C++11, C++14,
   C++17, C++20 ... 
 + -o app.bin -> Set the output native executable file ot app.bin
 + -I./include/path1/with/headers
   + Directory with header files
 + -g Produce executable with debug symbols
 + -Wall -Wextra -Wshadow 
   + Warning flags - enable more verbosity which helps to catch bugs
     earlier.
 + -O3 - Use optmization of level 3 - the disadvantage of using
   optmization is the slower compile time. So this flag should only be
   enabled on production builds.
 + -lpthread -lblas ~-lboost_system~ ~-lboost_filesystem~
   + Link against shared libraries (extensions: *.so - Unix, *.dylib
     or *.dll on Windows) pthread, blas, ~boost_system~ ...

*** Compile source with static Linking

#+BEGIN_SRC sh 
 $ gcc -static example.o -lgsl -lgslcblas -lm
#+END_SRC
*** Release / Debug building 

Compiler: 

 + GCC and CLANG
   + Debug: No optmized, but faster building time.
     * -OO -g  
   + Release:
     * -O3 -s -DNDEBUG [-march=native] [-mtune=native]
     * -O2 -s -DNDEBGU
 + MSVC:
   + Debug:
     * /MDd /Zi /Ob0 /Od /RTC1
   + Release:
     * /MD /O1 /Ob1 /DNDEBUG
Note: 
 - For GCC and Clang
   + -OO means no optmization
   + -g - adds debugging symbols to executable.
   + -DNDEBUG - disable assertions


References: 

 + [[https://stackoverflow.com/questions/1534912/how-to-build-in-release-mode-with-optimizations-in-gcc][c++ - How to build in release mode with optimizations in GCC? - Stack Overflow]]

 + 

** MSVC (VC++) Compiler Options 

 MSVC Native tools: 

  * CC = cl.exe
    + C and C++ Compiler - Can compile both C and C++ code depending on
      the flag. By default it compiles C++ code.
  * rc.exe => Resource Compiler.
  * LD = link.exe 
    + C++ Linker.
  * AS = ml
    + Assembler 
  * AR = lib
    + Archiver 

 Compiler: cl.exe 

  + /nologo - Suppress microsoft's logo

  + /out:<file.exe> - Set output file name.

  + /EHsc

  + /Zi - Add debugging symbols to the executable

  + /c - Doesn't link generating *.exe or *.dll, it creates only
    intermedidate object code for further separate linking. It is
    useful for compiling large code bases where each compilation unit
    can be compiled separately.

  + /W4 - Set the level of warning to the highest.

  + /entry:<entrypoint> - Set the C/C++ runtime, it can be:
    + mainCRTStartup     => calls main(), the entrypoint for console mode apps
    + wmainCRTStartup    => calls wmain(), as above but the Unicode version
    + WinMainCRTStartup  => calls WinMain(), the entrypoint for native Windows apps
    + wWinMainCRTStartup => calls wWinMain(), as above but the Unicode version
    + _DllMainCRTStartup => Calls DLLMain() 

  + /subsystem:<type> - Set the subsystem - default Console, it can be:

    + _/subsystem:console_ - For applications that necessarly runs in the
      console (aka terminal emulator)

    + _/subsystem:windows_ - Doesn't display the cmd.exe terminal when
      ones click at the application executable.

  + /TC  -> Specify that file name is C source code
  + /TP  -> Specify that file name is a C++ source code (default)
  + /MD, /MT, /LD => Run-time library - Indcates that object-code
    (compiled program) is a DLL.
  + /GF -> (Eliminate Duplicate Strings) - Enables the compiler to
    create a single copy of identical strings in the program image and
    in memory during execution. This is an optimization called string
    pooling that can create smaller programs.

 See: 
  + https://github.com/MicrosoftDocs/cpp-docs/blob/master/docs/build/building-on-the-command-line.md

 Useful preprocessor: 

  - Set subsystem 

 #+BEGIN_SRC cpp 
   #pragma comment(linker, "/SUBSYSTEM:WINDOWS")
   #pragma comment(linker, "/SUBSYSTEM:CONSOLE")
 #+END_SRC

  - Set linker library to be linked. This pragma is particularly useful
    in graphical applications.

 #+BEGIN_SRC cpp 
   #pragma comment(lib, "user32.lib")
 #+END_SRC

 Examples: 

  + Compile multiple files generating an executable named out.exe. Note
    the default subsystems is the console (_/subsystem:console_) and the
    default entry point is (mainCRTStartup).
    + /Isrc/includes  => Directories containing header files
    + /ld or /linker  => Linker flags
    + && out.exe      => If the compilation is successful runs the
      generated executable out.exe 

 #+BEGIN_SRC sh 
   $ cl.exe source1.cpp source2.cpp /Fe:out.exe /Isrc/includes /ld gdi.lib user32.lib && out.exe
 #+END_SRC

  - Compile multiple files for windows subsystem (GUI app) and with
    wmainCRtstartup.

 #+BEGIN_SRC sh 
   $ cl.exe source1.cpp source2.cpp /Fe:out.exe /Isrc/includes /entry:wmainCRtstartup /subsystem:windows /ld user32.lib && out.exe
 #+END_SRC

 References: 

  + [[http://psy.swansea.ac.uk/staff/carter/Compiling/compilation_build.htm][Command Line Compilation]]
  + [[https://cognitivewaves.wordpress.com/makefiles/][Makefiles and Visual Studio | Cognitive Waves]]
  + [[http://resources.esri.com/help/9.3/arcgisengine/com_cpp/Cpp/reference/Makefile.Windows.htm][C++ Windows Makefile]]
  + [[https://w3.cs.jmu.edu/bernstdh/web/common/help/msc_development.php][MS C/C++: The Command-Line Tools]]

 See also: 
 
  + [[https://support.microsoft.com/en-us/help/94248/how-to-use-the-c-run-time][How To Use the C Run-Time]]

  + 

  + 
** CMake Building Script Reference 
*** Build some project with CMAKE 

A project using Cmake as building system contains a build script at
top level directory named CMakeLists.txt. To build a project with
CMake, it is necessary to consider that CMake, is not a building
system and does not build anything. Actually, Cmake generates building
scripts for the platform preferred building scripts. For instance, on
Linux, it can generate Makefile, Eclipse Makefiles; on Windows it can
generate MSBuild scripts, NMake (Windows SDK's make) and so on.

 + Check all possible building system for which CMake can generate
   build scripts.
   + Command: $ *cmake -G*

#+BEGIN_SRC sh 
   # Running on Windows 10 
   $ cmake -G
   CMake Error: No generator specified for -G

   Generators
     Visual Studio 15 2017 [arch] = Generates Visual Studio 2017 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 14 2015 [arch] = Generates Visual Studio 2015 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 12 2013 [arch] = Generates Visual Studio 2013 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 11 2012 [arch] = Generates Visual Studio 2012 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 10 2010 [arch] = Generates Visual Studio 2010 project files.
                                    Optional [arch] can be "Win64" or "IA64".
     Visual Studio 9 2008 [arch]  = Generates Visual Studio 2008 project files.
                                    Optional [arch] can be "Win64" or "IA64".
     Borland Makefiles            = Generates Borland makefiles.
     NMake Makefiles              = Generates NMake makefiles.
     NMake Makefiles JOM          = Generates JOM makefiles.
     Green Hills MULTI            = Generates Green Hills MULTI files
                                    (experimental, work-in-progress).
     MSYS Makefiles               = Generates MSYS makefiles.
     MinGW Makefiles              = Generates a make file for use with
                                    mingw32-make.
     Unix Makefiles               = Generates standard UNIX makefiles.
     Ninja                        = Generates build.ninja files.
     Watcom WMake                 = Generates Watcom WMake makefiles.
     CodeBlocks - MinGW Makefiles = Generates CodeBlocks project files.
     CodeBlocks - NMake Makefiles = Generates CodeBlocks project files.
     CodeBlocks - NMake Makefiles JOM
                                  = Generates CodeBlocks project files.
     CodeBlocks - Ninja           = Generates CodeBlocks project files.
     CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files.
     CodeLite - MinGW Makefiles   = Generates CodeLite project files.
     CodeLite - NMake Makefiles   = Generates CodeLite project files.
     CodeLite - Ninja             = Generates CodeLite project files.
     CodeLite - Unix Makefiles    = Generates CodeLite project files.
     Sublime Text 2 - MinGW Makefiles
                                  = Generates Sublime Text 2 project files.
     Sublime Text 2 - NMake Makefiles
                                  = Generates Sublime Text 2 project files.
     Sublime Text 2 - Ninja       = Generates Sublime Text 2 project files.
     Sublime Text 2 - Unix Makefiles
                                  = Generates Sublime Text 2 project files.
     Kate - MinGW Makefiles       = Generates Kate project files.
     Kate - NMake Makefiles       = Generates Kate project files.
     Kate - Ninja                 = Generates Kate project files.
     Kate - Unix Makefiles        = Generates Kate project files.
     Eclipse CDT4 - NMake Makefiles
                                  = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - MinGW Makefiles
                                  = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - Ninja         = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files.
#+END_SRC

 *STEP 1: Generate Building Script*

Project directory listing:

#+BEGIN_SRC sh 
  $ tree .
  .
  âââ build.bat
  âââ client1.cpp
  âââ CMakeLists.txt
  âââ Makefile
  âââ pywrapper.py
  âââ testlib.cpp
  âââ testlib.hpp
#+END_SRC

 *Generate building scripts for platform-preferred building system:*

 + $ cmake -H<SOURCE> -B<BUILD>
   + <SOURCE> => Source directory where all *.cpp, *.hpp code. In this
     case it is (.) dot, current directory. If the directory was
     ./src, the command would be -Hsrc or -H./src
   + <BUILD> => Compilation output, directory where are all building
     scripts. 

Command output on Windows 10 - MSVC 2017. Note: It will set VC++ for
32 bits target, not 64 bits.

#+BEGIN_SRC sh 
  $ cmake -H. -Bbuild
  -- Building for: Visual Studio 15 2017
  -- The C compiler identification is MSVC 19.16.27025.1
  -- The CXX compiler identification is MSVC 19.16.27025.1  
  ... ...   ... ...   ... ...   ... ...   ... ... 
  -- Configuring done
  -- Generating done
  -- Build files have been written to: C:/Users/archbox/Desktop/experiments/dll/build
#+END_SRC

Command output on Linux: 

#+BEGIN_SRC sh 
  $ cmake -H. -Bbuild
  -- The C compiler identification is GNU 8.2.1
  -- The CXX compiler identification is GNU 8.2.1
  -- Check for working C compiler: /usr/lib64/ccache/cc
  -- Check for working C compiler: /usr/lib64/ccache/cc -- works
  ... ...   ... ...   ... ...   ... ...   ... ... 
   [INFO] Libtest location is at: libtest_location-NOTFOUND
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/gist/build

  # List ./build directory 
  $ tree -L 1 build
  build
  âââ CMakeCache.txt
  âââ CMakeFiles
  âââ cmake_install.cmake
  âââ Makefile

  1 directory, 3 files
#+END_SRC

  *Generate building script for specific building system:*

 + $ cmake -H<SOURCE> -B<BUILD> -G <BUILD-SYSTEM>
   + <SOURCE> => Source directory where all *.cpp, *.hpp code. In this
     case it is (.) dot, current directory. If the directory was
     ./src, the command would be -Hsrc or -H./src
   + <BUILD> => Compilation output, directory where are all building
     scripts.
   + <BUILD-SYSTEM> => All available build system can be listed with $ cmake -G.

#+BEGIN_SRC sh 
 # Generate MSbuild building scripts for 32 bits target 
  $ cmake -H. -Bbuild -G "Visual Studio 15 2017"

  # Generate MSbuild building scripts for 64 bits target 
  $ cmake -H. -Bbuild -G "Visual Studio 15 2017 Win64"
#+END_SRC

 *Generate building script with debug symbols enabled:*

It automatically adds the debugging flags (/Zi) for VC++ Microsoft
Visual C++ Compiler which necessary for debugging a program with GDB,
LLDB or WinDBG. 

 + Add the flag *-DCMAKE_BUILD_TYPE=DEBUG*

#+BEGIN_SRC sh 
  # Example 1:
  $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG

  # Example 2:
  $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=RELEASE

  # Example 3: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"

  # Example 4: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"

  # Example 5: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=RELEASE -G "Visual Studio 15 2017 Win64"
#+END_SRC


 *STEP 2: Compile the project invoking the generated building scripts*

Invoke the building scripts indirectly using CMake:

 + $ cmake --build <BUILD>
   + <BUILD> Is the build directory generated at step 1. 

#+BEGIN_SRC sh 
  $ cmake --build build
  # OR
  $ cmake --build build --config Debug 
  # OR
  $ cmake --build build --config Release
#+END_SRC

Invoke the building script directly, call the building tool:
 + This building method depends on the current building system.

For MSBuild, the compilation becomes:

#+BEGIN_SRC sh
  $ MSBuild build\testlib.vcxproj

  Microsoft (R) Build Engine version 15.5.180.51428 for .NET Framework
  Copyright (C) Microsoft Corporation. All rights reserved.

  Build started 12/21/2018 12:49:38 PM.
  Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" on node 1 (default targets).
  Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" (1) is building "C:\Users\archbox\ Desktop\experiments\dll\build\ZERO_CHECK.vcxproj" (2) on node 1 (default targets).
  ... ... ... ... ... ... ... ... ... ... ... ... ... ... 
  testlib.vcxproj -> C:\Users\archbox\Desktop\experiments\dll\build\Debug\testlib.dll
  FinalizeBuildStatus:
    Deleting file "testlib.dir\Debug\testlib.tlog\unsuccessfulbuild".
    Touching "testlib.dir\Debug\testlib.tlog\testlib.lastbuildstate".
  Done Building Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" (default targets).
#+END_SRC

For Linux or Unix GNU-Make, the compilation becomes:

#+BEGIN_SRC sh 
   $ cd build

   $ make
   /usr/bin/cmake -H/home/archbox/root-scripts/gist -B/home/archbox/root-scripts/gist/build --check-build-system CMakeFiles/Makefile.cmake 0
   /usr/bin/cmake -E cmake_progress_start /home/archbox/root-scripts/gist/build/CMakeFiles /home/archbox/root-scripts/gist/build/CMakeFiles/progress.marks
   make -f CMakeFiles/Makefile2 all
   make[1]: Entering directory '/home/archbox/root-scripts/gist/build'
   make -f CMakeFiles/testlib.dir/build.make CMakeFiles/testlib.dir/depend
   make[2]: Entering directory '/home/archbox/root-scripts/gist/build'
   ... ... ... ... ... ... ... ... ... ... ... ... 
   [100%] Built target client1-executable
   make[1]: Leaving directory '/home/archbox/root-scripts/gist/build'
   /usr/bin/cmake -E cmake_progress_start /home/archbox/root-scripts/gist/build/CMakeFiles 0  


  # Built executables: 
  #--------------------------------
  $ file libtestlib.so 
  libtestlib.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically 
  linked, BuildID[sha1]=ce79ed7580a16cbc27bf113a2967eb1d66f496a3, not stripped

  $ file client1-executable.bin 
  client1-executable.bin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
  for GNU/Linux 3.2.0, BuildID[sha1]=8103d822a6d58497b63346dfcc1f7375599114f7, not stripped
#+END_SRC

Or just in a single step: 

#+BEGIN_SRC sh 
  $ cd build && make && cd ..
#+END_SRC

*** Show system information 

#+BEGIN_SRC sh  
  cmake --sytem-information 
#+END_SRC 

Output on Linux: 

#+BEGIN_SRC sh 
   Avoid ctest truncation of output: CTEST_FULL_OUTPUT
   ========================================================
   === MAIN VARIABLES
   ========================================================
   CMAKE_STATIC_LIBRARY_PREFIX == "lib"
   CMAKE_STATIC_LIBRARY_SUFFIX == ".a"
   CMAKE_SHARED_LIBRARY_PREFIX == "lib"
   CMAKE_SHARED_LIBRARY_SUFFIX == ".so"
   CMAKE_SHARED_MODULE_PREFIX == "lib"
   CMAKE_SHARED_MODULE_SUFFIX == ".so"


   CMAKE_DL_LIBS == "dl"
   CMAKE_LIBRARY_PATH_FLAG == "-L"
   CMAKE_LINK_LIBRARY_FLAG == "-l"
   CMAKE_SKIP_RPATH == "NO"
   CMAKE_SYSTEM_INFO_FILE == "Platform/Linux"
   CMAKE_SYSTEM_NAME == "Linux"
   CMAKE_SYSTEM == "Linux-4.18.18-200.fc28.x86_64"
   CMAKE_CXX_COMPILER == "/usr/lib64/ccache/c++"
   CMAKE_C_COMPILER == "/usr/lib64/ccache/cc"
   CMAKE_COMPILER_IS_GNUCC == "1"
   CMAKE_COMPILER_IS_GNUCXX == "1"

   // C shared library flag
   CMAKE_SHARED_LIBRARY_C_FLAGS == "-fPIC"
   CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS == "-shared"
   CMAKE_SHARED_LIBRARY_LINK_FLAGS == ""
   ... ...    ... ...    ... ...    ... ...    ... ... 
#+END_SRC

*** Show all modules 

#+BEGIN_SRC sh 
  $ cmake --help-module-list
#+END_SRC

Output: 

#+BEGIN_SRC text 
  AddFileDependencies
  AndroidTestUtilities
  BundleUtilities
  CMakeAddFortranSubdirectory
  CMakeBackwardCompatibilityCXX
  CMakeDependentOption
  CMakeDetermineVSServicePack
  CMakeExpandImportedTargets
  CMakeFindDependencyMacro
  CMakeFindFrameworks
  CMakeFindPackageMode
  CMakeForceCompiler
  CMakeGraphVizOptions

  ... ... ... ... ... ... 

  FindLAPACK
  FindLATEX
  FindLTTngUST
  FindLibArchive
  FindLibLZMA
  FindLibXml2
  FindLibXslt
  FindLua
  FindLua50
  FindLua51
  FindMFC
  FindMPEG
  FindMPEG2
  FindMPI
  FindMatlab
  FindMotif
  FindOpenACC

  ... ... ... ... ... ... ... ... 

#+END_SRC

*** SNIPPET - Detect Operating System 

Check whether current OS is Microsft Windows NT:

#+BEGIN_SRC cmake
  if(WIN32)
    # actions ... 
    message("Compiling for Windows NT")
  else()
    # else actions .... ...
  endif()
#+END_SRC

Check whether current OS is a Unix-like operating system (Linux, BSD,
MacOSX, Android and so on): 

#+BEGIN_SRC cmake 
  if(UNIX)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC

Check if current OS is MacOSX:

#+BEGIN_SRC cmake 
  if(APPLE)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC

Check if current OS is Linux:

#+BEGIN_SRC cmake 
  if(LINUX)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC

Check if current OS is UNIX, but not MacOSX:

#+BEGIN_SRC cmake
  if(UNIX AND NOT APPLE)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC

*** SNIPPET - Detect Compiler 

 *MSVC*

Check if current compiler is MSVC - Microsft - Visual C/C++ Compiler
(Visual C++, vc++ for short):

#+BEGIN_SRC cmake 
  if(MSVC)
    message(STATUS << "Running MSVC")
  endif()
#+END_SRC

 *MSVC for 32 bits target*

Detect MSVC set up for 32 bits target (buids 32 bits binaries):

#+BEGIN_SRC cmake 
  if(MSVC AND NOT CMAKE_CL_64)
    message(" [INFO] Building for 32 bits Windows target.")
  endif()
#+END_SRC

 *MSVC for 64 bits target*

#+BEGIN_SRC cmake 
  if(MSVC AND CMAKE_CL_64)
    message(" [INFO] Building for 64 bits Windows target.")
  endif()
#+END_SRC

 *Mingw* 

Check if current compiler is GCC/Mingw, GCC compiler ported to
Windows.

#+BEGIN_SRC cmake
  if(MSVC)
    message("Running Mingw/GCC maybe on Windows")
  endif()
#+END_SRC

*** SNIPPET - Common Variables 
**** CMAKE_CXX_STANDARD - Set C++ Standard

The variable ~CMAKE_CXX_STANDARD~ sets the project current C++
standard. This variable can be set to 98 (for C++98); 11 (C++11); 14
(C++14); 17 (C++17) and 20 (C++20 - experimental yet.)

 + Documentation: [[https://cmake.org/cmake/help/latest/prop_tgt/CXX_STANDARD.html#prop_tgt:CXX_STANDARD][CXX_STANDARD â CMake 3.13.2 Documentation]] 

Example: Set project to compile with C++11 ISO standard.

#+BEGIN_SRC cmake 
  set(CMAKE_CXX_STANDARD 11)
#+END_SRC

Usage: (File CMAKELists.txt)

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(MY_PROJECT_NAME)

  set(CMAKE_CXX_STANDARD 17)
  ... ... .... .... 
#+END_SRC

**** CMAKE_BUILD_TYPE - Set default building type to DEBUG 

In the debug building type optimization flags are disabled and flags
for generating debugging symbols are enabled, for GGC or GCC/Mingw and
Clang the (-g) is automatically added and for MSVC, aka VC++ (cl.exe),
the flag /Zi is also passed to the compiler. The default building type
can be set to DEBUG with the following code.

#+BEGIN_SRC cmake 
  # Set default building type to debug if it was not set
  # in command line with -DCMAKE_BUILD_TYPE=release
  if(NOT DEFINED CMAKE_BUILD_TYPE OR CMAKE_BUILD_TYPE MATCHES "")
    set(CMAKE_BUILD_TYPE  debug)
  endif()
#+END_SRC

The building type can be changed by running cmake with the flag
 (-DCMAKE_BUILD_TYPE=release). Example: 

#+BEGIN_SRC sh 
 $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"
#+END_SRC

Note: CMake is not case sensitive, so it does not matter using
'release' or RELEASE; if or IF; endif or ENDIF and so on. 

**** CMAKE_CXX_FLAGS - Compiler flags 

The globals compiler flags used to build all targets can be extended
by setting the variable CMAKE_CXX_FLAGS. However, as the compiler
flags depends on the compiler, the custom settings may not be portable
if one uses a different compiler, for instance the (-g) flag used to
generate debug symbols with GCC or Clang does not work with MSVC
(visual c++ compiler, vc++) as it uses the flag /Zi for generating
debugging symbols.

Example 1: 

#+BEGIN_SRC cmake
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}"  "-std=c++17 -g -Wall -Wextra -pendantic -O0" )
#+END_SRC

Example 2 (better):

#+BEGIN_SRC cmake
  if(NOT MSVC)
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}"  "-std=c++17 -g -Wall -Wextra -pendantic -O0" )
  endif()
#+END_SRC

