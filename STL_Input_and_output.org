#+INCLUDE: theme/style.org 
#+TITLE: CPP/C++ STL Input and Output 
#+DESCRIPTION: cpp/c++ stl standard template library algorithms and iterators
#+STARTUP: content 

 - [[wiki:index][Index]]

* C++ IO  Input and Output System 
** IO Class Hierarchy

 *C++ IO Features:*

 + Object oriented and polymorphic
 + Stateful
   + The IO classes have internal states such as precision that float
     point will be printed; base which numbers will be print such as
     octal (base 8), hexadecimal (base 16) and decimal (default).
 + Without exceptions
   + The C++ IO does not have exceptions, it indicates error through
     error flags that must be checked by the calling code.

 *IO Classes:*

 * ios - base class for streams
 * istream - input stream base class
   + ifstream => Input file stream 
   + istringstream => Input string stream
 * ostream - output stream base class
   + ofstream => Output file stream 
   + ostringstream => Output string stream
 * iostream - input/output stream base class
   + fstream => Input/Output file stream.
   + sstringstream => String stream that can be used for reading and writing.

 *IO Global Objects*

Output stream global objects (instances of std::ostream): 
 + std::cout - Standard output stream (stdout)
 + std::cerr - Standard output error stream (stderr)
 + std::clog
 + std::wcout - Standard output stream (stdout) - wide character version. 
 + std::wcerr
 + std::wclog 

Input stream global objects (instances of std::istream): 
 + std::cin  - Standard input stream (stdin)
 + std::wcin - Standard input stream (stdin), wide character version.

 *Header Files* 

 * [[https://en.cppreference.com/w/cpp/header/iostream][<iostream>]] => Basic IO 
   + _std::ostream_, _std::istream_, std::cout, std::cerr, std::clog, std::wcerr 

 * [[https://en.cppreference.com/w/cpp/header/fstream][<fstream>]] => File IO 
   + std::ifstream, std::ofstream, std::fstream

 * [[https://en.cppreference.com/w/cpp/header/sstream][<sstream>]] => String / Memory IO
   + std::stringstream, std::istringstream, std::ostringstream

 * [[https://en.cppreference.com/w/cpp/header/iomanip][<iomanip>]] => IO manipulation functions
   * std::setfill, std::setprecision, std::setw, std::right,
     std::left, std::dec, std::hex, std::quoted (C++14)

Full references at: 
 + http://www.cplusplus.com/reference/iolibrary/


#+CAPTION: C++ IO Class hierarchy
#+BEGIN_SRC text 
                                  ios
                                   +
                  +----------------+--------------+
                  |                               |
                 \|/                             \|/
              +-------+                      +--------+
              |istream|                      |ostream |
              +--+----+                      +---+----+
                 |                               |
                \|/       +-----------+         \|/
      +------------------>+  iostream +<------+--v--------+-----------+
      |          |        +-----+-----+       |           |           |
      v          v              |             v           v           v
  ,*std::cin  ifstream           |         *std::cerr   ofstream   ostringstream
             istringstream      |          *std::cout
                                |          *std::clog
                          ------v------
                          |           |
                          v           v
                       fstream stringstream
#+END_SRC


 *Statefullness* 

The C++ IO streams are stateful, they have internal states for IO
configuration such as [[https://en.cppreference.com/w/cpp/io/ios_base/fmtflags][IO flags]] and numerical precision. In the
following code, the IO manipulator std::boolalpha enables the IO flag
std::ios_base::boolalpha that makes the IO stream print booleans as
string instead of '0' or '1'. The flag can be disabled with the IO
manipulator std::noboolalpha.

#+BEGIN_SRC cpp 
  #include <iostream> 
  #include <iomanip> 

  >> std::cout << "flag1 = " << true << " flag2 = " << false << "\n";
  flag1 = 1 flag2 = 0
  >> 
  >> std::cout << "flag1 = " << true << " flag2 = " << false << "\n";
  flag1 = 1 flag2 = 0
  >> 

  // IO Manipulator that enables boolalpha flag which enables booleans
  // be print as strings instead of being print as numbers.
  >> std::cout << std::boolalpha;

  >> std::cout << "flag1 = " << true << " flag2 = " << false << "\n";
  flag1 = true flag2 = false

  // Output continues in this way until the flag boolalpha is disabled. 
  >> std::cout << "flag1 = " << true << " flag2 = " << false << "\n";
  flag1 = true flag2 = false
  >> 

  // Disable flag 
  >> std::cout << std::noboolalpha;
  >> 
  >> std::cout << "flag1 = " << true << " flag2 = " << false << "\n";
  flag1 = 1 flag2 = 0
#+END_SRC
** IO Manipulators 

 + All mapipulators: [[https://en.cppreference.com/w/cpp/io/manip][documentation]]

Switch numeric representation of booleans

 + std::boolapha
   + => Print booleans as 'true' or 'false' rather than 0 or 1. 
 + std::noboolalpha
   + => Print boolean as number true as 1 and false as 0.

Case manipulators:

 + std::uppercase => Print everything as uppercase.
 + std::nouppercase => Print without forcing uppercase.

Change numerical base used for printing integers

 + std::dec => Print integers as decimal 
 + std::hex => Print integers as heaxdecimal  
 + std::oct => Print integers as octal

Float point number formatting:

  + std::setprecision(int N)
  + std::defaultflot (C++11)
  + std::fixed
    + Print float with fixed precision (fixed numbers of decimal places)
  + std::scientific
    + Print float with scientific notation 
  + std::hexfloat (C++11)

Flushing manipulators:

 + std::flush
   + Flush output stream, in other words, it forces the stream
     buffer to be written to the IO, for instance, it can force the
     buffer of a file output stream to be written to a file. TL;DR
     synchronize stream buffer with output.

 + std::endl
   + Insert new line character in the output stream ~\n~ and flushes
     the stream (std::flush).

 + std::unitbuf
   + => Automatically flushes the output stream after each
     operation. Note: most output streams flushes by default.
   + Sets the flag: std::ios_base::unitbuf.

 + std::nounitbuf
   + => Disables automatic output stream flushing.
   + => Disables the flag: std::ios_base::unitbuf


 *Examples Float point IO manipulators*

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <iomanip> 
  #include <cmath>

  >> std::cout << "sqrt(pi) = " << std::sqrt(M_PI) << " x = " << 2.50 << "\n";
  sqrt(pi) = 1.77245 x = 2.5
  >> 

  // Precision 3 decimal places 
  >> std::cout << std::fixed << std::setprecision(3);
  >> std::cout << "sqrt(pi) = " << std::sqrt(M_PI) << " x = " << 2.50 << "\n";
  sqrt(pi) = 1.772 x = 2.500

  // Precision 6 decimal places 
  >> std::cout << std::fixed << std::setprecision(6);
  >> std::cout << "sqrt(pi) = " << std::sqrt(M_PI) << " x = " << 2.50 << "\n";
  sqrt(pi) = 1.772454 x = 2.500000

  // Reset float IO
  >> std::cout << std::defaultfloat;
  >> std::cout << "sqrt(pi) = " << std::sqrt(M_PI) << " x = " << 2.50 << "\n";
  sqrt(pi) = 1.77245 x = 2.5
  >> 
#+END_SRC
** Custom IO manipulator 

Example: custom IO manipulator to print integers in hexadecimal format
without affecting IO global state. 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <iomanip>

  template<typename Numeric> struct to_hex {
       Numeric m_value;
       to_hex(Numeric value): m_value(value){ }

       friend std::ostream& operator<<(std::ostream& os, to_hex const& rhs)
       {
           return os << "0x" << std::uppercase << std::hex
                     << rhs.m_value << std::nouppercase << std::dec ;
       }
  };
#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
  >> std::cout << "x = " << to_hex<int>(2561) << " y = " << 246 << "\n";
  x = 0xA01 y = 246

  >> std::cout << "x = " << to_hex<int>(255) << " y = " << 246 << "\n";
  x = 0xFF y = 246
#+END_SRC
** Redirect IO 

See: [[http://www.cplusplus.com/reference/ios/ios/rdbuf/][ios::rdbuf - C++ Reference]]

 + Overload 1: Return pointer to stream buffer attached to stream.
 + Overload 2: Set pointer to stream buffer attached to stream and
   clears the error state flags.

#+BEGIN_SRC cpp 
 /* Overload 1 [get] */ 
  streambuf* ios::rdbuf() const;

 /* Overload 2 [set] */ 
  streambuf* ios::rdbuf (streambuf* sb);
#+END_SRC

 Example: *Redirect std::cerr to std::stringstream string IO*

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string> 
  #include <sstream>

  std::stringstream ss;

  >> std::cerr << " Stderr output \n";
   Stderr output 
  >> 
  // Backup pointer to cout stream buffer 
  >> auto buf = std::cerr.rdbuf()
  (std::basic_streambuf<char, std::char_traits<char> > *) @0x7ffe4c3bc4d8
  >> 
  // Redirect stream 
  std::cerr.rdbuf(ss.rdbuf());
#+END_SRC

The global object std::cerr prints to stringstream instead of process'
stderr (standard error output):

#+BEGIN_SRC cpp 
  >> std::cerr << "hello world ";
  >> std::cerr << "pi = " << M_PI << " exp(3.5) " << std::exp(3.5) << "\n";
#+END_SRC

Get content of stream ss: 

#+BEGIN_SRC cpp 
  // Stream content 
  >> ss
  (std::stringstream &) @0x7fa0341bb018
  >> 
  >> ss.str()
  "hello world pi = 3.14159 exp(3.5) 33.1155"
  >>   
#+END_SRC

Restore buffer:  

#+BEGIN_SRC cpp 
  >> std::cerr.rdbuf(buf);

  >> std::cerr << "pi = " << M_PI << " exp(3.5) " << std::exp(3.5) << "\n";
  pi = 3.14159 exp(3.5) 33.1155  

#+END_SRC





** IO - Insertion << and extraction >> operators

This example shows how to overload the operators insertion (<<) and
extraction (>>) for an user defined type. Note: those operators are
not class methods, they are free functions.

 + File: [[file:src/insertionExtractionOverload.cpp][file:src/insertionExtractionOverload.cpp]]
 + Online Compile: https://wandbox.org/permlink/97fcclubA7KHWEry  (No console input support)


Compiling and running: 

#+BEGIN_SRC sh 
  $ clang++ inputOutput.cpp -o inputOutput.bin -std=c++1z -O0 -Wall && ./inputOutput.bin
#+END_SRC

Class Product (file: Product.hpp):

#+BEGIN_SRC cpp 
  class Product{
  private:
      int          m_id;
      std::string  m_name;
      double       m_price;
  public:
      Product();
      Product(int id, std::string const& name, double price);
      int         Id()    const;
      std::string Name()  const;
      double      Price() const;
      void showProduct()  const;

      friend
      auto operator<<(std::ostream& os, Product const& prod) -> std::ostream&;

      friend
      auto operator>>(std::istream& is, Product& prod) -> std::istream&;	
  };
#+END_SRC

 *Methods implementation* (file: Product.hpp)

Constructors: 

#+BEGIN_SRC cpp 
  Product::Product(int id, std::string const& name, double price):
     m_id(id), m_name(name), m_price(price)
  {
  }

  Product::Product(): Product(-1, "unnamed", 0.0)
  {   
  }
#+END_SRC

Operator insertion (<<) for printing a Product object to an output
stream, it means any derived class of [[http://www.cplusplus.com/reference/istream/iostream/][std::ostream]] or std::cout,
std::stringstream, std::fstream.

 + Note: This operator is not a method of the class Product, it is
   just a function of two arguments. 

#+BEGIN_SRC cpp
  auto operator<<(std::ostream& os, Product const& prod) -> std::ostream&
  {
       os << " " << prod.m_id
          << " " << std::quoted(prod.m_name)
          << " " << prod.m_price;	   
       return os;	
  }
#+END_SRC

Operator extraction (>>) for reading a product object from an input
stream, it means, any derived class of the class [[http://www.cplusplus.com/reference/istream/istream/][std::istream]] such as
std::cin, std::fstream, std::sstream and so on. 

#+BEGIN_SRC cpp
   auto operator>>(std::istream& is, Product& prod) -> std::istream&
   {
       return is >> prod.m_id >> std::quoted(prod.m_name) >> prod.m_price;	
   }
#+END_SRC

 *Main function:*

Create sample products:

#+BEGIN_SRC cpp 
   Product p1{200, "Arabica Coffee", 4.50};	
   Product p2{300, "Orange 1kg ", 10.0};
   Product p3{126, "XYWZ soft drink", 15.60};
#+END_SRC

Experiment 1: print products to stdout.

#+BEGIN_SRC cpp 
   std::puts(" >>> EXPERIMENT 1 == Print Products ===========");
   std::cout << "Product p1 = {" << p1 << " }" << std::endl;
   std::cout << "Product p2 = {" << p2 << " }" << std::endl;
   std::cout << "Product p3 = {" << p3 << " }" << std::endl;
#+END_SRC

Output: 

#+BEGIN_SRC sh 
   >>> EXPERIMENT 1 == Print Products ===========
  Product p1 = { 200 "Arabica Coffee" 4.5 }
  Product p2 = { 300 "Orange 1kg " 10 }
  Product p3 = { 126 "XYWZ soft drink" 15.6 
#+END_SRC

Experiment 2: Print Product to memory stream (memory file)

#+BEGIN_SRC cpp 
    std::puts(" >>> EXPERIMENT 2 == Print Products to memory stream (memory file) ====");
    std::stringstream ss;
    ss << p1 << "\n" << p2 << "\n" << p3;
    std::cout << "ss = \n" << ss.str() << std::endl;
#+END_SRC

Output: 

#+BEGIN_SRC text 
   >>> EXPERIMENT 2 == Print Products to memory stream (memory file) ====
  ss = 
   200 "Arabica Coffee" 4.5
   300 "Orange 1kg " 10
   126 "XYWZ soft drink" 15.6
#+END_SRC

Experiment 3: Read product from memory stream.

#+BEGIN_SRC cpp 
   std::puts(" >>> EXPERIMENT 3 == Read products from memory stream ====");
   Product pr;
   ss >> pr;
   std::cout << " pr1 = " << pr << std::endl;
   ss >> pr;
   std::cout << " pr2 = " << pr << std::endl;
   ss >> pr;
   std::cout << " pr3 = " << pr << std::endl;
#+END_SRC

Output: 

#+BEGIN_SRC sh 
   >>> EXPERIMENT 3 == Read products from memory stream ====
   pr1 =  200 "Arabica Coffee" 4.5
   pr2 =  300 "Orange 1kg " 10
   pr3 =  126 "XYWZ soft drink" 15.6
#+END_SRC 

Experiment 4: Read products from console (user types the products) and
types Ctrl + D sending EOF (End Of File) character when he is done.

#+BEGIN_SRC cpp 
    std::puts(" >>> EXPERIMENT 4 == Read products from console ====");
    Product prod;
    while(!std::cin.eof()){
        std::cout << "Enter product: ";
        std::cin >> prod;
        std::cout << " prod = " << prod << " ; "
                  << " price = " << prod.Price()
                  << std::endl;
    }		
#+END_SRC

Output: 

#+BEGIN_SRC sh 
   Enter product: 451 Lemon 6.7
    prod =  451 "Lemon" 6.7 ;  price = 6.7
   Enter product: 234 "Fresh atum 1kg" 25.90
    prod =  234 "Fresh atum 1kg" 25.9 ;  price = 25.9
   Enter product: 461 "Cappucino coffee" 25.60        
    prod =  461 "Cappucino coffee" 25.6 ;  price = 25.6
#+END_SRC

