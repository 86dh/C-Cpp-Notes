#+INCLUDE: theme/style.org 
#+TITLE: CPP/C++ STL Input and Output 
#+DESCRIPTION: cpp/c++ stl standard template library algorithms and iterators
#+STARTUP: content 

 - [[wiki:index][Index]]

* C++ IO  Input and Output System 
** IO Class Hierarchy

 *C++ IO Features:*

 + Object oriented and polymorphic
 + Stateful
   + The IO classes have internal states such as precision that float
     point will be printed; base which numbers will be print such as
     octal (base 8), hexadecimal (base 16) and decimal (default).
 + Without exceptions
   + The C++ IO does not have exceptions, it indicates error through
     error flags that must be checked by the calling code.

 *IO Classes:*

 * ios - base class for streams
 * istream - input stream base class
   + ifstream => Input file stream 
   + istringstream => Input string stream
 * ostream - output stream base class
   + ofstream => Output file stream 
   + ostringstream => Output string stream
 * iostream - input/output stream base class
   + fstream => Input/Output file stream.
   + sstringstream => String stream that can be used for reading and writing.

 *IO Global Objects*

Output stream global objects (instances of std::ostream): 
 + std::cout - Standard output stream (stdout)
 + std::cerr - Standard output error stream (stderr)
 + std::clog
 + std::wcout - Standard output stream (stdout) - wide character version. 
 + std::wcerr
 + std::wclog 

Input stream global objects (instances of std::istream): 
 + std::cin  - Standard input stream (stdin)
 + std::wcin - Standard input stream (stdin), wide character version.

 *Header Files* 

 * [[https://en.cppreference.com/w/cpp/header/iostream][<iostream>]] => Basic IO 
   + _std::ostream_, _std::istream_, std::cout, std::cerr, std::clog, std::wcerr 

 * [[https://en.cppreference.com/w/cpp/header/fstream][<fstream>]] => File IO 
   + std::ifstream, std::ofstream, std::fstream

 * [[https://en.cppreference.com/w/cpp/header/sstream][<sstream>]] => String / Memory IO
   + std::stringstream, std::istringstream, std::ostringstream

 * [[https://en.cppreference.com/w/cpp/header/iomanip][<iomanip>]] => IO manipulation functions
   * std::setfill, std::setprecision, std::setw, std::right,
     std::left, std::dec, std::hex, std::quoted (C++14)

Full references at: 
 + http://www.cplusplus.com/reference/iolibrary/


#+CAPTION: C++ IO Class hierarchy
#+BEGIN_SRC text 
                                  ios
                                   +
                  +----------------+--------------+
                  |                               |
                 \|/                             \|/
              +-------+                      +--------+
              |istream|                      |ostream |
              +--+----+                      +---+----+
                 |                               |
                \|/       +-----------+         \|/
      +------------------>+  iostream +<------+--v--------+-----------+
      |          |        +-----+-----+       |           |           |
      v          v              |             v           v           v
  ,*std::cin  ifstream           |         *std::cerr   ofstream   ostringstream
             istringstream      |          *std::cout
                                |          *std::clog
                          ------v------
                          |           |
                          v           v
                       fstream stringstream
#+END_SRC


 *Statefullness* 

The C++ IO streams are stateful, they have internal states for IO
configuration such as [[https://en.cppreference.com/w/cpp/io/ios_base/fmtflags][IO flags]] and numerical precision. In the
following code, the IO manipulator std::boolalpha enables the IO flag
std::ios_base::boolalpha that makes the IO stream print booleans as
string instead of '0' or '1'. The flag can be disabled with the IO
manipulator std::noboolalpha.

#+BEGIN_SRC cpp 
  #include <iostream> 
  #include <iomanip> 

  >> std::cout << "flag1 = " << true << " flag2 = " << false << "\n";
  flag1 = 1 flag2 = 0
  >> 
  >> std::cout << "flag1 = " << true << " flag2 = " << false << "\n";
  flag1 = 1 flag2 = 0
  >> 

  // IO Manipulator that enables boolalpha flag which enables booleans
  // be print as strings instead of being print as numbers.
  >> std::cout << std::boolalpha;

  >> std::cout << "flag1 = " << true << " flag2 = " << false << "\n";
  flag1 = true flag2 = false

  // Output continues in this way until the flag boolalpha is disabled. 
  >> std::cout << "flag1 = " << true << " flag2 = " << false << "\n";
  flag1 = true flag2 = false
  >> 

  // Disable flag 
  >> std::cout << std::noboolalpha;
  >> 
  >> std::cout << "flag1 = " << true << " flag2 = " << false << "\n";
  flag1 = 1 flag2 = 0
#+END_SRC
** IO Manipulators 

 + All mapipulators: [[https://en.cppreference.com/w/cpp/io/manip][documentation]]

Switch numeric representation of booleans

 + std::boolapha
   + => Print booleans as 'true' or 'false' rather than 0 or 1. 
 + std::noboolalpha
   + => Print boolean as number true as 1 and false as 0.

Case manipulators:

 + std::uppercase => Print everything as uppercase.
 + std::nouppercase => Print without forcing uppercase.

Change numerical base used for printing integers (flag std::ios::basefield)

 + std::dec => Print integers as decimal 
 + std::hex => Print integers as heaxdecimal  
 + std::oct => Print integers as octal

Float point number formatting: (flag: std::ios::floatfield)

  + std::defaultflot (C++11)
  + std::fixed
    + Print float with fixed precision (fixed numbers of decimal places)
  + std::scientific
    + Print float with scientific notation 
  + std::hexfloat (C++11)

Float point precision: 

  + std::setprecision(int N)

Field adjusting (flag: std::ios::adjustfield)
 
 + std::ios::left 
 + std::ios::right
 + std::ios::internal 

Flushing manipulators:

 + std::flush
   + Flush output stream, in other words, it forces the stream
     buffer to be written to the IO, for instance, it can force the
     buffer of a file output stream to be written to a file. TL;DR
     synchronize stream buffer with output.

 + std::endl
   + Insert new line character in the output stream ~\n~ and flushes
     the stream (std::flush).

 + std::unitbuf
   + => Automatically flushes the output stream after each
     operation. Note: most output streams flushes by default.
   + Sets the flag: std::ios_base::unitbuf.

 + std::nounitbuf
   + => Disables automatic output stream flushing.
   + => Disables the flag: std::ios_base::unitbuf


 *Examples Float point IO manipulators*

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <iomanip> 
  #include <cmath>

  >> std::cout << "sqrt(pi) = " << std::sqrt(M_PI) << " x = " << 2.50 << "\n";
  sqrt(pi) = 1.77245 x = 2.5
  >> 

  // Precision 3 decimal places 
  >> std::cout << std::fixed << std::setprecision(3);
  >> std::cout << "sqrt(pi) = " << std::sqrt(M_PI) << " x = " << 2.50 << "\n";
  sqrt(pi) = 1.772 x = 2.500

  // Precision 6 decimal places 
  >> std::cout << std::fixed << std::setprecision(6);
  >> std::cout << "sqrt(pi) = " << std::sqrt(M_PI) << " x = " << 2.50 << "\n";
  sqrt(pi) = 1.772454 x = 2.500000

  // Reset float IO
  >> std::cout << std::defaultfloat;
  >> std::cout << "sqrt(pi) = " << std::sqrt(M_PI) << " x = " << 2.50 << "\n";
  sqrt(pi) = 1.77245 x = 2.5
  >> 
#+END_SRC
** IO stream redirection  
*** Stdout (cout) and Stderr (cerr) stream redirection

Every process, has the following standard streams: 

 + *stdin* - Standard input (file descriptor 0) => encapsulated by
   global object *std::cin* (derived class of std::istream)

 + *stdout* - Standard output (file descriptor 1) => encapsulated by
   global object *std::cout* (derived class of std::ostream)
   + Normal program console output should use std::cout. 

 + *stderr* - Standard error output (file descriptor 2) => encapsulated
   by global object *std::cerr* (derived class of std::ostream)
   + Diagnostics, error and logging should use std::cerr as this
     approach allows separating logging and diagnostics from program
     output and redirecting or discarding them.
   + Note: Stream redirection is also possible on Windows. Althoug, it
     is not so usual as in Unix-like operating system due to low usage
     of terminal application in Windows.
   + Note: A Windows application compiled for GUI subsystem will not
     display any output stream even if it is run from the terminal. 

 *Example:*

 + File: stream-redirect.cpp
   + Sample program that solves the equation f(x) = x^3 - a = 0 using
     newton raphson method.

#+BEGIN_SRC cpp 
  #include <iostream> // std::cout, std::cerr ...
  #include <string>   // std::stod 
  #include <cmath>    // std::sin, std::fabs, std::abs, ... 
  #include <iomanip>  // std::seprecision, std::fixed 

  int main(int argc, char** argv)
  {
       // 1e-6 or 6 digits tolerance 
       double tolerance = 0.000001;
       // Maximum number of iterationrs 
       size_t itermax   = 200;

       if(argc < 2)
       {
            std::cout << "Solves equation x^3 - a = 0 using Newton Raphson Method" << std::endl;
            std::cout << " Error: input parameter not provided" << std::endl;
            return EXIT_FAILURE;
       }

       //------- Parse Input Argument --------------
       double a;
       try {
               a = std::stod(argv[1]);
       } catch (std::exception const& ex) {
               std::cerr << " [ERROR] " << ex.what() << std::endl;
               return EXIT_FAILURE;
       }

       double dx, x = a;
       std::cerr << std::fixed << std::setprecision(4);
       int w = 10;

       std::cerr << " [INFO] Solving equation f(x) = x^3 - a ; for a = " << a << "\n\n";

       std::cerr << std::setw(w) << "Iter"
                         << std::setw(w) << "x"
                         << std::setw(w) << "AbsErr"
                         << std::setw(w) << "RelErr%"
                         << std::endl;	

       // Find the cubic root by solving the following equation with
       // Newton Raphson method: 
       // =>> F(x) = x^3 - a = 0
       for(auto iter = 0; iter < itermax; iter++)
       {
           dx  = (x * x * x - a ) / ( 2.0 * x * x);
           x   = x - dx;

           std::cerr << std::setw(w) << iter
                     << std::setw(w) << x
                     << std::setw(w) << std::fabs(dx)
                     << std::setw(w) << 100.0 * std::fabs(dx / x)
                     << std::endl;

          if(std::fabs(dx) < tolerance * std::fabs(x))
          {
              std::cout << " Cubic root of a = " << a
                        << " ; is approximately " << x
                        << " number of iteratios is " << iter + 1
                        << std::endl;
              return EXIT_SUCCESS;
          }
       }
       std::cerr << " [FAILURE] Root does not converge" << std::endl;
       return EXIT_FAILURE;
  }
#+END_SRC  

Compiling: 

#+BEGIN_SRC sh 
 # GCC
 $ g++     stream-redirect.cpp -o stream-redirect.bin -std=c++1z -g -O0 -Wall
 # Clang / LLVM 
 $ clang++ stream-redirect.cpp -o stream-redirect.bin -std=c++1z -g -O0 -Wall
#+END_SRC

Running: 

 + Print all results - the standard streams stdcout (std::cout) and
   stderr are redirected to console by default.
 + Note: Stream redirectiion peformed on Bash shell on Linux.


#+BEGIN_SRC text 
  $ ./stream-redirection.bin 125.0
   [INFO] Solving equation f(x) = x^3 - a ; for a = 125.0000

        Iter         x    AbsErr   RelErr%
           0   62.5040   62.4960   99.9872
           1   31.2680   31.2360   99.8977
           2   15.6979   15.5701   99.1855
           3    8.1026    7.5953   93.7396
           4    5.0033    3.0993   61.9454
           5    4.9984    0.0049    0.0985
           6    5.0008    0.0025    0.0492
           7    4.9996    0.0012    0.0246
           8    5.0002    0.0006    0.0123
           9    4.9999    0.0003    0.0062
          10    5.0001    0.0002    0.0031
          11    5.0000    0.0001    0.0015
          12    5.0000    0.0000    0.0008
          13    5.0000    0.0000    0.0004
          14    5.0000    0.0000    0.0002
          15    5.0000    0.0000    0.0001
   Cubic root of a = 125 ; is approximately 5 number of iteratios is 16
#+END_SRC


 + Discard stderr standard error stream by redirecting it to
   /dev/null. Note: valid for Unix-like OSes (Linux, BSD, OSX, QNX ...): 
   * $ ./program 2> /dev/null 

#+BEGIN_SRC text 
  $ ./stream-redirect.bin 125.0 2> /dev/null
   Cubic root of a = 125 ; is approximately 5 number of iteratios is 16
#+END_SRC

 + Discard stdout - standard output by redirecting it to /dev/null
   (Unix-like OSes)
   * $ ./program > /dev/null 

#+BEGIN_SRC text 
  $ ./stream-redirect.bin 125.0 > /dev/null
   [INFO] Solving equation f(x) = x^3 - a ; for a = 125.0000

        Iter         x    AbsErr   RelErr%
           0   62.5040   62.4960   99.9872
           1   31.2680   31.2360   99.8977
           2   15.6979   15.5701   99.1855
           3    8.1026    7.5953   93.7396
           4    5.0033    3.0993   61.9454
           5    4.9984    0.0049    0.0985
           6    5.0008    0.0025    0.0492
           7    4.9996    0.0012    0.0246
           8    5.0002    0.0006    0.0123
           9    4.9999    0.0003    0.0062
          10    5.0001    0.0002    0.0031
          11    5.0000    0.0001    0.0015
          12    5.0000    0.0000    0.0008
          13    5.0000    0.0000    0.0004
          14    5.0000    0.0000    0.0002
          15    5.0000    0.0000    0.0001
#+END_SRC

 + Discard both stdout and stderr by redirecting them to /dev/null
   + ./prorgram > /dev/null 2>&1 

#+BEGIN_SRC sh 
   $ ./stream-redirect.bin 125.0 > /dev/null 2>&1
#+END_SRC

 + Redirect stdout - standard output stream to a file.
   + ./program > stdout.log
   + Only the stderr is printed, the stdout is redirected to the text
     file stdout.log 

#+BEGIN_SRC sh 
  $ ./stream-redirect.bin 125.0 > stdout.log
   [INFO] Solving equation f(x) = x^3 - a ; for a = 125.0000

        Iter         x    AbsErr   RelErr%
           0   62.5040   62.4960   99.9872
           1   31.2680   31.2360   99.8977
           2   15.6979   15.5701   99.1855
           3    8.1026    7.5953   93.7396
           4    5.0033    3.0993   61.9454
           5    4.9984    0.0049    0.0985
           6    5.0008    0.0025    0.0492
           7    4.9996    0.0012    0.0246
           8    5.0002    0.0006    0.0123
           9    4.9999    0.0003    0.0062
          10    5.0001    0.0002    0.0031
          11    5.0000    0.0001    0.0015
          12    5.0000    0.0000    0.0008
          13    5.0000    0.0000    0.0004
          14    5.0000    0.0000    0.0002
          15    5.0000    0.0000    0.0001

  # Check file 
  $ cat stdout.log 
   Cubic root of a = 125 ; is approximately 5 number of iteratios is 16
#+END_SRC

 + Redirect stderr (std::cerr) - standard error stream to file.
   * ./program 2> stderr.log
   * Only the stdout is printed and the stderr is redirect to the text
     file stderr.log

#+BEGIN_SRC sh 
   $ ./stream-redirect.bin 125.0 2> stderr.log
    Cubic root of a = 125 ; is approximately 5 number of iteratios is 16

   # Show first 5 lines of log file 
   $ head -n 5 stderr.log 
    [INFO] Solving equation f(x) = x^3 - a ; for a = 125.0000

         Iter         x    AbsErr   RelErr%
            0   62.5040   62.4960   99.9872
            1   31.2680   31.2360   99.8977

   # Show last 5 lines of log file 
   $ tail -n 5 stderr.log 
           11    5.0000    0.0001    0.0015
           12    5.0000    0.0000    0.0008
           13    5.0000    0.0000    0.0004
           14    5.0000    0.0000    0.0002
           15    5.0000    0.0000    0.0001
#+END_SRC

 + Redirect both streams to different files: stdcout (std::cout) and
   stderr (std:cerr)
   * $ ./program > stdout.txt 2> stderr.txt
   * The stdout (std::cout) is redirected to the file stdout.txt and
     the stderr (std::cerr) is redirected to the file stderr.txt 

#+BEGIN_SRC sh 
  $ ./stream-redirect.bin 125.0 > stdout.txt 2> stderr.txt

  # Check stdout (std::cout) log file 
  $ cat stdout.txt 
   Cubic root of a = 125 ; is approximately 5 number of iteratios is 16

  # Check stderr (std::cerr) log file 
  $ tail -n 5 stderr.txt 
          11    5.0000    0.0001    0.0015
          12    5.0000    0.0000    0.0008
          13    5.0000    0.0000    0.0004
          14    5.0000    0.0000    0.0002
          15    5.0000    0.0000    0.0001
#+END_SRC

 + Redirect both streams to the same log file.
   + ./program > log.txt 2>&1

#+BEGIN_SRC text 
  $ ./stream-redirect.bin 125.0 > log.txt 2>&1 

  $ cat log.txt 
   [INFO] Solving equation f(x) = x^3 - a ; for a = 125.0000

        Iter         x    AbsErr   RelErr%
           0   62.5040   62.4960   99.9872
           1   31.2680   31.2360   99.8977
           2   15.6979   15.5701   99.1855
           3    8.1026    7.5953   93.7396
           4    5.0033    3.0993   61.9454
           5    4.9984    0.0049    0.0985
           6    5.0008    0.0025    0.0492
           7    4.9996    0.0012    0.0246
           8    5.0002    0.0006    0.0123
           9    4.9999    0.0003    0.0062
          10    5.0001    0.0002    0.0031
          11    5.0000    0.0001    0.0015
          12    5.0000    0.0000    0.0008
          13    5.0000    0.0000    0.0004
          14    5.0000    0.0000    0.0002
          15    5.0000    0.0000    0.0001
   Cubic root of a = 125 ; is approximately 5 number of iteratios is 16
#+END_SRC

 *Capturing process stdout and stderr with Python subprocess module* 

Run C++ program _stream-redirect.bin_ as subprocess: 
 + [[https://docs.python.org/3.6/library/subprocess.html][Subprocess documentation]]

#+BEGIN_SRC python 
  $ python3
  Python 3.6.8 (default, Mar 21 2019, 10:08:12) 
  [GCC 8.3.1 20190223 (Red Hat 8.3.1-2)] on linux
  Type "help", "copyright", "credits" or "license" for more information.
  >>> 

  #  Process result 
  >>> r = sp.run(["./stream-redirection.bin", "125"], stdout = sp.PIPE, stderr = sp.PIPE)
  >>> 
#+END_SRC

Check status code: 
 + Process status code => Numeric value returned by int main(....){ ... }
 + 0 => Status code means successful return 

#+BEGIN_SRC python 
  >>> r.returncode
  0
#+END_SRC

Check captured stdout: 

#+BEGIN_SRC python 
  # =============== Stdout => Standarde Output Stream =====================#

  >>> type(r.stdout)
  <class 'bytes'>

  >>> r.stdout
  b' Cubic root of a = 125 ; is approximately 5 number of iteratios is 16\n'
  >>> 

  >>> print(r.stdout.decode('utf-8'))
   Cubic root of a = 125 ; is approximately 5 number of iteratios is 16
#+END_SRC

Check captured stderr: 

#+BEGIN_SRC python 
  # => Type is a byte array 
  >>> type(r.stderr)
  <class 'bytes'>

  # => Type is a python string 
  >>> type(r.stderr.decode('utf-8'))
  <class 'str'>
  >>> 

  >>> print(r.stderr.decode('utf-8'))
   [INFO] Solving equation f(x) = x^3 - a ; for a = 125.0000

        Iter         x    AbsErr   RelErr%
           0   62.5040   62.4960   99.9872
           1   31.2680   31.2360   99.8977
           2   15.6979   15.5701   99.1855

         ... ... .... .... ... ... ... .... .... 

          15    5.0000    0.0000    0.0001
#+END_SRC

*** Stdin (cin) stream redirection 

 *File:* input-redirection.cpp 

#+BEGIN_SRC cpp 
  #include <iostream> // Import: std::cout, std::cin, std::cerr 
  #include <iomanip>  // Import: std::setw 
  #include <string>   // Import: std::string
  #include <functional> // Import: std::function 

  int main(int argc, char** argv)
  {
       if(argc > 1 && std::string(argv[1]) == "--help")
       {
           std::cout << "Count line numbers of some file." << std::endl;
           std::cout << " Usage: \n"
                     << "  $  " << argv[0] << " < file.txt \n"
                     << "  $  cat file.txt | " << argv[0] << "\n\n";
           // Early return 
           return 0;
       }	

       std::string line;
       long counter  = -1;

       // Self-executable lambda used for returning a value from the if-else 
       bool showLine = [&]{
                             if(argc > 1 && std::string(argv[1]) == "--show-line")
                                     return true;
                             return false;
                     }();

       std::cerr << std::boolalpha << " [INFO] showLine = " << showLine << std::endl;

       /* Note: The comma opeator evaluates first (counter++) and then 
        ,* evaluates std::getline(std::cin, line) returning its value. 
        ,*/
       while(counter++, std::getline(std::cin, line)){
            if(showLine)
            {
                    std::cout << "\n" << std::right << std::setw(4) << counter
                                      << " "  << std::left  << std::setw(8) <<  line;
            }
       }

       std::cout << "\n\n File has " << counter << " lines " << std::endl;	
       return 0; 
  }

#+END_SRC

 *Compiling:* 

#+BEGIN_SRC sh 
 # Clang 
 $ clang++ input-redirection.cpp -o input-redirection.bin -std=c++1z -g -O0 -Wall
 
 # GCC 
 $ gcc++ input-redirection.cpp -o input-redirection.bin -std=c++1z -g -O0 -Wall
#+END_SRC

  *Usage*: 

Display help: 

#+BEGIN_SRC sh 
  $ ./input-redirection.bin --help
  Count line numbers of some file.
   Usage: 
    $  ./input-redirection.bin < file.txt 
    $  cat file.txt | ./input-redirection.bin
#+END_SRC

Count number of line in input stream stdin (std::cin) typed by user: 
 + Note: When the user is done, he types CTRL + D to send EOF (End Of
   File) character to process. 

#+BEGIN_SRC sh 
  $ ./input-redirection.bin
   [INFO] showLine = false
  DXY index 
    VIX implied volatility 
       VAR VALUE AT RISK 
       standard deviation commodity prices 
           monte carlo simulations stochastic volatility

    Finaly user types CTRL + D when he is done to send EOF signal character to process.

   File has 7 lines 
#+END_SRC

Redirect output stream (stdout) of *echo* program to input stream
(stdin) of input-redirection.bin: 

#+BEGIN_SRC sh 
  $ echo -e " line0\n line1\n line2" 
   line0
   line1
   line2

  $ echo -e " line0\n line1\n line2" | ./input-redirection.bin 
   [INFO] showLine = false


   File has 3 lines 


  $ echo -e " line0\n line1\n line2" | ./input-redirection.bin --show-line
   [INFO] showLine = true

     0    line0
     1    line1
     2    line2

   File has 3 lines 
#+END_SRC

Redirect file to input stream (stdin) of process
input-redirection.bin: 

#+BEGIN_SRC sh 
   # Show test file 
   #-------------------------------------------------
   $ cat /etc/filesystems 
   ext4
   ext3
   ext2
   nodev proc
   nodev devpts
   iso9660
   vfat
   hfs
   hfsplus
   *

   # Redirect test file to process' input stream without displaying lines 
   #-------------------------------------------------
   $ ./input-redirection.bin < /etc/filesystems 
    [INFO] showLine = false


    File has 10 lines 

   # Redirect test file to process' input stream displaying its lines 
   #-------------------------------------------------
   $ ./input-redirection.bin --show-line < /etc/filesystems 
    [INFO] showLine = true

      0 ext4    
      1 ext3    
      2 ext2    
      3 nodev proc
      4 nodev devpts
      5 iso9660 
      6 vfat    
      7 hfs     
      8 hfsplus 
      9 *       

    File has 10 lines 
#+END_SRC



** Custom IO manipulators 

 *Example: 1* 

Custom IO manipulator to print integers in hexadecimal format without
affecting IO global state.

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <iomanip>

  template<typename Numeric> struct to_hex {
       Numeric m_value;
       to_hex(Numeric value): m_value(value){ }

       friend std::ostream& operator<<(std::ostream& os, to_hex const& rhs)
       {
           return os << "0x" << std::uppercase << std::hex
                     << rhs.m_value << std::nouppercase << std::dec ;
       }
  };
#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
  >> std::cout << "x = " << to_hex<int>(2561) << " y = " << 246 << "\n";
  x = 0xA01 y = 246

  >> std::cout << "x = " << to_hex<int>(255) << " y = " << 246 << "\n";
  x = 0xFF y = 246
#+END_SRC

 *Example 2* Custom IO manipulators for numerical tables. 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <iomanip>
  #include <type_traits>

  // Requires headers:  <iostream>, <iomanip>, <type_traits>
  template< 
     typename Numeric,
     // Used for restricting the types of arguments that can be used. 
     // It will generate a compiler error for non-float arguments. 
     typename std::enable_if<std::is_floating_point<Numeric>::value, void>::type* = nullptr
     >
  struct to_fix {
      Numeric m_value;
      size_t  m_precision;
      size_t  m_field_size;

      to_fix(Numeric value, size_t fieldSize = 8, size_t precision = 4)
      {
          m_value       = value;
          m_field_size  = fieldSize;
          m_precision	  = precision;
      }

      friend std::ostream& operator<<(std::ostream& os, to_fix const& rhs)
      {
          size_t prec = os.precision();
          std::ios config{nullptr};
          config.copyfmt(std::cout);	
          os << std::fixed << std::setprecision(rhs.m_precision)
             << std::setw(rhs.m_field_size) << rhs.m_value;
          std::cout.copyfmt(config);
          return os;
   }

  };
#+END_SRC

Experiment 1: 

#+BEGIN_SRC cpp 
  for(double x = 0.0; x < 4.0; x += 0.5) {
       using T = double;
       double y = std::sqrt(x);
       std::cout << to_fix<T>(x) << to_fix<T>(y) << "\n";
  }
#+END_SRC

Experiment 1 Output: 

#+BEGIN_SRC text 
  0.0000  0.0000
  0.5000  0.7071
  1.0000  1.0000
  1.5000  1.2247
  2.0000  1.4142
  2.5000  1.5811
  3.0000  1.7321
  3.5000  1.8708
#+END_SRC

Experiment 2: 

#+BEGIN_SRC cpp 
  for(double x = 0.0; x < 100.0; x += 10.0) {
       using T = double;
       double y = std::sqrt(x);
       std::cout << to_fix<T>(x, 8, 2) << to_fix<T>(y, 9, 5) << "\n";
  }
#+END_SRC

Experiment 2 output: 

#+BEGIN_SRC text 
    0.00  0.00000
   10.00  3.16228
   20.00  4.47214
   30.00  5.47723
   40.00  6.32456
   50.00  7.07107
   60.00  7.74597
   70.00  8.36660
   80.00  8.94427
   90.00  9.48683
#+END_SRC

Experiment 3: Print table to file.

#+BEGIN_SRC cpp 
  std::ofstream report("/tmp/report.txt");

  for(double x = 0.0; x < 100.0; x += 10.0) {
       using T = double;
       double y = std::sqrt(x);
       report << to_fix<T>(x, 8, 2) << to_fix<T>(y, 9, 5) << "\n";
  }

  // Sync buffer with IO 
  // force buffer to be written to IO 
  report.flush();

  // Force close
  report.close();

  // Run shell command to check file 
  >> .! head -n 3 /tmp/report.txt
      0.00  0.00000
     10.00  3.16228
     20.00  4.47214
  >> 

  >> .! tail -n 3 /tmp/report.txt
     70.00  8.36660
     80.00  8.94427
     90.00  9.48683
  >> 
#+END_SRC

** IO - Insertion << and extraction >> operators
*** Operators insertion insertion for STL std::vector<double> 

Operator insertion (<<) for type std::vector<double>: 

 + Code: [[https://wandbox.org/permlink/UX67EPtHSKpmXCR7][Wandbox Online Compiler]]

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <vector> 

  std::ostream& 
  operator<<(std::ostream& os, std::vector<double> const& xs )
  {
      os << "[" << xs.size() << "]( ";
      for(const auto&  x: xs)
              os << x << ", ";
      return os << " )";
  }
#+END_SRC

Function main: 

#+BEGIN_SRC cpp 
    std::vector<double> xs;
    xs = {};
    std::cout << "xs = " << xs << std::endl;
    xs = {1.0, 5.0, 4.6, 1e4, 9.8};    
    std::cout << "xs = " << xs << std::endl;
    return 0;
#+END_SRC

Output: 

#+BEGIN_SRC text 
  xs = [0](  )
  xs = [5]( 1, 5, 4.6, 10000, 9.8,  )
#+END_SRC

*** Operators insertion insertion for STL std::vector<T> 

 + Code: [[https://wandbox.org/permlink/NQN0loqv21td60P3][Wandbox Online Compiler]]

Operator: (<<)

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <vector>
  #include <string>

  template<typename Element> 
  std::ostream& 
  operator<<(std::ostream& os, std::vector<Element> const& xs )
  {
      os << "[" << xs.size() << "]( ";
      for(const auto&  x: xs)
         os << x << " ";
      return os << " )";
  }
#+END_SRC

Main function: 

#+BEGIN_SRC cpp 
    std::vector<double> xs;
    xs = {};
    std::cout << "xs = " << xs << std::endl;
    xs = {1.0, 5.0, 4.6, 1e4, 9.8};    
    std::cout << "xs = " << xs << std::endl;
    
    std::vector<int> xa = {1, 3, 4, 5, 6};
    std::cout << "xa = " << xa << "\n";
    
    auto words = std::vector<std::string>{"hello", "world", "C++", "new", "machine"};
    std::cout << "words = " << words << "\n";
    
    return 0;
#+END_SRC

Output: 

#+BEGIN_SRC text 
  xs = [0](  )
  xs = [5]( 1 5 4.6 10000 9.8  )
  xa = [5]( 1 3 4 5 6  )
  words = [5]( hello world C++ new machine  )
#+END_SRC

*** Operators insertion and extraction for used defined-type  


This example shows how to overload the operators insertion (<<) and
extraction (>>) for an user defined type. Note: those operators are
not class methods, they are free functions.

 + File: [[file:src/insertionExtractionOverload.cpp][file:src/insertionExtractionOverload.cpp]]
 + Online Compile: https://wandbox.org/permlink/97fcclubA7KHWEry  (No console input support)


Compiling and running: 

#+BEGIN_SRC sh 
  $ clang++ inputOutput.cpp -o inputOutput.bin -std=c++1z -O0 -Wall && ./inputOutput.bin
#+END_SRC

Class Product (file: Product.hpp):

#+BEGIN_SRC cpp 
  class Product{
  private:
      int          m_id;
      std::string  m_name;
      double       m_price;
  public:
      Product();
      Product(int id, std::string const& name, double price);
      int         Id()    const;
      std::string Name()  const;
      double      Price() const;
      void showProduct()  const;

      friend
      auto operator<<(std::ostream& os, Product const& prod) -> std::ostream&;

      friend
      auto operator>>(std::istream& is, Product& prod) -> std::istream&;	
  };
#+END_SRC

 *Methods implementation* (file: Product.hpp)

Constructors: 

#+BEGIN_SRC cpp 
  Product::Product(int id, std::string const& name, double price):
     m_id(id), m_name(name), m_price(price)
  {
  }

  Product::Product(): Product(-1, "unnamed", 0.0)
  {   
  }
#+END_SRC

Operator insertion (<<) for printing a Product object to an output
stream, it means any derived class of [[http://www.cplusplus.com/reference/istream/iostream/][std::ostream]] or std::cout,
std::stringstream, std::fstream.

 + Note: This operator is not a method of the class Product, it is
   just a function of two arguments. 

#+BEGIN_SRC cpp
  auto operator<<(std::ostream& os, Product const& prod) -> std::ostream&
  {
       os << " " << prod.m_id
          << " " << std::quoted(prod.m_name)
          << " " << prod.m_price;	   
       return os;	
  }
#+END_SRC

Operator extraction (>>) for reading a product object from an input
stream, it means, any derived class of the class [[http://www.cplusplus.com/reference/istream/istream/][std::istream]] such as
std::cin, std::fstream, std::sstream and so on. 

#+BEGIN_SRC cpp
   auto operator>>(std::istream& is, Product& prod) -> std::istream&
   {
       return is >> prod.m_id >> std::quoted(prod.m_name) >> prod.m_price;	
   }
#+END_SRC

 *Main function:*

Create sample products:

#+BEGIN_SRC cpp 
   Product p1{200, "Arabica Coffee", 4.50};	
   Product p2{300, "Orange 1kg ", 10.0};
   Product p3{126, "XYWZ soft drink", 15.60};
#+END_SRC

Experiment 1: print products to stdout.

#+BEGIN_SRC cpp 
   std::puts(" >>> EXPERIMENT 1 == Print Products ===========");
   std::cout << "Product p1 = {" << p1 << " }" << std::endl;
   std::cout << "Product p2 = {" << p2 << " }" << std::endl;
   std::cout << "Product p3 = {" << p3 << " }" << std::endl;
#+END_SRC

Output: 

#+BEGIN_SRC sh 
   >>> EXPERIMENT 1 == Print Products ===========
  Product p1 = { 200 "Arabica Coffee" 4.5 }
  Product p2 = { 300 "Orange 1kg " 10 }
  Product p3 = { 126 "XYWZ soft drink" 15.6 
#+END_SRC

Experiment 2: Print Product to memory stream (memory file)

#+BEGIN_SRC cpp 
    std::puts(" >>> EXPERIMENT 2 == Print Products to memory stream (memory file) ====");
    std::stringstream ss;
    ss << p1 << "\n" << p2 << "\n" << p3;
    std::cout << "ss = \n" << ss.str() << std::endl;
#+END_SRC

Output: 

#+BEGIN_SRC text 
   >>> EXPERIMENT 2 == Print Products to memory stream (memory file) ====
  ss = 
   200 "Arabica Coffee" 4.5
   300 "Orange 1kg " 10
   126 "XYWZ soft drink" 15.6
#+END_SRC

Experiment 3: Read product from memory stream.

#+BEGIN_SRC cpp 
   std::puts(" >>> EXPERIMENT 3 == Read products from memory stream ====");
   Product pr;
   ss >> pr;
   std::cout << " pr1 = " << pr << std::endl;
   ss >> pr;
   std::cout << " pr2 = " << pr << std::endl;
   ss >> pr;
   std::cout << " pr3 = " << pr << std::endl;
#+END_SRC

Output: 

#+BEGIN_SRC sh 
   >>> EXPERIMENT 3 == Read products from memory stream ====
   pr1 =  200 "Arabica Coffee" 4.5
   pr2 =  300 "Orange 1kg " 10
   pr3 =  126 "XYWZ soft drink" 15.6
#+END_SRC 

Experiment 4: Read products from console (user types the products) and
types Ctrl + D sending EOF (End Of File) character when he is done.

#+BEGIN_SRC cpp 
    std::puts(" >>> EXPERIMENT 4 == Read products from console ====");
    Product prod;
    while(!std::cin.eof()){
        std::cout << "Enter product: ";
        std::cin >> prod;
        std::cout << " prod = " << prod << " ; "
                  << " price = " << prod.Price()
                  << std::endl;
    }		
#+END_SRC

Output: 

#+BEGIN_SRC sh 
   Enter product: 451 Lemon 6.7
    prod =  451 "Lemon" 6.7 ;  price = 6.7
   Enter product: 234 "Fresh atum 1kg" 25.90
    prod =  234 "Fresh atum 1kg" 25.9 ;  price = 25.9
   Enter product: 461 "Cappucino coffee" 25.60        
    prod =  461 "Cappucino coffee" 25.6 ;  price = 25.6
#+END_SRC
** Redirect IO .rdbuf()

See: [[http://www.cplusplus.com/reference/ios/ios/rdbuf/][ios::rdbuf - C++ Reference]]

 + Overload 1: Return pointer to stream buffer attached to stream.
 + Overload 2: Set pointer to stream buffer attached to stream and
   clears the error state flags.

#+BEGIN_SRC cpp 
 /* Overload 1 [get] */ 
  streambuf* ios::rdbuf() const;

 /* Overload 2 [set] */ 
  streambuf* ios::rdbuf (streambuf* sb);
#+END_SRC

 Example: *Redirect std::cerr to std::stringstream string IO*

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string> 
  #include <sstream>

  std::stringstream ss;

  >> std::cerr << " Stderr output \n";
   Stderr output 
  >> 
  // Backup pointer to cout stream buffer 
  >> auto buf = std::cerr.rdbuf()
  (std::basic_streambuf<char, std::char_traits<char> > *) @0x7ffe4c3bc4d8
  >> 
  // Redirect stream 
  std::cerr.rdbuf(ss.rdbuf());
#+END_SRC

The global object std::cerr prints to stringstream instead of process'
stderr (standard error output):

#+BEGIN_SRC cpp 
  >> std::cerr << "hello world ";
  >> std::cerr << "pi = " << M_PI << " exp(3.5) " << std::exp(3.5) << "\n";
#+END_SRC

Get content of stream ss: 

#+BEGIN_SRC cpp 
  // Stream content 
  >> ss
  (std::stringstream &) @0x7fa0341bb018
  >> 
  >> ss.str()
  "hello world pi = 3.14159 exp(3.5) 33.1155"
  >>   
#+END_SRC

Restore buffer:  

#+BEGIN_SRC cpp 
  >> std::cerr.rdbuf(buf);

  >> std::cerr << "pi = " << M_PI << " exp(3.5) " << std::exp(3.5) << "\n";
  pi = 3.14159 exp(3.5) 33.1155  

#+END_SRC
** Read whole input stream to string 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <sstream> 
  #include <fstream> 

  /** @brief Read whole input stream to a string and returns it 
    ,* Requires headers: <iostream> and <sstream>
    ,*/
  std::string istreamToString(std::istream& is){
      if(is.bad())
          throw std::runtime_error("Error: stream has errors.");
      std::stringstream ss;
      ss << is.rdbuf();
      return ss.str();
  }
#+END_SRC

Read std::cin stream - console (stdin) 

#+BEGIN_SRC cpp 
  // Use types a text and types CTRL + D when he is done sending EOF character 
  >> auto text = istreamToString(std::cin); 
   A stdin input stream works like a "console file".      
   In UNIX everything has a file interface, works with a file API, everything is a file.
   Type CTRL + D to send EOF and close this stream.

  >> std::cout << "text = " << text2 << std::endl;
  text =  A stdin input stream works like a "console file".
   In UNIX everything has a file interface, works with a file API, everything is a file.
   Type CTRL + D to send EOF and close this stream.
#+END_SRC

Read file input stream: 

#+BEGIN_SRC cpp 
  >> auto ifs = std::ifstream("/proc/sys/kernel/osrelease")
  (std::basic_ifstream<char, std::char_traits<char> > &) @0x7f3edbc0a688

  >> auto os_release = istreamToString(ifs)
  (std::basic_string<char, std::char_traits<char>, std::allocator<char> > &) "4.20.16-100.fc28.x86_64
  "

  >> std::cout << " =>> Linux-OS Release = " << os_release << std::endl;
   =>> Linux-OS Release = 4.20.16-100.fc28.x86_64
#+END_SRC

Read stringstream - memory stream. 

#+BEGIN_SRC cpp 
  >> std::stringstream ms;
  >> ms << " UNIX - Linux OS2 Mainframes AIX VxWorks QNX ";
  >> ms << "\n network TCP IP UDP SOCKET packets";
  >> ms << " \n binary bits octets speed 3G 4G 5G business flow currency";
  >> ms << " \n technology price technology technology technology";
  >> ms << std::flush;

  // Type of txt => std::string 
  >> auto txt = istreamToString(ms);

  >> std::cout << "text = \n" << txt ;
  text = 
   UNIX - Linux OS2 Mainframes AIX VxWorks QNX 
   network TCP IP UDP SOCKET packets 
   binary bits octets speed 3G 4G 5G business flow currency 
#+END_SRC

** Saving and restoring IO flags 
*** Manual saving restoring  

IO manipulators such as std::scientific, std::fixed, std::setprecision
or std::uppercase are stateful and permanently affects the IO flags
what can make the code hard to understand and cause unintended IO
changes. This issue can be solved by saving and restoring the IO
flags. 

Save IO state: 
 
#+BEGIN_SRC cpp 
  #include <iostream>
  #include <iomanip>

  // ========= Save IO flags =========
  std::ios config{nullptr};
  config.copyfmt(std::cout);
#+END_SRC

Before changing IO flags: 

#+BEGIN_SRC cpp 
  >> std::cout << "pi = " << M_PI << " gravity = " << 9.8145723e3 << " E = " << 956e6 << "\n";
  pi = 3.14159 gravity = 9814.57 E = 9.56e+08
  >> 

  >> std::cout << " true = " << true << " false = " << false << "\n";
   true = 1 false = 0
  >> 
#+END_SRC

Change IO flags: 

#+BEGIN_SRC cpp 
   std::cout << std::boolalpha;
   std::cout << std::setprecision(3) << std::fixed;
#+END_SRC

After changing IO flags: 

#+BEGIN_SRC cpp 
   >> std::cout << "pi = " << M_PI << " gravity = " << 9.8145723e3 << " E = " << 956e6 << "\n";
   pi = 3.142 gravity = 9814.572 E = 956000000.000

   >> std::cout << "sqrt(2) = " << std::sqrt(2.0) << "\n" ;
   sqrt(2) = 1.414
   >> 

   >> std::cout << " true = " << true << " false = " << false << "\n";
    true = true false = false
   >> 
#+END_SRC

Restore IO flags: 

#+BEGIN_SRC cpp 
  std::cout.copyfmt(config);
#+END_SRC

After restoring IO flags: 

#+BEGIN_SRC cpp 
  >> std::cout << "pi = " << M_PI << " gravity = " << 9.8145723e3 << " E = " << 956e6 << "\n";
  pi = 3.14159 gravity = 9814.57 E = 9.56e+08

  >> std::cout << "sqrt(2) = " << std::sqrt(2.0) << "\n" ;
  sqrt(2) = 1.41421

  >> std::cout << " true = " << true << " false = " << false << "\n";
   true = 1 false = 0 
#+END_SRC
*** Automatic saving and restoring IO flags with RAAI

Class for saving IO flags using RAAI.

#+CAPTION: Class for saving and restoring IO context. 
#+BEGIN_SRC cpp 
  struct IOContext {
      std::ios      m_config{nullptr};
      std::ostream* m_pos;

      // Save context 
      IOContext(std::ostream& os = std::cout): m_pos(&os)
      {
          std::cerr << " [INFO] saved IO flags" << std::endl;
          m_config.copyfmt(os);
      }
      // Restore context 
      ~IOContext()
      {
          std::cerr << " [INFO] restored IO flags" << std::endl;
          m_pos->copyfmt(m_config);
      }

  };
#+END_SRC

Test function: 

#+CAPTION: Function testIOFlags for testing and demonstrating class IOContext.
#+BEGIN_SRC cpp 
  void testIOFlags() {
       std::cout << "===== Before =======" << "\n";
       std::cout << "pi = " << M_PI
                 << " gravity = " << 9.8145723e3
                 << " E = " << 956e6 << "\n";

       std::cout << " true = " << true << " false = " << false << "\n";

       std::cout << "===== Context - IO flags changed =======" << "\n";
       {  /* Sub-scope start */
           IOContext ctx{std::cout}; /* Save IO Flags */

           std::cout << std::boolalpha;
           std::cout << std::setprecision(3) << std::fixed;

           std::cout << "pi = " << M_PI
                     << " gravity = " << 9.8145723e3
                     << " E = " << 956e6 << "\n";

           std::cout << " true = " << true << " false = " << false << "\n";

          /* End of sub-scope */
       } // Object ctx destroyed here => IO flags restored 

       std::cout << "===== After => IO flags restored =======" << "\n";

       std::cout << "pi = " << M_PI
                 << " gravity = " << 9.8145723e3
                 << " E = " << 956e6 << "\n";

       std::cout << " true = " << true << " false = " << false << "\n";
  } /** --- End of function testIOFlags --- */
#+END_SRC

Test in REPL: 

#+CAPTION: CERN's ROOT repl session. 
#+BEGIN_SRC cpp 
  >> testIOFlags()

  ===== Before =======
  pi = 3.14159 gravity = 9814.57 E = 9.56e+08
   true = 1 false = 0
  ===== Context - IO flags changed =======
   [INFO] saved IO flags
  pi = 3.142 gravity = 9814.572 E = 956000000.000
   true = true false = false
   [INFO] restored IO flags
  ===== After => IO flags restored =======
  pi = 3.14159 gravity = 9814.57 E = 9.56e+08
   true = 1 false = 0
  >> 
  >> 
#+END_SRC
