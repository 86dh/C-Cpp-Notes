#+INCLUDE: theme/style.org
#+TITLE: CPP / C++ Review
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

- [[wiki:index][Index]]

* Template Metaprogramming or Generic Programming 
** Overview 

*C++ Metaprogramming Features:*

+ _Templates_
  + Use case:
    + Template metaprogramming or generic programming
    + Generic classes and containers
    + Generic algorithms
    + Compile-time optmization
    + Write high performance code by eliminating virtual member
      function calls.
  + Limitation: Unfortunately, the C++ templates cannot manipulate
    the AST and generate code in the way that LISP-like languages
    do. 

+ C++11 _Constexpr_
  + Use cases:
    + Compile-time computations such as look up tables, math
      constants, CRC32, hash, string encryption and obfuscation at
      compile-time and so on.

+ _Inline functions_
  + Use cases:
    + Removing function-calls. The function code is inserted at the
      call-site by the compiler allowing a more efficient and
      perfomant code.

+ _Pre-processor macros_
  + Use-cases:
    + Debugging, print line number, file, current function, function
      signature and so on. 
    + Conditional compilation
    + Conditional compilation for cross platform compatibility
    + Boilerplate code generation which cannot be done with templates
      or anything else.
    + Generation of reflection data. 

*Generic Programming / Template Metaprogramming Design Patterns:*

+ _Generic Functions, algorithms and containers_
  + Some known use cases:
    + C++ STL introduced by Alexander Stepanov.
    + Boost Libraries
+ _CRTP => Curious Recurring Template Pattern_
  + Eliminates virtual function-calls overhead by emulating
    inheritance or dynamic polymorphism with static polymorphism or
    template metaprogramming.
+ _Type Erasure_ 
  + Despite the high performance and the ability to operate ony type
    regardless of the class hierarchy, the main shortcoming of
    generic programming is that, it is not possible to store
    unrelated types in the same containers or access them by the same
    pointer. The type erasure technique address those downsides by
    combining generic programmign and generic programming.
  + Known uses:
    + std::function (C++11)
    + std::any (C++17), Boost.any, std::variant (C++17) and Boost.variant
+ _EP => Expression Template_ => Technique used by many scientific
  library for encoding DSL - Domain Specific Languages with
  templates.
  + Some known uses of this design pattern are:
    + Linear Algebra: librareis Blitz++, Eigen and Armadillo
    + Automatic Differentiation.
+ _Meta Functions_ => "Functions" emualted with structs and static
  methods or members that can manipulate types or query information
  about types using template specialisation.
+ _Policy Based Design_
+ _SFINAE_

*Libraries and Frameworks for metaprogramming:*

+ [[https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html][Boost.Hana]]  
+ [[https://www.boost.org/doc/libs/1_68_0/libs/fusion/doc/html/fusion/preface.html][Boost.Fusion]] 
+ [[https://www.boost.org/doc/libs/1_68_0/libs/mpl/doc/index.html][Boost.MPL]] 

*Tool for testing templates online* 

+ [[http://metashell.org/index.html][Home - Metashell]] - "The goal of this project is to provide an
  interactive template metaprogramming shell." 


*Template Metaprogramming Reference* 

- Andrei Alexandrescu's *Loki Library* (http://loki-lib.sourceforge.net/)
  + type list
  + functor
  + singleton
  + object factory
  + visitor
  + multi methods
  + pimpl - pointer to implementation.

** Template type-safe duck-typing or structural typing 

In dynamically programming languages like Python, Ruby and etc, a
function or method can accept any object implementing the methods
referred in the function body regardless of the object base or
interface. For instance, in the code below the function describeArea
will work with any class implementing the methods .area() and .name()
not matter the object's base class. 

This ability to work with any object which has that requested types,
in this case .area() and .name() is called _duck-typying_. Other
languages with duck-typing ability are Smalltalk, Groovy, C#, Scala
and Objective-C. The advantage of duck-typing is that function or
methods can work with classes without an inheritance hierarchy or a
common base class.

#+BEGIN_SRC python 
  def describeArea(shape):
      print("Shape is      = " + shape.name())
      print("Shape area is = " + str(shape.area()))

  class Square:
      def __init__(self, side):
          self.side = side 
      def area(self):
          return self.side * self.side
      def name(self):
          return "square"

  class Circle:
      def __init__(self, radius):
          self.radius = radius
      def area(self):
          return self.radius * self.radius  * 3.1415
      def name(self):
          return "circle"    
#+END_SRC

Running: 

#+BEGIN_SRC python 
  >>> s = Square(10)
  >>> c = Circle(3)
  >>>

  >>> describeArea(s)
  Shape is      = square
  Shape area is = 100
  >>> 
  >>> describeArea(c)
  Shape is      = circle
  Shape area is = 28.273500000000002
  >>> 
  >>> 
#+END_SRC


 *C++ "Duck-typing" or type-safe structural typing*

C++ templates feature supports a more type-safe duck-typing as the
feature allows to write functions or methods which works with any
object implementing the methods requested in the template code
regardless of passed types have a common class hierarchy or a base
class. However, unlike Python or Scala's duck typing, C++'s template
doesn't have performance penalty due to dynamic polymorphism or
reflection as it generates code at compile-time for each parameter
type. 

The C++'s template duck-typing is also called static polymorphism as a
contrast to dynamic polymorphism which requires that all objects
passed to a function or method implement the same base class.

Example: The function describeArea works with any object implementing
the methods area() and name(), however unlike Python and other
dynamically typed languages, if an object that doesn't implement none
of those mentioned methods is passed as argument, a compile error will
be generated rather than a runtime error. 

The advantage of C++ template is that it eliminates the runtime
overhead of dynamic polymorphism or virtual function calls, therefore
makes the code more performant and loosely coupled as it can work with
any class without any inheritance hierarchy.  

#+BEGIN_SRC cpp 
  #include <iostream>

  // Works with any type T which implements .name() or .area()
  template <class T>
  void describeArea(const T& obj){
          std::cout << "Shape is = " << obj.name() << std::endl;
          std::cout << "Area is  = " << obj.area() << std::endl;
          std::cout << "---------" << std::endl;
  }

  class Circle{
  private:
          double m_radius;
  public:
          Circle(double radius): m_radius(radius) {};
          double area() const {
                  return 3.1415 * m_radius * m_radius;
          }
          const char* name() const {
                  return "circle";
          }	
  };

  class Square{
  private:
          double m_side;
  public:
          Square(double side): m_side(side) {};
          double area() const {
                  return m_side * m_side;
          }
          const char* name() const {
                  return "square";
          }
  };

  int main(){
          Square s(4.0);
          Circle c(3.0);
          describeArea(s);
          describeArea(c);
          return 0;
  }

#+END_SRC

Running: 

 - The template generates multiple versions of the function
   describeArea specific for each type, for instance, it generates,
   describeArea(const Circle&) and describeArea(const Square&). The
   static polymorphism is a high performance alternative to the use of
   dynamic polymorphism, inheritance, and virtual methods since the
   methods that will be called are resolved at compile-time.

#+BEGIN_SRC sh 
  $ clang++ -std=c++11 templateDuckTyping.cpp -o out.bin && ./out.bin
  Shape is = square
  Area is  = 16
  ---------
  Shape is = circle
  Area is  = 28.2735
  ---------
#+END_SRC

Summary: 

 + C++ Templates works in similar fashion to dynamically typed
   languages' duck typing.

 + Templates can make the code more loosely coupled as they works with
   any class or type implementing the requested methods.

 + Templates have zero cost and follows the C++ motto, "don't pay for
   what you don't use" they only generate code when requested or
   instantiated.

 + Templates are widely used in the STL (Standard Template Library)
   and the Boost Library.
** Class Templates 
*** Example: Generic stack class 

Note: 

  + A class template is not a class, it is factory of classes and has
    zero cost until it is used or instantiated. For instance,
    Stack<int> and Stack<std::string> are different classes and cannot
    be stored in containers or accessed with the same pointer.

  + When Stack<int> or Stack<double> appears in the code, the compiler
    generates an unique object code for each of those template
    instantiation. The C++ generics doesn't have type erasure like
    java where all objects can be casted to an instance of Object.

  + All the template code must be always in the header files. 

Class Template Example: 

#+BEGIN_SRC cpp 
  #include <iostream> 
  #include <deque> 
  #include <string>

  template<class T>
  class Stack{
  private:
          std::deque<T> _stack;
  public:
          struct stack_empty_error: public std::exception{
                  const char* what() const throw(){
                          return " ==> Error: stack empty." ;
                  }
          };
          void push(const T& t){
                  _stack.push_back(t);
          }
          T pop(){
                  if(_stack.empty())
                          throw stack_empty_error();
                  auto x = _stack.back();
                  _stack.pop_back();
                  return x;
          }
          T peek(){
                  if(_stack.empty())
                          throw stack_empty_error();
                  return _stack.back();
          }
          size_t size(){  return _stack.size(); }
          bool   empty(){ return _stack.empty(); }
          void   clear(){ _stack.clear(); }
          void print(){
                  std::cout << " stack: ";
                  for(const auto& x: _stack)
                          std::cout << " " << x ;
                  std::cout << "\n";
          }
  };

#+END_SRC

Usage example: 
 
 - Instantiate class template with int parameter.

#+BEGIN_SRC cpp 
  >> Stack<int> s1;
  >> s1.push(10)
  >> s1.push(20)
  >> s1.push(-30)
  >> s1.push(15)
  >> 
  >> s1.size()
  (unsigned long) 4
  >> 
  >> s1.empty()
  (bool) false

  >> s1.print()
   stack:  10 20 -30 15

  >> s1.peek()
  (int) 15

  >> s1.pop()
  (int) 15
  >> s1.pop()
  (int) -30
  >> s1.pop()
  (int) 20
  >> s1.pop()
  (int) 10
  >> s1.pop()
  Error in <TRint::HandleTermInput()>: Stack<int>::stack_empty_error caught:  ==> Error: stack empty.
  >> 

  >> s1.size()
  (unsigned long) 0
  >> s1.empty()
  (bool) true
  >> 
  >>
#+END_SRC

 - Instantiate class template with std::string parameter.

#+BEGIN_SRC cpp 
  > Stack<std::string> sd;
  >> sd.push("hello")
  >> sd.push("c++")
  >> sd.push("templates")
  >> sd.push("test")
  >> 
  >> sd.size()
  (unsigned long) 4
  >> sd.empty()
  (bool) false
  >> sd.peek()
  (std::basic_string<char, std::char_traits<char>, std::allocator<char> >) "test"
  >> 
  >> sd.print()
   stack:  hello c++ templates test
  >> 
  >> sd.pop()
  (std::basic_string<char, std::char_traits<char>, std::allocator<char> >) "test"
  >> sd.pop()
  (std::basic_string<char, std::char_traits<char>, std::allocator<char> >) "templates"
  >> sd.pop()
  (std::basic_string<char, std::char_traits<char>, std::allocator<char> >) "c++"
  >> sd.pop()
  (std::basic_string<char, std::char_traits<char>, std::allocator<char> >) "hello"
  >> 
#+END_SRC

 - Generic client code for the class stack: 

#+BEGIN_SRC cpp 
  // Non-destructive print -> Creates a copy invoking copy constructor 
  template<typename T>
  void printStack(Stack<T> t){
          while(!t.empty())
                  std::cout << t.pop() << " ";
          std::cout << "\n";
          std::cout.flush();
  }

  template<class T>
  void fillStack(Stack<T> &t, const std::deque<T>& data){
          for(const auto& d: data)
                  t.push(d);
  }
#+END_SRC

 - Running client code.

#+BEGIN_SRC cpp 
  >> Stack<double> stack_double1;
  >> fillStack(stack_double1, {2.0, 5.0, 6.0, 9.0})
  >> 
  >> stack_double1.size()
  (unsigned long) 4
  >> stack_double1.peek()
  (double) 9.0000000
  >> 

  >> printStack(stack_double1)
  9 6 5 2 
  >> 
  >> printStack(stack_double1)
  9 6 5 2 

  >> Stack<std::string> stack_string;
  >> fillStack(stack_string, {"hello", "hpc", "C++", "RULEZ", "peformance", "matters"})

  >> printStack(stack_string)
  matters peformance RULEZ C++ hpc hello

  >> printStack<std::string>(stack_string)
  matters peformance RULEZ C++ hpc hello 
  >> 

  >> stack_string.clear()
  >> printStack3<std::string>(stack_string)

  >> 
#+END_SRC
*** Example: Tuple of three elements 

Code: 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>

  template <class A, class B, class C>
  struct tuple3{
          // Empty constructor - necessary to store by value the tuple
          // in STL containers.
          tuple3(){}
          tuple3(const A& a, const B& b, const C& c)
                  : a(a), b(b), c(c){		
          }
          A a;
          B b;
          C c;	
  };

  template <class A, class B, class C>
  auto getA(const tuple3<A, B, C>&  t) -> A{
          return t.a; 	
  }

  template <class A, class B, class C>
  auto getB(const tuple3<A, B, C>&  t) -> B{
          return t.b; 	
  }

  template <class A, class B, class C>
  auto getC(const tuple3<A, B, C>&  t) -> C{
          return t.c; 	
  }

  template <class A, class B, class C>
  void printTuple1(const tuple3<A, B, C>& t){
          std::cout << "tuple3{"
                            << " a = " << t.a
                            << " b = " << t.b
                            << " c = " << t.c
                            << " } "
                            << "\n";
  }

  template <class A, class B, class C>
  auto printTuple2(const tuple3<A, B, C>& t) -> void {
          std::cout << "tuple3{"
                            << " a = " << t.a
                            << " b = " << t.b
                            << " c = " << t.c
                            << " } "
                            << "\n";
  }
#+END_SRC


Running: 

#+BEGIN_SRC cpp 
  >> tuple3<double, char, std::string> h(100.23, 'x', "world")
  (tuple3<double, char, std::string> &) @0x7f3ea8607010
  >> 
  >> h.a
  (double) 100.23000
  >> h.b
  (char) 'x'
  >> h.c
  (std::basic_string<char, std::char_traits<char>, std::allocator<char> > &) "world"
  >> 

  >> getA(h)
  (double) 100.23000
  >> getB(h)
  (char) 'x'
  >> getC(h)
  (std::basic_string<char, std::char_traits<char>, std::allocator<char> >) "world"

  // Types parameter are deduced by the compiler.
  >> printTuple1(h)
  tuple3{ a = 100.23 b = x c = world } 

  >> printTuple2(h)
  tuple3{ a = 100.23 b = x c = world } 
  >> 

  >> printTuple1<double, char, std::string>(h)
  tuple3{ a = -100 b = x c = world } 
  >>

  auto tdata = std::deque<tuple3<int, char, std::string>>{
          {100, 'x', "C++"},
          {200, 'z', "Forth"},
          {-900, 'k', "Lisp"},
          {66, 'p', "route"}};

  for(const auto& t: tlist) printTuple1(t);

  >> for(const auto& t: tdata) printTuple1(t);
  tuple3{ a = 100 b = x c = C++ } 
  tuple3{ a = 200 b = z c = Forth } 
  tuple3{ a = -900 b = k c = Lisp } 
  tuple3{ a = 66 b = p c = route } 
  >> 

  // Compiler fails to deduce arguments 
  >> std::for_each(tdata.begin(), tdata.end(), printTuple1)
  ROOT_prompt_32:1:1: error: no matching function for call to 'for_each'
  std::for_each(tdata.begin(), tdata.end(), printTuple1)
  ^~~~~~~~~

  >> std::for_each(tdata.begin(), tdata.end(), printTuple1<int, char, std::string>);
  tuple3{ a = 100 b = x c = C++ } 
  tuple3{ a = 200 b = z c = Forth } 
  tuple3{ a = -900 b = k c = Lisp } 
  tuple3{ a = 66 b = p c = route } 
  >>

  >> std::for_each(tdata.begin(), tdata.end(), &printTuple1<int, char, std::string>);
  tuple3{ a = 100 b = x c = C++ } 
  tuple3{ a = 200 b = z c = Forth } 
  tuple3{ a = -900 b = k c = Lisp } 
  tuple3{ a = 66 b = p c = route } 
  >> 

#+END_SRC

** Templates and STL Containers 
*** Overview  

Templates can be used for writing more generic and resuable code which
operates like functions or STL algorithms on  any type of iterator or
container. 
*** Example 1 - iterating over containers 

This example shows how to implement generic code which operates on any
type of container or iterator in modern C++.

 + File: [[file:src/template-iterator-container.cpp][file:src/template-iterator-container.cpp]]

Code highlights:

#+BEGIN_SRC cpp 
  namespace IterUtils{
          template<class Iterator>
          double sumContainer(const Iterator& begin, const Iterator& end){
                  double sum = 0.0;
                  for(Iterator it = begin; it != end; ++it)
                          sum += *it;
                  return sum;
          }

          // Sum elements of any type <Container> with methods .begin() and .end()
          // returnign iterators.
          template<class U, class Container>
          auto sumContainer2(const Container& container) -> U{
                  U sum{}; // Uniform initialization
                  for(auto it = container.begin(); it != container.end(); ++it)
                          sum += *it;
                  return sum;
          }

          template<class Iterator>
          auto printContainer(
                  const Iterator& begin,
                  const Iterator& end,
                  const std::string& sep = ", " ) -> void
          {
                  for(Iterator it = begin; it != end; ++it)
                          std::cout <<  *it << sep;
          }

          template<class Container>
          auto printContainer2(
                    const Container& cont
                   ,const std::string& sep = ", "
                  ) -> void
          {
                  // C++11 For-range based loop
                  for(const auto& x: cont)
                          std::cout <<  x << sep;
          }

          // Higher order function
          // The parameter actions accepts any type which can be called like
          // a function returning void.
          //
          // Note: It doesn't matter as it is possible to use both class T or typename T.
          template<typename Container, typename Function>
          auto for_each (const Container cont, Function action) -> void
          {
                  for(const auto& x: cont) action(x);
          }

  }; // ----- End of namespace IterUtils ----- //
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
  $ clang++ template-iterator-container.cpp -o template-iterator-container.bin -g -std=c++11 -Wall -Wextra 
  $ ./template-iterator-container.bin

  =========== Experiment 1 - sumContainer
  template-iterator-container.cpp:95: ; iu::sumContainer(&carray[0], &carray[0] + arrsize) = 16
  template-iterator-container.cpp:96: ; iu::sumContainer(vec1.begin(), vec1.end()) = 16
  template-iterator-container.cpp:97: ; iu::sumContainer(list1.begin(), list1.end()) = 16
  template-iterator-container.cpp:98: ; iu::sumContainer(deque1.begin(), deque1.end()) = 16

  =========== Experiment 2 - sumContainer2 
  template-iterator-container.cpp:101: ; iu::sumContainer2<double>(vec1) = 16
  template-iterator-container.cpp:102: ; iu::sumContainer2<int>(vec1) = 15
  template-iterator-container.cpp:103: ; iu::sumContainer2<double>(list1) = 16
  template-iterator-container.cpp:104: ; iu::sumContainer2<int>(list2) = 114

  =========== Experiment 3 - printContainer 

  Contents of carray  = 1, 2, 4.5, 2.5, 6, 
  Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
  Contents of vec2  = c++, templates, awesome, binary, 
  Contents of list1 = 1, 2, 4.5, 2.5, 6, 

  =========== Experiment 4 - printContainer2 

  Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
  Contents of vec2  = c++, templates, awesome, binary, 
  Contents of list1 = 1, 2, 4.5, 2.5, 6, 

  =========== Experiment 5 - for_each higher order function 

  Contents of vec1  = 1, 2, 4.5, 2.5, 6, 
  Contents of vec2  = c++, templates, awesome, binary, c++, templates, awesome, binary, 
  Contents of m1  = 
    earth-gravity     9.810
            euler     2.718
               pi     3.142
                x     2.345

#+END_SRC
*** Example 2 - print any container element (typename)

#+BEGIN_SRC cpp
  template<class Container>
  void printContents(Container& c){
       // Dependent type declaration 
       typename Container::iterator i;
       for(i = c.begin(); i != c.end(); i++)
               std::cout << " " << *i << "\n";
       std::cout << "\n";
  }
#+END_SRC

Running: 

#+BEGIN_SRC cpp 
  >> std::vector<double> xs{10.23, -24.23, 25.2, 100.34};
  >> std::list<std::string> ds{"hello world", "C++", "HPC", "processor"};
  >> 
  >> printContents(xs)
   10.23
   -24.23
   25.2
   100.34

  >> printContents(ds)
   hello world
   C++
   HPC
   processor
#+END_SRC
** Basic Template Specialization 
   :PROPERTIES:
   :ID:       80f3766a-39eb-47ef-a3f5-5a49ef183db0
   :END:

Code example showing template specialization. As the code shows, the
template specilization can be used for type introspection, type
identification and implement reflection.

 + File: [[file:src/template-specialization1.cpp][file:src/template-specialization1.cpp]]
 + Online compiler: http://rextester.com/BKG53705

#+BEGIN_SRC cpp :tangle src/template-specialization1.cpp
  #include <iostream>
  #include <iomanip>    // Stream manipulator std::fixed, std::setw ... 
  #include <vector>
  #include <cmath>      // sin, cos, tan, exp ... M_PI, M_E ...
  #include <functional> // std::function 

  // ============= Example 1 ===============================//

  // Check whether type is float point 
  template<class T>
  auto isFPNumber() -> bool {
          return false;
  }
  // Template specialization of isFPNumber for type float
  template<> auto isFPNumber<float>() -> bool {
          return true;
  }
  // Template specialization of isFPNumber for type double 
  template<> auto isFPNumber<double>() -> bool {
          return true;
  }

  // ============= Example 2 - Template specialization for runtime type identification ====//
  // Note: this technique can be used for implemeting custom C++ reflection 

  // Return name of a given type 
  template<class Type>
  auto TypeName() -> const char* { return "unknown"; }

  #define REGISTER_TYPE(type)  template<> \
          auto TypeName<type>() -> const char* { return #type; } 

  // Specialization for int type 
  template<>
  auto TypeName<int>() -> const char* { return "int"; }

  // Automate boilerplate code using macros.
  REGISTER_TYPE(bool);
  REGISTER_TYPE(std::string);
  REGISTER_TYPE(const char*);
  REGISTER_TYPE(float);
  REGISTER_TYPE(double);
  REGISTER_TYPE(long);
  REGISTER_TYPE(unsigned);
  REGISTER_TYPE(char);
  REGISTER_TYPE(long long);

  // ============= Example 3 - Template with int argument specialization ===//
  template<int>
  const char* getNumberName(){
          return "I down't known";
  }
  template<> const char* getNumberName<0>(){ return "zero"; }
  template<> const char* getNumberName<1>(){ return "one"; }
  template<> const char* getNumberName<2>(){ return "two"; }
  template<> const char* getNumberName<3>(){ return "three"; }

  // ============= Example 4 - Template with bool argument specialization ====//
  template<bool>
  struct boolTemplate;

  template<> struct boolTemplate<false>{
          static auto getName() -> const char* { return "false"; }
  };
  template<> struct boolTemplate<true>{
          static auto getName() -> const char* { return "true"; }
  };

  // ============= Example 5 - Check whether types are equal ====//
  // Partial template specialization 

  template<class A, class B>
  struct type_equal{
          static bool get(){ return false; }
          enum { value = 0 };
  };

  // Partial specialisation
  template<class A>
  struct type_equal<A, A>{
          static bool get(){ return true; }
          enum { value = 1};
  };

  int main(){
          const char nl = '\n';
          std::cout << std::boolalpha;

          std::cout << nl << "EXPERIMENT 1 - Check whether type is float pointer" << nl;
          std::cout << "--------------------------------------------" << nl;	
          std::cout << "is float point type<int>    ? = " << isFPNumber<int>() << nl;
          std::cout << "is float point type<char>   ? = " << isFPNumber<char>() << nl;
          std::cout << "is float point type<float>  ? = " << isFPNumber<float>() << nl;
          std::cout << "is float point type<double> ? = " << isFPNumber<float>() << nl;

          std::cout << nl << "EXPERIMENT 2 - Type introspection" << nl;
          std::cout << "--------------------------------------------" << nl;	
          std::cout << "type = " << TypeName<int>() << nl;
          std::cout << "type = " << TypeName<char>() << nl;
          std::cout << "type = " << TypeName<float>() << nl;
          std::cout << "type = " << TypeName<const char*>() << nl;
          std::cout << "type = " << TypeName<std::string>() << nl;	
	
          std::cout << nl << "EXPERIMENT 3 - Templates with integers as arguments" << nl;
          std::cout << "--------------------------------------------" << nl;
          std::cout << "getNumberName<0>() = " << getNumberName<0>() << nl;
          std::cout << "getNumberName<1>() = " << getNumberName<1>() << nl;
          std::cout << "getNumberName<2>() = " << getNumberName<2>() << nl;
          std::cout << "getNumberName<10>() = " << getNumberName<10>() << nl;
          std::cout << "getNumberName<14>() = " << getNumberName<14>() << nl;

          std::cout << nl << "EXPERIMENT 4 - Templates with bool as arguments" << nl;
          std::cout << "--------------------------------------------" << nl;	
          std::cout << "boolTemplate<false>::getName>()  = " << boolTemplate<false>::getName() << nl;
          std::cout << "boolTemplate<true>::getName>()   = " << boolTemplate<true>::getName() << nl;

          std::cout << nl << "Check whether types are equal" << nl;
          std::cout << "type_equal<int, char>::get()       = "  << type_equal<int, char>::get() << nl;	
          std::cout << "type_equal<char, double>::get()    = "  << type_equal<char, double>::get() << nl;
          std::cout << "type_equal<double, double>::get()  = "  << type_equal<double, double>::get() << nl;
          std::cout << "type_equal<int, int>::get()        = "  << type_equal<int, int>::get() << nl;

          if(type_equal<int, double>::value)
                  std::cout << "[1] Types are equal\n";
          else
                  std::cout << "[1] Types are not equal\n";

          if(type_equal<double, double>::value)
                  std::cout << "[2] Types are equal\n";
          else
                  std::cout << "[2] Types are not equal\n";
	
	
          return 0;
  }

#+END_SRC

Program output: 

#+BEGIN_SRC sh 
  $ clang++ template-specialization1.cpp -o template-specialization1.bin -g -std=c++11 -Wall -Wextra 
  $ ./template-specialization1.bin

  EXPERIMENT 1 - Check whether type is float pointer
  --------------------------------------------
  is float point type<int>    ? = false
  is float point type<char>   ? = false
  is float point type<float>  ? = true
  is float point type<double> ? = true

  EXPERIMENT 2 - Type introspection
  --------------------------------------------
  type = int
  type = char
  type = float
  type = const char*
  type = std::string

  EXPERIMENT 3 - Templates with integers as arguments
  --------------------------------------------
  getNumberName<0>() = zero
  getNumberName<1>() = one
  getNumberName<2>() = two
  getNumberName<10>() = I down't known
  getNumberName<14>() = I down't known

  EXPERIMENT 4 - Templates with bool as arguments
  --------------------------------------------
  boolTemplate<false>::getName>()  = false
  boolTemplate<true>::getName>()   = true

  Check whether types are equal
  type_equal<int, char>::get()       = false
  type_equal<char, double>::get()    = false
  type_equal<double, double>::get()  = true
  type_equal<int, int>::get()        = true
  [1] Types are not equal
  [2] Types are equal
#+END_SRC
** Templates with default arguments 

Example: Array allocated on the stack memory.

 + File: default-template-args.C

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <ostream> 

  // Array allocated on stack with size 10.
  template <typename Element, size_t Size = 10>
  class Array{
  private:
          Element m_data [Size];
  public:
          auto size() -> size_t {
                  return Size;
          }
          auto fill(const Element& t) -> void{
                  for(size_t i = 0; i < Size; i++)
                          m_data[i] = t;
          }
          auto operator [] (size_t index) -> Element& {
                  return m_data[index];
          }
          auto begin() const -> decltype(std::begin(m_data)) {
                  return std::begin(m_data);
          }
          auto end() const -> decltype(std::end(m_data)) {
                  return std::end(m_data);
          }
          auto print(const std::string& name, std::ostream& os = std::cout) const -> void{
                  os << name << " = ";
                  for(auto& x: *this)
                          os << x << " " << std::flush;
                  os << "\n";
          }
  };

  void default_template_args(){
          Array<double> s1;
          std::cout << "s1.size() = " << s1.size() << "\n";
          s1.fill(3.0);
          s1[0] = 8.23;
          s1[1] = -10.2;
          s1[3] = 0.0;
          s1.print("s1");

          Array<std::string, 4> s2;
          std::cout << "s2.size() = " << s2.size() << "\n";
          s2.fill("C++");
          s2.print("s2");
          s2[0] = "PlusPlus";
          s2[1] = "CPP";
          s2[2] = "ASM";
          s2.print("s2");
  }
#+END_SRC

Running on CLING REPL:

#+BEGIN_SRC cpp 
  >> .X default-template-args.C 
  s1.size() = 10
  s1 = 8.23 -10.2 3 0 3 3 3 3 3 3 
  s2.size() = 4
  s2 = C++ C++ C++ C++ 
  s2 = PlusPlus CPP ASM C++ 
#+END_SRC
** Implementing Higher Order Functions with templates 
   :PROPERTIES:
   :ID:       20156a12-aa32-407d-8cc0-5c4b85ba9021
   :END:


 + File: [[file:src/template-hof1.cpp][file:src/template-hof1.cpp]]
 + Online Compiler: https://rextester.com/ZAT8950

#+BEGIN_SRC cpp :tangle src/template-hof1.cpp 
  /**   File:     template-hof1.cpp 
    ,*  Brief:    Shows how to implement template higher order functions which operates on containers.
    ,*  Features: Template metaprogramming, C++11, functional programming and STL.
    ,****************************************************************************/
  #include <iostream>
  #include <cmath>
  #include <list>
  #include <deque>
  #include <vector>
  #include <functional> 
  #include <iomanip>

  /** Apply a function to every element of a container */
  template<class ELEM, class ALLOC, template<class, class> class CONTAINER>
  void forRange1(CONTAINER<ELEM, ALLOC>& cont, std::function<void (ELEM&)> fn){
          for(auto i =  std::begin(cont); i != std::end(cont); i++)
                  fn(*i);
  }

  /** Apply a function to every element of a container */
  template<class CONTAINER>
  void forRange2(CONTAINER& cont, std::function<void (decltype(cont.front()))> fn){
          for(auto i =  std::begin(cont); i != std::end(cont); i++)
                  fn(*i);
  }

  /** Template for folding over a container in a similar way to the higher order function fold. 
   ,* Note: 
   ,* + CONTAINER parameter accepts any argument which has .begin() and .end() methods 
   ,*   returning iterators. 
   ,* + STEPFN type parameters accepts any function-object, function pointer or lambda 
   ,*   whith the following signature: (ACC, X) => ACC where ACC is the accumulator type 
   ,*   and X is the type of the container element. 
   ,*/
  template<class CONTAINER, class ACC, class STEPFN>
  auto foldRange(CONTAINER& cont, const ACC& init, STEPFN fn) -> ACC {
          ACC acc{init};
          for(auto i =  std::begin(cont); i != std::end(cont); i++)
                  acc = fn(*i, acc);
          return acc;
  }

  int main(){
          std::ios_base::sync_with_stdio(false);

          std::vector<int> vec{1, 2, 400, 100};
          std::list<int>   lst{1, 2, 400, 100};

          // Requires template argument 
          std::cout << "===== EXPERIMENT 1 =================\n";
                  std::cout << "forRange1 - Vector" << "\n";
          forRange1<int>(vec, [](int x){ std::cout << std::setw(5) << x << " "; });
          std::cout << "\n";
          std::cout << "forRange1 - List" << "\n";
          forRange1<int>(lst, [](int x){ std::cout << std::setw(5) << x << " "; });
          std::cout << "\n";

          // Doesn't require the template argument as the compiler can infer its type.
          std::cout << "===== EXPERIMENT 2 =================\n";
          std::cout << "forRange1 - Vector" << "\n";
          forRange2(vec, [](int x){ std::cout << std::setw(5) << x << " "; });
          std::cout << "\n";
          std::cout << "forRange1 - list" << "\n";
          forRange2(lst, [](int x){ std::cout << std::setw(5) << x << " "; });
          std::cout << "\n";

          std::cout << "===== EXPERIMENT 3 =================\n";
          int result1 = foldRange(vec, 0, [](int x, int acc){
                                                  return x + acc;
                                            });	
          std::cout << "sum(vec1) = " << result1 << "\n" ;
          int result2 = foldRange(lst, 0, std::plus<int>());	
          std::cout << "sum(lst) = " << result2 << "\n" ;

          std::cout << "product(lst) = " << foldRange(lst, 1, std::multiplies<int>()) << "\n" ;
          return 0;
  }

#+END_SRC

Output: 

#+BEGIN_SRC sh 
  clang++ template-hof1.cpp -o template-hof1.bin -g -std=c++11 -Wall -Wextra && ./template-hof1.bin
  ===== EXPERIMENT 1 =================
  forRange1 - Vector
      1     2   400   100 
  forRange1 - List
      1     2   400   100 
  ===== EXPERIMENT 2 =================
  forRange1 - Vector
      1     2   400   100 
  forRange1 - list
      1     2   400   100 
  ===== EXPERIMENT 3 =================
  sum(vec1) = 503
  sum(lst) = 503
  product(lst) = 80000
#+END_SRC
** Metafunctions or type traits 
*** Overview 

Metafunction (aka type traits) is a template metaprogramming technique
for type introspection, type manipulation and type computation. This
idiom uses templates, template specialization, structs (classes with
everything public) and constexpr in C++11.

This section contains examples about template metafunctions. For more
information about this subject and further reading, see: 
 + [[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Metafunction][More C++ Idioms/Metafunction - Wikibooks, open books for an open world]]
 + [[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Generator][More C++ Idioms/Type Generator - Wikibooks, open books for an open world]]
 + [[https://akrzemi1.wordpress.com/2012/03/19/meta-functions-in-c11/][Meta-functions in C++11 | Andrzej's C++ blog]]
 + [[https://accu.org/index.php/journals/442][ACCU - An introduction to C++ Traits]]


A meta function has the forms: 

 + Meta function which returns type.

#+BEGIN_SRC cpp 
  // Doesn't matter using typename T1, typename T2
  // or using class T1, class T2 ..
  template<class T1, class T2 ...>
  struct meta_function {
          // Before C++11
          // Meta function which returns type 
          using type = ... ;
  };

  template<typename T1, typename T2 ...>
  struct meta_function {
          // Before C++11
          // Meta function which returns type 
          using type = ... ;
  };

  // Before C++11 
  template<class T1, class T2 ...>
  struct meta_function {
          typedef ... ... type;
  };

  // Usage: 
  using type_synonym =  meta_function<T1, T2, ...>::type ;
  // Or in before C++11
  typedef  meta_function<T1, T2, ...>::type type_synonym;
#+END_SRC

 + Meta function which returns value.

#+BEGIN_SRC cpp 
  // At least C++11
  template<class T1, class T2 ...>
  struct meta_function {
          // Requires at aleast C++11
          // Meta function which returns type 
          static constexpr TYPE value = ... 
  };

  // Before C++11
  template<class T1, class T2 ...>
  struct meta_function {
          // Requires at aleast C++11
          // Meta function which returns type 
          static const TYPE value = ... 
  };

  // Usage:
  TYPE result = meta_function<T1, T2, ..>::value;
#+END_SRC

Further References: 

 + [[https://en.cppreference.com/w/cpp/header/type_traits][Standard library header <type_traits> - cppreference.com]]
 + [[https://www.youtube.com/watch?v=eVtLOHoDbTo][Type Traits - CopperSpice video]]

*** Example 

 *Example*

Example in:
 * file:            [[file:src/template-metafunction.cpp][file:src/template-metafunction.cpp]]
 * Online compiler: http://rextester.com/TAT89158
 * The code in the example demonstrates how to query types using
   template specialization, catalog type information and display the
   user as well. 

Highlights: 

 - The *metafunction isPointer* checks whether a given type is a
   pointer.

#+BEGIN_SRC cpp
  template<class T>
  struct isPointer{
          static constexpr bool value = false;
          constexpr bool operator()() const { return false; }
  };

  template<class T>
  struct isPointer<T*>{
          static constexpr bool value = true;
          constexpr bool operator()() const { return true; }
  };
#+END_SRC

Sample usage:

#+BEGIN_SRC cpp 
  std::cout << "isPointer<short*>::value  = " << isPointer<short*>::value << "\n";
  std::cout << "isPointer<short>::value   = " << isPointer<short>::value << "\n";
  std::cout << "isPointer<double>::value  = " << isPointer<double>::value << "\n";
  std::cout << "isPointer<double*>::value = " << isPointer<double*>::value << "\n";
#+END_SRC

Output: 

#+BEGIN_SRC text 
  isPointer<short*>::value  = true
  isPointer<short>::value   = false
  isPointer<double>::value  = false
  isPointer<double*>::value = true
#+END_SRC

  - The *meta function removePointer* turns any pointer type into a
    non-pointer type removing the star operator.

#+BEGIN_SRC cpp 
  // Partial specilization
  template<class T> struct removePointer{
          typedef T type;
  };
  template<class T> struct removePointer<T*>{
          typedef T type;
  };
#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
  disp(Typeinfo<removePointer<double>::type>::name);
  disp(Typeinfo<removePointer<double*>::type>::name);
  disp(Typeinfo<removePointer<const char*>::type>::name);
#+END_SRC

Output: 

#+BEGIN_SRC text 
  template-metafunction.cpp:175: ; Typeinfo<removePointer<double>::type>::name = double
  template-metafunction.cpp:176: ; Typeinfo<removePointer<double*>::type>::name = double
  template-metafunction.cpp:177: ; Typeinfo<removePointer<const char*>::type>::name = const char
#+END_SRC

 -  *The metafunction Typeinfo* computes basic information about types at
   compile-time. As this "metafunction" relies on template
   specialization, it requires defining template specialization for
   all supported types what can be cumbersome. In order to avoid the
   specialization boilerplate code, the macro ~REGISTER_TYPE_INFO~ is
   used to register the supported types. 

#+BEGIN_SRC cpp 
  template<typename T>
  struct Typeinfo{
          static constexpr const char* name	 = "unknown";
          static constexpr size_t      size	 = sizeof(T);
          static constexpr bool        isNumber	 = false;
          static constexpr bool        isPointer = ::isPointer<T>::value;
          static constexpr bool        isConst	 = ::isConst<T>::value;		
  };

  // Macro for type registration 
  #define REGISTER_TYPE_INFO(type, isNumberFlag) \
          template<> struct Typeinfo<type>{ \
                  static constexpr const char* name		= #type; \
                  static constexpr size_t      size		= sizeof(type); \
                  static constexpr bool        isNumber	= isNumberFlag;	\
                  static constexpr bool        isPointer	= ::isPointer<type>::value; \
                  static constexpr bool        isConst	= ::isConst<type>::value;	\
          }

   // Type registration 
   REGISTER_TYPE_INFO(bool, false);
   REGISTER_TYPE_INFO(char, false);
#+END_SRC

Usage example: 

#+BEGIN_SRC cpp 
  std::cout << "Type info for " << Typeinfo<int>>::name 
            << " size = " << Typeinfo<int>::size 
            << " isPointer = " << Typeinfo<int>::isPointer 
            << "\n";
#+END_SRC


 *Complete Program output:* ([[file:src/template-metafunction.cpp][file:src/template-metafunction.cpp]])

#+BEGIN_SRC text 
   $ clang++ template-metafunction.cpp -o template-metafunction.bin -g -std=c++11 -Wall -Wextra  
   ./template-metafunction.bin

   isPointerOLD<short*>::value  = 1
   isPointerOLD<short>::value   = 0
   isPointerOLD<double>::value  = 0
   isPointerOLD<double*>::value = 1
   isPointer<short*>::value  = true
   isPointer<short>::value   = false
   isPointer<double>::value  = false
   isPointer<double*>::value = true
   isPointer<short*>()()  = true
   isPointer<short>()()   = false
   isPointer<double>()()  = false
   isPointer<double*>()() = true
   Type Info: name =            bool ; bytes =    1 ; isNumber = false ; isPointer = false ; isConst = false
   Type Info: name =            char ; bytes =    1 ; isNumber = false ; isPointer = false ; isConst = false
   Type Info: name =     std::string ; bytes =   32 ; isNumber = false ; isPointer = false ; isConst = false
   Type Info: name =             int ; bytes =    4 ; isNumber =  true ; isPointer = false ; isConst = false
   Type Info: name =           short ; bytes =    2 ; isNumber =  true ; isPointer = false ; isConst = false
   Type Info: name =           float ; bytes =    4 ; isNumber =  true ; isPointer = false ; isConst = false
   Type Info: name =          double ; bytes =    8 ; isNumber =  true ; isPointer = false ; isConst = false
   Type Info: name =     const char* ; bytes =    8 ; isNumber =  true ; isPointer =  true ; isConst =  true
   Type Info: name =          float* ; bytes =    8 ; isNumber = false ; isPointer =  true ; isConst = false
   Type Info: name =         double* ; bytes =    8 ; isNumber = false ; isPointer =  true ; isConst = false
   Type Info: name =   const double& ; bytes =    8 ; isNumber = false ; isPointer = false ; isConst =  true
   template-metafunction.cpp:175: ; Typeinfo<removePointer<double>::type>::name = double
   template-metafunction.cpp:176: ; Typeinfo<removePointer<double*>::type>::name = double
   template-metafunction.cpp:177: ; Typeinfo<removePointer<const char*>::type>::name = const char
#+END_SRC
** Predefined type traits in <type_traits>

The C++11 header ~<type_traits>~ (before ~boost.type_traits~) provide many
useful type traits, also known as metafunction, for querying and
transforming types at compile-time. In addition to those operations,
the type traits available in this header can also be used for
optimizing templates by specializing them for specific types.

Documentation: 
 
  + [[https://en.cppreference.com/w/cpp/header/type_traits][Standard library header <type_traits> - cppreference.com]]
  + [[https://www.boost.org/doc/libs/1_68_0/libs/type_traits/doc/html/index.html][Chapter 1. Boost.TypeTraits - 1.68.0]] 

Examples: 
 
 - To use the C++11's type traits, it is necessary to include the
   header ~<type_traits>~

#+BEGIN_SRC cpp 
  #include <iostream> 
  #include <string> 
  #include <type_traits> 
#+END_SRC

 - Type trait ~std::is_void~
   - Checks whether type is void. 

#+BEGIN_SRC cpp 
  >> std::is_void<void>::value
  (const bool) true
  >> 
  >> std::is_void<int>::value
  (const bool) false
  >> std::is_void<void*>::value
  (const bool) false
  >> 
  >> std::is_void<bool>::value
  (const bool) false
  >> 

  template<class T>
  void inspectType(){
          if(std::is_void<T>::value)
                  std::cout << "Type is void" << "\n";
          else
                  std::cout << "Type is not void" << "\n";
  }

  >> 
  >> inspectType<void>()
  Type is void
  >> inspectType<bool>()
  Type is not void
  >> inspectType<int>()
  Type is not void
  >> 
#+END_SRC

 - Check whether type is float point: ~std::is_floating_point~

#+BEGIN_SRC cpp 
  >> std::is_floating_point<float>::value
  (const bool) true
  >> std::is_floating_point<double>::value
  (const bool) true
  >> std::is_floating_point<long double>::value
  (const bool) true
  >> std::is_floating_point<int>::value
  (const bool) false
  >> std::is_floating_point<char>::value
  (const bool) false
  >> 
#+END_SRC

 - Check whether type is interger: ~std::is_integral~

#+BEGIN_SRC cpp 
  >> 
  >> std::is_integral<int>::value
  (const bool) true
  >> std::is_integral<long>::value
  (const bool) true
  >> std::is_integral<char>::value
  (const bool) true
  >> std::is_integral<unsigned char>::value
  (const bool) true
  >> std::is_integral<double>::value
  (const bool) false
  >> std::is_integral<bool>::value
  (const bool) true
  >> std::is_integral<void>::value
  (const bool) false
  >> 
#+END_SRC

 - Check whether type is const 

#+BEGIN_SRC cpp 
  >> std::is_const<int>::value
  (const bool) false
  >> std::is_const<const int>::value
  (const bool) true
  >> std::is_const<const char*>::value
  (const bool) false
  >> std::is_const<const std::string&>::value
  (const bool) false
#+END_SRC

 - Check whether type is a reference (&)

#+BEGIN_SRC cpp 
  >> 
  >> std::is_reference<int&>::value
  (const bool) true
  >> std::is_reference<const int&>::value
  (const bool) true
  >> std::is_reference<double&>::value
  (const bool) true
  >> std::is_reference<double>::value
  (const bool) false
  >> std::is_reference<double*>::value
  (const bool) false
  >> 
#+END_SRC

 *Type relationship*

 - Check whether type are equal. 

#+BEGIN_SRC cpp 
  // Returns true if types are the same 
  >> std::is_same<int, int>::value
  (const bool) true
  >> std::is_same<int, float>::value
  (const bool) false
  >> std::is_same<float, float>::value
  (const bool) true
  >> 
#+END_SRC

 - Checks whether types are derived.
   - ~std::is_base_of<A, B>::value~ returns true if A is a base type (superclass) of
     B or B is derived class of A.

#+BEGIN_SRC cpp 
  class A{
  public:
  };
  class B: public A{
  public:
  };
  class Z{
  };

  >> std::is_base_of<A, B>::value
  (const bool) true
  >> std::is_base_of<B, A>::value
  (const bool) false
  >> 
  >> std::is_base_of<B, Z>::value
  (const bool) false
  >> std::is_base_of<Z, A>::value
  (const bool) false
  >> 

#+END_SRC
** Variadic Templates 

This code shows examples about variadic templates in C++11 and
newer standards.

File: [[file:src/template-variadic.cpp][file:src/template-variadic.cpp]]

Code Highlights:


 - Print a sequence of heterogenous arguments.

#+BEGIN_SRC cpp 
  template<typename T>
  void printTypes(const T& x){	
          std::cout << std::left << std::setw(15) << x
                                    << std::setw(10) << std::right << " size = "
                                    << std::setw(2) << sizeof(x) << "\n";
          std::clog << " [TRACE] Base case => x = " << x << "\n";
  }
  // Variadic template arguments 
  template<typename T, typename ... Types>
  void printTypes(const T& x, const Types ... args){
          std::cout << std::left << std::setw(15) << x
                                    << std::setw(10) << std::right << " size = "
                                    << std::setw(2) << sizeof(x) << "\n";
          printTypes(args ...);
  }
#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
   printTypes("hello world", 10, 'x', 20.23f, true, NAN);
#+END_SRC

Ouput: 

#+BEGIN_SRC text 
  hello world       size = 12
  10                size =  4
  x                 size =  1
  20.23             size =  4
  1                 size =  1
  nan               size =  4
#+END_SRC


 - Create a function that applies a member function to a given object.

#+BEGIN_SRC cpp 
  template<class T, class R, class ... Args>
  auto makeCommand(
          // Pointer to member function 
          R (T::* pMemfn) (Args ... args),
          // Member function arguments 
          Args ... arglist) -> std::function<R (T& obj)> {
          return [=](T& obj){ return (obj.*pMemfn)(arglist ...); };
  }
#+END_SRC

Usage:

#+BEGIN_SRC cpp
   CNCMachine mach1("7Z9FA");
   CNCMachine mach2("MY9FT");
   auto setSpeed10 = makeCommand(&CNCMachine::setSpeed, 10);
   auto shutdown   = makeCommand(&CNCMachine::shutdown);
   setSpeed10(mach1);
   setSpeed10(mach2);
   shutdown(mach2);
#+END_SRC

 - Dynamic load an [U] nix-shared library or shared object.

#+BEGIN_SRC cpp 
  /** Type synonym for shared library handler 
   ,*  Requires: #include <dlfcn.h> and -ldl linker flag */
  using LibHandle = std::unique_ptr<void, std::function<void (void*)>>;

  auto loadDLL(const std::string& libPath) -> LibHandle {
          // Return unique_ptr for RAAI -> Resource Acquisition is Initialization
          // releasing closing handle when the unique_ptr goes out of scope. 
          return LibHandle(
                  dlopen(libPath.c_str(), RTLD_LAZY),
                  [](void* h){
                          std::cout << " [INFO] Shared library handle released OK." << "\n";
                          dlclose(h);
                  });		
  }

  /** Load symbol from shared library 
    ,*  Requires: #include <dlfcn.h> and -ldl linker flag */
  template<typename Function>
  auto loadSymbol(const LibHandle& handle, const std::string& symbol) -> Function* {
          void* voidptr = dlsym(handle.get(), symbol.c_str());
          if(voidptr == nullptr)
                  return nullptr;
          return reinterpret_cast<Function*>(voidptr);
  }
#+END_SRC

Usage: 

#+BEGIN_SRC cpp 
   // GNU Scientific Library - Linear Algebra CBLAS 
   auto handle1 = loadDLL("/usr/lib64/libgslcblas.so");
   using cblas_daxpy_type = void (int, double, const double*, int, double*, int);
   auto cblas_daxpy = loadSymbol<cblas_daxpy_type>(handle1, "cblas_daxpy");
   // Or 
   auto cblas_daxpy = loadSymbol<void (int, double, const double*, int, double*, int)>(handle1, "cblas_daxpy");

   auto xs = std::vector<double>{ 3.0, 5.0, 6.0, 10.0, 8.0};
   auto ys = std::vector<double>{ 2.0, 2.0, 2.0,  2.0, 2.0};
   printContainer("xs", xs);
   printContainer("ys", ys);
   // Compute xs * 4.0 + ys
   cblas_daxpy(xs.size(), 4.0, &xs[0], 1, &ys[0], 1);
   printContainer("ys", ys);
#+END_SRC

Output: 

#+BEGIN_SRC text 
  [INFO]  Loaded clblas_daxpy OK!
 xs = 3, 5, 6, 10, 8, 
 ys = 2, 2, 2, 2, 2, 
 ys = 14, 22, 26, 42, 34, 
  [INFO] Shared library handle released OK.
#+END_SRC


Complete Output: 

#+BEGIN_SRC txt 
   $ g++ template-variadic.cpp -o template-variadic.bin -g -std=c++11 -Wall -Wextra -ldl 
   $ ./template-variadic.bin

   EXPERIMENT 1 = Function of many argument for printing all of them
   ---------------------------------------
   hello world       size = 12
   10                size =  4
   x                 size =  1
   20.23             size =  4
   1                 size =  1
   nan               size =  4
    [TRACE] Base case => x = nan

   EXPERIMENT 2 = Indirect method invocation
   --------------------------------------
   [MACHINE] id = 7Z9FA Set machine speed to level 10
   [MACHINE] id = MY9FT Set machine speed to level 10
   [MACHINE] id = 7Z9FA  Equipment to position set to  x = 10 ; y = -20
   [MACHINE] id = MY9FT  Equipment to position set to  x = 10 ; y = -20
   [MACHINE] id = 7Z9FA Shutdown equipment
   [MACHINE] id = MY9FT Shutdown equipment

   EXPERIMENT 3 = Dynamic Loading from shared library (libgslcblas.so) 
   --------------------------------------
    [INFO]  Loaded clblas_daxpy OK!
   xs = 3, 5, 6, 10, 8, 
   ys = 2, 2, 2, 2, 2, 
   ys = 14, 22, 26, 42, 34, 
    [INFO] Shared library handle released OK.
#+END_SRC

References:  
 + [[https://stackoverflow.com/questions/27604128/c-stdfunction-like-template-syntax][c++11 - C++ std::function-like template syntax - Stack Overflow]]
 + [[https://www.nag.com/numeric/FL/nagdoc_fl24/html/F06/f06ecf.html][F06ECF (DAXPY) : NAG Library, Mark 24]]
 + [[https://dwheeler.com/program-library/Program-Library-HOWTO/x172.html][Dynamically Loaded (DL) Libraries]]
 + [[https://www.gnu.org/software/gsl/doc/html/cblas.html][GSL CBLAS Library — GSL 2.5 documentation]]

** Variadic Templates - sizeof... operator 

The operator sizeof...(args) is used for counting the number of template
arguments.

 - Class or function with type parameters.

#+BEGIN_SRC cpp 
  template<class ... ARGUMENTS>
  Return FUNCTION(ARGUMENTS ... arguments){
    ..... 
  }

  template<class ... ARGUMENTS>
  struct AStruct{
    ..... 
  };
#+END_SRC

 - Operator: sizeof...(ARGUMENTS)

#+BEGIN_SRC cpp 
  size_t NumberOfTypeArguments = sizeof...(ARGUMENTS);
#+END_SRC


 - Count number of type parameters 

#+BEGIN_SRC cpp 
  template<typename ... Args>
  void countArgs1(){
       std::cout << "Number of args is equal to = " << sizeof...(Args) << "\n";
  }
#+END_SRC

Running: 

#+BEGIN_SRC cpp 
  >> countArgs1()
  Number of args is equal to = 0

  >> countArgs1<int, double, char>()
  Number of args is equal to = 3

  >> countArgs1<int, double, char, std::string>()
  Number of args is equal to = 4
#+END_SRC

 - Count number of template numeric arguments 

#+BEGIN_SRC cpp 
  template<size_t ... Number>
  void countNumberArguments(){
       std::cout << "Number of args is equal to = " << sizeof...(Number) << "\n";
  }
#+END_SRC

Running: 

#+BEGIN_SRC cpp 
  >> countNumberArguments()
  Number of args is equal to = 0

  >> countNumberArguments<>()
  Number of args is equal to = 0

  >> countNumberArguments<1>()
  Number of args is equal to = 1

  >> countNumberArguments<1, 3>()
  Number of args is equal to = 2

  >> countNumberArguments<1, 3, 5, 6, 7, 10>()
  Number of args is equal to = 6
#+END_SRC

 - Count number of function arguments 

#+BEGIN_SRC cpp 
  // Or:
  template<class ... Params>
  void countParameters(Params ... params){
       std::cout << "Number of parameters equal to = " << sizeof...(params) << "\n";
  }
#+END_SRC

Running: 

#+BEGIN_SRC cpp 
  >> countParameters()
  Number of parameters equal to = 0

  >> countParameters(10)
  Number of parameters equal to = 1

  >> countParameters('x')
  Number of parameters equal to = 1

  >> countParameters(12, 'x', "hello world", 3.34)
  Number of parameters equal to = 4
#+END_SRC

** Variadic Templates arguments expansion 

 + *Example 0*:

Expand numeric template arguments into a std::vector.

#+BEGIN_SRC cpp 
  template<size_t ... Numbers>
  auto getNumberParameters() -> std::vector<size_t>
  {
      return std::vector<size_t> { Numbers ... };
  }
#+END_SRC

Running: 

#+BEGIN_SRC cpp 
  >> .L script-parampack.C
  >> 
  >> getNumberParameters()
  (std::vector<size_t>) {}
  >> getNumberParameters<>()
  (std::vector<size_t>) {}
  >> 
  >> getNumberParameters<0>()
  (std::vector<size_t>) { 0 }
  >> getNumberParameters<0, 10, 56, 100, 5, 3>()
  (std::vector<size_t>) { 0, 10, 56, 100, 5, 3 }
  >> 
#+END_SRC

 + *Example 1:*

Get deque container containing the size in bytes of every type from
the parameter pack (arguments of a variadic template).

#+BEGIN_SRC cpp 
  // Return a deque containing the size in bytes of each type from the
  // parameter pack (types arguments).
  template<typename ... Types>
  auto getSizeList() -> std::deque<size_t> {
       // { ... } Intializer list - used for 
       // C++11 default intialization feature. 
       return std::deque<size_t> { sizeof(Types) ... };	
  }
#+END_SRC

Running: 

#+BEGIN_SRC cpp 
  >> getSizeList()
  (std::deque<size_t>) {}

  >> getSizeList<>()
  (std::deque<size_t>) {}

  >> getSizeList<char>()
  (std::deque<size_t>) { 1 }

  >> getSizeList<double>()
  (std::deque<size_t>) { 8 }

  >> getSizeList<char, int, double, long double, std::string>()
  (std::deque<size_t>) { 1, 4, 8, 16, 32 }
#+END_SRC

 + *Example 2:*

Example: modify example 1 for requiring at least one type parameter.

#+BEGIN_SRC cpp 
  template<typename Type0, typename ... Types>
  auto getSizeList2() -> std::deque<size_t> {
       return std::deque<size_t> { sizeof(Type0), sizeof(Types) ... };	
  }
#+END_SRC

Running: 

#+BEGIN_SRC cpp 
  >> getSizeList2<>()
  ROOT_prompt_2:1:1: error: no matching function for call to 'getSizeList2'
  getSizeList2<>()
  ^~~~~~~~~~~~~~
  /home/archbox/root-scripts/script-parampack.C:41:6: note: candidate template ignored: couldn't infer template argument 'Type0'
  auto getSizeList2() -> std::deque<size_t> {
     ^
  >> getSizeList2<char>()
  (std::deque<size_t>) { 1 }

  >> getSizeList2<double>()
  (std::deque<size_t>) { 8 }

  >> getSizeList2<double, int, char, long double, std::string>()
  (std::deque<size_t>) { 8, 4, 1, 16, 32 }
  >> 
#+END_SRC

 *Example 3:* 

Print RTTI (Runtime Type Information) about types parameters.

#+BEGIN_SRC cpp 
  struct TypeInfo
  {
      TypeInfo(const std::string& name, unsigned int hash_code, size_t size)
       : name(name),
         hash_code(hash_code),
         size(size)
      {		
      }
      std::string   name;
      unsigned long hash_code;
      size_t        size;	
  };

  template<typename ... Types>
  auto printTypesInfoFromRTTI() -> void
  {
      auto tlist = std::vector<TypeInfo> {
              TypeInfo{
                 typeid(Types).name(),
                 typeid(Types).hash_code(),
                 sizeof(Types)
                      } ... };
      std::cout << std::setw(5)  << "Name"
                << std::setw(5)  << "Size"
                << std::setw(15) << "Hash"
                << "\n";
      std::stringstream ss;	
      for(const auto& x: tlist){
          ss.str("");
          ss.clear();
          ss << "0x" << std::hex << x.hash_code;
          std::cout << std::right
                    << std::setw(5)  << x.name
                    << std::setw(5)  << x.size
                    << std::setw(15) << ss.str()
                    << "\n";
          }
  } //--- End of printTypesInfoFromRTTI() ----- //
#+END_SRC

Running (ROOT/Cling REPL): 

#+BEGIN_SRC sh 
   >> printTypesInfoFromRTTI<>()
    Name Size           Hash
   >> 
   >> printTypesInfoFromRTTI<char>()
    Name Size           Hash
       c    1     0x2479fc8d
   >> 
   >> printTypesInfoFromRTTI<char, int, double, long double>()
    Name Size           Hash
       c    1     0x2479fc8d
       i    4     0xb675de06
       d    8     0x44573475
       e   16     0xbbbbed2c
#+END_SRC

** References and Bookmarks 

General 

 + [[https://en.cppreference.com/w/cpp/language/templates][Templates - cppreference.com]]

 + [[https://en.cppreference.com/w/cpp/header/type_traits][Standard library header <type_traits> - cppreference.com]]

 + [[https://en.cppreference.com/w/cpp/language/class_template][Class template - cppreference.com]]


Templates and Iterators: 
 + [[https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/][std::iterator is deprecated: Why, What It Was, and What to Use Instead - Fluent C++]]

Dependent Type Names: 
 + [[http://www.enseignement.polytechnique.fr/informatique/INF478/docs/Cpp/en/cpp/language/dependent_name.html][Dependent names - cppreference.com]]

Variadic Templates:
 + [[http://www.cplusplus.com/articles/EhvU7k9E/][C++11 - New features - Variadic template - C++ Articles]]
 + [[http://kevinushey.github.io/blog/2016/01/27/introduction-to-c++-variadic-templates/][Introduction to C++ Variadic Templates · R and C++]]
 + [[https://docs.microsoft.com/en-gb/cpp/cpp/ellipses-and-variadic-templates?view=vs-2017][Ellipses and Variadic Templates | Microsoft Docs]]
 + [[https://stackoverflow.com/questions/27604128/c-stdfunction-like-template-syntax][c++11 - C++ std::function-like template syntax - Stack Overflow]]

Videos: 

 + CppCon 2015: Peter Sommerlad "Variadic Templates in C++11 / C++14 -
   An Introduction" - <https://www.youtube.com/watch?v=R1G3P5SRXCw>

 + CppCon 2016: Michał Dominiak "Variadic expansion in examples" -
   <https://www.youtube.com/watch?v=Os5YLB5D2BU> 

 + Presented by Andrei Alexandrescu - Channel 9 - *Variadic Templates are Funadic* -
   <https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Variadic-Templates-are-Funadic>

 + Presented by Andrei Alexandrescu - Channel 9 - *The Way of the*
   *Exploding Tuple* -
   <https://channel9.msdn.com/Events/GoingNative/2013/The-Way-of-the-Exploding-Tuple> 

Papers and technical documents about Generic Programming and Template Metaprogramming 

 + Alexander Stepanov and David R. Musser - *Generic Programming* -
   <http://stepanovpapers.com/genprog.pdf> 

 + Alexander Stepanov and Meng Lee. *The Standard Template Library*
   + <http://stepanovpapers.com/STL/DOC.PDF>

 + Alexandre Duret-Lutz et al. *Design Patterns for Generic Programming in C++*
   + <https://www.lrde.epita.fr/dload/papers/coots01.html>

 + Alexandre Duret-Lutz et al. *Design Patterns for Generic Programming in C++*
   + <https://www.usenix.org/legacy/events/coots01/full_papers/duret/duret_html/index.html>

 + James C. Dehnert and Alexander Stepanov. *Fundamentals of Generic Programming*
   + <http://stepanovpapers.com/DeSt98.pdf>

 + Jeremy Gibbons. *Patterns in Datatype-Generic Programming*
   + <http://www.cs.ox.ac.uk/jeremy.gibbons/publications/patterns.pdf>

 + Giuseppe Lipari. *Design Patterns in C++ Template metaprogramming*
   + <http://retis.sssup.it/~lipari/courses/oosd2010-2/07.metaprogramming-handout.pdf>

 + Gabriel Dos Reis and Jaakko Jarvi. *What is Generic Programming?*
   + <https://pdfs.semanticscholar.org/e730/3991015a041e50c7bdabbe4cb4678531e35b.pdf>

 + *Functional Programming with C++ Template Metaprograms*
   + <https://pdfs.semanticscholar.org/c7f3/a67b78dabd5aa6c4599a127583c07bb8c032.pdf>

 + *Implementing Monads for C++ Template Metaprograms*
   + <http://plcportal.inf.elte.hu/en/publications/TechnicalReports/monad-tr.pdf>

 + Angelika Langer. *C++ Expression Templates - An Introduction to the*
   *Principles of Expression Templates*
   + <http://www.angelikalanger.com/Articles/Cuj/ExpressionTemplates/ExpressionTemplates.htm>

 + *Advanced C++ Template Techniques: An Introduction to Meta-Programming for Scientific Computing*
   + <https://conradsanderson.id.au/misc/sanderson_templates_lecture_uqcomp7305.pdf>

 + [[http://people.cs.uchicago.edu/~jacobm/pubs/templates.html][What's Wrong with C++ Templates?]]
