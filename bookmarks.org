#+INCLUDE: theme/style.org
#+TITLE: CPP / C++ - Bookmarks 
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 

 - [[wiki:index][Index]]

* Bookmarks 
** Online Tools

 * *Online Compilers*

   + http://rextester.com/
     + The main selling point of this online tool is that it allows to
       save code snippets and run them again. 
     + Online C++ compiler, provides GCC, CLANG and Visual Studio
       Compiler, also known as MSVC (VC++ - Visual C++).

   + https://repl.it/languages/cpp11
     + Oline compiler (GCC / C++11 only) with REPL support.

   + https://wandbox.org/

 * *Compiler Explorer*
   + https://godbolt.org/
     * Compiler explorer - allows to explore the assembly generated by a
       wide variety of compilers, including, GNU GCC, Clang, MSVC and so on.
   + https://demangler.com/
     * Symbol demangler for MSVC and GCC.

 * *Template expasion visualizer*
   + http://metashell.org/index.html

 * *UML Ascii/Text Drawing Tools*
   * [[http://asciiflow.com/][ASCIIFlow Infinity]] (Pick-and place)
     * Allows to draw Ascii UML box diagrams by dragging and dropping
       like in MS-Paint.

   * http://stable.ascii-flow.appspot.com/ (Pick-and place)

   * https://textik.com/ (Pick-and place)

   * https://www.planttext.com/ (Latex-like)

   * https://textart.io/sequence  (Latex-like)
     * UML Sequence Diagram drawing tool. The user writes the commands
       and the tool draws the diagram. It adopts an approach similar
       to Tex/Latex.


 * *MISC*
   + [[https://www.google.ca/search?q=float%20point%20online][float point online - Google Search]]
   + [[https://www.h-schmidt.net/FloatConverter/IEEE754.html][IEEE-754 Floating Point Converter]]
   + [[http://weitz.de/ieee/][IEEE 754 Calculator]]

** Code Standards and guidelines 

 *Design guidelines*

Design:

 + [[https://root.cern.ch/TaligentDocs/TaligentOnline/DocumentRoot/1.0/Docs/books/WM/WM_4.html][Taligent's Design Guidelines]]

 + [[https://cppdepend.com/blog/?p=179][Lessons to learn from the old well implemented games: Prince of Persia && Doom3. – CppDepend Blog]]

Exception and Error Handling: 

 + ISO-CPP [[https://isocpp.org/wiki/faq/exceptions][Exceptions and Error Handling, C++ FAQ]]
   + Great coverage about error handling, error recovery, performance
     considerations about exceptions and their benefits and drawbacks
     as well.

 + [[https://cppdepend.com/blog/?p=311][Exceptions is one of the controversy mechanism in C++. Should I use them? – CppDepend Blog]]
   + Provides insights of widely known C++ experts and gurus about
     exceptions and useful considerations.

 + [[http://www.acodersjourney.com/2016/08/top-15-c-exception-handling-mistakes-avoid/][Top 15 C++ Exception handling mistakes and how to avoid them. - A CODER'S JOURNEY]]

Fail-fast approach: 

 + [[https://www.codeproject.com/Articles/1138445/Introduction-to-the-Fail-Fast-Principle-in-Softwar][Introduction to the 'Fail Fast!' Principle in Software Development - CodeProject]]
 + [[https://enterprisecraftsmanship.com/2015/09/15/fail-fast-principle/][Fail Fast principle - Enterprise Craftsmanship]]
 + [[http://ithare.com/unchecked-exceptions-for-c/][Unchecked Exceptions for C++ - IT Hare on Soft.ware]]
 + [[http://joeduffyblog.com/2016/02/07/the-error-model/][Joe Duffy - The Error Model]]
 + [[http://wiki.c2.com/?FailFast][Fail Fast]]


 *Coding format and standard guidelines*

 + [[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#main][ISO C++ Core Guidelines]] - "This is a set of core guidelines for
   modern C++, C++17, C++14, and C++11, taking likely future
   enhancements and ISO Technical Specifications (TSs) into
   account. The aim is to help C++ programmers to write simpler, more
   efficient, more maintainable code."

   + [[http://www.modernescpp.com/index.php/c-core-guidelines-constructors-assignments-and-desctructors][C++ Core Guidelines: The Rule of Zero, Five, or Six - ModernesCpp.com]]
   + [[http://www.modernescpp.com/index.php/c-core-guidelines-when-you-can-t-throw-an-exception][C++ Core Guidelines: finally in C++ - ModernesCpp.com]]
   + [[http://www.modernescpp.com/index.php/c-core-guidelines-constructors][C++ Core Guidelines: Constructors - ModernesCpp.com]]
   + [[http://www.modernescpp.com/index.php/c-core-guidelines-more-rules-to-concurrency-and-parallelism][C++ Core Guidelines: More Rules to Concurrency and Parallelism - ModernesCpp.com]]
   + [[http://www.modernescpp.com/index.php/c-core-guidelines-concurrency-and-lock-free-programming][C++ Core Guidelines: Concurrency and lock-free Programming - ModernesCpp.com]]
   + [[http://www.modernescpp.com/index.php/c-core-guidelines-rules-to-error-handling][C++ Core Guidelines: Rules for Error Handling - ModernesCpp.com]]
   + [[http://www.modernescpp.com/index.php/c-core-guidelines-type-erasure][C++ Core Guidelines: Type Erasure - ModernesCpp.com]]

 + [[https://developer.mozilla.org/en-US/docs/Mozilla/Using_CXX_in_Mozilla_code][Using C++ in Mozilla code - Mozilla | MDN]] 

 + [[https://wiki.openstack.org/wiki/CppCodingStandards#Using_Namespaces_Properly][CppCodingStandards - OpenStack]] - "Note that coding standards and
   guidelines will never be perfect and that not everyone will agree
   with every guideline or naming convention. The purpose of the
   guidelines and standards are to maintain consistency in the source
   code." 

 + [[https://google.github.io/styleguide/cppguide.html][Google C++ Style Guide]]

 + [[http://drake.mit.edu/styleguide/cppguide.html][Google C++ Style Guide for Drake]]

 + [[https://developer.lsst.io/cpp/style.html][DM C++ Style Guide — LSST DM Developer Guide Current documentation]]

 + [[https://users.ece.cmu.edu/~eno/coding/CppCodingStandard.html][C++ Coding Standard]]

 + [[https://juce.com/discover/stories/coding-standards][Coding Standards | JUCE]] - Juce code standard and its rationale and
   motivation.  

** Debugger 
*** GDB Front-Ends GUI 

GDB's (GNU Debugger) Front-End GUI for [U]-nix

 + [[https://sourceware.org/gdb/wiki/GDB%20Front%20Ends][GDB Front Ends - GDB Wiki]]

 + http://www.kdbg.org/ - GNU Debugger Front-End with KDE user
   interface.
   + Linux Fedora install: *$ sudo dnf install kdbg.x86_64*
   + Interface Style: KDE/QT
   + Features:
     + Syntax highligh
     + Dissably Line - Just click at a given line to show its assembly code.
     + Watch variables and expressions at any context
     + Can View the current stack of many threads
     + Inspect Stack Variables in a tree-like structure
     + View CPU Register.

 + [[https://wiki.gnome.org/Apps/Nemiver][Neminver]] - Intuitive and easy GNOME User Interface for (GDB) GNU
   Debugger.
   + Linux Fedora install: *$ sudo dnf install neminver.x86_64*
   + Interface Style: GNOME/Gtk 
   + Features:
     + Syntax highligh
     + Set/Clear breakpoints graphically by clicking.
     + Many windows to watch stack variables
     + Watch variables and C++ expressions.
     + View CPU Registers

   + https://gdbgui.com/ - Browser Front-end for GDB Server.
     + Note: requires Python.

 + https://github.com/cyrus-and/gdb-dashboard
   + GUI Style: TUI - Terminal User Interface - Keyboard driver.
   + Modular GDB Interface written in Python.

*** GDB Reference Cards 

 + [[http://visualgdb.com/gdbreference/commands/print][GDB Command Reference - print command]]

 + [[https://darkdust.net/files/GDB%2520Cheat%2520Sheet.pdf][PDF - GDB Cheat Sheet]]

 + [[http://shanekirk.com/2018/02/gdb-tips-and-tricks-6-examining-data-types/][GDB Tips and Tricks #6: Examining Data Types – ShaneKirk.com]]

 + [[http://shanekirk.com/2017/12/gdb-tips-and-tricks-5-the-display-command/][GDB Tips and Tricks #5: The Display Command – ShaneKirk.com]]

** Mind Map 

Shared Libraries / Software Components 

 - Interoperability

 - Binary Compatibility

 - C-library

   - [[http://www.etalabs.net/compare_libcs.html][Comparison of C/POSIX standard library implementations for Linux]]

 - Linking

   - Static Linking

   - Dynamic Linking

 - [[http://en.wikipedia.org/wiki/Dependency_hell][Dependency Hell]]

 - API - Application Programming Interface

 - ABI - [[https://en.wikipedia.org/wiki/Application_binary_interface][Application Binary Interface]]

   - Calling Conventions

   - [[https://en.wikipedia.org/wiki/System_call][System Call]]

   - Stable and Standard ABI - C Language

   - [[https://en.wikipedia.org/wiki/Loader_(computing)][Loader (computing)]]

   - [[https://en.wikipedia.org/wiki/Dynamic_linker][Dynamic linker]]

   - [[https://en.wikipedia.org/wiki/Binary-code_compatibility][Binary-code compatibility]]

 - FFI - Foreign Function Interface 

 - Excetuable Formats

   - [[https://en.wikipedia.org/wiki/Portable_Executable][PE]] - Portable Executable / Windows (*.exe files and *.dll files)

   - [[https://en.wikipedia.org/wiki/Executable_and_Linkable_Format][ELF]] - Executable and Linkable Format / Unix (Linux, BSD ...)

   - [[https://en.wikipedia.org/wiki/Mach-O][Mach-O]] -  Mach object file format / Mach-OSX and IOS

   - [[https://en.wikipedia.org/wiki/Comparison_of_executable_file_formats][Comparison of executable file formats]]

   - 

** Drawbacks and ABI Issues

*Drawbacks*

 + C++ is unsafe. Bugs like stack overflow, buffer overlow, null
   pointr exceptions may happen.

 + _Operating System Depedent_ - C++ may be portable, but it is not
   cross platform since it is compiled to machine code and for a
   particular operatiing system.

 + Hardware dependent (Processor Architecture) and Operating System
   Depedent. C++ is compied to machine code / binary code for a
   particular operating system and processor architecture with
   different executable formats. The most common processor
   architectures are Intel x86 (32 bits) and AMD64 (64 bits).

   + OS Windows            / Executable Format - PE-32

   + Unix (Linux, BSD ...) / Executable Format - ELF

   + Mac-OSX               / Executable Format - Mac-O

   +

 + _No Standard ABI (Application Binary Interface)_ - C++ shared
   libraries and programs compiled with different compilers or
   different versions of same compiler may be incompatible because
   unlinke C, C++ doesn't have a standard ABI. It makes hard to call
   libraries written in C+++ through an FFI - Foreign Function
   Interface form another programming language such as Python.


*ABI Issues* - Credits: *Defining a Portable C++ ABI* - https://isocpp.org/files/papers/n4028.pdf

_A C++ developer cannot compile C++ code and share the object file with_
_other C++ developers on the same platform and know that the result_
_will compile and link correctly_. Our status quo is that two source
files a.cpp and b.cpp can only be linked together if they are compiled
with both:" -- ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])

 - "the same version of the same compiler, or another compiler with a
   compatibility mode" ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])

 - "compatible switch settings, since most C++ compilers offer
   incompatible switch settings where even compiling two files with
   the same version of the same compiler will not link successfully."
   ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])



Issues:

 - "It makes sharing binary C++ libraries more difficult: _To ship a C++_
   _library in binary form for a given platform requires building it_
   _with possibly dozens of popular combinations of switch settings for_
   the popular compiler(s) on that platform, and then may not cover
   all combinations. Alternatively, one can wrap the library in that
   platform’s stable C ABI, which brings us to…"  ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])



 - "_It is a valid reason to use C: This is (the) one area where C is_
   _superior to C++_. Among programs and programmers who would otherwise
   use C++, _the top reason to use C appears to be the inability to_
   _publish an API with a stable binary ABI_, including that it can be
   linked to from C, C++, and other languages’ foreign function
   interfaces (FFIs) such as Java JNI and .NET PInvoke. In
   particular…"  ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])



 - "_It therefore creates ongoing security problems: The fact that C is_
   _the only de facto ABI-stable lingua franca continues to encourage_
   _type- and memory-unsafe C APIs that traffick in things like error_
   prone pointer/length pairs instead of more strongly typed and still
   highly efficient abstractions, including but not limited to
   std::string or the new string_view"  ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])


*Solutions to ABI compatibility issues*

 1) _Distribute the library in source format_. Approach adopted by QT
    (former Trolltech Inc, now the QT Company) with open source and
    commercial license.

 2) Distribute the library in binary format and only support a
    specific compiler.

 3) _Compile he C++ shared library with all possible compilers_ and
    distribute the binaries for each compiler, compiler version,
    processor architecture and operating system.

 4) _Write the library in C, instead of C++_. This approach is followed
    by most Unix/Linux libraries and OpenGL and Gtk GUI toolkit.

 5) Use some language that can compile/generate C-code (transpiler).

 6) Use Microsoft COM (Component Object Model)/ DCOM or CORBA, DBUS ... 



Note: C is until now the only language with a standard and public ABI
and most OS exposes its API through a C interface, programming
languages runtimes are generally implement in C.

** Compiler Metadata Generators

 + [[https://pygccxml.readthedocs.io/en/develop/upgrade_issues.html][GCC-XML 0.7 → 0.9 upgrade issues (Legacy) — pygccxml 1.9.1 documentation]]
      
** Tooling 

 * Documentation Builder, aka Generator 
   + Doxygen => http://www.doxygen.org/
   
 * IDEs and Quasi-IDEs

   + *Visual Studio Community Edition* (Windows Only)

   + *CLion* / JetBrains 

   + GNome Builder => Not an IDE, but at least the code completion
     "just works" without any configuration. 
     + https://wiki.gnome.org/Apps/Builder/Features
     + https://www.collabora.com/news-and-blog/blog/2018/08/03/cross-compilation-made-easy-for-gnome-builder/

 * Building Systems
   + CMake
     + https://cmake.org/documentation/
   + Meson
     + https://github.com/mesonbuild/meson/wiki
   + SCons
     + https://scons.org/
   + Make (GNU Make, BSD Make or Windows MAKE - NMake)
     + https://en.wikipedia.org/wiki/Makefile
   + Ninja
     + https://ninja-build.org/

 * Package Managers:
   + https://conan.io/
   + [[https://docs.microsoft.com/en-us/cpp/vcpkg?view=vs-2017][vcpkg-- A C++ package manager for Windows, Linux and MacOS | Microsoft Docs]]
   + [[http://www.buckaroo.pm/][Buckaroo - C/C++ Package Manager]]
   + [[https://gist.github.com/Overdrivr/d14e4c7e79234f1fb7b3a5a14f8b6ad9][Why C/C++ package managers fail for now ?]]

 * Source Code Naviagator => Helpers for understanding code. 
   + Source Trail => https://www.sourcetrail.com/
   + CPPDepend

 * *Debuggers* - Essential tools for development, debugging,
   introspecing processes, reversing engineering and security
   research.
   + GDB  - GNU Debugger 
   + LLDB - LLVM/Clang Debugger
   + WinDG -> Windows Debugger 
   + IDA

** What sucks about C++ 

Outline: 
 + Slow compile-time 
 + Macros and preprocessor
 + No pre-compiled libraries, project dependencies have to be
   compiled from source due to ABI incompatibility. This is why
   header-only libraries are popular. 
 + Lack of module system 
 + Undefined behavior 
 + High Degree of Complexity
 + Complexity of building systems 
 + No standard package manager
 + Binary compatibility among compilers.
 + Lack of ABI makes unfeasible to build C++ components or shared
   libraries without a C API. In C#, the user has just to add a DLL
   and in Java, the user has just to add jar package to include a
   dependency in a project. In C++, it is not possible, all
   dependencies need to compiled from source.
 + Code repetitition, every class' source file .cpp needs a matching
   header file. 

References: 

 + [[https://blog.codinghorror.com/the-problem-with-c/][The Problem With C++]] - Jeff Atwood. 
 + [[https://dorinlazar.ro/why-c-sucks-2016-02-edition/][Why C++ sucks (2016.02 edition) – dorinlazăr.ro]]
 + [[https://flyx.org/2014/04/24/cpp_sucks/][flyx.org - Reasons why C++ sucks]]
 + [[https://whydoesitsuck.com/cpp-sucks-for-a-reason/][The C++ Programming Language Sucks for a Very Good Reason | Why Does It Suck?]]
 + [[https://en.wikipedia.org/wiki/Criticism_of_C%2B%2B][Criticism of C++ - Wikipedia]]
 + [[https://en.wikipedia.org/wiki/Most_vexing_parse][Most vexing parse - Wikipedia]]

** C++ Resources

*C++ General Resources*

 - Ian D. Chivers - *An Introduction to C++*
   <http://www.icsd.aegean.gr/lecturers/kavallieratou/Cplusplus_files/notes.pdf>

 - [[https://www.reddit.com/r/Physics/comments/2w4exo/what_are_the_useful_aspects_of_c_in_physics/][What are the useful aspects of C++ in Physics programming? : Physics]]

 - [[https://anteru.net/blog/2016/05/01/3249/][Designing C APIs in 2016 | Anteru’s blog]]

*C++ Numerical Methods and Scientific Computing*

 - Prof. R. Hiptmair, SAM, ETH Zurich. *Numerical Methods for
   Computational Science and Engineering* -
   <http://www.sam.math.ethz.ch/~hiptmair/tmp/NumCSE/NumCSE15.pdf>


 - Norbert Pozar. *Basic C++ for numerical computations: vectors*
   <http://polaris.s.kanazawa-u.ac.jp/~npozar/basic-cpp-for-numerics-vectors.html>


*C++ STL - Standard Template Library*


 - *A modest STL tutorial*
   <http://cs.brown.edu/~jak/proglang/cpp/stltut/tut.html>


 - Carlos Moreno. *C++ Vectors* <https://cal-linux.com/tutorials/vectors.html>


*C++ ABI - Application Binary Interface, Binary Compatibility and FFI*

 - By Agner Fog. *Calling conventions for different C++ compilers and
   operating systems*
   <http://www.agner.org/optimize/calling_conventions.pdf>


 - Armin Ronacher. *Beautiful Native Libraries*
   <http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/>


 - Herb Sutter. *Defining a Portable C++ ABI* <https://isocpp.org/files/papers/n4028.pdf>

 - *Some thoughts on binary compatibility*
   <http://blog.qt.io/blog/2009/08/12/some-thoughts-on-binary-compatibility/>

 - *Interoperability of Libraries Created by Different Compiler
   Brands* <http://www.mingw.org/wiki/Interoperability_of_Libraries_Created_by_Different_Compiler_Brands>

 - Thiago Macieira. *Binary compatibility for library developers*
   <https://events.linuxfoundation.org/sites/events/files/slides/Binary_Compatibility_for_library_devs.pdf>

 - *What Language I Use for… Creating Reusable Libraries: Objective-C*
   <http://www.informit.com/articles/article.aspx?p=2144812>

 - *Compilable modern alternatives to C/C++* -
   <https://softwareengineering.stackexchange.com/questions/162614/compilable-modern-alternatives-to-c-c>

 - [[https://stackoverflow.com/questions/3217513/are-llvm-gcc-and-clang-binary-compatible-with-gcc-particularly-mingw-gcc-on-w][linker - Are llvm-gcc and clang binary compatible with gcc? - particularly mingw gcc on Windows - Stack Overflow]]

 - [[http://rlc.vlinder.ca/blog/2009/08/binary-compatibility/][Binary Compatibility | Making Life Easier]]

 - *System V Application Binary Interface AMD64 Architecture Processor
   Supplement* <https://c9x.me/compile/bib/abi-x64.pdf>

 - *Software optimization resources* - <http://www.agner.org/optimize/>

 - [[https://softwareengineering.stackexchange.com/questions/281882/why-does-c-provide-language-bindings-where-c-falls-short][Why does C provide language 'bindings' where C++ falls short? - Software Engineering Stack Exchange]]

 - [[https://news.ycombinator.com/item?id=2379676][I've written in C++ professionally almost 12 years (17 years counting College), ... | Hacker News]]

 - [[https://www.reddit.com/r/swift/comments/67z7dy/what_is_abi_stability_and_why_does_it_matter/][What is ABI stability and why does it matter? : swift]]

 - [[https://www.reddit.com/r/programming/comments/4r6r8e/abi_vs_api/][ABI vs. API : programming]]

 - [[https://www.reddit.com/r/linux_gaming/comments/5nqaux/confused_about_compatibility/dcdxd19/][heartsofwar comments on Confused about Compatibility]]

 - [[https://www.reddit.com/r/askscience/comments/3ei05n/why_is_that_programs_need_to_be_ported_between/][Why is that programs need to be ported between operating systems in order in to function? What goes on at the programming level to require this? : askscience]]

 - [[https://www.reddit.com/r/AskProgramming/comments/5c74i4/some_thoughts_about_abis/][some thoughts about ABIs : AskProgramming]]

 - [[http://damienkatz.net/2013/01/the_unreasonable_effectiveness_of_c.html][Damien Katz: The Unreasonable Effectiveness of C]]

 - [[https://www.reddit.com/r/linux/comments/42vngw/why_is_the_linux_community_ambivalent_about/][Why is the Linux community ambivalent about binary compatibility? : linux]]

 - [[https://www.reddit.com/r/C_Programming/comments/4afu69/implementing_cross_platform_library_in_c_proscons/][Implementing cross platform library in C pros/cons C_Programming]]

 - 

 - 

*C-Interface* 

 - *CppCon 2014: Stefanus DuToit "Hourglass Interfaces for C++ APIs* -
   <https://www.youtube.com/watch?v=PVYdHDm0q6Y>


*FFI - Foreign Function Interface*

 - https://en.wikipedia.org/wiki/Foreign_function_interface

 - [[http://www.mono-project.com/docs/advanced/pinvoke/][Interop with Native Libraries | Mono]]

 - [[https://en.wikipedia.org/wiki/SWIG][SWIG - Wikipedia]] -  Simplified Wrapper and Interface Generator

 - [[https://sourceware.org/libffi/][libffi]] - A Portable Foreign Function Interface Library

 - [[https://en.wikipedia.org/wiki/Libffi][libffi - Wikipedia]]

 - [[https://docs.python.org/3/extending/extending.html][1. Extending Python with C or C++ — Python 3.6.1 documentation]]

 - [[https://msdn.microsoft.com/en-us/library/aa288468(v=vs.71).aspx][Platform Invoke Tutorial (C#)]]

 - [[https://www.reddit.com/r/explainlikeimfive/comments/5c2yfq/eli5_how_can_a_single_software_project_use/][Eli5: How can a single software project use multiple languages? Wouldn't the compiler have difficulty understanding what's what? : explainlikeimfive]]

 - [[https://www.reddit.com/r/learnprogramming/comments/3dzif8/how_do_you_communicate_between_different_computer/][How do you communicate between different computer languages? : learnprogramming]]


*Courses and Online Books*

 - [[https://en.wikibooks.org/wiki/C%2B%2B_Programming][C++ Programming - Wikibooks, open books for an open world]]


 - Francois Fleuret. *C++ lecture notes*
   <https://www.idiap.ch/~fleuret/files/Francois_Fleuret_-_C++_Lecture_Notes.pdf>


 - Course:  https://www3.ntu.edu.sg/home/ehchua/programming/

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp0_Introduction.html][An Introduction to C++ Programming for First-time Programmers - C++ Programming Tutorial]] - https://archive.is/MRDZI

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][C++ Libraries, String and Standard Template Library]] - https://archive.is/lrIDk

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp2_MoreBasics.html][C++ More Basics]] - https://archive.is/pr7pn

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp3_OOP.html][Object-oriented Programming (OOP) in C++]] - https://archive.is/lpXae

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp4_PointerReference.html][C++ Pointers and References]] - https://archive.is/Ja1xJ

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp5_OOPExamples.html][Examples on Classes and Objects]] - https://archive.is/eZJPl

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp8_Template.html][Object-oriented Programming (OOP) in C++ - Template and Generic Programming]] - https://archive.is/eG0KZ

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_String.html][C++ Libraries, String and Standard Template Library]]

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_String.html][C++ Libraries, String and Standard Template Library]]

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_IO.html][C++ IO Streams and File Input/Output]]

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp11_TipsTraps.html][Examples on Classes and Objects]]

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/DataStructureAlgorithm.html][Data Structure and Algorithm]]

*Unix - API / LibC*

 - *User space and the libc interface* - <https://www.win.tue.nl/~aeb/linux/lk/lk-3.html>


*Embedded Systems*

 - [[http://bitbashing.io/embedded-cpp.html][C++ On Embedded Systems]]

 - [[http://git.eti.pg.gda.pl/intel-grant/pliki/esp/ESP_Toolchain_ENG.pdf][Embedded Systems Programming OS Linux - Toolchain]]

 - 

*Alternatives to C++*

The C++ language is suitable for system programming, writing native
applications and writing high performance software components or
libraries. However the lack of standard ABI - Application Binary
interface makes calling C++ calling a C++ library through FFI -
Foreign Function Interface in another language harder.

Due to the C++ ABI issues, many portable libraries that are easier to
invoked through a FFI are written in C, for instance, GTK GUI toolkit,
... 

Selection Requirements: 

 - Compile to native code.

 - Have an stable and standard ABI - Application Binary Interface like C.

 - Be able to build shared libraries *.so or *.dll and easily invoked
   through FFI - Foreign Function Intefaces of high level languages
   such as Python, Ruby, Java, C# and so on.

 - Be memory safe in order to avoid buffer overflow. 


_D language_


   - [[http://bitbashing.io/2015/01/26/d-is-like-native-python.html][D is like native Python]]

   - [[http://code.dlang.org/packages/pyd][Package pyd version 0.9.9 - DUB - The D package registry]]

   - [[http://dlang.org/spec/abi.html][Application Binary Interface - D Programming Language]] 

   - [[https://dlang.org/dll-linux.html][Writing Shared Libraries With D On Linux - D Programming Language]]

   - [[http://blog.tenstral.net/2016/05/adventures-in-d-programming.html][Adventures in D programming | Ximions Blog]]

_Gambit Scheme_ 

A Scheme implementation that is interactive with a REPL and that can
generate C-code and invoke C-libraries. It can be compiled to
shared libraries *.so or *.dlls and be called from scheme REPL.

_Rust_

** C => to C++ Guidelines

+ Malloc - Avoid malloc and manual memory management. Instead of that
  use _new_ and _vector_ instead of realloc.
+ Pointer - Avoid pointers.
+ Arrays - Use C++ STL vector classes instead of arrays.
+ Strings. Don't use array of characters to represent a string,
  instead of that use c++ strings by inclunding '#include <string>'
  header at the top of file.
+ Separate the operating system depedent code from the
  operating system agnostic code.

** Books 
*** C++ Programming Language 

+ Bruce Eckel. *Thinking in C++*. 1995
  + Notes: Despite being an old book, it has a step-by-step coverage
    of C++ main concepts and some design patterns.

+ Andrew Koenig and Barbara E. Moo. *Accelerated C++: Practical Programming by Example*

+ Andrei Alexandrescu. *Modern C++ Design: Generic Programming and*
  *Design Patterns Applied 1st Edition*. 2001 
  + Notes: Provides a comprehensive and broad coverage of C++
    generic/template metaprogramming.
  + Link: [[https://www.amazon.com/Modern-Design-Generic-Programming-Patterns/dp/0201704315][Amazon]]

+ Scott Meyers. *Effective C++ Third Edition, 55 Specific Ways to Improve Your*
  *Programs and Designs* 

+ Bjarne Stroustrup. *Tour of C++ second edition*

 *More Advanced Books:*

+ Martin Reddy. *API Design for C++* 
  + Table of contents: http://www.apibook.com/blog/contents
  + Amazon: https://www.amazon.com/API-Design-C-Martin-Reddy/dp/0123850037
  + Note: Covers design patters, API Versioning, Plugins, Scripts, ...

*** System Programming - Posix / Linux and U**N-ix

Note: Most of those books use C because operating system services and
low level system libraries are exposed in *C language* and most used
operating systems nowadays were written in C. In addition, C++ still
doesn't have a stable and standardized ABI (Application Binary
Interface like C).

Books about Linux C-APIs are not only useful for this operating
system, but also for other Unix-based OSes such as MacOSx, BSD,
Android (Based on Linux), QNX Rtos and so on.

 * Michael Kerrisk. *The Linux Programming Interface* - 2010 - ISBN
   978-1-59327-220-3
   + Coverage: File I/O, Processes, Memory Allocation, Daemons, Shared
     Libraries, Interprocess communication, System V Message Queues,
     System V Semaphores, Memory Mapping, TCP/IP Sockets,
     Unix-Sockets, Terminals and System Calls.
   + Web site:  http://man7.org/tlpi/
   + Wikipedia: [[https://en.wikipedia.org/wiki/The_Linux_Programming_Interface][The Linux Programming Interface - Wikipedia]]
   + Chapters:  http://man7.org/tlpi/toc-short.html
   + [[https://www.amazon.com/Linux-Programming-Interface-System-Handbook/dp/1593272200][Amazon Link]]

 * Kurt Wall et al. *Linux Programming Unleashed* - 1999
   + Covers low level system calls; process control;
     thread-synchronization primitives; TCP/IP sockets and network;
     shared memory and XWidows system/Xlib user interface.
   + The most used language in the book is C, although there are some
     examples in C++.
   + [[https://www.amazon.com/Linux-Programming-Unleashed-Kurt-Wall/dp/0672320215][Amazon link to second edition]]

*** System Programming - Microsft Windows NT

  + Mark Russinovitch et al - *Windows Internals* - 5th edition -
    Microsft Press 2000. 
    + Coverage: Windows API, Virtual Memory, Kernel Mode X User Mode,
      Terminal, Object and Handles, Registry, Sysinternals Tools,
      Kernel System Components, System Calls, Windows Sockets
      (Winsock), NetBIOS, NTFS file system.
    + [[https://www.amazon.com/Windows-Internals-Part-Developer-Reference/dp/0735648735][Amazon Link]] (6th edition)


  + Charles Petzold - *Windows Programming* - Microsoft Press - 5th
    edition - 1998
    + Coverage: Win32 API, windows graphical stack, GDI (Graphics
      Device Interface), Dynamic Linked Libraries DLLs. 
    + [[https://www.amazon.com/Programming-Windows%25C2%25AE-Fifth-Developer-Reference/dp/157231995X][Amazon Link]]

  + Johnson M. Hart, *Win32 System Programming: A Windows® 2000* -
    *Application Developer's Guide*, 2nd Edition, Addison -
    Wesley, 2000.
    + Note: This book discusses select Windows programming problems
      and addresses  the problem of portable programming by comparing
      Windows and Unixapproaches.
    + [[https://www.amazon.com/Win32-System-Programming-Application-Developers/dp/0201703106][Amazon Link]]

  + Jeffrey Richter, *Programming Applications for Microsoft Windows*,
    4th Edition, Microsoft Press, September 1999.
    + Note: This book provides a comprehensive discussion of the
      Windows API suggested reading.

  + Visual Basic - *Programmer’s Guide to the Win32 API*, The
    Authoritative Solution by Dan Appleman

  + Don Box - *Essential COM* 1st edition - 1998 - Addison-Wesley
    Professional - ISBN 978-0201634464
    + Comprehensive coverage of COM - Component Object Model. 
    + [[https://www.amazon.com/Essential-COM-Don-Box/dp/0201634465][Amazon Link]]
** Interesting Source Codes 

 + *Libfuse* (C, not C++)
   * https://github.com/libfuse/libfuse
   * The reference implementation of the Linux FUSE (Filesystem in
     Userspace) interface.  

 + *CERN-Reflex* => SEAL Reflection System 
   + https://github.com/snoopspy/reflex/tree/master/src
   + What it can do:
     + Return type by name, by type info, invoke constructor of
       registered type.
     + Return type unique identifier.
   + Techniques Used:
     + Type erasure using C++ template technique and void* pointer.
   + Some Codes:
     + Reflection types database
       + https://github.com/snoopspy/reflex/blob/master/inc/Reflex/Type.h
       + https://github.com/snoopspy/reflex/blob/master/src/Kernel.cxx
       + https://github.com/snoopspy/reflex/blob/master/src/Typedef.h
       + https://github.com/snoopspy/reflex/blob/master/src/Class.h
       + https://github.com/snoopspy/reflex/blob/master/src/Function.h
     + Property List => Properties get/set can be added to an object
       at runtime.
       + https://github.com/snoopspy/reflex/blob/master/inc/Reflex/PropertyList.h
       + https://github.com/snoopspy/reflex/blob/master/src/PropertyList.cxx
       + https://github.com/snoopspy/reflex/blob/master/src/PropertyListImpl.cxx
     + Object Interface
       + https://github.com/snoopspy/reflex/blob/master/inc/Reflex/Object.h
     + Any Container for type erasure derived from Boost.Variant 
       + https://github.com/snoopspy/reflex/blob/master/src/Any.cxx
       + https://github.com/snoopspy/reflex/blob/master/inc/Reflex/Any.h
     + Shared library and Plugins - wrapper
       + https://github.com/snoopspy/reflex/blob/master/inc/Reflex/SharedLibrary.h
       + https://github.com/snoopspy/reflex/blob/master/src/PluginService.cxx
       + https://github.com/snoopspy/reflex/blob/master/src/PluginFactoryMap.cxx
     + Python Code Generator => Parses GCCXML to generate a C++ code
       with reflection dictionary metadata. 
       + https://github.com/snoopspy/reflex/blob/master/python/genreflex/genreflex.py
       + https://github.com/snoopspy/reflex/blob/master/python/genreflex/gendict.py
       + 

 + *GNU Scientific Library* (C-lib)
   + https://github.com/ampl/gsl 

   + Most Used C-features:
     + *static* keyword used for make functions private to the
       compilation unit they are defined, so they are not visible in
       the executable, static or shared library. It is important to
       avoid name clashing because C doesn't have namespaces and it
       also needs all names to be unique as this language doesn't have
       overloading like C++.  

     + *const double array[], size_t size* => For passing C-arrays
       allocated by the caller code.

     + _void* vstate_ - Void pointer (opaque pointer) for passing state
       around functions and hiding data representation. TL;DR. Emulate
       orientation.

     + _const void* vstate_  => The "object" cannot be modified by the
       function.

     + malloc, free => Heap memory allocation.

   + Some Codes:
     + Polynomial Evaluation 
       + https://github.com/ampl/gsl/blob/master/poly/gsl_poly.h
     + Root Solvers 
       + https://github.com/ampl/gsl/blob/master/roots/bisection.c
       + https://github.com/ampl/gsl/blob/master/roots/newton.c
       + https://github.com/ampl/gsl/blob/master/roots/gsl_roots.h
       + https://github.com/ampl/gsl/blob/master/roots/steffenson.c
       + https://github.com/ampl/gsl/blob/master/gsl_math.h
     + Interpolation
       + https://github.com/ampl/gsl/blob/master/interpolation/linear.c
       + https://github.com/ampl/gsl/blob/master/interpolation/spline.c
       + https://github.com/ampl/gsl/blob/master/interpolation/poly.c
     + Derivate:
       + https://github.com/ampl/gsl/blob/master/deriv/deriv.c
     + Probability Distributions:
       + Normal - https://github.com/ampl/gsl/blob/master/cdf/gauss.c
       + Normal Inverse - https://github.com/ampl/gsl/blob/master/cdf/gaussinv.c
       + LogNormal https://github.com/ampl/gsl/blob/master/cdf/lognormal.c
       + T-student - https://github.com/ampl/gsl/blob/master/cdf/tdist.c
       + 

 + *CERN-Root* (CERN's Interactive C++ Framework)
   + https://github.com/root-project/root
   + Features Used:
     + std:: math functions, std::log, std::exp, std::max, std::min, std::fabs
   + Some Codes:
     + https://github.com/root-project/root/blob/master/.clang-format
     + https://github.com/root-project/root/blob/master/math/mathcore/src/RichardsonDerivator.cxx
     + https://github.com/root-project/root/blob/master/math/mathcore/src/BrentMethods.cxx

 + *libspng* (C-lib)
   + https://gitlab.com/randy408/libspng
   + A simpler, modern libpng alternative
   + Some Codes:
     + [[https://gitlab.com/randy408/libspng/blob/master/CMakeLists.txt][CMakeLists.txt · master · Randy / libspng · GitLab]]
     + [[https://gitlab.com/randy408/libspng/blob/master/common.c][common.c · master · Randy / libspng · GitLab]]
     + [[https://gitlab.com/randy408/libspng/blob/master/decode.c][decode.c · master · Randy / libspng · GitLab]]
     + [[https://gitlab.com/randy408/libspng/blob/master/spng.h][spng.h · master · Randy / libspng · GitLab]]

 + *go-ole* (GO Language)
   + https://github.com/go-ole/go-ole
   + win32 ole implementation for golang
   + Some Codes:
     + https://github.com/go-ole/go-ole/blob/master/com.go
     + https://github.com/go-ole/go-ole/blob/master/guid.go
     + https://github.com/go-ole/go-ole/blob/master/idispatch.go
     + https://github.com/go-ole/go-ole/blob/master/variant.go

 + *Busybox* (C Code) - Embedded Linux Swiss Army Knife
   + https://git.busybox.net/busybox/tree/
   + Some Codes:
     + https://git.busybox.net/busybox/tree/console-tools/reset.c
     + https://git.busybox.net/busybox/tree/coreutils
     + https://git.busybox.net/busybox/tree/coreutils/nohup.c
     + https://git.busybox.net/busybox/tree/coreutils/ls.c
     + https://git.busybox.net/busybox/tree/coreutils/shred.c (Secure deleting)
     + https://git.busybox.net/busybox/tree/coreutils/tail.c
     + https://git.busybox.net/busybox/tree/networking/arp.c
     + https://git.busybox.net/busybox/tree/networking/ifconfig.c

 + *Terminion* - (Rust) Library for low level ANSI/vt100 terminal control.
   + https://github.com/redox-os/termion
   + Some Codes:
     + https://github.com/redox-os/termion/blob/master/src/color.rs
     + https://github.com/redox-os/termion/blob/master/examples/is_tty.rs
     + https://github.com/redox-os/termion/blob/master/src/clear.rs
     + https://github.com/redox-os/termion/blob/master/src/screen.rs

* Selected Conference Videos 
** Misc 
*** Bjarne Stroustrup - The Essence of C++

- [[https://www.youtube.com/watch?v=86xWVb4XIyE][Bjarne Stroustrup - The Essence of C++]]
  - "Bjarne Stroustrup, creator and developer of C++, delivers his
    talk entitled, The Essence of C++. Stroustrup has held
    distinguished posts at Texas A&M University and spent significant
    time in the Computer Science Departments of Cambridge, Columbia
    and Princeton. C++ is the one of the world's most widely used
    technology languages and it has influenced newer languages such
    as C# and Java as well as older languages."
    + Applications on System Programming Domains:
      - Device drivers
      - Network drivers
      - Embedded Systems
      - Suitable for hard and soft real time systems.
    + C++ Origin: C + Simula (First Object Oriented language)
    + Main Ideas:
      - Direct map to hardware
      - Zero-overhead abstraction
      - Much of inspiration comes from operating systems.
      - Backward compatibility: Avoid breaking old code.
    + Key strengths:
      + A language for building lightweight abstractions.
      + Software infrastructure.
      + Resource-constrained application. (May be embedded systems)
      + Resource Management
*** CppCon 2017: Michael Spencer "My Little Object File: How Linkers Implement C++"

 - [[https://www.youtube.com/watch?v=a5L66zguFe4][CppCon 2017: Michael Spencer “My Little Object File: How Linkers Implement C++” - YouTube]]
   - "Ever wonder how the linker turns your compiled C++ code into an
     executable file? Why the One Definition Rule exists? Or why your
     debug builds are so large? In this talk we'll take a deep dive
     and follow the story of our three adventurers, ELF, MachO, and
     COFF as they make their way out of Objectville carrying C++
     translation units on their backs as they venture to become
     executables. We'll see as they make their way through the tangled
     forests of name mangling, climb the cliffs of thread local
     storage, and wade through the bogs of debug info. We'll see how
     they mostly follow the same path, but each approach the journey
     in their own way.  We'll also see that becoming an executable is
     not quite the end of their journey, as the dynamic linker awaits
     to bring them to yet a higher plane of existence as complete C++
     programs running on a machine."
*** C++NOW 2018: Michael Caisse - Modern C++ in Embedded Systems 

 + [[https://www.youtube.com/watch?v=1l2g2dAobXA][Modern C++ in Embedded Systems - YouTube]]
   + "For nearly 35 years I have been working with small processors
     and there has always been deep divides between practitioners of
     languages. When writing assembly we ridiculed those using C and
     when I spent years microcoding we scoffed at everyone. However,
     nearly all groups continue to wag their heads at the shameful C++
     programmers attempting to twist their tools toward the
     small. Recent language developments have made C++ the obvious
     choice for many embedded projects; nevertheless, the toxic
     environment extends past reddit roasts into poor vendor support
     of tools and nearly obstructionist chip manufacturers. This
     session will use a bare-metal project started in 2018 for a Ciere
     client as a case study while we work through the decision process
     for using C++, the acrobatics required to support the language,
     recent language features that enable goals of size, speed, and
     expressiveness, and useful libraries. While the examples will be
     based on a concrete project, the extracted lessons-learned should
     be applicable to many embedded projects (bare-metal and
     small-OS). Attendees will walk away with motivations to use C++
     in embedded projects, hints and tips to making tools work, and a
     sampling of language features and idioms that improve the quality
     of a final product."


See: https://arobenko.gitbooks.io/bare_metal_cpp/content/


What is shown:

   + Case presented: An ARM-based embedded processor is used for
     controlling motors and a hydraulic machine. 

   + Processor used: ARM Cortex RC4 connected to a FPGA (Filed
     Programmable Gate Array).

   + Peripherals mentioned: I2C, SPI

   + Tooling:
     + GCC toolchain for ARM
     + CMAKE for build automation.
     + Linker script

   + State Machine => Boost.SML (https://youtu.be/1l2g2dAobXA?t=4335)
     + Typical state machines used: _Mealy's state_ machine.
     + https://github.com/boost-experimental/sml

   + LADON - Real time object oriented modelling from 90's (prodecessor for
     UML Real time extensions) => Distributed State Machines.
     + Allows to connect multiple state machines.

   + Metaprogramming techniques used:
     + tag dispatching
     + CRTP => Curious Recurring Template Pattern for emulating
       dynamic polymorphism (runtime poly.) with static polymorphism
       at compile time.
     + Mixins
     + Variant Polymorphism
     + Type traits (metafunctions) => struct which takes list of types
       as arguments peforming computations on types.
     + Type synonyms with 'using' keyword

   + Common compiler options disabled on code for embedded systems:
     + Disable RTTI (-fno-rtti)
     + Disable exceptions (-fno-exceptions)

   + How can C++ simplify the project?
     + More declarative.
     + More correctness and bugs caught at compile-time.
     + Template metaprogramming is crucial for developing lightweight
       abstraction and reducing run-time overhead.

** Type Erasure and Polymorphism
*** NDC Conference 2017 - Sean Parent -  Better Code: Runtime Polymorphism

 + [[https://www.youtube.com/watch?v=QGcVXgEVMJg][Better Code: Runtime Polymorphism - Sean Parent - YouTube]]

   + Description: "This talk explains why (and how) to implement
     polymorphism without inheritance in C++. The talk contains many
     C++ tips and techniques, including many new features from
     C++11. During the course of that talk a key feature from
     Photoshop will be demonstrated and implemented."

   + Notes: This talk is about how to preserve value semantics and
     polymorphism without using inheritance in the client code. It is
     done by using the *type erasure* design pattern. Actually, the
     solution presented do use inheritance, but inside the ~object_t~
     class.

   + Benefits of the presented *type erasure* implementation:

     + Greater interoperability between software components as classes
       doesn't need to inherit froms same base class, the only
       requirement is to satisfy the constructor template constraints.

     + Alows value semantics to cohexist with polymorphism with
       minimal performance penalty. It combines the benefits of
       dynamic and static polymorphism.

     + A factory function can return a value rather than a pointer or
       smart pointer and still preserve the value semantics.

     + Non-intrusive for client code. A client code doesn't need to be
       aware of polymorphism. For instance, a client code _double describeArea(const Shape& sh)_ 
       cannot be used directly with objects returned by a factory
       function, for instance   std::unique_ptr<Shape>. By using 
       type erasure, this code  doesn't need to modified as the
       factory function can returns a value instead of a pointer and 
       still preserve the polymorphism.
       + Less error prone
       + Client code doesn't need heap allocation. (Actually, the heap
         allocation is hidden in the type erasure wrapper)
       + The client code doesn't need to worry about object ownership
         or lifetime.
       + Exception safe
       + Thread safe

     + _Referenced Book_: Stepanov, Alexander and Paul McJones -
       *Elements of Programming* - Addison Wesley - Professional 2009. 

   + Key Moments 

     + https://youtu.be/QGcVXgEVMJg?t=2032
       + The class structure is composed by concept class (interface),
         model classes inheriting the concept and the outter class
         that hides the inheritance and wraps any argument which
         statifies the template constraints.

     + https://youtu.be/QGcVXgEVMJg?t=2072
       + A virtual copy constructor is used in the concept class for
         allowing the wrapper class (outer class) object_t to preserve
         copy semantics by performing deep copying, instead of shallow
         copying.

     + https://youtu.be/QGcVXgEVMJg?t=2136 and https://youtu.be/QGcVXgEVMJg?t=2156
       + Templates used at constructor and the model. 
         
*** C++Now 2018: Louis Dionne "Runtime Polymorphism: Back to the Basics"

- [[https://www.youtube.com/watch?v=OtU51Ytfe04][C++Now 2018: Louis Dionne “Runtime Polymorphism: Back to the Basics” - YouTube]]
  + Description: "C++ solves the problem of runtime polymorphism in a very
    specific way. It does so through inheritance, by having all
    classes that will be used polymorphically inherit from the same
    base class, and then using a table of function pointers (the
    virtual table) to perform dynamic dispatch when a method is
    called. Polymorphic objects are then accessed through pointers to
    their base class, which encourages storing objects on the heap
    and accessing them via pointers. This is both inconvenient and
    inefficient when compared to traditional value semantics. As Sean
    Parent said: Inheritance is the base class of evil. It turns out
    that this is only one of many possible designs, each of which has
    different tradeoffs and characteristics. This talk will explore
    the design space for runtime polymorphism in C++, and in
    particular will introduce a policy-based approach to solving the
    problem. We will see how this approach enables runtime
    polymorphism with stack-allocated storage, heap-allocated
    storage, shared storage, no storage at all (reference semantics),
    and more. We will also see how we can get fine-grained control
    over the dispatch mechanism to beat the performance of classic
    virtual tables in some cases. The examples will be based on a
    real implementation in the Dyno library [1], but the principles
    are independent from the library."

    + Problem: C++ sub-typing polymorphism inevitably requires
      pointers to objects allocated on the heap. However by using
      pointers, the advantages of value semantics, which C++ is built
      on top, are lost. For instance, pointers doesn't play well with
      C++ algorithms and functions expecting value or reference
      parameters. Another issue is that pointers to objects allocated
      on the heap raises questions about memory ownership such as who
      should delete the pointer.

      + Ideas => some possible approaches:
        + Use static polymorphism: _template functions._
        + Use a _proxy object allocated on the stack._ The object
          inherits the base class and takes a pointer to base class
          as argument. Then the proxy object can forward any method
          call or message to the wrapped heap object.
        + Deal with it and accept as it is for performance reasons.

*** ECOOP 2015 - Bjarne Stroustrup - Object Oriented Programming without Inheritance 
 
 + [[https://www.youtube.com/watch?v=xcpSLRpOMJM][Bjarne Stroustrup - Object Oriented Programming without Inheritance - ECOOP 2015 - YouTube]]
   + Explanative talk about generic programming (templates) paradigm
     as an alternative to object oriented programming inheritance.
   + Selected Moments:
     + [[https://youtu.be/xcpSLRpOMJM?t=619][Deep Roots in earliste C++]]
     + [[https://youtu.be/xcpSLRpOMJM?t=794][Resources and resources management]]
     + [[https://youtu.be/xcpSLRpOMJM?t=1044][Move Semantics]]
     + [[https://youtu.be/xcpSLRpOMJM?t=1249][Generic Programming in C++]]
     + [[https://youtu.be/xcpSLRpOMJM?t=1566][An Example of generic interface]]
     + [[https://youtu.be/xcpSLRpOMJM?t=2088][C++ 'concepts']] (Generic programming.)

*** C++Now 2018: Odin Holmes C++ Mixins: Customization Through Compile Time Composition

 + [[https://www.youtube.com/watch?v=wWZi_wPyVvs][C++Now 2018: Odin Holmes “C++ Mixins: Customization Through Compile Time Composition” - YouTube]]
   + " Working in the embedded domain where 'special cases' are the
     norm I often find myself fighting with customization capabilities
     and 'canned' (non-customizable) abstractions. std::string often
     has a small buffer for small string optimization, std::function
     has something similar, why can't I set the size of that buffer,
     or more radically why can't I just stick that same buffer in a
     std::vector for a 'small vector optimization'. While we're at it
     why can't I take .at() out of std::vectors public interface and
     call some user-defined function on out of memory, maybe I turned
     off exceptions but still want to handle errors properly. Maybe I
     want a std::deque interface but have a fixed sized ring buffer
     under the hood. Those following the SG14 will notice I am ticking
     off proposals, the problem with these proposals is that the
     mostly follow a common pattern: "I need X without Y" or "I need X
     to have Y" and there are many many combinations of X and Y. Why
     do I have to pay for atomic ref counting in a shared_pointer in a
     single threaded use case? We could go on all day. In this talk we
     will explore the feasibility of building classes from composable
     pieces, some concrete proof of concepts as well as the library
     infrastructure needed for this task." 

** Functional Programming 
*** CPPCON-2017: Klaus Iglberger - Free Your Functions

+ [[https://www.youtube.com/watch?v=WLDT1lDOsb4][CppCon 2017: Klaus Iglberger "Free Your Functions!"]]
  * Description: "You are devoted to minimize coupling and
    duplication? You are taking care to maximize cohesion,
    flexibility, extensibility, encapsulation, testability, and even
    performance in order to achieve the high goals of
    (object-oriented) programming? Awesome!  But wait: You still
    favor member functions? Seriously? You have been deceived! You
    have been praying at the altar of false promises! Shed the
    shackles of Java philosophy! Free your functions!. In this talk I
    will demonstrate why in C++ free functions should generally be
    preferred to member functions, and why free functions — not
    member functions! — provide you with all the aforementioned
    advantages you expect from object-oriented programming. Note,
    though, that this talk might fundamentally change your perception
    of C++ and object-oriented programming in general!"

  * _Summary and notes_:
    * _Free functions_ (ordinary functions or non-virtual functions)
      abides to object oriented principles such as OCP (Open-Close
      Principle) as they can extend a class without requiring
      modification or recompilation of the class source code.
    * _Static polymorphism_ which is a combination of free functions
      and _template metaprogramming_ can make the code more loosely
      coupled and more perfomant.
      * Becomes more loosely coupled because it doesn't require that
        arguments have any common base class or class hierarchy.
      * Becomes more performant as template generates overloaded code
        for each different type parameters combination what
        eliminates virtual function calls and dynamic
        polymorphism. The disadvantage of templates are the higher
        complexity and larger code size.
    * Benefits of Free Functions:
      - Encapsulation
      - Cohesion (SRP - Single Responsibility Principle)
      - Reuse (DRY - DO NOT REPEAT YOURSELF)
      - Overloading (Polymorphism )
      - Generic Programming (Aka template metaprogramming)
      - Abstraction
      - Testability
      - _Performance_ (Raison d'être of C++).

    * Free Functions on standard library:
      - std::begin, std::cbegin ...

    * Use free functions in order to:
      * ... wrap virtual function calls
      * ... get an homogeneous interface.
      * ... get more performant code.
      * ... more flexible and loosely-coupled code.

    * Free functions aren't are multi-paradigm, they can work with
      any paradigm. It is not necessarly functional programming. 

    * Potential Problems
      * C++ doens't have a convenient syntax for function application
        as ML-based languages like Haskell and OCaml. So, multiple
        function applications would be written as f1(f2(f3(f5 ... fn(x))))

      * _Discoverability_: according to the presentation, IDE's may not
        help to find them easily as they help to find methods (aka
        member functions). However it can mitigated with careful
        selection of namespaces which would improve code complexion
        and discoverability.
*** C++Now 2018: Ben Deane "Easy to Use, Hard to Misuse: Declarative Style in C++"

 + [[https://www.youtube.com/watch?v=2ouxETt75R4][C++Now 2018: Ben Deane “Easy to Use, Hard to Misuse: Declarative Style in C++” - YouTube]]
   + We say that interfaces should be easy to use and hard to
     misuse. But how do we get there? In this talk I will demonstrate
     how using declarative techniques in APIs, functions, and plain
     old "regular" code can help. We'll look at what is meant by
     "declarative style" in C++; explore why declarative interfaces
     are desirable and how to construct them; and take an in-depth
     look at which features of C++ help us write in a declarative
     style. I want to deconstruct C++ a bit, examine what we're doing
     and what makes the good parts good, and from that reconstruct
     some best practices. Many of us are already writing code
     following piecemeal modern advice such as "no raw loops", or
     "almost always auto", or C++ core guideline recommendations. In
     many cases, this advice translates to writing more declarative
     code; being deliberate about exploring and using declarative
     techniques gives us insight we can apply more widely.     

** Tooling 
*** LVM Euro Conference 2013 - The Clang AST - a Tutorial

+ [[https://www.youtube.com/watch?v=VqCkCDFLSsc][The Clang AST - a Tutorial - YouTube]]
  + "If you always wanted to know more about about Clang's AST [1],
    for example because you want to implement an awesome tool [2, 3]
    based on Clang, or simply because you want to start contributing,
    this talk is for you."
  + Note: Clang + LLVM suite provides many services that can be used
    to build code automation tools for C++ such as code generators
    and reflection metadata code generator.
*** CppCon 2018: "Latest and Greatest in the Visual Studio Family for C++ Developers 2018" :tooling:

  + [[https://www.youtube.com/watch?v=6NAAuxWNhk4&feature=youtu.be][CppCon 2018: “Latest and Greatest in the Visual Studio Family for C++ Developers 2018” - YouTube]]
    + "This talk will be modeled on our previously successful talks at
      CppCon. We'll give the community an update on how we are doing
      in terms of conformance where we'll be announcing the final
      conformance state for MSVC for the final 2017 update. We'll be
      showing many many demos of new features (not in previous
      versions of this talk) that target cross platform developers in
      C++. This will include making it easier to bring your code to
      Visual Studio, significant improvements to ease of use for
      developers using CMake, improvements to unit testing
      experiences, a lot of new Linux targeting improvements, an
      update on our performance work, and new debugger features for
      C++ developers. Developers will learn new tricks they can apply
      immediately on leaving the session as well as get a sense of
      what is coming in future updates. The main message is that
      Visual Studio and Visual Studio Code will make every C++
      developer (not just Windows developers) more productive." 

  + Features:

    + Fredom to target any platform from a single ID:
      + ARM/mBed, Android, Cyngwin, iOS, Linux, UWP, Windows

    + CMake compatibility

    + The VC++ Compiler has full support for C++11/14/15 language features.

      + Process Snapshot - allows to introspect process memory.

      + Macro expansion - The editor, now can expand macros when the
        mouse is hoovered over some macro.

      + Completion for templates.

      + Live Sharing => Collaboration session. 

      + Multiple cursor editing, aka multi caret editing: hold CTRL +
        ALT and click at the points where the cursor will be placed
        and then type.

      + Peek definition.

      + Compiler flags:
        + /std:c++14 (default)
        + /std:c++17
        + /std:c++latest
        + /experimental:external  - Switch to isolate code from
          external headers.

      + C++ Core Check - https:/aka.ms/CppCoreCheck

    + Integratio with other building systems: Make, Ninja, NMake, ... 

    + Code editing experience:
      + IntelliSense => Smart Code Completion 
      + Refactoring
      + Debugging
      + Reverse Debugging
      + Debug Visualization

    + Integration with other compilers and tools:
      + Clang/LLVM, GCC, Clang-format, Google-test, Boost.Test

    + Recommended Package Manger: *Vcpakge* - cross platform package
      manager which works on Linux, MacOSX and Windows. There are over
      900 libraries available in that.

      + $ vcpackage install boost sdl zlib gtest
      + https://aka.ms/vcpkg 

    + Can compile and run code in remote machines and also perform
      remote debugging. 

    + One of the most valued and loved of feature of Visual Studio is
      the *debugger*.
      + The debugger can attach to process in current or remote
        machine through SSH.

    + *CMake target view* provides a CMake-centric experience showing
      all targets, files and configuration.

    + *Open folder experience:*
      + Optmized for non-MSBuild projects => any project using CMake,
        make or other C++ building system. Target Windows, MinGW,
        Cyngwin, Linux or mBed.
      + Easy to get started
        + devenv.exe <folder>
        + File => Open => Folder ... (Ctrl + Alt +Shift + O)

    + Linux Targeting:
      + Visual Studio can connect to any linux distribution with
        GDB or GdbServer. Remove VMs, Containers, IoT (RasberryPI, Beaglebone),
        Local Windows Subsystem for Linux distros and Cross-Compile.
*** Rapid Prototyping in C++ - Dmitri Nesteruk - Meeting C++ 2015

 - [[https://www.youtube.com/watch?v=Ncy4Y-k-vLA][Rapid Prototyping in C++ - Dmitri Nesteruk - Meeting C++ 2015 - YouTube]]
   * Description: Show several techniques for fast prototyping in C++.
   * Summary:
     + CERN's ROOT Framework or CLING C++ interpreter. Allows to play
       and evaluate C++ code in the same fashion Python interpreter does.
     + Wrap the C++ library with SWIG wrapper generator to generate a Python binding and
       then prototype in the Python REPL.
     + Use a more suitable tool with fast feedback for prototyping
       such as spreadsheet, R language, Python, Matlab, Octave and so
       on.
     + Runtime compiled C++.
*** CppCon 2018: Steven Simpson "Source Instrumentation for Monitoring C++ in Production" :tooling:instrumentation:

 + [[https://www.youtube.com/watch?v=0WgC5jnrRx8&feature=youtu.be][CppCon 2018: Steven Simpson “Source Instrumentation for Monitoring C++ in Production” - YouTube]]
   + "It is essential to discuss how modern C++ code can be
     effectively instrumented, in order to effectively monitor it
     after deployment. *This talk will focus on portable source*
     *instrumentation techniques such as logging, tracing and*
     *metrics*. Straightforward, but well designed code additions can
     drastically ease the troubleshooting of functional issues, and
     identification of performance bottlenecks, in production.  Of
     course when dealing with C++ performance is often critical, and
     so minimizing the cost of any instrumentation is also
     critical. Key to this is understanding the trade-off between the
     detail of information collected, and the overheads of exposing
     that information. It is also important to understand how best to
     benefit from advances in contemporary monitoring infrastructure,
     popularised by "cloud" environments.  This talk will open with a
     brief summary of monitoring goals, infrastructure, benefits, and
     existing practise. It will then detail practicalities of building
     a set of C++ source instrumentation primitives, based on proven
     principles employed in demanding production software."

 
   + Summary + Notes + Brainstorm:
     * Use a logging library with the following features.
       + Format string (or ostream)
       + Serverity levels, [INFO], [WARNING], [FAILURE], [CRITICAL], [TRACE] ...
       + Enable/disable at runtime
       + Logs files + rotation
       + Timestamp 
       + Remote Logging
       + OS Integration => Syslog on U*nix, or OutputDebugString on Windows.

     * Error messages and exception should have context about the
       problem such as the file where it happened, code line, what
       caused the exception and so on. 

     * Log Service infrastructure:
       + Should support search, indexing, sorting and filtering.
       + Structured Logging Format: json, csv, to avoid parsing and
         writing complicated regular expressions.
       + Logging Alert
       + Logging can be stored in cloud services. 

     * Logging X Tracing

       + A more detailed logging, showing the internals of some
         operation for debugging purposes. 

       + Example about tracing: Unix utility strace which log system
         calls perfomed by a program. $ strace -ttT cat hello.txt    

     * Downsides of logging:
       * Logging may, specially writing to IO, may cause performance
         overhead on performance critical code. This is why tracing
         logging in this type of code is often disabled on deployment
         builds.
       * Tracing can be implemented with C-preprocessor macros in
         order to allow disabling it on debug builds. Using
         preprocessor has also the advatange that, when the tracing is
         disabled, it will not inccur on any rutime overhead or
         performance cost, as string concatenation will not happen and
         the code will be discarded. 
  
     * Domains where logging is essential:
       * _Network Servers and Web Servers_. => Servers are long running
         programs which runs in background as daemons without any
         graphical user interface. So logging, is the only available
         information about what is going on with the sefver.
       * _Databases_ 
       * _Embedded Systems_ => Usually doesn't have keyboard, monitor
         and etc.
       * _Industrial Instrumentation_ => Temperature, pressure, speed, ... 

     * Closing:
       * By building observable software, the software can become its
         own debugger. 

     * *Techniques for Program Instrumentation* => My Ideas.
       * Logging with some logging library
       * Debug Build 
         * Debugging Symbols 
         * Assertions => Allows to check assumptions during the
           development. 
         * Tracing
       * Use a proper debugger such as GDB, WindBG, LLDB for
         instrospecting the process. 
       * Proper error messages with enough context information. 
       * Unit Tests or some automated testing.
       * System call logger such as strace.
       * Memory Leak Detector such as Valgrind.
       * Profiler => Mesure performance.
       * Compiler with non cryptic error messages like Clang++.
       * Enforce as much correctness as possible at compile-time in
         order to catch bugs earlier before runtime and deployment.
** High Performance Computing for Math 
*** CPPCON 2016: Klaus Iglberger "The Blaze High Performance Math Library"

 - [[https://www.youtube.com/watch?v=w-Y22KrMgFE][CppCon 2016: Klaus Iglberger “The Blaze High Performance Math Library" - YouTube]]
   - "In this presentation we introduce the Blaze C++ math library, a
     hot contender for the linear algebra performance throne. Blaze
     is an open-source, high-performance library for dense and sparse
     arithmetic. It combines elegance and ease of use with HPC-grade
     performance, making it one of the most intuitive and at the same
     time fastest C++ math libraries available. We demonstrate its
     basic linear algebra functionality by means of several BLAS
     level 1 to 3 operations and explain why Blaze outperforms even
     well established linear algebra libraries. Additionally, we
     present some advanced features that enable users to adapt Blaze
     to special circumstances: custom data structures, custom
     operations, and the customizable error reporting mechanism."

     - Note: Blaze library uses _Express Template_ technique for
       compile-time generation of high-performance linear algebra
       code. 
*** Statistical scientific programming OO patterns: accumulators - Olivia Quinet - Lightning Talks :math:science:
 
 + [[https://www.youtube.com/watch?v=IwvA7oExmSo][Statistical scientific programming OO patterns: accumulators - Olivia Quinet - Lightning Talks - YouTube]]
   + "Statistical scientific programming OO patterns: accumulators -
     Olivia Quinet - Lightning Talks Meeting C++ 2017"
     + Summary: Accumulators like Boost.Accumulators allows to compute
       several statistical properties of a set of values such as a
       time series avoiding errors such as _float pointing_
       _castastrophic cancellation_ and loss of precision. The Welford
       statistical formula is shown as a way to implement accumulators
       and how it can be used to compute standard deviation and other
       statistical properties. 
*** Algorithms and Iterators for Multidimensional Arrays - Cem Bassoy - Lightning Talks Meeting C++ 2017 :math:science:

  + [[https://www.youtube.com/watch?v=8P-sDH9XJAc][Algorithms and Iterators for Multidimensional Arrays - Cem Bassoy - Lightning Talks Meeting C++ 2017 - YouTube]]

Paper at:  [[https://arxiv.org/abs/1711.10912][1711.10912 - TLib: A Flexible C++ Tensor Framework for Numerical Tensor Calculus]]

Abstract:

#+BEGIN_QUOTE
Numerical tensor calculus comprise basic tensor operations such as the
entrywise addition and contraction of higher-order tensors. We
present, TLib, flexible tensor framework with generic tensor functions
and tensor classes that assists users to implement generic and
flexible tensor algorithms in C++. The number of dimensions, the
extents of the dimensions of the tensors and the contraction modes of
the tensor operations can be runtime variable. Our framework provides
tensor classes that simplify the management of multidimensional data
and utilization of tensor operations using object-oriented and generic
programming techniques. Additional stream classes help the user to
verify and compare of numerical results with MATLAB. Tensor operations
are implemented with generic tensor functions and in terms of
multidimensional iterator types only, decoupling data storage
representation and computation. The user can combine tensor functions
with different tensor types and extend the framework without further
modification of the classes or functions. We discuss the design and
implementation of the framework and demonstrate its usage with
examples that have been discussed in the literature.

#+END_QUOTE    
** C++ Binary Components + ABI + Reflection 
*** CPPCON 2016 - C++14 Reflections Without Macros, Markup nor External Tooling :reflection:metaprogramming:templates:

 + [[https://www.youtube.com/watch?v=abdeAew3gmQ][CppCon 2016: "C++14 Reflections Without Macros, Markup nor External Tooling.." - YouTube]]
   + "C++ was lacking the reflections feature for a long time. But a
     new metaprogramming trick was discovered recently: we can get
     some information about POD structure by probing it's braced
     initializes. Combining that trick with variadic templates,
     constexpr functions, implicit conversion operators, SFINAE,
     decltype and integral constants we can count structure's fields
     and even deduce type of each field.  Now the best part:
     everything works without any additional markup nor macros
     typically needed to implement reflections in C++.  In this talk
     I'll explain most of the tricks in detail, starting from a very
     basic implementation that is only capable of detecting fields
     count and ending up with a fully functional prototype capable of
     dealing with nested PODs, const/volatile qualified pointers,
     pointers-to-pointers and enum members. Highly useful use-cases
     will be shown a the end of the talk. You may start experimenting
     right now using the implementation at".
*** NDC Conference - Introduction to C++ Template Metaprogramming - Sasha Goldshtein :tmp:templates:

 + [[https://www.youtube.com/watch?v=lrziylOWBT4][Introduction to C++ Template Metaprogramming - Sasha Goldshtein]]
   + "technique in modern C++. First, TMP can be used as a precursor
     to C++17 Concepts, in order to check constraints and produce
     clear error messages when a template parameter doesn't adhere to
     its specified constraints. Second, TMP can be used to pick an
     algorithm implementation based on the template type provided --
     thus enabling optimizations for specific types. Finally, TMP can
     be used to introspect C++ types at compile-time and generate
     compile-time constructs that save time or enable
     fully-compile-time computation. In this talk, we will review a
     collection of techniques and examples for using TMP in your
     libraries and application code. You are expected to understand
     basic template syntax and template specialisation, and we will
     build the rest as we go along." 
*** CppCon 2018: Victor Ciura "These Aren't the COM Objects You're Looking For"

 + [[https://www.youtube.com/watch?v=T_1zutIBHs0][CppCon 2018: Victor Ciura “These Aren't the COM Objects You're Looking For” - YouTube]]
   + Description: "Windows COM is 25 years old. Yet it is relevant
     today more than ever, because Microsoft has bet its entire
     modern WinRT API on it (starting with Windows 8/10). But, if
     you’re familiar with the “old” COM with its idioms and SDK
     helper classes, you’re in for a treat. With the advent of modern
     C++ 17, using COM objects and new Windows APIs in your
     applications feels like a completely new experience. In this
     session, we’ll explore how using modern C++ features can
     radically transform the shape of your COM code. By eliminating a
     lot of boilerplate, your code will be much more readable and
     maintainable. Classic COM idioms around activation and
     QueryInterface() can feel totally different with modern C++
     helpers. A beautiful example of modern COM usage is C++/WinRT
     (now part of Windows SDK). This is a standard C++ language
     projection for the new Windows Runtime API.  COM memory
     management, data marshalling, string handling can all feel quite
     mechanical in nature and very error prone, so a little help from
     modern C++ facilities would be more than welcomed. Error
     handling and debugging can be cumbersome for COM like APIs;
     we’ll explore some tricks to improve this experience, as well."
*** BoostCon: John Bandela - Easy Binary Compatible C++ Interfaces Across Compilers
 
 + [[https://www.youtube.com/watch?v=BbbqBJ94-_E][John Bandela: Easy Binary Compatible C++ Interfaces Across Compilers - YouTube]]
   + Description: C++ is often perceived as hard to use and not as
     productive as other languages. One of the reasons for this is
     the lack of interoperability of binary components. When using a
     library, the user then either has to build from source (further
     complicated by the fact that there are multiple build systems)
     or the creator has to distribute multiple binaries. For example
     on Windows, one may have to distribute binaries for GCC Mingw,
     Visual C++ 2010 (release and debug, static and dynamic CRT),
     Visual C++ 2012, etc. There have been attempts to get around
     this problem. Options range from "extern C" functions, COM or
     XPCOM, or language extensions such as C++/CX. The above options
     either require compiler extensions or feel foreign and low-level
     to someone who is used to Modern C++. With C++11 being more
     consistently implemented across more compilers, one can take
     advantage of features such as lambdas and variadic templates to
     create easy to define, use, and implement binary interfaces that
     will work across compilers.
     + This presentation will discuss the design and implementation of
       a library that has the following benefits:
     + No external tools to run
       * Define an interface once and use the definition for both implementation and usage
       * Interfaces are easy to implement and use once defined
       * Use std::string, std::vector, and std::pair in the interface
       * Use real return types (not error codes)
       * Use exceptions both in implementation and usage
       * Binary compatible with COM
       * Supports interface inheritance
       * Supports implementation inheritance
       * Implementation tested on Windows with Visual C++ executable and GCC .dll
       * Implementation tested on Linux with GCC executable and Clang .so
*** BoostCon: John Bandela - CppComponents- A Modern Portable C++11 Component System

 + [[https://www.youtube.com/watch?v=a4iFJuNBx7U][CppComponents- A Modern Portable C++11 Component System - YouTube]]

*** CppCon 2017: Mathieu Ropert "API & ABI Versioning"

- [[https://www.youtube.com/watch?v=Ia3IDPjA-d0][CppCon 2017: Mathieu Ropert “API & ABI Versioning...” - YouTube]]
  - "Software keeps changing, but not always as fast as its
    clients. A key to maintaining a library in the long run is to
    ensure a proper versioning of the API and ABI. Not only does this
    gives a clear picture of both source and binary compatibility
    between the versions, but it also helps design by making breaking
    changes explicit to the developer.  In this talk I will define
    API and ABI in terms of impacts on compatibility, explain the
    difference between breaking and non-breaking changes and present
    a few techniques to handle them.  We will quickly explain what
    APIs are, with an emphasis on the notion of contracts. Then the
    usually lesser known notion of ABI will be explained, going over
    the concepts of call syntax, mangling and most importantly sizes,
    alignment and offsets in data structures. We will see how to use
    semantic versioning (semver) in C++ by considering not only
    changes to the API but also to the ABI and offer some advice on
    how to change API and ABI over time and how to minimize the
    impacts."
