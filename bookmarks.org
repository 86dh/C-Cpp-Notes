#+TITLE: CPP / C++ Review
#+DESCRIPTION: cpp c++ code examples, demonstrations, design pattern and integration.
#+STARTUP: content 
#+AUTHOR: Caio Rodrigues 

* Bookmarks 
** Online Tools

 + https://demangler.com/
   * Symbol demancler for MSVC and GCC.

 + https://wandbox.org/
   * Online C++ compiler.

 + https://godbolt.org/
   * Compiler explorer - allows to explore the assembly generated by a
     wide variety of compilers, including, GNU GCC, Clang, MSVC and so on. 

** Selected Conference Videos 
*** Bjarne Stroustrup - The Essence of C++

- [[https://www.youtube.com/watch?v=86xWVb4XIyE][Bjarne Stroustrup - The Essence of C++]]
  - "Bjarne Stroustrup, creator and developer of C++, delivers his
    talk entitled, The Essence of C++. Stroustrup has held
    distinguished posts at Texas A&M University and spent significant
    time in the Computer Science Departments of Cambridge, Columbia
    and Princeton. C++ is the one of the world's most widely used
    technology languages and it has influenced newer languages such
    as C# and Java as well as older languages."
    + Applications on System Programming Domains:
      - Device drivers
      - Network drivers
      - Embedded Systems
      - Suitable for hard and soft real time systems.
    + C++ Origin: C + Simula (First Object Oriented language)
    + Main Ideas:
      - Direct map to hardware
      - Zero-overhead abstraction
      - Much of inspiration comes from operating systems.
      - Backward compatibility: Avoid breaking old code.
    + Key strengths:
      + A language for building lightweight abstractions.
      + Software infrastructure.
      + Resource-constrained application. (May be embedded systems)
      + Resource Management

*** CPPCON-2017 Klaus Iglberger - Free Your Functions

+ [[https://www.youtube.com/watch?v=WLDT1lDOsb4][CppCon 2017: Klaus Iglberger "Free Your Functions!"]]
  * Description: "You are devoted to minimize coupling and
    duplication? You are taking care to maximize cohesion,
    flexibility, extensibility, encapsulation, testability, and even
    performance in order to achieve the high goals of
    (object-oriented) programming? Awesome!  But wait: You still
    favor member functions? Seriously? You have been deceived! You
    have been praying at the altar of false promises! Shed the
    shackles of Java philosophy! Free your functions!. In this talk I
    will demonstrate why in C++ free functions should generally be
    preferred to member functions, and why free functions — not
    member functions! — provide you with all the aforementioned
    advantages you expect from object-oriented programming. Note,
    though, that this talk might fundamentally change your perception
    of C++ and object-oriented programming in general!"

  * _Summary and notes_:
    * _Free functions_ (ordinary functions or non-virtual functions)
      abides to object oriented principles such as OCP (Open-Close
      Principle) as they can extend a class without requiring
      modification or recompilation of the class source code.
    * _Static polymorphism_ which is a combination of free functions
      and _template metaprogramming_ can make the code more loosely
      coupled and more perfomant.
      * Becomes more loosely coupled because it doesn't require that
        arguments have any common base class or class hierarchy.
      * Becomes more performant as template generates overloaded code
        for each different type parameters combination what
        eliminates virtual function calls and dynamic
        polymorphism. The disadvantage of templates are the higher
        complexity and larger code size.
    * Benefits of Free Functions:
      - Encapsulation
      - Cohesion (SRP - Single Responsibility Principle)
      - Reuse (DRY - DO NOT REPEAT YOURSELF)
      - Overloading (Polymorphism )
      - Generic Programming (Aka template metaprogramming)
      - Abstraction
      - Testability
      - _Performance_ (Raison d'être of C++).

    * Free Functions on standard library:
      - std::begin, std::cbegin ...

    * Use free functions in order to:
      * ... wrap virtual function calls
      * ... get an homogeneous interface.
      * ... get more performant code.
      * ... more flexible and loosely-coupled code.

    * Free functions aren't are multi-paradigm, they can work with
      any paradigm. It is not necessarly functional programming. 

    * Potential Problems
      * C++ doens't have a convenient syntax for function application
        as ML-based languages like Haskell and OCaml. So, multiple
        function applications would be written as f1(f2(f3(f5 ... fn(x))))

      * _Discoverability_: according to the presentation, IDE's may not
        help to find them easily as they help to find methods (aka
        member functions). However it can mitigated with careful
        selection of namespaces which would improve code complexion
        and discoverability.
*** CPPCON 2016: Klaus Iglberger "The Blaze High Performance Math Library"

 - [[https://www.youtube.com/watch?v=w-Y22KrMgFE][CppCon 2016: Klaus Iglberger “The Blaze High Performance Math Library" - YouTube]]
   - "In this presentation we introduce the Blaze C++ math library, a
     hot contender for the linear algebra performance throne. Blaze
     is an open-source, high-performance library for dense and sparse
     arithmetic. It combines elegance and ease of use with HPC-grade
     performance, making it one of the most intuitive and at the same
     time fastest C++ math libraries available. We demonstrate its
     basic linear algebra functionality by means of several BLAS
     level 1 to 3 operations and explain why Blaze outperforms even
     well established linear algebra libraries. Additionally, we
     present some advanced features that enable users to adapt Blaze
     to special circumstances: custom data structures, custom
     operations, and the customizable error reporting mechanism."

     - Note: Blaze library uses _Express Template_ technique for
       compile-time generation of high-performance linear algebra
       code. 
*** CppCon 2017: Mathieu Ropert "API & ABI Versioning"

- [[https://www.youtube.com/watch?v=Ia3IDPjA-d0][CppCon 2017: Mathieu Ropert “API & ABI Versioning...” - YouTube]]
  - "Software keeps changing, but not always as fast as its
    clients. A key to maintaining a library in the long run is to
    ensure a proper versioning of the API and ABI. Not only does this
    gives a clear picture of both source and binary compatibility
    between the versions, but it also helps design by making breaking
    changes explicit to the developer.  In this talk I will define
    API and ABI in terms of impacts on compatibility, explain the
    difference between breaking and non-breaking changes and present
    a few techniques to handle them.  We will quickly explain what
    APIs are, with an emphasis on the notion of contracts. Then the
    usually lesser known notion of ABI will be explained, going over
    the concepts of call syntax, mangling and most importantly sizes,
    alignment and offsets in data structures. We will see how to use
    semantic versioning (semver) in C++ by considering not only
    changes to the API but also to the ABI and offer some advice on
    how to change API and ABI over time and how to minimize the
    impacts."

*** LVM Euro Conference 2013 - The Clang AST - a Tutorial

+ [[https://www.youtube.com/watch?v=VqCkCDFLSsc][The Clang AST - a Tutorial - YouTube]]
  + "If you always wanted to know more about about Clang's AST [1],
    for example because you want to implement an awesome tool [2, 3]
    based on Clang, or simply because you want to start contributing,
    this talk is for you."
  + Note: Clang + LLVM suite provides many services that can be used
    to build code automation tools for C++ such as code generators
    and reflection metadata code generator.
*** C++Now 2018: Louis Dionne "Runtime Polymorphism: Back to the Basics"

- [[https://www.youtube.com/watch?v=OtU51Ytfe04][C++Now 2018: Louis Dionne “Runtime Polymorphism: Back to the Basics” - YouTube]]
  + Description: "C++ solves the problem of runtime polymorphism in a very
    specific way. It does so through inheritance, by having all
    classes that will be used polymorphically inherit from the same
    base class, and then using a table of function pointers (the
    virtual table) to perform dynamic dispatch when a method is
    called. Polymorphic objects are then accessed through pointers to
    their base class, which encourages storing objects on the heap
    and accessing them via pointers. This is both inconvenient and
    inefficient when compared to traditional value semantics. As Sean
    Parent said: Inheritance is the base class of evil. It turns out
    that this is only one of many possible designs, each of which has
    different tradeoffs and characteristics. This talk will explore
    the design space for runtime polymorphism in C++, and in
    particular will introduce a policy-based approach to solving the
    problem. We will see how this approach enables runtime
    polymorphism with stack-allocated storage, heap-allocated
    storage, shared storage, no storage at all (reference semantics),
    and more. We will also see how we can get fine-grained control
    over the dispatch mechanism to beat the performance of classic
    virtual tables in some cases. The examples will be based on a
    real implementation in the Dyno library [1], but the principles
    are independent from the library."

    + Problem: C++ sub-typing polymorphism inevitably requires
      pointers to objects allocated on the heap. However by using
      pointers, the advantages of value semantics, which C++ is built
      on top, are lost. For instance, pointers doesn't play well with
      C++ algorithms and functions expecting value or reference
      parameters. Another issue is that pointers to objects allocated
      on the heap raises questions about memory ownership such as who
      should delete the pointer.

      + Ideas => some possible approaches:
        + Use static polymorphism: _template functions._
        + Use a _proxy object allocated on the stack._ The object
          inherits the base class and takes a pointer to base class
          as argument. Then the proxy object can forward any method
          call or message to the wrapped heap object.
        + Deal with it and accept as it is for performance reasons.
*** CppCon 2017: Michael Spencer "My Little Object File: How Linkers Implement C++"

 - [[https://www.youtube.com/watch?v=a5L66zguFe4][CppCon 2017: Michael Spencer “My Little Object File: How Linkers Implement C++” - YouTube]]
   - "Ever wonder how the linker turns your compiled C++ code into an
     executable file? Why the One Definition Rule exists? Or why your
     debug builds are so large? In this talk we'll take a deep dive
     and follow the story of our three adventurers, ELF, MachO, and
     COFF as they make their way out of Objectville carrying C++
     translation units on their backs as they venture to become
     executables. We'll see as they make their way through the tangled
     forests of name mangling, climb the cliffs of thread local
     storage, and wade through the bogs of debug info. We'll see how
     they mostly follow the same path, but each approach the journey
     in their own way.  We'll also see that becoming an executable is
     not quite the end of their journey, as the dynamic linker awaits
     to bring them to yet a higher plane of existence as complete C++
     programs running on a machine."

