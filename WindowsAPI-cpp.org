#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ Notes - Windows API Programming Win32
#+DESCRIPTION: cpp/c++ code examples and demonstrations.
#+STARTUP: content 

* Windows API Programming Win32
** Idiosincrasies
 
  + Hungarian Notation
  + Non standard types:
    + LPSTRING, WORD, DWORD, BOOL, LPVOID ... 
  + Different Calling Conventions in the same OS: 
    + ~__stdcall~
    + ~__cdecl~
    + ~__fastcall~
  + Characters
    + 16-bits Unicode wide characters (wchar) instead of 8 bits
      Unicode UTF-8 which is common in most modern Unix-like Oses such
      as Linux, BSD and MacOSX.
  + Many string types
  + Many C-runtimes and entry points.
  + Functions has many parameters which makes them pretty complex. The
    only way to understand the API is to compile and run small
    specific examples.
  + Not all system calls are documented like open source OSes such as
    Linux or BSD. 


** Windows API Main Header Files

Most used headers: 

 + #include <windows.h>
 + #include <wchar.h> - Wide Characters - UTF16 chars 
 + #include <tchar.h>
 + #include <global.h>
 + #include <nsfbd.h>

Other useful header files: 

 + windows.h
   + Basic header file of Windows API
 + WinError.h
   + Error codes and strings
 + tchar.h
   + Provides the macro _T(...) and TEXT(...) for Unicode/ANSI string
     encoding handling.
 + wchar.h
   + Wide Character - UTF16 or wchar
 + global.h
 + ntfsb.h 
 + Winsock2.h
   + Network sockets 
 + Winbase.h
   + Windows types definitions
 + WinUser.h
   + Windows Messages
 + ShellAPI.h
   + Shell API
 + ShFolder.h
   + Folder definitions
 + Commdlg.h
   + Commom Controls (COM based)
 + Dlgs.h
   + Dialog definitions
 + IUnknown.h
   + COM header
 + conio.h
   + Console Input/Output functions - it is heritage grom MSDOS.

** Windows API Runtime Libraries

 + kernel32.dll
   + Low level NTDLL wrappers. 
 + user32.dll
   + User interface primitives used by graphical programs with menus,
     toolboxes, prompts, windows ..
 + shell.dll
   + 
 + gdi32.dll
   + Basic drawing primitives.
 + ole32.dll
 + MSVCRT.DLL
   + Implementation of the C standard library stdlib.
 + advapi.dll
   + Contains functions for system-related tasks such as registry and
     registry handling.
 + ~WS_32.DLL~
   + Winsock2 library contains a socket implementation.
 + Ntdll.dll
   + Interface to Kernel. Not used by Windows programs directly.
 + Wininet.dll
   + Provides high level network APIs, for instance, HttpOpenRequest,
     FtpGetFile ...
** WinAPI C Data Types 
*** General Terminology

 + _Handle_ - Is a unsigned integer number assigned to processes,
   windows, buttons, resources and etc. Actually, it is an opaque
   pointer to some system data structure (Kernel Object), similar to
   Unix's file descriptor pointer. The purpose of using handles or
   opaque pointer is to hide the implementation of those data
   structures allowing implementators to change their inner working
   without disrupting application developers. This approach gives a
   pseudo object-oriented interface to the Windows API. See also:

   + _Note_: A handle can be an _obfuscated pointer_ exposed as an
     integer, void pointer void* (also opaque pointer) or ordinary
     opaque pointer (pointer to a C-struct or class which
     implementation is not exposed). 

 + _Types of Kernel Objects_ (Handle is a numeric value related to the
   pointer to kernel object C-struct). The name "object" comes from
   the idea that it is possible to access the kernel data structure
   pointer by the handle using the Win32 API functions. It works in a
   similar way to classical object oriented programming where the data
   structure and internal representation can only be accessed by the
   class methodos. 
   + Symbolic Link
   + Process
     + A running program, executable. A process has its own address
       space, data, stack and heap.
   + Job
     + Group of processes managed as group. 
   + File
     + Open file or I/O device.
   + Token
     + Security token used by many Win32 functions.
   + Event
     + Synchronization object used for notification.
   + Threads
     + Smallest unit of execution within a process. 
   + Semaphore
   + Mutex
   + Timer
     + Object which provides notification after a certain period is
       elapsed.

References:

  + [[https://en.wikipedia.org/wiki/Opaque_pointer][Opaque pointer - Wikipedia]] - Note: Opaque pointer is also called
    "handle classes", "pimpl idiom", "Compiler-firewall", "d-pointer" in C++.
  + [[https://en.wikipedia.org/wiki/Handle_(computing)][Handle (computing) - Wikipedia]]
  + [[https://stackoverflow.com/questions/2334966/win32-application-arent-so-object-oriented-and-why-there-are-so-many-pointers][c++ - win32 application aren't so object oriented and why there are so many pointers? - Stack Overflow]]
  + [[https://dmitryfrank.com/articles/oop_in_c][Object-oriented techniques in C Dmitry Frank]]
  + [[https://lwn.net/Articles/444910/][Object-oriented design patterns in the kernel, part 1 ]]
*** Hungarian Notation 

|      |              |
|------+--------------|
| n    | short int    |
| H    | Handle       |
| p    | Pointer      |
| fn   | Function     |
| lpsz | Long Pointer |
| LP   | Long Pointer |
|      |              |
*** Common Data Types

| Data Type       | Definition                                  | Description                                                                      |
|-----------------+---------------------------------------------+----------------------------------------------------------------------------------|
| BOOL            | typedef int BOOL                            | Boolean variable true (non zero) or false (zero or 0)                            |
| BYTE            | typedef unsigned char BYTE                  | A byte, 8 bits.                                                                  |
| CCHAR           | typedef char CHAR                           | An 8-bit Windows (ANSI) character.                                               |
|                 |                                             |                                                                                  |
| DWORD           | typedef unsigned long DWORD                 | A 32-bit unsigned integer. The range is 0 through 4294967295 decimal.            |
| DWORDLONG       | typedef unsigned __int64 DWORDLONG          | 64 bits usigned int.                                                             |
| DWORD32         | typedef unsigned int DWORD32                | A 32-bit unsigned integer.                                                       |
| DWORD64         | typedef unsigned __int64 DWORD64            | A 64-bit unsigned integer.                                                       |
|                 |                                             |                                                                                  |
|                 |                                             |                                                                                  |
| FLOAT           | typedef float FLOAT                         | A floating-point variable.                                                       |
|                 |                                             |                                                                                  |
| INT8            | typedef signed char INT8                    | An 8-bit signed integer.                                                         |
| INT16           | typedef signed short INT16                  | A 16-bit signed integer.                                                         |
| INT32           | typedef signed int INT32                    | A 32-bit signed integer. The range is -2147483648 through 2147483647 decimal.    |
| INT64           | typedef signed __int64 INT64                | A 64-bit signed integer.                                                         |
|                 |                                             |                                                                                  |
|                 |                                             |                                                                                  |
| LPBOOL          | typedef BOOL far *LPBOOL;                   | A pointer to a BOOL.                                                             |
| LPBYTE          | typedef BYTE far *LPBYTE                    | A pointer to a BYTE.                                                             |
| LPCSTR, PCSTR   | typedef __nullterminated CONST CHAR *LPCSTR | pointer to a constant null-terminated string of 8-bit Windows (ANSI) characters. |
| LPCVOID         | typedef CONST void *LPCVOID;                | A pointer to a constant of any type.                                             |
| LPCWSTR, PCWSTR | typedef CONST WCHAR *LPCWSTR;               | A pointer to a constant null-terminated string of 16-bit Unicode characters.     |
| LPDWORD         | typedef DWORD *LPDWORD                      | A pointer to a DWORD.                                                            |
| LPSTR           | typedef CHAR *LPSTR;                        | A pointer to a null-terminated string of 8-bit Windows (ANSI) characters.        |
| LPTSTR          |                                             | An LPWSTR if UNICODE is defined, an LPSTR otherwise.                             |
| LPWSTR          | typedef WCHAR *LPWSTR;                      | A pointer to a null-terminated string of 16-bit Unicode characters.              |
| PCHAR           | typedef CHAR *PCHAR;                        | A pointer to a CHAR.                                                             |
|                 |                                             |                                                                                  |
| CHAR            | ANSI Char or char                           |                                                                                  |
| WCHAR           | Wide character 16 bits UTF16                |                                                                                  |
| TCHAR           | -                                           | A WCHAR if UNICODE is defined, a CHAR otherwise.                                 |
| UCHAR           | typedef unsigned char UCHAR;                | An unsigned CHAR.                                                                |
|                 |                                             |                                                                                  |
| WPARAM          | typedef UINT_PTR WPARAM;                    | A message parameter.                                                             |
|                 |                                             |                                                                                  |
|                 |                                             |                                                                                  |
*** Other data types

|           |                                                    |
|-----------+----------------------------------------------------|
|           |                                                    |
| HANDLE    | 32 bits integer used as a handle                   |
| HDC       | Handle to device context                           |
| HWND      | 32-bit unsigned integer used as handle to a window |
| LONG      |                                                    |
| LPARAM    |                                                    |
| LPSTR     |                                                    |
| LPVOID    | Generic pointer similar to void*                   |
| LRESULT   |                                                    |
| UINT      | Unsigned integer                                   |
| WCHAR     | 16-bit Unicode character or Wide-Character         |
| WPARAM    |                                                    |
| HINSTANCE |                                                    |



*** References 

General:

 + [[https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx][Windows Data Types (Windows)]]

 + [[https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx][Windows Data Types for Strings (Windows)]]

Windows Programming:

 + [[http://www.tenouk.com/ModuleC.html][The Windows OS Win32 programming tutorial: notes, references and C/Win32 program examples on data type, system error, notation, handles and objects]]

 + [[https://scs.senecac.on.ca/~chris.szalwinski/archives/gam666.073/content/windo.html][Seneca | Computer Studies | Introduction to Game Programming]]

 + [[https://www.codeproject.com/Articles/3004/The-Complete-Guide-to-C-Strings-Part-II-String-Wra][The Complete Guide to C++ Strings, Part II - String Wrapper Classes - CodeProject]]

** SAL - Source Code Annotation Language 

Annotation such as ~__In__~ or ~__Out__~ commonly found on Windows API
documetation, as shown in the code below, is called _SAL - Source Code_
_Annotation language_. In a C code, it is hard to figure out which
parameters are used to return values or are read-only used only as
input. The SAL solves this problem by declaring which function
parameters are input, read-only and which parameters are output.

#+BEGIN_QUOTE
  SAL is the Microsoft source code annotation language.  By using source
  code annotations, you can make the intent behind your code
  explicit. These annotations also enable automated static analysis
  tools to analyze your code more accurately, with significantly fewer
  false positives and false negatives.
#+END_QUOTE

 -- http://msdn.microsoft.com/en-us/library/hh916383.aspx

#+BEGIN_SRC cpp 
   HANDLE CreateRemoteThreadEx(
     __in__ HANDLE                       hProcess,
     __in__ LPSECURITY_ATTRIBUTES        lpThreadAttributes,
     __in__ SIZE_T                       dwStackSize,
     __in__ LPTHREAD_START_ROUTINE       lpStartAddress,
     __in__ LPVOID                       lpParameter,
     __in__ DWORD                        dwCreationFlags,
     __in__ LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
     __out__ LPDWORD                     lpThreadId
   );

   DWORD WINAPI FormatMessage(
      _In_     DWORD dwFlags,
      _In_opt_ LPCVOID lpSource,
      _In_     DWORD dwMessageId,
      _In_     DWORD dwLanguageId,
      _Out_    LPTSTR lpBuffer,
      _In_     DWORD nSize,
      _In_opt_ va_list *Arguments
   );

#+END_SRC

To allow those annotations in the source code, it is necessary to add
the header _#include <sal.h>_. This SAL annotation is not standard among
C++ compilers and is not defined by any C or C++ standard, as a
result, the annotations only works on MSVC - Microsoft Visual C++
Compiler. This feature can be implemented in a portable way with
macros.

SAL Fundamentals: 

| SAL Annotatio | Description                                                                                |
|---------------+--------------------------------------------------------------------------------------------|
| ~_In_~          | Input parameter - read only argument no modified inside the by the function.               |
|               | Generally has the const qualifier such as const char*.                                     |
| ~_In_Out_~      | Optional input parameter, can be ignored by passing a null pointer.                        |
|               |                                                                                            |
| ~_Out_~         | Output paramenter - Argument is written by the called function. It is generally a pointer. |
|               |                                                                                            |
| ~_Out_opt_~     | Optional output parameter. Can be ignored by setting it to null pointer.                   |
|               |                                                                                            |
| ~_Inout_~       | Data is passed to the function and pontentially modified.                                  |
|               |                                                                                            |
| ~_Outptr_~      | Output to caller. The value returned by written to the parameter is pointer.               |
|               |                                                                                            |
| ~_Outptr_opt_~  | Optional output pointer to caller, can be ignored by passing NULL pointer.                 |
|               |                                                                                            |

Note: if the parameter is not annotated with ~_opt_~ the caller is not
supposed to pass a NULL pointer, otherwise the parameter must be
annotated with ~_In_opt_~, ~_Out_opt_~ and etc.

Usage example: 

 - This annotation enhances the readability by telling reader which
   parameters are input and which parameters are output or used for
   returning values.

File: sal1.cpp 

#+BEGIN_SRC cpp
  #include <sal.h>     // Microsft's Source Code Annotation Language 
  #include <iostream>

  // Computes elementwise product of two vectors 
  void vector_element_product(
        _In_ size_t size,
        _In_ const double xs[],
        _In_ const double ys[],
        _Out_      double zs[]
        ){
        for(int i = 0; i < size; i++){
            zs[i] = xs[i] * ys[i];
        }
  }

  void showArray(size_t size, double xs[]){
    std::cout << "(" << size << ")[ ";
    for(int i = 0; i < size; i++){
      std::cout << xs[i] << " ";
    }
    std::cout << "] ";
  }

  int main(){
    double xs [] = {4, 5, 6, 10};
    double ys [] = {4, 10, 5, 25};
    double zs [4];
    vector_element_product(4, xs, ys, zs);
    std::cout << "xs = "; showArray(4, xs); std::cout << "\n";
    std::cout << "ys = "; showArray(4, ys); std::cout << "\n";
    std::cout << "zs = "; showArray(4, zs); std::cout << "\n";
    
  }
#+END_SRC

Compiling: 

 - MSVC (CL.EXE):

#+BEGIN_SRC sh 
   $ cl.exe sal1.cpp /nologo /Fe:sal1-a.exe && sal1-a.exe
   sal1.cpp
   C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.12.25827\include\xlocale(313): warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc
   xs = (4)[ 4 5 6 10 ]
   ys = (4)[ 4 10 5 25 ]
   zs = (4)[ 16 50 30 250 ]
#+END_SRC

 - Mingw/G++

#+BEGIN_SRC sh
   $ g++ sal1.cpp -o sal1-b.exe -std=c++11 && sal1-b.exe
   xs = (4)[ 4 5 6 10 ]
   ys = (4)[ 4 10 5 25 ]
   zs = (4)[ 16 50 30 250 ]
#+END_SRC


Note: It doesn't work on Linux or other OSes. But it can be
implemented with header files.

 *Open Source SAL Implementation:*

 + Source-code annotation language (SAL) compatibility header -
   <https://github.com/nemequ/salieri> 

   + "Salieri is a header which provides definitions for Microsoft's
     source-code annotation language (SAL). Simply drop the header
     into your code and use it instead of including <sal.h> directly,
     and you can use SAL annotations even if you want your program to
     be portable to compilers which don't support it."

   + "SAL provides lots of annotations you can use to describe the
     behavior of your program. There is a Best Practices and Examples
     (SAL) page on MSDN if you want to get a very quick idea of how it
     works, but the basic idea is that you end up with something like
     this:" 

 *References:*

  + [[https://docs.microsoft.com/en-us/visualstudio/code-quality/understanding-sal][Understanding SAL - Visual Studio | Microsoft Docs]]
  + [[https://msdn.microsoft.com/en-us/library/hh916382.aspx][Annotating Function Parameters and Return Values]]
  + [[https://msdn.microsoft.com/en-us/library/ms182032.aspx?f=255&MSPPError=-2147217396][Using SAL Annotations to Reduce C-C++ Code Defects]]
  + [[https://msdn.microsoft.com/en-us/library/jj159525.aspx][Best Practices and Examples (SAL)]]
  + [[https://stackoverflow.com/questions/11457328/what-is-in-in-c][What is _In_ in C++? - Stack Overflow]]
  + [[https://ariccio.com/2015/04/02/preventing-bugs-and-improving-code-quality-with-microsoft-sal-part-2-custom-preconditions-for-structs-objects/][Preventing bugs, and improving code quality with Microsoft SAL (Part 2, custom preconditions for structs & objects) | Alexander Riccio]]
  + SQLite Source Code Annotated with SAL -
    https://github.com/ariccio/SQLite-Test-SAL and [[https://ariccio.com/2015/05/10/using-sal-in-the-sqlite-api/][Using SAL in the SQLite API | Alexander Riccio]]
  + [[https://www.osr.com/blog/2015/02/23/sal-annotations-dont-hate-im-beautiful/][SAL Annotations: Don’t Hate Me Because I’m Beautiful – OSR]]

** Character Encoding in WinAPI - ANSI x utf8 x utf16 (wchar_t)
*** Overview 

Unlike Linux, MacOSX and BSD where the API supports unicode UTF-8,
the Windows API only supports ANSI enconding (char) and UTF16 or
Unicode with 2 bytes per character _wchar_t_. 

 *Macros and types for enconding portability*

The following macros are widely used by Windows API for portability
between ANSI and Unicode: 

 + Strings:
   + [[http://www.cplusplus.com/reference/string/][<std::string>]] (UTF8 enconding) - Ordinary string (aka multi-byte string) 

   + [[http://www.cplusplus.com/reference/string/wstring/][std::wstring]] (UTF-16 enconding) - Wide string - string defined as
     array of wide characters wchar_t.

 + _TCHAR_ (Header: <tchar.h>) - When the _UNICODE_ is defined TCHAR
   becomes wchar_t, otherwise, it becomes char.

#+BEGIN_SRC cpp 
  #ifdef _UNICODE
    typedef wchar_t TCHAR;
  #else
    typedef char TCHAR;
  #endif
#+END_SRC

 + String Literal *_T* or TEXT macro. 

#+BEGIN_SRC cpp 
  #ifdef _UNICODE 
     #define _T(str)   L##str
     #define TEXT(c)   L##str
  #else 
     #define _T(str)     str 
     #define TEXT(str)   str
  #endif
#+END_SRC

 + Character array type definition: 

| Type    | Definition     |   |
|---------+----------------+---|
| LPSTR   | char*          |   |
| LPCSTR  | const char*    |   |
|         |                |   |
| LPWSTR  | wchar_t*       |   |
| LPCWSTR | const wchar_t* |   |
|         |                |   |
| LPTSTR  | TCHAR*         |   |
| LPCTSTR | const TCHAR*   |   |
|         |                |   |

 *String Literals*

 + _Utf-8 string literal_ (narrow characters or multibyte string) -
   cannot be used with Windows APIs as they will interpret those
   string literals as ANSI, thus not all characters will be
   represented.

#+BEGIN_SRC cpp 
  "UTF8 - Unicode 8 bits multi-byte literal";
  // Note: It doesn't work with Windows APIs (Windows specific functions)
  char utf8_text [] = "Random text in Chinese script (UTF8): 读写汉字1";
#+END_SRC

 + _Utf-16 string literal_ (wide characters - wchar_t). Windows Unicode
   APIs or functions only works with wide characters (wchar_t).

#+BEGIN_SRC cpp   
  L"UTF16 Wchar wide chracters literal";
  wchar_t utf16_text [] = L"Random text in Chinese script (UTF16): 读写汉字1";
#+END_SRC

 + String prefixed with _T or TEXT. If Unicode is defined the string
   literal becomes an unicode UTF16 string literal and prefix 'L' is
   added to the string, otherwise nothing happens.

#+BEGIN_SRC cpp 
  TCHAR text [] = _T("Random text in Chinese script  读写汉字1");
  // OR 
  TCHAR text [] = TEXT("Random text in Chinese script  读写汉字1");
#+END_SRC

If _UNICODE_ is not defined, it becomes: 

#+BEGIN_SRC cpp 
  char text [] = "Random text in Chinese script 读写汉字1";
#+END_SRC

If Unicode is defined, it becomes: 

#+BEGIN_SRC cpp
  wchar_t text [] = L"Random text in Chinese script 读写汉字1";
#+END_SRC

 *Windows APIs - ANSI X Unicode version*

Almost every function in Windows API such as [[https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createdirectorya][CreateDirectory]] has an
ANSI and Unicode UTF16 (with wide chars wchar_t) version. The ANSI
version of CreateDirectory API is [[https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createdirectorya][CreateDirectoryA]] (suffix A) and the
unicode version is [[https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createdirectoryw][CreateDirectoryW]]. The API _CreateDirectory_ is
expanded to CreateDirectoryW if #define UNICODE preprocessor flag is
not defined, otherwise it is expanded to CreateDirectoryA. 

 + ANSI Version: 

#+BEGIN_SRC cpp 
  BOOL CreateDirectoryA(
    LPCSTR /* const char */  lpPathName,
    LPSECURITY_ATTRIBUTES    lpSecurityAttributes
  );
#+END_SRC

 + Unicode Version: 

#+BEGIN_SRC cpp 
  BOOL CreateDirectoryW(
    LPCWSTR /* const wchar_t*  */  lpPathName,   
    LPSECURITY_ATTRIBUTES          lpSecurityAttributes
  );
#+END_SRC

*** Example - ANSI X Unicode and Windows API 

Complete File:
 + [[file:src/windows/winapi-enconding1.cpp][file:src/windows/winapi-enconding1.cpp]] 

Compiling with GCC: 

#+BEGIN_SRC sh 
 # Build 
 $ g++ winapi-encoding1.cpp -o out-gcc.exe -std=c++14  
 # Compile 
 $ out-gcc.exe 
#+END_SRC

Compiling with MSVC:
 + Note: If there is any unicode literal in the source, such as some
   text in Chinese or Hidi script, it is necessary to compile with the
   options (/source-charset:utf-8 /execution-charset:utf-8), otherwise
   the 

#+BEGIN_SRC sh 
 # Build 
 $ cl.exe winapi-encoding1.cpp user32.lib /EHsc /Zi /nologo /source-charset:utf-8 /execution-charset:utf-8 \
    /Fe:out-msvc.exe 
 # Run 
 $ out-msvc.exe 
#+END_SRC


Headers: 

 + To enable the expansion to unicode versions of WinAPIs, the flags
   UNICODE and ~_UNICODE~ must be enabled. For instance, if those flags
   are enabled CreateDirectory is expanded to CreateDirectoryW and TCHAR
   is expanded to wchar_t. Otherwise, CreateDirectory is expanded to
   CreateDirectoryA and TCHAR to char.

 + Note: The unicode flags must be defined before any windows specific
   header such as <windows.h> or <tchar.h>.

#+BEGIN_SRC cpp 
  #include <fstream> 
  #include <string>
  #include <sstream>

  // Enable Unicode version of Windows API compile with -DWITH_UNICODE 
  #ifdef WITH_UNICODE
    #define UNICODE
    #define _UNICODE
  #endif 

  #include <windows.h>
  #include <tchar.h>
#+END_SRC

 *Experiment 1* - Print to console: 

#+BEGIN_SRC cpp 
  // ===========> EXPERIMENT 1 - Print to Console ============//	
  std::cout << "\n ===>>> EXPERIMENT 1: Print to terminal [ANSI/UTF8] <<<=== " << std::endl;
  {
     std::cout  <<  " [COUT] Some text example - указан - 读写汉字1 " << "\n";
     std::wcout << L" [WCOUT] Some text example - указан - 读写汉字1 " << L"\n";	
  }
#+END_SRC

Output: 

 + This piece of code fails because the Windows' console (cmd.exe)
   cannot print unicode text by default. It needs to be configured
   before printing unicode, otherwise it will print garbage.

#+BEGIN_SRC text 
 ===>>> EXPERIMENT 1: Print to terminal [ANSI/UTF8] <<<
 [COUT] Some text example - ╤â╨║╨░╨╖╨░╨╜ - Φ»╗σåÖµ▒ëσ¡ù
 [WCOUT] Some text example -
#+END_SRC

 *Experiment 2* - Print to File

#+BEGIN_SRC cpp 
   // ===========> EXPERIMENT 2 - Print to File ============//
   std::cout << "\n ===>>> EXPERIMENT 2: Write non ANSI Chars to File <<<=== " << "\n";
   std::stringstream ss;
   ss << " Text in Cyrllic Script: Если указан параметр  " << "\n"
      << " Text in Chinese Script: 读写汉字1 " << "\n"
      << "\n";

   auto dfile = std::ofstream("logging.txt");
   dfile << ss.str() << std::flush;
#+END_SRC

Output: file - loggin.txt  
 + By opening the file logging.txt with notepad.exe, it is
   possible view all characters as show in the following block.

#+BEGIN_SRC text 
 Text in Cyrllic Script: Если указан параметр  
 Text in Chinese Script: 读写汉字1 
#+END_SRC

  *Experiment 3* - WinAPI - [[https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createdirectorya][CreateDirectory]]  

This code experiment attempts to create 3 directories: 

  + Directory: directoryANSI-读写汉字1 with CreateDirectoryA
    function (ANSI version of the underlying API)

  + Directory: directoryWCHAR-读写汉字 with CreateDirectoryW (Unicode
    version of the API).

  + Directory: directoryTCHAR-读写汉字 with _CreateDirectory macro_
    which is expanded to CreateDirectoryW when UNICODE is defined,
    othewise it is expanded to CreateDirectoryA.

#+BEGIN_SRC cpp 
     // ===========> EXPERIMENT 4 - WinAPI - CreateDirectory ============//
     std::cout << "\n ===>>> EXPERIMENT 3: WinAPI CreateDirectory <<<=== " << std::endl;

     { // -- ANSI Version of CreateDirectory API 
         bool res;
         res = CreateDirectoryA("directoryANSI-读写汉字1", NULL);
         std::cout << "Successful 1 ?=  " << std::boolalpha << res << std::endl;
     }

     {  // -- Unicode (UTF16) - Wide character version of CreateDirectory API 
         bool res;
         res = CreateDirectoryW(L"directoryWCHAR-读写汉字", NULL);
         std::cout << "Successful 2 ?= " << std::boolalpha << res << std::endl;  		
     }
     {
        // -- TCHAR Version Wide character version of CreateDirectory API 
        bool res;

        #ifdef UNICODE
          std::cout << " [INFO] UNICODE (UTF16) CreateDirectory expanded to CreateDirectoryW" << std::endl;
        #else
          std::cout << " [INFO] ANSI CreateDirectory expanded to CreateDirectoryA" << std::endl;
        #endif
        res = CreateDirectory(_T("directoryTCHAR-读写汉字"), NULL);
        std::cout << "Successful 3 ?= " << std::boolalpha << res << std::endl;  		
  }
#+END_SRC

Output when compiling without -DWITH_UNICODE: 

#+BEGIN_SRC sh
   $ g++ winapi-encoding1.cpp -o out-gcc.exe -std=c++14  && out-gcc.exe 

   ... ....  ... 
   ===>>> EXPERIMENT 3: WinAPI CreateDirectory <<<=== 
  Successful 1 ?=  true
  Successful 2 ?= true
   [INFO] ANSI CreateDirectory expanded to CreateDirectoryA
  Successful 3 ?= true
   ... ....  ... 
#+END_SRC

Directories created: 

 + [FAILED]  ~directoryANSI-è¯»å†™æ±‰å­—1~
 + [SUCCESS] ~directoryWCHAR-读写汉字~
   + Only the Unicode (CreateDirectoryW) function  works, the ANSI
     function CreateDirectoryA fails even if the string is encoded
     with UTF-8.
 + [FAILED]  ~directoryTCHAR-è¯»å†™æ±‰å­—~
   + Without UNICODE flag, CreateDirectory expands to
     CreateDirectoryA. 

Output when compiling without -DWITH_UNICODE: 

#+BEGIN_SRC sh 
   $ g++ winapi-encoding1.cpp -o out-gcc.exe -std=c++14 -DWITH_UNICODE  && out-gcc.exe 

      ... .... ... ... ...   
   ===>>> EXPERIMENT 3: WinAPI CreateDirectory <<<=== 
  Successful 1 ?=  true
  Successful 2 ?= true
   [INFO] UNICODE (UTF16) CreateDirectory expanded to CreateDirectoryW
  Successful 3 ?= true
      ... .... ... ... ...   
#+END_SRC

Directories created: 

 + [FAILED] ~directoryANSI-è¯»å†™æ±‰å­—1~
 + [SUCCESS] ~directoryWCHAR-读写汉字~
 + [SUCCESS] ~directoryTCHAR-读写汉字~


  *Experiment 4* - WinAPI [[https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-messagebox][MessageBox]] function.

#+BEGIN_SRC cpp 
    // ===========> EXPERIMENT 4 - WinAPI - MessageBox ============//
    std::cout << "\n ===>>> EXPERIMENT 4: MessageBox <<<=== " << std::endl;

    DWORD const infoboxOptions  = MB_OK | MB_ICONINFORMATION | MB_SETFOREGROUND;
    // Text in UTF8 => Note => Windows API doesn't work with UTF8
    // or multi-byte characters as the API treats the chars as they were ANSI.
    char narrowText []  = "Some chinese text não inglês  读写汉字 - 学中文";
    // Unicode text in UTF16 
    wchar_t wideText []  = L"Some chinese text não inglês 读写汉字 - 学中文";
    MessageBoxA( 0, narrowText, "ANSI (narrow) text:", infoboxOptions );    
    MessageBoxW( 0, wideText, L"Unicode (wide) text:", infoboxOptions );
#+END_SRC
 
Output of [[https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-messageboxa][MessageBoxA]] (failure, it cannot deal with unicode UTF-8 chars):

 [[file:images/messagebox-ansi1.png][file:images/messagebox-ansi1.png]]

Output of [[https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-messageboxw][MessageBoxW]] (success):

 [[file:images/messabox-unicode1.png][file:images/messabox-unicode1.png]]

** Install Building Tools and Compilers 
*** Install Mingw 

Migw - gcc/g++ GNU C/C++ Compiler ported for Windows  - [[https://chocolatey.org/packages/mingw][mingw]]

Tools: 
 + gcc => GNU C compiler
 + g++ => GNU C++ compiler
 + gfortran => GNU Fortran Compiler 

#+BEGIN_SRC sh 
 $ choco install -f mingw 
#+END_SRC

Note the tools are installed at: ~C:\tools\mingw64\bin\~

Check installed tools:

#+BEGIN_SRC sh 
  λ dir C:\tools\mingw64\bin
   Volume in drive C has no label.
   Volume Serial Number is CEFD-3D70

   Directory of C:\tools\mingw64\bin

  12/28/2015  08:49 PM    <DIR>          .
  12/28/2015  08:49 PM    <DIR>          ..
  12/28/2015  05:51 PM         1,003,008 addr2line.exe
  12/28/2015  05:51 PM         1,029,120 ar.exe
  12/28/2015  05:51 PM         1,781,248 as.exe
  12/28/2015  07:32 PM         1,812,480 c++.exe
  12/28/2015  05:51 PM         1,001,472 c++filt.exe
  12/28/2015  07:32 PM         1,810,944 cpp.exe
  12/28/2015  05:51 PM         1,061,888 dlltool.exe
  12/28/2015  05:51 PM            55,296 dllwrap.exe
  12/28/2015  05:51 PM         3,037,696 dwp.exe
  12/28/2015  05:51 PM            41,984 elfedit.exe
  12/28/2015  07:32 PM         1,812,480 g++.exe
  12/28/2015  07:32 PM            62,464 gcc-ar.exe
  12/28/2015  07:32 PM            61,952 gcc-nm.exe
  12/28/2015  07:32 PM            61,952 gcc-ranlib.exe
  12/28/2015  07:32 PM         1,809,920 gcc.exe
  12/28/2015  07:32 PM         1,391,616 gcov-tool.exe
  12/28/2015  07:32 PM         1,409,536 gcov.exe
  12/28/2015  08:47 PM            58,333 gdb.exe
  12/28/2015  08:47 PM         7,786,103 gdborig.exe
  12/28/2015  08:47 PM           412,003 gdbserver.exe
  12/28/2015  07:34 PM            57,856 gendef.exe
  12/28/2015  07:34 PM            75,264 genidl.exe
  12/28/2015  07:34 PM            31,232 genpeimg.exe
  12/28/2015  07:32 PM         1,811,968 gfortran.exe
  12/28/2015  05:51 PM         1,069,568 gprof.exe
  12/28/2015  05:51 PM         1,419,264 ld.bfd.exe
  12/28/2015  05:51 PM         1,419,264 ld.exe
  12/28/2015  05:51 PM         4,806,144 ld.gold.exe
  12/28/2015  07:33 PM            37,888 libatomic-1.dll
  12/28/2015  07:33 PM            82,944 libgcc_s_seh-1.dll
  12/28/2015  07:33 PM         1,293,312 libgfortran-3.dll
  12/28/2015  07:33 PM           112,640 libgomp-1.dll
  12/28/2015  07:33 PM            17,920 libgomp-plugin-host_nonshm-1.dll
  12/28/2015  07:33 PM           333,824 libquadmath-0.dll
  12/28/2015  07:33 PM            19,968 libssp-0.dll
  12/28/2015  07:33 PM         1,424,896 libstdc++-6.dll
  12/28/2015  07:33 PM            16,384 libvtv-0.dll
  12/28/2015  07:33 PM            16,384 libvtv_stubs-0.dll
  12/28/2015  07:33 PM            83,456 libwinpthread-1.dll
  12/28/2015  08:49 PM           219,648 mingw32-make.exe
  12/28/2015  05:51 PM         1,013,760 nm.exe
  12/28/2015  05:51 PM         1,171,456 objcopy.exe
  12/28/2015  05:51 PM         2,101,760 objdump.exe
  12/28/2015  05:51 PM         1,029,120 ranlib.exe
  12/28/2015  05:51 PM           490,496 readelf.exe
  12/28/2015  05:51 PM         1,004,032 size.exe
  12/28/2015  05:51 PM         1,003,520 strings.exe
  12/28/2015  05:51 PM         1,171,456 strip.exe
  12/28/2015  07:35 PM           437,760 widl.exe
  12/28/2015  05:51 PM         1,027,072 windmc.exe
  12/28/2015  05:51 PM         1,115,648 windres.exe
  12/28/2015  07:32 PM         1,812,480 x86_64-w64-mingw32-c++.exe
  12/28/2015  07:32 PM         1,812,480 x86_64-w64-mingw32-g++.exe
  12/28/2015  07:32 PM         1,809,920 x86_64-w64-mingw32-gcc-5.3.0.exe
  12/28/2015  07:32 PM            62,464 x86_64-w64-mingw32-gcc-ar.exe
  12/28/2015  07:32 PM            61,952 x86_64-w64-mingw32-gcc-nm.exe
  12/28/2015  07:32 PM            61,952 x86_64-w64-mingw32-gcc-ranlib.exe
  12/28/2015  07:32 PM         1,809,920 x86_64-w64-mingw32-gcc.exe
  12/28/2015  07:32 PM         1,811,968 x86_64-w64-mingw32-gfortran.exe
                59 File(s)     62,660,535 bytes
                 2 Dir(s)  19,433,713,664 bytes free

#+END_SRC

See: 

 + [[https://www.transmissionzero.co.uk/computing/building-dlls-with-mingw/][Building Windows DLLs with MinGW]]
 + [[https://www.codeproject.com/Articles/84461/MinGW-Static-and-Dynamic-Libraries][MinGW Static and Dynamic Libraries - CodeProject]]
 + 
 + 
*** Install Visual Studio + Microsft MSVC C++ Compiler 

Installing Visual Studio building tools directly is hassle as
Microsoft doesn't provide an easy and quick way to install it as Linux
development tools which can be quick installed by using the command
line and trusted repositories. However [[https://chocolatey.org/][chocolately]] package manager
provides a Linux-like solution to install those development tools in
an automatic and seamlessly way.

Visual Studio Build Tools 2015 - [[https://chocolatey.org/packages/VisualCppBuildTools][Visual C++ Build Tools 2015 14.0.25420.1]]

#+BEGIN_SRC sh 
  $ choco install visualcppbuildtools
#+END_SRC

Visual C++ 2017 - [[https://chocolatey.org/packages/visualstudio2017buildtools][Visual Studio 2017 Build Tools 15.2.26430.20170650]]

#+BEGIN_SRC sh 
 $ choco install hoco install visualstudio2017buildtools 
#+END_SRC
*** Install CMDER Terminal Emulator 

CMDER Is decent ANSI/VT100 compliant terminal emulator which supports
ANI Escape sequences, ANSI colors and Emacs Keybindigns used on bash.

#+BEGIN_SRC sh  
 $ choco install cmder 
#+END_SRC
*** Install SysInternals 


SysInterals - https://chocolatey.org/packages/sysinternals

#+BEGIN_SRC sh 
 $  choco install sysinternals 
#+END_SRC

Process Explorer - https://chocolatey.org/packages/procexp

#+BEGIN_SRC sh 
 $ choco install procexp 
#+END_SRC
*** Install IDA Free Disassembler

IDA - Free - Famous Disassembler - https://chocolatey.org/packages/ida-free

#+BEGIN_SRC sh 
 $ choco install ida-free 
#+END_SRC
*** ILSpy - Dissabler for C# 

 - http://chocolately.org/pakcages/lspy 

#+BEGIN_SRC sh 
 $ choco install -y ilspy 
#+END_SRC

** MSVC Compiler Options 

MSVC Native tools: 

 * CC = cl.exe
   + C and C++ Compiler - Can compile both C and C++ code depending on
     the flag. By default it compiles C++ code.
 * rc.exe => Resource Compiler.
 * LD = link.exe 
   + C++ Linker.
 * AS = ml
   + Assembler 
 * AR = lib
   + Archiver 

Compiler: cl.exe 

 + /nologo - Suppress microsoft's logo

 + /out:<file.exe> - Set output file name.

 + /EHsc

 + /Zi - Add debugging symbols to the executable

 + /c - Doesn't link generating *.exe or *.dll, it creates only
   intermedidate object code for further separate linking. It is
   useful for compiling large code bases where each compilation unit
   can be compiled separately.

 + /W4 - Set the level of warning to the highest.

 + /entry:<entrypoint> - Set the C/C++ runtime, it can be:
   + mainCRTStartup     => calls main(), the entrypoint for console mode apps
   + wmainCRTStartup    => calls wmain(), as above but the Unicode version
   + WinMainCRTStartup  => calls WinMain(), the entrypoint for native Windows apps
   + wWinMainCRTStartup => calls wWinMain(), as above but the Unicode version
   + _DllMainCRTStartup => Calls DLLMain() 

 + /subsystem:<type> - Set the subsystem - default Console, it can be:

   + _/subsystem:console_ - For applications that necessarly runs in the
     console (aka terminal emulator)

   + _/subsystem:windows_ - Doesn't display the cmd.exe terminal when
     ones click at the application executable.

 + /TC  -> Specify that file name is C source code
 + /TP  -> Specify that file name is a C++ source code (default)
 + /MD, /MT, /LD => Run-time library - Indcates that object-code
   (compiled program) is a DLL.
 + /GF -> (Eliminate Duplicate Strings) - Enables the compiler to
   create a single copy of identical strings in the program image and
   in memory during execution. This is an optimization called string
   pooling that can create smaller programs.

See: 
 + https://github.com/MicrosoftDocs/cpp-docs/blob/master/docs/build/building-on-the-command-line.md

Useful preprocessor: 

 - Set subsystem 

#+BEGIN_SRC cpp 
  #pragma comment(linker, "/SUBSYSTEM:WINDOWS")
  #pragma comment(linker, "/SUBSYSTEM:CONSOLE")
#+END_SRC

 - Set linker library to be linked. This pragma is particularly useful
   in graphical applications.

#+BEGIN_SRC cpp 
  #pragma comment(lib, "user32.lib")
#+END_SRC

Examples: 

 + Compile multiple files generating an executable named out.exe. Note
   the default subsystems is the console (_/subsystem:console_) and the
   default entry point is (mainCRTStartup).
   + /Isrc/includes  => Directories containing header files
   + /ld or /linker  => Linker flags
   + && out.exe      => If the compilation is successful runs the
     generated executable out.exe 

#+BEGIN_SRC sh 
  $ cl.exe source1.cpp source2.cpp /Fe:out.exe /Isrc/includes /ld gdi.lib user32.lib && out.exe
#+END_SRC

 - Compile multiple files for windows subsystem (GUI app) and with
   wmainCRtstartup.

#+BEGIN_SRC sh 
  $ cl.exe source1.cpp source2.cpp /Fe:out.exe /Isrc/includes /entry:wmainCRtstartup /subsystem:windows /ld user32.lib && out.exe
#+END_SRC

References: 

 + [[http://psy.swansea.ac.uk/staff/carter/Compiling/compilation_build.htm][Command Line Compilation]]
 + [[https://cognitivewaves.wordpress.com/makefiles/][Makefiles and Visual Studio | Cognitive Waves]]
 + [[http://resources.esri.com/help/9.3/arcgisengine/com_cpp/Cpp/reference/Makefile.Windows.htm][C++ Windows Makefile]]
 + [[https://w3.cs.jmu.edu/bernstdh/web/common/help/msc_development.php][MS C/C++: The Command-Line Tools]]

See also: 
 
 + [[https://support.microsoft.com/en-us/help/94248/how-to-use-the-c-run-time][How To Use the C Run-Time]]

 + 

 + 

** Books  

Books: 

  + Mark Russinovitch et al - *Windows Internals* - 5th edition -
    Microsft Press 2000.

  + *Windows Operating System Internals Curriculum*  Development Kit,
    developed by David A. Solomon and  Mark E. Russinovich with
    Andreas Polze.

  + Penny Orwick and Guy Smith. *Developing Drivers with Windows Driver Foundation*. 

  + *Windows Research Kernel* Sources by Microsoft - only allowed to be
    used by licensed academic institutions.

  + Charles Petzold: *Windows Programming* - Microsoft Press.

  + Visual Basic - *Programmer’s Guide to the Win32 API*, The
    Authoritative Solution by Dan Appleman

  + Johnson M. Hart, *Win32 System Programming: A Windows® 2000* -
    *Application Developer's Guide*, 2nd Edition, Addison -
    Wesley, 2000.
    + Note: This book discusses select Windows programming problems
      and addresses  the problem of portable programming by comparing
      Windows and Unixapproaches.

  + Jeffrey Richter, *Programming Applications for Microsoft Windows*,
    4th Edition, Microsoft Press, September 1999.
    + Note: This book provides a comprehensive discussion of the
      Windows API suggested reading. 
