#+TITLE: CPP / C++ Review
#+DESCRIPTION: cpp/c++ code examples and demonstrations.
#+STARTUP: content 
#+AUTHOR: Caio Rodrigues 

* Review CPP - C++
** Oveview 
*** C++ Language features

C++ Supported Paradigms: 

 + _Imperative / Procedural_ as C and Pascal

 + _Object Oriented_

 + _Functional Programmign_ since C++11 with the introduction type
   deduction (auto keyword) and lambda functions.

 + _Generic Programming_ - Template metaprogramming, a combination of
   statically typed duck-typing and lisp-like metaprogramming that
   allows efficient code generation at compile-time.

Other Features: 

 + Automatic memory management.
 + No garbage collector.
 + Low level access to system and operating system services or API in
   a similar way to C.

Domains where C++ is used: 

 + System Programming - It means, operating systems, device drivers,
   hardware interfacing, USB driver ...
 + Embedded Systems 
 + 3D game engines and AAA (triple-A) games.
 + High Performance Computing (HPC)
 + High perfomance numerical simulation.
 + High Perfomance reusable libraries and software components
 + Physics
 + High Energy Physics - See CERN 

*** Big Picture

 + Operating System
   - Windows
   - Linux (Unix)
   - Mac OSX (unix)
   - BSD Family (Unix)

 + Executable Formats
   - Windows / .exe, *.dll files         (PE32)
   - Linux   / No extension, *.so files  (ELF)
   - MacOSX  / *.dylib                   (MachO)

 + Processor Architecture

   - Most used for personal computers (based on x86)
     - Intel x86     - 32 bits.
     - AMD/Inteal 64 - 64 bits.

   - Most used for embedded systems and mobile devices.
     - ARM (32 bits) - Widely used in Smartphones, PDAs, Tablets and
       so on.
     - Power PC

 + Graphical Stack - Outline of the most common graphical systems.

   + X11 - XServer / Unix (Linux, BSD, FreeBSD)

   + Windows API / Microsoft Windows OS

   + MacOSX ???


*Tooling*

 + Compilers

   + Windows C/C++ compiler

   + GCC - Gnu C/C++ Compiler (Stard Compiler of many Linux distributions)

   + LLVM/Clang

   + Proprietary compilers: Many manufacturers provide compilers for
     their processors, microcontrollers and embedded systems that
     generally have a different architecture than most people are used
     to.

 + Building Tools

   + GNU Make

   + Cmake

 + Main C/C++ GUI - Graphical User Interfaces Libraries

   + QT toolkit / C++ - Cross Platform. QT is the most supported cross
     platform toolkit, but it is hard to be called from languages
     other than C++ as it is written in C++ and this language doesn't
     have a standard ABI (Application Binary Interface).

   + GTK / C with C++ inteface - Cross platform, most common in Linux OS.

   + Cocoa / MacOSX - Not cross platform. It is only available to MacOSX.

   + Windows API. / Only available for Windows.

*** Guidelines

 + Malloc - Avoid malloc and manual memory management. Instead of that
   use _new_ and _vector_ instead of realloc.
 + Pointer - Avoid pointers.
 + Arrays - Use C++ STL vector classes instead of arrays.
 + Strings. Don't use array of characters to represent a string,
   instead of that use c++ strings by inclunding '#include <string>'
   header at the top of file.
 + Separate the operating system depedent code from the
   operating system agnostic code.

*** Mind Map 

Shared Libraries / Software Components 

 - Interoperability

 - Binary Compatibility

 - C-library

   - [[http://www.etalabs.net/compare_libcs.html][Comparison of C/POSIX standard library implementations for Linux]]

 - Linking

   - Static Linking

   - Dynamic Linking

 - [[http://en.wikipedia.org/wiki/Dependency_hell][Dependency Hell]]

 - API - Application Programming Interface

 - ABI - [[https://en.wikipedia.org/wiki/Application_binary_interface][Application Binary Interface]]

   - Calling Conventions

   - [[https://en.wikipedia.org/wiki/System_call][System Call]]

   - Stable and Standard ABI - C Language

   - [[https://en.wikipedia.org/wiki/Loader_(computing)][Loader (computing)]]

   - [[https://en.wikipedia.org/wiki/Dynamic_linker][Dynamic linker]]

   - [[https://en.wikipedia.org/wiki/Binary-code_compatibility][Binary-code compatibility]]

 - FFI - Foreign Function Interface 

 - Excetuable Formats

   - [[https://en.wikipedia.org/wiki/Portable_Executable][PE]] - Portable Executable / Windows (*.exe files and *.dll files)

   - [[https://en.wikipedia.org/wiki/Executable_and_Linkable_Format][ELF]] - Executable and Linkable Format / Unix (Linux, BSD ...)

   - [[https://en.wikipedia.org/wiki/Mach-O][Mach-O]] -  Mach object file format / Mach-OSX and IOS

   - [[https://en.wikipedia.org/wiki/Comparison_of_executable_file_formats][Comparison of executable file formats]]

   - 

*** Standards and Libraries 

*C++ Standards* ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp1_Basics.html][Source]])

 - *C++ is standardized as ISO/IEC 14882.* Currently, there are two
   versions:

   - _C++98 (ISO/IEC 14882:1998)_ 1st standard version of C++.
   - _C++03 (ISO/IEC 14882:2003)_ minor "bug-fix" to C++98 with no change
     to the language. Commonly refer to as C++98/C++03 or First C++
     standard.
 - _C++11 (ISO/IEC 14882:2011)_ 2nd standard version of C++.


*C++ Libraries* 

 + STL (Standard Template Library) Containers, Iterators and Function objects.
   + Sequence
     + vector
     + list
     + dequee

   + Associative Sequence
     + set
     + map (Hashmap or hash table).

 + C++ Libraries ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][Source]])
   + <ios>, <iostream>, <istream>, <ostream>, <fstream>, <sstream>
   + <iomanip> 
   + <string>  - C++ Strings.
   + <regex>
   + <random>
   + <limits>
   + <stdexcept>, <exception>
   + <complex>, <tuple>, <valarray>
   + <locale>
   + <typeinfo>
   + <chrono>

   + Other: <codecvt>, <new>, <ratio>, <system_error>, <type_traits>

 + Useful non-standard C++ Libraries 
   + Boost C++ libaries
   + QT toolkit / GUI - Toolkit

 + C Compatibility
   + Standard ANSI C libaries ported to C++ are prefixed with "c"
     without ".h". For instance, "#include <math.h>" form C becomes
     "#include <cmath>" in C++.

   + C Libraries. ([[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][Source]])
     + <cmath> - (math.h) - Standard mathematical functions such as
       sin, cos, sqrt and so on.
     + <cctypes> - (ctypes.h) - Checking character types (isalpha,
       isdigit, isalnum, isspace, isupper, islower, isblank, iscntrl,
       isgraph, isprint, ispunct, isxdigit) and character conversion
       (toupper, tolower).
     + <climits>, <cfloat>: Size and limit of integer types (INT_MAX,
       INT_MIN, UINT_MAX, CHAR_BIT; and SHRT_XXX for short, LONG_XXX
       for long, LLONG_XXX for long long, CHAR_XXX for char) and
       floating-point types (DBL_MIN, DBL_MAX, DBL_DIG, DBL_MIN_EXP,
       DBL_MAX_EXP; and FLT_XXX for float, LDBL_XXX for long double).

     + <ctime>: time, difftime, clock, gmttime, localtime, and etc.
     + <cstdio>: C's IO operations (scanf, printf, fscanf, fprintf, fopen, fclose, etc)
     + <cassert>, <cerrno>, <csignal>: Diagnostics and error
     + <clocale>: localizaton
     + <cstdbool>, <cstdint>, <cstddef>, <cstdarg>
     + <cstdbool>, <cstdint>, <cstddef>, <cstdarg>

*** C++ Checklist

 - [ ] - Create C++ shared library 

 - [ ] - Create a C-interface and FFI-interface for a C++ shared
   library.

   - [ ] - Example - Haskell FFI.

   - [ ] - Example - Python FFI.

   - [ ] - Example - F# (.NET) FFI.

 - [ ] - Some graphical programming with QT.

 - [ ] - Interface low level Unix/Linux OS services.

 - [ ] - Standard STL library

 - [ ] - Vectors and numerical computing with STL.

*** C++ Resources

*C++ General Resources*

 - Ian D. Chivers - *An Introduction to C++*
   <http://www.icsd.aegean.gr/lecturers/kavallieratou/Cplusplus_files/notes.pdf>

 - [[https://www.reddit.com/r/Physics/comments/2w4exo/what_are_the_useful_aspects_of_c_in_physics/][What are the useful aspects of C++ in Physics programming? : Physics]]

 - [[https://anteru.net/blog/2016/05/01/3249/][Designing C APIs in 2016 | Anteru’s blog]]

*C++ Numerical Methods and Scientific Computing*

 - Prof. R. Hiptmair, SAM, ETH Zurich. *Numerical Methods for
   Computational Science and Engineering* -
   <http://www.sam.math.ethz.ch/~hiptmair/tmp/NumCSE/NumCSE15.pdf>


 - Norbert Pozar. *Basic C++ for numerical computations: vectors*
   <http://polaris.s.kanazawa-u.ac.jp/~npozar/basic-cpp-for-numerics-vectors.html>


*C++ STL - Standard Template Library*


 - *A modest STL tutorial*
   <http://cs.brown.edu/~jak/proglang/cpp/stltut/tut.html>


 - Carlos Moreno. *C++ Vectors* <https://cal-linux.com/tutorials/vectors.html>


*C++ ABI - Application Binary Interface, Binary Compatibility and FFI*

 - By Agner Fog. *Calling conventions for different C++ compilers and
   operating systems*
   <http://www.agner.org/optimize/calling_conventions.pdf>


 - Armin Ronacher. *Beautiful Native Libraries*
   <http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/>


 - Herb Sutter. *Defining a Portable C++ ABI* <https://isocpp.org/files/papers/n4028.pdf>

 - *Some thoughts on binary compatibility*
   <http://blog.qt.io/blog/2009/08/12/some-thoughts-on-binary-compatibility/>

 - *Interoperability of Libraries Created by Different Compiler
   Brands* <http://www.mingw.org/wiki/Interoperability_of_Libraries_Created_by_Different_Compiler_Brands>

 - Thiago Macieira. *Binary compatibility for library developers*
   <https://events.linuxfoundation.org/sites/events/files/slides/Binary_Compatibility_for_library_devs.pdf>

 - *What Language I Use for… Creating Reusable Libraries: Objective-C*
   <http://www.informit.com/articles/article.aspx?p=2144812>

 - *Compilable modern alternatives to C/C++* -
   <https://softwareengineering.stackexchange.com/questions/162614/compilable-modern-alternatives-to-c-c>

 - [[https://stackoverflow.com/questions/3217513/are-llvm-gcc-and-clang-binary-compatible-with-gcc-particularly-mingw-gcc-on-w][linker - Are llvm-gcc and clang binary compatible with gcc? - particularly mingw gcc on Windows - Stack Overflow]]

 - [[http://rlc.vlinder.ca/blog/2009/08/binary-compatibility/][Binary Compatibility | Making Life Easier]]

 - *System V Application Binary Interface AMD64 Architecture Processor
   Supplement* <https://c9x.me/compile/bib/abi-x64.pdf>

 - *Software optimization resources* - <http://www.agner.org/optimize/>

 - [[https://softwareengineering.stackexchange.com/questions/281882/why-does-c-provide-language-bindings-where-c-falls-short][Why does C provide language 'bindings' where C++ falls short? - Software Engineering Stack Exchange]]

 - [[https://news.ycombinator.com/item?id=2379676][I've written in C++ professionally almost 12 years (17 years counting College), ... | Hacker News]]

 - [[https://www.reddit.com/r/swift/comments/67z7dy/what_is_abi_stability_and_why_does_it_matter/][What is ABI stability and why does it matter? : swift]]

 - [[https://www.reddit.com/r/programming/comments/4r6r8e/abi_vs_api/][ABI vs. API : programming]]

 - [[https://www.reddit.com/r/linux_gaming/comments/5nqaux/confused_about_compatibility/dcdxd19/][heartsofwar comments on Confused about Compatibility]]

 - [[https://www.reddit.com/r/askscience/comments/3ei05n/why_is_that_programs_need_to_be_ported_between/][Why is that programs need to be ported between operating systems in order in to function? What goes on at the programming level to require this? : askscience]]

 - [[https://www.reddit.com/r/AskProgramming/comments/5c74i4/some_thoughts_about_abis/][some thoughts about ABIs : AskProgramming]]

 - [[http://damienkatz.net/2013/01/the_unreasonable_effectiveness_of_c.html][Damien Katz: The Unreasonable Effectiveness of C]]

 - [[https://www.reddit.com/r/linux/comments/42vngw/why_is_the_linux_community_ambivalent_about/][Why is the Linux community ambivalent about binary compatibility? : linux]]

 - [[https://www.reddit.com/r/C_Programming/comments/4afu69/implementing_cross_platform_library_in_c_proscons/][Implementing cross platform library in C pros/cons C_Programming]]

 - 

 - 

*C-Interface* 

 - *CppCon 2014: Stefanus DuToit "Hourglass Interfaces for C++ APIs* -
   <https://www.youtube.com/watch?v=PVYdHDm0q6Y>


*FFI - Foreign Function Interface*

 - https://en.wikipedia.org/wiki/Foreign_function_interface

 - [[http://www.mono-project.com/docs/advanced/pinvoke/][Interop with Native Libraries | Mono]]

 - [[https://en.wikipedia.org/wiki/SWIG][SWIG - Wikipedia]] -  Simplified Wrapper and Interface Generator

 - [[https://sourceware.org/libffi/][libffi]] - A Portable Foreign Function Interface Library

 - [[https://en.wikipedia.org/wiki/Libffi][libffi - Wikipedia]]

 - [[https://docs.python.org/3/extending/extending.html][1. Extending Python with C or C++ — Python 3.6.1 documentation]]

 - [[https://msdn.microsoft.com/en-us/library/aa288468(v=vs.71).aspx][Platform Invoke Tutorial (C#)]]

 - [[https://www.reddit.com/r/explainlikeimfive/comments/5c2yfq/eli5_how_can_a_single_software_project_use/][Eli5: How can a single software project use multiple languages? Wouldn't the compiler have difficulty understanding what's what? : explainlikeimfive]]

 - [[https://www.reddit.com/r/learnprogramming/comments/3dzif8/how_do_you_communicate_between_different_computer/][How do you communicate between different computer languages? : learnprogramming]]


*Courses and Online Books*

 - [[https://en.wikibooks.org/wiki/C%2B%2B_Programming][C++ Programming - Wikibooks, open books for an open world]]


 - Francois Fleuret. *C++ lecture notes*
   <https://www.idiap.ch/~fleuret/files/Francois_Fleuret_-_C++_Lecture_Notes.pdf>


 - Course:  https://www3.ntu.edu.sg/home/ehchua/programming/

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp0_Introduction.html][An Introduction to C++ Programming for First-time Programmers - C++ Programming Tutorial]] - https://archive.is/MRDZI

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html][C++ Libraries, String and Standard Template Library]] - https://archive.is/lrIDk

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp2_MoreBasics.html][C++ More Basics]] - https://archive.is/pr7pn

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp3_OOP.html][Object-oriented Programming (OOP) in C++]] - https://archive.is/lpXae

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp4_PointerReference.html][C++ Pointers and References]] - https://archive.is/Ja1xJ

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp5_OOPExamples.html][Examples on Classes and Objects]] - https://archive.is/eZJPl

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp8_Template.html][Object-oriented Programming (OOP) in C++ - Template and Generic Programming]] - https://archive.is/eG0KZ

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_String.html][C++ Libraries, String and Standard Template Library]]

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp9_String.html][C++ Libraries, String and Standard Template Library]]

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_IO.html][C++ IO Streams and File Input/Output]]

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp11_TipsTraps.html][Examples on Classes and Objects]]

   - [[https://www3.ntu.edu.sg/home/ehchua/programming/cpp/DataStructureAlgorithm.html][Data Structure and Algorithm]]

*Unix - API / LibC*

 - *User space and the libc interface* - <https://www.win.tue.nl/~aeb/linux/lk/lk-3.html>


*Embedded Systems*

 - [[http://bitbashing.io/embedded-cpp.html][C++ On Embedded Systems]]

 - [[http://git.eti.pg.gda.pl/intel-grant/pliki/esp/ESP_Toolchain_ENG.pdf][Embedded Systems Programming OS Linux - Toolchain]]

 - 

*Alternatives to C++*

The C++ language is suitable for system programming, writing native
applications and writing high performance software components or
libraries. However the lack of standard ABI - Application Binary
interface makes calling C++ calling a C++ library through FFI -
Foreign Function Interface in another language harder.

Due to the C++ ABI issues, many portable libraries that are easier to
invoked through a FFI are written in C, for instance, GTK GUI toolkit,
... 

Selection Requirements: 

 - Compile to native code.

 - Have an stable and standard ABI - Application Binary Interface like C.

 - Be able to build shared libraries *.so or *.dll and easily invoked
   through FFI - Foreign Function Intefaces of high level languages
   such as Python, Ruby, Java, C# and so on.

 - Be memory safe in order to avoid buffer overflow. 


_D language_


   - [[http://bitbashing.io/2015/01/26/d-is-like-native-python.html][D is like native Python]]

   - [[http://code.dlang.org/packages/pyd][Package pyd version 0.9.9 - DUB - The D package registry]]

   - [[http://dlang.org/spec/abi.html][Application Binary Interface - D Programming Language]] 

   - [[https://dlang.org/dll-linux.html][Writing Shared Libraries With D On Linux - D Programming Language]]

   - [[http://blog.tenstral.net/2016/05/adventures-in-d-programming.html][Adventures in D programming | Ximions Blog]]

_Gambit Scheme_ 

A Scheme implementation that is interactive with a REPL and that can
generate C-code and invoke C-libraries. It can be compiled to
shared libraries *.so or *.dlls and be called from scheme REPL.

_Rust_

*** Drawbacks and ABI Issues

*Drawbacks*

 + C++ is unsafe. Bugs like stack overflow, buffer overlow, null
   pointr exceptions may happen.

 + _Operating System Depedent_ - C++ may be portable, but it is not
   cross platform since it is compiled to machine code and for a
   particular operatiing system.

 + Hardware dependent (Processor Architecture) and Operating System
   Depedent. C++ is compied to machine code / binary code for a
   particular operating system and processor architecture with
   different executable formats. The most common processor
   architectures are Intel x86 (32 bits) and AMD64 (64 bits).

   + OS Windows            / Executable Format - PE-32

   + Unix (Linux, BSD ...) / Executable Format - ELF

   + Mac-OSX               / Executable Format - Mac-O

   +

 + _No Standard ABI (Application Binary Interface)_ - C++ shared
   libraries and programs compiled with different compilers or
   different versions of same compiler may be incompatible because
   unlinke C, C++ doesn't have a standard ABI. It makes hard to call
   libraries written in C+++ through an FFI - Foreign Function
   Interface form another programming language such as Python.


*ABI Issues* - Credits: *Defining a Portable C++ ABI* - https://isocpp.org/files/papers/n4028.pdf

_A C++ developer cannot compile C++ code and share the object file with_
_other C++ developers on the same platform and know that the result_
_will compile and link correctly_. Our status quo is that two source
files a.cpp and b.cpp can only be linked together if they are compiled
with both:" -- ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])

 - "the same version of the same compiler, or another compiler with a
   compatibility mode" ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])

 - "compatible switch settings, since most C++ compilers offer
   incompatible switch settings where even compiling two files with
   the same version of the same compiler will not link successfully."
   ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])



Issues:

 - "It makes sharing binary C++ libraries more difficult: _To ship a C++_
   _library in binary form for a given platform requires building it_
   _with possibly dozens of popular combinations of switch settings for_
   the popular compiler(s) on that platform, and then may not cover
   all combinations. Alternatively, one can wrap the library in that
   platform’s stable C ABI, which brings us to…"  ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])



 - "_It is a valid reason to use C: This is (the) one area where C is_
   _superior to C++_. Among programs and programmers who would otherwise
   use C++, _the top reason to use C appears to be the inability to_
   _publish an API with a stable binary ABI_, including that it can be
   linked to from C, C++, and other languages’ foreign function
   interfaces (FFIs) such as Java JNI and .NET PInvoke. In
   particular…"  ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])



 - "_It therefore creates ongoing security problems: The fact that C is_
   _the only de facto ABI-stable lingua franca continues to encourage_
   _type- and memory-unsafe C APIs that traffick in things like error_
   prone pointer/length pairs instead of more strongly typed and still
   highly efficient abstractions, including but not limited to
   std::string or the new string_view"  ([[https://isocpp.org/files/papers/n4028.pdf][Herb Sutter]])


*Solutions to ABI compatibility issues*

 1) _Distribute the library in source format_. Approach adopted by QT
    (former Trolltech Inc, now the QT Company) with open source and
    commercial license.

 2) Distribute the library in binary format and only support a
    specific compiler.

 3) _Compile he C++ shared library with all possible compilers_ and
    distribute the binaries for each compiler, compiler version,
    processor architecture and operating system.

 4) _Write the library in C, instead of C++_. This approach is followed
    by most Unix/Linux libraries and OpenGL and Gtk GUI toolkit.

 5) Use some language that can compile/generate C-code (transpiler).

 6) Use Microsoft COM (Component Object Model)/ DCOM or CORBA, DBUS ... 



Note: C is until now the only language with a standard and public ABI
and most OS exposes its API through a C interface, programming
languages runtimes are generally implement in C.

** CPP
*** Data Types Sizes 

File: [[file:src/dataTypeSizes.cpp][file:src/dataTypeSizes.cpp]]

#+BEGIN_SRC cpp :tangle src/dataTypeSizes.cpp 
/**   File:      dataTypeSizes.cpp 
      Objective: Show C/C++ primitive data types sizes.      

 */

#include <iostream>
#include <limits>

using namespace std;


int main(){
  // 8 bits / 1 byte numeric types
  //---------------------------------------------------
  int charMin = numeric_limits<char>::min() ;
  int charMax = numeric_limits<char>::max() ;
  
  int scharMin = numeric_limits<signed char>::min() ;
  int scharMax = numeric_limits<signed char>::max() ;

  int ucharMin = numeric_limits<unsigned char>::min() ;
  int ucharMax = numeric_limits<unsigned char>::max() ;

  int int8Min  = numeric_limits<int8_t>::min() ;
  int int8Max  = numeric_limits<int8_t>::max() ;  

  int uint8Min  = numeric_limits<uint8_t>::min() ;
  int uint8Max  = numeric_limits<uint8_t>::max() ;

  // 16 bits / 2 bytes Numeric types
  //---------------------------------------------------
  
  int shortMin  = numeric_limits<short>::min() ;
  int shortMax  = numeric_limits<short>::max() ;

  int ushortMin  = numeric_limits<unsigned short>::min() ;
  int ushortMax  = numeric_limits<unsigned short>::max() ;
  
  int int16Min  = numeric_limits<int16_t>::min() ;
  int int16Max  = numeric_limits<int16_t>::max() ;  

  int uint16Min  = numeric_limits<uint16_t>::min() ;
  int uint16Max  = numeric_limits<uint16_t>::max() ;  

  // 32 bits / 4 bytes Numeric types
  //---------------------------------------------------
    
  int intMin  = numeric_limits<int>::min() ;
  int intMax  = numeric_limits<int>::max() ;  
  
  cout << "C/C++ Data type sizes in number of bytes (1 byte = 8 bits)" << endl;

  cout << "\n1 byte / 8 bits Data types"                       << endl;
  cout <<  "------------------------------------"              << endl; 
  cout << "sizeof(char)          = " << sizeof(char)           << " min = " << charMin  << " max = " << charMax << endl; 
  cout << "sizeof(signed char)   = " << sizeof(signed char)    << " min = " << scharMin << " max = " << scharMax << endl; 
  cout << "sizeof(unsigned char) = " << sizeof(unsigned char)  << " min = " << ucharMin << " max = " << ucharMax << endl; 
  cout << "sizeof(int8_t)        = " << sizeof(int8_t)         << " min = " << int8Min  << " max = " << int8Max << endl; 
  cout << "sizeof(uint8_t)       = " << sizeof(uint8_t)        << " min = " << uint8Min << " max = " << uint8Max << endl; 
  
  cout << "\n2 bytes / 16 bits Data types"                     << endl;  
  cout <<  "------------------------------------"              << endl;   
  cout << "sizeof(short)         = " << sizeof(short)          << " min = " << shortMin  << " max = " << shortMax  << endl; 
  cout << "sizeof(usigned short) = " << sizeof(unsigned short) << " min = " << ushortMin << " max = " << ushortMax << endl; 
  cout << "sizeof(int16_t)       = " << sizeof(int16_t)        << " min = " << int16Min  << " max = " << int16Max  << endl;  
  cout << "sizeof(uint16_t)      = " << sizeof(uint16_t)       << " min = " << uint16Min << " max = " << uint16Max << endl;  
  
  cout << "\n4 bytes / 32 bits Data types"                    << endl;  
  cout <<  "------------------------------------"             << endl;   
  cout << "sizeof(int)           = " << sizeof(int)           << " min = " << intMin << " max = " << intMax << endl;  
  cout << "sizeof(int32_t)       = " << sizeof(int32_t)       << endl;
  cout << "sizeof(int64_t)       = " << sizeof(int64_t)       << endl;
  
  cout << "sizeof(float)         = " << sizeof(float)         << endl;  
    cout << "\n8 bytes / 64 bits Data types"                    << endl;  
  cout <<  "------------------------------------"             << endl;    
  cout << "sizeof(long)          = " << sizeof(long)          << endl;
  cout << "sizeof(long long)     = " << sizeof(long long)     << endl;    
  cout << "sizeof(double)        = " << sizeof(double)        << endl;  
  
  return 0;
}

#+END_SRC

Running:

#+BEGIN_SRC sh
$ g++ dataTypeSizes.cpp -o dataTypeSizes.bin && ./dataTypeSizes.bin
C/C++ Data type sizes in number of bytes (1 byte = 8 bits)

1 byte / 8 bits Data types
------------------------------------
sizeof(char)          = 1 min = -128 max = 127
sizeof(signed char)   = 1 min = -128 max = 127
sizeof(unsigned char) = 1 min = 0 max = 255
sizeof(int8_t)        = 1 min = -128 max = 127
sizeof(uint8_t)       = 1 min = 0 max = 255

2 bytes / 16 bits Data types
------------------------------------
sizeof(short)         = 2 min = -32768 max = 32767
sizeof(usigned short) = 2 min = 0 max = 65535
sizeof(int16_t)       = 2 min = -32768 max = 32767
sizeof(uint16_t)      = 2 min = 0 max = 65535

4 bytes / 32 bits Data types
------------------------------------
sizeof(int)           = 4 min = -2147483648 max = 2147483647
sizeof(int32_t)       = 4
sizeof(int64_t)       = 8
sizeof(float)         = 4

8 bytes / 64 bits Data types
------------------------------------
sizeof(long)          = 8
sizeof(long long)     = 8
sizeof(double)        = 8

#+END_SRC

*** Simple assertion testing - file testing1.cpp
   :PROPERTIES:
   :ID:       106aed05-30af-44c1-b3c1-a360b025ac09
   :END:

 - file:src/testing1.cpp - Unit test example cpp files - [[https://drive.google.com/viewerng/viewer?url%3Dhttp://users.csc.calpoly.edu/~djanzen/tdl/AutomatedUnitTesting.pdf][Automated Unit Testing for CPP]]


#+BEGIN_SRC cpp :tangle src/testing.cpp
#include <cassert>

int sum(int min, int max){
  return min + max;
}

int main()
{
  assert(sum(0, 2)  == 3);
  assert(sum(-2, 2) == 0);
  assert(sum(3, 7) == 25);

  return 0;

}
#+END_SRC


#+BEGIN_SRC sh
$ ./testing.bin
testing.bin: testing1.cpp:9: int main(): Assertion `sum(0, 2) == 3' failed.
Aborted
#+END_SRC

*** Assertion in CPP - file assert.cpp                    :assert:test:check:
   :PROPERTIES:
   :ID:       6796c748-6658-49b1-be2e-ad444af89229
   :END:


File: file:src/assert.cpp

#+BEGIN_SRC cpp :tangle src/assert.cpp
// Description: Assertion demonstration in C++.
// Author:      Caio Rodrigues
// File:        assert.cpp
// Compile: g++ assert.cpp -o assert.bin
//

#include <cassert>    // Assertion
#include <iostream>   // Standard library

int main (int argc, char * argv[]) {

  // Check argc and exit if not enough arguments are provided to avoid segmentation fault.
  //
  if (argc != 2){
    std::cout << "Usage: ./" << argv[0] << "[n]" << std::endl;
    std::cout << "where [n] is a number > 0. If n * n != 25 the assertion fails." << std::endl;

    exit(0); // exit(1) - Return status code 1 - Indicating failure.
  }

  int i = atoi(argv[1]);
  int j = i * i ;

  assert (j == 25);

  std::cout << "continuing" << std::endl;

  exit(0); // exit(0) - Return status code 0 - Indicating success.
}

#+END_SRC

This file demonstrate assertion in C++. If the square of input
argument is not 25 it throws an assertion error.

Compile:

#+BEGIN_SRC sh
$ g++ assert.cpp -o assert.bin
#+END_SRC

*Running:*

No arguments - print help

#+BEGIN_SRC sh
./assert.bin
Usage: ././assert.bin[n]
where [n] is a number > 0. If n * n != 25 the assertion fails.
#+END_SRC

Passing 4 as argument.

#+BEGIN_SRC sh
./assert.bin 4
assert.bin: assert.cpp:24: int main(int, char**): Assertion `j == 25' failed.
#+END_SRC

Passing 10 as argument

#+BEGIN_SRC sh
./assert.bin 10
assert.bin: assert.cpp:24: int main(int, char**): Assertion `j == 25' failed.

#+END_SRC

Passing 5 as argument. 5 * 5 == 25. Ok. The assertion doesn't fail.

#+BEGIN_SRC sh
./assert.bin 5
continuing
#+END_SRC
*** Parse number                                     :atoi:atof:parse:number:
   :PROPERTIES:
   :ID:       170ef7e0-8f02-4bc3-afb6-38b2ee8810d6
   :END:

Shows how to parse number with atoi, atof and so on.

File: file:src/numberParse.cpp

#+BEGIN_SRC cpp :tangle src/numberParse.cpp
// Description: atoi, atof, strtol demonstration.
// Note: Convert string to integer, double and long integer.
// Tags: atoi, atof, strtol
//

#include <cassert>
#include <iostream>

using namespace std;

int main (){

  cout << "\nAtoi - parse int 32 bits" << endl;

  cout << "atoi(\"2342\")    = " << atoi("2342")  << endl;
  cout << "atoi(\"-2323\")   = " << atoi("-2323") << endl;
  cout << "atoi(\"failed\")  = " << atoi("failed") << endl;
  cout << "atoi(\"12xy346\") = " << atoi("12xy346") << endl;

  cout << "\nAtof - parse float/double" << endl;

  cout <<  "atof(\"100.23\")              = "  << atof("100.23") << endl;
  cout <<  "atof(\"-20.015e3\")           = "  << atof("-20.015e3") << endl;
  cout <<  "atof(\"100.134354blablah\")   = "  << atof("100.134354blablah") << endl;
  cout <<  "atof(\"failed0.3123garbage\") = "  << atof("failed0.3123garbage") << endl;

  return 0;
}
#+END_SRC

Running:

#+BEGIN_SRC sh
./g++ numberParse.cpp -o numberParse.bin && ./numberParse.bin

Atoi - parse int 32 bits
atoi("2342")    = 2342
atoi("-2323")   = -2323
atoi("failed")  = 0
atoi("12xy346") = 12

Atof - parse float/double
atof("100.23")              = 100.23
atof("-20.015e3")           = -20015
atof("100.134354blablah")   = 100.134
atof("failed0.3123garbage") = 0
#+END_SRC
*** C++ Functions with Arrays (C-style)
    :PROPERTIES:
    :ID:       a89d5099-af3a-4034-8331-628fe59a0eb7
    :END:

  - [[file:src/arraysFun.cpp][file:src/arraysFun.cpp]]

#+BEGIN_SRC cpp :tangle src/arraysFun.cpp
#include <iostream>  // Basic IO functions
#include <cmath>     // C-math functions such as sqrt, pow ...
#include <cassert>   // Assertions

using namespace std;

// Function prototypes
//---------------------------------//

double scalarProduct   (double [], double [], int);
double vectorSum       (double [], int);
double vectorNorm      (double [], int);
void   printVectorVert (double xs[], int size);

//  Main function
//-------------------------------

int main()
{
  int size = 4 ;
  double v1[] = {1.0, 2.0, 3.0, 4.0} ;
  double v2[] = {3.0, 4.0, 5.0, 6.0} ;

  cout << "\n\nVector v1 = " << endl ;
  printVectorVert(v1, size);

  cout << "\n\nVector v2 = " << endl ;
  printVectorVert(v2, size);

  cout << "\n\nScalar product is = " << scalarProduct(v1, v2, size) << endl;

  cout << "Vector v1 sum is  = " << vectorSum(v1, size) << endl;

  cout << "Vector v2 Norm is = " << vectorNorm(v1, size) << endl;

  assert(scalarProduct(v1, v2, size) == 50.0);

  return 0 ; // Return 0 as status code.
}

//  Functions Implementations
// -------------------------------- //

double scalarProduct(double xs[], double ys[], int size){
  double sum = 0.0;

    for (int i = 0; i <= size -1; i++){
      sum = sum + xs[i] * ys[i];
    }
  return sum;
}

double vectorSum(double xs[], int size){
  double sum = 0.0 ;

  for (int i = 0; i <= size - 1; i++){
    sum = sum + xs[i];
  }
  return sum;
}


double vectorNorm(double xs[], int size){
  double sum = 0.0 ;

  for (int i = 0; i <= size - 1; i++){
    sum = sum + xs[i] * xs[i];
  }
  return sqrt(sum);
}


void printVectorVert(double xs[], int size){
  for (int i = 0; i <= size -1; i++){
    cout << "v[" << i << "] = " << xs[i] << endl ;
  }
}
#+END_SRC

Program output:

#+BEGIN_SRC sh
g++ arraysFun.cpp -o arraysFun.bin && ./arraysFun.bin


Vector v1 =
v[0] = 1
v[1] = 2
v[2] = 3
v[3] = 4


Vector v2 =
v[0] = 3
v[1] = 4
v[2] = 5
v[3] = 6


Scalar product is = 50
Vector v1 sum is  = 10
Vector v2 Norm is = 5.47723


#+END_SRC

*** C++ Strings
    :PROPERTIES:
    :ID:       e11fbf1d-b47a-4151-806b-b5b0c2f99799
    :END:

The c++ string class is better to than the old c-style strings as
arrays of characters because it frees the developer from manual memory
management.

C-style strings

#+BEGIN_SRC C
char name[] = "John";
#+END_SRC

C++ style-strings.

File: [[file:src/cppStrings.cpp][src/cppStrings.cpp]]

#+BEGIN_SRC cpp :tangle src/cppStrings.cpp
  #include <iostream>
  #include <string>
  using namespace std;

  int main()
  {
    string s;

    s = "hello world c++ string" ;
    cout << "s = " << s << endl;

    s += " Append this to string" ;
    cout << "s = " << s << endl;

    return 0;
  }
#+END_SRC

Compiling and running:

#+BEGIN_SRC sh
$ g++ cppStrings.cpp -o cppStrings.bin && ./cppStrings.bin
s = hello world c++ string
s = hello world c++ string Append this to string
#+END_SRC

*** C++ Concrete Data Types (Classes)
    :PROPERTIES:
    :ID:       4699b19e-1282-44bc-9cf3-a5ad8cd6c6cd
    :END:
**** Simple Class
     :PROPERTIES:
     :ID:       98c433c6-fbfa-48c0-82fa-51520b23c872
     :END:

 - File: [[file:src/cppClasses1.cpp][file:src/cppClasses1.cpp]]

#+BEGIN_SRC cpp :tangle src/cppClasses1.cpp

  #include <iostream>
  using namespace std;

  class Date
  {
  public:
    int year, month, day;

    // ---- Public Class Members ----- //

    void showDate();
    void showDate2();
    int  getYear();
    int  getDay();
    int  getMonth();
  };


  void Date::showDate(){
    cout << "Date = " << this->year << "-" << this->month << "-" << this->day << endl;
  }

  void Date::showDate2(){
    cout << "Date = " << year << "-" << month << "-" << day << endl;
  }

  int Date::getYear(){
    return year;
  }

  int Date::getMonth(){
    return month;
  }

  int Date::getDay(){
    return day;
  }

  Date makeDate (int y, int m, int d){
    Date date;
    date.year  = y ;
    date.month = m ;
    date.day   = d ;
    return date;
  }

  void printDate(Date d){
    cout << "Date is " << d.year << "-" << d.month << "-" << d.day << endl;
  }


  int main(){
    Date d;
    d.day   = 10;
    d.month = 4;
    d.year  = 1998;

    cout << "Date (YMD) is = " << d.year << "-" << d.month << "-" << d.day << endl;
    d.showDate();
    d.showDate2();
    printDate(d);

    cout << "Year of date d is  = " << d.getYear() << endl;
    cout << "Month of date d is = " << d.getMonth() << endl;

    printDate(makeDate(1996, 8, 20));

    return 0;
  }
#+END_SRC

Running:

#+BEGIN_SRC sh
$ g++ cppClasses1.cpp -o cppClasses1.bin&& ./cppClasses1.bin
Date (YMD) is = 1998-4-10
Date = 1998-4-10
Date = 1998-4-10
Date is 1998-4-10
Year of date d is  = 1998
Month of date d is = 4
Date is 1996-8-20
#+END_SRC

**** Class with operator overload (vector2D)
     :PROPERTIES:
     :ID:       4bcee82a-e2d8-48c6-b09e-8253b54958ea
     :END:

 - File: [[file:src/cppVector2D.cpp][file:src/cppVector2D.cpp]]

#+BEGIN_SRC cpp :tangle src/cppVector2D.cpp
#include <iostream>
#include <cmath>

using namespace std;

class vector2D
{
private:
  // Private members
  double x;
  double y;
  
public:
  
  // Class constructors 
  vector2D();
  vector2D(double vX, double vY);

  // Getters
  double getX() const;
  double getY() const;

  void print() const;

  void move(double dx, double dy);

  void setPos(double vX, double vY);

  //-- Operators (Binary Functions/ Class members) -- //

  vector2D operator+ (vector2D B);
  vector2D operator- (vector2D B);
  
  vector2D operator* (double factor);
  vector2D operator/ (double factor);
  
};

vector2D::vector2D() {
  x = 0.0;
  y = 0.0; 
}

vector2D::vector2D(double vX, double vY){
  x = vX;
  y = vY;
}

double vector2D::getX() const{
  return x;
}

double vector2D::getY() const{
  return y;
}


void vector2D::move(double dx, double dy){
  x = x + dx;
  y = y + dy;
}


void vector2D::setPos(double vX, double vY)
{
  x = vX;
  y = vY;
}

void vector2D::print() const
{
  cout << "Vector2D (X = " << x << ", Y = " << y << ")" << endl;
}

vector2D vector2D::operator + (vector2D B){
  vector2D res;
  res.x = x + B.x;
  res.y = y + B.y;
  return res;
}


vector2D vector2D::operator - (vector2D B){
  vector2D res;
  res.x = x - B.x;
  res.y = y - B.y;
  return res;
}


vector2D vector2D::operator * (double factor){
  vector2D res;
  res.x = x * factor; 
  res.y = y * factor;
  return res;
}


vector2D vector2D::operator / (double factor){
  vector2D res;
  res.x = x / factor; 
  res.y = y / factor;
  return res;
}



int main(){

  vector2D vA = vector2D();
  vector2D vB = vector2D(10.23, -8.63);

  vA.print();
  vA.move(2.0, 3.0);
  vA.print();
  
  vB.print();
  vB.move(2.0, 3.0);
  vB.print();

  cout << "\n(1) Vc = vA + vB = " << endl;
  vector2D vC = vA + vB;
  vC.print();

  cout << "\n(2) Vc = vA + vB = " << endl;  
  (vA + vB).print();

  cout << "\n(3) vB * 3.0 = " << endl;
  (vB * 3.0).print();
  
  cout << "\n(4) (vA + vB) / 2.0 = " << endl;
  vector2D vD = (vB + vB) / 2.0 ;
  vD.print();


  // ----------- Pointer Tests ------------------ // 

  vector2D * vp ;

  vp = & vB ;  // Assign pointer to address of vector vB.

  cout  << "\n\nPointer address = " << vp << endl ;


  cout << "\nvp->print()   = " << endl;
  vp->print();

  cout << "\n(*vp).print() = " << endl;  
  (*vp).print();

  cout << "\nvector2D m = *vp; m.print(); = " << endl;  
  vector2D m = *vp;  
  m.print();
  
  return 0;
}

#+END_SRC

Running:

#+BEGIN_SRC sh1
$ g++ cppVector2D.cpp -o cppVector2D.bin && ./cppVector2D.bin
Vector2D (X = 0, Y = 0)
Vector2D (X = 2, Y = 3)
Vector2D (X = 10.23, Y = -8.63)
Vector2D (X = 12.23, Y = -5.63)

(1) Vc = vA + vB = 
Vector2D (X = 14.23, Y = -2.63)

(2) Vc = vA + vB = 
Vector2D (X = 14.23, Y = -2.63)

(3) vB * 3.0 = 
Vector2D (X = 36.69, Y = -16.89)

(4) (vA + vB) / 2.0 = 
Vector2D (X = 12.23, Y = -5.63)


Pointer address = 0x7fffa50cb390

vp->print()   = 
Vector2D (X = 12.23, Y = -5.63)

(*vp).print() = 
Vector2D (X = 12.23, Y = -5.63)

vector2D m = *vp; m.print(); = 
Vector2D (X = 12.23, Y = -5.63)


#+END_SRC

*** C++ STL Vectors Containers 
**** Overview 

*C++ Arrays Drawbacks*

 - The size of array is fixed or constant.

 - Passing an array as parameter is cumbersome since the array and its
   size must be passed.

 - There is no way to insert elements at the beggining or at the end.

 - It is not possible to return an array from a function.

 - It requires manual memory management and allocation what is error
   prone.

*Vectors*

 - C++ Vectors are a class in C++.

 - Size of vectors can grow or shrink during execution.

 - A vector stores its size, therefore a it doesn't need to be passed
   as function argument.

 - It provides random access. Vector elements can accessed by its
   indexes like C/C++ arrays.

 - Vectors can be returned from functions.

*Vectors X Arrays Declaration*

C/C++ Arrays

#+BEGIN_SRC cpp
const int VECTOR_SIZE = 10;
double xs[VECTOR_SIZE];
#+END_SRC

C/C++ STL Vector

#+BEGIN_SRC cpp
const int VECTOR_SIZE = 10
vector<double> xs;
#+END_SRC

**** Vector Class

*Import vector class*

Add at the top of file. - =#include <vector>=

#+BEGIN_SRC cpp 
#include <iostream>
#include <vector>

using namespace std;
... .... ... ... ... 
#+END_SRC

**** Example 

File: [[file:src/cppStlVector.cpp][file:src/cppStlVector.cpp]]


#+BEGIN_SRC cpp :tangle src/cppStlVector.cpp
  #include <iostream>
  #include <vector>
  #include <cmath>
  #include <string>

  using namespace std;

  /// Pass the vectors by value. It copies the vectors, so passing by
  //  reference does not copies the vectors and it is more efficient.
  //
  vector<double> sumVectors1(vector<double> xs, vector<double> ys){
    vector<double> zs(xs.size());
    
    for (int i = 0; i < xs.size(); i++){
      zs.at(i) = xs.at(i) + ys.at(i);
    }

    return zs;
  }

  vector<double> sumVectors2(vector<double> &xs, vector<double> &ys){
    vector<double> zs(xs.size());
    
    for (int i = 0; i < xs.size(); i++){
      zs.at(i) = xs.at(i) + ys.at(i);
    }

    return zs;
  }


  void printVector1(string name, vector<double> xs){
    cout << name << " = [ "; 
    
    for (int i = 0; i < xs.size(); i++){
      cout << xs.at(i) << " " ;
    }

    cout << "]" << endl;
  }

  void printVector2(string name, vector<double> &xs){
    cout << name << " = [ "; 
    
    for (int i = 0; i < xs.size(); i++){
      cout << xs.at(i) << " " ;
    }

    cout << "]" << endl;
  }

  void printVectorWithIterator(string name, vector<double> &xs){
    cout << name << " = [ "; 
    
    for (vector<double>::iterator i = xs.begin(); i != xs.end(); ++i){
      cout << *i << " " ;    
    }

    cout << "]" << endl;
    
  }


  // Returns the sum of all vector elements.
  double vectorSum(vector<double> &xs){
    double sum = 0;
    
    for (int i = 0; i < xs.size(); i++){
      sum = sum + xs.at(i);
    }

    return sum;
  }

  // Returns the product of all vectors elements.
  double vectorProd(vector<double> &xs){
    double prod = 1.0;
    
    for (int i = 0; i < xs.size(); i++){
      prod = prod + xs.at(i);
    }

    return prod;
  }

  double vectorNorm(vector<double> &xs){
    double sum = 1.0;
    double x   = 0.0;
    
    for (int i = 0; i < xs.size(); i++){
      x = xs.at(i);
      sum = sum + x * x;
    }

    return sqrt(sum);
  }


  double vectorAverage(vector<double> &xs){
    double sum = 1.0;
    
    for (int i = 0; i < xs.size(); i++){    
      sum = sum + xs.at(i);
    }

    return sum / xs.size();
  }


  void vectorAnalytics(string name, vector<double> &xs){
    cout << "\n\nAnalytic for vector " << name     << endl;
    cout << "----------------------------------- " << endl;
    printVector2(name, xs);
    cout << "size    = " << xs.size()         << endl;
    cout << "average = " << vectorAverage(xs) << endl;
    cout << "sum     = " << vectorSum(xs)     << endl;
    cout << "product = " << vectorProd(xs)    << endl;
    cout << "norm    = " << vectorNorm(xs)    << endl;
    
  }


  int main(){
    int size = 6;

    //  Vector initialized from a double array.
    vector<double> xs({1, 2, 3, 5.5, 10.8, 4.5});

    // Vector initialized with all elements set to 0.0
    vector<double> ys(6);

    // Vector intialized with all elements set to 4.0
    vector<double> zs(6, 4.0);

    // Vector with 0 elements.
    vector<double> ks;

    printVector1("xs", xs);

    printVector1("ys", ys);

    printVector2("zs", zs);

    printVectorWithIterator("Print Vector with iteractor - xs", xs);
    
    cout << "xs.size()      = " << xs.size()  << endl ;
    cout << "xs.at(3)       = " << xs.at(3)   << endl ;    
    cout << "xs.at(0)       = " << xs.at(0)   << endl ;
    cout << "xs.at(5)       = " << xs.at(5)   << endl ;      
    cout << "vectorSum(xs)  = " << vectorSum(xs) << endl;
    cout << "vectorNorm(xs) = " << vectorNorm(xs) << endl;
    
    printVector1("sumVectors1(xs, zs) = xs + zs", sumVectors1(xs, zs));
    printVector1("sumVectors2(xs, zs) = xs + zs", sumVectors2(xs, zs));

    cout << "Clear vector xs -> "  ;
    xs.clear();
    printVector2("xs", xs);

    ks.push_back(4.0);
    ks.push_back(5.0);
    ks.push_back(3.0);
    ks.push_back(6.0);
    ks.push_back(7.0);
    ks.push_back(9.3);
    printVector2("ks", ks);
    
    vectorAnalytics("ks", ks);
    
    return 0;
  }

#+END_SRC


Running:

#+BEGIN_SRC sh
$ g++ cppStlVector.cpp -o cppStlVector.bin && ./cppStlVector.bin
xs = [ 1 2 3 5.5 10.8 4.5 ]
ys = [ 0 0 0 0 0 0 ]
zs = [ 4 4 4 4 4 4 ]
Print Vector with iteractor - xs = [ 1 2 3 5.5 10.8 4.5 ]
xs.size()      = 6
xs.at(3)       = 5.5
xs.at(0)       = 1
xs.at(5)       = 4.5
vectorSum(xs)  = 26.8
vectorNorm(xs) = 13.4959
sumVectors1(xs, zs) = xs + zs = [ 5 6 7 9.5 14.8 8.5 ]
sumVectors2(xs, zs) = xs + zs = [ 5 6 7 9.5 14.8 8.5 ]
Clear vector xs -> xs = [ ]
ks = [ 4 5 3 6 7 9.3 ]


Analytic for vector ks
----------------------------------- 
ks = [ 4 5 3 6 7 9.3 ]
size    = 6
average = 5.88333
sum     = 34.3
product = 35.3
norm    = 14.9161


#+END_SRC

*** C++ Lambda functions and Closures

 - [[file:src/cppLambda1.cpp][file:src/cppLambda1.cpp]] 

** Linux - Only
*** Show glibc - file glibc-version.c 

 - file:src/glibc-version.c

Source:

#+BEGIN_SRC c
  /*
  Description: Show glibc Version. 
  OS:          Linux only 

  Compile with:

   $ gcc glibc-version.c -o glibc-version.bin && ./glibc-version.bin 
   glibc version: 2.24

   ,*/
  #include <stdio.h>
  #include <stdlib.h>
  #include <gnu/libc-version.h>

  int main(int argc, char *argv[]) {
    printf("glibc version: %s\n", gnu_get_libc_version());
  }

#+END_SRC

Compile:

#+BEGIN_SRC sh
 gcc glibc-version.c -o glibc-version.bin 
#+END_SRC

Run:

#+BEGIN_SRC sh 
  $ ./src/glibc-version.bin 
  glibc version: 2.24
#+END_SRC
