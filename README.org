#+TITLE: CPP / C++ Review
#+DESCRIPTION: cpp/c++ code examples and demonstrations.

* Review CPP - C++
** CPP
*** Simple assertion testing - file testing1.cpp
   :PROPERTIES:
   :ID:       106aed05-30af-44c1-b3c1-a360b025ac09
   :END:

 - file:src/testing1.cpp - Unit test example cpp files - [[https://drive.google.com/viewerng/viewer?url%3Dhttp://users.csc.calpoly.edu/~djanzen/tdl/AutomatedUnitTesting.pdf][Automated Unit Testing for CPP]]


#+BEGIN_SRC cpp :tangle src/testing.cpp
#include <cassert>

int sum(int min, int max){
  return min + max;
}

int main()
{
  assert(sum(0, 2)  == 3);
  assert(sum(-2, 2) == 0);
  assert(sum(3, 7) == 25);

  return 0;

}
#+END_SRC


#+BEGIN_SRC sh
$ ./testing.bin
testing.bin: testing1.cpp:9: int main(): Assertion `sum(0, 2) == 3' failed.
Aborted
#+END_SRC

*** Assertion in CPP - file assert.cpp                    :assert:test:check:
   :PROPERTIES:
   :ID:       6796c748-6658-49b1-be2e-ad444af89229
   :END:


File: file:src/assert.cpp

#+BEGIN_SRC cpp :tangle src/assert.cpp
// Description: Assertion demonstration in C++.
// Author:      Caio Rodrigues
// File:        assert.cpp
// Compile: g++ assert.cpp -o assert.bin
//

#include <cassert>    // Assertion
#include <iostream>   // Standard library

int main (int argc, char * argv[]) {

  // Check argc and exit if not enough arguments are provided to avoid segmentation fault.
  //
  if (argc != 2){
    std::cout << "Usage: ./" << argv[0] << "[n]" << std::endl;
    std::cout << "where [n] is a number > 0. If n * n != 25 the assertion fails." << std::endl;

    exit(0); // exit(1) - Return status code 1 - Indicating failure.
  }

  int i = atoi(argv[1]);
  int j = i * i ;

  assert (j == 25);

  std::cout << "continuing" << std::endl;

  exit(0); // exit(0) - Return status code 0 - Indicating success.
}

#+END_SRC

This file demonstrate assertion in C++. If the square of input
argument is not 25 it throws an assertion error.

Compile:

#+BEGIN_SRC sh
$ g++ assert.cpp -o assert.bin
#+END_SRC

*Running:*

No arguments - print help

#+BEGIN_SRC sh
./assert.bin
Usage: ././assert.bin[n]
where [n] is a number > 0. If n * n != 25 the assertion fails.
#+END_SRC

Passing 4 as argument.

#+BEGIN_SRC sh
./assert.bin 4
assert.bin: assert.cpp:24: int main(int, char**): Assertion `j == 25' failed.
#+END_SRC

Passing 10 as argument

#+BEGIN_SRC sh
./assert.bin 10
assert.bin: assert.cpp:24: int main(int, char**): Assertion `j == 25' failed.

#+END_SRC

Passing 5 as argument. 5 * 5 == 25. Ok. The assertion doesn't fail.

#+BEGIN_SRC sh
./assert.bin 5
continuing
#+END_SRC
*** Parse number                                     :atoi:atof:parse:number:
   :PROPERTIES:
   :ID:       170ef7e0-8f02-4bc3-afb6-38b2ee8810d6
   :END:

Shows how to parse number with atoi, atof and so on.

File: file:src/numberParse.cpp

#+BEGIN_SRC cpp :tangle src/numberParse.cpp
// Description: atoi, atof, strtol demonstration.
// Note: Convert string to integer, double and long integer.
// Tags: atoi, atof, strtol
//

#include <cassert>
#include <iostream>

using namespace std;

int main (){

  cout << "\nAtoi - parse int 32 bits" << endl;

  cout << "atoi(\"2342\")    = " << atoi("2342")  << endl;
  cout << "atoi(\"-2323\")   = " << atoi("-2323") << endl;
  cout << "atoi(\"failed\")  = " << atoi("failed") << endl;
  cout << "atoi(\"12xy346\") = " << atoi("12xy346") << endl;

  cout << "\nAtof - parse float/double" << endl;

  cout <<  "atof(\"100.23\")              = "  << atof("100.23") << endl;
  cout <<  "atof(\"-20.015e3\")           = "  << atof("-20.015e3") << endl;
  cout <<  "atof(\"100.134354blablah\")   = "  << atof("100.134354blablah") << endl;
  cout <<  "atof(\"failed0.3123garbage\") = "  << atof("failed0.3123garbage") << endl;

  return 0;
}
#+END_SRC

Running:

#+BEGIN_SRC sh
./g++ numberParse.cpp -o numberParse.bin && ./numberParse.bin

Atoi - parse int 32 bits
atoi("2342")    = 2342
atoi("-2323")   = -2323
atoi("failed")  = 0
atoi("12xy346") = 12

Atof - parse float/double
atof("100.23")              = 100.23
atof("-20.015e3")           = -20015
atof("100.134354blablah")   = 100.134
atof("failed0.3123garbage") = 0
#+END_SRC
*** Functions with Arrays in C++
    :PROPERTIES:
    :ID:       a89d5099-af3a-4034-8331-628fe59a0eb7
    :END:

  - [[file:src/arraysFun.cpp][file:src/arraysFun.cpp]]

#+BEGIN_SRC cpp :tangle src/arraysFun.cpp
#include <iostream>  // Basic IO functions
#include <cmath>     // C-math functions such as sqrt, pow ...
#include <cassert>   // Assertions

using namespace std;

// Function prototypes
//---------------------------------//

double scalarProduct   (double [], double [], int);
double vectorSum       (double [], int);
double vectorNorm      (double [], int);
void   printVectorVert (double xs[], int size);

//  Main function
//-------------------------------

int main()
{
  int size = 4 ;
  double v1[] = {1.0, 2.0, 3.0, 4.0} ;
  double v2[] = {3.0, 4.0, 5.0, 6.0} ;

  cout << "\n\nVector v1 = " << endl ;
  printVectorVert(v1, size);

  cout << "\n\nVector v2 = " << endl ;
  printVectorVert(v2, size);

  cout << "\n\nScalar product is = " << scalarProduct(v1, v2, size) << endl;

  cout << "Vector v1 sum is  = " << vectorSum(v1, size) << endl;

  cout << "Vector v2 Norm is = " << vectorNorm(v1, size) << endl;

  assert(scalarProduct(v1, v2, size) == 50.0);

  return 0 ; // Return 0 as status code.
}

//  Functions Implementations
// -------------------------------- //

double scalarProduct(double xs[], double ys[], int size){
  double sum = 0.0;

    for (int i = 0; i <= size -1; i++){
      sum = sum + xs[i] * ys[i];
    }
  return sum;
}

double vectorSum(double xs[], int size){
  double sum = 0.0 ;

  for (int i = 0; i <= size - 1; i++){
    sum = sum + xs[i];
  }
  return sum;
}


double vectorNorm(double xs[], int size){
  double sum = 0.0 ;

  for (int i = 0; i <= size - 1; i++){
    sum = sum + xs[i] * xs[i];
  }
  return sqrt(sum);
}


void printVectorVert(double xs[], int size){
  for (int i = 0; i <= size -1; i++){
    cout << "v[" << i << "] = " << xs[i] << endl ;
  }
}
#+END_SRC

Program output:

#+BEGIN_SRC sh
g++ arraysFun.cpp -o arraysFun.bin && ./arraysFun.bin


Vector v1 =
v[0] = 1
v[1] = 2
v[2] = 3
v[3] = 4


Vector v2 =
v[0] = 3
v[1] = 4
v[2] = 5
v[3] = 6


Scalar product is = 50
Vector v1 sum is  = 10
Vector v2 Norm is = 5.47723


#+END_SRC

** Linux - Only
*** Show glibc - file glibc-version.c 

 - file:src/glibc-version.c

Source:

#+BEGIN_SRC c
  /*
  Description: Show glibc Version. 
  OS:          Linux only 

  Compile with:

   $ gcc glibc-version.c -o glibc-version.bin && ./glibc-version.bin 
   glibc version: 2.24

   ,*/
  #include <stdio.h>
  #include <stdlib.h>
  #include <gnu/libc-version.h>

  int main(int argc, char *argv[]) {
    printf("glibc version: %s\n", gnu_get_libc_version());
  }

#+END_SRC

Compile:

#+BEGIN_SRC sh
 gcc glibc-version.c -o glibc-version.bin 
#+END_SRC

Run:

#+BEGIN_SRC sh 
  $ ./src/glibc-version.bin 
  glibc version: 2.24
#+END_SRC
