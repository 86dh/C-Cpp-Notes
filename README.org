#+TITLE: CPP / C++ Review
#+DESCRIPTION: cpp/c++ code examples and demonstrations.

* Review CPP - C++
** CPP
*** Simple assertion testing - file testing1.cpp
   :PROPERTIES:
   :ID:       106aed05-30af-44c1-b3c1-a360b025ac09
   :END:

 - file:src/testing1.cpp - Unit test example cpp files - [[https://drive.google.com/viewerng/viewer?url%3Dhttp://users.csc.calpoly.edu/~djanzen/tdl/AutomatedUnitTesting.pdf][Automated Unit Testing for CPP]]


#+BEGIN_SRC cpp :tangle src/testing.cpp
#include <cassert>

int sum(int min, int max){
  return min + max;
}

int main()
{
  assert(sum(0, 2)  == 3);
  assert(sum(-2, 2) == 0);
  assert(sum(3, 7) == 25);

  return 0;

}
#+END_SRC


#+BEGIN_SRC sh
$ ./testing.bin
testing.bin: testing1.cpp:9: int main(): Assertion `sum(0, 2) == 3' failed.
Aborted
#+END_SRC

*** Assertion in CPP - file assert.cpp                    :assert:test:check:
   :PROPERTIES:
   :ID:       6796c748-6658-49b1-be2e-ad444af89229
   :END:


File: file:src/assert.cpp

#+BEGIN_SRC cpp :tangle src/assert.cpp
// Description: Assertion demonstration in C++.
// Author:      Caio Rodrigues
// File:        assert.cpp
// Compile: g++ assert.cpp -o assert.bin
//

#include <cassert>    // Assertion
#include <iostream>   // Standard library

int main (int argc, char * argv[]) {

  // Check argc and exit if not enough arguments are provided to avoid segmentation fault.
  //
  if (argc != 2){
    std::cout << "Usage: ./" << argv[0] << "[n]" << std::endl;
    std::cout << "where [n] is a number > 0. If n * n != 25 the assertion fails." << std::endl;

    exit(0); // exit(1) - Return status code 1 - Indicating failure.
  }

  int i = atoi(argv[1]);
  int j = i * i ;

  assert (j == 25);

  std::cout << "continuing" << std::endl;

  exit(0); // exit(0) - Return status code 0 - Indicating success.
}

#+END_SRC

This file demonstrate assertion in C++. If the square of input
argument is not 25 it throws an assertion error.

Compile:

#+BEGIN_SRC sh
$ g++ assert.cpp -o assert.bin
#+END_SRC

*Running:*

No arguments - print help

#+BEGIN_SRC sh
./assert.bin
Usage: ././assert.bin[n]
where [n] is a number > 0. If n * n != 25 the assertion fails.
#+END_SRC

Passing 4 as argument.

#+BEGIN_SRC sh
./assert.bin 4
assert.bin: assert.cpp:24: int main(int, char**): Assertion `j == 25' failed.
#+END_SRC

Passing 10 as argument

#+BEGIN_SRC sh
./assert.bin 10
assert.bin: assert.cpp:24: int main(int, char**): Assertion `j == 25' failed.

#+END_SRC

Passing 5 as argument. 5 * 5 == 25. Ok. The assertion doesn't fail.

#+BEGIN_SRC sh
./assert.bin 5
continuing
#+END_SRC
*** Parse number                                     :atoi:atof:parse:number:
   :PROPERTIES:
   :ID:       170ef7e0-8f02-4bc3-afb6-38b2ee8810d6
   :END:

Shows how to parse number with atoi, atof and so on.

File: file:src/numberParse.cpp

#+BEGIN_SRC cpp :tangle src/numberParse.cpp
// Description: atoi, atof, strtol demonstration.
// Note: Convert string to integer, double and long integer.
// Tags: atoi, atof, strtol
//

#include <cassert>
#include <iostream>

using namespace std;

int main (){

  cout << "\nAtoi - parse int 32 bits" << endl;

  cout << "atoi(\"2342\")    = " << atoi("2342")  << endl;
  cout << "atoi(\"-2323\")   = " << atoi("-2323") << endl;
  cout << "atoi(\"failed\")  = " << atoi("failed") << endl;
  cout << "atoi(\"12xy346\") = " << atoi("12xy346") << endl;

  cout << "\nAtof - parse float/double" << endl;

  cout <<  "atof(\"100.23\")              = "  << atof("100.23") << endl;
  cout <<  "atof(\"-20.015e3\")           = "  << atof("-20.015e3") << endl;
  cout <<  "atof(\"100.134354blablah\")   = "  << atof("100.134354blablah") << endl;
  cout <<  "atof(\"failed0.3123garbage\") = "  << atof("failed0.3123garbage") << endl;

  return 0;
}
#+END_SRC

Running:

#+BEGIN_SRC sh
./g++ numberParse.cpp -o numberParse.bin && ./numberParse.bin

Atoi - parse int 32 bits
atoi("2342")    = 2342
atoi("-2323")   = -2323
atoi("failed")  = 0
atoi("12xy346") = 12

Atof - parse float/double
atof("100.23")              = 100.23
atof("-20.015e3")           = -20015
atof("100.134354blablah")   = 100.134
atof("failed0.3123garbage") = 0
#+END_SRC
** Linux - Only
*** Show glibc - file glibc-version.c 

 - file:src/glibc-version.c

Source:

#+BEGIN_SRC c
  /*
  Description: Show glibc Version. 
  OS:          Linux only 

  Compile with:

   $ gcc glibc-version.c -o glibc-version.bin && ./glibc-version.bin 
   glibc version: 2.24

   ,*/
  #include <stdio.h>
  #include <stdlib.h>
  #include <gnu/libc-version.h>

  int main(int argc, char *argv[]) {
    printf("glibc version: %s\n", gnu_get_libc_version());
  }

#+END_SRC

Compile:

#+BEGIN_SRC sh
 gcc glibc-version.c -o glibc-version.bin 
#+END_SRC

Run:

#+BEGIN_SRC sh 
  $ ./src/glibc-version.bin 
  glibc version: 2.24
#+END_SRC
