#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ Notes - Boost Libraries and complementarty libraries
#+DESCRIPTION: cpp/c++ c++ design patterns gneric programming object oriented metaprogramming
#+STARTUP: content 

- [[wiki:index][Index]]

* Boost Libraries 
** Boost Libraries already in C++ ISO standard 

Some Boost libraries are redundant as they are already in the C++ ISO
standard. However, it is worth using them if a compiler to new
C++ standards is not available. 

#+CAPTION: Boost libraries aready in C++ ISO Standard 
|-------------------+----------------------------------------------------+---------------------------------------------|
| Boost Library     | C++ Standard                                       | Description                                 |
|                   | equivalent                                         |                                             |
|-------------------+----------------------------------------------------+---------------------------------------------|
| *Added since C++11* |                                                    |                                             |
|-------------------+----------------------------------------------------+---------------------------------------------|
| Boost.Chrono      | [[https://en.cppreference.com/w/cpp/chrono][std::chrono]]                                        | Time interval                               |
| Boost.Array       | [[https://en.cppreference.com/w/cpp/container/array][std::array]]                                         | Fixed-size non-dynamically allocated array. |
| Boost.Foreach     | C++11 ranged for                                   |                                             |
| [[https://www.boost.org/doc/libs/1_65_1/doc/html/function.html][Boost.Function]]    | [[https://en.cppreference.com/w/cpp/utility/functional/function][std::function]]                                      | Function type erasure and/or callbacks      |
| [[https://www.boost.org/doc/libs/1_70_0/libs/bind/doc/html/bind.html][Boost::bind]]       | [[https://en.cppreference.com/w/cpp/utility/functional/bind][std::bind]]                                          |                                             |
| Boost.Heap        | std::priority_queue                                |                                             |
| Boost.Intrusive   | STL move constructor  and move assignment operator |                                             |
| [[https://www.boost.org/doc/libs/1_62_0/doc/html/ratio.html][Boost.Ratio]]       | [[https://en.cppreference.com/w/cpp/numeric/ratio/ratio][std::ratio]]                                         |                                             |
| [[https://www.boost.org/doc/libs/1_63_0/doc/html/move.html][Boost.Move]]        | [[https://en.cppreference.com/w/cpp/utility/move][std::move]]                                          |                                             |
| Boost.SaticAssert | [[https://en.cppreference.com/w/cpp/language/static_assert][static_assert]]                                      |                                             |
|                   |                                                    |                                             |
| [[https://www.boost.org/doc/libs/1_69_0/libs/core/doc/html/core/ref.html][Boost.Ref]]         | Reference warapers in <functional> header          |                                             |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_random.html][Boost.Random]]      | Header <[[http://www.cplusplus.com/reference/random/][<random>]]                                   |                                             |
| [[https://www.boost.org/doc/libs/1_69_0/libs/regex/doc/html/index.html][Boost.Regex]]       | Library: [[https://en.cppreference.com/w/cpp/regex][<regex>]]  (std::regex)                     | Regular expressions library                 |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/thread.html][Boost.Thread]]      | Library: [[https://en.cppreference.com/w/cpp/thread][<thread>]] (std::thread)                    |                                             |
|                   |                                                    |                                             |
|-------------------+----------------------------------------------------+---------------------------------------------|
| *Added since C++17* |                                                    |                                             |
|-------------------+----------------------------------------------------+---------------------------------------------|
| [[https://www.boost.org/doc/libs/1_69_0/libs/optional/doc/html/index.html][Boost.Optional]]    | [[https://en.cppreference.com/w/cpp/utility/optional][std::optional]]                                      |                                             |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/any.html][Boost.Any]]         | [[https://en.cppreference.com/w/cpp/utility/any][std::any]]                                           |                                             |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/variant.html][Boost.Variant]]     | [[https://en.cppreference.com/w/cpp/utility/variant][std::variant]]                                       |                                             |
| [[https://www.boost.org/doc/libs/1_69_0/libs/filesystem/doc/index.htm][Boost.Filesystem]]  | Library: [[https://en.cppreference.com/w/cpp/filesystem][filesystem]]                                |                                             |
|                   |                                                    |                                             |
|-------------------+----------------------------------------------------+---------------------------------------------|

Boost Containers already in STL and C++ standards: 

#+CAPTION: Boost containers and functions aready incorpored into STL and C++ ISO Standard.
|-------------------------+------------------------+---------------+----------------------------------------------------------|
| Boost container or type | STL equivalent type    | STL Header    | Description                                              |
|-------------------------+------------------------+---------------+----------------------------------------------------------|
| *Since C++11*             |                        |               |                                                          |
|-------------------------+------------------------+---------------+----------------------------------------------------------|
| boost lambda            | C++11 lambdas          | -             | Lambda "function" constructor.                           |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/function.html][boost::function]]         | [[https://en.cppreference.com/w/cpp/utility/functional/function][std::function]]          | <functional>  | Container for function or method-call type erasure.      |
| [[https://www.boost.org/doc/libs/1_69_0/libs/bind/doc/html/bind.html][boost::bind]]             | [[https://en.cppreference.com/w/cpp/utility/functional/bind][std::bind]]              | <functional>  | Function wrappers.                                       |
| [[https://www.boost.org/doc/libs/1_70_0/libs/core/doc/html/core/ref.html][boost::ref]], boost::cref | [[https://en.cppreference.com/w/cpp/utility/functional/ref][std::ref and std::cref]] | <functional>> | Reference wrappers in header <functional>                |
| [[https://www.boost.org/doc/libs/1_70_0/doc/html/boost/movelib/unique_ptr.html][boost::unique_ptr]]       | [[https://en.cppreference.com/w/cpp/memory/unique_ptr][std::unique_ptr]]        | <memory>      |                                                          |
| [[https://www.boost.org/doc/libs/1_69_0/libs/smart_ptr/doc/html/smart_ptr.html#shared_ptr][boost::shared_ptr]]       | [[https://en.cppreference.com/w/cpp/memory/shared_ptr][std::shared_ptr]]        | <memory>      |                                                          |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/array.html][boost::array]]            | std::array             |               | Non-heap allocated fixed-size array, similar to C-array. |
|-------------------------+------------------------+---------------+----------------------------------------------------------|
| *Since C++17*             |                        |               |                                                          |
|-------------------------+------------------------+---------------+----------------------------------------------------------|
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/any.html][boost::any]]              | [[https://en.cppreference.com/w/cpp/utility/any][std::any]]               | <any>         | Type erasure container for storing any copiable type.    |
| [[https://www.boost.org/doc/libs/1_69_0/libs/optional/doc/html/index.html][boost::optional]]         | [[https://en.cppreference.com/w/cpp/utility/optional][std::optional]]          | <optional>    | Container which may or may not have any value.           |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/variant.html][boost::variant]]          | [[https://en.cppreference.com/w/cpp/utility/variant][std::variant]]           | <variant>     | Discriminated union, a better C-Union                    |
|                         |                        |               |                                                          |
|-------------------------+------------------------+---------------+----------------------------------------------------------|


Note: 
 + Reference wrappers in <functional> header:
   + [[https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper][std::reference_wrapper]]
   + [[https://en.cppreference.com/w/cpp/utility/functional/ref][std::ref, std::cref]]

 +  [[https://www.boost.org/doc/libs/1_69_0/libs/bind/doc/html/bind.html][boost::bind]] and std::bind => Function for building lambda
   functions out of functions with partial arguments, member function
   pointers and pointer to member variables.

See:
 + [[https://stackoverflow.com/questions/7241993/is-it-smart-to-replace-boostthread-and-boostmutex-with-c11-equivalents][c++ -
   Is it smart to replace boost::thread and boost::mutex with c++11
   equivalents? - Stack Overflow]]
** Compiling Boost with CMake 

Some boost libraries are not header-only and requires linking against
a pre-compiled static or shared library. The compilation procedure can
be simplified with the CMake module [[https://cmake.org/cmake/help/latest/module/FindBoost.html][FindBoost.]]

Some non header-only Boost libraries are:
 + date_time 
 + iostream 
 + filesystem
 + program_options
 + system (for Boost ASIO)

 *Sample project:*

File: CMakeLists.txt 
  + Note: It is assumed that Boost is already installed in the system.

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(cmake-boost)
  #======================================#

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  set(Boost_USE_STATIC_LIBS ON)

  find_package(Boost REQUIRED date_time serialization )

  add_executable(boost-app main.cpp)
  target_link_libraries(boost-app Boost::date_time Boost::serialization)
#+END_SRC

File: main.cpp 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <fstream>
  #include <string>

  #include <boost/date_time/gregorian/gregorian.hpp> 
  #include<boost/archive/text_oarchive.hpp> 
  #include <boost/archive/text_iarchive.hpp>

  namespace gr = boost::gregorian;
  namespace dt = boost::date_time;

  class Waypoint{
  private:
      std::string m_name;
      double      m_latitude;
      double      m_longitude;

      // Required by boost to access private data of this class
      friend class boost::serialization::access;

  public:

      Waypoint(std::string const& name, double latitude, double longitude):
          m_name(name)
        , m_latitude(latitude)
        , m_longitude(longitude)
      {
      }

      Waypoint(): Waypoint("<EMPTY>", 0.0, 0.0)
      {
      }

      friend std::ostream& operator<<(std::ostream& os, Waypoint const& rhs)
      {
          return os << " Waypoint{ location = "
                    << rhs.m_name << " ; lat = "
                    << rhs.m_latitude << " ; long = "
                    << rhs.m_longitude << " } ";
      }

  private:

      // Required by boost serialize
      template<typename Archive>
      void serialize(Archive& ar, const unsigned int version)
      {
          ar & m_name;
          ar & m_latitude;
          ar & m_longitude;
      }
  };


  int main()
  {
      std::puts("=========== Boost Date Time ===============\n");

      auto d1 = gr::date(2009, 10, 20);
      std::cout << " date1 = " << d1 << std::endl;

      auto mdate = gr::date(2012, 06, 21);
      std::string text = " Date mdate is equal to: " + gr::to_iso_string(mdate) + "\n";
      std::cout << " Text => " << text;

      std::puts("=========== Boost Serialization ===============\n");

      // Note: this stream fs could be replaced by a real file stream.
      //  std::ofstream fs("archive.dat");
      std::stringstream fs; // Mock-file

      // Serialization
      {
          Waypoint wp1{"Frankfurt", 50.1109, 8.6821};
          Waypoint wp2{"Bern",      40.9480, 7.4474};

          // The stream buffer is only written to the destination when
          // this object goes out of scope and the destructor is called.
          boost::archive::text_oarchive archive(fs);
          archive << wp1 << wp2;
      }
      std::cout << "Serialized data in 'disk' = " << fs.str() << std::endl;


      std::puts("=========== Boost Deserialization ===============\n");

      // Note: Here fs could be replaced by a real input file stream
      // std::ifstream
      {
          Waypoint wpA, wpB;
          boost::archive::text_iarchive archive(fs);
          archive >> wpA >> wpB;
          std::cout << "wpA = " << wpA << std::endl;
          std::cout << "wpB = " << wpB << std::endl;
      }

      return 0;
  }
#+END_SRC

Program output: 

#+BEGIN_SRC sh 
   =========== Boost Date Time ===============

    date1 = 2009-Oct-20
    Text =>  Date mdate is equal to: 20120621
   =========== Boost Serialization ===============

   Serialized data in 'disk' = 22 serialization::archive 16 0 0 9 Frankfurt 5.01109000000000009e+01 8.68210000000000015e+00 4 Bern 4.09480000000000004e+01 7.44740000000000002e+00

   =========== Boost Deserialization ===============

   wpA =  Waypoint{ location = Frankfurt ; lat = 50.1109 ; long = 8.6821 } 
   wpB =  Waypoint{ location = Bern ; lat = 40.948 ; long = 7.4474 } 
#+END_SRC

** Compiling Boost with CMake and Conan 

Conan package manager allows a project use mutiple versions of Boost
libraries without prior manual installation that is time consuming as
the library has to be set up for a specific version and
compiler. Conan also provides modular Boost packages that allows
installing individual boost libraries whithout installing everything. 

 *Boost Libraries (whole-package) - Conan References*
 
 + Boost version 1.64.0 / [[https://bintray.com/conan-community/conan/boost%253Aconan/1.64.0%253Astable][boost/1.64.0@conan/stable]]

 + Boost version 1.68.0 / [[https://bintray.com/conan-community/conan/boost%253Aconan/1.68.0%253Astable][boost/1.68.0@conan/stable]]

 + Boost version 1.69.0 / [[https://bintray.com/conan-community/conan/boost%253Aconan/1.69.0%253Astable][boost/1.69.0@conan/stable]]

 + Boost version 1.7.0  / [[https://bintray.com/conan-community/conan/boost%253Aconan/1.70.0%253Astable][boost/1.70.0@conan/stable]] 


 *Modular packages for Boost Libraries* 

 * [[https://bintray.com/bincrafters/public-conan/boost_asio%253Abincrafters][boost_asio:bincrafters]]
   * Portable networking and other low-level I/O, including sockets,
     timers, hostname resolution, socket iostreams, serial ports, file
     descriptors and Windows HANDLEs, from Chris Kohlhoff
   * Sample conan references:
     + boost_asio/1.69.0@bincrafters/stable
     + boost_asio/1.68.0@bincrafters/stable
     + boost_asio/1.67.0@bincrafters/stable

 * [[https://bintray.com/bincrafters/public-conan/boost_fiber%253Abincrafters][boost_fiber:bincrafters]]
   * (C++11) Userland threads library, from Oliver Kowalke

 * [[https://bintray.com/bincrafters/public-conan/boost_ratio%253Abincrafters][boost_ratio::bincrafters]]
   + Sample conan reference:  boost_ratio/1.69.0@bincrafters/stable 

 * [[https://bintray.com/bincrafters/public-conan/boost_spirit%253Abincrafters][boost_spirit:bincrafters]]
   * Parser framework represents parsers directly as EBNF grammars in
     inlined C++, from Joel de Guzman, Hartmut Kaiser and Dan Nuffer
   * Sample conan reference: boost_spirit/1.69.0@bincrafters/stable

 * [[https://bintray.com/bincrafters/public-conan/boost_serialization%253Abincrafters][boost_serialization::bincrafters]]

 * [[https://bintray.com/bincrafters/public-conan/boost_tokenizer%253Abincrafters][boost_tokenizer:bincrafters]]
   * Break of a string or other character sequence into a series of
     tokens, from John Bandela.

 * [[https://bintray.com/bincrafters/public-conan/boost_type_index%253Abincrafters][boost_type_index:bincrafters]]
   * Runtime and Compile time copyable type info, from Antony Polukhin

 * [[https://bintray.com/bincrafters/public-conan/boost_system%253Abincrafters][boost_system:bincrafters]] 
   * Operating system support, including the diagnostics support that
     will be part of the C++0x standard library, from Beman Dawes
   * Sample conan reference:  boost_system/1.69.0@bincrafters/stable

 * [[https://bintray.com/bincrafters/public-conan/boost_statechart%253Abincrafters][boost_statechart:bincrafters]]
   * Arbitrarily complex finite state machines can be implemented in
     easily readable and maintainable C++ code, from Andreas Huber
     Dönni.
   * Sample conan reference:  boost_statechart/1.69.0@bincrafters/stable

 * [[https://bintray.com/bincrafters/public-conan/boost_stacktrace%253Abincrafters][boost_stacktrace:bincrafters]]
   * Sample conan reference:  boost_stacktrace/1.69.0@bincrafters/stable 

 * [[https://bintray.com/bincrafters/public-conan/boost_range%253Abincrafters][boost_range::bincrafters]]

 * [[https://bintray.com/bincrafters/public-conan/boost_scope_exit%253Abincrafters][boost_scope_exit:bincrafters]]
   + Execute arbitrary code at scope exit, from Alexander Nasonov

 * [[https://bintray.com/bincrafters/public-conan/boost_signals2%253Abincrafters][boost_signals2:bincrafters]]
   + Managed signals & slots callback implementation (thread-safe
     version 2), from Frank Mori Hess.
   + Sample Reference: boost_signals2/1.69.0@bincrafters/stable 

 * [[https://bintray.com/bincrafters/public-conan/boost_smart_ptr%253Abincrafters][boost_smart_ptr:bincrafters]]
   * Smart pointer class templates, from Greg Colvin, Beman Dawes,
     Peter Dimov, Darin Adler and Glen Fernandes
   * Sample Reference:  boost_smart_ptr/1.69.0@bincrafters/stable

 * [[https://bintray.com/bincrafters/public-conan/boost_sort%253Abincrafters][boost_sort:bincrafters]]
   * High-performance templated sort functions, from Steven Ross
   * Sample Reference:  boost_sort/1.69.0@bincrafters/stable

 * [[https://bintray.com/bincrafters/public-conan/boost_tti%253Abincrafters][boost_tti:bincrafters]] 
   * Type Traits Introspection library, from Edward Diener


 *CMakeLists.txt* example: 

 + Note: It uses Boost version 1.7.0 (Conan reference:
   boost/1.70.0@conan/stable) and the sub-packages
   Boost::serialization and Boost::date_time.

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 2.8)
  project(conan-boost)

  #========================================#

  set(CMAKE_CXX_STANDARD 17)

  # set(CMAKE_VERBOSE_MAKEFILE ON CACHE BOOL "ON")
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #=========== Conan Bootstrap =================#

  message( [INFO] " CMAKE_BUILD_TYPE = ${CMAKE_BUILD_TYPE}")

  # Download automatically, you can also just copy the conan.cmake file
  if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
     message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
     file(DOWNLOAD "https://github.com/conan-io/cmake-conan/raw/v0.13/conan.cmake"
                   "${CMAKE_BINARY_DIR}/conan.cmake")
  endif()

  include(${CMAKE_BINARY_DIR}/conan.cmake)
  set(CONAN_PROFILE default)

  conan_cmake_run( REQUIRES
                   boost/1.70.0@conan/stable
                   BASIC_SETUP
                   BUILD missing )

  #=========== Find Package ================#

  set(Boost_USE_STATIC_LIBS ON)

  find_package(Boost REQUIRED date_time serialization )

  #=========== Targets ======================#

  add_executable(conan-boost-app main.cpp)
  target_link_libraries(conan-boost-app Boost::date_time Boost::serialization)
#+END_SRC


See: 

 * Announcement: Boost Package Deprecations
   + https://bincrafters.github.io/2018/02/19/Boost-package-deprecations/

** Boost Format 

The boost library format provides a type-safe printf-like notation
which is concise as the old C-printf functions (printf, sprintf,
fprintf) and less intrusive and verbose than the C++ (<<) insertion
operator. 

 + Documentation: [[https://www.boost.org/doc/libs/1_69_0/libs/format/doc/format.html][Boost format]]
 + Header: <boost/format.hpp>
 + Functions:
   + boost::str
   + boost::format

Using the library: 
 + As the library is a header-only library as almost all boost
   libraries. All what is needed to use it is just include the
   following header.

#+BEGIN_SRC cpp 
  #include <boost/format.hpp>
#+END_SRC

Example 1: Test in CERN's ROOT REPL.

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <cmath>
  #include <boost/format.hpp>
  double x = 10.0;

  >> boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") % x % std::sqrt(x) % std::log2(x)
  (boost::basic_format &) @0x7ffcfe86fbd8

  >> auto fmt = boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") % x % std::sqrt(x) % std::log2(x);
  >> fmt
  (boost::basic_format<char, std::char_traits<char>, std::allocator<char> > &) @0x7f8c7b52b020
  >>  

  >> std::cout << fmt << "\n";
   x = 10 ; sqrt(x) = 3.16228 ; log2(x) = 3.32193

  >> std::cout << boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") % x % std::sqrt(x) % std::log2(x) << "\n";
   x = 10 ; sqrt(x) = 3.16228 ; log2(x) = 3.32193
  >> 
#+END_SRC

Example 2: Multiline code. 

#+BEGIN_SRC cpp 
  // Pasting the following code block in the REPL between curly
  // brackets, including them.
  {
   std::cout << boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") 
                % x % std::sqrt(x) % std::log2(x) << "\n";
  } 
  // Output:
  x = 10 ; sqrt(x) = 3.16228 ; log2(x) = 3.32193
#+END_SRC

Example 3.A: Turn format object into std::string.

#+BEGIN_SRC cpp 
  >> double z = M_PI_2;
  >> z
  (double) 1.5707963

  >> auto fm = boost::format("operation = %1% - z = %2% %1%(%2%) = %3%") % "sin" % z % std::sin(z) ;
  >> std::cout << "fm = " << fm << "\n";
  fm = operation = sin - z = 1.5708 sin(1.5708) = 1

  >> std::string result = fm.str();
  >> result
  (std::string &) "operation = sin - z = 1.5708 sin(1.5708) = 1"
#+END_SRC

Example 3.B: 

#+BEGIN_SRC cpp 
 >> std::string result2 = boost::str(boost::format("operation = %1% - z = %2% %1%(%2%) = %3%") % "sin" % z % std::sin(z))

 >> result2
 (std::string &) "operation = sin - z = 1.5708 sin(1.5708) = 1"
#+END_SRC
** Boost Lexical_cast 

Boost lexical cast is header-only library for converting from
built-int types to string and from string to built-in types. 

 + Documentation: [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_lexical_cast.html#boost_lexical_cast.motivation][Boost Lexical Cast]] 
 + Header: <boost/format.hpp>
 + Functions:
   + boost::lexical_cast 

Example: 

 + *Headers and namespace:*

#+BEGIN_SRC cpp 
  #include <boost/lexical_cast.hpp>

  // Namespace alias 
  namespace b = boost;
#+END_SRC

 *Basic conversions:*

#+BEGIN_SRC cpp 
  >> b::lexical_cast<int>("456")
  (int) 456

  >> b::lexical_cast<double>(".4615e3")
  (double) 461.50000

  >> b::lexical_cast<double>("inf")
  (double) inf

  >> b::lexical_cast<long double>("34e5")
  (long double) 3400000.0L
  >> 

  >> b::lexical_cast<double>("inf error")
  Error in <TRint::HandleTermInput()>: 
  boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_lexical_cast> > 
   caught: bad lexical cast: source type value could not be interpreted as target

  >> b::lexical_cast<double>(" asdsas ")
  Error in <TRint::HandleTermInput()>: 
  boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_lexical_cast> > 
  caught: bad lexical cast: source type value could not be interpreted as target
    >> 

  >> b::lexical_cast<long double>(" 100 ")
  Error in <TRint::HandleTermInput()>: 
   boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_lexical_cast> > 
   caught: bad lexical cast: source type value could not be interpreted as target
  >> 
#+END_SRC

 *Catch exceptions:*

#+BEGIN_SRC cpp 
  #include <cmath> 

  void PrintSquareRoot(const char* number_str){
       try {
          double x = boost::lexical_cast<double>(number_str);
          std::cout << "x = " << x
                    << " ; sqrt(x) = " << std::sqrt(x)
                    << "\n";
       } catch(boost::bad_lexical_cast const& ex)
       {
          std::cerr << " [ERROR] " << ex.what() << "\n";
       }
  }
#+END_SRC

Testing: 

#+BEGIN_SRC cpp 
  >> PrintSquareRoot("34.34")
  x = 34.34 ; sqrt(x) = 5.86003

  >> PrintSquareRoot("-125.0")
  x = -125 ; sqrt(x) = -nan

  >> PrintSquareRoot("-12dsad 5.0")
   [ERROR] bad lexical cast: source type value could not be interpreted as target

  >> PrintSquareRoot(" ")

  >> PrintSquareRoot(" 100 ")
   [ERROR] bad lexical cast: source type value could not be interpreted as target
  >> 
#+END_SRC

 *Function try_lexical_convert* 

Convert from string to built-in type without exceptions. 

Pseudo-signature: 
 + Returns true if succeed to convert source type to target type and
   then sets the result variable. Otherwise, the function returns
   false. 

#+BEGIN_SRC cpp 
  namespace boost::conversion 
  {
    template<typename Target, typename Source>
    bool try_lexical_convert(Source const& arg, Targe& result);
  }
#+END_SRC

Testing: 

#+BEGIN_SRC cpp 
  >> double z = 0.0
  (double) 0.0000000

  >> boost::conversion::try_lexical_convert("200.34", z)
  (bool) true
  >> z
  (double) 200.34000

  >> boost::conversion::try_lexical_convert("200 error .34", z)
  (bool) false
  >> z
  (double) 200.00000

  >> boost::conversion::try_lexical_convert("not-a-number", z)
  (bool) false
  >> z
  (double) 0.0000000
#+END_SRC
** Boost string algo 

Provides lots of useful string utility functions that are missing in
the standard library. 

 + Documentation:
   + [[https://www.boost.org/doc/libs/1_69_0/doc/html/string_algo/usage.html][Boost String Main Documentation]]
   + [[https://www.boost.org/doc/libs/1_69_0/doc/html/string_algo/quickref.html][Quick Referece card.]]
 + Header: <boost/algorithm/string.hpp>
 + Functions:
   + boost::to_upper
   + boost::to_lower
   + boost::trim
   + boost::iends_with
   + boost::istarts_with
   + boost::replace
   + boost::replace_first 

 *Example:*

Headers: 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 
   #include <vector>
#+END_SRC

Boost header and namespace alias: 

#+BEGIN_SRC cpp  
   #include <boost/algorithm/string.hpp>

   // b => Namespace alias to boost namespace. 
   namespace b = boost;
#+END_SRC

Convert string to upper/lower case.

#+BEGIN_SRC cpp 
  >> std::string s = " C++ is an old new programmign LANGUAGE";
  >> 

  // To upper case 
  >> b::to_upper(s)
  >> s
  (std::string &) " C++ IS AN OLD NEW PROGRAMMIGN LANGUAGE"
  >> 

  // To lower case:
  >> b::to_lower(s)
  >> s
  (std::string &) " c++ is an old new programmign language"
#+END_SRC

Trim string on both sides: 

#+BEGIN_SRC cpp 
  >> std::string ss = "   A string with  spaces   ";
  >> b::trim(ss)
  >> ss
  (std::string &) "A string with  spaces"
#+END_SRC

Check whether starts with some prefix: 

#+BEGIN_SRC cpp 
  // Checks whether first string argument starts with 'industry
  >> b::istarts_with("revenues outlook.pdf", "industry")
  (bool) false

  >> b::istarts_with("industry revenues outlook.pdf", "industry")
  (bool) true

  >> b::istarts_with("   industry revenues outlook.pdf", "industry")
  (bool) false
#+END_SRC

Check whether string ends with some suffix:

#+BEGIN_SRC cpp 
  // Checks whether first strigns ends with suffix '.pdf'
  >>  b::iends_with("revenues-outlook.xls", ".pdf")
  (bool) false

  >>  b::iends_with("revenues-outlook.pdf", ".pdf")
  (bool) true
#+END_SRC

Replace all strings: 

#+BEGIN_SRC cpp 
  >> std::string words = "ASM c++ low c++ ASM  python bytes ASM c++";

  // Replace 'c++' by 'CEE-PLUS-PLUS'
  >> b::replace_all(words, "c++", "CEE-PLUS-PLUS")

  >> words
  (std::string &) "ASM CEE-PLUS-PLUS low CEE-PLUS-PLUS ASM  python bytes ASM CEE-PLUS-PLUS"
  >> 

  >> b::replace_all(words, "CEE-PLUS-PLUS", "cpp")
  >> words
  (std::string &) "ASM cpp low cpp ASM  python bytes ASM cpp"
#+END_SRC


Split string: 

#+BEGIN_SRC cpp 
  std::string dataset = " -100.23 ; 577.15 ; 99.34 ; 1003.5";
  std::vector<std::string> split_vector{};

  >> split_vector
  (std::vector<std::string> &) {}

  // Split string dataset at delimiter ";"
  >> b::split(split_vector, dataset, b::is_any_of(";"));

  // Result 
  >> split_vector
  (std::vector<std::string> &) { " -100.23 ", " 577.15 ", " 99.34 ", " 1003.5" }
#+END_SRC
** Boost Lambda 

 + Documentation: [[https://www.boost.org/doc/libs/1_69_0/doc/html/lambda.html#introduction][Boost.Lambda]]

Notes: 

boost::bind from Boost.Lambda is already in C++ standard since C++11
and the placeholders, _1, _2 are in the namespace
std::placeholders. 

STL lambda placeholders does not support arithmetic expressions like
boost lambda placeholders. For instance, the following code generates
a lambda expression shown after it.
 
#+CAPTION: Boost lambda placeholder 
#+BEGIN_SRC cpp 
  3.0 * boost::lambda::_1 + 10.0
#+END_SRC

Equivalent lambda expression (lambda object):

#+CAPTION: Equivalent C++11 lambda function. 
#+BEGIN_SRC cpp 
  [](double x){ return 3.0 * x + 10.0}
#+END_SRC

 *Examples:*
 
Headers: 

#+BEGIN_SRC cpp 
   #include <boost/lambda/lambda.hpp>
   #include <boost/lambda/loops.hpp>

   #include <iostream>
   #include <string>
   #include <algorithm>
#+END_SRC

Namespace alias: 

#+BEGIN_SRC cpp 
  namespace bl = boost::lambda;
#+END_SRC

Creating a function of one argument:

#+BEGIN_SRC cpp 
  >> auto funOf1Arg = 10.0 * bl::_1 - 20.0;

  >> funOf1Arg(20)
  (double) 180.00000

  >> funOf1Arg(6.7)
  (double) 47.000000
  > 
#+END_SRC

Creating a function of two arguments: 

#+BEGIN_SRC cpp 
  >> auto funOf2ArgsA = 10.0 * bl::_1 + 6 * bl::_2 - 20;

  >> funOf2ArgsA(3, 4)
  (double) 34.000000

  >> funOf2ArgsA(5, 1)
  (double) 36.000000

 
  >> auto funOf2 = std::cout << " x = " << bl::_1 << " ; y = " << bl::_2 << "\n";

  >> funOf2(100, "hello");
   x = 100 ; y = hello

  >> funOf2('z', "hello");
  z ; y = hello
#+END_SRC

Lambda placeholder and STL "algorithms":

 + Algorithm std::for_each 

#+BEGIN_SRC cpp 
   auto xs = std::vector<int>{100, 200, 50, -70, 80, 45};

   >> std::for_each(xs.begin(), xs.end(), std::cout << bl::_1 << "\n");
   100
   200
   50
   -70
   80
   45
   >> 

   // Increase at 25%
   >> std::for_each(xs.begin(), xs.end(), std::cout << 1.25 * bl::_1 << "\n");
   125
   250
   62.5
   -87.5
   100
   56.25
   >> 

   >> xs
   (std::vector<int> &) { 100, 200, 50, -70, 80, 45 }
   >> 

   >> std::for_each(xs.begin(), xs.end(), std::cout << 1.25 * bl::_1 + 10.0 << "\n");
   135
   260
   72.5
   -77.5
   110
   66.25
   >> 
 #+END_SRC

 + Algorithm std::transform 

#+BEGIN_SRC cpp 
  >> std::vector<double> out(xs.size());

  >> out
  (std::vector<double> &) { 0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000, 0.0000000 }

  >> std::transform(xs.begin(), xs.end(), out.begin(), bl::_1 * 3.0 + 100);
  >> out
  (std::vector<double> &) { 400.00000, 700.00000, 250.00000, -110.00000, 340.00000, 235.00000 }

  // Divide every element of xs by 100.0 and insert it at vector out. 
  >> std::transform(xs.begin(), xs.end(), out.begin(), bl::_1 / 100.0);
  >> out
  (std::vector<double> &) { 1.0000000, 2.0000000, 0.50000000, -0.70000000, 0.80000000, 0.45000000 }
#+END_SRC

 *Lambda expressions for control structures*

#+BEGIN_SRC cpp 
  >> std::vector<int> yds{200, 40, 5, 9, 20, 40, 90, 35};

  >> std::for_each(yds.begin(), yds.end(), bl::if_then( bl::_1 > 25, std::cout << bl::_1 << "\n"));
  200
  40
  40
  90
  35

  {
  std::for_each(yds.begin(), yds.end(), 
                bl::if_then( bl::_1 > 25, std::cout << 4.5 * bl::_1 - 20.0 << "\n")
               );

  }
  // Output: 
  880
  160
  160
  385
  137.5
#+END_SRC

** Boost Operators 
*** Overview 

There are about 50 operators in C++ that can be overloaded which makes
implementing them repetitive and cumbersome. Boost operators is a
header-only library simplifies operator overloading by implementing
redundant operators in terms of each other. For instance, from the
operator less-than or (<), boost operators can automatically generate
the operators (<=), (>) and (>=). The library uses the CRT (Curious
Recurring Template Design Pattern) for generating the operators at
compile-time.

Documentation: 
 + [[https://www.boost.org/doc/libs/1_69_0/libs/utility/operators.htm][Boost.Operators]]

Headers: 
 + <boost/operators.hpp>
*** Example 

 + File: [[file:src/boost/boost-operators.cpp][file:src/boost/boost-operators.cpp]]
 + Gist: [[https://gist.github.com/caiorss/3682847393fd42b4001c9c71a74e2c37][boost-operators.cpp]]
 + Online Compiler: https://rextester.com/UZGM54875

Compilation: 

#+BEGIN_SRC sh 
  # Compile 
  $ clang++ boost-operator.cpp -o boost-operator.bin -std=c++1z -g -O0 -Wall
  # Run 
  $ ./boost-operator.bin
#+END_SRC

 *Parts*

Headers: 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <cmath>
  #include <cassert>
  #include <boost/operators.hpp>
#+END_SRC

Class Vec3D: 

#+CAPTION: Class Vec3D - three dimensional vector of 3 coordinates X, Y, Z
#+BEGIN_SRC cpp 
  class Vec3D: public boost::less_than_comparable<Vec3D>
             , public boost::addable<Vec3D, double>
  {
  private:
      double m_x, m_y, m_z;
  public:
      Vec3D(double x, double y, double z);
      double norm() const;

      // Stream insertion operator => Make class printable 
      friend std::ostream& operator<<(std::ostream& os, Vec3D const& vec);	

      // Required by: boost::less_than_comparable<Vec3D>
      // From this operator, boost implements the operators (<=), (>), (>=)
      friend bool operator<(Vec3D const& lhs, Vec3D const& rhs);

      // Required by: boost::addable<Vec3D, double>
      // Boost implements: operator+(Vec3D, double) and operator+(double, Vec3D)
      friend Vec3D& operator+=(Vec3D& lhs, double rhs);	
  };
#+END_SRC

The templated class *boost::less_than_comparable<T>* requires that the
client code implements the operator function less-than (<) or: 

#+CAPTION: Operator less-than (<) required by boost::less_than_comparable
#+BEGIN_SRC cpp 
  friend bool operator<(Vec3D const& lhs, Vec3D const& rhs);
  
  // Implementation: 
  bool
  operator<(Vec3D const& lhs, Vec3D const& rhs)
  {
     return lhs.norm() < rhs.norm();
  }
#+END_SRC

From the operator less-than (<), the templated class implements the
following operator functions: 

#+CAPTION: Operators generated by boost::less_than_comparable
#+BEGIN_SRC cpp 
  friend bool operator<=(Vec3D const& lhs, Vec3D const& rhs);
  friend bool operator>(Vec3D const& lhs, Vec3D const& rhs);
  friend bool operator>=(Vec3D const& lhs, Vec3D const& rhs);
#+END_SRC

The templated class *boost::addable<Vec3D, double>* requires the client
code supplying the operator (+=):

#+CAPTION: Operator function required by boost::addable<Vec3D, double>
#+BEGIN_SRC cpp 
  friend Vec3D& operator+=(Vec3D& lhs, double rhs);	

  // Implementation or definition:
  Vec3D&
  operator+=(Vec3D& lhs, double rhs)
  {
      double  d = rhs;
      lhs = {lhs.m_x + d, lhs.m_y + d, lhs.m_z + d};
      return lhs;
  }
#+END_SRC

From the operator (+=), the class boost::addable generates the
operators: 

#+CAPTION: Operator functions generated by boost::addable<Vec3D, double>
#+BEGIN_SRC cpp 
  friend Vec3D operator+(Vec3D const& lhs, double rhs);	
  friend Vec3D operator+(double rhs, Vec3D const& lhs);	
#+END_SRC

Function: disp used for displaying variables

#+BEGIN_SRC cpp 
  template<typename variable_t>
  void disp(const char* variableName, variable_t const& value)
  {
     std::cout << " =>> " << variableName << " = " << value << "\n";
  }
#+END_SRC

 *Function Main*

Variables:

#+BEGIN_SRC cpp 
  Vec3D v1 = {3, 5, 6};
  Vec3D v2 = {12, 5, 9};
  std::cout << std::boolalpha;
  disp("v1", v1); disp("v2", v2);
  disp("v1.norm()", v1.norm());
  disp("v2.norm()", v2.norm());
#+END_SRC

Program Output: 

#+BEGIN_SRC text 
 =>> v1 = Vec3D{  x = 3 ; y = 5 ; z = 6 } 
 =>> v2 = Vec3D{  x = 12 ; y = 5 ; z = 9 } 
 =>> v1.norm() = 8.3666
 =>> v2.norm() = 15.8114
#+END_SRC

Experiment 1: 

#+BEGIN_SRC cpp 
  std::cout << "\n EXPERIMENT 1 boost::less_than_comparable<Vec3D>" << "\n";
  std::cout << "--------------------------------------------------" << "\n";

  std::cout << "[a] v1 <  v2 = " << (v1 < v2) << "\n";
  std::cout << "[b] v1 <  v2 = " << operator<(v1, v2) << "\n\n";   

  std::cout << "[a] v1 <= v2 = " << (v1 <= v2) << "\n";
  std::cout << "[b] v1 <= v2 = " << operator<=(v1, v2) << "\n\n";

  std::cout << "[a] v1 >  v2 = " << (v1 > v2) << "\n";
  std::cout << "[b] v1 >  v2 = " << operator>(v1, v2) << "\n\n";

  std::cout << "[a] v1 >=  v2 = " << (v1 >= v2) << "\n";
  std::cout << "[b] v1 >=  v2 = " << operator>=(v1, v2) << "\n\n";
#+END_SRC

Program Output: 

#+BEGIN_SRC text 
   EXPERIMENT 1 boost::less_than_comparable<Vec3D>
  --------------------------------------------------
  [a] v1 <  v2 = true
  [b] v1 <  v2 = true

  [a] v1 <= v2 = true
  [b] v1 <= v2 = true

  [a] v1 >  v2 = false
  [b] v1 >  v2 = false

  [a] v1 >=  v2 = false
  [b] v1 >=  v2 = false
#+END_SRC

Experiment 2: 

#+BEGIN_SRC cpp 
  std::cout << "\n EXPERIMENT 2 boost::less_than_comparable<Vec3D>" << "\n";
  std::cout << "--------------------------------------------------" << "\n";
  disp("v1 + 5.0", v1 + 5.0);
  disp("operator+(v1, 5.0)", operator+(v1, 5.0));
  disp("5.0 + v1", 5.0 + v1);
  disp("operator+(5.0, v1", operator+(5.0, v1));
  disp("v1", v1);
#+END_SRC

Output: 

#+BEGIN_SRC text 
   EXPERIMENT 2 boost::less_than_comparable<Vec3D>
  --------------------------------------------------
   =>> v1 + 5.0 = Vec3D{  x = 8 ; y = 10 ; z = 11 } 
   =>> operator+(v1, 5.0) = Vec3D{  x = 8 ; y = 10 ; z = 11 } 
   =>> 5.0 + v1 = Vec3D{  x = 8 ; y = 10 ; z = 11 } 
   =>> operator+(5.0, v1 = Vec3D{  x = 8 ; y = 10 ; z = 11 } 
   =>> v1 = Vec3D{  x = 3 ; y = 5 ; z = 6 } 
#+END_SRC

** Boost Range 

Documentation: 
 + [[https://www.boost.org/doc/libs/1_69_0/libs/range/doc/html/index.html][Boost.Range]]

New Version of Range Library - v3
 + https://ericniebler.github.io/range-v3/index.html

Headers and functionality: 
 + <boost/range.hpp>
 + <boost/range/adapators.hpp>
 + <boost/range/algorithm.hpp>
 + <boost/range/algorithm_ext/for_each.hpp>
 + <boost/range/algorithm/copy.hpp>
 + <boost/range/adaptor/reversed.hpp>
 + <boost/range/adaptor/transformed.hpp>

Namespaces: 
 + boost
 + boost::adaptors 

 *Example:*

Headers: 

#+BEGIN_SRC cpp 
  #include <boost/range.hpp>
  #include <boost/range/adaptors.hpp>
  // Include all algorithms 
  #include <boost/range/algorithm.hpp>

  #include <boost/range/algorithm/copy.hpp>
  #include <boost/range/adaptor/reversed.hpp>
  #include <boost/range/adaptor/transformed.hpp>
   
  #include <iostream> 
  #include <vector> 
  #include <deque>
  #include <string> 

  namespace b = boost;
  namespace ba = boost::adaptors;
#+END_SRC



 + Boost for_each rage: 

#+BEGIN_SRC cpp 
   #include <iostream> 
   #include <vector> 
   #include <boost/range/algorithm/for_each.hpp>

   auto xs = std::vector<int> {100, 80, 60, 70, 98, 45, 173};
   
   // Boost Range - for_each 
   >> boost::for_each(xs, [](int x){ std::cout << x << "\n"; });
   100
   80
   60
   70
   98
   45
   173
 
   // STL for_each: 
   >> std::for_each(xs.begin(), xs.end(), [](int x){ std::cout << x << "\n"; });
   100
   80
   60
   70
   98
   45
   173
#+END_SRC


 + Boost sort: 

#+BEGIN_SRC cpp 
   #include <iostream> 
   #include <vector> 
   #include <algorithm> 

   #include <boost/range/algorithm/sort.hpp>

   >> auto ys = xs;
   >> ys
   { 100, 80, 60, 70, 98, 45, 173 }

   // ----- Bost range ------------ // 
   >> boost::sort(ys);
   >> ys
   { 45, 60, 70, 80, 98, 100, 173 }

   // --- STL Range ------------- // 

   >> auto zs = xs;
   >> zs
    { 100, 80, 60, 70, 98, 45, 173 }

   >> std::sort(xs.begin(), xs.end());
   >> xs
    { 45, 60, 70, 80, 98, 100, 173 }
#+END_SRC

 + Boost copy 

#+BEGIN_SRC cpp 
  #include <boost/range/algorithm/copy.hpp>

  >> xs
  { 45, 60, 70, 80, 98, 100, 173 }
  >> 

  >> std::vector<int> out;

  >> boost::copy(xs, std::back_inserter(out));
  
  >> out
  { 45, 60, 70, 80, 98, 100, 173 }
#+END_SRC

 + Boost transform 

#+BEGIN_SRC cpp 
  >> std::vector<double> weights = {10.2, 5.60, 8.25};
  >> std::vector<double> ts(weights.size());

  >> boost::transform(weights, ts.begin(), [](double x){ return x / 100.0; });

  >> ts
  (std::vector<double> &) { 0.10200000, 0.056000000, 0.082500000 }
#+END_SRC

** Boost Pointer Container 

The C++ Standard Template Library - STL does not work well with
polymorphic types as polymorphic objects cannot be stored in container
directly due to object slicing, only the base part is copied and the
derived is discarded; storing polymorphic objects with smart pointers
pointers is memory and exception safe. However, it is still cumbersome
and does not plays well with STL algorithms such as std::sort or
std::for_each with functors or lambda wrappers due to STL algorithms
be designed to work with values, not pointers.

The boost pointer container library provides STL-like containers for
holding heap-allocated objects or polymorphic objects. The containers
provide interoperability with STL algorithms; non-pointer notation for
accessing object members; single memory-ownership.  

Note: If there is shared ownership semantics, in other words, multiple
objects need to point to a polymorphic object during their entire
lifetime, then this library is not suitable to this use case. In this
situation, the best solution is to use a container of shared pointers
such as std::vector<std::shared<T>>. 

See: [[https://web.archive.org/web/20050413215843/http://www.oonumerics.org:80/tmpw00/kuehl.html][STL and OO Don't Easily Mix]]

 + Documentation: [[https://www.boost.org/doc/libs/1_69_0/libs/ptr_container/doc/ptr_container.html][Pointer Container]]
 + Headers:
   + <boost/ptr_container/ptr_vector.hpp>
   + <boost/ptr_container/ptr_deque.hpp>
   + <boost/ptr_container/nullable.hpp>	
   + [[https://www.boost.org/doc/libs/1_69_0/libs/ptr_container/doc/headers.html][Full list]]
 + Containers:
   + ptr_vector
   + ptr_deque 
   + ptr_list
   + ptr_map
   + ptr_set
 + Functions:
   + boost::str
   + boost::format

 *Example:*

Source: 
 + File: [[file:src/boost/boost-pointer-container.cpp][file:src/boost/boost-pointer-container.cpp]]
 + Online Compiler: https://rextester.com/LIJMMS16329

Compiling and running: 

#+BEGIN_SRC sh 
 $ clang++ boost-pointer-container.cpp -o boost-pointer-container.bin -std=c++1z -g -O0 -Wall 
 $ ./boost-pointer-container.bin
#+END_SRC

Headers: 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <vector>
  #include <string>
  #include <functional>

  #include <boost/ptr_container/ptr_vector.hpp>
#+END_SRC

Sample class hierarchy: 

#+CAPTION: Base class of sample hierarchy.
#+BEGIN_SRC cpp 
  class Base{
  public:
      static auto nextID() -> int {
         static int i = 0;
         return ++i;
      }		

      Base() = default;
      // Destructor of base class must always be virtual
      virtual ~Base() = default;
      virtual auto getID() const -> int = 0;
      virtual auto getType() const -> std::string = 0;
  };
#+END_SRC

#+CAPTION: Class DerivedA - Derived class of Base 
#+BEGIN_SRC cpp 
  class DerivedA: public Base{	
  public:
      const int m_id;
	
      DerivedA(): m_id(Base::nextID())  { }
      auto getType() const  -> std::string {
         return "DerivedA";
      }
      auto getID() const -> int {
         return m_id;
      }	
      ~DerivedA(){
          std::cout << " [INFO] Class DerivedA deleted. => Object ID = "
                    << m_id << "\n";
      }
  };
#+END_SRC

#+CAPTION: Class DerivedB - Derived class of Base 
#+BEGIN_SRC cpp 
  class DerivedB: public Base{
      const int m_id;
  public:		
      DerivedB(): m_id(Base::nextID())  { }
      auto getType() const -> std::string {
         return "DerivedB";
      }
      auto getID() const -> int {
         return m_id;
      }		
      ~DerivedB(){
          std::cout << " [INFO] Class DerivedB deleted. => ObjectID = "
                    << m_id  << "\n";
      }
  };
#+END_SRC

Function showType: 

#+BEGIN_SRC cpp 
  void showType(Base const& obj)
  {
          std::cout << "Object ID = " << obj.getID()
                    <<  " Class type = " << obj.getType()
                    << "\n";
  }
#+END_SRC

 *Main Function*

Experiment 0: STL Container olding non-polymorphic objects
(non-dynamically allocated, type is known at compile-time).

#+BEGIN_SRC cpp 
  std::vector<DerivedA> xsa;
  xsa.push_back(DerivedA());
  xsa.push_back(DerivedA());
  xsa.emplace_back();

  std::cout << "Run std::for_each" << "\n";
  std::for_each(xsa.begin(), xsa.end(), showType);
#+END_SRC

Experiment 1: STL container holding polymorphic objects:

 + Note: STL algorithms require lambda wrappers.

#+BEGIN_SRC cpp 
  std::cout << "\n === EXPERIMENT 1 ==============================" << "\n";

  std::vector<std::shared_ptr<Base>> xs;
  xs.push_back(std::make_shared<DerivedA>());
  xs.push_back(std::make_shared<DerivedB>());
  xs.push_back(std::make_shared<DerivedA>());
  xs.push_back(std::make_shared<DerivedB>());

  std::cout << " <<INFO>> xs[0]  type " << xs[0]->getType()
            << " ; id = " << xs[0]->getID() << "\n";

  std::cout << " <<INFO>> xs[2]  type " << xs[2]->getType()
            << " ; id = " << xs[2]->getID() << "\n";

  std::for_each(xs.begin(), xs.end(),
                [](auto const& pBase){
                        showType(*pBase);
                });

  std::vector<int> identifiers1;
  std::transform(xs.begin(), xs.end(),
                 std::back_inserter(identifiers1),
                 [](auto pBase){ return pBase->getID(); });
#+END_SRC

Experiment 2: Boost ptr_vector 

 + Notes:
   + Accessing elements ps[0] uses conventional notation without (->)
     arrow operator.
   + STL algorithms does not need lambda or functor wrappers.
   + Memory solely owned by ptr_vector (single-ownership)

#+BEGIN_SRC cpp 
  boost::ptr_vector<Base> ps;
  ps.push_back(new DerivedA);
  ps.push_back(new DerivedB());
  ps.push_back(new DerivedA());
  ps.push_back(new DerivedB);

  std::cout << " <<INFO>> ps[0]  type " << ps[0].getType() << " ; id = " << ps[0].getID() << "\n";
  std::cout << " <<INFO>> ps[1]  type " << ps[1].getType() << " ; id = " << ps[1].getID() << "\n";
  std::cout << " <<INFO>> ps[2]  type " << ps[2].getType() << " ; id = " << ps[2].getID() << "\n";

  std::vector<int> identifiers2;
  std::transform(xs.begin(), xs.end(),
                 std::back_inserter(identifiers2),
                 std::bind(&Base::getID, std::placeholders::_1));

  std::cout << "\n ==> Show objects before deleting last item " << "\n";
  std::for_each(ps.begin(), ps.end(), showType);

  std::cout << "\n ==> Show objects after deleting last item " << "\n";
  ps.pop_back();
  std::for_each(ps.begin(), ps.end(), showType);

  std::cout << " ============= END =================" << "\n";
#+END_SRC

** Boost Interprocess 
*** Overview  

[[https://www.boost.org/doc/libs/1_69_0/doc/html/interprocess.html][Boost.Interprocess]] is a library that provides wrappers or a common
interface for many operating-system-specific inter process
communication (IPC) primitive functions. The library provides wrappers
to the following IPC facilities:

 + File locking 
 + Mutex
 + Semaphore 
 + Shared Memory
 + Memory Mapped File
 + Message Queue 
*** Example: Shared memory facilities

Shared memory is the fastest IPC inter-process communication mechanism
available in most operating systems for exchanging data between
processes in the same machine. The share memory IPC allows data to be
shared by multiple processes without any copying overhead which makes
it faster than sockets, message passing and so on. However, using
operating systems shared memory APIs directly is not easy or
portable. Boost inter-process library provides many facilities that
encapsulates operating systems APIs with a higher level interface that
makes the code portable across many operating systems.

 + Documentation: [[https://www.boost.org/doc/libs/1_69_0/doc/html/interprocess.html][Boost.InterProcess]]

This code provide many client/server examples about using the
Boost.Interprocess shared memory API and also about how to allocate
STL containers in a shared memory segment. 

 *Source Code* 
  + [[file:src/boost/boost-shared-memory1.cpp][file:src/boost/boost-shared-memory1.cpp]]

 *Headers*

 #+BEGIN_SRC cpp 
   #include <iostream>
   #include <cassert>
   #include <map>
   #include <functional>
   #include <vector>

   #include <boost/interprocess/mapped_region.hpp>
   #include <boost/interprocess/shared_memory_object.hpp>
   #include <boost/interprocess/sync/named_mutex.hpp>
   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/segment_manager.hpp>
 #+END_SRC

Namespace alias: 

#+BEGIN_SRC cpp 
  namespace bi = boost::interprocess;
#+END_SRC

Templates: 

#+BEGIN_SRC cpp 
  /** Generic Shared Memory Allocator */
  template<typename T>
  using ShmemAllocator = bi::allocator<T, bi::managed_shared_memory::segment_manager> ;

  /** Generic STL vector allocated in shared memory */
  template<typename T>
  using ShmemVector = std::vector<T, ShmemAllocator<T>> ;
#+END_SRC

Class SharedMemoryCleaner uses the RAII (Resource Acquisition Is
Initialization) for deleting shared memory segments when out of
scope. 

#+BEGIN_SRC cpp 
  /** RAII Object for removing shared memory segment. */
  struct SharedMemoryCleaner
  {	
     std::string m_name;
     SharedMemoryCleaner(std::string name): m_name(name){ }

     ~SharedMemoryCleaner(){
          namespace bi = boost::interprocess;
          std::cerr << " [INFO] Remove shared memory segment { name = " << m_name << " }" << "\n";
          bi::shared_memory_object::remove(m_name.c_str());
     }
  };
#+END_SRC

Function Declarations: 

#+BEGIN_SRC cpp 
  int serverA();
  int clientA();

  int serverB();
  int clientB();

  int serverC();
  int clientC();
#+END_SRC

Main Function: 

#+BEGIN_SRC cpp 
  int main(int argc, char** argv){
       using DispatchTable = std::map<std::string, std::function<int ()>>;
       DispatchTable table = {
           {"serverA", &serverA},
           {"clientA", &clientA},
           {"serverB", &serverB},
           {"clientB", &clientB},
           {"serverC", &serverC},
           {"clientC", &clientC}
       };

       if(argc < 2) {
           std::cout << " Error: invalid arguments." << std::endl;
           return EXIT_SUCCESS;
       }
       auto it = table.find(argv[1]);
       if(it == table.end()){
           std::cout << " Error: invalid command." << std::endl;
           return EXIT_FAILURE;		
       }
       // Execute function 
       return it->second();			
  }
#+END_SRC

Function: ServerA.

#+BEGIN_SRC cpp 
  // Print string (char array) to shared memory 
  int serverA()
  {	
      // Create shared memory wrapper object 
      auto shm = bi::shared_memory_object{
                   // Creates shared memory segment if it does not exist 
                   bi::open_or_create,
                   "shared_memory_segment",
                   bi::read_write
                 };
      // RAII object that removes the segment when out of scope 
      auto shm_remove = SharedMemoryCleaner("shared_memory_segment");	
      // Set size of the shared memory segment in Kb (kbytes = 1024 bytes)
      shm.truncate(1024); // 1kb (kbytes)
      // Map the shared memory segment to current process
      auto region = bi::mapped_region{shm, bi::read_write};
      // Pointer to shared memory 
      void* pMem = region.get_address();

      // Print to shared memory
      char* pChar = static_cast<char*>(pMem);
      std::sprintf(pChar, " ==> String written to shared memory segment");

      // Keep the server Alive as the shared memory segment is not 
      // persistent on Windows. 
      std::cout << "Enter RETURN to EXIT " << "\n";
      std::cin.get();
      return EXIT_SUCCESS;
  }
#+END_SRC

Function: clientA.

#+BEGIN_SRC cpp 
   // Print string (char array) to shared memory 
   int clientA()
   {	
       // Create shared memory wrapper object 
       auto shm = bi::shared_memory_object{
          // Creates shared memory segment if it does not exist 
          bi::open_only,
          "shared_memory_segment",
          bi::read_only
          };
       auto region = bi::mapped_region{shm, bi::read_only};
       void* pMem = region.get_address();

       // Interpret shared memory as a pointer to char* 
       char* pMessage = static_cast<char*>(pMem);
       std::cout << " Content of shared memory = " << pMessage << "\n";	
       return EXIT_SUCCESS;
   }
#+END_SRC

Function: serverB.

#+BEGIN_SRC cpp 
  /** Allocate double[] array in shared memory */
  int serverB()
  {
       auto shm = bi::shared_memory_object{	
       bi::open_or_create,
       "shared_memory_segment",
       bi::read_write
       };
       auto shm_remove = SharedMemoryCleaner("shared_memory_segment");
       shm.truncate(1024); // 1kb (kbytes)
       auto region = bi::mapped_region{shm, bi::read_write};
       void* pMem = region.get_address();

       // Allocate array of 5 doubles in the shared memory 
       double* arr = new (pMem) double [5];
       arr[0] = 100.34;
       arr[1] = 200.5;
       arr[2] = -5.6;
       arr[3] = 9.10;
       arr[4] = 10.5;

       // Keep the server Alive as the shared memory segment is not 
       // persistent on Windows. 
       std::cout << "Enter RETURN to EXIT " << "\n";
       std::cin.get();
       return EXIT_SUCCESS;
  }

#+END_SRC

Function clientB:

#+BEGIN_SRC cpp 
  /** Retrieve double[] array from shared memory */
  int clientB(){
       auto shm = bi::shared_memory_object{
            bi::open_only, 
           "shared_memory_segment",
            bi::read_only 
       };
       auto region = bi::mapped_region{shm, bi::read_only};

       void* pMem = region.get_address();
       double* arr = static_cast<double*>(pMem);

       std::cout << "arr[0] = " << arr[0] << "\n";
       std::cout << "arr[1] = " << arr[1] << "\n";
       std::cout << "arr[2] = " << *(arr + 2) << "\n";
       std::cout << "arr[3] = " << *(arr + 3) << "\n";
       std::cout << "arr[4] = " << arr[4] << "\n";
       return EXIT_SUCCESS;
  }

#+END_SRC

Function: ServerC. 

#+BEGIN_SRC cpp 
  // Allocate STL container in shared memory  
  int serverC(){
       // Remove shared memory segment if it already exists 
       bi::shared_memory_object::remove("shared_seg");

       auto segment = bi::managed_shared_memory(
               bi::open_or_create,
               "shared_seg", // segment name 
               4096              // 4 kbytes 
               );
       auto shm_remove = SharedMemoryCleaner("shared_seg");

       // Segment manager pointer 
       // Type: managed_shared_memory::segment_manage* 
       auto segmgr = segment.get_segment_manager();
       segmgr->construct<const char*>("text")("'Hello world shared memory'");
       segmgr->construct<double>("speed")(10.50);
       segmgr->construct<int>("nodes")(100);

       // === Allocate STL Vector in Shared Memory === //	
       // Build shared memory allocator 
       auto aloc = ShmemAllocator<double>(segmgr);

       // Instantiate vector in shared memory 
       ShmemVector<double>* pVector = segmgr->construct<ShmemVector<double>>("avector")(aloc);
       pVector->reserve(50);
       pVector->push_back(4.5);
       pVector->push_back(10.3);
       pVector->push_back(100.50);
       pVector->push_back(20.0);

       std::cout << "Enter RETURN to EXIT " << "\n";
       std::cin.get();
       return EXIT_SUCCESS;
  };

#+END_SRC


Function: ClientC.

#+BEGIN_SRC cpp 
  int clientC(){
        auto segment = bi::managed_shared_memory(
                bi::open_or_create,
                "shared_seg", // segment name 
                4096          // 4 kbytes 
              );	

        auto segmgr = segment.get_segment_manager();
        std::pair<double*, size_t> p1 = segmgr->find<double>("speed");
        std::cout << "Speed = " << *p1.first << "\n";

        auto pairNodes = segmgr->find<int>("nodes");
        std::cout << "Nodes = " << *pairNodes.first << "\n";

        auto pairText = segmgr->find<const char*>("text");
        std::cout << "Text = " << *pairText.first << "\n";

        // C++17 - Structured Binding
        auto [pVector, _] = segmgr->find<ShmemVector<double>>("avector");

        std::cout << " => pVector->size() = " << pVector->size() << std::endl;
        std::cout << " => pVector[0] = " << pVector->operator[](0) << std::endl;
        std::cout << " => pVector[1] = " << (*pVector)[1] << std::endl;
        size_t idx = 0;
        for(auto const& x: *pVector)
            std::cout << "pVector[" << idx++ << "] = " <<  x << "\n";

        double speed;
        std::cout << "Enter new speed: ";
        std::cin >> speed;
        ,*p1.first = speed;

        pVector->push_back(speed);

        return EXIT_SUCCESS;
  };
#+END_SRC

 *Compile on Linux, OSX or any other Unix-like OS*

#+BEGIN_SRC sh 
  # GCC  
  $ g++ boost-shared-memory1.cpp -o boost-shared-memory1.bin -std=c++1z -Wall -lpthread -lrt

  # Clang 
  $ clang++ boost-shared-memory1.cpp -o boost-shared-memory1.bin -std=c++1z -Wall -lpthread -lrt
#+END_SRC

 *Compile on Windows* 

Compile with Visual C++ or MSVC (VC++)

#+BEGIN_SRC bat 
  $ cl.exe boost-shared-memory1.cpp /Fe:boost-shared-memory1.exe /EHsc /std:c++17 ...
    /GA /MDd /nologo /I C:\boost\boost_1_69_0 /link /LIBPATH:C:\boost\lib
#+END_SRC

Compile with Mingw (GCC)

#+BEGIN_SRC bat 
  $ g++ boost-shared-memory1.cpp -o boost-shared-memory1.exe -std=c++1z -I C:\boost\boost_1_69_0
#+END_SRC

 *Running functions serverA and clientA*

The process that runs serverA in terminal 1 allocates a string in the
shared memory and the process running in the terminal 2 displays the
string from fetched from shared memory. 

Terminal 1: 

#+BEGIN_SRC sh 
  F:\boost> boost-shared-memory1.exe serverA
  Enter RETURN to EXIT
#+END_SRC

Terminal 2: 

#+BEGIN_SRC sh 
  F:\boost> boost-shared-memory1.exe clientA
   Content of shared memory =  ==> String written to shared memory segment
#+END_SRC

 *Running functions serverB and clientB* 
 
Terminal 1: 

#+BEGIN_SRC sh 
  F:\boost>
  F:\boost> boost-shared-memory1.exe serverB
  Enter RETURN to EXIT
#+END_SRC

Terminal 2: 

#+BEGIN_SRC sh 
  F:\boost>boost-shared-memory1.exe clientB
  arr[0] = 100.34
  arr[1] = 200.5
  arr[2] = -5.6
  arr[3] = 9.1
  arr[4] = 10.5
#+END_SRC

 *Running functions serverC and clientC* 

The process running in terminal 1 (serverC) allocates several variables in the
shared memory and an std::vector<double> container and the process
running in the terminal 2 (clientC) reads the shared memory and
updates the variable speed and the vector container. The changes in
the std::vector container are persistent on each execution of the
process in terminal 2 while the process running the command serverC is
running. 

Terminal 1: 

#+BEGIN_SRC sh 
  F:\boost> boost-shared-memory1.exe serverC
  Enter RETURN to EXIT
#+END_SRC

Terminal 2: 

#+BEGIN_SRC sh 
  F:\boost> boost-shared-memory1.exe clientC
  Speed = 100.665
  Nodes = 100
  Text = 'Hello world shared memory'
   => pVector->size() = 5
   => pVector[0] = 4.5
   => pVector[1] = 10.3
  pVector[0] = 4.5
  pVector[1] = 10.3
  pVector[2] = 100.5
  pVector[3] = 20
  pVector[4] = 100.665
  Enter new speed: 40.51

  F:\boost> boost-shared-memory1.exe clientC
  Speed = 40.51
  Nodes = 100
  Text = 'Hello world shared memory'
   => pVector->size() = 6
   => pVector[0] = 4.5
   => pVector[1] = 10.3
  pVector[0] = 4.5
  pVector[1] = 10.3
  pVector[2] = 100.5
  pVector[3] = 20
  pVector[4] = 100.665
  pVector[5] = 40.51
  Enter new speed: ^C

#+END_SRC

*** Example: Shared memory logging with mutex synchronization

This sample program emulates a client that sends logging message to a
shared memory segment and a server that receives the logging messages
from the shared memory and prints them to the standard output
stdout. A named mutex object is used for coordinating both processes. 

 *File:*
 + [[file:src/boost/boost-shared-memory-logger.cpp][file:src/boost/boost-shared-memory-logger.cpp]]

 *Headers:*

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <sstream>

  #include <cstring> // strok 
  #include <ctime>
  #include <chrono>

  #include <boost/interprocess/mapped_region.hpp>
  #include <boost/interprocess/shared_memory_object.hpp>
  #include <boost/interprocess/sync/named_mutex.hpp>
  #include <boost/interprocess/sync/scoped_lock.hpp>
#+END_SRC

 *Namespace Alias*

#+BEGIN_SRC cpp 
  namespace bi = boost::interprocess;
#+END_SRC

 *Function Main* 

Create shared memory segment: 

#+BEGIN_SRC cpp 
     // Create shared memory wrapper object 
     auto shm = bi::shared_memory_object{
             bi::open_or_create,  
             "logger_shm",
             bi::read_write
     };
     // Set size of the shared memory segment in Kb (kbytes = 1024 bytes)
     shm.truncate(4096); // 4kb (kbytes)
     // Map the shared memory segment to current process
     auto region = bi::mapped_region{shm, bi::read_write};
     // Pointer to shared memory 
     void* pMem = region.get_address();
#+END_SRC

Create a named mutex object for process synchronizing the shared memory
access: 

#+BEGIN_SRC cpp 
   // Create mutex Object 
   bi::named_mutex amutex(bi::open_or_create, "logger_mutex");
#+END_SRC

Check command line arguments: 

#+BEGIN_SRC cpp 
  if(argc < 2){
      std::cout << "$ " << argv[0] << " [-client|-server]" << "\n";
      return EXIT_SUCCESS;
  }

  std::string cmd = argv[1];
#+END_SRC

Server command: 

#+BEGIN_SRC cpp 
     if(cmd == "-server"){
         char* pMessage = (char*) pMem;
         while(true)
         {
              std::cerr << " [TRACE] Waiting logging message " << std::endl;
              // Acquire mutex lock blocking this thread 
              amutex.lock();
              // Print logging memssage from shared memory 
              std::cout << pMessage << std::endl;
         }
         return EXIT_SUCCESS;
     }
#+END_SRC

Client command: 

#+BEGIN_SRC cpp 
     if(cmd == "-client")
     {
         // Interpret shared memory as a pointer an null-terminated
         // array of characters 
         char* pMessage = (char*) pMem;
         std::string line;
         while(true)
         {
             std::cout << " => Enter line: ";
             std::getline(std::cin, line);			
             std::stringstream ss;
             auto now = std::chrono::system_clock::now();
             std::time_t ttp = std::chrono::system_clock::to_time_t(now);
             ss << " [INFO] " << strtok(std::ctime(&ttp), "\n") << " - " << line;
             // Print to shared memory (pointer by pMessage)
             std::sprintf(pMessage, "%s", ss.str().c_str());
             // Release mutex lock 
             amutex.unlock();
         }	   
         return EXIT_SUCCESS;
     }
#+END_SRC

 *Compiling on Linux or any other Unix-like OS:*

#+BEGIN_SRC sh 
 # Clang 
 $ clang++ boost-shared-memory-logger.cpp -o logger.bin -std=c++1z -g -O0 -Wall -lpthread -lrt  
 # GCC
 $ gcc++ boost-shared-memory-logger.cpp -o logger.bin -std=c++1z -g -O0 -Wall -lpthread -lrt  
#+END_SRC

 *Compiling on Windows with MingW/GCC* 

#+BEGIN_SRC sh 
  $ g++ boost-logger.cpp -o boost-logger.exe -IC:\boost\boost_1_69_0
#+END_SRC

 *Compiling on Windows with MSVC (VC++)*

Problem faced when compiling wiht MSVC:
 + [[https://stackoverflow.com/questions/9628527/linker-error-lnk1104-with-libboost-filesystem-vc100-mt-s-1-49-lib][c++ - Linker error LNK1104 with 'libboost_filesystem-vc100-mt-s-1_49.lib' - Stack Overflow]]

#+BEGIN_SRC sh 
  $ cl.exe boost-logger.cpp /Fe:boost-logger1.exe /EHsc /GA /MDd /nologo /I C:\boost\boost_1_69_0 /link /LIBPATH:C:\boost\lib
#+END_SRC

Run program as server in terminal 1: 

#+BEGIN_SRC sh 
  $ ./logger.bin -server
   [TRACE] Waiting logging message 
   [INFO] Sun Mar 17 08:13:26 2019 - price 10% up
   [TRACE] Waiting logging message 
   [INFO] Sun Mar 17 08:13:38 2019 - price change 4.5 down
   [TRACE] Waiting logging message 
   [INFO] Sun Mar 17 08:14:07 2019 - new forecast arriving soon
   [TRACE] Waiting logging message 
   [INFO] Sun Mar 17 08:14:11 2019 - new data
   [TRACE] Waiting logging message 
   ... ...  ... ...  ... ...  ... ... 
#+END_SRC

Run program as client in terminal 2: 
 + User type messages in this terminal and they are sent to the shared
   memory buffer, then mutex lock is released what makes the server
   process print the message from the shared memory to standard output.


#+BEGIN_SRC sh 
  $ ./logger.bin -client
   => Enter line: price 10% up
   => Enter line: price change 4.5 down
   => Enter line: new forecast arriving soon
   => Enter line: new data
   => Enter line: ^C
#+END_SRC
*** Example: Memory Mapped Files 
**** Overview 

Most operating systems have system-calls or APIs for mapping files
into a process' address space or virtual memory which allows reading
and writing to a file as it was a memory. Any changes in memory-mapped
file memory segment is immediately written to the disk. 

Among other things, memory-mapped files provide the following
benefits:

 * Faster and more performant file processing, specially for big files
   of Gigabyte-size (big-data).

 * Persistence and serialization:
   + Simplified serialization, any object allocated in a memory-mapped
     file segment is automatically written to the mapped file in a
     disk. And deserialization only requires reading the object from
     the memory or just casting a pointer without any special
     deserialization code.

Operating System APIs: 

 + Unix-like OSes or POSIX (Linux, MacOSX, Android, BSD, QNX ...)
   + Uses the system-call or API: [[https://en.wikipedia.org/wiki/Mmap][mmap]] for memory-mapped files.

 + Windows NT, Windows CE:
   + Uses the Win32 APIs: [[https://docs.microsoft.com/en-gb/windows/desktop/api/winbase/nf-winbase-createfilemappinga][CreateFileMapping]], [[https://docs.microsoft.com/en-gb/windows/desktop/api/memoryapi/nf-memoryapi-mapviewoffile][MapViewOFile]], [[https://docs.microsoft.com/en-gb/windows/desktop/api/memoryapi/nf-memoryapi-unmapviewoffile][UnmapViewOfFile]]

The boost interprocess library provides a generalized interface to
those operating system specific memory-mapping file APIs. The library
also provides a C++ friendly notation, memory-allocators, memory
managers and so on that simplifies the usage on many different
operating systems.

See also: 
 + Boost.Interprocess: [[https://www.boost.org/doc/libs/1_69_0/doc/html/interprocess/sharedmemorybetweenprocesses.html#interprocess.sharedmemorybetweenprocesses.mapped_file][Memory Mapped Files]]
 + Boost.Interprocess: [[https://www.boost.org/doc/libs/1_69_0/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_mapped_files][Managed Mapped Files]]
 + [[http://john.freml.in/mmap-pattern][John Fremlin's blog: The mmap pattern]]
 + [[https://stackoverflow.com/questions/7159271/live-c-objects-that-live-in-memory-mapped-files]["live C++ objects that live in memory mapped files"? - Stack Overflow]]
 + [[https://docs.microsoft.com/en-us/dotnet/standard/io/memory-mapped-files][Memory-Mapped Files | Microsoft Docs]]
 + [[https://software.intel.com/en-us/articles/introduction-to-programming-with-persistent-memory-from-intel][Introduction to Programming with Persistent Memory from Intel | Intel® Software]]
 + [[http://blogs.microsoft.co.il/sasha/2016/01/21/myth-busting-memory-mapped-files-and-shared-memory-on-windows/][Myth-Busting: Memory-Mapped Files and Shared Memory on Windows | All Your Base Are Belong To Us]]
 + [[https://en.wikipedia.org/wiki/Memory-mapped_file][Memory-mapped file - Wikipedia]]
 + [[https://pymotw.com/2/mmap/][mmap – Memory-map files - Python Module of the Week]]
**** Code 

 *File*:
  + [[file:src/boost/boost-memory-mapped-file.cpp][file:src/boost/boost-memory-mapped-file.cpp]]

Headers: 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <functional>
  #include <string>
  #include <fstream>
  #include <vector>

  #include <boost/interprocess/managed_mapped_file.hpp>
  #include <boost/interprocess/file_mapping.hpp>
  #include <boost/interprocess/mapped_region.hpp>
#+END_SRC

 *Namespace alias:*

#+BEGIN_SRC cpp 
  namespace bi = boost::interprocess;	
#+END_SRC

 *Template aliases:*

#+BEGIN_SRC cpp 
  /** Generic Memory-mapped file allocator */
  template<typename T>
  using MMFAllocator = bi::allocator<T, bi::managed_mapped_file::segment_manager> ;

  /** Generic STL vector allocated in memory-mapped file */
  template<typename T>
  using MMFVector = std::vector<T, MMFAllocator<T>> ;
#+END_SRC

 *Function Main*

Intial definitions: 

#+BEGIN_SRC cpp 
  constexpr const char* fileName = "memory-dump.dat";
  constexpr size_t      fileSize = 4096; // 4 kbytes
  bool flagFileExists            = fileExists(fileName);

  // Manged file mapping object => Creates the file if it does not exists 
  auto mf = bi::managed_mapped_file{bi::open_or_create, fileName, fileSize};
#+END_SRC

Check if file exits, if does not exist yet, then initial data is
written to the file by allocating data in the mapped memory. 

#+BEGIN_SRC cpp 
  if(!flagFileExists){
       // Executed when the file did not exist 
       std::cout << " [INFO] Setting file data" << std::endl;
       mf.construct<int>("NumberOfNodes")(100);	
       mf.construct<double>("Speed")(200.0);
       mf.construct<const char*>("Text")("'Allocated text in memory mapped file'");

       // Allocate std::vector<double>
       MMFAllocator<double> aloc1(mf.get_segment_manager());
       MMFVector<double>* pVector = mf.construct<MMFVector<double>>("AVector")(aloc1);
       pVector->reserve(20);
       pVector->push_back(40.5);
       pVector->push_back(98.10);
       pVector->push_back(-50.45);
       pVector->push_back(10);		

       return EXIT_SUCCESS;
  }
#+END_SRC

If the file already exists, then it is mapped into the current
process' virtual memory and the data extracted just by reading the
memory, any modification to this mapped segment is written to the file
memory-dump.dat. 

Get variable: NumberOfNodes and increment it.

#+BEGIN_SRC cpp 
  // ======= Executed when file already exists =========// 

  std::cout << " [INFO] Retrieving objects from memory mapped file" << std::endl;

  // Retrieve variable NumberOfNodes with very explicitly and verbose notation 
  std::pair<int*, size_t> pairResult1 =  mf.find<int>("NumberOfNodes");
  if(pairResult1.first == nullptr){
          std::cerr << " [ERROR] I cannot find the object 'NumberOfNodes'" << std::endl;
          return EXIT_FAILURE;
  }
  std::cout << "Number of nodes = " << *pairResult1.first  << "\n";
  (*pairResult1.first)++;
#+END_SRC

Get variable 'Text' and display it. 

#+BEGIN_SRC cpp 
  // Retrieve variable text
  auto [pText, _size1 ] = mf.find<const char*>("Text");
  assert(pText != nullptr);
  std::cout << "Text = " << *pText << "\n";
#+END_SRC

Get variable 'Speed' and update it with value read from user input. 

#+BEGIN_SRC cpp 
  // Retrieve variable speed
  auto [pSpeed, _size2 ] = mf.find<double>("Speed");
  assert(pSpeed != nullptr);
  std::cout << "Speed = " << *pSpeed << "\n";
  std::cout << " => Set new speed := ";
  std::cin >> *pSpeed;
#+END_SRC

Get vector named 'AVector', display, and update it. 

#+BEGIN_SRC cpp 
  // Rerieve vector
  auto [pVector, _size3] = mf.find<MMFVector<double>>("AVector");
  assert(pVector != nullptr);
  std::cout << "\n pVector->size() = " << pVector->size() << std::endl;
  size_t idx = 0;
  for(auto const& x: *pVector)
     std::cout << " pVector[" << idx++ << "] = " << x << std::endl ;	

  pVector->push_back(*pSpeed);	
  return 0;
#+END_SRC

 *Compile on Linux or any other Unix-like OS*

#+BEGIN_SRC sh    
  # Clang 
  $ clang++ boost-memory-mapped-file.cpp -o boost-memory-mapped-file.bin -std=c++1z -g -O0 -Wall -lpthread -lrt 
  # GCC
  $ g++ boost-memory-mapped-file.cpp -o boost-memory-mapped-file.bin -std=c++1z -g -O0 -Wall -lpthread -lrt 
#+END_SRC

 *Compile on Windows*

Compile with MSVC (VC++)

#+BEGIN_SRC bat
  $ cl.exe boost-memory-mapped-file.cpp /Fe:boost-memory-mapped-file.exe /EHsc /std:c++17 ...
     /GA /MDd /nologo /I C:\boost\boost_1_69_0 /link /LIBPATH:C:\boost\lib
#+END_SRC

Compile with Mingw

#+BEGIN_SRC sh 
  $ g++ boost-memory-mapped-file.cpp -o boost-memory-mapped-file.exe -std=c++1z -I C:\boost\boost_1_69_0
#+END_SRC

 *Running* 

Running for the first time, before the file 'memory-dump.dat'
exists. Note: (compiled with Mingw).

#+BEGIN_SRC sh 
  F:\boost> boost-memory-mapped-file.exe

   [INFO] Setting file data
#+END_SRC

Running for the second time: 

#+BEGIN_SRC sh 
  F:\boost> boost-memory-mapped-file.exe

   [INFO] Retrieving objects from memory mapped file
  Number of nodes = 100
  Text = 'Allocated text in memory mapped file'
  Speed = 200
   => Set new speed := 4.51

   pVector->size() = 4
   pVector[0] = 40.5
   pVector[1] = 98.1
   pVector[2] = -50.45
   pVector[3] = 10
#+END_SRC

Running for the third time: 

#+BEGIN_SRC sh 
  F:\boost> boost-memory-mapped-file.exe
   [INFO] Retrieving objects from memory mapped file
  Number of nodes = 101
  Text = 'Allocated text in memory mapped file'
  Speed = 4.51
   => Set new speed := 125.75

   pVector->size() = 5
   pVector[0] = 40.5
   pVector[1] = 98.1
   pVector[2] = -50.45
   pVector[3] = 10
   pVector[4] = 4.51
#+END_SRC

**  Boost DateTime 
*** Overview 

Documentation:
  + Boost: [[https://www.boost.org/doc/libs/1_69_0/doc/html/date_time.html][Date Time]]
  + [[http://www.crystalclearsoftware.com/libraries/date_time/release_1_33/date_time/doxy.html][Doxygen]]
  + [[http://www.crystalclearsoftware.com/libraries/date_time/date_time.pdf][PDF Documentation]]

Documentation Code Examples: 
 + [[https://www.boost.org/doc/libs/1_69_0/doc/html/date_time/examples.html#date_time.examples.days_alive][Date Time Examples]]

Headers: 
 + <boost/date_time/date.hpp>
 + <boost/date_time/date_formatting.hpp>
 + <boost/date_time/date_duration.hpp>
 + <boost/date_time/time.hpp>
 + <boost/date_time/gregorian/gregorian.hpp>

Library Dependency:
 + Requires linkign the library *-lboost_date_time* with GCC or Clang.

Motivation: 

#+BEGIN_QUOTE
  The motivation for this library comes from working with and helping
  build several date-time libraries on several projects. Date-time
  libraries provide fundamental infrastructure for most development
  projects. However, most of them have limitations in their ability to
  calculate, format, convert, or perform some other functionality. For
  example, most libraries do not correctly handle leap seconds,
  provide concepts such as infinity, or provide the ability to use
  high resolution or network time sources. These libraries also tend
  to be rigid in their representation of dates and times. Thus
  customized policies for a project or subproject are not possible.
 #+END_QUOTE

Domain Concepts: 
 + Time Point
 + Time Duration
 + Time Interval 

Calendar Systems: 
 + Gregorian System
 + UTC - UTC (Coordinated Universal Time) 
*** Example - Date Manipulation 

Search where is Boost Date time on Linux/Fedora: 

#+BEGIN_SRC sh 
  $ ls /lib/ | grep -i date
  kconf_update_bin/
  libboost_date_time.a
  libboost_date_time.so@
  libboost_date_time.so.1.67.0*
#+END_SRC

 *Simple tests in CERN ROOT REPL:*

Load library in REPL:

#+BEGIN_SRC cpp 
  #include <boost/date_time/gregorian/gregorian.hpp>

  // Load shared library 
  gSystem->Load("/lib/libboost_date_time.so")

  namespace g = boost::gregorian;
  namespace dt = boost::date_time;
#+END_SRC

Construct a date from year-month-day, for instance 
(year = 2009, month = 10, day = 20):

#+BEGIN_SRC cpp 
  >> auto d1 = g::date(2009, 10, 20)
  (boost::gregorian::date &) @0x7fd6d7647050

  >> stg::cout << "d1 = " << d1 << "\n";
  d1 = 2009-Oct-20
#+END_SRC


Get current Date: 

#+BEGIN_SRC cpp 
  >> auto today = g::day_clock::local_day()
  (boost::gregorian::date &) @0x7fd6d7647030

  >> stg::cout << "today = " << today << "\n";
  today = 2019-Apr-02
  >> 
#+END_SRC

Convert date to string: 

#+BEGIN_SRC cpp 
  >> auto mdate = g::date(2012, 06, 21)
  (boost::gregorian::date &) @0x7f83a2ba70a8

  >> g::to_simple_string(mdate)
  (std::string) "2012-Jun-21"

  >> g::to_iso_string(mdate)
  (std::string) "20120621"

  >> g::to_iso_extended_string(mdate)
  (std::string) "2012-06-21"
#+END_SRC


Parse Date with ISO format YYYYMMDD:

#+BEGIN_SRC cpp 
  >> auto p = gr::from_undelimited_string("20100921")
  (boost::gregorian::date &) @0x7f83a2ba7014

  >> std::cout << " p = " << p << "\n";
   p = 2010-Sep-21
#+END_SRC

Parse Date with ISO format YYYY-MM-DD: 

#+BEGIN_SRC cpp 
  g::from_simple_string("2001-10-11")

  >> auto s1 = g::from_simple_string("2001-10-11")
  (boost::gregorian::date &) @0x7fd6d7647010

  // ========= Parse Date =============
  >> stg::cout << "s1 = " << s1 << "\n";
  s1 = 2001-Oct-11
#+END_SRC


Get year component:

#+BEGIN_SRC cpp 
  >> s1.year()
  (boost::date_time::date<boost::gregorian::date, boost::gregorian::gregorian_calendar, 
   boost::gregorian::date_duration>::year_type) @0x79588b0
  >> 

  >> (int) s1.year()
  (int) 2001

  >> static_cast<int>(s1.year())
  (int) 2001
  >> 
#+END_SRC

Get month component:

#+BEGIN_SRC cpp 
  >> s1.month()
  (boost::date_time::date<boost::gregorian::date, boost::gregorian::gregorian_calendar, 
  boost::gregorian::date_duration>::month_type) @0x7d69550

  >> (int) s1.month()
  (int) 10

  >> static_cast<int>(s1.month())
  (int) 10
  >> 
#+END_SRC

Get day component: 

#+BEGIN_SRC cpp 
  >> s1.day()
  (boost::date_time::date<boost::gregorian::date, boost::gregorian::gregorian_calendar, 
  boost::gregorian::date_duration>::day_type) @0x7f9bfc0

  >> (int) s1.day()
  (int) 11

  >> stg::cout << s1.day() << "\n";
  11
#+END_SRC

Get day of Week: 

#+BEGIN_SRC cpp 
  >> auto dw = s1.day_of_week()
  (boost::gregorian::greg_weekday &) @0x7fd6d764702e

  >> (int) dw
  (int) 4

  >> (int) s1.day_of_week()
  (int) 4

  >> static_cast<int>(dw)
  (int) 4
#+END_SRC

Get day of Week as Enumeration:

#+BEGIN_SRC cpp 
  >> auto dw = s1.day_of_week()
  (boost::gregorian::greg_weekday &) @0x7fd6d764702e

  >> dw.as_enum()
  (boost::gregorian::greg_weekday::weekday_enum) (boost::date_time::weekdays::Thursday) : (unsigned int) 4

  >> dw.as_enum() == dt::weekdays::Thursday
  (bool) true  
#+END_SRC

Get day of Week as C-string (const char*): 

#+BEGIN_SRC cpp 
  >> dw.as_short_string()
  (const char *) "Thu"

  >> dw.as_long_string()
  (const char *) "Thursday"
#+END_SRC

Get day of year (number of elapsed days until the date s1)

#+BEGIN_SRC cpp 
  >> s1.day_of_year()
  (boost::gregorian::date::day_of_year_type) @0x8000e30

  >> (int) s1.day_of_year()
  (int) 284

  >> static_cast<int>(s1.day_of_year())
  (int) 284
#+END_SRC

Get difference between two dates in days: 

#+BEGIN_SRC cpp 
  >> auto date_a = g::date(2009, 10, 20)
  (boost::gregorian::date &) @0x7fd6d7647068

  >> auto date_b = g::date(2011, 1, 1)
  (boost::gregorian::date &) @0x7fd6d764706c

  >> auto diff = date_b - date_a
  (boost::gregorian::date_duration &) @0x7fd6d7647070

  >> diff.days()
  (long) 438
#+END_SRC

 *Date arithmetics:*

Add days to a date: 

 + Add 200 days to date 2005-09-25 

#+BEGIN_SRC cpp 
  >> auto date_a = g::date(2005, 9, 25)
  (boost::gregorian::date &) @0x7f83a2ba7048

  >> std::cout << "date_a = " << date_a << "\n";
  date_a = 2005-Sep-25

  // Create a new date object = date_a + 200 days 
  >> auto date_b = date_a + g::days(200)
  (boost::gregorian::date &) @0x7f83a2ba7060

  >> std::cout << "date_b = " << date_b << "\n";
  date_b = 2006-Apr-13

  >> std::cout << "date_a + 200 days = " << date_a + g::days(200) << "\n";
  date_a + 200 days = 2006-Apr-13

  >> std::cout << "date_a + 1200 days = " << date_a + g::days(1200) << "\n";
  date_a + 1200 days = 2009-Jan-07
#+END_SRC

Add months to a date: 
 + Add 5 months to date 2005-09-25

#+BEGIN_SRC cpp 
    >> auto date_a = g::date(2005, 9, 25)
    (boost::gregorian::date &) @0x7f83a2ba7048

    >> std::cout << "date_a + 5 months  = " << date_a + g::months(5) << "\n";
    date_a + 5 months  = 2006-Feb-25
#+END_SRC


** Library Map 
*** Math 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/index.html][Math Toolkit 2.8.0 - 1.69.0]]
  + Brief: The math toolkit provides the following facilities:
    + Floating Point Utilities
    + Specific Width Floating Point Types
    + *Statistical Distributions* (Gaussian, Poisson, Bernouli...)
    + Mathematical Special Function
    + Root Finding and Function
    + Minimisations, Polynomials and Rational Functions
    + Interpolation
    + Numerical Integration and Differentiation
    + Quaternions and Octonions.   
  + [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/special.html][Chapter 6. Special Functions - 1.69.0]]
  + [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/dist.html][Chapter 5. Statistical Distributions and Functions - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/numeric/ublas/][uBLAS]] (Linear algebra facilities, linear systems, vector matrices
  and so on.)
  + Brief: "uBLAS provides matrix and vector classes as well as basic
    linear algebra routines. Several dense, packed and sparse storage
    schemes are supported."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/numeric/odeint/doc/html/boost_numeric_odeint/getting_started/overview.html][Boost Odeint]]
  + Library for ordinary differential equations - initial value
    problems.

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/date_time.html][Date Time]]
  + Brief: "A set of date-time libraries based on generic programming concepts."
  + Descr: "The motivation for this library comes from working with
    and helping build several date-time libraries on several
    projects. Date-time libraries provide fundamental infrastructure
    for most development projects. However, most of them have
    limitations in their ability to calculate, format, convert, or
    perform some other functionality. For example, most libraries do
    not correctly handle leap seconds, provide concepts such as
    infinity, or provide the ability to use high resolution or
    network time sources. These libraries also tend to be rigid in
    their representation of dates and times. Thus customized policies
    for a project or subproject are not possible."

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/chrono.html][Chapter 7. Boost.Chrono 2.0.8 - 1.69.0]] (Time interval computation,
  already in C++11, but it is a good documentation for the STL
  library.) 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/accumulators.html][Accumulators]]
  + Summary: Incremental statistics.
  + Descr: "Boost.Accumulators is both a library for incremental statistical
    computation as well as an extensible framework for incremental
    calculation in general. The library deals primarily with the
    concept of an accumulator, which is a primitive computational
    entity that accepts data one sample at a time and maintains some
    internal state. These accumulators may offload some of their
    computations on other accumulators, on which they
    depend. Accumulators are grouped within an accumulator
    set. Boost.Accumulators resolves the inter-dependencies between
    accumulators in a set and ensures that accumulators are processed
    in the proper order."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/multiprecision/doc/html/boost_multiprecision/intro.html][Boost Multiprecisions]]
  + Brief: "The Multiprecision Library provides integer, rational,
    floating-point, and complex types in C++ that have more range and
    precision than C++'s ordinary built-in types. The big number
    types in Multiprecision can be used with a wide selection of
    basic mathematical operations, elementary transcendental
    functions as well as the functions in Boost.Math. The
    Multiprecision types can also interoperate with the built-in
    types in C++ using clearly defined conversion rules. This allows
    Boost.Multiprecision to be used for all kinds of mathematical
    calculations involving integer, rational and floating-point types
    requiring extended range and precision."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/units/][Units]]
  + Brief: "Zero-overhead dimensional analysis and unit/quantity
    manipulation and conversion."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/multi_array/doc/user.html][The Boost Multidimensional Array Library (Boost.MultiArray) - 1.69.0]]
  + Brief: Multidimensional arrays, aka tensors. 

*** Parallel Computing 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/mpi.html][Chapter 26. Boost.MPI - 1.69.0]]
  + Brief: "Boost.MPI is a library for message passing in high-performance
    parallel applications. A Boost.MPI program is one or more
    processes that can communicate either via sending and receiving
    individual messages (point-to-point communication) or by
    coordinating as a group (collective communication). Unlike
    communication in threaded environments or using a shared-memory
    library, Boost.MPI processes can be spread across many different
    machines, possibly with different operating systems and
    underlying architectures."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/compute/doc/html/index.html][Chapter 1. Boost.Compute - 1.69.0]]
  + Brief: "The Boost Compute library provides a C++ interface to
    multi-core CPU and GPGPU computing platforms based on OpenCL." 
 
*** String Utilities 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_lexical_cast.html][Chapter 21. Boost.Lexical_Cast 1.0 - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/format/][The Boost Format library - 1.69.0]]
  + The format library provides a class for formatting arguments
    according to a format-string, as does printf, but with two major
    differences : format sends the arguments to an internal stream,
    and so is entirely type-safe and naturally supports all
    user-defined types. The ellipsis (...) can not be used correctly
    in the strongly typed context of format, and thus the function
    call with arbitrary arguments is replaced by successive calls to
    an argument feeding operator%

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/string_algo.html][String algo]]
  + Brief: "The String Algorithm Library provides a generic
    implementation of string-related algorithms which are missing in
    STL. It is an extension to the algorithms library of STL and it
    includes trimming, case conversion, predicates and find/replace
    functions. All of them come in different variants so it is easier
    to choose the best fit for a particular need." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/spirit/][Boost Spirit]]
  + Brief: Framework for building parsers.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/tokenizer/][Tokenizer]]
  + Brief: "Break of a string or other character sequence into a
    series of tokens."

*** Template Metaprogramming facilities 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/utility/operators.htm][Boost Operators]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/range/][Range]] [BEST]
  + Descr: "A new infrastructure for generic algorithms that builds
    on top of the new iterator concepts."
  + Note: Maybe the future replacement for C++ classical iterators.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/hof/doc/html/doc/src/index.html][Boost.HigherOrderFunctions]] (aka Boost.Hof)
  + Brief: Provides many higher order functions. 
  + Descr: HigherOrderFunctions is a header-only C++11/C++14 library that
    provides utilities for functions and function objects, which can
    solve many problems with much simpler constructs than whats
    traditionally been done with metaprogramming.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/mp11/doc/html/mp11.html][Boost.Mp11: A C++11 metaprogramming library - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/fusion/doc/html/fusion/preface.html][Boost Fusion]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/hana/doc/html/index.html][Boost.Hana]]
  + Brief: "Hana is a header-only library for C++ metaprogramming
    suited for computations on both types and values."
  + Descr: "The functionality it provides is a superset of what is
    provided by the well established Boost.MPL and Boost.Fusion
    libraries. By leveraging C++11/14 implementation techniques and
    idioms, Hana boasts faster compilation times and runtime
    performance on par or better than previous metaprogramming
    libraries, while noticeably increasing the level of
    expressiveness in the process. Hana is easy to extend in a ad-hoc
    manner and it provides out-of-the-box inter-operation with
    Boost.Fusion, Boost.MPL and the standard library." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/concept_check/][Concept check]]
  + Descr: "Tools for generic programming."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/proto/][Proto]]
  + Brief: "Expression template library and compiler construction
    toolkit for domain-specific embedded languages."

*** Design Patterns and Object Oriented Design Patterns 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_typeerasure.html][Chapter 40. Boost.TypeErasure - 1.69.0]]
  + Brief: "The Boost.TypeErasure library provides runtime
    polymorphism in C++ that is more flexible than that provided by
    the core language. The Boost.TypeErasure library combines the
    superior abstraction capabilities of templates, with the runtime
    flexibility of virtual functions."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/ptr_container/doc/ptr_container.html][Boost Pointer Container Library - 1.69.0]]
  + Brief: "Boost.Pointer Container provides containers for holding
    heap-allocated objects in an exception-safe manner and with
    minimal overhead. The aim of the library is in particular to make
    OO programming easier in C++ by establishing a standard set of
    classes, methods and designs for dealing with OO specific
    problems." 

+ [[https://www.boost.org/doc/libs/release/libs/flyweight/][Boost Flyweight]]
  + Brief: Descr: "Design pattern to manage large quantities of
    highly redundant objects."

  + Descr: "Flyweights are small-sized handle classes granting
    constant access to shared common data, thus allowing for the
    management of large amounts of entities within reasonable memory
    limits. Boost.Flyweight makes it easy to use this common
    programming idiom by providing the class template flyweight<T>,
    which acts as a drop-in replacement for const T."

  + Additional notes:
    + "Learning to use Boost.Flyweight can be accomplished in a matter
      of minutes. When special needs arise, however, an extensive
      customization interface is provided which allows the user to
      control and extend the following aspects:"
    + Type tagging for separation of domains using the same basic flyweight types.
    + Specification and parameterization of the so-called flyweight factory.
    + Control of the factory instantiation procedure.
    + Specification of the internal synchronization mechanisms.
    + Flyweight tracking, allowing for the disposal of stored values
      when no longer referenced by any flyweight object.

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/property_tree.html][Chapter 32. Boost.PropertyTree - 1.69.0]]
  + "The Property Tree library provides a data structure that stores
    an arbitrarily deeply nested tree of values, indexed at each
    level by some key. Each node of the tree stores its own value,
    plus an ordered list of its subnodes and their keys. The tree
    allows easy access to any of its nodes by means of a path, which
    is a concatenation of multiple keys." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/functional/factory/doc/html/index.html][Boost.Functional/Factory]]
  + Brief: "The template boost::factory lets you encapsulate a new
    expression as a function object, boost::value_factory
    encapsulates a constructor invocation without new."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/property_map/doc/property_map.html][Property Map Library - 1.69.0]]

*** Command Line Options 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/program_options.html][Chapter 31. Boost.Program_options - 1.69.0]]

*** Debugging, Logging and Assertions 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/log/doc/html/index.html][Chapter 1. Boost.Log v2 - 1.69.0]]
  + Descr: "The application stores all essential information about its
    execution to a log, and when something goes wrong this
    information can be used to analyze the program behavior and make
    the necessary corrections. There are other very useful
    applications of logging, such as gathering statistical
    information and highlighting events (i.e. indicating that some
    situation has occurred or that the application is experiencing
    some problems). These tasks have proved to be vital for many
    real-world industrial applications. This library aims to make
    logging significantly easier for the application developer. It
    provides a wide range of out-of-the-box tools along with public
    interfaces for extending the library. The main goals of the
    library are:"
    + Simplicity. A small example code snippet should be enough to
      get the feel of the library and be ready to use its basic
      features.
    + Extensibility. A user should be able to extend functionality of
      the library for collecting and storing information into logs.
    + Performance. The library should have as little performance
      impact on the user's application as possible.

*** Network - Sockets - TCP/IP

+ [[https://www.boost.org/doc/libs/1_69_0/libs/asio/][Boost Asio]]
  + Descr: "Portable networking and other low-level I/O, including sockets,
    timers, hostname resolution, socket iostreams, serial ports, file
    descriptors and Windows HANDLEs."

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/crc.html][Boost CRC]] - CRC (Cyclick Redundancy Checking)
  + Descr: " CRCs (cyclic redundancy codes) is one common technique
    to confirming data integrity after transmission. The Boost.CRC
    library provides access to two styles of CRC computation, one as
    a function template, the other as a function template and two
    computation object class templates, where the two class templates
    differ in speed."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/statechart/][Statechart]]
  + Brief: "Boost.Statechart - Arbitrarily complex finite state
    machines can be implemented in easily readable and maintainable
    C++ code."
  + Note: Many network protocols, embedded systems applications and
    business processes are well described by state machines such as
     [[https://en.wikipedia.org/wiki/Mealy_machine][Mealy state machine]] or [[https://en.wikipedia.org/wiki/Moore_machine][Moore State machine]].

+ [[https://www.boost.org/doc/libs/1_69_0/libs/uuid/][UUID]] - A universally unique identifier.

*** Shared Libraries and Plugins - DLL, DSO, SO

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_dll.html][Boost DLL]]
  + Brief: "This library was designed to simplify plugin development using C++ in a portable cross-platform manner."
  + Descr: "Adding a specific features to an existing software
    applications at runtime could be useful in many cases. Such
    extensions, or plugins, are usually implemented using Dynamic
    Library Modules (DLL,SO/DSO) loaded at runtime."
  + Library provides a portable across platforms way to:
    + load libraries
    + import any native functions and variables
    + make alias names for C++ mangled functions and symbols
    + query libraries for sections and exported symbols
    + self loading and self querying
    + getting program and module location by exported symbol

*** Subprocess and inter process communication - IPC 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/interprocess.html][Boost.Interprocess]]
  + Brief: "Boost.Interprocess simplifies the use of common
    interprocess communication and synchronization mechanisms and
    offers a wide range of them:"
    + Shared memory.
    + Memory-mapped files.
    + Semaphores, mutexes, condition variables and upgradable mutex
      types to place them in shared memory and memory mapped files.
    + Named versions of those synchronization objects, similar to UNIX/Windows sem_open/CreateSemaphore API.
    + File locking.
    + Relative pointers.
    + Message queues.
  + Additional:
    + Boost.Interprocess also offers higher-level interprocess
      mechanisms to allocate dynamically portions of a shared memory
      or a memory mapped file (in general, to allocate portions of a
      fixed size memory segment). Using these mechanisms,
      Boost.Interprocess offers useful tools to construct C++
      objects, including STL-like containers, in shared memory and
      memory mapped files:

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/process.html#boost_process.introduction][Boost.Process]]
  + Brief: "Boost.Process is a library to manage system processes. It
    can be used to:"
    + create child processes
    + setup streams for child processes
    + communicate with child processes through streams (synchronously
      or asynchronously)
    + wait for processes to exit (synchronously or asynchronously)
    + terminate processes

*** Low level and byte manipulation 

  + [[https://www.boost.org/doc/libs/1_69_0/libs/endian/doc/index.html][Endian Library - 1.69.0]]

* Complementary Libraries 
** fmtlib (fmt) - Better printf 

Fmt is a highly popular library for printing  in a formatted way just
like the old C's printf, however fmt is type safe like std::ostream
IO, however its format specifiers are more concise and based on Python
ones.

Web Site:
 + http://fmtlib.net/latest/index.html

Repository: 
 + https://github.com/fmtlib/fmt

Conan Refence: 
 + [[https://bintray.com/bincrafters/public-conan/fmt%253Abincrafters/5.3.0%253Astable][fmt/5.3.0@bincrafters/stable]] 

 *Library Local Installation for header-only usage* 

Installation at: ~/dev/include/fmt 

#+BEGIN_SRC sh 
 $ git clone https://github.com/fmtlib/fmt

 # Build directory /home/<USER>/dev on Linux 
 $ mkdir -p ~/dev && cd dev                           
 # Clone repository 
 $ git clone https://github.com/fmtlib/fmt
 # Extract headers 
 $ cp -r -v fmt/include ~/dev/
 # Delete fmt directory 
 $ rm -rf fmt 
#+END_SRC

Testing code: File - *fmttest.cpp*

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <fstream>
  #include <cmath>
  #include <sstream>

  // If defined before including fmt, uses it as header-only library
  #define FMT_HEADER_ONLY

  // Basic functionality
  #include <fmt/core.h>
  // fmt string literals "name"_a, "product"_a
  #include <fmt/format.h>
  // Print to streams std::cout, std::cerr, std::ostream
  #include <fmt/ostream.h>

  #include <fmt/color.h>

  // #include <fmt/color.h>

  using namespace fmt::literals;

  void printHeader(const char* header)
  {
      fmt::print("\n{}\n", header);
      fmt::print("---------------------------------------------\n");
  }

  int main()
  {
      printHeader(" ***** EXPERIMENT 1 - Boolean  *************");
      fmt::print(" true == {0} ; false == {1} \n", true, false);


      printHeader(" ***** EXPERIMENT 2 - Numeric Base  *********");

      fmt::print(" [BASES] => dec: {0:d} ; hex = 0x{0:X} "
                 " ; oct = {0:o} ; bin = 0b{0:b} \n", 241 );

      printHeader(" ***** EXPERIMENT 3 - Positional arguments ****");

      fmt::print(" first = {0}, 2nd = {1}, 1st = {1}, 3rd = {2}\n",
                  200, "hello", 5.615);

      printHeader("**** EXPERIMENT 4 - Named Arguments ********* ");

      fmt::print(" [A] Product => product = {0} id = {1} price = {2}\n"
                 ,"oranges 1 kg", 200, 10.6758 );

      // Requires: #include <fmt/format.h>
      // using namespace fmt::literals;
      fmt::print(" [B] Product => product = {product} id = {id} price = {price:.2F}\n"
                 , "product"_a = "oranges 1 kg", "id"_a = 200, "price"_a = 10.6758 );

      fmt::print(" [B] Product => product = {product} id = {id} price = {price:.2F}\n"
                 , fmt::arg("product", "oranges 1 kg")
                 , fmt::arg("id",  200)
                 , fmt::arg("price", 10.6758 ));

      printHeader("************ Colored Output ******************");

      fmt::print( fmt::fg(fmt::color::aqua) | fmt::emphasis::bold,
                 " [INFO] Voltage Leval  = {0:+.3F}\n", 10.6478);

      fmt::print( fmt::fg(fmt::color::red) | fmt::emphasis::underline,
                 " [ERROR] Fatal Error, shutdown systems code  0x{0:X}\n", 2651);


      printHeader(" ***** EXPERIMENT 5 - Numeric Formatting ******");

      double x = 20.0;
      fmt::print("The square root of x = {}\n", std::sqrt(x));

      x = 28524.0;

      fmt::print(" log(x) = {:.2F}  (2 digit precision)\n", std::log(x));
      fmt::print(" log(x) = {:+.6F} (6 digit precision)\n", std::log(x));
      fmt::print(" 2000 * log(x) = {:+.6G} (6 digit precision)\n", 1e5 * std::log(x));
      fmt::print("  log(x) = {0:+.8E} ; sqrt(x) = {1:+8E} (8 digit precision)\n",
                 std::log(x), std::sqrt(x));

      printHeader(" ***** EXPERIMENT 6 - Print numeric table ******");

      int i = 0;
      for(double x = 0.0; x <= 4.0; x += 0.5)
          fmt::print("{0:8d}{1:10.5F}{2:10.5F}\n", i++, x, std::exp(x));

      printHeader(" ***** EXPERIMENT 7 - Print table to file *******");

      // std::ofstream file("/tmp/table.txt");
      std::stringstream file; // Fake file

      i = 0;

      // Note: Requires <fmt/ostream.h>
      for(double x = -4.0; x <= 4.0; x += 1.0)
          fmt::print(file, "{0:8d}{1:10.5F}{2:10.5F}\n", i++, x, std::exp(x));

      fmt::print("File content = \n{0}", file.str());

      return 0;
  }
#+END_SRC

Program output: 

#+BEGIN_SRC text 
   ,***** EXPERIMENT 1 - Boolean  *************
  ---------------------------------------------
   true == true ; false == false 

   ,***** EXPERIMENT 2 - Numeric Base  *********
  ---------------------------------------------
   [BASES] => dec: 241 ; hex = 0xF1  ; oct = 361 ; bin = 0b11110001 

   ,***** EXPERIMENT 3 - Positional arguments ****
  ---------------------------------------------
   first = 200, 2nd = hello, 1st = hello, 3rd = 5.615

  ,**** EXPERIMENT 4 - Named Arguments ********* 
  ---------------------------------------------
   [A] Product => product = oranges 1 kg id = 200 price = 10.6758
   [B] Product => product = oranges 1 kg id = 200 price = 10.68
   [B] Product => product = oranges 1 kg id = 200 price = 10.68

  ,************ Colored Output ******************
  ---------------------------------------------
  [1m[38;2;000;255;255m [INFO] Voltage Leval  = +10.648
  [0m[4m[38;2;255;000;000m [ERROR] Fatal Error, shutdown systems code  0xA5B
  [0m
   ,***** EXPERIMENT 5 - Numeric Formatting ******
  ---------------------------------------------
  The square root of x = 4.47213595499958
   log(x) = 10.26  (2 digit precision)
   log(x) = +10.258501 (6 digit precision)
   2000 * log(x) = +1.02585e+06 (6 digit precision)
    log(x) = +1.02585011E+01 ; sqrt(x) = +1.688905E+02 (8 digit precision)

   ,***** EXPERIMENT 6 - Print numeric table ******
  ---------------------------------------------
         0   0.00000   1.00000
         1   0.50000   1.64872
         2   1.00000   2.71828
         3   1.50000   4.48169
         4   2.00000   7.38906
         5   2.50000  12.18249
         6   3.00000  20.08554
         7   3.50000  33.11545
         8   4.00000  54.59815

   ,***** EXPERIMENT 7 - Print table to file *******
  ---------------------------------------------
  File content = 
         0  -4.00000   0.01832
         1  -3.00000   0.04979
         2  -2.00000   0.13534
         3  -1.00000   0.36788
         4   0.00000   1.00000
         5   1.00000   2.71828
         6   2.00000   7.38906
         7   3.00000  20.08554
         8   4.00000  54.59815
#+END_SRC

Compilation: 

#+BEGIN_SRC sh 
  $ g++  fmttest.cpp -o app.bin -std=c++1z -Wall -I$HOME/dev/include 

  # Or, on Linux
  $ clang++  fmttest.cpp -o app.bin -std=c++1z -Wall -I/home/<USER>/dev/include 

  # Or, On OSX 
  $ clang++  fmttest.cpp -o app.bin -std=c++1z -Wall -I/Users/<USER>/dev/include 
#+END_SRC

The code can be compiled without specifying the include path, by
adding the following code to the file  *~/.profile* on Linux.

#+BEGIN_SRC sh 
  #------------ Local Libraries Installation ---------------------
  LOCAL_LIB_PATH=~/dev
  export CPLUS_INCLUDE_PATH=$LOCAL_LIB_PATH/include:$CPLUS_INCLUDE_PATH
  export C_INCLUDE_PATH=$LOCAL_LIB_PATH/include:$C_INCLUDE_PATH
  export LIBRARY_PATH=$LOCAL_LIB_PATH/lib:$LIBRARY_PATH
  export LD_LIBRARY_PATH=$LOCAL_LIB_PATH/lib:$LD_LIBRARY_PATH
#+END_SRC

After this configuration was set, the code can be compiled with:

#+BEGIN_SRC sh 
  $ g++  fmttest.cpp -o app.bin -std=c++1z -Wall

  # Header only compilation takes 2 seconds 
  $ time g++  fmttest.cpp -o app.bin -std=c++1z -Wall

  real	0m1.824s
  user	0m1.650s
  sys	0m0.156s
#+END_SRC

Once the environment variabble CPLUS_INCLUDE_PATH is set, the library
can be loaded from CERN's Root or Cling REPL with:  

#+BEGIN_SRC cpp 
  #define FMT_HEADER_ONLY
  #include <fmt/format.h>
  #include <fmt/color.h>
  #include <fmt/ostream.h>

  >> fmt::print(" x = {0:.5F}, sqrt(x) = {1:+.8F}\n", 20.6, std::sqrt(20.6))
   x = 20.60000, sqrt(x) = +4.53872229
  >> 

  // Print with color foreground blue 
  >> fmt::print(fmt::fg(fmt::color::blue), " [INFO] x = {0:.5E}\n", 20.6)
   [INFO] x = 2.06000E+01

  // Print with background color blue 
  >> fmt::print(fmt::bg(fmt::color::blue), " [INFO] x = {0:.5E}\n", 20.6)
   [INFO] x = 2.06000E+01
  >> 
#+END_SRC
** Range v3 (C++20)

Ranges v3 is a header-only generic library that will be included in
the [[https://en.cppreference.com/w/cpp/ranges][C++20 ranges]] and provides stl-like algorithms that can operate on
ranges, also known as pairs of iterators. The benefit of the range v3
library over STL algorithms and iterator pairs is that the greater
composability and that the calling code does not need to specify the
iterator pair explicitly.

Resources: 

  * Documentation:
    + https://ericniebler.github.io/range-v3/

  * Conan Reference:
    * [[https://bintray.com/range-v3/range-v3/range-v3%253Aericniebler][range-v3/0.5.0@ericniebler/stable]]

  * Github Repsitory:
    + https://github.com/ericniebler/range-v3

  * C++ Standard Proposal:
    + https://ericniebler.github.io/std/wg21/D4128.html

    + [[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html][Ranges for the Standard Library, Revision 1]]

  * C++20 - <ranges> header
    + https://en.cppreference.com/w/cpp/ranges

  * Videos:
    + [[https://www.youtube.com/watch?v=mFUXNMfaciE][CppCon 2015: Eric Niebler "Ranges for the Standard Library"]]
    + [[https://www.youtube.com/watch?v=4p21wBOplPQ][Introduction to C++ Ranges - Fluent C++]]
    + [[https://www.youtube.com/watch?v=OI0YFgEscGQ][C++ Russia 2018: Arno Schödl, From Iterators To Ranges]]

Headers: 
 + Include all features:
   + <range/v3/all.hpp>  (Note: It increase the compile-time)

 + Algorithms
   + <range/v3/action/join.hpp>
   + <range/v3/algorithm/copy.hpp>
   + <range/v3/algorithm/for_each.hpp>
   + <range/v3/algorithm/mismatch.hpp>

 + All
   + <range/v3/view/transform.hpp>
   + <range/v3/core.hpp>
   + <range/v3/view/all.hpp>
   + <range/v3/view/concat.hpp>
   + <range/v3/view/group_by.hpp>
   + <range/v3/view/iota.hpp>
   + <range/v3/view/join.hpp>
   + <range/v3/view/repeat_n.hpp>
   + <range/v3/view/single.hpp>
   + <range/v3/view/take.hpp>
   + <range/v3/view/transform.hpp>

Built-in Range Views: 
 + Views are lazily evaluated algorithms that are computed on demand
   without any wasteful allocation. 
 

|--------------------+------------+-------------+--------------|
| adjacent_remove_if | drop_while | map         | split        |
| all                | empty      | move        | stride       |
| any_range          | filter     | parital_sum | tail         |
| bounded            | for_each   | remove_if   | take         |
| c_str              | generate   | repeat      | take_exactly |
| chunck             | generate_n | repetat_n   | take_while   |
| concat             | group_by   | replace     | tokenize     |
| const_             | indirect   | replace_if  | transform    |
| counted            | interspece | reverse     | unbounded    |
| delimit            | iota       | single      | unique       |
| drop               | join       | slice       | zip_with     |
|--------------------+------------+-------------+--------------|

Built-in Range Actions: 
 + Actions are eager sequence algorithms that operates on containers
   and returns containers. 

|------------+------------+-------------|
| drop       | push_front | stable_sort |
| drop_while | remove_if  | stride      |
| erase      | shuffle    | take        |
| insert     | slice      | take_while  |
| join       | sort       | transform   |
| push_back  | split      | unique      |
|------------+------------+-------------|

Comparison Range Views X Range Actions: 

|----------------------------+------------------------------------------------|
| Range Views                | Range Actions                                  |
|----------------------------+------------------------------------------------|
| Lazy sequence algorithms   | Eager sequence algorithms                      |
| Lightweightm, non owning   | Operates on containers and returns containers. |
| Doesn't perform allocation | Performs allocation                            |
| Composable                 | Composable                                     |
| Non-mutating               | Potentially mutating                           |
|----------------------------+------------------------------------------------|


 *Example:*

 + Complete source: 
   + [[https://gist.github.com/caiorss/6d1ca8c20e71ea72866fe799408c6add#file-main1-cpp][Experiments with C++ ranges v3 Library  - Gisthub]]
   + File: [[https://gist.github.com/caiorss/6d1ca8c20e71ea72866fe799408c6add#file-main1-cpp][main1.cpp]]

 *Main Function - Range Algorithms Experiments*

 + Experiment 1A: 

#+BEGIN_SRC cpp 
    std::cout << "   +------------------------------------+\n"
              << "   | Range Algorithms Experiments       |\n"
              << "   +------------------------------------+\n";

    auto printLambda = [](auto x){
        std::cout << " x = " << x << std::endl;
    };

    // std::cout << view::iota(2, 10) << std::endl;

    //-------------------------------------------//
    std::puts("\n === EXPERIMENT 1 A - for_each ===");
    {

        std::vector<int> xs = {8, 9, 20, 25};
        std::cout << " => Print numbers" << std::endl;
        ranges::for_each(xs, printLambda);

        std::deque<std::string> words = {"c++", "c++17", "C++20", "asm", "ADA"};
        std::cout << " => Print words" << std::endl;
        ranges::for_each(xs, printLambda);
}
#+END_SRC

Output: 

#+BEGIN_SRC text 
     +------------------------------------+
     | Range Algorithms Experiments       |
     +------------------------------------+

   === EXPERIMENT 1 A - for_each ===
   => Print numbers
   x = 8
   x = 9
   x = 20
   x = 25
   => Print words
   x = 8
   x = 9
   x = 20
   x = 25
#+END_SRC

 + Experiment 1B 

#+BEGIN_SRC cpp 
  std::puts("\n === EXPERIMENT 1 B - for_each ===");
  {
      std::string astr = "bolts";
      ranges::for_each(astr, printLambda);
  }
#+END_SRC

Output: 

#+BEGIN_SRC text 
  === EXPERIMENT 1 B - for_each ===
  x = b
  x = o
  x = l
  x = t
  x = s
#+END_SRC

 + Experiment 2 

#+BEGIN_SRC cpp 
  std::puts("\n === EXPERIMENT 2 - sort ===");
  {
      std::vector<double> xs2 = {10.45, -30.0, 45.0, 8.2, 100.0, 10.6};
      std::cout << " Reverse vector" << std::endl;
      std::cout << " BEFORE xs2 = " << xs2 << std::endl;
      ranges::sort(xs2);
      std::cout << " AFTER xs2 = " << xs2 << std::endl;
  }
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 2 - sort ===
   Reverse vector
   BEFORE xs2 = [6]( 10.45 -30 45 8.2 100 10.6  )
   AFTER xs2 = [6]( -30 8.2 10.45 10.6 45 100  )
#+END_SRC


 + Experiment 3 

#+BEGIN_SRC cpp  
    std::puts("\n === EXPERIMENT 3 - fill ===");
    {
        std::vector<int> xs2(10, 0);

        std::cout << " BEFORE  A xs2 = " << view::all(xs2 )<< std::endl;
        std::cout << " BEFOREB B xs2 = " << xs2 << std::endl;

        ranges::fill(xs2, 10);
        std::cout << " AFTER 1 => x2 = " << xs2 << std::endl;

        ranges::fill(xs2, 5);
        std::cout << " AFTER 2 => x2 = " << xs2 << std::endl;
    }
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 3 - fill ===
   BEFORE  A xs2 = [0,0,0,0,0,0,0,0,0,0]
   BEFOREB B xs2 = [10]( 0 0 0 0 0 0 0 0 0 0  )
   AFTER 1 => x2 = [10]( 10 10 10 10 10 10 10 10 10 10  )
   AFTER 2 => x2 = [10]( 5 5 5 5 5 5 5 5 5 5  )
#+END_SRC

 + Experiment 4: 

#+BEGIN_SRC cpp 
    std::puts("\n === EXPERIMENT 4 - reverse ===");
    {
        std::deque<std::string> words = {"c++", "c++17", "C++20", "asm", "ADA"};

        std::cout << " BEFORE => words = " << view::all(words) << std::endl;

        ranges::reverse(words);
        std::cout << " AFTER => words = " << view::all(words) << std::endl;
    }
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 4 - reverse ===
   BEFORE => words = [c++,c++17,C++20,asm,ADA]
   AFTER => words = [ADA,asm,C++20,c++17,c++]
#+END_SRC


 + Experiment 5: 

#+BEGIN_SRC cpp 
  std::puts("\n === EXPERIMENT 5 - remove_if ===");
  {
      std::vector<int> xvec = {1, 2, 5, 10, 1, 4, 1, 2, 8, 20, 100, 10, 1};

      std::cout << " BEFORE => xvec = " << xvec << std::endl;

      // Erase remove idiom
      xvec.erase(ranges::remove_if(xvec, [](int x){ return x == 1; }), xvec.end());
      std::cout << " AFTER  => xvec = " << xvec << std::endl;
  }
#+END_SRC

Output: 

#+BEGIN_SRC text 
  === EXPERIMENT 5 - remove_if ===
  BEFORE => xvec = [13]( 1 2 5 10 1 4 1 2 8 20 100 10 1  )
  AFTER  => xvec = [9]( 2 5 10 4 2 8 20 100 10  )
#+END_SRC

 + Experiment 6: 

#+BEGIN_SRC cpp 
  std::puts("\n === EXPERIMENT 6 - find ===");
  {
      std::vector<int> xvec = {1, 2, 5, 10, 1, 4, 1, 2};

      auto it = ranges::find(xvec, 10);
      if(it != xvec.end()){
           std::cout << " [OK] Found value == 10 => *it = " << *it << std::endl;
           std::cout << " Position = "
                     << ranges::distance(xvec.begin(), it)
                     << std::endl;
      }
      else
          std::cout << " [FAIL] Not found  value " << std::endl;
  }
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 6 - find ===
   [OK] Found value == 10 => *it = 10
   Position = 3
#+END_SRC

 + Experiment 7: 

#+BEGIN_SRC cpp 
  std::puts("\n === EXPERIMENT 7 - accumulator ===");
  {
      std::vector<int> xvec = {1, 2, 5, 10, 1, 4, 1, 2};

      int result = ranges::accumulate(xvec, 0);
      std::cout << " => ranges::accumulate(xvec, 0) = "
                << result << std::endl;

  }
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 7 - accumulator ===
   => ranges::accumulate(xvec, 0) = 26
#+END_SRC

   *Range View Experiments* 

 + Experiment 1A 

#+BEGIN_SRC cpp 
  std::cout << "\n";
  std::cout << "  +------------------------------------+\n"
            << "   | Range View Experiments             |\n"
            << "   +------------------------------------+\n";

  std::puts("\n === EXPERIMENT 1A - view::all");
  {
      std::vector<char> xs = {'x', 'y', 'm', 'k', 'm'};

      std::cout << " [1] => std::view(xs) = "
                << view::all(xs) << std::endl;

      std::cout << "\n [2] => xs = ";
      for(auto&& x: view::all(xs))
          std::cout << x << " ";
      std::cout << std::endl;
  }
#+END_SRC

Output: 

#+BEGIN_SRC text 
  === EXPERIMENT 1A - view::all
  [1] => std::view(xs) = [x,y,m,k,m]

  [2] => xs = x y m k m
#+END_SRC

  + Experiment 1B 

#+BEGIN_SRC cpp 
    std::puts("\n === EXPERIMENT 1B - view::reverse ===");
    {
        std::vector<char> xs = {'x', 'y', 'm', 'k', 'm'};

        for(auto const& x: view::reverse(xs))
            std::cout << " " << x;

        std::cout << std::endl;
        std::cout << " AFTER xs = " << xs << std::endl;
    }
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 1B - view::reverse ===
   m k m y x
   AFTER xs = [5]( x y m k m  )
#+END_SRC

 + Experiment 1C: 

#+BEGIN_SRC cpp 
    std::puts("\n === EXPERIMENT 1C - view::transform ===");
    {
        std::vector<int> xs = {100, 5, 20, 9, 10, 6};
        auto a_lambda = [](auto x){ return 5 * x -10; };

        for(auto const& x: xs | view::transform(a_lambda))
            std::cout << " " << x;

        std::cout << std::endl;
        //std::cout << " AFTER xs = " << xs << std::endl;
    }
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 1C - view::transform ===
   490 15 90 35 40 20
#+END_SRC

 + Experiment 2A: 

#+BEGIN_SRC cpp 
  std::puts("\n === EXPERIMENT 2A - Range adaptors pipeline ===");
  {
      auto a_lambda = [](auto x){ return 5 * x -10; };

      std::cout << " => Iota view = ";
      for(auto const& x: view::iota(1) | view::take(8))
          std::cout << " " << x;
      std::cout << std::endl;
  }
#+END_SRC

Output: 

#+BEGIN_SRC cpp 
   === EXPERIMENT 2A - Range adaptors pipeline ===
   => Iota view =  1 2 3 4 5 6 7 8
#+END_SRC


 + Expeirment 2B 

#+BEGIN_SRC cpp 
  std::puts("\n === EXPERIMENT 2B - Range adaptors pipeline ===");
  {
      std::cout << " => Iota view [B] = \n";
      auto aview =
                view::iota(1)
              | view::take(5)
              | view::transform([](int x){ return 5 * x + 6; });

      std::cout << " [INFO] aview = " << aview << std::endl;
      std::cout << " [INFO] aview | reverse = "
                << (aview | view::reverse)
                << std::endl;

      std::cout << "\n Iteration 1 => ";
      ranges::for_each(aview, [](int a){ std::cout << a << " "; });

      std::cout << "\n Iteration 2 => ";
      for(auto const& x: aview | view::reverse)
          std::cout << x << " ";
      std::cout << std::endl;

  }
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 2B - Range adaptors pipeline ===
   => Iota view [B] = 
   [INFO] aview = [11,16,21,26,31]
   [INFO] aview | reverse = [31,26,21,16,11]

   Iteration 1 => 11 16 21 26 31 
   Iteration 2 => 31 26 21 16 11 
#+END_SRC


 + Experiment 3A

#+BEGIN_SRC cpp 
  std::puts("\n === EXPERIMENT 3A - enumerate ===");
  {
      std::deque<std::string> words = { "c++", "c++17", "C++20", "asm" };

      std::cout << " ==== Loop 1 ==== " << std::endl;
      for(auto const& x: view::enumerate(words))
          std::cout << " => n = " << x.first
                    << " ; w = " << x.second << std::endl;

      std::cout << " ==== Loop 2 ==== " << std::endl;
      for(auto const& x: words | view::enumerate)
          std::cout << " => n = " << x.first
                    << " ; w = " << x.second << std::endl;
  }
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 3A - enumerate ===
   ==== Loop 1 ==== 
   => n = 0 ; w = c++
   => n = 1 ; w = c++17
   => n = 2 ; w = C++20
   => n = 3 ; w = asm
   ==== Loop 2 ==== 
   => n = 0 ; w = c++
   => n = 1 ; w = c++17
   => n = 2 ; w = C++20
   => n = 3 ; w = asm
#+END_SRC

 + Experiment 4A: 

#+BEGIN_SRC cpp 
    std::puts("\n === EXPERIMENT 4 - ranges::accumulate withe iterator ===");
    {
        auto aview = view::iota(2)
                   | view::transform([](double x){return 3.0 * x - 5; })
                   | view::take(15);

        std::cout << " aview = " << aview << std::endl;
        std::cout << " accumulate(aview) = " << ranges::accumulate(aview, 0.0)
                  << std::endl;
    }
#+END_SRC

Output: 

#+BEGIN_SRC cpp 
   === EXPERIMENT 4 - ranges::accumulate withe iterator ===
   aview = [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43]
   accumulate(aview) = 330
#+END_SRC

 + Experiment 5

#+BEGIN_SRC cpp 
  std::puts("\n === EXPERIMENT 5 - Copy Range to destination ===");
  {
      std::vector<int> output;
      auto aview = view::iota(5)
                 | view::transform([](int n){ return 6 * n - 10;})
                 | view::take(10);

      std::cout << " BEFORE => output = " << output << std::endl;

      ranges::copy(aview, ranges::back_inserter(output));
      std::cout << " AFTER => output = " << output << std::endl;
  }
#+END_SRC

Output: 

#+BEGIN_SRC text 
   === EXPERIMENT 5 - Copy Range to destination ===
   BEFORE => output = [0](  )
   AFTER => output = [10]( 20 26 32 38 44 50 56 62 68 74  )
#+END_SRC

** cxx-prettyprint - STL container pretty print

Description:
 + "A header-only library for C++(0x) that allows automagic pretty-printing of any container."
 + Note: as this library is single-file and header-only, it does not need any
   pre-compilation. All that is needed for using it is to download the
   file prettyprint.hpp and add it to the project directory or any
   other include directory.

Website:
 + http://louisdx.github.io/cxx-prettyprint/

Repository:
 + https://github.com/louisdx/cxx-prettyprint

 *Examples in CERN-Root REPL*

Step 1: Download the library and start the CERN's ROOT Repl (Cling).

#+BEGIN_SRC sh
  $ curl -O -L https://raw.githubusercontent.com/louisdx/cxx-prettyprint/master/prettyprint.hpp

  $ ~/opt/root/bin/root.exe
     ------------------------------------------------------------
    | Welcome to ROOT 6.14/04                http://root.cern.ch |
    |                               (c) 1995-2018, The ROOT Team |
    | Built for linuxx8664gcc                                    |
    | From tags/v6-14-04@v6-14-04, Aug 23 2018, 17:00:44         |
    | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |
     ------------------------------------------------------------
#+END_SRC

Include header in the repl:

#+BEGIN_SRC cpp
  >> #include "prettyprint.hpp""
#+END_SRC

Print vector:

#+BEGIN_SRC cpp
  >> auto xs = std::vector<double>{434.4, -10.54, 9.654, 45.23, -10.56};

  //------- Print Vector -----------------//
  >>
  >> std::cout << " xs = " << xs << std::endl;
   xs = [5](434.4 -10.54 9.654 45.23 -10.56 )
  >>
#+END_SRC

Print tuple:

#+BEGIN_SRC cpp
  >> auto t = std::make_tuple(std::string("hello"), 100)
  (std::tuple<basic_string<char>, int> &) { "hello", 100 }

  >> std::cout << " t = " << t << std::endl;
   t = (hello, 100)

  >> auto tt = std::make_tuple(std::string("hello"), 100, 'x')
  (std::tuple<basic_string<char>, int, char> &) { "hello", 100, 'x' }
  >>
  >> std::cout << " tt = " << tt << std::endl;
   tt = (hello, 100, x)

#+END_SRC

Print map:

#+BEGIN_SRC cpp
   >> std::map<std::string, double> dataset {{"USD", 200.3}, {"BRL", 451.34}, {"CAD", 400.5}, {"AUD", 34.65}};

   >> std::cout << " dataset = " << dataset << std::endl;
    dataset = [(AUD, 34.65), (BRL, 451.34), (CAD, 400.5), (USD, 200.3)]
   >>
#+END_SRC
** Cereal - Serialization Library

Cereal is a lightweight header-only library for serialization which
supports a wide variety of serialization formats such as binary, XML
and JSON. The library also provides lots of facilities for serializing
and deserializing STL containers.

 + License: BSD

 + Documentation and official web site:
   * https://uscilab.github.io/cereal

 + Github Repository:
   * https://github.com/USCiLab/cereal

 + Conan Reference:
   * [[https://bintray.com/conan-community/conan/cereal%253Aconan/1.2.2%253Astable][cereal/1.2.2@conan/stable]]

 *Serialization Challenges*

Despite what it may look like, serialization is not easy, there are
lots of serialization pitfalls that a library shoudl deal with:

 + _Machine endianess_:
   + The order that bytes of numeric data are loaded into memory
     depends on the machine architecture, therefore a numeric data
     stored in a binary file generated in a machine with a *little
     endian* processor, may be read in a wrong way by a *big endian*
     machine. So, in order to be portable, a binary file must use a
     default endianess independent of the any processor.

 + _Data Sizes_:
   + C and C++ binary sizes of fundamental data types such
     as int, long and long long are not constant across different
     operating systems and machine architectures. So a value of long
     type save in binary format in one machine may be read in a wrong
     way in a machine where the long type has a different size in
     bytes. The only way to ensure that the data type is portable and
     avoid bad surprises is to use fixed width integers from header
     <stdint> uint32_t, uint64_t and so on.

 + _Data Versioning_
   + In order to avoid data corruption, a serialization format should
     support multiple versions of the data structure being
     serialized and check the version of the data whenever it is
     deserialized from any stream.

 *Supported Serialization Formats:*

 + XML
 + JSON
 + Binary

 *Headers:*

 * Serialization formats:
   - Binary Format:
     + <cereal/archives/binary.hpp>

   - Portable Binary Format:
     + <cereal/archives/portable_binary.hpp>

   - XML
     + <cereal/archives/xml.hpp>

   - JSON - JavaScript Object Notation
     + <cereal/archives/json.hpp>

 * Support for serializing STL containers
   + <cereal/types/vector.hpp> => STL Vector std::vector serialization

 * Support for polymorphic types serialization
   + <cereal/types/polymorphic.hpp>


Sample Code:
 + File: cereal_test.cpp

#+BEGIN_SRC cpp
  #include <iostream>
  #include <iomanip>
  #include <string>
  #include <vector>
  #include <fstream> // std::ofstream
  #include <sstream> // std::stringstream

  #include <cereal/archives/binary.hpp>
  // #include <cereal/archives/portable_binary.hpp>
  #include <cereal/archives/xml.hpp>
  #include <cereal/archives/json.hpp>

  // Allows std::vector serialization
  #include <cereal/types/vector.hpp>

  struct DummyClass
  {
      double x;
      float  y;
      size_t N;
      std::vector<int> list;

      DummyClass(): x(0), y(0), N(0){ }

      DummyClass(double x, float y, size_t N)
          : x(x), y(y), N(N){ }

      void Add(int x)
      {
          list.push_back(x);
      }

      template<typename Archive>
      void serialize(Archive& archive)
      {
          // Archive without name-value pair
          //--------------------------------
          // archive(x, y, N, list);

          // Archive with name-value pair
          //-------------------------------
          archive(cereal::make_nvp("x", x),
                  cereal::make_nvp("y", y),
                  cereal::make_nvp("N", N),
                  cereal::make_nvp("list", list)
                  );
      }

      void show(std::ostream& os)
      {
          os << "DummyClass { x = " << x
             << " ; y = " << y
             << " ; N = " << N
             << " } => ";
          os << " List[ ";
          for(auto const& e: list)
              os << " " << e;
          os << " ] " << "\n";
      }
  };


  int main()
  {
      // ============ Binary Serialization ==================//

      // Memory "file" simulating a disk file
      auto mock_file = std::stringstream{};

      std::cout << "\n=== Experiment 1 - Serialize object to binary file ===\n";
      {
          auto outArchive   = cereal::BinaryOutputArchive(mock_file);
          DummyClass obj{100.6534, 45.5f, 100};
          obj.Add(100); obj.Add(200); obj.Add(50); obj.Add(80);
          outArchive(obj);
          std::cout << " Content of mock-file =  " << mock_file.str() << std::endl;
      }

      std::cout << "\n=== Experiment 2 - Deserialize object from binary file ====\n" ;
      {
          auto inArchive = cereal::BinaryInputArchive(mock_file);
          DummyClass cls;
          inArchive(cls);
          cls.show(std::cout);
      }

      //============= XML Serialization ============================//

      // auto xmlFile = std::ofstream("/tmp/dataset.xml");
      auto xmlFile = std::stringstream{};
      std::cout << "\n=== Experiment 3 - Serialize object to XML file ====\n" ;
      {
          auto outArchive = cereal::XMLOutputArchive(xmlFile);
          DummyClass obj1{200.0, -802.5f, 900};
          obj1.Add(100); obj1.Add(200); obj1.Add(50); obj1.Add(80);
          DummyClass obj2{400.0, -641.f, 300};
          outArchive(obj1, obj2);
      }
      // Note: Cereal uses RAII to flush the archive output, so the output is only
      // guaranteeed to be written to the stream when the archive go out of escope.
      std::cout << " [TRACE] xmlFile = " << xmlFile.str() << std::endl;

      std::cout << "\n=== Experiment 4 - Deserialize object from XML file ===\n" ;
      {
          auto inArchive = cereal::XMLInputArchive(xmlFile);
          DummyClass obj1, obj2;
          // Read two objects from stream
          inArchive(obj1, obj2);
          obj1.show(std::cout);
          obj2.show(std::cout);
      }

      // ============= JSON Serialization =================================//


      // auto xmlFile = std::ofstream("/tmp/dataset.xml");
      auto jsonFile = std::stringstream{};
      std::cout << "\n=== Experiment 5 - Serialize object to JSON file ====\n" ;
      {
          auto outArchive = cereal::JSONOutputArchive(jsonFile);
          DummyClass obj1{200.0, -802.5f, 900};
          obj1.Add(100); obj1.Add(200); obj1.Add(50); obj1.Add(80);
          DummyClass obj2{400.0, -641.f, 300};
          outArchive(cereal::make_nvp("object1", obj1),
                     cereal::make_nvp("object2", obj2));
      }
      std::cout << " [TRACE] JSON File =\n" << jsonFile.str() << std::endl;

      std::cout << "\n=== Experiment 6 - Deserialize object from JSON file ====\n" ;
      {
          auto inArchive = cereal::JSONInputArchive(jsonFile);
          DummyClass obj1, obj2;
          // Read two objects from stream
          inArchive(obj1, obj2);
          obj1.show(std::cout);
          obj2.show(std::cout);
      }

      return 0;
  }

#+END_SRC

Program output:

#+BEGIN_SRC sh
   $ ./cereal_test.bin

   === Experiment 1 - Serialize object to binary file ===
    Content of mock-file =  6�;N�)Y@  6Bd              d   �   2   P   

   === Experiment 2 - Deserialize object from binary file ====
   DummyClass { x = 100.653 ; y = 45.5 ; N = 100 } =>  List[  100 200 50 80 ]

   === Experiment 3 - Serialize object to XML file ====
    [TRACE] xmlFile = <?xml version="1.0" encoding="utf-8"?>
   <cereal>
           <value0>
                   <x>200</x>
                   <y>-802.5</y>
                   <N>900</N>
                   <list size="dynamic">
                           <value0>100</value0>
                           <value1>200</value1>
                           <value2>50</value2>
                           <value3>80</value3>
                   </list>
           </value0>
           <value1>
                   <x>400</x>
                   <y>-641</y>
                   <N>300</N>
                   <list size="dynamic"/>
           </value1>
   </cereal>



   === Experiment 4 - Deserialize object from XML file ===
   DummyClass { x = 200 ; y = -802.5 ; N = 900 } =>  List[  100 200 50 80 ]
   DummyClass { x = 400 ; y = -641 ; N = 300 } =>  List[  ]

   === Experiment 5 - Serialize object to JSON file ====
    [TRACE] JSON File =
   {
       "object1": {
           "x": 200.0,
           "y": -802.5,
           "N": 900,
           "list": [
               100,
               200,
               50,
               80
           ]
       },
       "object2": {
           "x": 400.0,
           "y": -641.0,
           "N": 300,
           "list": []
       }
   }

   === Experiment 6 - Deserialize object from JSON file ====
   DummyClass { x = 200 ; y = -802.5 ; N = 900 } =>  List[  100 200 50 80 ]
   DummyClass { x = 400 ; y = -641 ; N = 300 } =>  List[  ]
#+END_SRC

** TinyXML2 - Lightweight XML parser 

Simple and ligtweight C++ library for parsing XML files.

Site:
 + http://leethomason.github.io/tinyxml2/

Repository:
 + https://github.com/leethomason/tinyxml2

Conan Reference: 
 + [[https://bintray.com/nicolastagliani/tinyxml2/tinyxml2%253Anicolastagliani/7.0.1%253Astable][tinyxml2/7.0.1@nicolastagliani/stable]] 

Conan package repository: 
 + https://github.com/nicolastagliani/conan-tinyxml2/

 *Example:*

Full Project Code: 

 + https://gist.github.com/caiorss/351e291b8df2b0fc8e1bba5c86b7ee4d


 File: *tinyxml2-test.cpp*

 + This file parses the XML taken from [[https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml][eurofxref-daily.xml]] which
   contains a set of FX exchange rates. 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <iomanip>

  #include <tinyxml2.h>

  #define ENABLE_ASSERT

  #ifdef ENABLE_ASSERT
  #define M_ASSERT(expr) \
        { \
           if(!(expr)){ \
              std::cerr << "ASSERTION FAILURE: \n"; \
              std::cerr << " => Condition: " << #expr << "\n"; \
              std::cerr << " =>  Function: " << __FUNCTION__ << "\n"; \
              std::cerr << __FILE__ << ":" << __LINE__ << ":" << "\n"; \
              std::terminate(); \
           } \
        }
  #else
  #define M_ASSERT(expr)
  #endif

  using tinyxml2::XMLText;
  using tinyxml2::XMLElement;
  using tinyxml2::XMLNode;

  extern const char* exchangeRatesXML;

  int main()
  {

      std::cout << " [INFO] Running TinyXMl2 " << std::endl;

      tinyxml2::XMLDocument doc;

      if(doc.Parse( exchangeRatesXML) != tinyxml2::XML_SUCCESS)
      {
          std::cout << " [ERROR] Failed to parse XML" << std::endl;
          return EXIT_FAILURE;
      }
      std::cout << " [OK] XML parsed successfully" << std::endl;


      tinyxml2::XMLPrinter printer;
      doc.Print(&printer);

      std::cout << "Value: doc.FirstChild()->Value() = " << doc.FirstChild()->Value() << std::endl;

      XMLElement* elem = doc.FirstChildElement("gesmes:Envelope");
      M_ASSERT(elem != nullptr);
      if(elem){
          std::cout << " Element found. OK " << std::endl;
          std::cout << " =>> Element Name = " << elem->Name() << std::endl;

      }

      XMLElement* elem1 = elem->FirstChildElement("Cube");
      M_ASSERT(elem1 != nullptr);

      std::cout << " =>> Found Node Name: " << elem1->ToElement()->Name() << "\n";

      XMLElement* elem2 = elem1->FirstChildElement("Cube");
      M_ASSERT(elem2 != nullptr);

      const char* time = elem2->Attribute("time");
      M_ASSERT(time != nullptr);

      // XML node with: <Cube time = 'xxxx-xx-xx'>
      std::cout << " => Time = " << time << "\n\n";
      std::cout << std::fixed << std::setprecision(3);

      std::cout << " ===== Exchange rates in Euros ====" << std::endl;

      for(XMLElement* e = elem2->FirstChildElement("Cube")
               ; e != nullptr; e = e->NextSiblingElement("Cube") )
      {
          std::cout << std::setw(10) << e->Attribute("currency")
                    << std::setw(15) << std::stod(e->Attribute("rate"))
                    << std::endl;
      }


      return doc.ErrorID();
  }

  // Source: https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml
  const char* exchangeRatesXML = R"(
     <?xml version="1.0" encoding="UTF-8"?>
     <gesmes:Envelope 
                  xmlns:gesmes="http://www.gesmes.org/xml/2002-08-01" 
                  xmlns="http://www.ecb.int/vocabulary/2002-08-01/eurofxref">

             <gesmes:subject>Reference rates</gesmes:subject>
             <gesmes:Sender>
                     <gesmes:name>European Central Bank</gesmes:name>
             </gesmes:Sender>
             <Cube>
                     <Cube time='2019-06-14'>
                             <Cube currency='USD' rate='1.1265'/>
                             <Cube currency='JPY' rate='121.90'/>
                             <Cube currency='BGN' rate='1.9558'/>
                             <Cube currency='CZK' rate='25.540'/>
                             <Cube currency='DKK' rate='7.4676'/>
                             <Cube currency='GBP' rate='0.89093'/>
                             <Cube currency='HUF' rate='321.53'/>
                             <Cube currency='PLN' rate='4.2534'/>
                             <Cube currency='RON' rate='4.7233'/>
                             <Cube currency='SEK' rate='10.6390'/>
                             <Cube currency='CHF' rate='1.1211'/>
                             <Cube currency='ISK' rate='141.50'/>
                             <Cube currency='NOK' rate='9.7728'/>
                             <Cube currency='HRK' rate='7.4105'/>
                             <Cube currency='RUB' rate='72.3880'/>
                             <Cube currency='TRY' rate='6.6427'/>
                             <Cube currency='AUD' rate='1.6324'/>
                             <Cube currency='BRL' rate='4.3423'/>
                             <Cube currency='CAD' rate='1.5018'/>
                             <Cube currency='CNY' rate='7.7997'/>
                             <Cube currency='HKD' rate='8.8170'/>
                             <Cube currency='IDR' rate='16128.10'/>
                             <Cube currency='ILS' rate='4.0518'/>
                             <Cube currency='INR' rate='78.6080'/>
                             <Cube currency='KRW' rate='1333.60'/>
                             <Cube currency='MXN' rate='21.6073'/>
                             <Cube currency='MYR' rate='4.6981'/>
                             <Cube currency='NZD' rate='1.7241'/>
                             <Cube currency='PHP' rate='58.539'/>
                             <Cube currency='SGD' rate='1.5403'/>
                             <Cube currency='THB' rate='35.101'/>
                             <Cube currency='ZAR' rate='16.6529'/>
                     </Cube>
             </Cube>
     </gesmes:Envelope>
  )";
#+END_SRC

 File: *CMakeLists.txt* 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(tinyxml2-test)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #=========== Conan Bootstrap =================#

  # Download automatically, you can also just copy the conan.cmake file
  if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
     message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
     file(DOWNLOAD "https://github.com/conan-io/cmake-conan/raw/v0.13/conan.cmake"
                   "${CMAKE_BINARY_DIR}/conan.cmake")
  endif()

  include(${CMAKE_BINARY_DIR}/conan.cmake)
  set(CONAN_PROFILE default)

  conan_cmake_run( REQUIRES
                   tinyxml2/7.0.1@nicolastagliani/stable
                   BASIC_SETUP
                   BUILD missing )

  #=========== Find Package ================#

  include(tinyxml2_helper.cmake)
               
  #=========== Targets =====================# 

  add_executable(tinyxml2-test tinyxml2-test.cpp)
  target_link_libraries(tinyxml2-test PRIVATE ${tinyxml2_LIBRARY})
#+END_SRC

 File: *tinyxml2_helper.cmake* 

#+BEGIN_SRC cmake 
  # Credits: https://github.com/nicolastagliani/conan-tinyxml2/issues/3
  include( FindPackageHandleStandardArgs )

  find_path( tinyxml2_INCLUDE_DIR
    NAMES
      tinyxml2.h
    PATHS
      ${CONAN_INCLUDE_DIRS_TINYXML2}
  )

  find_library( tinyxml2_LIBRARY
    NAMES
      ${CONAN_LIBS_TINYXML2}
    PATHS
      ${CONAN_LIB_DIRS_TINYXML2}
  )

  find_package_handle_standard_args( tinyxml2 DEFAULT_MSG
    tinyxml2_INCLUDE_DIR
  )

  if( tinyxml2_FOUND )
    set( tinyxml2_INCLUDE_DIRS ${tinyxml2_INCLUDE_DIR} )
    set( tinyxml2_LIBRARIES ${tinyxml2_LIBRARY} )

    get_filename_component( tinyxml2_CONFIG_PATH ${CONAN_TINYXML2_ROOT} DIRECTORY )
    get_filename_component( tinyxml2_HASH ${CONAN_TINYXML2_ROOT} NAME )
    get_filename_component( tinyxml2_CONFIG_PATH ${tinyxml2_CONFIG_PATH} DIRECTORY )
    set( tinyxml2_CONFIG_PATH  ${tinyxml2_CONFIG_PATH}/build/${tinyxml2_HASH} )
    set( tinyxml2_CONFIG_FILENAME tinyxml2Config.cmake )

    find_file( tinyxml2_CONFIG_DIR
        ${tinyxml2_CONFIG_FILENAME}
      HINTS
        ${tinyxml2_CONFIG_PATH}
    )

    if( tinyxml2_CONFIG_DIR-NOTFOUND )
      set( tinyxml2_CONFIG "" )
    else()
      set( tinyxml2_CONFIG ${tinyxml2_CONFIG_DIR} )
    endif()

    mark_as_advanced(
      tinyxml2_INCLUDE_DIR
      tinyxml2_LIBRARY
      tinyxml2_DIR
      tinyxml2_CONFIG
    )
  else()
    set( tinyxml2_DIR "" CACHE STRING
      "An optional hint to a tinyxml2 directory"
    )
  endif()
#+END_SRC

 *Build* 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/caiorss/351e291b8df2b0fc8e1bba5c86b7ee4d gist 
  $ cd gist 

  # Build with QT Creator 
  $ qtcreator CMakeLists.txt 

  # Build from command line 
  $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=Debug
  $ cmake --build build --target
#+END_SRC

 *Program Output:* 

#+BEGIN_SRC sh 
   $ build/bin/tinyxml2-test 

    [INFO] Running TinyXMl2 
    [OK] XML parsed successfully
   Value: doc.FirstChild()->Value() = xml version="1.0" encoding="UTF-8"
    Element found. OK 
    =>> Element Name = gesmes:Envelope
    =>> Found Node Name: Cube
    => Time = 2019-06-14

    ===== Exchange rates in Euros ====
          USD          1.127
          JPY        121.900
          BGN          1.956
          CZK         25.540
          DKK          7.468
          GBP          0.891
          HUF        321.530
          PLN          4.253
          RON          4.723
          SEK         10.639
          CHF          1.121
          ISK        141.500
          NOK          9.773
          HRK          7.410
          RUB         72.388
          TRY          6.643
          AUD          1.632
          BRL          4.342
          CAD          1.502
          CNY          7.800
          HKD          8.817
          IDR      16128.100
          ILS          4.052
          INR         78.608
          KRW       1333.600
          MXN         21.607
          MYR          4.698
          NZD          1.724
          PHP         58.539
          SGD          1.540
          THB         35.101
          ZAR         16.653
#+END_SRC


** GTest - Unit Testing Framework

GTest or Google test is one of the most used and most popular test
frameworks which supports many features such as mocks; test fixtures;
parameterized tests; XML test report in JUnit / xUnit format; test
discovery and integration with IDEs, namely Eclipse, QTCreator and
Visual Studio.


Official Web site:
 + https://github.com/google/googletest

Some Tutorial/Primers: 
 + [[https://github.com/google/googletest/blob/master/googletest/docs/primer.md][Google Test Primer]] (Official)
 + [[https://docs.microsoft.com/en-us/visualstudio/test/how-to-use-google-test-for-cpp?view=vs-2019][How to use Google Test for C++ - Visual Studio | Microsoft Docs]]
 + [[http://www.yolinux.com/TUTORIALS/Cpp-GoogleTest.html][GoogleTest: C++ unit test framework]]
 + [[https://developer.ibm.com/articles/au-googletestingframework/][A quick introduction to the Google C++ Testing Framework – IBM Developer]]

Conan Reference: 
 + [[https://bintray.com/conan-community/conan/gtest%253Aconan/1.8.0%253Astable][gtest/1.8.0@conan/stable]]

Test Runner for GTest: 
 + https://github.com/nholthaus/gtest-runner

CMake Integration:
 + [[https://cmake.org/cmake/help/latest/module/FindGTest.html][FindGTest — CMake 3.14.4 Documentation]]

Fatal Assertions: 
 + ASSERT_TRUE
 + ASSERT_FALSE
 + ASSERT_EQ(val1, val2)
 + ASSERT_NE(val1, val2)
 + ASSERT_LT
 + ASSERT_GT
 + ASSERT_GE 

Non-fatal assertions Macros: 

 + EXPECT_TRUE
 + EXPECT_FALSE
 + EXPECT_EQ
 + EXPECT_NQ
 + EXPECT_DOUBLE_EQ
 + EXPECT_FLOAT_EQ
 + EXPECT_NEAR(value1, value2, absolute_tolerance)
 + TEST(<NAME>, ){ ... <BODY> .. }
 + EXPECT_FLOAT_EQ 

 *Example: Usage with CMake and QTCreator*

Get the source code: 
 + Gist: [[https://gist.github.com/caiorss/eb2fc15b7ed322ccac5ee496585e54e9][Sample Project CMake and GTest with Conan]]

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/caiorss/eb2fc15b7ed322ccac5ee496585e54e9 gist && cd gist
  Cloning into 'gist'...
  remote: Enumerating objects: 4, done.
  remote: Counting objects: 100% (4/4), done.
  remote: Compressing objects: 100% (4/4), done.
  remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0
  Unpacking objects: 100% (4/4), done.

  $ ls
  CMakeLists.txt  gtest-experiment.cpp

  # Open with QT Creator, Visual Studio or build from command line 
  $ qtcreator CMakeList.txt 

  # Open with Visual Studio 
  $ devenv CMakeLists.txt 
#+END_SRC

 *File: gtest-experiment.cpp*

Headers:

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <string>
  #include <vector>
  #include <cassert>

  #include <gtest/gtest.h>
#+END_SRC

Implementations: 

#+BEGIN_SRC cpp 
  // ==================== Implementation ========================

  int factorial(int n){
      int prod = 1;
      for(int i = 1; i <= n; i++)
          prod *= i;
      return prod;
  }

  struct Date
  {
      int year;
      int month;
      int day;
      Date(){}
      Date(int year, int month, int day)
          : year(year)
          , month(month)
          , day(day)
      { }

      // Comparison operator required by  EXPECT_EQ
      bool operator==(Date const& rhs) const
      {
          return year  == rhs.year
              && month == rhs.month
              && day   == rhs.day;
      }
      // Necessary for make class printable in GTest
      friend std::ostream& operator<<(std::ostream& os, Date const& rhs)
      {
          return os << "Date { " << rhs.year << " ; "
                    << rhs.month << " ; "
                    << rhs.day << " } ";
      }
  };

  Date GregorianEasterSunday(int y)
  {
      int c = y / 100;
      int n = y - 19 * ( y / 19 );
      int k = ( c - 17 ) / 25;
      int i = c - c / 4 - ( c - k ) / 3 + 19 * n + 15;
      i = i - 30 * ( i / 30 );
      i = i - ( i / 28 ) * ( 1 - ( i / 28 )
            ,* ( 29 / ( i + 1 ) )
            ,* ( ( 21 - n ) / 11 ) );
      int j = y + y / 4 + i + 2 - c + c / 4;
      j = j - 7 * ( j / 7 );
      int l = i - j;
      int m = 3 + ( l + 40 ) / 44;
      int d = l + 28 - 31 * ( m / 4 );
      return Date(y, m, d);
  }
#+END_SRC

Test code: 

#+BEGIN_SRC cpp 
  //=============== Tests ====================================//

  TEST(FactorialTest, test1){
      EXPECT_EQ(6,        factorial(3));
      EXPECT_EQ(24,       factorial(4));
      EXPECT_EQ(120,      factorial(5));
      EXPECT_EQ(3628800,  factorial(10));
      // Expect greater than
      EXPECT_GT(10000000, factorial(10));
      // Expect not equal
      EXPECT_NE(25, factorial(4));
  }

  TEST(FactorialTestFailure, testFailure){
      // Deliberately fails for demonstration purposes
      EXPECT_EQ(6, factorial(3));
      EXPECT_EQ(4, factorial(4));
      EXPECT_EQ(6, factorial(2));
  }

  TEST(GregorianEaster, testdates){
      EXPECT_EQ(Date(2005, 3, 27), GregorianEasterSunday(2005));
      EXPECT_EQ(Date(2008, 3, 23), GregorianEasterSunday(2008));
      EXPECT_EQ(Date(2010, 4, 4),  GregorianEasterSunday(2010));
  }
#+END_SRC

  *File: CMakeLists.txt*

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project( GtestsExperiment
           VERSION      0.1
           DESCRIPTION  "Experiment with Gtest uni testing framework"
          )
  # ============= Conan Bootstrap =============================#

  # Download automatically, you can also just copy the conan.cmake file
  if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
     message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
     file(DOWNLOAD "https://github.com/conan-io/cmake-conan/raw/v0.13/conan.cmake"
                   "${CMAKE_BINARY_DIR}/conan.cmake")
  endif()

  include(${CMAKE_BINARY_DIR}/conan.cmake)

  conan_cmake_run(REQUIRES
                  gtest/1.8.1@bincrafters/stable
                  BASIC_SETUP
                  BUILD missing
                  )

  #============= Find Packages ================================#

  find_package(GTest REQUIRED)

  #---------------------------------------------------#
  #             Targets Settings                      #
  #---------------------------------------------------#

  add_executable(gtest-experiment gtest-experiment.cpp)
  target_link_libraries(gtest-experiment GTest::GTest GTest::Main)
  add_test(GTestExperiment gtest-experiment)
#+END_SRC

 *Test Output:*

#+CAPTION: Test output in Command Line 
[[file:images/gtest-framework-console.png][file:images/gtest-framework-console.png]]

#+CAPTION: QTCreator Test Discovery 
[[file:images/gtest-framework-qtcreator.png][file:images/gtest-framework-qtcreator.png]]

** Catch2 - Unit Testing Framework

Advatanges over other test frameworks:

 + Header-only library, so it requires no linking step or linking
   dependencies.

 + Uses C++ operators instead of many macros such as (X > 20) instead of
   EXPECT_GT(X, 20) (expect grater than) as in GTest (Google's test)

 + BDD - Behavior Driven Development

 + Property-based testing - testing with several random values and
   combination of random values.

 + Test with multiple data or data table which frees the user from
   writing lots boilerplate ASSERT_EQUAL(x, y). A single REQUIRE macro
   can be used for test a whole list of cartesian pairs such as (x, y,z, expected)

 + XML output in JUnit, xUnit format.

Problem:
 + Compile-time can be a bit slow due to the library be header-only.

Repository:
 + https://github.com/catchorg/Catch2

Conan Reference:
 + [[https://bintray.com/catchorg/Catch2/Catch2:catchorg/2.7.2:stable][Catch2/2.7.2@catchorg/stable]]

Code Examples:
 + https://github.com/catchorg/Catch2/tree/master/examples
 + [[https://github.com/catchorg/Catch2/blob/master/projects/SelfTest/UsageTests/Generators.tests.cpp][Test Generators]] - testing with multiple data

Tutorial:
 + [[https://github.com/catchorg/Catch2/blob/master/docs/tutorial.md#top][Catch2/tutorial.md at master · catchorg/Catch2 · GitHub]]
 + [[https://mariusbancila.ro/blog/2018/03/29/writing-cpp-unit-tests-with-catch2/][Writing C++ unit tests with Catch2]] - BDD - Behavior Driven Development.

Misc:
 + [[https://levelofindirection.com/blog/catch2-released.html][Catch2 Released : Level of Indirection]]
 + [[https://codingnest.com/the-future-of-catch2/][The future of Catch2 — The Coding Nest]]

Example simple test:

File: testcatch2.cpp

#+BEGIN_SRC cpp
  #include <iostream>

  #include <catch2/catch.hpp>


  int formula(int x, int y)
  {
      return 4 * x + 2 * y;
  }

  TEST_CASE("Test function furmula A", "[tag1]")
  {
      REQUIRE( formula(3, 4) == 20 );
      REQUIRE( formula(4, 5) == 26 );
  }

  TEST_CASE("Test function formula B", "[tag2]")
  {
      REQUIRE( formula(0, 0) == 0  );
      // Intentionally fails
      REQUIRE( formula(2, 5) == 10 );
  }


  struct TestData
  {
      int x, y, expected;
  };


  TEST_CASE("Testing with struct")
  {
      auto t = GENERATE( values<TestData>(
      {
          {3,  4, 20}
         ,{4,  5, 26}
         ,{0,  0,  0}
         ,{-1, 4,  6} // Fails
         ,{ 2, 2, 12}
      }));
      REQUIRE( formula(t.x, t.y) == t.expected);
  }


  TEST_CASE("Testing with structured bindings")
  {
      auto [x, y, z] = GENERATE( table<int, int, int>(
      {
          {3,  4, 20}
         ,{4,  5, 26}
         ,{0,  0,  0}
         ,{2, 2, 12}
      }));
      REQUIRE( formula(x, y) == z);
  }
#+END_SRC

File: CMakeLists.txt - CMake building script integrated with Conan.

#+BEGIN_SRC cmake
  cmake_minimum_required(VERSION 3.9)
  project(Catch2_testing)

  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  # ============= Conan Bootstrap =============================#

  # Download automatically, you can also just copy the conan.cmake file
  if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
     message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
     file(DOWNLOAD "https://github.com/conan-io/cmake-conan/raw/v0.13/conan.cmake"
                   "${CMAKE_BINARY_DIR}/conan.cmake")
  endif()

  include(${CMAKE_BINARY_DIR}/conan.cmake)

  conan_cmake_run(REQUIRES
                  Catch2/2.7.2@catchorg/stable
                  BASIC_SETUP
                  BUILD missing
                  )
  #============= Find Packages ================================#

  find_package(Catch2 REQUIRED)

  #---------------------------------------------------#
  #             Targets Settings                      #
  #---------------------------------------------------#

  add_executable(testcatch2 testcatch2.cpp test-main.cpp)
  target_link_libraries(testcatch2)
#+END_SRC

Test runner help option:

#+BEGIN_SRC sh
  $ ./testcatch2 -h

  Catch v2.7.2
  usage:
    testcatch2 [<test name|pattern|tags> ... ] options

  where options are:
    -?, -h, --help                            display usage information
    -l, --list-tests                          list all/matching test cases
    -t, --list-tags                           list all/matching tags
    -s, --success                             include successful tests in
                                              output
    -b, --break                               break into debugger on failure
    -e, --nothrow                             skip exception tests
    -i, --invisibles                          show invisibles (tabs, newlines)
    -o, --out <filename>                      output filename
    -r, --reporter <name>                     reporter to use (defaults to
                                              console)
    -n, --name <name>                         suite name
    -a, --abort                               abort at first failure
    -x, --abortx <no. failures>               abort after x failures
    -w, --warn <warning name>                 enable warnings
    -d, --durations <yes|no>                  show test durations
    -f, --input-file <filename>               load test names to run from a
                                              file
    -#, --filenames-as-tags                   adds a tag for the filename
    -c, --section <section name>              specify section to run
    -v, --verbosity <quiet|normal|high>       set output verbosity
    --list-test-names-only                    list all/matching test cases
                                              names only
    --list-reporters                          list all reporters
    --order <decl|lex|rand>                   test case order (defaults to
                                              decl)
    --rng-seed <'time'|number>                set a specific seed for random
                                              numbers
    --use-colour <yes|no>                     should output be colourised
    --libidentify                             report name and version according
                                              to libidentify standard
    --wait-for-keypress <start|exit|both>     waits for a keypress before
                                              exiting
    --benchmark-resolution-multiple           multiple of clock resolution to
    <multiplier>                              run benchmarks

  For more detailed usage please see the project docs


#+END_SRC

Test runner test list:

#+BEGIN_SRC sh
  $ ./testcatch2 --list-tests
  All available test cases:
    Test function furmula A
        [tag1]
    Test function formula B
        [tag2]
    Testing with struct
    Testing with structured bindings
  4 test cases

#+END_SRC

Test runner output:

#+BEGIN_SRC text
   $ ./testcatch2

   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   testcatch2 is a Catch v2.7.2 host application.
   Run with -? for options

   -------------------------------------------------------------------------------
   Test function formula B
   -------------------------------------------------------------------------------
   /home/archbox/Documents/projects/fquant/testcatch2.cpp:17
   ...............................................................................

   /home/archbox/Documents/projects/fquant/testcatch2.cpp:21: FAILED:
     REQUIRE( formula(2, 5) == 10 )
   with expansion:
     18 == 10

   -------------------------------------------------------------------------------
   Testing with struct
   -------------------------------------------------------------------------------
   /home/archbox/Documents/projects/fquant/testcatch2.cpp:31
   ...............................................................................

   /home/archbox/Documents/projects/fquant/testcatch2.cpp:41: FAILED:
     REQUIRE( formula(t.x, t.y) == t.expected )
   with expansion:
     4 == 6

   ===============================================================================
   test cases:  4 |  2 passed | 2 failed
   assertions: 13 | 11 passed | 2 failed
#+END_SRC

** Doctest - Unit Testing Framewok

Doctest is a unit test framework based on catch2 test framework,
however doctest has a much faster compile-time than many other
unit-test frameworks.

Advantages:
 + Easy of use
 + Faster compile-time
 + Easy to integrate, header-only-library
 + Operator based testing: CHECK(VALUE == EXPECTED), CHECK(x > 10)
   instead of No need to use macros ASSERT_EQ, ASSERT_NEQ (not equal)
   as in GTest.

Disadvantages:
 + No XML output with jUnit standard similar to GTest standard.
 + No integration with IDE
 + No data-driven test, aka parameterized test, or test with a list of value tuples.

Repository:
 + https://github.com/onqtam/doctest

Conan Reference:
 + [[https://bintray.com/bincrafters/public-conan/doctest%253Abincrafters/2.3.1%253Astable][doctest/2.3.1@bincrafters/stable]]

Conan Package:
 + https://github.com/bincrafters/conan-doctest

Code Examples:
 + https://github.com/onqtam/doctest/tree/master/examples

Features:
 + https://github.com/onqtam/doctest/blob/master/doc/markdown/features.md

See:
 + [[https://accu.org/index.php/journals/2343][ACCU - doctest – the Lightest C++ Unit Testing Framewor]]
 + [[https://www.codeproject.com/Articles/1156938/doctest-the-lightest-Cplusplus-unit-testing-framew][doctest - the lightest C++ unit testing framework - CodeProject]]

Video:
 + [[https://www.youtube.com/watch?v=eH1CxEC29l8][CppCon 2017: Viktor Kirilov “Mix Tests and Production Code With Doctest...” - YouTube]]

Usage:

 + File: doctest_experiment.cpp

#+BEGIN_SRC cpp
  #define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
  #include <doctest.h>

  int formula(int x, int y)
  {
      return 4 * x + 2 * y;
  }

  TEST_CASE("Test function furmula A")
  {
      CHECK( formula(3, 4) == 20 );
      CHECK( formula(4, 5) == 26 );
      CHECK( formula(4, 5) < 100 );
      CHECK( formula(4, 5) != 0 );
  }

  TEST_CASE("Test function formula B")
  {
      CHECK( formula(0, 0) == 0  );
      // Intentionally fails
      CHECK( formula(2, 5) == 10 );
  }
#+END_SRC

 + File: CMakeLists.txt integrated with Conan

#+BEGIN_SRC cmake
  cmake_minimum_required(VERSION 3.9)
  project( doctest_experiment
           VERSION      0.1
           DESCRIPTION  "A doctest experiment"
          )
  set(CMAKE_CXX_STANDARD 17)
  set(CMAKE_VERBOSE_MAKEFILE ON)

  # ============= Conan Bootstrap =============================#

  # Download automatically, you can also just copy the conan.cmake file
  if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
     message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
     file(DOWNLOAD "https://github.com/conan-io/cmake-conan/raw/v0.13/conan.cmake"
                   "${CMAKE_BINARY_DIR}/conan.cmake")
  endif()

  include(${CMAKE_BINARY_DIR}/conan.cmake)

  conan_cmake_run(REQUIRES
                  doctest/2.3.1@bincrafters/stable
                  BASIC_SETUP
                  BUILD missing
                  )

  #============= Find Packages ================================#

  find_package(doctest 2.3.1 REQUIRED)

  #---------------------------------------------------#
  #             Targets Settings                      #
  #---------------------------------------------------#

  add_executable(doctest_experiment doctest_experiment.cpp)
  copy_after_build(doctest_experiment)
  # target_link_libraries(doctest_experiment doctest::doctest)
#+END_SRC

Show options:

#+BEGIN_SRC sh
   $ bin/doctest_experiment -h
   [doctest] doctest version is "2.3.1"
   [doctest]
   [doctest] boolean values: "1/on/yes/true" or "0/off/no/false"
   [doctest] filter  values: "str1,str2,str3" (comma separated strings)
   [doctest]
   [doctest] filters use wildcards for matching strings
   [doctest] something passes a filter if any of the strings in a filter matches
   [doctest]
   [doctest] ALL FLAGS, OPTIONS AND FILTERS ALSO AVAILABLE WITH A "dt-" PREFIX!!!
   [doctest]
   [doctest] Query flags - the program quits after them. Available:

    -?,   --help, -h                      prints this message
    -v,   --version                       prints the version
    -c,   --count                         prints the number of matching tests
    -ltc, --list-test-cases               lists all matching tests by name
    -lts, --list-test-suites              lists all matching test suites
    -lr,  --list-reporters                lists all registered reporters

   [doctest] The available <int>/<string> options/filters are:

    -tc,  --test-case=<filters>           filters     tests by their name
    -tce, --test-case-exclude=<filters>   filters OUT tests by their name
    -sf,  --source-file=<filters>         filters     tests by their file
    -sfe, --source-file-exclude=<filters> filters OUT tests by their file
    -ts,  --test-suite=<filters>          filters     tests by their test suite
    -tse, --test-suite-exclude=<filters>  filters OUT tests by their test suite
    -sc,  --subcase=<filters>             filters     subcases by their name
    -sce, --subcase-exclude=<filters>     filters OUT subcases by their name
    -r,   --reporters=<filters>           reporters to use (console is default)
    -o,   --out=<string>                  output filename
    -ob,  --order-by=<string>             how the tests should be ordered
                                          <string> - by [file/suite/name/rand]
    -rs,  --rand-seed=<int>               seed for random ordering
    -f,   --first=<int>                   the first test passing the filters to
                                          execute - for range-based execution
    -l,   --last=<int>                    the last test passing the filters to
                                          execute - for range-based execution
    -aa,  --abort-after=<int>             stop after <int> failed assertions
    -scfl,--subcase-filter-levels=<int>   apply filters for the first <int> levels

   [doctest] Bool options - can be used like flags and true is assumed. Available:

    -s,   --success=<bool>                include successful assertions in output
    -cs,  --case-sensitive=<bool>         filters being treated as case sensitive
    -e,   --exit=<bool>                   exits after the tests finish
    -d,   --duration=<bool>               prints the time duration of each test
    -nt,  --no-throw=<bool>               skips exceptions-related assert checks
    -ne,  --no-exitcode=<bool>            returns (or exits) always with success
    -nr,  --no-run=<bool>                 skips all runtime doctest operations
    -nv,  --no-version=<bool>             omit the framework version in the output
    -nc,  --no-colors=<bool>              disables colors in output
    -fc,  --force-colors=<bool>           use colors even when not in a tty
    -nb,  --no-breaks=<bool>              disables breakpoints in debuggers
    -ns,  --no-skip=<bool>                don't skip test cases marked as skip
    -gfl, --gnu-file-line=<bool>          :n: vs (n): for line numbers in output
    -npf, --no-path-filenames=<bool>      only filenames and no paths in output
    -nln, --no-line-numbers=<bool>        0 instead of real line numbers in output

   [doctest] for more information visit the project documentation
#+END_SRC

Test runner test listing:

#+BEGIN_SRC sh
  $ bin/doctest_experiment --list-test-cases
  [doctest] listing all test case names
  ===============================================================================
  Test function furmula A
  Test function formula B
  ================================================
#+END_SRC

Run tests: (Note: It is printed with colored output)

#+BEGIN_SRC text
  $ bin/doctest_experiment
  [doctest] doctest version is "2.3.1"
  [doctest] run with "--help" for options
  ===============================================================================
  /home/archbox/Documents/projects/fquant/doctest_experiment.cpp:21:
  TEST CASE:  Test function formula B

  /home/archbox/Documents/projects/fquant/doctest_experiment.cpp:25: ERROR: CHECK( formula(2, 5) == 10 ) is NOT correct!
    values: CHECK( 18 == 10 )

  ===============================================================================
  [doctest] test cases:      2 |      1 passed |      1 failed |      0 skipped
  [doctest] assertions:      6 |      5 passed |      1 failed |
  [doctest] Status: FAILURE!
#+END_SRC
