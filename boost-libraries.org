#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ Notes - Boost Libraries 
#+DESCRIPTION: cpp/c++ c++ design patterns gneric programming object oriented metaprogramming
#+STARTUP: content 

- [[wiki:index][Index]]

* Boost Libraries 
** Boost Libraries already in C++ ISO standard 

Some Boost libraries are redundant as they are already in the C++ ISO
standard. However, it is worth using them if a compiler to new
C++ standards is not available. 

|-------------------+-------------------------------------------+-----------------------|
| Boost Library     | C++ Standard                              | Added to the standard |
|                   | equivalent                                | since:                |
|-------------------+-------------------------------------------+-----------------------|
| *Added since C++11* |                                           |                       |
|-------------------+-------------------------------------------+-----------------------|
| [[https://www.boost.org/doc/libs/1_69_0/libs/core/doc/html/core/ref.html][Boost.Ref]]         | Reference warapers in <functional> header | C++11                 |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_random.html][Boost.Random]]      | Header <random>                           | C++11                 |
| [[https://www.boost.org/doc/libs/1_69_0/libs/regex/doc/html/index.html][Boost.Regex]]       | Library: [[https://en.cppreference.com/w/cpp/regex][<regex>]]  (std::regex)            | C++11                 |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/thread.html][Boost.Thread]]      | Library: [[https://en.cppreference.com/w/cpp/thread][<thread>]] (std::thread)           | C++11                 |
|                   |                                           |                       |
| *Added since C++17* |                                           |                       |
|-------------------+-------------------------------------------+-----------------------|
| [[https://www.boost.org/doc/libs/1_69_0/libs/optional/doc/html/index.html][Boost.Optional]]    | std::optional                             | C++17                 |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/any.html][Boost.Any]]         | std::any                                  | C++17                 |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/variant.html][Boost.Variant]]     | std::variant                              | C++17                 |
| [[https://www.boost.org/doc/libs/1_69_0/libs/filesystem/doc/index.htm][Boost.Filesystem]]  | Library: [[https://en.cppreference.com/w/cpp/filesystem][filesystem]]                       | C++17 [optional]      |
|                   |                                           |                       |
|-------------------+-------------------------------------------+-----------------------|

Note: 
 + Reference wrappers in <functional> header:
   + [[https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper][std::reference_wrapper]]
   + [[https://en.cppreference.com/w/cpp/utility/functional/ref][std::ref, std::cref]]

See:
 + [[https://stackoverflow.com/questions/7241993/is-it-smart-to-replace-boostthread-and-boostmutex-with-c11-equivalents][c++ - Is it smart to replace boost::thread and boost::mutex with c++11 equivalents? - Stack Overflow]]

** Library Map 
*** Math 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/index.html][Math Toolkit 2.8.0 - 1.69.0]]
  + Brief: The math toolkit provides the following facilities:
    + Floating Point Utilities
    + Specific Width Floating Point Types
    + *Statistical Distributions* (Gaussian, Poisson, Bernouli...)
    + Mathematical Special Function
    + Root Finding and Function
    + Minimisations, Polynomials and Rational Functions
    + Interpolation
    + Numerical Integration and Differentiation
    + Quaternions and Octonions.   
  + [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/special.html][Chapter 6. Special Functions - 1.69.0]]
  + [[https://www.boost.org/doc/libs/1_69_0/libs/math/doc/html/dist.html][Chapter 5. Statistical Distributions and Functions - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/numeric/ublas/][uBLAS]] (Linear algebra facilities, linear systems, vector matrices
  and so on.)
  + Brief: "uBLAS provides matrix and vector classes as well as basic
    linear algebra routines. Several dense, packed and sparse storage
    schemes are supported."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/numeric/odeint/doc/html/boost_numeric_odeint/getting_started/overview.html][Boost Odeint]]
  + Library for ordinary differential equations - initial value
    problems.

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/date_time.html][Date Time]]
  + Brief: "A set of date-time libraries based on generic programming concepts."
  + Descr: "The motivation for this library comes from working with
    and helping build several date-time libraries on several
    projects. Date-time libraries provide fundamental infrastructure
    for most development projects. However, most of them have
    limitations in their ability to calculate, format, convert, or
    perform some other functionality. For example, most libraries do
    not correctly handle leap seconds, provide concepts such as
    infinity, or provide the ability to use high resolution or
    network time sources. These libraries also tend to be rigid in
    their representation of dates and times. Thus customized policies
    for a project or subproject are not possible."

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/chrono.html][Chapter 7. Boost.Chrono 2.0.8 - 1.69.0]] (Time interval computation,
  already in C++11, but it is a good documentation for the STL
  library.) 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/accumulators.html][Accumulators]]
  + Summary: Incremental statistics.
  + Descr: "Boost.Accumulators is both a library for incremental statistical
    computation as well as an extensible framework for incremental
    calculation in general. The library deals primarily with the
    concept of an accumulator, which is a primitive computational
    entity that accepts data one sample at a time and maintains some
    internal state. These accumulators may offload some of their
    computations on other accumulators, on which they
    depend. Accumulators are grouped within an accumulator
    set. Boost.Accumulators resolves the inter-dependencies between
    accumulators in a set and ensures that accumulators are processed
    in the proper order."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/multiprecision/doc/html/boost_multiprecision/intro.html][Boost Multiprecisions]]
  + Brief: "The Multiprecision Library provides integer, rational,
    floating-point, and complex types in C++ that have more range and
    precision than C++'s ordinary built-in types. The big number
    types in Multiprecision can be used with a wide selection of
    basic mathematical operations, elementary transcendental
    functions as well as the functions in Boost.Math. The
    Multiprecision types can also interoperate with the built-in
    types in C++ using clearly defined conversion rules. This allows
    Boost.Multiprecision to be used for all kinds of mathematical
    calculations involving integer, rational and floating-point types
    requiring extended range and precision."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/units/][Units]]
  + Brief: "Zero-overhead dimensional analysis and unit/quantity
    manipulation and conversion."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/multi_array/doc/user.html][The Boost Multidimensional Array Library (Boost.MultiArray) - 1.69.0]]
  + Brief: Multidimensional arrays, aka tensors. 

*** Parallel Computing 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/mpi.html][Chapter 26. Boost.MPI - 1.69.0]]
  + Brief: "Boost.MPI is a library for message passing in high-performance
    parallel applications. A Boost.MPI program is one or more
    processes that can communicate either via sending and receiving
    individual messages (point-to-point communication) or by
    coordinating as a group (collective communication). Unlike
    communication in threaded environments or using a shared-memory
    library, Boost.MPI processes can be spread across many different
    machines, possibly with different operating systems and
    underlying architectures."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/compute/doc/html/index.html][Chapter 1. Boost.Compute - 1.69.0]]
  + Brief: "The Boost Compute library provides a C++ interface to
    multi-core CPU and GPGPU computing platforms based on OpenCL." 
 
*** String Utilities 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_lexical_cast.html][Chapter 21. Boost.Lexical_Cast 1.0 - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/format/][The Boost Format library - 1.69.0]]
  + The format library provides a class for formatting arguments
    according to a format-string, as does printf, but with two major
    differences : format sends the arguments to an internal stream,
    and so is entirely type-safe and naturally supports all
    user-defined types. The ellipsis (...) can not be used correctly
    in the strongly typed context of format, and thus the function
    call with arbitrary arguments is replaced by successive calls to
    an argument feeding operator%

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/string_algo.html][String algo]]
  + Brief: "The String Algorithm Library provides a generic
    implementation of string-related algorithms which are missing in
    STL. It is an extension to the algorithms library of STL and it
    includes trimming, case conversion, predicates and find/replace
    functions. All of them come in different variants so it is easier
    to choose the best fit for a particular need." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/spirit/][Boost Spirit]]
  + Brief: Framework for building parsers.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/tokenizer/][Tokenizer]]
  + Brief: "Break of a string or other character sequence into a
    series of tokens."

*** Template Metaprogramming facilities 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/utility/operators.htm][Boost Operators]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/range/][Range]] [BEST]
  + Descr: "A new infrastructure for generic algorithms that builds
    on top of the new iterator concepts."
  + Note: Maybe the future replacement for C++ classical iterators.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/hof/doc/html/doc/src/index.html][Boost.HigherOrderFunctions]] (aka Boost.Hof)
  + Brief: Provides many higher order functions. 
  + Descr: HigherOrderFunctions is a header-only C++11/C++14 library that
    provides utilities for functions and function objects, which can
    solve many problems with much simpler constructs than whats
    traditionally been done with metaprogramming.

+ [[https://www.boost.org/doc/libs/1_69_0/libs/mp11/doc/html/mp11.html][Boost.Mp11: A C++11 metaprogramming library - 1.69.0]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/fusion/doc/html/fusion/preface.html][Boost Fusion]]

+ [[https://www.boost.org/doc/libs/1_69_0/libs/hana/doc/html/index.html][Boost.Hana]]
  + Brief: "Hana is a header-only library for C++ metaprogramming
    suited for computations on both types and values."
  + Descr: "The functionality it provides is a superset of what is
    provided by the well established Boost.MPL and Boost.Fusion
    libraries. By leveraging C++11/14 implementation techniques and
    idioms, Hana boasts faster compilation times and runtime
    performance on par or better than previous metaprogramming
    libraries, while noticeably increasing the level of
    expressiveness in the process. Hana is easy to extend in a ad-hoc
    manner and it provides out-of-the-box inter-operation with
    Boost.Fusion, Boost.MPL and the standard library." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/concept_check/][Concept check]]
  + Descr: "Tools for generic programming."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/proto/][Proto]]
  + Brief: "Expression template library and compiler construction
    toolkit for domain-specific embedded languages."

*** Design Patterns and Object Oriented Design Patterns 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_typeerasure.html][Chapter 40. Boost.TypeErasure - 1.69.0]]
  + Brief: "The Boost.TypeErasure library provides runtime
    polymorphism in C++ that is more flexible than that provided by
    the core language. The Boost.TypeErasure library combines the
    superior abstraction capabilities of templates, with the runtime
    flexibility of virtual functions."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/ptr_container/doc/ptr_container.html][Boost Pointer Container Library - 1.69.0]]
  + Brief: "Boost.Pointer Container provides containers for holding
    heap-allocated objects in an exception-safe manner and with
    minimal overhead. The aim of the library is in particular to make
    OO programming easier in C++ by establishing a standard set of
    classes, methods and designs for dealing with OO specific
    problems." 

+ [[https://www.boost.org/doc/libs/release/libs/flyweight/][Boost Flyweight]]
  + Brief: Descr: "Design pattern to manage large quantities of
    highly redundant objects."

  + Descr: "Flyweights are small-sized handle classes granting
    constant access to shared common data, thus allowing for the
    management of large amounts of entities within reasonable memory
    limits. Boost.Flyweight makes it easy to use this common
    programming idiom by providing the class template flyweight<T>,
    which acts as a drop-in replacement for const T."

  + Additional notes:
    + "Learning to use Boost.Flyweight can be accomplished in a matter
      of minutes. When special needs arise, however, an extensive
      customization interface is provided which allows the user to
      control and extend the following aspects:"
    + Type tagging for separation of domains using the same basic flyweight types.
    + Specification and parameterization of the so-called flyweight factory.
    + Control of the factory instantiation procedure.
    + Specification of the internal synchronization mechanisms.
    + Flyweight tracking, allowing for the disposal of stored values
      when no longer referenced by any flyweight object.

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/property_tree.html][Chapter 32. Boost.PropertyTree - 1.69.0]]
  + "The Property Tree library provides a data structure that stores
    an arbitrarily deeply nested tree of values, indexed at each
    level by some key. Each node of the tree stores its own value,
    plus an ordered list of its subnodes and their keys. The tree
    allows easy access to any of its nodes by means of a path, which
    is a concatenation of multiple keys." 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/functional/factory/doc/html/index.html][Boost.Functional/Factory]]
  + Brief: "The template boost::factory lets you encapsulate a new
    expression as a function object, boost::value_factory
    encapsulates a constructor invocation without new."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/property_map/doc/property_map.html][Property Map Library - 1.69.0]]

*** Command Line Options 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/program_options.html][Chapter 31. Boost.Program_options - 1.69.0]]

*** Debugging, Logging and Assertions 

+ [[https://www.boost.org/doc/libs/1_69_0/libs/log/doc/html/index.html][Chapter 1. Boost.Log v2 - 1.69.0]]
  + Descr: "The application stores all essential information about its
    execution to a log, and when something goes wrong this
    information can be used to analyze the program behavior and make
    the necessary corrections. There are other very useful
    applications of logging, such as gathering statistical
    information and highlighting events (i.e. indicating that some
    situation has occurred or that the application is experiencing
    some problems). These tasks have proved to be vital for many
    real-world industrial applications. This library aims to make
    logging significantly easier for the application developer. It
    provides a wide range of out-of-the-box tools along with public
    interfaces for extending the library. The main goals of the
    library are:"
    + Simplicity. A small example code snippet should be enough to
      get the feel of the library and be ready to use its basic
      features.
    + Extensibility. A user should be able to extend functionality of
      the library for collecting and storing information into logs.
    + Performance. The library should have as little performance
      impact on the user's application as possible.

*** Network - Sockets - TCP/IP

+ [[https://www.boost.org/doc/libs/1_69_0/libs/asio/][Boost Asio]]
  + Descr: "Portable networking and other low-level I/O, including sockets,
    timers, hostname resolution, socket iostreams, serial ports, file
    descriptors and Windows HANDLEs."

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/crc.html][Boost CRC]] - CRC (Cyclick Redundancy Checking)
  + Descr: " CRCs (cyclic redundancy codes) is one common technique
    to confirming data integrity after transmission. The Boost.CRC
    library provides access to two styles of CRC computation, one as
    a function template, the other as a function template and two
    computation object class templates, where the two class templates
    differ in speed."

+ [[https://www.boost.org/doc/libs/1_69_0/libs/statechart/][Statechart]]
  + Brief: "Boost.Statechart - Arbitrarily complex finite state
    machines can be implemented in easily readable and maintainable
    C++ code."
  + Note: Many network protocols, embedded systems applications and
    business processes are well described by state machines such as
     [[https://en.wikipedia.org/wiki/Mealy_machine][Mealy state machine]] or [[https://en.wikipedia.org/wiki/Moore_machine][Moore State machine]].

+ [[https://www.boost.org/doc/libs/1_69_0/libs/uuid/][UUID]] - A universally unique identifier.

*** Shared Libraries and Plugins - DLL, DSO, SO

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_dll.html][Boost DLL]]
  + Brief: "This library was designed to simplify plugin development using C++ in a portable cross-platform manner."
  + Descr: "Adding a specific features to an existing software
    applications at runtime could be useful in many cases. Such
    extensions, or plugins, are usually implemented using Dynamic
    Library Modules (DLL,SO/DSO) loaded at runtime."
  + Library provides a portable across platforms way to:
    + load libraries
    + import any native functions and variables
    + make alias names for C++ mangled functions and symbols
    + query libraries for sections and exported symbols
    + self loading and self querying
    + getting program and module location by exported symbol

*** Subprocess and inter process communication - IPC 

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/interprocess.html][Boost.Interprocess]]
  + Brief: "Boost.Interprocess simplifies the use of common
    interprocess communication and synchronization mechanisms and
    offers a wide range of them:"
    + Shared memory.
    + Memory-mapped files.
    + Semaphores, mutexes, condition variables and upgradable mutex
      types to place them in shared memory and memory mapped files.
    + Named versions of those synchronization objects, similar to UNIX/Windows sem_open/CreateSemaphore API.
    + File locking.
    + Relative pointers.
    + Message queues.
  + Additional:
    + Boost.Interprocess also offers higher-level interprocess
      mechanisms to allocate dynamically portions of a shared memory
      or a memory mapped file (in general, to allocate portions of a
      fixed size memory segment). Using these mechanisms,
      Boost.Interprocess offers useful tools to construct C++
      objects, including STL-like containers, in shared memory and
      memory mapped files:

+ [[https://www.boost.org/doc/libs/1_69_0/doc/html/process.html#boost_process.introduction][Boost.Process]]
  + Brief: "Boost.Process is a library to manage system processes. It
    can be used to:"
    + create child processes
    + setup streams for child processes
    + communicate with child processes through streams (synchronously
      or asynchronously)
    + wait for processes to exit (synchronously or asynchronously)
    + terminate processes

*** Low level and byte manipulation 

  + [[https://www.boost.org/doc/libs/1_69_0/libs/endian/doc/index.html][Endian Library - 1.69.0]]
** Boost Format 

The boost library format provides a type-safe printf-like notation
which is concise as the old C-printf functions (printf, sprintf,
fprintf) and less intrusive and verbose than the C++ (<<) insertion
operator. 

 + Documentation: [[https://www.boost.org/doc/libs/1_69_0/libs/format/doc/format.html][Boost format]]
 + Header: <boost/format.hpp>
 + Functions:
   + boost::str
   + boost::format

Using the library: 
 + As the library is a header-only library as almost all boost
   libraries. All what is needed to use it is just include the
   following header.

#+BEGIN_SRC cpp 
  #include <boost/format.hpp>
#+END_SRC

Example 1: Test in CERN's ROOT REPL.

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <cmath>
  #include <boost/format.hpp>
  double x = 10.0;

  >> boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") % x % std::sqrt(x) % std::log2(x)
  (boost::basic_format &) @0x7ffcfe86fbd8

  >> auto fmt = boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") % x % std::sqrt(x) % std::log2(x)(boost::basic_format<char, std::char_traits<char>, std::allocator<char> > &) @0x7f8c7b52b020
  >> fmt
  (boost::basic_format<char, std::char_traits<char>, std::allocator<char> > &) @0x7f8c7b52b020
  >>  

  >> std::cout << fmt << "\n";
   x = 10 ; sqrt(x) = 3.16228 ; log2(x) = 3.32193

  >> std::cout << boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") % x % std::sqrt(x) % std::log2(x) << "\n";
   x = 10 ; sqrt(x) = 3.16228 ; log2(x) = 3.32193
  >> 
#+END_SRC

Example 2: Multiline code. 

#+BEGIN_SRC cpp 
  // Pasting the following code block in the REPL between curly
  // brackets, including them.
  {
   std::cout << boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") 
                % x % std::sqrt(x) % std::log2(x) << "\n";
  } 
  // Output:
  x = 10 ; sqrt(x) = 3.16228 ; log2(x) = 3.32193
#+END_SRC

Example 3.A: Turn format object into std::string.

#+BEGIN_SRC cpp 
  >> double z = M_PI_2;
  >> z
  (double) 1.5707963

  >> auto fm = boost::format("operation = %1% - z = %2% %1%(%2%) = %3%") % "sin" % z % std::sin(z) ;
  >> std::cout << "fm = " << fm << "\n";
  fm = operation = sin - z = 1.5708 sin(1.5708) = 1

  >> std::string result = fm.str();
  >> result
  (std::string &) "operation = sin - z = 1.5708 sin(1.5708) = 1"
#+END_SRC

Example 3.B: 

#+BEGIN_SRC cpp 
 >> std::string result2 = boost::str(boost::format("operation = %1% - z = %2% %1%(%2%) = %3%") % "sin" % z % std::sin(z))

 >> result2
 (std::string &) "operation = sin - z = 1.5708 sin(1.5708) = 1"
#+END_SRC
** Boost Lexical_cast 

Boost lexical cast is header-only library for converting from
built-int types to string and from string to built-in types. 

 + Documentation: [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_lexical_cast.html#boost_lexical_cast.motivation][Boost Lexical Cast]] 
 + Header: <boost/format.hpp>
 + Functions:
   + boost::lexical_cast 

Example: 

 + *Headers and namespace:*

#+BEGIN_SRC cpp 
  #include <boost/lexical_cast.hpp>

  // Namespace alias 
  namespace b = boost;
#+END_SRC

 *Basic conversions:*

#+BEGIN_SRC cpp 
  >> b::lexical_cast<int>("456")
  (int) 456

  >> b::lexical_cast<double>(".4615e3")
  (double) 461.50000

  >> b::lexical_cast<double>("inf")
  (double) inf

  >> b::lexical_cast<long double>("34e5")
  (long double) 3400000.0L
  >> 

  >> b::lexical_cast<double>("inf error")
  Error in <TRint::HandleTermInput()>: 
  boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_lexical_cast> > 
   caught: bad lexical cast: source type value could not be interpreted as target

  >> b::lexical_cast<double>(" asdsas ")
  Error in <TRint::HandleTermInput()>: 
  boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_lexical_cast> > 
  caught: bad lexical cast: source type value could not be interpreted as target
    >> 

  >> b::lexical_cast<long double>(" 100 ")
  Error in <TRint::HandleTermInput()>: 
   boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_lexical_cast> > 
   caught: bad lexical cast: source type value could not be interpreted as target
  >> 
#+END_SRC

 *Catch exceptions:*

#+BEGIN_SRC cpp 
  #include <cmath> 

  void PrintSquareRoot(const char* number_str){
       try {
          double x = boost::lexical_cast<double>(number_str);
          std::cout << "x = " << x
                    << " ; sqrt(x) = " << std::sqrt(x)
                    << "\n";
       } catch(boost::bad_lexical_cast const& ex)
       {
          std::cerr << " [ERROR] " << ex.what() << "\n";
       }
  }
#+END_SRC

Testing: 

#+BEGIN_SRC cpp 
  >> PrintSquareRoot("34.34")
  x = 34.34 ; sqrt(x) = 5.86003

  >> PrintSquareRoot("-125.0")
  x = -125 ; sqrt(x) = -nan

  >> PrintSquareRoot("-12dsad 5.0")
   [ERROR] bad lexical cast: source type value could not be interpreted as target

  >> PrintSquareRoot(" ")

  >> PrintSquareRoot(" 100 ")
   [ERROR] bad lexical cast: source type value could not be interpreted as target
  >> 
#+END_SRC

 *Function try_lexical_convert* 

Convert from string to built-in type without exceptions. 

Pseudo-signature: 
 + Returns true if succeed to convert source type to target type and
   then sets the result variable. Otherwise, the function returns
   false. 

#+BEGIN_SRC cpp 
  namespace boost::conversion 
  {
    template<typename Target, typename Source>
    bool try_lexical_convert(Source const& arg, Targe& result);
  }
#+END_SRC

Testing: 

#+BEGIN_SRC cpp 
  >> double z = 0.0
  (double) 0.0000000

  >> boost::conversion::try_lexical_convert("200.34", z)
  (bool) true
  >> z
  (double) 200.34000

  >> boost::conversion::try_lexical_convert("200 error .34", z)
  (bool) false
  >> z
  (double) 200.00000

  >> boost::conversion::try_lexical_convert("not-a-number", z)
  (bool) false
  >> z
  (double) 0.0000000
#+END_SRC
** Boost string algo 

Provides lots of useful string utility functions that are missing in
the standard library. 

 + Documentation:
   + [[https://www.boost.org/doc/libs/1_69_0/doc/html/string_algo/usage.html][Boost String Main Documentation]]
   + [[https://www.boost.org/doc/libs/1_69_0/doc/html/string_algo/quickref.html][Quick Referece card.]]
 + Header: <boost/algorithm/string.hpp>
 + Functions:
   + boost::to_upper
   + boost::to_lower
   + boost::trim
   + boost::iends_with
   + boost::istarts_with
   + boost::replace
   + boost::replace_first 

 *Example:*

Headers: 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 
   #include <vector>
#+END_SRC

Boost header and namespace alias: 

#+BEGIN_SRC cpp  
   #include <boost/algorithm/string.hpp>

   // b => Namespace alias to boost namespace. 
   namespace b = boost;
#+END_SRC

Convert string to upper/lower case.

#+BEGIN_SRC cpp 
  >> std::string s = " C++ is an old new programmign LANGUAGE";
  >> 

  // To upper case 
  >> b::to_upper(s)
  >> s
  (std::string &) " C++ IS AN OLD NEW PROGRAMMIGN LANGUAGE"
  >> 

  // To lower case:
  >> b::to_lower(s)
  >> s
  (std::string &) " c++ is an old new programmign language"
#+END_SRC

Trim string on both sides: 

#+BEGIN_SRC cpp 
  >> std::string ss = "   A string with  spaces   ";
  >> b::trim(ss)
  >> ss
  (std::string &) "A string with  spaces"
#+END_SRC

Check whether starts with some prefix: 

#+BEGIN_SRC cpp 
  // Checks whether first string argument starts with 'industry
  >> b::istarts_with("revenues outlook.pdf", "industry")
  (bool) false

  >> b::istarts_with("industry revenues outlook.pdf", "industry")
  (bool) true

  >> b::istarts_with("   industry revenues outlook.pdf", "industry")
  (bool) false
#+END_SRC

Check whether string ends with some suffix:

#+BEGIN_SRC cpp 
  // Checks whether first strigns ends with suffix '.pdf'
  >>  b::iends_with("revenues-outlook.xls", ".pdf")
  (bool) false

  >>  b::iends_with("revenues-outlook.pdf", ".pdf")
  (bool) true
#+END_SRC

Replace all strings: 

#+BEGIN_SRC cpp 
  >> std::string words = "ASM c++ low c++ ASM  python bytes ASM c++";

  // Replace 'c++' by 'CEE-PLUS-PLUS'
  >> b::replace_all(words, "c++", "CEE-PLUS-PLUS")

  >> words
  (std::string &) "ASM CEE-PLUS-PLUS low CEE-PLUS-PLUS ASM  python bytes ASM CEE-PLUS-PLUS"
  >> 

  >> b::replace_all(words, "CEE-PLUS-PLUS", "cpp")
  >> words
  (std::string &) "ASM cpp low cpp ASM  python bytes ASM cpp"
#+END_SRC


Split string: 

#+BEGIN_SRC cpp 
  std::string dataset = " -100.23 ; 577.15 ; 99.34 ; 1003.5";
  std::vector<std::string> split_vector{};

  >> split_vector
  (std::vector<std::string> &) {}

  // Split string dataset at delimiter ";"
  >> b::split(split_vector, dataset, b::is_any_of(";"));

  // Result 
  >> split_vector
  (std::vector<std::string> &) { " -100.23 ", " 577.15 ", " 99.34 ", " 1003.5" }
#+END_SRC











