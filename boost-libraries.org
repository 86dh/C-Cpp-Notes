#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ Notes - Boost Libraries 
#+DESCRIPTION: cpp/c++ c++ design patterns gneric programming object oriented metaprogramming
#+STARTUP: content 

- [[wiki:index][Index]]

* Boost Libraries 
** Boost Libraries already in C++ ISO standard 

Some Boost libraries are redundant as they are already in the C++ ISO
standard. However, it is worth using them if a compiler to new
C++ standards is not available. 

|------------------+---------------------+-----------------------|
| Boost Library    | C++ Standard        | Added to the standard |
|                  | equivalent          | since:                |
|------------------+---------------------+-----------------------|
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_random.html][Boost.Random]]     | Header <random>     | C++11                 |
| [[https://www.boost.org/doc/libs/1_69_0/libs/regex/doc/html/index.html][Boost.Regex]]      | Library: [[https://en.cppreference.com/w/cpp/regex][<regex>]]    | C++11                 |
|                  |                     |                       |
| [[https://www.boost.org/doc/libs/1_69_0/libs/optional/doc/html/index.html][Boost.Optional]]   | std::optional       | C++17                 |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/any.html][Boost.Any]]        | std::any            | C++17                 |
| [[https://www.boost.org/doc/libs/1_69_0/doc/html/variant.html][Boost.Variant]]    | std::variant        | C++17                 |
| [[https://www.boost.org/doc/libs/1_69_0/libs/filesystem/doc/index.htm][Boost.Filesystem]] | Library: [[https://en.cppreference.com/w/cpp/filesystem][filesystem]] | C++17 [optional]      |
|                  |                     |                       |
|------------------+---------------------+-----------------------|


** Boost Format 

The boost library format provides a type-safe printf-like notation
which is concise as the old C-printf functions (printf, sprintf,
fprintf) and less intrusive and verbose than the C++ (<<) insertion
operator. 

 + Documentation: [[https://www.boost.org/doc/libs/1_69_0/libs/format/doc/format.html][Boost format]]
 + Header: <boost/format.hpp>
 + Functions:
   + boost::str
   + boost::format

Using the library: 
 + As the library is a header-only library as almost all boost
   libraries. All what is needed to use it is just include the
   following header.

#+BEGIN_SRC cpp 
  #include <boost/format.hpp>
#+END_SRC

Example 1: Test in CERN's ROOT REPL.

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <cmath>
  #include <boost/format.hpp>
  double x = 10.0;

  >> boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") % x % std::sqrt(x) % std::log2(x)
  (boost::basic_format &) @0x7ffcfe86fbd8

  >> auto fmt = boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") % x % std::sqrt(x) % std::log2(x)(boost::basic_format<char, std::char_traits<char>, std::allocator<char> > &) @0x7f8c7b52b020
  >> fmt
  (boost::basic_format<char, std::char_traits<char>, std::allocator<char> > &) @0x7f8c7b52b020
  >>  

  >> std::cout << fmt << "\n";
   x = 10 ; sqrt(x) = 3.16228 ; log2(x) = 3.32193

  >> std::cout << boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") % x % std::sqrt(x) % std::log2(x) << "\n";
   x = 10 ; sqrt(x) = 3.16228 ; log2(x) = 3.32193
  >> 
#+END_SRC

Example 2: Multiline code. 

#+BEGIN_SRC cpp 
  // Pasting the following code block in the REPL between curly
  // brackets, including them.
  {
   std::cout << boost::format(" x = %1% ; sqrt(x) = %2% ; log2(x) = %3%") 
                % x % std::sqrt(x) % std::log2(x) << "\n";
  } 
  // Output:
  x = 10 ; sqrt(x) = 3.16228 ; log2(x) = 3.32193
#+END_SRC

Example 3.A: Turn format object into std::string.

#+BEGIN_SRC cpp 
  >> double z = M_PI_2;
  >> z
  (double) 1.5707963

  >> auto fm = boost::format("operation = %1% - z = %2% %1%(%2%) = %3%") % "sin" % z % std::sin(z) ;
  >> std::cout << "fm = " << fm << "\n";
  fm = operation = sin - z = 1.5708 sin(1.5708) = 1

  >> std::string result = fm.str();
  >> result
  (std::string &) "operation = sin - z = 1.5708 sin(1.5708) = 1"
#+END_SRC

Example 3.B: 

#+BEGIN_SRC cpp 
 >> std::string result2 = boost::str(boost::format("operation = %1% - z = %2% %1%(%2%) = %3%") % "sin" % z % std::sin(z))

 >> result2
 (std::string &) "operation = sin - z = 1.5708 sin(1.5708) = 1"
#+END_SRC
** Boost Lexical_cast 

Boost lexical cast is header-only library for converting from
built-int types to string and from string to built-in types. 

 + Documentation: [[https://www.boost.org/doc/libs/1_69_0/doc/html/boost_lexical_cast.html#boost_lexical_cast.motivation][Boost Lexical Cast]] 
 + Header: <boost/format.hpp>
 + Functions:
   + boost::lexical_cast 

Example: 

 + *Headers and namespace:*

#+BEGIN_SRC cpp 
  #include <boost/lexical_cast.hpp>

  // Namespace alias 
  namespace b = boost;
#+END_SRC

 *Basic conversions:*

#+BEGIN_SRC cpp 
  >> b::lexical_cast<int>("456")
  (int) 456

  >> b::lexical_cast<double>(".4615e3")
  (double) 461.50000

  >> b::lexical_cast<double>("inf")
  (double) inf

  >> b::lexical_cast<long double>("34e5")
  (long double) 3400000.0L
  >> 

  >> b::lexical_cast<double>("inf error")
  Error in <TRint::HandleTermInput()>: 
  boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_lexical_cast> > 
   caught: bad lexical cast: source type value could not be interpreted as target

  >> b::lexical_cast<double>(" asdsas ")
  Error in <TRint::HandleTermInput()>: 
  boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_lexical_cast> > 
  caught: bad lexical cast: source type value could not be interpreted as target
    >> 

  >> b::lexical_cast<long double>(" 100 ")
  Error in <TRint::HandleTermInput()>: 
   boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_lexical_cast> > 
   caught: bad lexical cast: source type value could not be interpreted as target
  >> 
#+END_SRC

 *Catch exceptions:*

#+BEGIN_SRC cpp 
  #include <cmath> 

  void PrintSquareRoot(const char* number_str){
       try {
          double x = boost::lexical_cast<double>(number_str);
          std::cout << "x = " << x
                    << " ; sqrt(x) = " << std::sqrt(x)
                    << "\n";
       } catch(boost::bad_lexical_cast const& ex)
       {
          std::cerr << " [ERROR] " << ex.what() << "\n";
       }
  }
#+END_SRC

Testing: 

#+BEGIN_SRC cpp 
  >> PrintSquareRoot("34.34")
  x = 34.34 ; sqrt(x) = 5.86003

  >> PrintSquareRoot("-125.0")
  x = -125 ; sqrt(x) = -nan

  >> PrintSquareRoot("-12dsad 5.0")
   [ERROR] bad lexical cast: source type value could not be interpreted as target

  >> PrintSquareRoot(" ")

  >> PrintSquareRoot(" 100 ")
   [ERROR] bad lexical cast: source type value could not be interpreted as target
  >> 
#+END_SRC

 *Function try_lexical_convert* 

Convert from string to built-in type without exceptions. 

Pseudo-signature: 
 + Returns true if succeed to convert source type to target type and
   then sets the result variable. Otherwise, the function returns
   false. 

#+BEGIN_SRC cpp 
  namespace boost::conversion 
  {
    template<typename Target, typename Source>
    bool try_lexical_convert(Source const& arg, Targe& result);
  }
#+END_SRC

Testing: 

#+BEGIN_SRC cpp 
  >> double z = 0.0
  (double) 0.0000000

  >> boost::conversion::try_lexical_convert("200.34", z)
  (bool) true
  >> z
  (double) 200.34000

  >> boost::conversion::try_lexical_convert("200 error .34", z)
  (bool) false
  >> z
  (double) 200.00000

  >> boost::conversion::try_lexical_convert("not-a-number", z)
  (bool) false
  >> z
  (double) 0.0000000
#+END_SRC
** Boost string algo 

Provides lots of useful string utility functions that are missing in
the standard library. 

 + Documentation:
   + [[https://www.boost.org/doc/libs/1_69_0/doc/html/string_algo/usage.html][Boost String Main Documentation]]
   + [[https://www.boost.org/doc/libs/1_69_0/doc/html/string_algo/quickref.html][Quick Referece card.]]
 + Header: <boost/algorithm/string.hpp>
 + Functions:
   + boost::to_upper
   + boost::to_lower
   + boost::trim
   + boost::iends_with
   + boost::istarts_with
   + boost::replace
   + boost::replace_first 

 *Example:*

Headers: 

#+BEGIN_SRC cpp 
   #include <iostream>
   #include <string> 
   #include <vector>
#+END_SRC

Boost header and namespace alias: 

#+BEGIN_SRC cpp  
   #include <boost/algorithm/string.hpp>

   // b => Namespace alias to boost namespace. 
   namespace b = boost;
#+END_SRC

Convert string to upper/lower case.

#+BEGIN_SRC cpp 
  >> std::string s = " C++ is an old new programmign LANGUAGE";
  >> 

  // To upper case 
  >> b::to_upper(s)
  >> s
  (std::string &) " C++ IS AN OLD NEW PROGRAMMIGN LANGUAGE"
  >> 

  // To lower case:
  >> b::to_lower(s)
  >> s
  (std::string &) " c++ is an old new programmign language"
#+END_SRC

Trim string on both sides: 

#+BEGIN_SRC cpp 
  >> std::string ss = "   A string with  spaces   ";
  >> b::trim(ss)
  >> ss
  (std::string &) "A string with  spaces"
#+END_SRC

Check whether starts with some prefix: 

#+BEGIN_SRC cpp 
  // Checks whether first string argument starts with 'industry
  >> b::istarts_with("revenues outlook.pdf", "industry")
  (bool) false

  >> b::istarts_with("industry revenues outlook.pdf", "industry")
  (bool) true

  >> b::istarts_with("   industry revenues outlook.pdf", "industry")
  (bool) false
#+END_SRC

Check whether string ends with some suffix:

#+BEGIN_SRC cpp 
  // Checks whether first strigns ends with suffix '.pdf'
  >>  b::iends_with("revenues-outlook.xls", ".pdf")
  (bool) false

  >>  b::iends_with("revenues-outlook.pdf", ".pdf")
  (bool) true
#+END_SRC

Replace all strings: 

#+BEGIN_SRC cpp 
  >> std::string words = "ASM c++ low c++ ASM  python bytes ASM c++";

  // Replace 'c++' by 'CEE-PLUS-PLUS'
  >> b::replace_all(words, "c++", "CEE-PLUS-PLUS")

  >> words
  (std::string &) "ASM CEE-PLUS-PLUS low CEE-PLUS-PLUS ASM  python bytes ASM CEE-PLUS-PLUS"
  >> 

  >> b::replace_all(words, "CEE-PLUS-PLUS", "cpp")
  >> words
  (std::string &) "ASM cpp low cpp ASM  python bytes ASM cpp"
#+END_SRC


Split string: 

#+BEGIN_SRC cpp 
  std::string dataset = " -100.23 ; 577.15 ; 99.34 ; 1003.5";
  std::vector<std::string> split_vector{};

  >> split_vector
  (std::vector<std::string> &) {}

  // Split string dataset at delimiter ";"
  >> b::split(split_vector, dataset, b::is_any_of(";"));

  // Result 
  >> split_vector
  (std::vector<std::string> &) { " -100.23 ", " 577.15 ", " 99.34 ", " 1003.5" }
#+END_SRC











