#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ - Building Systems and Build Automation 
#+DESCRIPTION: cpp/c++ code examples and demonstrations.
#+STARTUP: content 

- [[wiki:index][Index]]

* Building Systems and Build Automation 
** Building System 

  + [[https://cmake.org/][CMake]] (*De-facto standard*) Meta building system which can generate
    project files and building scripts for platform-preferred building
    systems. For instance, it can generate Makefile for U*nix-like
    system, Ninja build scripts, Visual Studio solutions and so on.
    + Note: CMake is being used by many projects and supported by many
      IDEs. Now, it is supported by Microsft's Visual Studio and
      JetBrains' Clion IDE and others.
    + See:
      + [[http://cliutils.gitlab.io/modern-cmake/][An Introduction to Modern CMake]]
      + [[https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1][Effective Modern CMake]]
      + https://github.com/ttroy50/cmake-examples
      + [[https://cristianadam.eu/20181202/a-better-qnx-cmake-toolchain-file/][A Better QNX CMake Toolchain File - Cristian Adam]]

  + [[https://build2.org/][build2]] - "build2 is an open source (MIT), cross-platform build
    toolchain for developing and packaging C++ code. It is a hierarchy
    of tools that includes the build system, package dependency manager
    (for package consumption), and project dependency manager (for
    project development)."
    + See: [[https://news.ycombinator.com/item?id=17188851][Build2, a Cargo-like dependency and build manager for C/C++ | Hacker News]]

  + [[https://xmake.io][xmake]] -  "xmake is a cross-platform build utility based on lua. The
    project focuses on making development and building easier and
    provides many features (.e.g package, install, plugin, macro,
    action, option, task ...), so that any developer can quickly pick
    it up and enjoy the productivity boost when developing and building
    project. "
    + Github: https://github.com/tboox/xmake
    + Advatange:
      + Lua-like syntax
      + Less verbose than CMake
      + Run lua scripts
      + Generation of projects, for instance Visual studio solutions.    

  + *Make* (GNU Make, BSD Make and NMake) - Simple and quick building
    system more used on U*nix-like operating systems.

** Dependency Management and Package Managers

 *Package Managers*
 
There still no standard C++ package manager or most widely used pacakge
manager. However there are many of them without a clear winner.

 + [[https://www.conan.io/][Conan]] [Most mature], [BEST] - Dependency manager written in Python which
   can install source packages.
   + CMake Support: YES
   + Implementation Issues: As Conan is written in Python, therefore
     it requires a Python installation.
   + Package authoring: Packages configuration are written in Python.
   + See:
     + [[https://blog.conan.io/2017/05/11/C-C++-Binary-Package-Management-for-Visual-Studio.html][C/C++ Binary Package Management for Visual Studio]]

 + [[https://docs.microsoft.com/en-us/cpp/vcpkg?view=vs-2017][vcpkg]] [Most mature], [BEST] - open source cross-platform C++ package
   manager created by Microsft Inc.
   + Creator: Microsft Inc. MSFT
   + CMake Support: YES
   + Documentation: https://vcpkg.readthedocs.io/en/latest/
   + Repository: https://github.com/Microsoft/vcpkg
   + See:
     + [[https://blog.kitware.com/vcpkg-a-tool-to-build-open-source-libraries-on-windows/][Vcpkg: A tool to build open source libraries on Window]]
     + Video: Microsft - [[https://www.youtube.com/watch?v=zo6nqFVBd5o][Vcpkg a tool to build open source C++ libraries]]
     + Video: Microsft - [[https://channel9.msdn.com/Shows/C9-GoingNative/GoingNative-54-Whats-New-In-Visual-Studio-2017-RC-and-Introduction-To-Vcpkg][GoingNative 54: What's New In Visual Studio 2017 RC and Introduction To Vcpkg]]
     + Video: [[https://www.youtube.com/watch?v=KOeOLOu6nHw][C++ Weekly - Ep 118 - Trying Out The vcpkg Package Manager]]

 + [[https://www.qpm.io/][QPM]] - Pcakge manager for QT.
   + Repository: https://github.com/Cutehacks/qpm
   + CMake Support: ???
   + Package listing: https://www.qpm.io/packages/index.html

 + [[https://github.com/pfultz2/cget][cget]] - "Cmake package retrieval. This can be used to download and
   install cmake packages." Decentralized: Packages can be installed
   from anywhere, from github, urls, or local files. NOTE: It is not a
   package manager.
   + Reator: Paul Fultz
   + CMake Support: YES 
   + Repository: https://github.com/pfultz2/cget

 + [[https://github.com/ruslo/hunter][Hunter]] - Cross-platform package manager for C/C++ fully integrated
   to CMake, it does not need any external configuration file or run
   any application before CMake.
   + Creator: Ruslan Baratov
   + CMake Support: YES
   + Documentation: https://docs.hunter.sh
   + Package list: https://docs.hunter.sh/en/latest/packages.html
   + Note: It is still under development, but it seems promising.

 + [[http://www.buckaroo.pm/][Buckaroo]] - "A C++ package manager that will take you to your happy place"
   + Creator: LoopPerfect Limited LTD.
   + CMake Support: ???
   + Buckaroo-recipes: https://github.com/LoopPerfect/buckaroo-recipes/tree/master/recipes

 + [[https://cppan.org/][Cppan]] - "CPPPAN is the crossplatform C/C++ dependency manager. It
   is built on top of CMake and also has build system capabilities."
   + Creator: Egor Pugin
   + CMake Support: ???
   + Repository: https://github.com/cppan/cppan
   + Documentation: https://github.com/cppan/cppan/tree/v1/doc

 + [[https://build2.org/][Build2]] - "build2 is an open source (MIT), cross-platform build
   toolchain for developing and packaging C++ code. It is a hierarchy
   of tools that includes the build system, package dependency manager
   (for package consumption), and project dependency manager (for
   project development)."
   + Creator: [[https://codesynthesis.com/][Code Synthesis LTDA]], Boris Kolpackov
   + CMake Support: NO 
   + Package listing: https://cppget.org/
   + Possible shortcoming: No integration with CMake building-system
     and no integration to IDEs like CMake.
   + See:
     + Video: [[https://www.youtube.com/watch?v=Nni2Qu2WitY&feature=youtu.be][CppCon 2018: "C++ Dependency Management: from Package Consumption to Project Development"]]

 + [[https://blogs.msdn.microsoft.com/vcblog/2013/04/26/nuget-for-c/][Nuget]] - A pacakge manager used in Visual Studio for C#, VB.NET,
   Javascript and C++.
   + Creator: Microsft Inc. MSFT
   + CMake Support: NO 
   + Problem: It seems to work only on Windows and Visual Studio.
   + See: 
     + https://blog.nuget.org/20130426/native-support.html
     + Video: [[https://www.youtube.com/watch?v=FIY4FZDIt8Q][Consuming Native NuGet Packages in Visual Studio]]
     + https://blog.scalyr.com/2018/07/getting-started-quickly-c-logging/
     + [[https://www.microsofttranslator.com/bv.aspx?from=&to=en&a=https://qiita.com/nia_tn1012/items/77c3c1b006f7c69d30ac][Let's use Nuget in C++ project]] (Translated from Japanese with Bing Translator.)

 + [[https://spack.io/][Spack]] - "Spack is a package manager for supercomputers, Linux, and
   macOS. It makes installing scientific software easy. With Spack,
   you can build a package with multiple versions, configurations,
   platforms, and compilers, and all of these builds can coexist on
   the same machine."
   + Repository: https://github.com/spack/spack

 + [[https://github.com/iauns/cpm][CPM]] - [NO LONGER MAINTENED] "A C++ Package Manager based on CMake and Git."


Some package manager whishlist:

 + CMake integration
 + Cross platform
 + Easier to use from CMake without needing to call any external
   command, the packages to be installed should be defined in the
   CMakeLists.txt file.
 + Command line tools
 + Browse package metadata from command line.
 + Integration with IDEs
 + [IF Possible] - Standalone no depending on any interpreter or
   external dependency. If the tool is written with a scripting
   language, but fully packed with the interpreter, it would fullfill
   the whishlist.

Interesting discussions: 

 + Reddit /r/cpp [[https://www.reddit.com/r/cpp/comments/3d1vjq/is_there_a_c_package_manager_if_not_how_do_you/][Is there a C++ package manager? If not, how do you handle dependencies?]]

 + Reddit /r/cpp - [[https://www.reddit.com/r/cpp/comments/5v10r1/downsides_to_conanio/][Downsides to Conan.io?]]

 + Reddit /r/cpp - [[https://www.reddit.com/r/cpp/comments/40cfbk/hunter_crossplatform_package_manager_for_c/][Hunter - Cross-platform package manager for C++]]

 + [[https://news.ycombinator.com/item?id=16915195][Announcing a single C++ library manager for Linux, macOS and Windows: Vcpkg]]

* CMake - Reference Card
** Overview 

 *Motivation* 
 
  + _Easier cross-platform compilation and portability_
    + A single CMake building-script to rule all building systems.

  + _No reliance on a single IDE or building system_
    + CMake can generate projects and building scripts for many IDEs
      and also several IDEs are providing support for CMake without
      requiring generating a project to the IDE.

  + _Human-readability_
    + The project file is just a CMakeLists.txt human-readable text,
      not an obfuscated or cryptic XML files, cryptic and verbose Json
      files or non-portable Makefiles.

  + _All configuration managed by code rather than GUI and XML_
    + Almost all configuration of a CMake project are managed by CMake
      language code, rather than by GUIs graphical user interfaces
      like Visual Studio Projects with MSBUild. This approach allows
      more customization, scalability and also faster changes. Another
      benefits are the portability among IDEs with CMake support. This
      text-centric approach also relieves users from learning IDE
      specific details or configuration GUIs. 

  + _Network effect (Network Externality)_
    + Network effect can be described as phenomenon where additional
      users increases the value of products and services to all
      users.
    + Many C++ libraries are being distributed with CMake; many open
      source projects are adopting CMake; most C++ package managers
      support CMake and IDEs are starting to provide CMake support.


 *CMake can be used in following ways:*

 + _Build a software directly from command line_ in a similar way to
   Unix's make - $ make and $ make install.

 + _Generate IDE-specific or preferred project files_ in IDEs that does
   not supports CMake, for instance cmake can generate projects from
   the file CMakeLists.txt for the IDEs and text editors: Microsoft
   Visual Studio, CodeBlocks, Kate projects, Sublime and Eclipse CDT.

 + _Manage a project in IDEs which supports CMake_. In this case, it is
   not necessary to generate IDE-specific project files.


 *IDE Supporting Cmake for managing and building projects:*

 + Microsft - [[https://blogs.msdn.microsoft.com/vcblog/2016/10/05/cmake-support-in-visual-studio/][Visual Studio]] 
 + JetBrains - [[https://www.youtube.com/watch?v=Rbb0fVCz41w][Clion IDE]] 
 + QTCreator 
 + [[https://www.kdevelop.org/][KDevelop IDE]] 
   + Note: KDevelop allows managing project with CMake, visualization
     of all CMake targets, run individual targets with mouse click,
     run install target and so on.
   + Note: On Windows, it doesn't support Visual Studio / MSVC
     projects with MSVC (VC++) "visual" C++ compiler.

 *Supported Programming Languages*

 + ASM - Assembly
 + C
 + C++
 + Fortran
 + CSharp C#
 + CUDA
 + CXX 
 + Java
 + RC - Windows Resource Compiler
 + Swift 

 *Capabilities:*

 + Generate IDE-specific project files.
 + Generate Visual Studio Solutions (projects)
 + Generate Makefiles (GNU Make) or NMake (Windows make) for direct
   compilation.
 + Run targets like GNU make
 + Build a software or library directly from command line.

 *Possibilities* 

A CMake project can contain one or more target (taks), similar to
Makefile rules:

 + _Multiples targets for build executables_ - the same CMake file can
   be used to build multiple applications.

 + _Target to build shared library_ 

 + _Target to build static library_

 + _Target to install aplications or libraries_

 + _Custom targets_

 *CMake Project Examples*

  + [[https://github.com/caiorss/winapi-snippets-cmake][winapi snippets]]
    + Code snippets and examples for Windows API in modern C++ managed
      by CMake.
  + [[https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71][shared library]]
    + Example containibng: Cross platform shared library exporting
      functions, classes, polymorphic classes and C-interfaces
      (wrapper functions with C-linkage). It also contains a C++
      client-code and Python wrapper which uses Python ctype FFI
      foreign function interface.
  + [[https://github.com/caiorss/example-pybind11-vcpkg][example-pybind11-vcpkg]]
    + This example project contains a Python3 native module written in
      C++ with the help of CMake and Pybind11, vcpkg (C++) Package
      manager. 

** Minimal CMake Project Workflow

This section contains a minimal CMake project that generates a single
executable which uses OpenGL libraries. All sources at: [[https://gist.github.com/caiorss/fd9e61887e9b2575f2275a80af44fac2][gist]]

A CMake project contains at least the file CMakeLists.txt (Cmake
building definitions akin to Makefile) and one or more sources -
files: *.c, *.cpp, *.cxx, *.hpp. 

Workflow:

 + Build and install the application or library directly from command
   line.

 + Generate IDE-specific building scripts if the IDE does not support
   opening CMake projects. Example: CMake can generate Makefiles for
   EClipse CDT or Visual Studio solution for old Visual Studio
   versions which doesn't support CMake.

 + Open and manage the project directly if the IDE or editor supports
   CMake. In Visual Studio, QTCreator or KDevelop, to open a CMake
   project, it is just necessary to open the directory containing the
   CMakeLists.txt. 

 *File:* CMakeLists.text 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)

  # Proeject name - should not contain whitespace 
  project(OpengGL_CPP)

  #========== Global Configurations =============#
  #----------------------------------------------#

  # Set the C++ standard for all targets (It sets the flags
  # (-std=c++11, -std=c++14 ...) on Clang or GCC. and /std=c++17 on MSVC
  # OPTIONAL:
  #---------------------------------
  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #========== Targets Configurations ============#

  # Build an executable (Unix-like OSes generates ./openglDemo1, on
  # Windows ./opengDemo1.exe)
  # ..........................................
  add_executable(openglDemo1 opengl1.cpp)

  # Set executable dependency libraries
  # Equivalent to pass flags -lGL, -lGLU and -lglut 
  target_link_libraries(openglDemo1 GL GLU glut)

  # Add extension .bin to executable name to make it easier
  # to identify that the binary file is an executable.
  # So, it turns  openglDemo1 becomes openglDemo1.bin 
  if(UNIX)
    set_target_properties(openglDemo1 PROPERTIES SUFFIX ".bin")
  endif()

  # Add target to run executable 
  add_custom_target(run-ex1
      COMMAND openglDemo1 
      DEPENDS openglDemo1 
      WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
  )
#+END_SRC

Without all the comments and the custom target, the CMakeLists.txt
file would become:

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(OpengGL_CPP)
  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #========== Targets Configurations ============#
  add_executable(openglDemo1 opengl1.cpp)
  target_link_libraries(openglDemo1 GL GLU glut)
#+END_SRC


 *Building on Command Line:*

1 Install OpenGL development libraries (Fedora Linux):

#+BEGIN_SRC sh 
  $ sudo dnf install freeglut-devel.x86_64
  # Optional: Faster and better building system than GNU Make
  $ sudo dnf install ninja-build.x86_64 
#+END_SRC

2 Clone sample project:

#+BEGIN_SRC sj 
  $ git clone https://gist.github.com/caiorss/fd9e61887e9b2575f2275a80af44fac2 cmake-opengl
  Cloning into 'cmake-opengl'...
  remote: Enumerating objects: 4, done.
  remote: Counting objects: 100% (4/4), done.
  remote: Compressing objects: 100% (4/4), done.
  remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0
  Unpacking objects: 100% (4/4), done.

  $ cd cmake-opengl/

  $ ls
  CMakeLists.txt  opengl1.cpp
#+END_SRC

3 Build with Makefile:
 
   + cmake -H<SOURCE> -B<BUILD> [-G <Build-Systems>]
     + <SOURCE> - Directory where is CMakeLists.txt (In this case (.)
       current directory)
     + <BUILD> - Directory containing compilation output and the
       building scripts generated by CMake for some building
       systems. In this exaple: ./cache 
     + -G  <Build-Systems> -> [Optional] Specifies the building
       systems which CMake will generate the scripts for. On Linux,
       the default building system is Makefiles and on Windows it is
       MSBuild. 

#+BEGIN_SRC sh 
  # Generate => Building scripts for Makefile on ./cache directory 
  $ cmake -H. -Bcache 

  -- The C compiler identification is GNU 8.2.1
  -- The CXX compiler identification is GNU 8.2.1
  ... ...   ... ...   ... ...   ... ...   ... ... 
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/cmake-opengl/cache
#+END_SRC

Build the executable running the building script (Makefile) from CMake:

 + Note: It will build all CMake targets, all executables and libraries.

#+BEGIN_SRC sh 
  $ cmake --build cache

  /usr/bin/cmake -H/home/archbox/root-scripts/cmake-opengl -B/home/archbox/root-scripts/cmake-opengl/cache --check-build-system CMakeFiles/Makefile.cmake 0
  /usr/bin/cmake -E cmake_progress_start /home/archbox/root-scripts/cmake-opengl/cache/CMakeFiles /home/archbox/root-scripts/cmake-opengl/cache/CMakeFiles/progress.marks
   .. ...  .. ...  .. ...  .. ...  .. ...  .. ... 
  ir/build
  gmake[2]: Entering directory '/home/archbox/root-scripts/cmake-opengl/cache'
  [ 50%] Building CXX object CMakeFiles/openglDemo1.dir/opengl1.cpp.o
  /usr/lib64/ccache/c++    -std=gnu++1z -o CMakeFiles/openglDemo1.dir/opengl1.cpp.o -c /home/archbox/root-scripts/cmake-opengl/opengl1.cpp
  [100%] Linking CXX executable openglDemo1.bin
#+END_SRC

Build a single target:

#+BEGIN_SRC sh 
 $ cmake --build cache --target openglDemo1
#+END_SRC

Inspect executable: 

#+BEGIN_SRC sh 
  $ file cache/openglDemo1.bin 
   
   cache/openglDemo1.bin: ELF 64-bit LSB
   executable, x86-64, version 1 (SYSV), dynamically linked, interpreter
   /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0,
   BuildID[sha1]=269d06a0054677d70ecf0258268565535e3dfbd4, not stripped
#+END_SRC

Execute a custom target, for instance the custom target _run-ex1_ which runs
the executable (aking to $ make run).

#+BEGIN_SRC sh 
  $ cmake --build cache --target run-ex1

    ... ... .... 
  Scanning dependencies of target run-ex1
  gmake[3]: Leaving directory '/home/archbox/root-scripts/cmake-opengl/cache'
  /usr/bin/gmake -f CMakeFiles/run-ex1.dir/build.make CMakeFiles/run-ex1.dir/build
  gmake[3]: Entering directory '/home/archbox/root-scripts/cmake-opengl/cache'
  ./openglDemo1.bin
  [INFO] Starting OpenGL main loop.
  [INFO] Running loop.
  [INFO] Running loop.
#+END_SRC

4 Build with Ninja. 

 + The compilation can be faster and less verbose with Ninja-build
   building systems.

#+BEGIN_SRC sh 
  # Remove cache directory 
  rm -rf cache

  # Generate building scripts for Ninja building system in directory ./cache 
  $ cmake -H. -Bcache -G Ninja
  -- The C compiler identification is GNU 8.2.1
   ... .... ... .... ... .... ... ....
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/cmake-opengl/cache

  # Build a single target 
  $ cmake --build cache --target openglDemo1
  [2/2] Linking CXX executable openglDemo1.bin

  # Build all targets 
  $ cmake --build cache --target all
  ninja: no work to do.

  # Run target: run-ex1 (akin to $ make run)
  $ cmake --build cache --target run-ex1
  [0/1] cd /home/archbox/root-scripts/cm...pts/cmake-opengl/cache/openglDemo1.bin
#+END_SRC
 
5 Open project with IDE or editor that doesn't support CMake, for
instance: Code Blocks.

 + The following command generates a blocks project file
   (OpengGL_CPP.cbp) and a GNU make building (Makefile) script. Then,
   the project can be opened from Code Blocks by selecting the file
   OpenGL_CPP.cpb which is a CodeBlocks project file.

#+BEGIN_SRC 
  $ cmake -H. -Bcblock -G "CodeBlocks - Unix Makefiles"

  -- The C compiler identification is GNU 8.2.1
   ... ... ... ... ... ... .... 
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/cmake-opengl/cblock

  $ tree cblock -L 1
  cblock
  ├── CMakeCache.txt
  ├── CMakeFiles
  ├── cmake_install.cmake
  ├── Makefile
  └── OpengGL_CPP.cbp

  1 directory, 4 files
#+END_SRC

** Target Configuration 

CMake can set up a compilation target in compiler-agnostic manner:

 *Set up executable target*

 + Executable target defintion => Builds a *.exe on Windows.

#+BEGIN_SRC cmake  
   add_executable(SampleApp main.cpp sourc1.cpp source2.cpp)
#+END_SRC

 *Set target defines #define or -D<DEFINITION>=VALUE or /D<DEFINTION>=<VALUE>*

 + Compiler defintions. => Defines.
   + It is the same as compiling with GCC with command line option
     -D{DEFINITION}={VALUE} or compiling with MSVC VC++ with the
     command line option /D{DEFINITION}={VALUE} which becomes #define
     {DEFINITION} {VALUE} in the code.
   + Docs: [[https://cmake.org/cmake/help/latest/command/target_compile_definitions.html][target_compile_definitions — CMake 3.13.2 Documentation]]

#+BEGIN_SRC cmake 
    target_compile_definitions(SampleApp PRIVATE  
       VERBOSITY=100  # Same as #define VERBOSITY 100 
       Optimize       # Same as -DOptimize or #define Optimize
       foo=bar        # Same as -Dfoo=bar on (GGCC or Clang) or /Dfoo=bar on MSVC
      )
   # In a single line 
    target_compile_definitions(SampleApp PRIVATE VERBOSITY=100 Optimize foo=bar)
#+END_SRC

 *Set target include directories*

 + Include directories containing header files. Similar to
   command line option -I with GCC.
   + [[https://cmake.org/cmake/help/v3.0/command/target_include_directories.html][target_include_directories — CMake 3.0.2 Documentation]]

#+BEGIN_SRC cmake 
  # Similar to: g++ main.cpp src1.cpp ... -o app.bin -Isrc/include1 -I/home/user/include
  target_include_directories(SampleApp PUBLIC src/include1 /home/usr/include)
#+END_SRC

 *Set directories where shared or static libraries will be searched*

Set the directories where shared or static libraries will be
searched. Note: this command sets the search path for shared libraries
for all targets. 

#+BEGIN_SRC cmake
  link_directories(  
    # C:\Users\DummyUser\libs
    "C:\\Users\\DummyUser\\libs" # Windows paths with backward slash must be escaped with '\'
    "C:/libs/Graphics"           # Windows paths with forward slash 
    "/home/DummyUser/libs" 
  )
#+END_SRC

The command shown in the previous code is equivalent to compiling a
target with GCC as: 

#+BEGIN_SRC sh 
  $ g++ file1.cpp -c -o file1.o -LC:\Users\DummyUser\libs -LC:/libs/Graphics/ -L/home/DummyUser/libs
#+END_SRC


Shared Librarie files extensions: 
 + ~*.dll~ files on Windows for all compilers.
 + ~*.so~ files on Unix-like OSes
 + ~*.dylib~ or ~*.so~ on MacOSX

Static librarie file extension:
 + ~*.lib~ files for MSVC, VC++
 + ~*.a~ for GCC, GCC/Mingw or Clang++. 

 *Set linking libraries*

 + Libraries that the executable will link against.
   + It can be: shared libraries installed on the system or either
     shared or static libraries in the current project.
   + Note: Project libraries are also targets. 

#+BEGIN_SRC cmake  
   # Project shared library SampleSharedLib.so (Linux, Unix) or 
   # SampleSharedLib.dll on Windows. 
   add_library(SampleSharedLib SHARED  lib1.cpp lib2.cpp lib3.cpp)
   # Configuration of target SampleSharedLib
   target_include_directories(SampleSharedLib PRIVATE src/lib/include1)

   # Project static library 
   add_library(StaticLibrary STATIC lib1.cpp lib2.cpp lib3.cpp)

   target_link_libraries(SampleApp  
           GL blas opencv ole32 user32  # System libraries  /usr/lib/*.so files on Linux 
                                        # or *.lib files for MSVC VC++/Windows compiler and DLLs 
                                        # at C:\Windows\System32
           SampleSharedLib              # Project shared library 
           StaticLibrary                # Project static library 
   )
#+END_SRC

 *Set compiler flags* 

 + Target compilar flags.
   + Note: The compilation flags are compiler-specific, the following
     flags only works for GCC and Clang, but they don't work for MSVC
     (VC++ Compiler) that uses forward slashes for compiler options
     instead of dashes. 

#+BEGIN_SRC cmake 
   if(NOT MSVC) 
      # Only for GCC or Clang 
      # (g) => Add debugging symbols 
      target_compile_options(SampleApp -g -Wall -Wpendantic -Wextra )
   else()
      # MSVC (VC++) => "visual" C++
      target_compile_options(SampleApp /Zi /Wall /Yd)         
   endif()
#+END_SRC

 *Set target Properties*

  + Set target properties:

#+BEGIN_SRC cmake 
 set_target_properties(SampleApp PROPERTIES 
     {PROPERTY1} {VALUE1}
     {PROPERTY2} {VALUE2}
     ... .... ... ... 
     {PROPERTYN} {VALUEN}
  )
#+END_SRC

Example 1: Add file extension .bin to Unix executable (note: on
Unix-like OSes, executables does not have extension like in Windows):

#+BEGIN_SRC cmake 
 if(UNIX)
    # When it is compiled, instead of generating the executable named as SampleApp, 
    # the program will be named as "SampleApp.bin". 
    set_target_properties(SampleApp PROPERTIES SUFFIX ".bin")
  endif()
#+END_SRC

Example 2: Modify multiple properties, set the shared library file
name to AddinExtesion.xll. 

#+BEGIN_SRC cmake 
  add_library(WrapperLibrary SHARED src1.cpp src2.cpp ... srcN.cpp)
  # ... omit configuration ... # 

  set_target_properties(WrapperLibrary PROPERTIES
    # On Unix, it would add "lib" to beggining of the file name.
    # If prefix was not set to empty, the output file name would be
    # 'libAddinExtesion.xll'
    PREFIX       ""  

    # Change file name without changing prefix or extension (suffix)
    OUTPUT_NAME  "AddinExtension"

    # Change file extension 
    SUFFIX      ".xll"    
  
    # Makes all symbols hidden by default (compiles with by compiling
    # with flag -fvisibility=hidden on Unix-like Oses).  This setting
    # mimics the behavior of MSVC compiler extension
    # __declspec(dllexport)/__declspec(dllimport)
    CXX_VISIBILITY_PRESET hidden
  )
#+END_SRC

The target properties could also be set individually:

#+BEGIN_SRC cmake 
  add_library(WrapperLibrary SHARED src1.cpp src2.cpp ... srcN.cpp)
  # ... omit configuration ... # 
  set_target_properties(WrapperLibrary PROPERTIES PREFIX      "")
  set_target_properties(WrapperLibrary PROPERTIES OUTPUT_NAME "AddinExtension")
  set_target_properties(WrapperLibrary PROPERTIES SUFFIX      ".xll")  
#+END_SRC

 *Add more targets* 

A CMake project can have multiple targets, generating executables,
static libraries or shared libraries.

#+BEGIN_SRC cmake 
  add_executable(DocGenerator src/docgen/main.cpp src/docgen/src2.cpp ...)
  # ... configuration of DocGenerator

  add_executable(Display src/docgen/main.cpp src/docge/src2.cpp ...)
  
  add_library(libCommon SHARED src/lib/src1.cpp src/lib/src2.cpp ...)

  # .... configure targes .... #
#+END_SRC

 *To avoid* 

 + *Commands which affects all targets*: for instance,
   include_directories(dir1 dir2 ...) will add those include
   directories to all targets regardless if they need them or not. It
   is better to use the command target_include_directories as it
   affects just a single target. The same said for the command
   link_directories().

 + *Non portable compiler settings.* Example: Compiler flags such as
   -D{KEY}=VALUE, used by GCC and Clang, or /D{KEY}=VALUE, used by
   MSVC (VC++) are non portable accross different compilers. To
   overcome this, CMake provides many commands with an unified
   interface to many compilers and build-systems, such as
   _target_compile_definitions_ that allows setting defines in a
   compiler agnostic manner.

** Executable Target with resource icon (Windows only)

This section provides an example about how to add a resource icon to a
Windows executable target.

Files:

| Project Item    | Description                            |   |
|-----------------+----------------------------------------+---|
| Application     | ProgramWithICON.exe                    |   |
| Sources:        | src/main.cpp src/src1.cpp src/src2.cpp |   |
| Icon            | src/programImage.ico                   |   |
| Resource script | src/icon.rc                            |   |
|-----------------+----------------------------------------+---|

Resource file: src/icon.rc 

#+BEGIN_SRC cpp
  // Icon Resource => Compiled by Resource compiler
  id ICON "programImage.ico"
#+END_SRC

CMakeLists.txt 

#+BEGIN_SRC cmake 
   # .... Omit beginning and global configuration .... #
    add_executable(ProgramWithICON src/main.cpp src/src1.cpp src/src2.cpp)
   if(WIN32)
      target_sources(ProgramWithICON src/icon.rc)
   endif()
 
   target_include_directories(ProgramWithICON  ./includes)
  # .... Omit additional configuration ... #
#+END_SRC

** CMake Map 

 + Global configuration/settings 
   + add_definitions
   + set(<VARIABLE> <VALUE>)
   + add_subdirectory 

 + Target defintions
   + add_executable => Create target for building executable. 
   + add_library    => Create target for building static or shared library.
   + add_custom_target

 + Target Configuration:
   + set_target_properties(<TARGET> PROPERTIES <KEY> <VALUE> [<KEY <VALUE>] ...)
   + set_target_properties(testlib PROPERTIES CXX_VISIBILITY_PRESET hidden)
     + Make  symbols of shared or static library hidden by default,
       only explicitly annotated symbols are visible. It avoids name
       clashing which can lead to undefined behavior.

   + target_link_libraries(<executable-target> PUBLIC testlib)

 + Auxiliary targets:
   + install  => Install packages to some directoriy.

 + Find Commands:
   + find_path 
   + find_package
   + find_library
   + include_directory

 + Global Variables:
   + set(CMAKE_CXX_STANDARD 14)
   + set(CMAKE_VERBOSE_MAKEFILE ON)
   + set(CMAKE_BUILD_TYPE  debug)

Typical CMake Variables:

|--------------------------+----------------+-----------------------------------------------------------|
| Variable                 | Compiler flags | Description                                               |
|                          | affected       |                                                           |
|--------------------------+----------------+-----------------------------------------------------------|
| *Misc*                     |                |                                                           |
| PROJECT_NAME             | -              | Sets project name.                                        |
|                          |                |                                                           |
| *Compiler*                 |                |                                                           |
|                          |                |                                                           |
| CMAKE_CXX_STANDARD       | -std=c++11     | Set the C++ standard used for compoling all sources       |
| CMAKE_CXX_FLAGS          | -              | Additional compiler flags for all targets.                |
| CMAKE_BUILD_TYPE         |                | Set whether build type is release or debug                |
|                          |                |                                                           |
| *Location*                 |                |                                                           |
| CMAKE_BINARY_DIR         |                |                                                           |
| CMAKE_CURRENT_LIST_DIR   |                | Get location of current CMakeLists.txt file.              |
| CMAKE_INSTALL_PREFIX     |                | Location where targets will be installed (target _install_) |
| CMAKE_CURRENT_BINARY_DIR |                |                                                           |
|                          |                |                                                           |
|--------------------------+----------------+-----------------------------------------------------------|

Notes: 

 + The default value of the variable CMAKE_INSTALL_PREFIX are:
   + Windows:        C:/Program Files/${PROJECT_NAME}
   + Unix-like OS:   /usr/local
** Build a project from command line.

A project using Cmake as building system contains a build script at
top level directory named CMakeLists.txt. To build a project with
CMake, it is necessary to consider that CMake, is not a building
system and does not build anything. Actually, Cmake generates building
scripts for the platform preferred building scripts. For instance, on
Linux, it can generate Makefile, Eclipse Makefiles; on Windows it can
generate MSBuild scripts, NMake (Windows SDK's make) and so on.

 + Check all possible building system for which CMake can generate
   build scripts.
   + Command: $ *cmake -G*

#+BEGIN_SRC sh 
   # Running on Windows 10 
   $ cmake -G
   CMake Error: No generator specified for -G

   Generators
     Visual Studio 15 2017 [arch] = Generates Visual Studio 2017 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 14 2015 [arch] = Generates Visual Studio 2015 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 12 2013 [arch] = Generates Visual Studio 2013 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 11 2012 [arch] = Generates Visual Studio 2012 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 10 2010 [arch] = Generates Visual Studio 2010 project files.
                                    Optional [arch] can be "Win64" or "IA64".
     Visual Studio 9 2008 [arch]  = Generates Visual Studio 2008 project files.
                                    Optional [arch] can be "Win64" or "IA64".
     Borland Makefiles            = Generates Borland makefiles.
     NMake Makefiles              = Generates NMake makefiles.
     NMake Makefiles JOM          = Generates JOM makefiles.
     Green Hills MULTI            = Generates Green Hills MULTI files
                                    (experimental, work-in-progress).
     MSYS Makefiles               = Generates MSYS makefiles.
     MinGW Makefiles              = Generates a make file for use with
                                    mingw32-make.
     Unix Makefiles               = Generates standard UNIX makefiles.
     Ninja                        = Generates build.ninja files.
     Watcom WMake                 = Generates Watcom WMake makefiles.
     CodeBlocks - MinGW Makefiles = Generates CodeBlocks project files.
     CodeBlocks - NMake Makefiles = Generates CodeBlocks project files.
     CodeBlocks - NMake Makefiles JOM
                                  = Generates CodeBlocks project files.
     CodeBlocks - Ninja           = Generates CodeBlocks project files.
     CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files.
     CodeLite - MinGW Makefiles   = Generates CodeLite project files.
     CodeLite - NMake Makefiles   = Generates CodeLite project files.
     CodeLite - Ninja             = Generates CodeLite project files.
     CodeLite - Unix Makefiles    = Generates CodeLite project files.
     Sublime Text 2 - MinGW Makefiles
                                  = Generates Sublime Text 2 project files.
     Sublime Text 2 - NMake Makefiles
                                  = Generates Sublime Text 2 project files.
     Sublime Text 2 - Ninja       = Generates Sublime Text 2 project files.
     Sublime Text 2 - Unix Makefiles
                                  = Generates Sublime Text 2 project files.
     Kate - MinGW Makefiles       = Generates Kate project files.
     Kate - NMake Makefiles       = Generates Kate project files.
     Kate - Ninja                 = Generates Kate project files.
     Kate - Unix Makefiles        = Generates Kate project files.
     Eclipse CDT4 - NMake Makefiles
                                  = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - MinGW Makefiles
                                  = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - Ninja         = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files.
#+END_SRC

 *STEP 1: Generate Building Script*

Project directory listing:

#+BEGIN_SRC sh 
  $ tree .
  .
  ├── build.bat
  ├── client1.cpp
  ├── CMakeLists.txt
  ├── Makefile
  ├── pywrapper.py
  ├── testlib.cpp
  └── testlib.hpp
#+END_SRC

 *Generate building scripts for platform-preferred building system:*

 + $ cmake -H<SOURCE> -B<BUILD>
   + <SOURCE> => Source directory where all *.cpp, *.hpp code. In this
     case it is (.) dot, current directory. If the directory was
     ./src, the command would be -Hsrc or -H./src
   + <BUILD> => Compilation output, directory where are all building
     scripts. 

Command output on Windows 10 - MSVC 2017. Note: It will set VC++ for
32 bits target, not 64 bits.

#+BEGIN_SRC sh 
  $ cmake -H. -Bbuild
  -- Building for: Visual Studio 15 2017
  -- The C compiler identification is MSVC 19.16.27025.1
  -- The CXX compiler identification is MSVC 19.16.27025.1  
  ... ...   ... ...   ... ...   ... ...   ... ... 
  -- Configuring done
  -- Generating done
  -- Build files have been written to: C:/Users/archbox/Desktop/experiments/dll/build
#+END_SRC

Command output on Linux: 

#+BEGIN_SRC sh 
  $ cmake -H. -Bbuild
  -- The C compiler identification is GNU 8.2.1
  -- The CXX compiler identification is GNU 8.2.1
  -- Check for working C compiler: /usr/lib64/ccache/cc
  -- Check for working C compiler: /usr/lib64/ccache/cc -- works
  ... ...   ... ...   ... ...   ... ...   ... ... 
   [INFO] Libtest location is at: libtest_location-NOTFOUND
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/gist/build

  # List ./build directory 
  $ tree -L 1 build
  build
  ├── CMakeCache.txt
  ├── CMakeFiles
  ├── cmake_install.cmake
  └── Makefile

  1 directory, 3 files
#+END_SRC

  *Generate building script for specific building system:*

 + $ cmake -H<SOURCE> -B<BUILD> -G <BUILD-SYSTEM>
   + <SOURCE> => Source directory where all *.cpp, *.hpp code. In this
     case it is (.) dot, current directory. If the directory was
     ./src, the command would be -Hsrc or -H./src
   + <BUILD> => Compilation output, directory where are all building
     scripts.
   + <BUILD-SYSTEM> => All available build system can be listed with $ cmake -G.

#+BEGIN_SRC sh 
 # Generate MSbuild building scripts for 32 bits target 
  $ cmake -H. -Bbuild -G "Visual Studio 15 2017"

  # Generate MSbuild building scripts for 64 bits target 
  $ cmake -H. -Bbuild -G "Visual Studio 15 2017 Win64"
#+END_SRC

 *Generate building script with debug symbols enabled:*

It automatically adds the debugging flags (/Zi) for VC++ Microsoft
Visual C++ Compiler which necessary for debugging a program with GDB,
LLDB or WinDBG. 

 + Add the flag *-DCMAKE_BUILD_TYPE=DEBUG*

#+BEGIN_SRC sh 
  # Example 1:
  $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG

  # Example 2:
  $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=RELEASE

  # Example 3: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"

  # Example 4: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"

  # Example 5: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=RELEASE -G "Visual Studio 15 2017 Win64"
#+END_SRC


 *STEP 2: Compile the project invoking the generated building scripts*

Invoke the building scripts indirectly using CMake:

 + $ cmake --build <BUILD>
   + <BUILD> Is the build directory generated at step 1. 

#+BEGIN_SRC sh 
  $ cmake --build build
  # OR
  $ cmake --build build --config Debug 
  # OR
  $ cmake --build build --config Release
#+END_SRC

Invoke the building script directly, call the building tool:
 + This building method depends on the current building system.

For MSBuild, the compilation becomes:

#+BEGIN_SRC sh
  $ MSBuild build\testlib.vcxproj

  Microsoft (R) Build Engine version 15.5.180.51428 for .NET Framework
  Copyright (C) Microsoft Corporation. All rights reserved.

  Build started 12/21/2018 12:49:38 PM.
  Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" on node 1 (default targets).
  Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" (1) is building "C:\Users\archbox\ Desktop\experiments\dll\build\ZERO_CHECK.vcxproj" (2) on node 1 (default targets).
  ... ... ... ... ... ... ... ... ... ... ... ... ... ... 
  testlib.vcxproj -> C:\Users\archbox\Desktop\experiments\dll\build\Debug\testlib.dll
  FinalizeBuildStatus:
    Deleting file "testlib.dir\Debug\testlib.tlog\unsuccessfulbuild".
    Touching "testlib.dir\Debug\testlib.tlog\testlib.lastbuildstate".
  Done Building Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" (default targets).
#+END_SRC

For Linux or Unix GNU-Make, the compilation becomes:

#+BEGIN_SRC sh 
   $ cd build

   $ make
   /usr/bin/cmake -H/home/archbox/root-scripts/gist -B/home/archbox/root-scripts/gist/build --check-build-system CMakeFiles/Makefile.cmake 0
   /usr/bin/cmake -E cmake_progress_start /home/archbox/root-scripts/gist/build/CMakeFiles /home/archbox/root-scripts/gist/build/CMakeFiles/progress.marks
   make -f CMakeFiles/Makefile2 all
   make[1]: Entering directory '/home/archbox/root-scripts/gist/build'
   make -f CMakeFiles/testlib.dir/build.make CMakeFiles/testlib.dir/depend
   make[2]: Entering directory '/home/archbox/root-scripts/gist/build'
   ... ... ... ... ... ... ... ... ... ... ... ... 
   [100%] Built target client1-executable
   make[1]: Leaving directory '/home/archbox/root-scripts/gist/build'
   /usr/bin/cmake -E cmake_progress_start /home/archbox/root-scripts/gist/build/CMakeFiles 0  


  # Built executables: 
  #--------------------------------
  $ file libtestlib.so 
  libtestlib.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically 
  linked, BuildID[sha1]=ce79ed7580a16cbc27bf113a2967eb1d66f496a3, not stripped

  $ file client1-executable.bin 
  client1-executable.bin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
  for GNU/Linux 3.2.0, BuildID[sha1]=8103d822a6d58497b63346dfcc1f7375599114f7, not stripped
#+END_SRC

Or just in a single step: 

#+BEGIN_SRC sh 
  $ cd build && make && cd ..
#+END_SRC

** Show system information 

#+BEGIN_SRC sh  
  cmake --sytem-information 
#+END_SRC 

Output on Linux: 

#+BEGIN_SRC sh 
   Avoid ctest truncation of output: CTEST_FULL_OUTPUT
   ========================================================
   === MAIN VARIABLES
   ========================================================
   CMAKE_STATIC_LIBRARY_PREFIX == "lib"
   CMAKE_STATIC_LIBRARY_SUFFIX == ".a"
   CMAKE_SHARED_LIBRARY_PREFIX == "lib"
   CMAKE_SHARED_LIBRARY_SUFFIX == ".so"
   CMAKE_SHARED_MODULE_PREFIX == "lib"
   CMAKE_SHARED_MODULE_SUFFIX == ".so"


   CMAKE_DL_LIBS == "dl"
   CMAKE_LIBRARY_PATH_FLAG == "-L"
   CMAKE_LINK_LIBRARY_FLAG == "-l"
   CMAKE_SKIP_RPATH == "NO"
   CMAKE_SYSTEM_INFO_FILE == "Platform/Linux"
   CMAKE_SYSTEM_NAME == "Linux"
   CMAKE_SYSTEM == "Linux-4.18.18-200.fc28.x86_64"
   CMAKE_CXX_COMPILER == "/usr/lib64/ccache/c++"
   CMAKE_C_COMPILER == "/usr/lib64/ccache/cc"
   CMAKE_COMPILER_IS_GNUCC == "1"
   CMAKE_COMPILER_IS_GNUCXX == "1"

   // C shared library flag
   CMAKE_SHARED_LIBRARY_C_FLAGS == "-fPIC"
   CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS == "-shared"
   CMAKE_SHARED_LIBRARY_LINK_FLAGS == ""
   ... ...    ... ...    ... ...    ... ...    ... ... 
#+END_SRC

** Show all modules 

#+BEGIN_SRC sh 
  $ cmake --help-module-list
#+END_SRC

Output: 

#+BEGIN_SRC text 
  AddFileDependencies
  AndroidTestUtilities
  BundleUtilities
  CMakeAddFortranSubdirectory
  CMakeBackwardCompatibilityCXX
  CMakeDependentOption
  CMakeDetermineVSServicePack
  CMakeExpandImportedTargets
  CMakeFindDependencyMacro
  CMakeFindFrameworks
  CMakeFindPackageMode
  CMakeForceCompiler
  CMakeGraphVizOptions

  ... ... ... ... ... ... 

  FindLAPACK
  FindLATEX
  FindLTTngUST
  FindLibArchive
  FindLibLZMA
  FindLibXml2
  FindLibXslt
  FindLua
  FindLua50
  FindLua51
  FindMFC
  FindMPEG
  FindMPEG2
  FindMPI
  FindMatlab
  FindMotif
  FindOpenACC

  ... ... ... ... ... ... ... ... 

#+END_SRC
** SNIPPET - Common Variables 
*** CMAKE_CURRENT_LIST_DIR - Directory where is CMakeLists.txt 

Prints the directory where CMAkeLists.

#+BEGIN_SRC cmake 
  message(" [INFO] CMakeLists.txt is in the directory ${CMAKE_CURRENT_LIST_DIR}")
#+END_SRC

*** CMAKE_CXX_STANDARD - Set C++ Standard

The variable ~CMAKE_CXX_STANDARD~ sets the project current C++
standard. This variable can be set to 98 (for C++98); 11 (C++11); 14
(C++14); 17 (C++17) and 20 (C++20 - experimental yet.)

 + Documentation: [[https://cmake.org/cmake/help/latest/prop_tgt/CXX_STANDARD.html#prop_tgt:CXX_STANDARD][CXX_STANDARD — CMake 3.13.2 Documentation]] 

Example: Set project to compile with C++11 ISO standard.

#+BEGIN_SRC cmake 
  set(CMAKE_CXX_STANDARD 11)
#+END_SRC

Usage: (File CMAKELists.txt)

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(MY_PROJECT_NAME)

  set(CMAKE_CXX_STANDARD 17)
  ... ... .... .... 
#+END_SRC

*** CMAKE_BUILD_TYPE - Set default building type to DEBUG 

In the debug building type optimization flags are disabled and flags
for generating debugging symbols are enabled, for GGC or GCC/Mingw and
Clang the (-g) is automatically added and for MSVC, aka VC++ (cl.exe),
the flag /Zi is also passed to the compiler. The default building type
can be set to DEBUG with the following code.

#+BEGIN_SRC cmake 
  # Set default building type to debug if it was not set
  # in command line with -DCMAKE_BUILD_TYPE=release
  if(NOT DEFINED CMAKE_BUILD_TYPE OR CMAKE_BUILD_TYPE MATCHES "")
    set(CMAKE_BUILD_TYPE  debug)
  endif()
#+END_SRC

The building type can be changed by running cmake with the flag
 (-DCMAKE_BUILD_TYPE=release). Example: 

#+BEGIN_SRC sh 
 $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"
#+END_SRC

Note: CMake is not case sensitive, so it does not matter using
'release' or RELEASE; if or IF; endif or ENDIF and so on. 

*** CMAKE_CXX_FLAGS - Compiler flags 

The globals compiler flags used to build all targets can be extended
by setting the variable CMAKE_CXX_FLAGS. However, as the compiler
flags depends on the compiler, the custom settings may not be portable
if one uses a different compiler, for instance the (-g) flag used to
generate debug symbols with GCC or Clang does not work with MSVC
(visual c++ compiler, vc++) as it uses the flag /Zi for generating
debugging symbols.

Example 1: 

#+BEGIN_SRC cmake
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}"  "-std=c++17 -g -Wall -Wextra -pendantic -O0" )
#+END_SRC

Example 2 (better):

#+BEGIN_SRC cmake
  if(NOT MSVC)
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}"  "-std=c++17 -g -Wall -Wextra -pendantic -O0" )
  endif()
#+END_SRC
** SNIPPET - Detect Operating System 
*** Detect operating system with predefined variables  

Check whether current OS is Microsft Windows NT:

#+BEGIN_SRC cmake
  if(WIN32)
    # actions ... 
    message("Compiling for Windows NT")
  else()
    # else actions .... ...
  endif()
#+END_SRC

Check whether current OS is a Unix-like operating system (Linux, BSD,
MacOSX, Android and so on): 

#+BEGIN_SRC cmake 
  if(UNIX)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC

Check if current OS is MacOSX:

#+BEGIN_SRC cmake 
  if(APPLE)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC

Check if current OS is Linux:

#+BEGIN_SRC cmake 
  if(LINUX)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC

Check if current OS is UNIX, but not MacOSX:

#+BEGIN_SRC cmake
  if(UNIX AND NOT APPLE)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC
*** Detect operating system with variable CMAKE_SYSTEM_NAME

Example: 

#+BEGIN_SRC cmake 
if(${CMAKE_SYSTEM_NAME} matches "linux")
  message(" [INFO] compiling for Linux")
elseif(${CMAKE_SYSTEM_NAME} matches "Windows")
  message(" [INFO] compiling for Windows")
elseif(${CMAKE_SYSTEM_NAME} matches "darwin")
  message(" [INFO] compiling for Apple MacOSX")
elseif(${CMAKE_SYSTEM_NAME} matches "Android")
  message(" [INFO] compiling for Android OS.")
else()
  message( " [WARNING] Operating system not identified.")
endif()
#+END_SRC

Possible Values of Variable _CMAKE_SYSTEM_NAME_

#+BEGIN_SRC cmake
  if(${CMAKE_SYSTEM_NAME} matches <<MATCHING-STRING>)
    message(" [INFO] compiling for <<MATCHIGN-STTRING> ")
  endif()
#+END_SRC

| Value of <<MATCHING-STRING> | Operating System              |   |
| for _CMAKE_SYSTEM_NAME_       |                               |   |
|-----------------------------+-------------------------------+---|
| Windows                     | Windows                       |   |
| Darwin                      | MacOSX                        |   |
| BSD                         | Free BSD, OpenBDS, NetBSD ... |   |
| FreeBSD                     |                               |   |
| Linux                       | Linux                         |   |
| Android                     | Android                       |   |
|-----------------------------+-------------------------------+---|

** SNIPPET - Detect Compiler 
*** Detect compiler using predefined variables  

 *MSVC*

Check if current compiler is MSVC - Microsft - Visual C/C++ Compiler
(Visual C++, vc++ for short):

#+BEGIN_SRC cmake 
  if(MSVC)
    message(STATUS << "Running MSVC")
  endif()
#+END_SRC

 *MSVC for 32 bits target*

Detect MSVC set up for 32 bits target (buids 32 bits binaries):

#+BEGIN_SRC cmake 
  if(MSVC AND NOT CMAKE_CL_64)
    message(" [INFO] Building for 32 bits Windows target.")
  endif()
#+END_SRC

 *MSVC for 64 bits target*

#+BEGIN_SRC cmake 
  if(MSVC AND CMAKE_CL_64)
    message(" [INFO] Building for 64 bits Windows target.")
  endif()
#+END_SRC

 *Mingw* 

Check if current compiler is GCC/Mingw, GCC compiler ported to
Windows.

#+BEGIN_SRC cmake
  if(MSVC)
    message("Running Mingw/GCC maybe on Windows")
  endif()
#+END_SRC
*** Detect compiler using CMAKE_CXX_COMPILER_ID variable 

The variable CMAKE_CXX_COMPILER_ID can be used for checking the
current C++ compiler.
 + See: [[https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER_ID.html#variable:CMAKE_%253CLANG%253E_COMPILER_ID][Documentation]]

#+BEGIN_SRC cmake 
   if (${CMAKE_CXX_COMPILER_ID} matches GNU)
     message(STATUS " [INFO] Using GCC - GNU C/C++ Compiler or MingW/GCC.")
   elseif(${CMAKE_CXX_COMPILER_ID} matches CLANG) 
     message(STATUS " [INFO] Using the super amazing, the finest C++ compiler: Clang++/LLVM.")
   elseif(${CMAKE_CXX_COMPILER_ID} matches MSVC)
     message(STATUS " [INFO] Using MSVC Windows 'Visual!!' C++ compiler")
   else()
     message( FATAL_ERROR " [ERROR] I cannot identify CMake Configuration not set for this compiler yet.")
   endif()
#+END_SRC

All possible values of ~CMAKE_CXX_COMPILER_ID~:

| Value of ~CMAKE_CXX_COMPILER_ID~ | Compiler                                       |
|--------------------------------+------------------------------------------------|
| *Most used compilers*            |                                                |
| GNU                            | GNU Compiler Collection (gcc.gnu.org)          |
| Clang                          | LLVM Clang (clang.llvm.org)                    |
| MSVC                           | Microsoft Visual Studio (microsoft.com)        |
| Intel                          | Intel Compiler (intel.com)                     |
| PGI                            | The Portland Group (pgroup.com)                |
| G95                            | G95 Fortran (g95.org)                          |
| Embarcadero, Borland           | Embarcadero (embarcadero.com)                  |
| ARMCC                          | ARM Compiler (arm.com)                         |
|                                |                                                |
| *Other compilers*                |                                                |
| Absoft                         | Absoft Fortran (absoft.com)                    |
| ADSP                           | Analog VisualDSP++ (analog.com)                |
| AppleClang                     | Apple Clang (apple.com)                        |
| Bruce                          | Bruce C Compiler                               |
| CCur                           | Concurrent Fortran (ccur.com)                  |
| Cray                           | Cray Compiler (cray.com)                       |
| HP                             | Hewlett-Packard Compiler (hp.com)              |
| IAR                            | IAR Systems (iar.com)                          |
| MIPSpro                        | SGI MIPSpro (sgi.com)                          |
| NVIDIA                         | NVIDIA CUDA Compiler (nvidia.com)              |
| OpenWatcom                     | Open Watcom (openwatcom.org)                   |
| Flang                          | Flang Fortran Compiler                         |
| PathScale                      | PathScale (pathscale.com)                      |
| SDCC                           | Small Device C Compiler (sdcc.sourceforge.net) |
| SunPro                         | Oracle Solaris Studio (oracle.com)             |
| TI                             | Texas Instruments (ti.com)                     |
| TinyCC                         | Tiny C Compiler (tinycc.org)                   |
| XL, VisualAge, zOS             | IBM XL (ibm.com)                               |

** SNIPPET - Detect whether current build is 32 bits or 64 bits

Check whether current configuration is for 64 bits build:

#+BEGIN_SRC cmake 
  if(CMAKE_SIZEOF_VOID_P EQUAL 8)
      message(" [INFO] 64 bits build.")
  else()
     message(" [INFO] 32 bits build.")
  endif()
#+END_SRC

** SNIPPET - Copy some target binaries to a directory

This piece of code copies the target binaries (compiled code) to a
directory relative to project's root directory where is CMakeLists.txt 

Targets:

#+BEGIN_SRC cmake 
  # TARGET: testlib Shared library => Builds liblinalg.so on Unix or
  # linalg.dll on Windows.
  add_library(linalg SHARED  src/testlib.cpp)

  # TARGET: app Executable => Builds 'app' on Unix-like Oses and
  # unix.exe on Windows.
  add_executable(app src/main/main-app.cpp src/main/file1.cpp src/main/file2.cpp)
#+END_SRC

Copy target files to top level directory where is CMakeLists.txt 

#+BEGIN_SRC cmake
  # If not set the install directory, attemp set the install directory
  # CMAKE_INSTALL_PREFIX to the directory ./bin 
  if(NOT DEFINED CMAKE_INSTALL_PREFIX OR CMAKE_INSTALL_PREFIX MATCHES "")
    set(CMAKE_INSTALL_PREFIX  "./bin")
  endif()

  message(" [INFO] CMakeLists.txt is in the directory ${CMAKE_CURRENT_LIST_DIR}")

  # Copy targets to ./ - Directory where is this file CMakeLists.txt (project top level dir)
  install(TARGETS app linalg DESTINATION  ${CMAKE_CURRENT_LIST_DIR})
#+END_SRC

This target can be run with: 

 + STEP 1: Set CMake building system or the project type with -G.

#+BEGIN_SRC sh 
 $ cd project-directory 

 #===> Set build system 
 # -H<SOURCE> -B<COMPILATION-OUTPUT> -G <BUILDING-SYSTEM>
 $ cmake -H. -G "Unix Makefiles" -Bbuild 
#+END_SRC
 
 + STEP 2: Run targets 

#+BEGIN_SRC sh 
 #===> Run all targets [all default.]
 $ cmake --build build --target all 

 #===> Run target install and copy the binaries to ./bin 
 $ cmake --build build --target install 
#+END_SRC

** SNIPPET - Create target to run compiled executable 

The piece following piece of code runs an executable target after it
is built in a similar way to a command $ make run. 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)

   ... ...  ... ...  ... ...

  # TARGET: myapplication 
  add_executable(myapplication src/main.cpp src/code1.cpp code2.cpp ...)

  # TARGET: run -> Runs the executable myapplication 
  # On Unix-like Oses, it runs  /<build-directory>/myapplication 
  # On Windows: it runs  <build-directory>/myapplication.exe 
  add_custom_target(run
      COMMAND myapplication
      DEPENDS myapplication
      WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
  )
#+END_SRC

After the building system is set and output directory ./build, run:

#+BEGIN_SRC sh 
   #===> Run all targets [all default.]
   $ cmake --build build --target run
#+END_SRC

** SNIPPET - Issue an error if condition is not met 

In this piece of code, if the compiler is not MSVC (vc++, aka cl.exe),
CMake stops the generation of the building script showing an error
message to the user.

#+BEGIN_SRC cmake 
  ... ... 

  if(MSVC)
     set_target_properties(WindowApp1 PROPERTIES LINK_FLAGS "/entry:mainCRTStartup")
  else() 
     message(FATAL_ERROR " [ERROR] Linker flags of target WindowApp1 not set for this compiler")
  endif()
  ... ... 
#+END_SRC
** SNIPPET - Set target subsystem: console/window - Win32 API Specific

Set target subsystem. 

#+BEGIN_SRC cmake 
  if(WIN32)
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_DEBUG "/SUBSYSTEM:CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES COMPILE_DEFINITIONS_DEBUG "_CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_RELWITHDEBINFO "/SUBSYSTEM:CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES COMPILE_DEFINITIONS_RELWITHDEBINFO "_CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_RELEASE "/SUBSYSTEM:WINDOWS")
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_MINSIZEREL "/SUBSYSTEM:WINDOWS")
  endif(WIN32)
#+END_SRC

Taken from: 
 + [[https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/recipe/VSConfigSpecificSettings][Vsconfigspecificsettings · Wiki · CMake / Community · GitLab]]
 + [[https://developercommunity.visualstudio.com/content/problem/46678/cmake-set-subsystem-to-console.html][cmake: Set subsystem to console - Developer Community]]
 + [[https://stackoverflow.com/questions/33873735/correctly-set-visual-studio-linker-flag-subsystem-in-cmake][c++ - Correctly set Visual Studio linker flag /SUBSYSTEM in CMAKE - Stack Overflow]]
** SNIPPET - Copy a target file whenever it is recompiled

Example:  Copy a shared library to project root directory ./
whenever it is rebuilt. 

 + Set the shared library target. (libtestlib.so on Unix or testlib.dll
   on Windows)

#+BEGIN_SRC cmake 
  add_library( testlib  SHARED  ./testlib.cpp)
  set_target_properties(testlib PROPERTIES CXX_VISIBILITY_PRESET hidden)
#+END_SRC

 + Automatically copy to root directory the generated shared library
   binary to root directory on every recompilation of the target
   testlib. 

#+BEGIN_SRC cmake
  add_custom_command(TARGET testlib POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy 
    $<TARGET_FILE:testlib>                     # Source    
    ${CMAKE_CURRENT_SOURCE_DIR}/libtest.so     # Destination, file or directory 
    # OR: ${CMAKE_CURRENT_SOURCE_DIR}/         # Directory destination. 
  )
#+END_SRC

Test this post-build target: 

#+BEGIN_SRC sh 
  # Generate cache directory containing building scripts or project files 
  # specifics for some building systems
  $ cmake -H. -Bcache -G "CHOOSE SYSTEM>"

  # Run all targets  [Default]
  $ cmake --build cache --target
  $ cmake --build cache --target all 

  # Run target 'testlib'. 
  $ cmake --build cache --target testlib 
#+END_SRC

After the target is recompiled, the shared library is copied to the
current directory (project top-level directory ./).

References: 
 + https://stackoverflow.com/questions/31277186
 + https://stackoverflow.com/questions/15694347/
* Vcpkg package manager 
** Linux Installation

1 Create install directory 
  + In this instruction: VCPKG will be installed at directory
    $HOME/opt/vcpkg or ~/home/<<MY-USER>/opt/vcpkg/~

#+BEGIN_SRC sh 
  $ mkdir -p ~/opt && cd ~/opt
#+END_SRC

2 Download and compile VCPKG 

#+BEGIN_SRC sh 
  $ git clone https://github.com/Microsoft/vcpkg
  $ cd vcpkg/
  $ sh bootstrap-vcpkg.sh 
#+END_SRC

#+RESULTS:

3 Run VCPKG:

#+BEGIN_SRC sh 
  $ ./vcpkg
  Commands:
    vcpkg search [pat]              Search for packages available to be built
    vcpkg install <pkg>...          Install a package
    vcpkg remove <pkg>...           Uninstall a package
    vcpkg remove --outdated         Uninstall all out-of-date packages
    vcpkg list                      List installed packages
    vcpkg update                    Display list of packages for updating

    ... ... ... ... ... ....   ... . .. ... . .. ... .. .... 

  For more help (including examples) see the accompanying README.md.
#+END_SRC

4 Add VCPKG to search $PATH variable in order to be able to call it
from any directory.

 + Edit: ~/.bashrc or ~/.bash_profile and add the following code and
   restart the REPL.

#+BEGIN_SRC sh 
  # Directory where installed VCPKG
  export VCPKG_ROOT=$HOME/opt/vcpkg/

  # Make vcpkg tool callable from anywhere 
  export PATH=$PATH:$VCPKG_ROOT
 #+END_SRC

** Example: Project with Nana GUI Library 

GIST: [[https://gist.github.com/caiorss/724942d43cd11c6ee5b3461ac067c846][Nana GUI + VCPKG + CMake project]]

File: *CMakeLists.txt*

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.9)

   if(DEFINED ENV{VCPKG_ROOT} AND NOT DEFINED CMAKE_TOOLCHAIN_FILE)
     set(CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"
       CACHE STRING "")
       message(" [INFO] VCPKG CMAKE_TOOLCHAIN_FILE = ${CMAKE_TOOLCHAIN_FILE}")
   endif()

   #======= Global Project Configuration =========#

   project(DummyProject)
   set(CMAKE_CXX_STANDARD 17)     

   #========== Targets Configurations ============#

   ## ==> Target: gui1 - Executable: gui1

   find_package(unofficial-nana CONFIG REQUIRED)
   add_executable(gui1 gui1.cpp)
   target_link_libraries(gui1 PRIVATE
     unofficial::nana::nana fontconfig stdc++fs)

   # Add target to run executable gui1 (similar to $ make run)
   add_custom_target(run-gui1
       COMMAND gui1
       DEPENDS gui1
       WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
   )

   # Install directory relative to ${CMAKE_PREFIX_PATH}
   install(TARGETS gui1 DESTINATION ./bin)
#+END_SRC

File: *gui1.cpp*

 + Note: Demo code taken from - http://nanapro.org/en-us/

#+BEGIN_SRC cpp 
  #include <nana/gui.hpp>
  #include <nana/gui/widgets/label.hpp>
  #include <nana/gui/widgets/button.hpp>

  int main()
  {
      using namespace nana;

      //Define a form.
      form fm;
      //Define a label and display a text.
      label lab{fm, "Hello, <bold blue size=16>Nana C++ Library</>"};
      lab.format(true);
      //Define a button and answer the click event.
      button btn{fm, "Quit"};
      btn.events().click([&fm]{
          fm.close();
      });
      //Layout management
      fm.div("vert <><<><weight=80% text><>><><weight=24<><button><>><>");
      fm["text"]<<lab;
      fm["button"] << btn;
      fm.collocate();
      //Show the form
      fm.show();
      //Start to event loop process, it blocks until the form is closed.
      exec();
  }
#+END_SRC

Project directory: 

#+BEGIN_SRC sh 
  $ tree -L 1
  .
  ├── build
  ├── CMakeLists.txt
  └── gui1.cpp

  1 directory, 2 files
#+END_SRC

Install Linux dependency libraries (Tested on Linux Fedora): 

 + Note: Sometimes VCPKG cannot install system libraries. In this
   case, it is necessary to use the current distribution package
   manager. 

#+BEGIN_SRC sh 
  $ sudo dnf install libX11-devel.x86_x64
  $ sudo dnf install libXft-devel.x86_64
#+END_SRC

Clone gist containing the project: 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/caiorss/724942d43cd11c6ee5b3461ac067c846 sample-vcpkg-proj
  $ cd sample-vcpkg-proj
#+END_SRC

#+RESULTS:

 *Install package Nana with vcpkg:*

#+BEGIN_SRC sh 
  $ vcpkg install nana

   ...  ...  ...  ... 
  -- Using cached /home/archbox/opt/vcpkg/downloads/cnjinhao-nana-v1.6.2.tar.gz
  -- Using source at /home/archbox/opt/vcpkg/buildtrees/nana/src/v1.6.2-51b575c248
  -- Configuring x64-linux-dbg
  -- Configuring x64-linux-rel
  -- Building x64-linux-dbg
  -- Building x64-linux-rel
  -- Performing post-build validation
  -- Performing post-build validation done
  Building package nana[core]:x64-linux... done
  Installing package nana[core]:x64-linux... 
  Installing package nana[core]:x64-linux... done
  Elapsed time for package nana:x64-linux: 1.825 min

  Total elapsed time: 1.825 min

  The package nana:x64-linux provides CMake targets:

      find_package(unofficial-nana CONFIG REQUIRED)
      target_link_libraries(main PRIVATE unofficial::nana::nana)
#+END_SRC

List installed packages: 

#+BEGIN_SRC sh 
   $ vcpkg list
   boost-accumulators:x64-linux                       1.68.0           Boost accumulators module
   boost-algorithm:x64-linux                          1.68.0           Boost algorithm module
   boost-any:x64-linux                                1.68.0           Boost any module
   boost-array:x64-linux                              1.68.0           Boost array module

   ... ... ...   ... ... ...   ... ... ...   ... ... ...   ... ... ...   ... ... ...   ... ... ...
  
   gsl:x64-linux                                      2.4-3            The GNU Scientific Library is a numerical librar...
   gtest:x64-linux                                    1.8.1-1          GoogleTest and GoogleMock testing frameworks.
   libiconv:x64-linux                                 1.15-5           GNU Unicode text conversion
   libjpeg-turbo:x64-linux                            1.5.3-1          libjpeg-turbo is a JPEG image codec that uses SI...
   liblzma:x64-linux                                  5.2.4            Compression library with an API similar to that ...
   libpng:x64-linux                                   1.6.35-1         libpng is a library implementing an interface fo...
   nana:x64-linux                                     1.6.2            Cross-platform library for GUI programming in mo...
   pybind11:x64-linux                                 2.2.3-1          pybind11 is a lightweight header-only library th...
   spdlog:x64-linux                                   1.2.1            Very fast, header only, C++ logging library
   zlib:x64-linux                                     1.2.11-3         A compression librar
#+END_SRC

Filter nana package: 

#+BEGIN_SRC sh 
   $ vcpkg list | grep nana
   nana:x64-linux                                     1.6.2            Cross-platform library for GUI programming in mo...
#+END_SRC

 *Building with CMake Ninja or Makefile*

Cmake configuration step

 + Default system building system
   + $ cmake -H. -Bbuild 

 + Ninja building System:
   + $ cmake -H. -Bbuild -G Ninja

#+BEGIN_SRC sh 
  # Install executable at (.) curret directory
  $ cmake -H. -Bbuild -G Ninja  -DCMAKE_PREFIX_PATH=.

   [INFO] VCPKG CMAKE_TOOLCHAIN_FILE = /home/archbox/opt/vcpkg/scripts/buildsystems/vcpkg.cmake
  -- The C compiler identification is GNU 8.2.1
  -- The CXX compiler identification is GNU 8.2.1
  -- Check for working C compiler: /usr/lib64/ccache/cc

   ... ... ... ... ... ... 

  -- Found Freetype: /home/archbox/build/vcpkg/installed/x64-linux/lib/libfreetype.a (found version "2.8.1") 
  -- Found ZLIB: /home/archbox/build/vcpkg/installed/x64-linux/debug/lib/libz.a (found version "1.2.11") 
  -- Found PNG: /home/archbox/build/vcpkg/installed/x64-linux/share/png/../../lib/libpng16.a (found version "1.6.35") 
  -- Found BZip2: /home/archbox/build/vcpkg/installed/x64-linux/lib/libbz2.a (found version "1.0.6") 
  -- Looking for BZ2_bzCompressInit
  -- Looking for BZ2_bzCompressInit - found
  -- Looking for XOpenDisplay in /usr/lib64/libX11.so;/usr/lib64/libXext.so
  -- Looking for XOpenDisplay in /usr/lib64/libX11.so;/usr/lib64/libXext.so - found

   ... ... ... ... ... ... 

  -- Looking for shmat - found
  -- Found X11: /usr/lib64/libX11.so
  -- Found JPEG: /home/archbox/build/vcpkg/installed/x64-linux/debug/lib/libjpeg.a  
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/vcpkg2/build
#+END_SRC

Build all targets: 

#+BEGIN_SRC sh 
 $ cmake --build build --target 
#+END_SRC

Build and run executable target gui1 (target: run-gui1)

#+BEGIN_SRC sh 
  $ cmake --build build --target run-gui1
  [3/3] cd /home/archbox/root-scripts/vcpkg2/build && /home/archbox/root-scripts/vcpkg2/build/gui1
#+END_SRC

Install executable: 

#+BEGIN_SRC sh 
  $ cmake --build build --target install
  [2/3] Install the project...
  -- Install configuration: ""
  -- Installing: /home/archbox/root-scripts/vcpkg2/./bin/gui1
#+END_SRC

Run installed executable at ./bin 

#+BEGIN_SRC sh 
  $ bin/gui1 
#+END_SRC

Directory after compilation: 

#+BEGIN_SRC sh 
  $ tree . -L 2
  .
  ├── bin
  │   └── gui1
  ├── build
  │   ├── build.ninja
  │   ├── CMakeCache.txt
  │   ├── CMakeFiles
  │   ├── cmake_install.cmake
  │   ├── gui1
  │   ├── install_manifest.txt
  │   └── rules.ninja
  ├── CMakeLists.txt
  └── gui1.cpp

  3 directories, 9 files
#+END_SRC

 *Analyse executable:*

Check binary format 

#+BEGIN_SRC sh 
  $ file bin/gui1 

  bin/gui1: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux),
  dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for
  GNU/Linux 3.2.0,
  BuildID[sha1]=b2273c2b397213af8c8b8e8808da1ebc195d3b4d, with
  debug_info, not stripped
#+END_SRC

Check file size 

#+BEGIN_SRC sh
  # File size 
  $ du -h bin/gui1
  19M	bin/gui1
  19M	total
#+END_SRC

Remove debugging symbols 

#+BEGIN_SRC sh 
  $ strip bin/gui1 
#+END_SRC

Check file size again: 

#+BEGIN_SRC sh 
  $ du -h bin/gui1
  3.3M	bin/gui1
  3.3M	total
#+END_SRC

Check shared libraries dependencies:

#+BEGIN_SRC sh 
   $ ldd bin/gui1
           linux-vdso.so.1 (0x00007fff18930000)
           libfontconfig.so.1 => /lib64/libfontconfig.so.1 (0x00007f5f73116000)
           libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f5f72ef7000)
           libX11.so.6 => /lib64/libX11.so.6 (0x00007f5f72bb6000)
           libXext.so.6 => /lib64/libXext.so.6 (0x00007f5f729a4000)
           libXft.so.2 => /lib64/libXft.so.2 (0x00007f5f7278d000)
           libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007f5f723fa000)
           libm.so.6 => /lib64/libm.so.6 (0x00007f5f72066000)
           libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007f5f71e4e000)
           libc.so.6 => /lib64/libc.so.6 (0x00007f5f71a8f000)
           libfreetype.so.6 => /lib64/libfreetype.so.6 (0x00007f5f717d8000)
           libexpat.so.1 => /lib64/libexpat.so.1 (0x00007f5f7159d000)
           libuuid.so.1 => /lib64/libuuid.so.1 (0x00007f5f71396000)
           /lib64/ld-linux-x86-64.so.2 (0x00007f5f7335a000)
           libxcb.so.1 => /lib64/libxcb.so.1 (0x00007f5f7116d000)
           libdl.so.2 => /lib64/libdl.so.2 (0x00007f5f70f69000)
           libXrender.so.1 => /lib64/libXrender.so.1 (0x00007f5f70d5e000)
           libbz2.so.1 => /lib64/libbz2.so.1 (0x00007f5f70b4d000)
           libpng16.so.16 => /lib64/libpng16.so.16 (0x00007f5f70919000)
           libz.so.1 => /lib64/libz.so.1 (0x00007f5f70702000)
           libXau.so.6 => /lib64/libXau.so.6 (0x00007f5f704fe000)
#+END_SRC


