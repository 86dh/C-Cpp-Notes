#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ - Building Systems and Build Automation 
#+DESCRIPTION: cpp/c++ code examples and demonstrations.
#+STARTUP: content 

- [[wiki:index][Index]]

* Building Systems and Build Automation 

  + [[https://cmake.org/][CMake]] (*De-facto standard*) Meta building system which can generate
    project files and building scripts for platform-preferred building
    systems. For instance, it can generate Makefile for U*nix-like
    system, Ninja build scripts, Visual Studio solutions and so on.
    + Note: CMake is being used by many projects and supported by many
      IDEs. Now, it is supported by Microsft's Visual Studio and
      JetBrains' Clion IDE and others.
    + See:
      + [[http://cliutils.gitlab.io/modern-cmake/][An Introduction to Modern CMake]]
      + [[https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1][Effective Modern CMake]]
      + https://github.com/ttroy50/cmake-examples
      + [[https://cristianadam.eu/20181202/a-better-qnx-cmake-toolchain-file/][A Better QNX CMake Toolchain File - Cristian Adam]]

  + [[https://build2.org/][build2]] - "build2 is an open source (MIT), cross-platform build
    toolchain for developing and packaging C++ code. It is a hierarchy
    of tools that includes the build system, package dependency manager
    (for package consumption), and project dependency manager (for
    project development)."
    + See: [[https://news.ycombinator.com/item?id=17188851][Build2, a Cargo-like dependency and build manager for C/C++ | Hacker News]]

  + [[https://xmake.io][xmake]] -  "xmake is a cross-platform build utility based on lua. The
    project focuses on making development and building easier and
    provides many features (.e.g package, install, plugin, macro,
    action, option, task ...), so that any developer can quickly pick
    it up and enjoy the productivity boost when developing and building
    project. "
    + Github: https://github.com/tboox/xmake
    + Advatange:
      + Lua-like syntax
      + Less verbose than CMake
      + Run lua scripts
      + Generation of projects, for instance Visual studio solutions.    

  + *Make* (GNU Make, BSD Make and NMake) - Simple and quick building
    system more used on U*nix-like operating systems.

* CMake - Reference Card
** Overview 

 *CMake can be used in following ways:*

 + _Build a software directly from command line_ in a similar way to
   Unix's make - $ make and $ make install.

 + _Generate IDE-specific or preferred project files_ in IDEs that does
   not supports CMake, for instance cmake can generate projects from
   the file CMakeLists.txt for the IDEs and text editors: Microsoft
   Visual Studio, CodeBlocks, Kate projects, Sublime and Eclipse CDT.

 + _Manage a project in IDEs which supports CMake_. In this case, it is
   not necessary to generate IDE-specific project files.


 *IDE Supporting Cmake for managing and building projects:*

 + Microsft - [[https://blogs.msdn.microsoft.com/vcblog/2016/10/05/cmake-support-in-visual-studio/][Visual Studio]] 
 + JetBrains - [[https://www.youtube.com/watch?v=Rbb0fVCz41w][Clion IDE]] 
 + QTCreator 
 + [[https://www.kdevelop.org/][KDevelop IDE]] 
   + Note: KDevelop allows managing project with CMake, visualization
     of all CMake targets, run individual targets with mouse click,
     run install target and so on. 

 *Capabilities:*

 + Generate IDE-specific project files.
 + Generate Visual Studio Solutions (projects)
 + Generate Makefiles (GNU Make) or NMake (Windows make) for direct
   compilation.
 + Run targets like GNU make
 + Build a software or library directly from command line.

 *Possibilities* 

A CMake project can contain one or more target (taks), similar to
Makefile rules:

 + _Multiples targets for build executables_ - the same CMake file can
   be used to build multiple applications.

 + _Target to build shared library_ 

 + _Target to build static library_

 + _Target to install aplications or libraries_

 + _Custom targets_

 *CMake Project Examples*

  + [[https://github.com/caiorss/winapi-snippets-cmake][winapi snippets]]
    + Code snippets and examples for Windows API in modern C++ managed
      by CMake.
  + [[https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71][shared library]]
    + Example containibng: Cross platform shared library exporting
      functions, classes, polymorphic classes and C-interfaces
      (wrapper functions with C-linkage). It also contains a C++
      client-code and Python wrapper which uses Python ctype FFI
      foreign function interface.
  + [[https://github.com/caiorss/example-pybind11-vcpkg][example-pybind11-vcpkg]]
    + This example project contains a Python3 native module written in
      C++ with the help of CMake and Pybind11, vcpkg (C++) Package
      manager. 

** Minimal CMake Project Workflow

This section contains a minimal CMake project that generates a single
executable which uses OpenGL libraries. All sources at: [[https://gist.github.com/caiorss/fd9e61887e9b2575f2275a80af44fac2][gist]]

A CMake project contains at least the file CMakeLists.txt (Cmake
building definitions akin to Makefile) and one or more sources -
files: *.c, *.cpp, *.cxx, *.hpp. 

Workflow:

 + Build and install the application or library directly from command
   line.

 + Generate IDE-specific building scripts if the IDE does not support
   opening CMake projects. Example: CMake can generate Makefiles for
   EClipse CDT or Visual Studio solution for old Visual Studio
   versions which doesn't support CMake.

 + Open and manage the project directly if the IDE or editor supports
   CMake. In Visual Studio, QTCreator or KDevelop, to open a CMake
   project, it is just necessary to open the directory containing the
   CMakeLists.txt. 

 *File:* CMakeLists.text 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)

  # Proeject name - should not contain whitespace 
  project(OpengGL_CPP)

  #========== Global Configurations =============#
  #----------------------------------------------#

  # Set the C++ standard for all targets (It sets the flags
  # (-std=c++11, -std=c++14 ...) on Clang or GCC. and /std=c++17 on MSVC
  # OPTIONAL:
  #---------------------------------
  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #========== Targets Configurations ============#

  # Build an executable (Unix-like OSes generates ./openglDemo1, on
  # Windows ./opengDemo1.exe)
  # ..........................................
  add_executable(openglDemo1 opengl1.cpp)

  # Set executable dependency libraries
  # Equivalent to pass flags -lGL, -lGLU and -lglut 
  target_link_libraries(openglDemo1 GL GLU glut)

  # Add extension .bin to executable name to make it easier
  # to identify that the binary file is an executable.
  # So, it turns  openglDemo1 becomes openglDemo1.bin 
  if(UNIX)
    set_target_properties(openglDemo1 PROPERTIES SUFFIX ".bin")
  endif()

  # Add target to run executable 
  add_custom_target(run-ex1
      COMMAND openglDemo1 
      DEPENDS openglDemo1 
      WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
  )
#+END_SRC

Without all the comments and the custom target, the CMakeLists.txt
file would become:

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(OpengGL_CPP)
  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #========== Targets Configurations ============#
  add_executable(openglDemo1 opengl1.cpp)
  target_link_libraries(openglDemo1 GL GLU glut)
#+END_SRC


 *Building on Command Line:*

1 Install OpenGL development libraries (Fedora Linux):

#+BEGIN_SRC sh 
  $ sudo dnf install freeglut-devel.x86_64
  # Optional: Faster and better building system than GNU Make
  $ sudo dnf install ninja-build.x86_64 
#+END_SRC

2 Clone sample project:

#+BEGIN_SRC sj 
  $ git clone https://gist.github.com/caiorss/fd9e61887e9b2575f2275a80af44fac2 cmake-opengl
  Cloning into 'cmake-opengl'...
  remote: Enumerating objects: 4, done.
  remote: Counting objects: 100% (4/4), done.
  remote: Compressing objects: 100% (4/4), done.
  remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0
  Unpacking objects: 100% (4/4), done.

  $ cd cmake-opengl/

  $ ls
  CMakeLists.txt  opengl1.cpp
#+END_SRC

3 Build with Makefile:
 
   + cmake -H<SOURCE> -B<BUILD> [-G <Build-Systems>]
     + <SOURCE> - Directory where is CMakeLists.txt (In this case (.)
       current directory)
     + <BUILD> - Directory containing compilation output and the
       building scripts generated by CMake for some building
       systems. In this exaple: ./cache 
     + -G  <Build-Systems> -> [Optional] Specifies the building
       systems which CMake will generate the scripts for. On Linux,
       the default building system is Makefiles and on Windows it is
       MSBuild. 

#+BEGIN_SRC sh 
  # Generate => Building scripts for Makefile on ./cache directory 
  $ cmake -H. -Bcache 

  -- The C compiler identification is GNU 8.2.1
  -- The CXX compiler identification is GNU 8.2.1
  ... ...   ... ...   ... ...   ... ...   ... ... 
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/cmake-opengl/cache
#+END_SRC

Build the executable running the building script (Makefile) from CMake:

 + Note: It will build all CMake targets, all executables and libraries.

#+BEGIN_SRC sh 
  $ cmake --build cache

  /usr/bin/cmake -H/home/archbox/root-scripts/cmake-opengl -B/home/archbox/root-scripts/cmake-opengl/cache --check-build-system CMakeFiles/Makefile.cmake 0
  /usr/bin/cmake -E cmake_progress_start /home/archbox/root-scripts/cmake-opengl/cache/CMakeFiles /home/archbox/root-scripts/cmake-opengl/cache/CMakeFiles/progress.marks
   .. ...  .. ...  .. ...  .. ...  .. ...  .. ... 
  ir/build
  gmake[2]: Entering directory '/home/archbox/root-scripts/cmake-opengl/cache'
  [ 50%] Building CXX object CMakeFiles/openglDemo1.dir/opengl1.cpp.o
  /usr/lib64/ccache/c++    -std=gnu++1z -o CMakeFiles/openglDemo1.dir/opengl1.cpp.o -c /home/archbox/root-scripts/cmake-opengl/opengl1.cpp
  [100%] Linking CXX executable openglDemo1.bin
#+END_SRC

Build a single target:

#+BEGIN_SRC sh 
 $ cmake --build cache --target openglDemo1
#+END_SRC

Inspect executable: 

#+BEGIN_SRC sh 
  $ file cache/openglDemo1.bin 
   
   cache/openglDemo1.bin: ELF 64-bit LSB
   executable, x86-64, version 1 (SYSV), dynamically linked, interpreter
   /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0,
   BuildID[sha1]=269d06a0054677d70ecf0258268565535e3dfbd4, not stripped
#+END_SRC

Execute a custom target, for instance the custom target _run-ex1_ which runs
the executable (aking to $ make run).

#+BEGIN_SRC sh 
  $ cmake --build cache --target run-ex1

    ... ... .... 
  Scanning dependencies of target run-ex1
  gmake[3]: Leaving directory '/home/archbox/root-scripts/cmake-opengl/cache'
  /usr/bin/gmake -f CMakeFiles/run-ex1.dir/build.make CMakeFiles/run-ex1.dir/build
  gmake[3]: Entering directory '/home/archbox/root-scripts/cmake-opengl/cache'
  ./openglDemo1.bin
  [INFO] Starting OpenGL main loop.
  [INFO] Running loop.
  [INFO] Running loop.
#+END_SRC

4 Build with Ninja. 

 + The compilation can be faster and less verbose with Ninja-build
   building systems.

#+BEGIN_SRC sh 
  # Remove cache directory 
  rm -rf cache

  # Generate building scripts for Ninja building system in directory ./cache 
  $ cmake -H. -Bcache -G Ninja
  -- The C compiler identification is GNU 8.2.1
   ... .... ... .... ... .... ... ....
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/cmake-opengl/cache

  # Build a single target 
  $ cmake --build cache --target openglDemo1
  [2/2] Linking CXX executable openglDemo1.bin

  # Build all targets 
  $ cmake --build cache --target all
  ninja: no work to do.

  # Run target: run-ex1 (akin to $ make run)
  $ cmake --build cache --target run-ex1
  [0/1] cd /home/archbox/root-scripts/cm...pts/cmake-opengl/cache/openglDemo1.bin
#+END_SRC
 
5 Open project with IDE or editor that doesn't support CMake, for
instance: Code Blocks.

 + The following command generates a blocks project file
   (OpengGL_CPP.cbp) and a GNU make building (Makefile) script. Then,
   the project can be opened from Code Blocks by selecting the file
   OpenGL_CPP.cpb which is a CodeBlocks project file.

#+BEGIN_SRC 
  $ cmake -H. -Bcblock -G "CodeBlocks - Unix Makefiles"

  -- The C compiler identification is GNU 8.2.1
   ... ... ... ... ... ... .... 
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/cmake-opengl/cblock

  $ tree cblock -L 1
  cblock
  ├── CMakeCache.txt
  ├── CMakeFiles
  ├── cmake_install.cmake
  ├── Makefile
  └── OpengGL_CPP.cbp

  1 directory, 4 files
#+END_SRC

** Additional Target Configuration 

CMake can set up a compilation target in compiler-agnostic manner:

 + Executable target defintion => Builds a *.exe on Windows.

#+BEGIN_SRC cmake  
   add_executable(SampleApp main.cpp sourc1.cpp source2.cpp)
#+END_SRC

 + Compiler defintions.
   + It is the same as compiling with GCC with command line option
     -D{DEFINITION}={VALUE} or compiling with MSVC VC++ with the
     command line option /D{DEFINITION}={VALUE} which becomes #define
     {DEFINITION} {VALUE} in the code.
   + Docs: [[https://cmake.org/cmake/help/latest/command/target_compile_definitions.html][target_compile_definitions — CMake 3.13.2 Documentation]]

#+BEGIN_SRC cmake 
    target_compile_definitions(SampleApp PRIVATE  
       VERBOSITY=100  # Same as #define VERBOSITY 100 
       Optimize       # Same as -DOptimize or #define Optimize
       foo=bar 
      )
   # In a single line 
    target_compile_definitions(SampleApp PRIVATE VERBOSITY=100 Optimize foo=bar)
#+END_SRC

 + Additional include directories containing header files. Similar to
   command line option -I with GCC.
   + [[https://cmake.org/cmake/help/v3.0/command/target_include_directories.html][target_include_directories — CMake 3.0.2 Documentation]]

#+BEGIN_SRC cmake 
  # Similar to: g++ main.cpp src1.cpp ... -o app.bin -Isrc/include1 -I/home/user/include
  target_include_directories(SampleApp PUBLIC src/include1 /home/usr/include)
#+END_SRC


 + Libraries that the executable will link against.
   + It can be: shared libraries installed on the system or either
     shared or static libraries in the current project.

#+BEGIN_SRC cmake  
   # Project shared library SampleSharedLib.so (Linux, Unix) or 
   # SampleSharedLib.dll on Windows. 
   add_library(SampleSharedLib SHARED  lib1.cpp lib2.cpp lib3.cpp)

   # Project static library 
   add_library(StaticLibrary STATIC lib1.cpp lib2.cpp lib3.cpp)

   target_link_libraries(SampleApp  
           GL blas opencv  # System installed libraries 
           SampleSharedLib # Project shared library 
           StaticLibrary   # Project static library 
   )
#+END_SRC

  + Set target properties:

#+BEGIN_SRC cmake 
 set_target_properties(SampleApp PROPERTIES 
     {PROPERTY1} {VALUE1}
     {PROPERTY2} {VALUE2}
     ... .... ... ... 
     {PROPERTYN} {VALUEN}
  )
#+END_SRC

Add file extension .bin to Unix executable (note: on Unix-like OSes,
executables does not have extension like in Windows):

#+BEGIN_SRC cmake 
 if(UNIX)
    set_target_properties(SampleApp PROPERTIES SUFFIX ".bin")
  endif()
#+END_SRC

 *To avoid* 

 + Note: It should avoided CMake commands which affects all targets,
   for instance, include_directories(dir1 dir2 ...) will add those
   include directories to all targets regardless if they need them or
   not. It is better to use the command target_include_directories as
   it affects just a single target. The same said for the command
   link_directories(). 

** CMake Map 

 + Global configuration/settings 
   + add_definitions
   + set(<VARIABLE> <VALUE>)
   + add_subdirectory 

 + Target defintions
   + add_executable => Create target for building executable. 
   + add_library    => Create target for building static or shared library.
   + add_custom_target

 + Target Configuration:
   + set_target_properties(<TARGET> PROPERTIES <KEY> <VALUE> [<KEY <VALUE>] ...)
   + set_target_properties(testlib PROPERTIES CXX_VISIBILITY_PRESET hidden)
     + Make  symbols of shared or static library hidden by default,
       only explicitly annotated symbols are visible. It avoids name
       clashing which can lead to undefined behavior.

   + target_link_libraries(<executable-target> PUBLIC testlib)

 + Auxiliary targets:
   + install  => Install packages to some directoriy.

 + Find Commands:
   + find_path 
   + find_package
   + find_library
   + include_directory

 + Global Variables:
   + set(CMAKE_CXX_STANDARD 14)
   + set(CMAKE_VERBOSE_MAKEFILE ON)
   + set(CMAKE_BUILD_TYPE  debug)

Typical CMake Variables:

|--------------------------+----------------+-----------------------------------------------------------|
| Variable                 | Compiler flags | Description                                               |
|                          | affected       |                                                           |
|--------------------------+----------------+-----------------------------------------------------------|
| *Misc*                     |                |                                                           |
| PROJECT_NAME             | -              | Sets project name.                                        |
|                          |                |                                                           |
| *Compiler*                 |                |                                                           |
|                          |                |                                                           |
| CMAKE_CXX_STANDARD       | -std=c++11     | Set the C++ standard used for compoling all sources       |
| CMAKE_CXX_FLAGS          | -              | Additional compiler flags for all targets.                |
| CMAKE_BUILD_TYPE         |                | Set whether build type is release or debug                |
|                          |                |                                                           |
| *Location*                 |                |                                                           |
| CMAKE_BINARY_DIR         |                |                                                           |
| CMAKE_CURRENT_LIST_DIR   |                | Get location of current CMakeLists.txt file.              |
| CMAKE_INSTALL_PREFIX     |                | Location where targets will be installed (target _install_) |
| CMAKE_CURRENT_BINARY_DIR |                |                                                           |
|                          |                |                                                           |
|--------------------------+----------------+-----------------------------------------------------------|

Notes: 

 + The default value of the variable CMAKE_INSTALL_PREFIX are:
   + Windows:        C:/Program Files/${PROJECT_NAME}
   + Unix-like OS:   /usr/local
** Build a project from command line.

A project using Cmake as building system contains a build script at
top level directory named CMakeLists.txt. To build a project with
CMake, it is necessary to consider that CMake, is not a building
system and does not build anything. Actually, Cmake generates building
scripts for the platform preferred building scripts. For instance, on
Linux, it can generate Makefile, Eclipse Makefiles; on Windows it can
generate MSBuild scripts, NMake (Windows SDK's make) and so on.

 + Check all possible building system for which CMake can generate
   build scripts.
   + Command: $ *cmake -G*

#+BEGIN_SRC sh 
   # Running on Windows 10 
   $ cmake -G
   CMake Error: No generator specified for -G

   Generators
     Visual Studio 15 2017 [arch] = Generates Visual Studio 2017 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 14 2015 [arch] = Generates Visual Studio 2015 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 12 2013 [arch] = Generates Visual Studio 2013 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 11 2012 [arch] = Generates Visual Studio 2012 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 10 2010 [arch] = Generates Visual Studio 2010 project files.
                                    Optional [arch] can be "Win64" or "IA64".
     Visual Studio 9 2008 [arch]  = Generates Visual Studio 2008 project files.
                                    Optional [arch] can be "Win64" or "IA64".
     Borland Makefiles            = Generates Borland makefiles.
     NMake Makefiles              = Generates NMake makefiles.
     NMake Makefiles JOM          = Generates JOM makefiles.
     Green Hills MULTI            = Generates Green Hills MULTI files
                                    (experimental, work-in-progress).
     MSYS Makefiles               = Generates MSYS makefiles.
     MinGW Makefiles              = Generates a make file for use with
                                    mingw32-make.
     Unix Makefiles               = Generates standard UNIX makefiles.
     Ninja                        = Generates build.ninja files.
     Watcom WMake                 = Generates Watcom WMake makefiles.
     CodeBlocks - MinGW Makefiles = Generates CodeBlocks project files.
     CodeBlocks - NMake Makefiles = Generates CodeBlocks project files.
     CodeBlocks - NMake Makefiles JOM
                                  = Generates CodeBlocks project files.
     CodeBlocks - Ninja           = Generates CodeBlocks project files.
     CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files.
     CodeLite - MinGW Makefiles   = Generates CodeLite project files.
     CodeLite - NMake Makefiles   = Generates CodeLite project files.
     CodeLite - Ninja             = Generates CodeLite project files.
     CodeLite - Unix Makefiles    = Generates CodeLite project files.
     Sublime Text 2 - MinGW Makefiles
                                  = Generates Sublime Text 2 project files.
     Sublime Text 2 - NMake Makefiles
                                  = Generates Sublime Text 2 project files.
     Sublime Text 2 - Ninja       = Generates Sublime Text 2 project files.
     Sublime Text 2 - Unix Makefiles
                                  = Generates Sublime Text 2 project files.
     Kate - MinGW Makefiles       = Generates Kate project files.
     Kate - NMake Makefiles       = Generates Kate project files.
     Kate - Ninja                 = Generates Kate project files.
     Kate - Unix Makefiles        = Generates Kate project files.
     Eclipse CDT4 - NMake Makefiles
                                  = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - MinGW Makefiles
                                  = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - Ninja         = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files.
#+END_SRC

 *STEP 1: Generate Building Script*

Project directory listing:

#+BEGIN_SRC sh 
  $ tree .
  .
  ├── build.bat
  ├── client1.cpp
  ├── CMakeLists.txt
  ├── Makefile
  ├── pywrapper.py
  ├── testlib.cpp
  └── testlib.hpp
#+END_SRC

 *Generate building scripts for platform-preferred building system:*

 + $ cmake -H<SOURCE> -B<BUILD>
   + <SOURCE> => Source directory where all *.cpp, *.hpp code. In this
     case it is (.) dot, current directory. If the directory was
     ./src, the command would be -Hsrc or -H./src
   + <BUILD> => Compilation output, directory where are all building
     scripts. 

Command output on Windows 10 - MSVC 2017. Note: It will set VC++ for
32 bits target, not 64 bits.

#+BEGIN_SRC sh 
  $ cmake -H. -Bbuild
  -- Building for: Visual Studio 15 2017
  -- The C compiler identification is MSVC 19.16.27025.1
  -- The CXX compiler identification is MSVC 19.16.27025.1  
  ... ...   ... ...   ... ...   ... ...   ... ... 
  -- Configuring done
  -- Generating done
  -- Build files have been written to: C:/Users/archbox/Desktop/experiments/dll/build
#+END_SRC

Command output on Linux: 

#+BEGIN_SRC sh 
  $ cmake -H. -Bbuild
  -- The C compiler identification is GNU 8.2.1
  -- The CXX compiler identification is GNU 8.2.1
  -- Check for working C compiler: /usr/lib64/ccache/cc
  -- Check for working C compiler: /usr/lib64/ccache/cc -- works
  ... ...   ... ...   ... ...   ... ...   ... ... 
   [INFO] Libtest location is at: libtest_location-NOTFOUND
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/gist/build

  # List ./build directory 
  $ tree -L 1 build
  build
  ├── CMakeCache.txt
  ├── CMakeFiles
  ├── cmake_install.cmake
  └── Makefile

  1 directory, 3 files
#+END_SRC

  *Generate building script for specific building system:*

 + $ cmake -H<SOURCE> -B<BUILD> -G <BUILD-SYSTEM>
   + <SOURCE> => Source directory where all *.cpp, *.hpp code. In this
     case it is (.) dot, current directory. If the directory was
     ./src, the command would be -Hsrc or -H./src
   + <BUILD> => Compilation output, directory where are all building
     scripts.
   + <BUILD-SYSTEM> => All available build system can be listed with $ cmake -G.

#+BEGIN_SRC sh 
 # Generate MSbuild building scripts for 32 bits target 
  $ cmake -H. -Bbuild -G "Visual Studio 15 2017"

  # Generate MSbuild building scripts for 64 bits target 
  $ cmake -H. -Bbuild -G "Visual Studio 15 2017 Win64"
#+END_SRC

 *Generate building script with debug symbols enabled:*

It automatically adds the debugging flags (/Zi) for VC++ Microsoft
Visual C++ Compiler which necessary for debugging a program with GDB,
LLDB or WinDBG. 

 + Add the flag *-DCMAKE_BUILD_TYPE=DEBUG*

#+BEGIN_SRC sh 
  # Example 1:
  $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG

  # Example 2:
  $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=RELEASE

  # Example 3: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"

  # Example 4: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"

  # Example 5: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=RELEASE -G "Visual Studio 15 2017 Win64"
#+END_SRC


 *STEP 2: Compile the project invoking the generated building scripts*

Invoke the building scripts indirectly using CMake:

 + $ cmake --build <BUILD>
   + <BUILD> Is the build directory generated at step 1. 

#+BEGIN_SRC sh 
  $ cmake --build build
  # OR
  $ cmake --build build --config Debug 
  # OR
  $ cmake --build build --config Release
#+END_SRC

Invoke the building script directly, call the building tool:
 + This building method depends on the current building system.

For MSBuild, the compilation becomes:

#+BEGIN_SRC sh
  $ MSBuild build\testlib.vcxproj

  Microsoft (R) Build Engine version 15.5.180.51428 for .NET Framework
  Copyright (C) Microsoft Corporation. All rights reserved.

  Build started 12/21/2018 12:49:38 PM.
  Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" on node 1 (default targets).
  Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" (1) is building "C:\Users\archbox\ Desktop\experiments\dll\build\ZERO_CHECK.vcxproj" (2) on node 1 (default targets).
  ... ... ... ... ... ... ... ... ... ... ... ... ... ... 
  testlib.vcxproj -> C:\Users\archbox\Desktop\experiments\dll\build\Debug\testlib.dll
  FinalizeBuildStatus:
    Deleting file "testlib.dir\Debug\testlib.tlog\unsuccessfulbuild".
    Touching "testlib.dir\Debug\testlib.tlog\testlib.lastbuildstate".
  Done Building Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" (default targets).
#+END_SRC

For Linux or Unix GNU-Make, the compilation becomes:

#+BEGIN_SRC sh 
   $ cd build

   $ make
   /usr/bin/cmake -H/home/archbox/root-scripts/gist -B/home/archbox/root-scripts/gist/build --check-build-system CMakeFiles/Makefile.cmake 0
   /usr/bin/cmake -E cmake_progress_start /home/archbox/root-scripts/gist/build/CMakeFiles /home/archbox/root-scripts/gist/build/CMakeFiles/progress.marks
   make -f CMakeFiles/Makefile2 all
   make[1]: Entering directory '/home/archbox/root-scripts/gist/build'
   make -f CMakeFiles/testlib.dir/build.make CMakeFiles/testlib.dir/depend
   make[2]: Entering directory '/home/archbox/root-scripts/gist/build'
   ... ... ... ... ... ... ... ... ... ... ... ... 
   [100%] Built target client1-executable
   make[1]: Leaving directory '/home/archbox/root-scripts/gist/build'
   /usr/bin/cmake -E cmake_progress_start /home/archbox/root-scripts/gist/build/CMakeFiles 0  


  # Built executables: 
  #--------------------------------
  $ file libtestlib.so 
  libtestlib.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically 
  linked, BuildID[sha1]=ce79ed7580a16cbc27bf113a2967eb1d66f496a3, not stripped

  $ file client1-executable.bin 
  client1-executable.bin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
  for GNU/Linux 3.2.0, BuildID[sha1]=8103d822a6d58497b63346dfcc1f7375599114f7, not stripped
#+END_SRC

Or just in a single step: 

#+BEGIN_SRC sh 
  $ cd build && make && cd ..
#+END_SRC

** Show system information 

#+BEGIN_SRC sh  
  cmake --sytem-information 
#+END_SRC 

Output on Linux: 

#+BEGIN_SRC sh 
   Avoid ctest truncation of output: CTEST_FULL_OUTPUT
   ========================================================
   === MAIN VARIABLES
   ========================================================
   CMAKE_STATIC_LIBRARY_PREFIX == "lib"
   CMAKE_STATIC_LIBRARY_SUFFIX == ".a"
   CMAKE_SHARED_LIBRARY_PREFIX == "lib"
   CMAKE_SHARED_LIBRARY_SUFFIX == ".so"
   CMAKE_SHARED_MODULE_PREFIX == "lib"
   CMAKE_SHARED_MODULE_SUFFIX == ".so"


   CMAKE_DL_LIBS == "dl"
   CMAKE_LIBRARY_PATH_FLAG == "-L"
   CMAKE_LINK_LIBRARY_FLAG == "-l"
   CMAKE_SKIP_RPATH == "NO"
   CMAKE_SYSTEM_INFO_FILE == "Platform/Linux"
   CMAKE_SYSTEM_NAME == "Linux"
   CMAKE_SYSTEM == "Linux-4.18.18-200.fc28.x86_64"
   CMAKE_CXX_COMPILER == "/usr/lib64/ccache/c++"
   CMAKE_C_COMPILER == "/usr/lib64/ccache/cc"
   CMAKE_COMPILER_IS_GNUCC == "1"
   CMAKE_COMPILER_IS_GNUCXX == "1"

   // C shared library flag
   CMAKE_SHARED_LIBRARY_C_FLAGS == "-fPIC"
   CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS == "-shared"
   CMAKE_SHARED_LIBRARY_LINK_FLAGS == ""
   ... ...    ... ...    ... ...    ... ...    ... ... 
#+END_SRC

** Show all modules 

#+BEGIN_SRC sh 
  $ cmake --help-module-list
#+END_SRC

Output: 

#+BEGIN_SRC text 
  AddFileDependencies
  AndroidTestUtilities
  BundleUtilities
  CMakeAddFortranSubdirectory
  CMakeBackwardCompatibilityCXX
  CMakeDependentOption
  CMakeDetermineVSServicePack
  CMakeExpandImportedTargets
  CMakeFindDependencyMacro
  CMakeFindFrameworks
  CMakeFindPackageMode
  CMakeForceCompiler
  CMakeGraphVizOptions

  ... ... ... ... ... ... 

  FindLAPACK
  FindLATEX
  FindLTTngUST
  FindLibArchive
  FindLibLZMA
  FindLibXml2
  FindLibXslt
  FindLua
  FindLua50
  FindLua51
  FindMFC
  FindMPEG
  FindMPEG2
  FindMPI
  FindMatlab
  FindMotif
  FindOpenACC

  ... ... ... ... ... ... ... ... 

#+END_SRC
** SNIPPET - Common Variables 
*** CMAKE_CURRENT_LIST_DIR - Directory where is CMakeLists.txt 

Prints the directory where CMAkeLists.

#+BEGIN_SRC cmake 
  message(" [INFO] CMakeLists.txt is in the directory ${CMAKE_CURRENT_LIST_DIR}")
#+END_SRC

*** CMAKE_CXX_STANDARD - Set C++ Standard

The variable ~CMAKE_CXX_STANDARD~ sets the project current C++
standard. This variable can be set to 98 (for C++98); 11 (C++11); 14
(C++14); 17 (C++17) and 20 (C++20 - experimental yet.)

 + Documentation: [[https://cmake.org/cmake/help/latest/prop_tgt/CXX_STANDARD.html#prop_tgt:CXX_STANDARD][CXX_STANDARD — CMake 3.13.2 Documentation]] 

Example: Set project to compile with C++11 ISO standard.

#+BEGIN_SRC cmake 
  set(CMAKE_CXX_STANDARD 11)
#+END_SRC

Usage: (File CMAKELists.txt)

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(MY_PROJECT_NAME)

  set(CMAKE_CXX_STANDARD 17)
  ... ... .... .... 
#+END_SRC

*** CMAKE_BUILD_TYPE - Set default building type to DEBUG 

In the debug building type optimization flags are disabled and flags
for generating debugging symbols are enabled, for GGC or GCC/Mingw and
Clang the (-g) is automatically added and for MSVC, aka VC++ (cl.exe),
the flag /Zi is also passed to the compiler. The default building type
can be set to DEBUG with the following code.

#+BEGIN_SRC cmake 
  # Set default building type to debug if it was not set
  # in command line with -DCMAKE_BUILD_TYPE=release
  if(NOT DEFINED CMAKE_BUILD_TYPE OR CMAKE_BUILD_TYPE MATCHES "")
    set(CMAKE_BUILD_TYPE  debug)
  endif()
#+END_SRC

The building type can be changed by running cmake with the flag
 (-DCMAKE_BUILD_TYPE=release). Example: 

#+BEGIN_SRC sh 
 $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"
#+END_SRC

Note: CMake is not case sensitive, so it does not matter using
'release' or RELEASE; if or IF; endif or ENDIF and so on. 

*** CMAKE_CXX_FLAGS - Compiler flags 

The globals compiler flags used to build all targets can be extended
by setting the variable CMAKE_CXX_FLAGS. However, as the compiler
flags depends on the compiler, the custom settings may not be portable
if one uses a different compiler, for instance the (-g) flag used to
generate debug symbols with GCC or Clang does not work with MSVC
(visual c++ compiler, vc++) as it uses the flag /Zi for generating
debugging symbols.

Example 1: 

#+BEGIN_SRC cmake
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}"  "-std=c++17 -g -Wall -Wextra -pendantic -O0" )
#+END_SRC

Example 2 (better):

#+BEGIN_SRC cmake
  if(NOT MSVC)
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}"  "-std=c++17 -g -Wall -Wextra -pendantic -O0" )
  endif()
#+END_SRC
** SNIPPET - Detect Operating System 

Check whether current OS is Microsft Windows NT:

#+BEGIN_SRC cmake
  if(WIN32)
    # actions ... 
    message("Compiling for Windows NT")
  else()
    # else actions .... ...
  endif()
#+END_SRC

Check whether current OS is a Unix-like operating system (Linux, BSD,
MacOSX, Android and so on): 

#+BEGIN_SRC cmake 
  if(UNIX)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC

Check if current OS is MacOSX:

#+BEGIN_SRC cmake 
  if(APPLE)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC

Check if current OS is Linux:

#+BEGIN_SRC cmake 
  if(LINUX)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC

Check if current OS is UNIX, but not MacOSX:

#+BEGIN_SRC cmake
  if(UNIX AND NOT APPLE)
    # actions ... 
    message("Running on Unix-like OS")
  endif()  
#+END_SRC

** SNIPPET - Detect Compiler 

 *MSVC*

Check if current compiler is MSVC - Microsft - Visual C/C++ Compiler
(Visual C++, vc++ for short):

#+BEGIN_SRC cmake 
  if(MSVC)
    message(STATUS << "Running MSVC")
  endif()
#+END_SRC

 *MSVC for 32 bits target*

Detect MSVC set up for 32 bits target (buids 32 bits binaries):

#+BEGIN_SRC cmake 
  if(MSVC AND NOT CMAKE_CL_64)
    message(" [INFO] Building for 32 bits Windows target.")
  endif()
#+END_SRC

 *MSVC for 64 bits target*

#+BEGIN_SRC cmake 
  if(MSVC AND CMAKE_CL_64)
    message(" [INFO] Building for 64 bits Windows target.")
  endif()
#+END_SRC

 *Mingw* 

Check if current compiler is GCC/Mingw, GCC compiler ported to
Windows.

#+BEGIN_SRC cmake
  if(MSVC)
    message("Running Mingw/GCC maybe on Windows")
  endif()
#+END_SRC

** SNIPPET - Detect whether current build is 32 bits or 64 bits

Check whether current configuration is for 64 bits build:

#+BEGIN_SRC cmake 
  if(CMAKE_SIZEOF_VOID_P EQUAL 8)
      message(" [INFO] 64 bits build.")
  else()
     message(" [INFO] 32 bits build.")
  endif()
#+END_SRC

** SNIPPET - Copy some target binaries to a directory

This piece of code copies the target binaries (compiled code) to a
directory relative to project's root directory where is CMakeLists.txt 

Targets:

#+BEGIN_SRC cmake 
  # TARGET: testlib Shared library => Builds liblinalg.so on Unix or
  # linalg.dll on Windows.
  add_library(linalg SHARED  src/testlib.cpp)

  # TARGET: app Executable => Builds 'app' on Unix-like Oses and
  # unix.exe on Windows.
  add_executable(app src/main/main-app.cpp src/main/file1.cpp src/main/file2.cpp)
#+END_SRC

Copy target files to top level directory where is CMakeLists.txt 

#+BEGIN_SRC cmake
  # If not set the install directory, attemp set the install directory
  # CMAKE_INSTALL_PREFIX to the directory ./bin 
  if(NOT DEFINED CMAKE_INSTALL_PREFIX OR CMAKE_INSTALL_PREFIX MATCHES "")
    set(CMAKE_INSTALL_PREFIX  "./bin")
  endif()

  message(" [INFO] CMakeLists.txt is in the directory ${CMAKE_CURRENT_LIST_DIR}")

  # Copy targets to ./ - Directory where is this file CMakeLists.txt (project top level dir)
  install(TARGETS app linalg DESTINATION  ${CMAKE_CURRENT_LIST_DIR})
#+END_SRC

This target can be run with: 

 + STEP 1: Set CMake building system or the project type with -G.

#+BEGIN_SRC sh 
 $ cd project-directory 

 #===> Set build system 
 # -H<SOURCE> -B<COMPILATION-OUTPUT> -G <BUILDING-SYSTEM>
 $ cmake -H. -G "Unix Makefiles" -Bbuild 
#+END_SRC
 
 + STEP 2: Run targets 

#+BEGIN_SRC sh 
 #===> Run all targets [all default.]
 $ cmake --build build --target all 

 #===> Run target install and copy the binaries to ./bin 
 $ cmake --build build --target install 
#+END_SRC



** SNIPPET - Create target to run compiled executable 

The piece following piece of code runs an executable target after it
is built in a similar way to a command $ make run. 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)

   ... ...  ... ...  ... ...

  # TARGET: myapplication 
  add_executable(myapplication src/main.cpp src/code1.cpp code2.cpp ...)

  # TARGET: run -> Runs the executable myapplication 
  # On Unix-like Oses, it runs  /<build-directory>/myapplication 
  # On Windows: it runs  <build-directory>/myapplication.exe 
  add_custom_target(run
      COMMAND myapplication
      DEPENDS myapplication
      WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
  )
#+END_SRC

After the building system is set and output directory ./build, run:

#+BEGIN_SRC sh 
   #===> Run all targets [all default.]
   $ cmake --build build --target run
#+END_SRC



** SNIPPET - Issue an error if condition is not met 

In this piece of code, if the compiler is not MSVC (vc++, aka cl.exe),
CMake stops the generation of the building script showing an error
message to the user.

#+BEGIN_SRC cmake 
  ... ... 

  if(MSVC)
     set_target_properties(WindowApp1 PROPERTIES LINK_FLAGS "/entry:mainCRTStartup")
  else() 
     message(FATAL_ERROR " [ERROR] Linker flags of target WindowApp1 not set for this compiler")
  endif()
  ... ... 
#+END_SRC
** SNIPPET - Set target subsystem: console/window - Win32 API Specific

Set target subsystem. 

#+BEGIN_SRC cmake 
  if(WIN32)
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_DEBUG "/SUBSYSTEM:CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES COMPILE_DEFINITIONS_DEBUG "_CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_RELWITHDEBINFO "/SUBSYSTEM:CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES COMPILE_DEFINITIONS_RELWITHDEBINFO "_CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_RELEASE "/SUBSYSTEM:WINDOWS")
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_MINSIZEREL "/SUBSYSTEM:WINDOWS")
  endif(WIN32)
#+END_SRC

Taken from: 
 + [[https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/recipe/VSConfigSpecificSettings][Vsconfigspecificsettings · Wiki · CMake / Community · GitLab]]
 + [[https://developercommunity.visualstudio.com/content/problem/46678/cmake-set-subsystem-to-console.html][cmake: Set subsystem to console - Developer Community]]
 + [[https://stackoverflow.com/questions/33873735/correctly-set-visual-studio-linker-flag-subsystem-in-cmake][c++ - Correctly set Visual Studio linker flag /SUBSYSTEM in CMAKE - Stack Overflow]]
** SNIPPET - Copy a target file whenever it is recompiled

Example:  Copy a shared library to project root directory ./
whenever it is rebuilt. 

 + Set the shared library target. (libtestlib.so on Unix or testlib.dll
   on Windows)

#+BEGIN_SRC cmake 
  add_library( testlib  SHARED  ./testlib.cpp)
  set_target_properties(testlib PROPERTIES CXX_VISIBILITY_PRESET hidden)
#+END_SRC

 + Automatically copy to root directory the generated shared library
   binary to root directory on every recompilation of the target
   testlib. 

#+BEGIN_SRC cmake
  add_custom_command(TARGET testlib POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy 
    $<TARGET_FILE:testlib>                     # Source    
    ${CMAKE_CURRENT_SOURCE_DIR}/libtest.so     # Destination, file or directory 
    # OR: ${CMAKE_CURRENT_SOURCE_DIR}/         # Directory destination. 
  )
#+END_SRC

Test this post-build target: 

#+BEGIN_SRC sh 
  # Generate cache directory containing building scripts or project files 
  # specifics for some building systems
  $ cmake -H. -Bcache -G "CHOOSE SYSTEM>"

  # Run all targets  [Default]
  $ cmake --build cache --target
  $ cmake --build cache --target all 

  # Run target 'testlib'. 
  $ cmake --build cache --target testlib 
#+END_SRC

After the target is recompiled, the shared library is copied to the
current directory (project top-level directory ./).

References: 
 + https://stackoverflow.com/questions/31277186
 + https://stackoverflow.com/questions/15694347/
