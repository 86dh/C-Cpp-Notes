#+INCLUDE: theme/style.org 
#+TITLE: CPP / C++ - Building Systems and Build Automation 
#+DESCRIPTION: cpp/c++ code examples and demonstrations.
#+STARTUP: content 

- [[wiki:index][Index]]

* Building Systems and Build Automation 
** Building System 

  + [[https://cmake.org/][CMake]] (*De-facto standard*) Meta building system which can generate
    project files and building scripts for platform-preferred building
    systems. For instance, it can generate Makefile for U*nix-like
    system, Ninja build scripts, Visual Studio solutions and so on.
    + Note: CMake is being used by many projects and supported by many
      IDEs. Now, it is supported by Microsft's Visual Studio and
      JetBrains' Clion IDE and others.
    + See:
      + [[http://cliutils.gitlab.io/modern-cmake/][An Introduction to Modern CMake]]
      + [[https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1][Effective Modern CMake]]
      + https://github.com/ttroy50/cmake-examples
      + [[https://cristianadam.eu/20181202/a-better-qnx-cmake-toolchain-file/][A Better QNX CMake Toolchain File - Cristian Adam]]

  + [[https://build2.org/][build2]] - "build2 is an open source (MIT), cross-platform build
    toolchain for developing and packaging C++ code. It is a hierarchy
    of tools that includes the build system, package dependency manager
    (for package consumption), and project dependency manager (for
    project development)."
    + See: [[https://news.ycombinator.com/item?id=17188851][Build2, a Cargo-like dependency and build manager for C/C++ | Hacker News]]

  + [[https://xmake.io][xmake]] -  "xmake is a cross-platform build utility based on lua. The
    project focuses on making development and building easier and
    provides many features (.e.g package, install, plugin, macro,
    action, option, task ...), so that any developer can quickly pick
    it up and enjoy the productivity boost when developing and building
    project. "
    + Github: https://github.com/tboox/xmake
    + Advatange:
      + Lua-like syntax
      + Less verbose than CMake
      + Run lua scripts
      + Generation of projects, for instance Visual studio solutions.    

  + *Make* (GNU Make, BSD Make and NMake) - Simple and quick building
    system more used on U*nix-like operating systems.

** Package Managers

 *Package Managers*
 
There are several solutions for managing dependencies in C++ projects,
however they are still no widely used or integrated to IDEs and
building systems. A reasonable set of features for selecting a package
manager is CMake support, CMake integration, IDE integration, command
line interface and distributed repositories. Some of them are:

 + [[https://www.conan.io/][Conan]] [Most mature], [BEST] - Dependency manager written in Python which
   can install source packages from multiple repositories, including
   local network and current machine package cache of pre-compiled
   object code.
   + Creator: Diego Rodriguez Losada
   + CMake Support: YES
   + Implementation Issues: As Conan is written in Python, it requires
     a Python installation. 
   + Package authoring: Packages configuration are written in Python.
   + See:
     + [[https://blog.conan.io/2017/05/11/C-C++-Binary-Package-Management-for-Visual-Studio.html][C/C++ Binary Package Management for Visual Studio]]
   + Video:
     + [[https://www.youtube.com/watch?v=xvqH_ck-5Q8][CppCon 2016: Diego Rodriguez-Losada "Conan, a C and C++ package manager for developers"]]
     + Humor, funny: [[https://www.youtube.com/watch?v=nLdB1ErncBg][CppCon 2016: Diego Rodriguez-Losada "Why not Conan?"]]
     + [[https://www.youtube.com/watch?v=CCKiKGn-ew8][Diego Rodriguez-Losada: Conan C++ package manager]]

 + [[https://docs.microsoft.com/en-us/cpp/vcpkg?view=vs-2017][vcpkg]] [Most mature], [BEST] - open source cross-platform C++ package
   manager created by Microsft Inc.
   + Creator: Microsft Inc. MSFT
   + CMake Support: YES
   + Documentation: https://vcpkg.readthedocs.io/en/latest/
   + Repository: https://github.com/Microsoft/vcpkg
   + FAQ: [[https://github.com/Microsoft/vcpkg/blob/master/docs/about/faq.md][VCpkg FAQ]]
   + See:
     + [[https://blog.kitware.com/vcpkg-a-tool-to-build-open-source-libraries-on-windows/][Vcpkg: A tool to build open source libraries on Window]]
     + Video: Microsft - [[https://www.youtube.com/watch?v=zo6nqFVBd5o][Vcpkg a tool to build open source C++ libraries]]
     + Video: Microsft - [[https://channel9.msdn.com/Shows/C9-GoingNative/GoingNative-54-Whats-New-In-Visual-Studio-2017-RC-and-Introduction-To-Vcpkg][GoingNative 54: What's New In Visual Studio 2017 RC and Introduction To Vcpkg]]
     + Video: [[https://www.youtube.com/watch?v=KOeOLOu6nHw][C++ Weekly - Ep 118 - Trying Out The vcpkg Package Manager]]

 + [[http://www.buckaroo.pm/][Buckaroo]] - "A C++ package manager that will take you to your happy place"
   + Creator: LoopPerfect Limited LTD.
   + CMake Support: Backaroo uses Buck build system as its default
     building system, although there is still some limited support to
     CMake. More info. at [[https://github.com/LoopPerfect/buckaroo/wiki/Building-CMake-Projects][Buildign CMake projects]]
   + Repository: https://github.com/LoopPerfect/buckaroo
   + Documentation: https://github.com/LoopPerfect/buckaroo/wiki/
   + Buckaroo-recipes: https://github.com/LoopPerfect/buckaroo-recipes/tree/master/recipes

 + [[https://www.qpm.io/][QPM]] - Pcakge manager for QT.
   + Repository: https://github.com/Cutehacks/qpm
   + CMake Support: ???
   + Package listing: https://www.qpm.io/packages/index.html

 + [[https://github.com/pfultz2/cget][cget]] - "Cmake package retrieval. This can be used to download and
   install cmake packages." Decentralized: Packages can be installed
   from anywhere, from github, urls, or local files. NOTE: It is not a
   package manager.
   + Creator: Paul Fultz
   + CMake Support: YES 
   + Repository: https://github.com/pfultz2/cget

 + [[https://github.com/ruslo/hunter][Hunter]] - Cross-platform package manager for C/C++ fully integrated
   to CMake, it does not need any external configuration file or run
   any application before editing the project or running cmake from
   command line. All the libraries to be installed are set in the
   file CMakeFiles.txt. If they are not available in the system, they
   are automatically downloaded and installed.
   + Creator: Ruslan Baratov
   + CMake Support: YES
   + Documentation: https://docs.hunter.sh
   + Package list: https://docs.hunter.sh/en/latest/packages.html
   + Note: It is still under development, but it seems promising.

 + [[https://cppan.org/][Cppan]] - "CPPPAN is the crossplatform C/C++ dependency manager. It
   is built on top of CMake and also has build system capabilities."
   + Creator: Egor Pugin
   + CMake Support: ???
   + Repository: https://github.com/cppan/cppan
   + Documentation: https://github.com/cppan/cppan/tree/v1/doc

 + [[https://build2.org/][Build2]] - "build2 is an open source (MIT), cross-platform build
   toolchain for developing and packaging C++ code. It is a hierarchy
   of tools that includes the build system, package dependency manager
   (for package consumption), and project dependency manager (for
   project development)."
   + Creator: [[https://codesynthesis.com/][Code Synthesis LTDA]], Boris Kolpackov
   + CMake Support: NO 
   + Package listing: https://cppget.org/
   + Possible shortcoming: No integration with CMake building-system
     and no integration to IDEs like CMake.
   + See:
     + Video: [[https://www.youtube.com/watch?v=Nni2Qu2WitY&feature=youtu.be][CppCon 2018: "C++ Dependency Management: from Package Consumption to Project Development"]]

 + [[https://github.com/iauns/cpm][CPM]] - [NO LONGER MAINTENED] "A C++ Package Manager based on CMake and Git."

 + [[https://spack.io/][Spack]] - "Spack is a package manager for supercomputers, Linux, and
   macOS. It makes installing scientific software easy. With Spack,
   you can build a package with multiple versions, configurations,
   platforms, and compilers, and all of these builds can coexist on
   the same machine."
   + Repository: https://github.com/spack/spack

 + [[https://blogs.msdn.microsoft.com/vcblog/2013/04/26/nuget-for-c/][Nuget]] - A pacakge manager used in Visual Studio for C#, VB.NET,
   Javascript and C++.
   + Creator: Microsft Inc. MSFT
   + CMake Support: NO 
   + Problem: It seems to work only on Windows and Visual Studio.
   + See: 
     + https://blog.nuget.org/20130426/native-support.html
     + Video: [[https://www.youtube.com/watch?v=FIY4FZDIt8Q][Consuming Native NuGet Packages in Visual Studio]]
     + https://blog.scalyr.com/2018/07/getting-started-quickly-c-logging/
     + [[https://www.microsofttranslator.com/bv.aspx?from=&to=en&a=https://qiita.com/nia_tn1012/items/77c3c1b006f7c69d30ac][Let's use Nuget in C++ project]] (Translated from Japanese with Bing Translator.)


 *Considerations for package manager choice*

 + The most mature package managers with CMake integration are Conan
   and Vcpkg. Vcpkg has the largest number of packages available.
   However, it is not possible to install multiple versions of the
   same package or host a local package repository.

 + Conan is more documented and provides more control over package
   versions. It has descentralized repositories and also allows users to
   host local or intranet private repositories. A minor problem
   of Conan is the Python installation requirement, but this issue
   could be quickly solved by turning Conan into a single native
   executable file by packing Conan Python module with the Python
   interpreter with tools like Py2Exe for Windows. 

Comparative table:

|-----------------------------------+--------+--------|
| Feature                           | Conan  | Vcpkg  |
|-----------------------------------+--------+--------|
| Standalone                        | NO     | YES    |
| Decentralized repositories        | YES    | NO     |
| Local Repository                  | YES    | NO     |
| Multiple versions of same package | YES    | NO     |
| Integration with IDEs             | NO     | NO     |
| Most Simple                       | -      | Winner |
| More packages                     | -      | Winner |
| User control                      | Winner | -      |
|-----------------------------------+--------+--------|
| Overall                           | Winner | -      |
|-----------------------------------+--------+--------|

 *Some reasonable set of features for a package managers*

 + CMake integration
 + Default repository, descentralized and local repositories.
 + Cross platform
 + Easier to use from CMake without needing to call any external
   command, the packages to be installed should be defined in the
   CMakeLists.txt file.
 + Command line tools
 + Browse package metadata from command line or IDE like .net's Nuget
   or Python's pip.
 + Integration with IDEs
 + Standalone no depending on any interpreter or
   external dependency or fully packed with the interpreter making
   easier to install and deploy.

 *Low tech approaches for package or dependency management*

 + GIT Submodules

 + Use system-specific package manager for instance: Ubuntu: apt-get;
   Fedora Linux: dnf; BSD Ports: ...
   + Disadvantage: Hard to reproduce compilation across different
     machines as most Linux distributions only provide a single
     version and may not have all necessary libraries and header-only
     libraries.

 + Add libraries manually

 + Install packages manually in the systems:
   + ./configure && make && make install

 + Copy header-only libraries to project-directory


 *Interesting discussions:*

 + Reddit /r/cpp [[https://www.reddit.com/r/cpp/comments/3d1vjq/is_there_a_c_package_manager_if_not_how_do_you/][Is there a C++ package manager? If not, how do you handle dependencies?]]
 + Reddit /r/cpp - [[https://www.reddit.com/r/cpp/comments/5v10r1/downsides_to_conanio/][Downsides to Conan.io?]]
 + Reddit /r/cpp - [[https://www.reddit.com/r/cpp/comments/40cfbk/hunter_crossplatform_package_manager_for_c/][Hunter - Cross-platform package manager for C++]]
 + [[https://news.ycombinator.com/item?id=16915195][Announcing a single C++ library manager for Linux, macOS and Windows: Vcpkg]]

* CMake - Reference Card
** Overview 

 *Motivation* 
 
  + _Easier cross-platform compilation and portability_
    + A single CMake building-script to rule all building systems.

  + _No reliance on a single IDE or building system_
    + CMake can generate projects and building scripts for many IDEs
      and also several IDEs are providing support for CMake without
      requiring generating a project to the IDE.

  + _Human-readable project file with a declarative language_
    + The project file is just a CMakeLists.txt human-readable text
      with a simple and declarative language, not an obfuscated or
      cryptic XML file, a verbose and fragile Json or a non-portable
      Makefile or Visual Studio Solutions.

  + _All configuration managed by code rather than GUI and XML_
    + Almost all configuration of a CMake project are managed by CMake
      language code, rather than by GUIs graphical user interfaces
      like Visual Studio Projects with MSBUild. This approach allows
      more customization, scalability and also faster changes. Another
      benefits are the portability among IDEs with CMake support. This
      text-centric approach also frees users from learning IDE
      specific details or configuration GUIs. 

  + _Network effect (Network Externality)_
    + Network effect can be described as phenomenon where additional
      users increases the value of products and services to all
      users.
    + Many C++ libraries are being distributed with CMake; many open
      source projects are adopting CMake; most C++ package managers
      support CMake and IDEs are starting to provide CMake support.


 *CMake can be used in following ways:*

 + _Build a software directly from command line_ in a similar way to
   Unix's make - $ make and $ make install.

 + _Generate IDE-specific or preferred project files_ in IDEs that does
   not supports CMake, for instance cmake can generate projects from
   the file CMakeLists.txt for the IDEs and text editors: Microsoft
   Visual Studio, CodeBlocks, Kate projects, Sublime and Eclipse CDT.

 + _Manage a project in IDEs which supports CMake_. In this case, it is
   not necessary to generate IDE-specific project files.


 *IDE Supporting Cmake for managing and building projects:*

 + Microsft - [[https://blogs.msdn.microsoft.com/vcblog/2016/10/05/cmake-support-in-visual-studio/][Visual Studio]] 
 + JetBrains - [[https://www.youtube.com/watch?v=Rbb0fVCz41w][Clion IDE]] 
 + QTCreator 
 + [[https://www.kdevelop.org/][KDevelop IDE]] 
   + Note: KDevelop allows managing project with CMake, visualization
     of all CMake targets, run individual targets with mouse click,
     run install target and so on.
   + Note: On Windows, it doesn't support Visual Studio / MSVC
     projects with MSVC (VC++) "visual" C++ compiler.

 *Supported Programming Languages*

 + ASM - Assembly
 + C
 + C++
 + Fortran
 + CSharp C#
 + CUDA
 + CXX 
 + Java
 + RC - Windows Resource Compiler
 + Swift 

 *Capabilities:*

 + Generate IDE-specific project files.
 + Generate Visual Studio Solutions (projects)
 + Generate Makefiles (GNU Make) or NMake (Windows make) for direct
   compilation.
 + Run targets like GNU make
 + Build a software or library directly from command line.

 *Possibilities* 

A CMake project can contain one or more target (taks), similar to
Makefile rules:

 + Multiples targets for build executables - the same CMake file can
   be used to build multiple applications.

 + Target to build shared library

 + Target to build static library

 + Target to install aplications or libraries

 + Custom targets

 *CMake Project Examples*

  + [[https://github.com/caiorss/winapi-snippets-cmake][winapi snippets]]
    + Code snippets and examples for Windows API in modern C++ managed
      by CMake.
  + [[https://gist.github.com/caiorss/2bba4c50866d9467aaa8c7792b337f71][shared library]]
    + Example containibng: Cross platform shared library exporting
      functions, classes, polymorphic classes and C-interfaces
      (wrapper functions with C-linkage). It also contains a C++
      client-code and Python wrapper which uses Python ctype FFI
      foreign function interface.
  + [[https://github.com/caiorss/example-pybind11-vcpkg][example-pybind11-vcpkg]]
    + This example project contains a Python3 native module written in
      C++ with the help of CMake and Pybind11, vcpkg (C++) Package
      manager. 

** Useful CMake Modules 

 * *Cotire* [BEST]
   * CMake module for speeding compilation by automating the usage of
     pre-compiled headers in a non-intrusive way that requires few
     modifications in the source code.
   * Note: The process of using pre-compiled headers is usually
     cumbersome and compiler-specific. This CMake module (script)
     automates this configuration.
   * Repository: https://github.com/sakra/cotire

 * *cmake-precompile-headers*
   * Precompiled header setup for CMake. Supported CMake generators:
     Visual Studio; NMake Makefiles; Unix Makefiles (GCC); MinGW
     Makefiles; MSYS Makefiles and Ninja.
   * https://github.com/larsch/cmake-precompiled-header

 * *UCM*
   * Useful cmake macros that help with: compiler/linker flags,
     collecting sources, PCHs, Unity builds and other stuff.  
   * Repository: https://github.com/onqtam/ucm

 * *Dockcross* 
   * Cross compiling toolchains in Docker images
   * Repository: https://github.com/dockcross/dockcross

 * *clang-tidy-project-cmake*
   + Add clang-tidy checks to a target usingCMake 
   + Repository: https://github.com/polysquare/clang-tidy-target-cmake

 * *FindLAPACK*
   * CMake FindLAPACK.cmake that works with Intel MKL, Atlas, OpenBLAS, Netlib, LAPACK95 for C / C++ / Fortran
   * Repository: https://github.com/scivision/lapack-cmake

 * *android-cmake*
   * "CMake is great, and so is Android. This is a collection of CMake
     scripts that may be useful to the Android NDK community. It is
     based on experience from porting OpenCV library to Android:
     http://opencv.org/platforms/android.html Main goal is to share
     these scripts so that devs that use CMake as their build system
     may easily compile native code for Android."
   * Repository: https://github.com/taka-no-me/android-cmake

 * *cmake-avr*
   * cmake-avr - a cmake toolchain for AVR projects
   * https://github.com/mkleemann/cmake-avr

 * *arduino-cmake*
   * Arduino CMake Build system
   * https://github.com/francoiscampbell/arduino-cmake

 * *Hunder Package Manager* - A CMake module (aka script) that works as
   package manager. 
   + Repository: https://github.com/ruslo/hunter

** Minimal CMake Project Workflow

This section contains a minimal CMake project that generates a single
executable which uses OpenGL libraries. All sources at: [[https://gist.github.com/caiorss/fd9e61887e9b2575f2275a80af44fac2][gist]]

A CMake project contains at least the file CMakeLists.txt (Cmake
building definitions akin to Makefile) and one or more sources -
files: *.c, *.cpp, *.cxx, *.hpp. 

Workflow:

 + Build and install the application or library directly from command
   line.

 + Generate IDE-specific building scripts if the IDE does not support
   opening CMake projects. Example: CMake can generate Makefiles for
   EClipse CDT or Visual Studio solution for old Visual Studio
   versions which doesn't support CMake.

 + Open and manage the project directly if the IDE or editor supports
   CMake. In Visual Studio, QTCreator or KDevelop, to open a CMake
   project, it is just necessary to open the directory containing the
   CMakeLists.txt. 

 *File:* CMakeLists.text 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)

  # Proeject name - should not contain whitespace 
  project(OpengGL_CPP)

  #========== Global Configurations =============#
  #----------------------------------------------#

  # Set the C++ standard for all targets (It sets the flags
  # (-std=c++11, -std=c++14 ...) on Clang or GCC. and /std=c++17 on MSVC
  # OPTIONAL:
  #---------------------------------
  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #========== Targets Configurations ============#

  # Build an executable (Unix-like OSes generates ./openglDemo1, on
  # Windows ./opengDemo1.exe)
  # ..........................................
  add_executable(openglDemo1 opengl1.cpp)

  # Set executable dependency libraries
  # Equivalent to pass flags -lGL, -lGLU and -lglut 
  target_link_libraries(openglDemo1 GL GLU glut)

  # Add extension .bin to executable name to make it easier
  # to identify that the binary file is an executable.
  # So, it renames the executable  'openglDemo1' to 'openglDemo1.bin'
  if(UNIX)
    set_target_properties(openglDemo1 PROPERTIES SUFFIX ".bin")
  endif()

  # Add target to run executable 
  add_custom_target(run-ex1
      COMMAND openglDemo1 
      DEPENDS openglDemo1 
      WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
  )
#+END_SRC

Without all the comments and the custom target, the CMakeLists.txt
file would become:

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(OpengGL_CPP)
  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #========== Targets Configurations ============#
  add_executable(openglDemo1 opengl1.cpp)
  target_link_libraries(openglDemo1 GL GLU glut)
#+END_SRC


 *Building on Command Line:*

1 Install OpenGL development libraries (Fedora Linux):

#+BEGIN_SRC sh 
  $ sudo dnf install freeglut-devel.x86_64
  # Optional: Faster and better building system than GNU Make
  $ sudo dnf install ninja-build.x86_64 
#+END_SRC

2 Clone sample project:

#+BEGIN_SRC sj 
  $ git clone https://gist.github.com/caiorss/fd9e61887e9b2575f2275a80af44fac2 cmake-opengl
  Cloning into 'cmake-opengl'...
  remote: Enumerating objects: 4, done.
  remote: Counting objects: 100% (4/4), done.
  remote: Compressing objects: 100% (4/4), done.
  remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0
  Unpacking objects: 100% (4/4), done.

  $ cd cmake-opengl/

  $ ls
  CMakeLists.txt  opengl1.cpp
#+END_SRC

3 Build with Makefile:
 
   + cmake -H<SOURCE> -B<BUILD> [-G <Build-Systems>]
     + <SOURCE> - Directory where is CMakeLists.txt (In this case (.)
       current directory)
     + <BUILD> - Directory containing compilation output and the
       building scripts generated by CMake for some building
       systems. In this exaple: ./cache 
     + -G  <Build-Systems> -> [Optional] Specifies the building
       systems which CMake will generate the scripts for. On Linux,
       the default building system is Makefiles and on Windows it is
       MSBuild. 

#+BEGIN_SRC sh 
  # Generate => Building scripts for Makefile on ./cache directory 
  $ cmake -H. -Bcache 

  -- The C compiler identification is GNU 8.2.1
  -- The CXX compiler identification is GNU 8.2.1
  ... ...   ... ...   ... ...   ... ...   ... ... 
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/cmake-opengl/cache
#+END_SRC

Build the executable running the building script (Makefile) from CMake:

 + Note: It will build all CMake targets, all executables and libraries.

#+BEGIN_SRC sh 
  $ cmake --build cache

  /usr/bin/cmake -H/home/archbox/root-scripts/cmake-opengl -B/home/archbox/root-scripts/cmake-opengl/cache --check-build-system CMakeFiles/Makefile.cmake 0
  /usr/bin/cmake -E cmake_progress_start /home/archbox/root-scripts/cmake-opengl/cache/CMakeFiles /home/archbox/root-scripts/cmake-opengl/cache/CMakeFiles/progress.marks
   .. ...  .. ...  .. ...  .. ...  .. ...  .. ... 
  ir/build
  gmake[2]: Entering directory '/home/archbox/root-scripts/cmake-opengl/cache'
  [ 50%] Building CXX object CMakeFiles/openglDemo1.dir/opengl1.cpp.o
  /usr/lib64/ccache/c++    -std=gnu++1z -o CMakeFiles/openglDemo1.dir/opengl1.cpp.o -c /home/archbox/root-scripts/cmake-opengl/opengl1.cpp
  [100%] Linking CXX executable openglDemo1.bin
#+END_SRC

Build a single target:

#+BEGIN_SRC sh 
 $ cmake --build cache --target openglDemo1
#+END_SRC

Inspect executable: 

#+BEGIN_SRC sh 
  $ file cache/openglDemo1.bin 
   
   cache/openglDemo1.bin: ELF 64-bit LSB
   executable, x86-64, version 1 (SYSV), dynamically linked, interpreter
   /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0,
   BuildID[sha1]=269d06a0054677d70ecf0258268565535e3dfbd4, not stripped
#+END_SRC

Execute a custom target, for instance the custom target _run-ex1_ which runs
the executable (aking to $ make run).

#+BEGIN_SRC sh 
  $ cmake --build cache --target run-ex1

    ... ... .... 
  Scanning dependencies of target run-ex1
  gmake[3]: Leaving directory '/home/archbox/root-scripts/cmake-opengl/cache'
  /usr/bin/gmake -f CMakeFiles/run-ex1.dir/build.make CMakeFiles/run-ex1.dir/build
  gmake[3]: Entering directory '/home/archbox/root-scripts/cmake-opengl/cache'
  ./openglDemo1.bin
  [INFO] Starting OpenGL main loop.
  [INFO] Running loop.
  [INFO] Running loop.
#+END_SRC

4 Build with Ninja. 

 + The compilation can be faster and less verbose with Ninja-build
   building systems.

#+BEGIN_SRC sh 
  # Remove cache directory 
  rm -rf cache

  # Generate building scripts for Ninja building system in directory ./cache 
  $ cmake -H. -Bcache -G Ninja
  -- The C compiler identification is GNU 8.2.1
   ... .... ... .... ... .... ... ....
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/cmake-opengl/cache

  # Build a single target 
  $ cmake --build cache --target openglDemo1
  [2/2] Linking CXX executable openglDemo1.bin

  # Build all targets 
  $ cmake --build cache --target all
  ninja: no work to do.

  # Run target: run-ex1 (akin to $ make run)
  $ cmake --build cache --target run-ex1
  [0/1] cd /home/archbox/root-scripts/cm...pts/cmake-opengl/cache/openglDemo1.bin
#+END_SRC
 
5 Open project with IDE or editor that doesn't support CMake, for
instance: Code Blocks.

 + The following command generates a blocks project file
   (OpengGL_CPP.cbp) and a GNU make building (Makefile) script. Then,
   the project can be opened from Code Blocks by selecting the file
   OpenGL_CPP.cpb which is a CodeBlocks project file.

#+BEGIN_SRC 
  $ cmake -H. -Bcblock -G "CodeBlocks - Unix Makefiles"

  -- The C compiler identification is GNU 8.2.1
   ... ... ... ... ... ... .... 
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/cmake-opengl/cblock

  $ tree cblock -L 1
  cblock
  ├── CMakeCache.txt
  ├── CMakeFiles
  ├── cmake_install.cmake
  ├── Makefile
  └── OpengGL_CPP.cbp

  1 directory, 4 files
#+END_SRC

** Project with multiple targets 
*** Adding and setting multiple targets  

This section provides shows how to set up a project with additional
configuration and multiple targets which means a project with multiple
executables, shared libraries or static libraries.

 *Set up executable target*

 + Executable target defintion => Builds a *.exe on Windows.

#+BEGIN_SRC cmake  
   add_executable(SampleApp main.cpp source1.cpp source2.cpp)
#+END_SRC

 *Set target defines #define or -D<DEFINITION>=VALUE or /D<DEFINTION>=<VALUE>*

 + Compiler defintions. => Defines.
   + It is the same as compiling with GCC with command line option
     -D{DEFINITION}={VALUE} or compiling with MSVC VC++ with the
     command line option /D{DEFINITION}={VALUE} which becomes #define
     {DEFINITION} {VALUE} in the code.
   + Docs: [[https://cmake.org/cmake/help/latest/command/target_compile_definitions.html][target_compile_definitions — CMake 3.13.2 Documentation]]

#+BEGIN_SRC cmake 
    target_compile_definitions(SampleApp PRIVATE  
       VERBOSITY=100  # Same as #define VERBOSITY 100 
       Optimize       # Same as -DOptimize or #define Optimize
       foo=bar        # Same as -Dfoo=bar on (GGCC or Clang) or /Dfoo=bar on MSVC
      )
   # In a single line 
    target_compile_definitions(SampleApp PRIVATE VERBOSITY=100 Optimize foo=bar)
#+END_SRC

 *Set target include directories*

 + Include directories containing header files. Similar to
   command line option -I with GCC.
   + [[https://cmake.org/cmake/help/v3.0/command/target_include_directories.html][target_include_directories — CMake 3.0.2 Documentation]]

#+BEGIN_SRC cmake 
  # Similar to: g++ main.cpp src1.cpp ... -o app.bin -Isrc/include1 -I/home/user/include
  target_include_directories(SampleApp PUBLIC src/include1 /home/usr/include)
#+END_SRC

 *Set directories where shared or static libraries will be searched*

Set the directories where shared or static libraries will be
searched. Note: this command sets the search path for shared libraries
for all targets. 

#+BEGIN_SRC cmake
  link_directories(  
    # C:\Users\DummyUser\libs
    "C:\\Users\\DummyUser\\libs" # Windows paths with backward slash must be escaped with '\'
    "C:/libs/Graphics"           # Windows paths with forward slash 
    "/home/DummyUser/libs" 
  )
#+END_SRC

The command shown in the previous code is equivalent to compiling a
target with GCC as: 

#+BEGIN_SRC sh 
  $ g++ file1.cpp -c -o file1.o -LC:\Users\DummyUser\libs -LC:/libs/Graphics/ -L/home/DummyUser/libs
#+END_SRC


Shared Librarie files extensions: 
 + ~*.dll~ files on Windows for all compilers.
 + ~*.so~ files on Unix-like OSes
 + ~*.dylib~ or ~*.so~ on MacOSX

Static librarie file extension:
 + ~*.lib~ files for MSVC, VC++
 + ~*.a~ for GCC, GCC/Mingw or Clang++. 

 *Set linking libraries*

 + Libraries that the executable will link against.
   + It can be: shared libraries installed on the system or either
     shared or static libraries in the current project.
   + Note: Project libraries are also targets. 

#+BEGIN_SRC cmake  
   # Project shared library SampleSharedLib.so (Linux, Unix) or 
   # SampleSharedLib.dll on Windows. 
   add_library(SampleSharedLib SHARED  lib1.cpp lib2.cpp lib3.cpp)
   # Configuration of target SampleSharedLib
   target_include_directories(SampleSharedLib PRIVATE src/lib/include1)

   # Project static library 
   add_library(StaticLibrary STATIC lib1.cpp lib2.cpp lib3.cpp)

   target_link_libraries(SampleApp  
           GL blas opencv ole32 user32  # System libraries  /usr/lib/*.so files on Linux 
                                        # or *.lib files for MSVC VC++/Windows compiler and DLLs 
                                        # at C:\Windows\System32
           SampleSharedLib              # Project shared library 
           StaticLibrary                # Project static library 
   )
#+END_SRC

 *Set compiler flags* 

 + Target compilar flags.
   + Note: The compilation flags are compiler-specific, the following
     flags only works for GCC and Clang, but they don't work for MSVC
     (VC++ Compiler) that uses forward slashes for compiler options
     instead of dashes. 

#+BEGIN_SRC cmake 
   if(NOT MSVC) 
      # Only for GCC or Clang 
      # (g) => Add debugging symbols 
      target_compile_options(SampleApp -g -Wall -Wpendantic -Wextra )
   else()
      # MSVC (VC++) => "visual" C++
      target_compile_options(SampleApp /Zi /Wall /Yd)         
   endif()
#+END_SRC


 *Set target compiler extensions and C++ standard*

Documentation: 
  + [[https://cmake.org/cmake/help/latest/command/target_compile_features.html][target_compile_features]]
  + [[https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html][CMAKE_CXX_KNOWN_FEATURES]] - Arguments of command target_compile_features
  + See: https://github.com/Kitware/CMake/tree/master/Tests/CompileFeatures

#+BEGIN_SRC cmake 

   # Equivalent to compiling the target usign GCC with -std=c++14 (C++14 ISO Standard)
   # Or /std:c++14 in MSVC VC++ 
   target_compile_features(SomeExecutableTarget PRIVATE cxx_std_14)

   # Equivalent to compiling the target usign GCC with -std=c++17 (C++17 ISO Standard)
   # Or /std:c++17 in MSVC VC++ 
   target_compile_features(SomeExecutableTarget PRIVATE cxx_std_17)

   # Equivalent to compiling the target usign GCC with -std=c++20 - Experimental C++20
   target_compile_features(SomeExecutableTarget PRIVATE cxx_std_20)
#+END_SRC


 *Set target Properties*

  + Set target properties:

#+BEGIN_SRC cmake 
 set_target_properties(SampleApp PROPERTIES 
     {PROPERTY1} {VALUE1}
     {PROPERTY2} {VALUE2}
     ... .... ... ... 
     {PROPERTYN} {VALUEN}
  )
#+END_SRC

Example 1: Add file extension .bin to Unix executable (note:
executables of Unix-like operating system do not have extension *.exe
like in Microsft Windows): 

#+BEGIN_SRC cmake 
 if(UNIX)
    # When it is compiled, instead of generating the executable named as SampleApp, 
    # the program will be named as "SampleApp.bin". 
    set_target_properties(SampleApp PROPERTIES SUFFIX ".bin")
  endif()
#+END_SRC

Example 2: Modify multiple properties, set the shared library file
name to AddinExtesion.xll. 

#+BEGIN_SRC cmake 
  add_library(WrapperLibrary SHARED src1.cpp src2.cpp ... srcN.cpp)
  # ... omit configuration ... # 

  set_target_properties(WrapperLibrary PROPERTIES
    # On Unix, it would add "lib" to beggining of the file name.
    # If prefix was not set to empty, the output file name would be
    # 'libAddinExtesion.xll'
    PREFIX       ""  

    # Change file name without changing prefix or extension (suffix)
    OUTPUT_NAME  "AddinExtension"

    # Change file extension 
    SUFFIX      ".xll"    
  
    # Makes all symbols hidden by default (compiles with by compiling
    # with flag -fvisibility=hidden on Unix-like Oses).  This setting
    # mimics the behavior of MSVC compiler extension
    # __declspec(dllexport)/__declspec(dllimport)
    CXX_VISIBILITY_PRESET hidden
  )
#+END_SRC

The target properties could also be set individually:

#+BEGIN_SRC cmake 
  add_library(WrapperLibrary SHARED src1.cpp src2.cpp ... srcN.cpp)
  # ... omit configuration ... # 
  set_target_properties(WrapperLibrary PROPERTIES PREFIX      "")
  set_target_properties(WrapperLibrary PROPERTIES OUTPUT_NAME "AddinExtension")
  set_target_properties(WrapperLibrary PROPERTIES SUFFIX      ".xll")  
#+END_SRC

 *Add more targets* 

A CMake project can have multiple targets, generating executables,
static libraries or shared libraries.

#+BEGIN_SRC cmake 
  add_executable(DocGenerator src/docgen/main.cpp src/docgen/src2.cpp ...)
  # ... configuration of DocGenerator

  add_executable(Display src/docgen/main.cpp src/docge/src2.cpp ...)
  
  add_library(libCommon SHARED src/lib/src1.cpp src/lib/src2.cpp ...)

  # .... configure targes .... #
#+END_SRC

 *To avoid* 

 + *Commands which affects all targets*: for instance,
   include_directories(dir1 dir2 ...) will add those include
   directories to all targets regardless if they need them or not. It
   is better to use the command target_include_directories as it
   affects just a single target. The word 'should not' does not means
   'never'. If the intent is really set the same include directories
   for all targets, then the command include_directories should be
   used. 

 + *Non portable compiler settings.* Example: Compiler flags such as
   -D{KEY}=VALUE, used by GCC and Clang, or /D{KEY}=VALUE, used by
   MSVC (VC++) are non portable accross different compilers. To
   overcome this, CMake provides many commands with an unified
   interface to many compilers and build-systems, such as
   _target_compile_definitions_ that allows setting defines in a
   compiler agnostic manner.
*** Example 

Project directory structure:

 + ~C:\User\Dummy\Documents\SampleProject~  (Project Root Directory)

   * CMakeLists.txt

   * ./bin => Directory where the compiled binaries will be installed. 

   * ./src - Directory 
     + src/main.cpp
     + src/execMain.cpp
     + src/source1.cpp
     + src/source1.hpp
     + src/source2.cpp
     + src/source2.hpp 
     + src/source3.cpp 
     + ... ... .. 

   * ./lib - directory
     + lib/lib1.cpp
     + lib/lib2.cpp
     + lib/lib3.cpp


  File: *CMakeLists.txt* file for this hypothetical project.

Global configuration: 
 + Note: Global settings such _add_definitions_ and _include_directories_
   should be avoided.  

#+CAPTION: Part 1 of CMakeListi.txt - Global project's configuration 
#+BEGIN_SRC cmake 
   # ========= Global Configuration  ===============#
   # The global configuration is shared by all targets. 
   cmake_minimum_required(VERSION 3.9)
 
   project( SuperCADTool
            # Note: the following fields are optional 
            DESCRIPTION "Another CAD Computer Aided Design APP"
            VERSION     1.0 
            LANGUAGE    CXX 
          )
 
   set(CMAKE_CXX_STANDARD 17)     
   set(CMAKE_VERBOSE_MAKEFILE ON)

  # Global compile definition
  # Add compiled definition -DQT_QML_DEBUG for all target.s 
  add_definitions(-DQT_QML_DEBUG)

  # Global includes added to all targets 
  include_directories("C:\\boost\\v1.67\\include"  "/home/someone/includes")
 
   # Global linking directories which contains static (*.a) or shared
   # libraries (*.so or *.dll files)
  link_directories(  
     # C:\Users\DummyUser\libs
     "C:\\Users\\DummyUser\\libs" # Windows paths with backward slash must be escaped with '\'
     "C:/libs/Graphics"           # Windows paths with forward slash 
     "/home/DummyUser/libs" 
   )
#+END_SRC

Target Configurations: 

#+CAPTION: Part 2 of CMakeListi.txt - Per-target configuration. 
#+BEGIN_SRC cmake 
   # ======= Configuration per target =============#

   # Target: SampleApp executable 
   #---------------------------------------------------------
   add_executable(SampleApp src/main.cpp src/source1.cpp src/source2.cpp) 
   target_compile_definitions(SampleApp PRIVATE VERBOSITY=100 Optimize foo=bar)
   target_include_directories(SampleApp PUBLIC src/include1 /home/usr/include)

   target_link_libraries(SampleApp  
           GL blas opencv ole32 user32  # System libraries  /usr/lib/*.so files on Linux 
                                        # or *.lib files for MSVC VC++/Windows compiler and DLLs 
                                        # at C:\Windows\System32
           SampleSharedLib              # Project shared library 
           StaticLibrary                # Project static library 
   )

  # Target: Executable2 
  #-----------------------------------------------------------------
  add_executable(Executable2 src/execMain.cpp src/source1.cpp src/source2.cpp src/source3.cpp) 

  # Target: SampleShared - Shared library dll, so 
  #-------------------------------------------------------------------
  add_library(SampleSharedLib SHARED  lib/lib1.cpp lib/lib2.cpp lib/lib3.cpp)
  target_include_directories(SampleSharedLib PRIVATE src/lib/include1)
#+END_SRC

Intallation commands: 

#+CAPTION: Part 3 of CMakeListi.txt - Target/commands for installing executables and libraries.
#+BEGIN_SRC cmake 
  # Install binaries locally during development.
  # The binaries are installed in project's "${ROOT DIRECTORY}./bin" 
  #----------------------------------------------------------------------

  # During the development install ./bin dir.  in project's root directory 
  # To install using CMAKE_INSTALL_PREFIX path, set this variable to 'OFF'
  set(INSTALL_LOCAL ON) 

  if(INSTALL_LOCAL ON)
    # Overrides the default default install location that would be 
    # ${CMAKE_INSTALL_PREFIX}/bin as ${CMAKE_CURRENT_LIST_DIR}/bin 
    #
    # Note: CMAKE_CURRENT_LIST_DIR is the directory where is CMakeLists.txt 
    install(TARGETS SampleApp Executable2 SampleSharedLib DESTINATION  ${CMAKE_CURRENT_LIST_DIR}/bin)
  else()
    # Install binary to directory probvided by the variable CMAKE_INSTALL_PREFIX 
    install(TARGETS SampleApp Executable2 SampleSharedLib DESTINATION  bin)
  endif()
#+END_SRC


 *Compilation:*

Once the project file CMakeLists.txt is opened in any supported IDE or
an text editor such as QTCreator, the IDE will show all available
targets and provide menus, context menus or buttons where is possible
to select all targets for building the entire project; build individual
targets; debug an specific executable targets and run the *install*
target that copies the compiled files to the directory stored in the
variable *CMAKE_INSTALL_PREFIX*. 

 *Running targets manually from command line without any IDE:* 

Step 1. Configuration - run the command from the project's top level directory.

 + Configure with install path CMAKE_INSTALL_PREFIX set to default
   sytem location. (/usr/local on Linux). To install the binaries to
   the this location, set the variable INSTALL_LOCAL in the code to
   OFF. 

#+BEGIN_SRC sh 
  # Use Ninja build system 
  $ cmake -Bcache -H. -G Ninja 

  # Use Makefile 
  $ cmake -Bcache -H. -G Ninja 
#+END_SRC

 + Configure base install path (CMAKE_INSTALL_PREFIX) to
   /home/dummy/Documents/myapp, assuming that INSTALL_LOCAL is set to
   OFF.

#+BEGIN_SRC sh 
  $ cmake -Bcache -H. -G Ninja -DCMAKE_INSTALL_PREFIX=/home/dummy/Documents/myapp 
#+END_SRC

Step 2. Run targets. 

 + Run all targetes building the whole project 

#+BEGIN_SRC sh 
   $ cmake --build cache --target  
#+END_SRC

 + Run only the target SampleApp that builds the SampleApp executable:

#+BEGIN_SRC sh 
  $ cmake --build cache --target SampleApp
#+END_SRC

 + Run only the target Executable2 that builds the Excutable2 executable 

#+BEGIN_SRC sh 
   $ cmake --build cache --target Executable2 
#+END_SRC
 
 + Run the target 'install' that will install all binaries specified
   in target install to ./bin directory if the option *INSTALL_LOCAL* is
   set in the code (ON). To install the standard location specified by
   ${CMAKE_INSTALL_PREFIX}, set *INSTALL_LOCAL* in the code to OFF.

#+BEGIN_SRC sh 
   $ cmake --build cache --target install 
#+END_SRC

*** Further Reading

General 

 + Ben Morgan - The University of Warwick - [[https://web.archive.org/web/20190109203537/https://indico.fnal.gov/event/9717/session/38/contribution/82/material/slides/0.pdf][C++11/14/1z in CMake]]
 + [[https://foonathan.net/doc/compatibility/][Documentation of Compatibility]]
 + [[https://manpages.debian.org/stretch-backports/cmake-data/cmake-compile-features.7.en.html][Manpage - Cmake compile features]]
 + https://community.kde.org/Guidelines_and_HOWTOs/CMake/Library

Install Dependencies - Shared Libraries: 

 + https://cmake.org/cmake/help/latest/command/install.html

 + [[https://stackoverflow.com/questions/41175354/can-i-install-shared-imported-library][Can I install shared imported library?]]

 + https://cmake.org/pipermail/cmake/2014-December/059338.html

 + [[https://cmake.org/pipermail/cmake/2009-June/030205.html][Install of library sub-project prior to building application]]

 + [[http://cmake.3232098.n2.nabble.com/Copying-Shared-Libraries-DLLs-Next-to-the-Executable-td7597163.html][Copying Shared Libraries (DLLs) Next to the Executable]]
** Common Variables 
*** CMAKE_CURRENT_LIST_DIR - Directory where is CMakeLists.txt 

Prints the directory where CMAkeLists.

#+BEGIN_SRC cmake 
  message(" [INFO] CMakeLists.txt is in the directory ${CMAKE_CURRENT_LIST_DIR}")
#+END_SRC

*** CMAKE_CXX_STANDARD - Set C++ Standard

The variable ~CMAKE_CXX_STANDARD~ sets the project current C++
standard. This variable can be set to 98 (for C++98); 11 (C++11); 14
(C++14); 17 (C++17) and 20 (C++20 - experimental yet.)

 + Documentation: [[https://cmake.org/cmake/help/latest/prop_tgt/CXX_STANDARD.html#prop_tgt:CXX_STANDARD][CXX_STANDARD — CMake 3.13.2 Documentation]] 

Example: Set project to compile with C++11 ISO standard.

#+BEGIN_SRC cmake 
  set(CMAKE_CXX_STANDARD 11)
#+END_SRC

Usage: (File CMAKELists.txt)

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(MY_PROJECT_NAME)

  set(CMAKE_CXX_STANDARD 17)
  ... ... .... .... 
#+END_SRC

*** CMAKE_BUILD_TYPE - Set default building type to DEBUG 

In the debug building type optimization flags are disabled and flags
for generating debugging symbols are enabled, for GGC or GCC/Mingw and
Clang the (-g) is automatically added and for MSVC, aka VC++ (cl.exe),
the flag /Zi is also passed to the compiler. The default building type
can be set to DEBUG with the following code.

#+BEGIN_SRC cmake 
  # Set default building type to debug if it was not set
  # in command line with -DCMAKE_BUILD_TYPE=release
  if(NOT DEFINED CMAKE_BUILD_TYPE OR CMAKE_BUILD_TYPE MATCHES "")
    set(CMAKE_BUILD_TYPE  debug)
  endif()
#+END_SRC

The building type can be changed by running cmake with the flag
 (-DCMAKE_BUILD_TYPE=release). Example: 

#+BEGIN_SRC sh 
 $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"
#+END_SRC

Note: CMake is not case sensitive, so it does not matter using
'release' or RELEASE; if or IF; endif or ENDIF and so on. 

*** CMAKE_CXX_FLAGS - Compiler flags 

The globals compiler flags used to build all targets can be extended
by setting the variable CMAKE_CXX_FLAGS. However, as the compiler
flags depends on the compiler, the custom settings may not be portable
if one uses a different compiler, for instance the (-g) flag used to
generate debug symbols with GCC or Clang does not work with MSVC
(visual c++ compiler, vc++) as it uses the flag /Zi for generating
debugging symbols.

Example 1: 

#+BEGIN_SRC cmake
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}"  "-std=c++17 -g -Wall -Wextra -pendantic -O0" )
#+END_SRC

Example 2 (better):

#+BEGIN_SRC cmake
  if(NOT MSVC)
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}"  "-std=c++17 -g -Wall -Wextra -pendantic -O0" )
  endif()
#+END_SRC

** CMake Map 

 + Global configuration/settings 
   + add_definitions
   + set(<VARIABLE> <VALUE>)
   + add_subdirectory 

 + Target defintions
   + add_executable => Create target for building executable. 
   + add_library    => Create target for building static or shared library.
   + add_custom_target

 + Target Configuration:
   + set_target_properties(<TARGET> PROPERTIES <KEY> <VALUE> [<KEY <VALUE>] ...)
   + set_target_properties(testlib PROPERTIES CXX_VISIBILITY_PRESET hidden)
     + Make  symbols of shared or static library hidden by default,
       only explicitly annotated symbols are visible. It avoids name
       clashing which can lead to undefined behavior.

   + target_link_libraries(<executable-target> PUBLIC testlib)

 + Auxiliary targets:
   + install  => Install packages to some directoriy.

 + Find Commands:
   + find_path 
   + find_package
   + find_library
   + include_directory

 + Global Variables:
   + set(CMAKE_CXX_STANDARD 14)
   + set(CMAKE_VERBOSE_MAKEFILE ON)
   + set(CMAKE_BUILD_TYPE  debug)

Typical CMake Variables:

|--------------------------+----------------+-----------------------------------------------------------|
| Variable                 | Compiler flags | Description                                               |
|                          | affected       |                                                           |
|--------------------------+----------------+-----------------------------------------------------------|
| *Misc*                     |                |                                                           |
| PROJECT_NAME             | -              | Sets project name.                                        |
|                          |                |                                                           |
| *Compiler*                 |                |                                                           |
|                          |                |                                                           |
| CMAKE_CXX_STANDARD       | -std=c++11     | Set the C++ standard used for compoling all sources       |
| CMAKE_CXX_FLAGS          | -              | Additional compiler flags for all targets.                |
| CMAKE_BUILD_TYPE         |                | Set whether build type is release or debug                |
|                          |                |                                                           |
| *Location*                 |                |                                                           |
| CMAKE_BINARY_DIR         |                |                                                           |
| CMAKE_CURRENT_LIST_DIR   |                | Get location of current CMakeLists.txt file.              |
| CMAKE_INSTALL_PREFIX     |                | Location where targets will be installed (target _install_) |
| CMAKE_CURRENT_BINARY_DIR |                |                                                           |
|                          |                |                                                           |
|--------------------------+----------------+-----------------------------------------------------------|

Notes: 

 + The default value of the variable CMAKE_INSTALL_PREFIX are:
   + Windows:        C:/Program Files/${PROJECT_NAME}
   + Unix-like OS:   /usr/local
** Build a project from command line.

A project using Cmake as building system contains a build script at
top level directory named CMakeLists.txt. To build a project with
CMake, it is necessary to consider that CMake, is not a building
system and does not build anything. Actually, Cmake generates building
scripts for the platform preferred building scripts. For instance, on
Linux, it can generate Makefile, Eclipse Makefiles; on Windows it can
generate MSBuild scripts, NMake (Windows SDK's make) and so on.

 + Check all possible building system for which CMake can generate
   build scripts.
   + Command: $ *cmake -G*

#+BEGIN_SRC sh 
   # Running on Windows 10 
   $ cmake -G
   CMake Error: No generator specified for -G

   Generators
     Visual Studio 15 2017 [arch] = Generates Visual Studio 2017 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 14 2015 [arch] = Generates Visual Studio 2015 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 12 2013 [arch] = Generates Visual Studio 2013 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 11 2012 [arch] = Generates Visual Studio 2012 project files.
                                    Optional [arch] can be "Win64" or "ARM".
     Visual Studio 10 2010 [arch] = Generates Visual Studio 2010 project files.
                                    Optional [arch] can be "Win64" or "IA64".
     Visual Studio 9 2008 [arch]  = Generates Visual Studio 2008 project files.
                                    Optional [arch] can be "Win64" or "IA64".
     Borland Makefiles            = Generates Borland makefiles.
     NMake Makefiles              = Generates NMake makefiles.
     NMake Makefiles JOM          = Generates JOM makefiles.
     Green Hills MULTI            = Generates Green Hills MULTI files
                                    (experimental, work-in-progress).
     MSYS Makefiles               = Generates MSYS makefiles.
     MinGW Makefiles              = Generates a make file for use with
                                    mingw32-make.
     Unix Makefiles               = Generates standard UNIX makefiles.
     Ninja                        = Generates build.ninja files.
     Watcom WMake                 = Generates Watcom WMake makefiles.
     CodeBlocks - MinGW Makefiles = Generates CodeBlocks project files.
     CodeBlocks - NMake Makefiles = Generates CodeBlocks project files.
     CodeBlocks - NMake Makefiles JOM
                                  = Generates CodeBlocks project files.
     CodeBlocks - Ninja           = Generates CodeBlocks project files.
     CodeBlocks - Unix Makefiles  = Generates CodeBlocks project files.
     CodeLite - MinGW Makefiles   = Generates CodeLite project files.
     CodeLite - NMake Makefiles   = Generates CodeLite project files.
     CodeLite - Ninja             = Generates CodeLite project files.
     CodeLite - Unix Makefiles    = Generates CodeLite project files.
     Sublime Text 2 - MinGW Makefiles
                                  = Generates Sublime Text 2 project files.
     Sublime Text 2 - NMake Makefiles
                                  = Generates Sublime Text 2 project files.
     Sublime Text 2 - Ninja       = Generates Sublime Text 2 project files.
     Sublime Text 2 - Unix Makefiles
                                  = Generates Sublime Text 2 project files.
     Kate - MinGW Makefiles       = Generates Kate project files.
     Kate - NMake Makefiles       = Generates Kate project files.
     Kate - Ninja                 = Generates Kate project files.
     Kate - Unix Makefiles        = Generates Kate project files.
     Eclipse CDT4 - NMake Makefiles
                                  = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - MinGW Makefiles
                                  = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - Ninja         = Generates Eclipse CDT 4.0 project files.
     Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files.
#+END_SRC

 *STEP 1: Generate Building Script*

Project directory listing:

#+BEGIN_SRC sh 
  $ tree .
  .
  ├── build.bat
  ├── client1.cpp
  ├── CMakeLists.txt
  ├── Makefile
  ├── pywrapper.py
  ├── testlib.cpp
  └── testlib.hpp
#+END_SRC

 *Generate building scripts for platform-preferred building system:*

 + $ cmake -H<SOURCE> -B<BUILD>
   + <SOURCE> => Source directory where all *.cpp, *.hpp code. In this
     case it is (.) dot, current directory. If the directory was
     ./src, the command would be -Hsrc or -H./src
   + <BUILD> => Compilation output, directory where are all building
     scripts. 

Command output on Windows 10 - MSVC 2017. Note: It will set VC++ for
32 bits target, not 64 bits.

#+BEGIN_SRC sh 
  $ cmake -H. -Bbuild
  -- Building for: Visual Studio 15 2017
  -- The C compiler identification is MSVC 19.16.27025.1
  -- The CXX compiler identification is MSVC 19.16.27025.1  
  ... ...   ... ...   ... ...   ... ...   ... ... 
  -- Configuring done
  -- Generating done
  -- Build files have been written to: C:/Users/archbox/Desktop/experiments/dll/build
#+END_SRC

Command output on Linux: 

#+BEGIN_SRC sh 
  $ cmake -H. -Bbuild
  -- The C compiler identification is GNU 8.2.1
  -- The CXX compiler identification is GNU 8.2.1
  -- Check for working C compiler: /usr/lib64/ccache/cc
  -- Check for working C compiler: /usr/lib64/ccache/cc -- works
  ... ...   ... ...   ... ...   ... ...   ... ... 
   [INFO] Libtest location is at: libtest_location-NOTFOUND
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/gist/build

  # List ./build directory 
  $ tree -L 1 build
  build
  ├── CMakeCache.txt
  ├── CMakeFiles
  ├── cmake_install.cmake
  └── Makefile

  1 directory, 3 files
#+END_SRC

  *Generate building script for specific building system:*

 + $ cmake -H<SOURCE> -B<BUILD> -G <BUILD-SYSTEM>
   + <SOURCE> => Source directory where all *.cpp, *.hpp code. In this
     case it is (.) dot, current directory. If the directory was
     ./src, the command would be -Hsrc or -H./src
   + <BUILD> => Compilation output, directory where are all building
     scripts.
   + <BUILD-SYSTEM> => All available build system can be listed with $ cmake -G.

#+BEGIN_SRC sh 
 # Generate MSbuild building scripts for 32 bits target 
  $ cmake -H. -Bbuild -G "Visual Studio 15 2017"

  # Generate MSbuild building scripts for 64 bits target 
  $ cmake -H. -Bbuild -G "Visual Studio 15 2017 Win64"
#+END_SRC

 *Generate building script with debug symbols enabled:*

It automatically adds the debugging flags (/Zi) for VC++ Microsoft
Visual C++ Compiler which necessary for debugging a program with GDB,
LLDB or WinDBG. 

 + Add the flag *-DCMAKE_BUILD_TYPE=DEBUG*

#+BEGIN_SRC sh 
  # Example 1:
  $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG

  # Example 2:
  $ cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=RELEASE

  # Example 3: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"

  # Example 4: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=DEBUG -G "Visual Studio 15 2017 Win64"

  # Example 5: 
  cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=RELEASE -G "Visual Studio 15 2017 Win64"
#+END_SRC


 *STEP 2: Compile the project invoking the generated building scripts*

Invoke the building scripts indirectly using CMake:

 + $ cmake --build <BUILD>
   + <BUILD> Is the build directory generated at step 1. 

#+BEGIN_SRC sh 
  $ cmake --build build
  # OR
  $ cmake --build build --config Debug 
  # OR
  $ cmake --build build --config Release
#+END_SRC

Invoke the building script directly, call the building tool:
 + This building method depends on the current building system.

For MSBuild, the compilation becomes:

#+BEGIN_SRC sh
  $ MSBuild build\testlib.vcxproj

  Microsoft (R) Build Engine version 15.5.180.51428 for .NET Framework
  Copyright (C) Microsoft Corporation. All rights reserved.

  Build started 12/21/2018 12:49:38 PM.
  Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" on node 1 (default targets).
  Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" (1) is building "C:\Users\archbox\ Desktop\experiments\dll\build\ZERO_CHECK.vcxproj" (2) on node 1 (default targets).
  ... ... ... ... ... ... ... ... ... ... ... ... ... ... 
  testlib.vcxproj -> C:\Users\archbox\Desktop\experiments\dll\build\Debug\testlib.dll
  FinalizeBuildStatus:
    Deleting file "testlib.dir\Debug\testlib.tlog\unsuccessfulbuild".
    Touching "testlib.dir\Debug\testlib.tlog\testlib.lastbuildstate".
  Done Building Project "C:\Users\archbox\Desktop\experiments\dll\build\testlib.vcxproj" (default targets).
#+END_SRC

For Linux or Unix GNU-Make, the compilation becomes:

#+BEGIN_SRC sh 
   $ cd build

   $ make
   /usr/bin/cmake -H/home/archbox/root-scripts/gist -B/home/archbox/root-scripts/gist/build --check-build-system CMakeFiles/Makefile.cmake 0
   /usr/bin/cmake -E cmake_progress_start /home/archbox/root-scripts/gist/build/CMakeFiles /home/archbox/root-scripts/gist/build/CMakeFiles/progress.marks
   make -f CMakeFiles/Makefile2 all
   make[1]: Entering directory '/home/archbox/root-scripts/gist/build'
   make -f CMakeFiles/testlib.dir/build.make CMakeFiles/testlib.dir/depend
   make[2]: Entering directory '/home/archbox/root-scripts/gist/build'
   ... ... ... ... ... ... ... ... ... ... ... ... 
   [100%] Built target client1-executable
   make[1]: Leaving directory '/home/archbox/root-scripts/gist/build'
   /usr/bin/cmake -E cmake_progress_start /home/archbox/root-scripts/gist/build/CMakeFiles 0  


  # Built executables: 
  #--------------------------------
  $ file libtestlib.so 
  libtestlib.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically 
  linked, BuildID[sha1]=ce79ed7580a16cbc27bf113a2967eb1d66f496a3, not stripped

  $ file client1-executable.bin 
  client1-executable.bin: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
  for GNU/Linux 3.2.0, BuildID[sha1]=8103d822a6d58497b63346dfcc1f7375599114f7, not stripped
#+END_SRC

Or just in a single step: 

#+BEGIN_SRC sh 
  $ cd build && make && cd ..
#+END_SRC

** Show system information 

#+BEGIN_SRC sh  
  cmake --sytem-information 
#+END_SRC 

Output on Linux: 

#+BEGIN_SRC sh 
   Avoid ctest truncation of output: CTEST_FULL_OUTPUT
   ========================================================
   === MAIN VARIABLES
   ========================================================
   CMAKE_STATIC_LIBRARY_PREFIX == "lib"
   CMAKE_STATIC_LIBRARY_SUFFIX == ".a"
   CMAKE_SHARED_LIBRARY_PREFIX == "lib"
   CMAKE_SHARED_LIBRARY_SUFFIX == ".so"
   CMAKE_SHARED_MODULE_PREFIX == "lib"
   CMAKE_SHARED_MODULE_SUFFIX == ".so"


   CMAKE_DL_LIBS == "dl"
   CMAKE_LIBRARY_PATH_FLAG == "-L"
   CMAKE_LINK_LIBRARY_FLAG == "-l"
   CMAKE_SKIP_RPATH == "NO"
   CMAKE_SYSTEM_INFO_FILE == "Platform/Linux"
   CMAKE_SYSTEM_NAME == "Linux"
   CMAKE_SYSTEM == "Linux-4.18.18-200.fc28.x86_64"
   CMAKE_CXX_COMPILER == "/usr/lib64/ccache/c++"
   CMAKE_C_COMPILER == "/usr/lib64/ccache/cc"
   CMAKE_COMPILER_IS_GNUCC == "1"
   CMAKE_COMPILER_IS_GNUCXX == "1"

   // C shared library flag
   CMAKE_SHARED_LIBRARY_C_FLAGS == "-fPIC"
   CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS == "-shared"
   CMAKE_SHARED_LIBRARY_LINK_FLAGS == ""
   ... ...    ... ...    ... ...    ... ...    ... ... 
#+END_SRC

** Show all modules 

#+BEGIN_SRC sh 
  $ cmake --help-module-list
#+END_SRC

Output: 

#+BEGIN_SRC text 
  AddFileDependencies
  AndroidTestUtilities
  BundleUtilities
  CMakeAddFortranSubdirectory
  CMakeBackwardCompatibilityCXX
  CMakeDependentOption
  CMakeDetermineVSServicePack
  CMakeExpandImportedTargets
  CMakeFindDependencyMacro
  CMakeFindFrameworks
  CMakeFindPackageMode
  CMakeForceCompiler
  CMakeGraphVizOptions

  ... ... ... ... ... ... 

  FindLAPACK
  FindLATEX
  FindLTTngUST
  FindLibArchive
  FindLibLZMA
  FindLibXml2
  FindLibXslt
  FindLua
  FindLua50
  FindLua51
  FindMFC
  FindMPEG
  FindMPEG2
  FindMPI
  FindMatlab
  FindMotif
  FindOpenACC

  ... ... ... ... ... ... ... ... 

#+END_SRC

** Windows OS Specifick Snippets
*** Executable Target with resource icon

This section provides an example about how to add a resource icon to a
Windows executable target.

Files:

| Project Item    | Description                            |   |
|-----------------+----------------------------------------+---|
| Application     | ProgramWithICON.exe                    |   |
| Sources:        | src/main.cpp src/src1.cpp src/src2.cpp |   |
| Icon            | src/programImage.ico                   |   |
| Resource script | src/icon.rc                            |   |
|-----------------+----------------------------------------+---|

Resource file: src/icon.rc 

#+BEGIN_SRC cpp
  // Icon Resource => Compiled by Resource compiler
  id ICON "programImage.ico"
#+END_SRC

CMakeLists.txt 

#+BEGIN_SRC cmake 
   # .... Omit beginning and global configuration .... #
    add_executable(ProgramWithICON src/main.cpp src/src1.cpp src/src2.cpp)
   if(WIN32)
      target_sources(ProgramWithICON src/icon.rc)
   endif()
 
   target_include_directories(ProgramWithICON  ./includes)
  # .... Omit additional configuration ... #
#+END_SRC
*** Set target subsystem: console/window

Set target subsystem. 

#+BEGIN_SRC cmake 
  if(WIN32)
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_DEBUG "/SUBSYSTEM:CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES COMPILE_DEFINITIONS_DEBUG "_CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_RELWITHDEBINFO "/SUBSYSTEM:CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES COMPILE_DEFINITIONS_RELWITHDEBINFO "_CONSOLE")
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_RELEASE "/SUBSYSTEM:WINDOWS")
     set_target_properties(WindowApplicationExample PROPERTIES LINK_FLAGS_MINSIZEREL "/SUBSYSTEM:WINDOWS")
  endif(WIN32)
#+END_SRC

Taken from: 
 + [[https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/recipe/VSConfigSpecificSettings][Vsconfigspecificsettings · Wiki · CMake / Community · GitLab]]
 + [[https://developercommunity.visualstudio.com/content/problem/46678/cmake-set-subsystem-to-console.html][cmake: Set subsystem to console - Developer Community]]
 + [[https://stackoverflow.com/questions/33873735/correctly-set-visual-studio-linker-flag-subsystem-in-cmake][c++ -
   Correctly set Visual Studio linker flag /SUBSYSTEM in CMAKE - Stack
   Overflow]]
** Force Settings 
*** Force generation of debugging symbols 

This snippet forces the generation of debugging symbols regardless of
the build type. It is a useful setting when building from command
line. 

Add the following line to the CMake file: 

#+BEGIN_SRC cpp 
 set(CMAKE_BUILD_TYPE Debug) # Force debug build
#+END_SRC

After the line is added, the file CMakeLists.txt becomes:

#+BEGIN_SRC cmake
  #========= Global Configuration ===============# 
  cmake_minimum_required(VERSION 3.9)
  project(Demo_cpp_plugin)
  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  # Force debug build
  set(CMAKE_BUILD_TYPE Debug) # Force debug build

  #========== Targets Configurations ============#

  add_executable(app ... )
  .. ... ... ... 
#+END_SRC
*** Force Compiler to Clang 

Despite C++ language remarkable improvements, C++ compiler error
messages of most compilers still cryptic and hard to grasp. Even for
silly syntax mistakes, C++ compilers can fill the screen with error
messages providing little context about the compiler error. 

Such cryptic errors can be better diagnosed by switching the compiler
to Clang that provides much better error messages that other compilers.
The compiler can be temporarily switched by using the IDE, by setting
environment variables or by setting CMake variables to force using an
specific compiler.


Example: CMakeLists.txt forcing compiler to Clang.

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)
  project(NumericalMethods)
  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  set(FORCE_CLANG ON)
  # Force compiler to Clang++
  if(FORCE_CLANG)
      set(CMAKE_C_COMPILER clang)
      set(CMAKE_CXX_COMPILER clang++)
  endif()

  #========== Targets Configurations ============#

  # TARGET: rootFinding1.cpp 
  add_executable(rootFinding1 rootFinding1.cpp)
#+END_SRC

 *Explanation:*

This next line sets the variable FORCE_CLANG:

#+BEGIN_SRC cmake 
   set(FORCE_CLANG ON)   # Force using clang compiler 
   set(FORCE_CLANG OFF)  # Use default compiler 
#+END_SRC

When the variable FORCE_CLANG is set, the commands within the if-endif
block set the C and C++ compiler to Clang and Clang++.

#+BEGIN_SRC cmake 
  # Force compiler to Clang++
  if(FORCE_CLANG)
      set(CMAKE_C_COMPILER clang)
      set(CMAKE_CXX_COMPILER clang++)
  endif()
#+END_SRC

** Snippets 
*** Debug Information for diagnosing problems

 *Set Build Type*

Informs whether the current build type is Release or Debug. Relase has
optmization flags enabled and debugging symbols disabled. Debug
building type has optmization flags and debugging symbols flags
disabled.

The build type is:

 + Release when :
   + $ cmake --build <BUILD-DIRECTORY> --config Release --target
   + $ cmake --build <BUILD-DIRECTORY> --config Release --target install

 + Debug when using (Default):
   + $ cmake --build <BUILD-DIRECTORY> --config Debug --target
   + $ cmake --build <BUILD-DIRECTORY> --config Debug --target Application1
   + $ cmake --build <BUILD-DIRECTORY> --config Debug --target install 

 *Set Installation Directory* 

The installation directory can be set with the option
-DCMAKE_INSTALL_PREFIX, examples: 

#+BEGIN_SRC sh 
  # Configuration 
  $ cmake -Bcache -DCMAKE_INSTALL_PREFIX=C:\\Users\Dummy\apps 

  # Execute install target 
  $ cmake --build cache --config Debug --target install 
#+END_SRC

 *Useful Debugging Commands*

#+BEGIN_SRC cmake  
  message(" [INFO] Build type = ${CMAKE_BUILD_TYPE}")
#+END_SRC

Target word size 32 bits (x86) or 64 bits (x86_64):

#+BEGIN_SRC cmake 
  if(CMAKE_SIZEOF_VOID_P EQUAL 8)
     message(" [INFO] Target = 64 bits build.")
  else()
     message(" [INFO] Target = 32 bits build.")
  endif()
#+END_SRC

Compiler: 

#+BEGIN_SRC cmake 
  message(" [INFO] Compiler ID = ${CMAKE_CXX_COMPILER_ID}")
#+END_SRC

Current Platform: 

#+BEGIN_SRC cmake 
  message(" [INFO] System Name = ${CMAKE_SYSTEM_NAME} ")
#+END_SRC

Binary directory <BUILD-DIRECTORY>

#+BEGIN_SRC cmake 
  message(" [INFO] CMake binary dir = ${CMAKE_BINARY_DIR}")
#+END_SRC

Installation directory specifies the directory where the binaries will
be installed by the target *install*. It can be specified during
configuration phase by using:

 + *--DCMAKE_INSTALL_PREFIX=C:\Users\Dummy\app*

#+BEGIN_SRC cmake 
  message(" [INFO] Install path CMAKE_INSTALL_PREFIX = ${CMAKE_INSTALL_PREFIX} ")
#+END_SRC


Putting it all together:

#+BEGIN_SRC cmake 
   message(" [INFO]  System Name  - CMAKE_SYSTEM_NAME     = ${CMAKE_SYSTEM_NAME}")
   message(" [INFO]  Build type   - CMAKE_BUILD_TYPE      = ${CMAKE_BUILD_TYPE}")
   message(" [INFO]  Compiler ID  - CMAKE_CXX_COMPILER_ID = ${CMAKE_CXX_COMPILER_ID}")
   message(" [INFO]  Install path - CMAKE_INSTALL_PREFIX  = ${CMAKE_INSTALL_PREFIX} ")
   if(CMAKE_SIZEOF_VOID_P EQUAL 8)
      message(" [INFO] Target = 64 bits build.")
   else()
      message(" [INFO] Target = 32 bits build.")
   endif()
   message(" [INFO] CMake binary dir = ${CMAKE_BINARY_DIR}")
#+END_SRC

*** Detect Operating System 
**** Detect operating system with predefined variables  

 Check whether current OS is Microsft Windows NT:

 #+BEGIN_SRC cmake
   if(WIN32)
     # actions ... 
     message("Compiling for Windows NT")
   else()
     # else actions .... ...
   endif()
 #+END_SRC

 Check whether current OS is a Unix-like operating system (Linux, BSD,
 MacOSX, Android and so on): 

 #+BEGIN_SRC cmake 
   if(UNIX)
     # actions ... 
     message("Running on Unix-like OS")
   endif()  
 #+END_SRC

 Check if current OS is MacOSX:

 #+BEGIN_SRC cmake 
   if(APPLE)
     # actions ... 
     message("Running on Unix-like OS")
   endif()  
 #+END_SRC

 Check if current OS is Linux:

 #+BEGIN_SRC cmake 
   if(LINUX)
     # actions ... 
     message("Running on Unix-like OS")
   endif()  
 #+END_SRC

 Check if current OS is UNIX, but not MacOSX:

 #+BEGIN_SRC cmake
   if(UNIX AND NOT APPLE)
     # actions ... 
     message("Running on Unix-like OS")
   endif()  
 #+END_SRC
**** Detect operating system with variable CMAKE_SYSTEM_NAME

 Example: 

 #+BEGIN_SRC cmake 
 if(${CMAKE_SYSTEM_NAME} matches "linux")
   message(" [INFO] compiling for Linux")
 elseif(${CMAKE_SYSTEM_NAME} matches "Windows")
   message(" [INFO] compiling for Windows")
 elseif(${CMAKE_SYSTEM_NAME} matches "darwin")
   message(" [INFO] compiling for Apple MacOSX")
 elseif(${CMAKE_SYSTEM_NAME} matches "Android")
   message(" [INFO] compiling for Android OS.")
 else()
   message( " [WARNING] Operating system not identified.")
 endif()
 #+END_SRC

 Possible Values of Variable _CMAKE_SYSTEM_NAME_

 #+BEGIN_SRC cmake
   if(${CMAKE_SYSTEM_NAME} matches <<MATCHING-STRING>)
     message(" [INFO] compiling for <<MATCHIGN-STTRING> ")
   endif()
 #+END_SRC

 | Value of <<MATCHING-STRING> | Operating System              |   |
 | for _CMAKE_SYSTEM_NAME_       |                               |   |
 |-----------------------------+-------------------------------+---|
 | Windows                     | Windows                       |   |
 | Darwin                      | MacOSX                        |   |
 | BSD                         | Free BSD, OpenBDS, NetBSD ... |   |
 | FreeBSD                     |                               |   |
 | Linux                       | Linux                         |   |
 | Android                     | Android                       |   |
 |-----------------------------+-------------------------------+---|
*** Detect Compiler 
**** Detect compiler using predefined variables  

  *MSVC*

 Check if current compiler is MSVC - Microsft - Visual C/C++ Compiler
 (Visual C++, vc++ for short):

 #+BEGIN_SRC cmake 
   if(MSVC)
     message(STATUS << "Running MSVC")
   endif()
 #+END_SRC

  *MSVC for 32 bits target*

 Detect MSVC set up for 32 bits target (buids 32 bits binaries):

 #+BEGIN_SRC cmake 
   if(MSVC AND NOT CMAKE_CL_64)
     message(" [INFO] Building for 32 bits Windows target.")
   endif()
 #+END_SRC

  *MSVC for 64 bits target*

 #+BEGIN_SRC cmake 
   if(MSVC AND CMAKE_CL_64)
     message(" [INFO] Building for 64 bits Windows target.")
   endif()
 #+END_SRC

  *Mingw* 

 Check if current compiler is GCC/Mingw, GCC compiler ported to
 Windows.

 #+BEGIN_SRC cmake
   if(MSVC)
     message("Running Mingw/GCC maybe on Windows")
   endif()
 #+END_SRC
**** Detect compiler using CMAKE_CXX_COMPILER_ID variable 

 The variable CMAKE_CXX_COMPILER_ID can be used for checking the
 current C++ compiler.
  + See: [[https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER_ID.html#variable:CMAKE_%253CLANG%253E_COMPILER_ID][Documentation]]

 #+BEGIN_SRC cmake 
    if (${CMAKE_CXX_COMPILER_ID} matches GNU)
      message(STATUS " [INFO] Using GCC - GNU C/C++ Compiler or MingW/GCC.")
    elseif(${CMAKE_CXX_COMPILER_ID} matches CLANG) 
      message(STATUS " [INFO] Using the super amazing, the finest C++ compiler: Clang++/LLVM.")
    elseif(${CMAKE_CXX_COMPILER_ID} matches MSVC)
      message(STATUS " [INFO] Using MSVC Windows 'Visual!!' C++ compiler")
    else()
      message( FATAL_ERROR " [ERROR] I cannot identify CMake Configuration not set for this compiler yet.")
    endif()
 #+END_SRC

 All possible values of ~CMAKE_CXX_COMPILER_ID~:

 | Value of ~CMAKE_CXX_COMPILER_ID~ | Compiler                                       |
 |--------------------------------+------------------------------------------------|
 | *Most used compilers*            |                                                |
 | GNU                            | GNU Compiler Collection (gcc.gnu.org)          |
 | Clang                          | LLVM Clang (clang.llvm.org)                    |
 | MSVC                           | Microsoft Visual Studio (microsoft.com)        |
 | Intel                          | Intel Compiler (intel.com)                     |
 | PGI                            | The Portland Group (pgroup.com)                |
 | G95                            | G95 Fortran (g95.org)                          |
 | Embarcadero, Borland           | Embarcadero (embarcadero.com)                  |
 | ARMCC                          | ARM Compiler (arm.com)                         |
 |                                |                                                |
 | *Other compilers*                |                                                |
 | Absoft                         | Absoft Fortran (absoft.com)                    |
 | ADSP                           | Analog VisualDSP++ (analog.com)                |
 | AppleClang                     | Apple Clang (apple.com)                        |
 | Bruce                          | Bruce C Compiler                               |
 | CCur                           | Concurrent Fortran (ccur.com)                  |
 | Cray                           | Cray Compiler (cray.com)                       |
 | HP                             | Hewlett-Packard Compiler (hp.com)              |
 | IAR                            | IAR Systems (iar.com)                          |
 | MIPSpro                        | SGI MIPSpro (sgi.com)                          |
 | NVIDIA                         | NVIDIA CUDA Compiler (nvidia.com)              |
 | OpenWatcom                     | Open Watcom (openwatcom.org)                   |
 | Flang                          | Flang Fortran Compiler                         |
 | PathScale                      | PathScale (pathscale.com)                      |
 | SDCC                           | Small Device C Compiler (sdcc.sourceforge.net) |
 | SunPro                         | Oracle Solaris Studio (oracle.com)             |
 | TI                             | Texas Instruments (ti.com)                     |
 | TinyCC                         | Tiny C Compiler (tinycc.org)                   |
 | XL, VisualAge, zOS             | IBM XL (ibm.com)                               |
*** Detect whether current build is 32 bits or 64 bits

Check whether current configuration is for 64 bits build:

#+BEGIN_SRC cmake 
 if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    message(" [INFO] 64 bits build.")
 else()
    message(" [INFO] 32 bits build.")
 endif()
#+END_SRC

*** Copy some target binaries to a directory

This piece of code copies the target binaries (compiled code) to a
directory relative to project's root directory where is CMakeLists.txt 

Targets:

#+BEGIN_SRC cmake 
  # TARGET: testlib Shared library => Builds liblinalg.so on Unix or
  # linalg.dll on Windows.
  add_library(linalg SHARED  src/testlib.cpp)

  # TARGET: app Executable => Builds 'app' on Unix-like Oses and
  # unix.exe on Windows.
  add_executable(app src/main/main-app.cpp src/main/file1.cpp src/main/file2.cpp)
#+END_SRC

Copy target files to top level directory where is CMakeLists.txt 

#+BEGIN_SRC cmake
  # If not set the install directory, attemp set the install directory
  # CMAKE_INSTALL_PREFIX to the directory ./bin 
  if(NOT DEFINED CMAKE_INSTALL_PREFIX OR CMAKE_INSTALL_PREFIX MATCHES "")
    set(CMAKE_INSTALL_PREFIX  "./bin")
  endif()

  message(" [INFO] CMakeLists.txt is in the directory ${CMAKE_CURRENT_LIST_DIR}")

  # Copy targets to ./ - Directory where is this file CMakeLists.txt (project top level dir)
  install(TARGETS app linalg DESTINATION  ${CMAKE_CURRENT_LIST_DIR})
#+END_SRC

This target can be run with: 

 + STEP 1: Set CMake building system or the project type with -G.

#+BEGIN_SRC sh 
 $ cd project-directory 

 #===> Set build system 
 # -H<SOURCE> -B<COMPILATION-OUTPUT> -G <BUILDING-SYSTEM>
 $ cmake -H. -G "Unix Makefiles" -Bbuild 
#+END_SRC
 
 + STEP 2: Run targets 

#+BEGIN_SRC sh 
 #===> Run all targets [all default.]
 $ cmake --build build --target all 

 #===> Run target install and copy the binaries to ./bin 
 $ cmake --build build --target install 
#+END_SRC

*** Create target to run compiled executable 

The piece following piece of code runs an executable target after it
is built in a similar way to a command $ make run. 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)

   ... ...  ... ...  ... ...

  # TARGET: myapplication 
  add_executable(myapplication src/main.cpp src/code1.cpp code2.cpp ...)

  # TARGET: run -> Runs the executable myapplication 
  # On Unix-like Oses, it runs  /<build-directory>/myapplication 
  # On Windows: it runs  <build-directory>/myapplication.exe 
  add_custom_target(run
      COMMAND myapplication
      DEPENDS myapplication
      WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
  )
#+END_SRC

After the building system is set and output directory ./build, run:

#+BEGIN_SRC sh 
   #===> Run all targets [all default.]
   $ cmake --build build --target run
#+END_SRC

*** Issue an error if condition is not met 

In this piece of code, if the compiler is not MSVC (vc++, aka cl.exe),
CMake stops the generation of the building script showing an error
message to the user.

#+BEGIN_SRC cmake 
  ... ... 

  if(MSVC)
     set_target_properties(WindowApp1 PROPERTIES LINK_FLAGS "/entry:mainCRTStartup")
  else() 
     message(FATAL_ERROR " [ERROR] Linker flags of target WindowApp1 not set for this compiler")
  endif()
  ... ... 
#+END_SRC
*** Copy a target file whenever it is recompiled

Example:  Copy a shared library to project root directory ./
whenever it is rebuilt. 

 + Set the shared library target. (libtestlib.so on Unix or testlib.dll
   on Windows)

#+BEGIN_SRC cmake 
  add_library( testlib  SHARED  ./testlib.cpp)
  set_target_properties(testlib PROPERTIES CXX_VISIBILITY_PRESET hidden)
#+END_SRC

 + Automatically copy to root directory the generated shared library
   binary to root directory on every recompilation of the target
   testlib. 

#+BEGIN_SRC cmake
  add_custom_command(TARGET testlib POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy 
    $<TARGET_FILE:testlib>                     # Source    
    ${CMAKE_CURRENT_SOURCE_DIR}/libtest.so     # Destination, file or directory 
    # OR: ${CMAKE_CURRENT_SOURCE_DIR}/         # Directory destination. 
  )
#+END_SRC

Test this post-build target: 

#+BEGIN_SRC sh 
  # Generate cache directory containing building scripts or project files 
  # specifics for some building systems
  $ cmake -H. -Bcache -G "CHOOSE SYSTEM>"

  # Run all targets  [Default]
  $ cmake --build cache --target
  $ cmake --build cache --target all 

  # Run target 'testlib'. 
  $ cmake --build cache --target testlib 
#+END_SRC

After the target is recompiled, the shared library is copied to the
current directory (project top-level directory ./).

References: 
 + https://stackoverflow.com/questions/31277186
 + https://stackoverflow.com/questions/15694347/
* Conan package Manager
** Main Web Sites

 + https://conan.io

 + https://jfrog.com 

** Benefits and Capabilities

Benefits: 

 + Reduce compile-time
 + Reduce library installation effort duplication
 + Increase library discoverability
 + Easier cross-compilation for different architectures
 + Host package recipes in local network or remotely 

Capabilities:

 + *Cache and reuse compilation binaries (aka object-code)*  such as intermediate
   object-code (*.o or *.obj), static libraries and shared libraries
   which reduces compile-time and effort duplication for installing
   a libraries since all projects using the same conan recipe can
   reuse the binaries.

 + *Package with embedded sources*: Sources can be embedded in a
   package. 

 + *Package with remote sources*: Conan packages (aka recipes) can fetch
   source code from remote sources such as Github, Gitlab,
   Sourceforge, FTP or even a *Conan Server* in local network.

 + Conan Recipes can build package's sources with a wide variety of tools such as:
   + GNU autotools
   + CMake
   + GNU Makefile
   + BSD Makefile 

** Videos 

Webinar JFrog: 

 * [[https://www.youtube.com/watch?v=xBLjXdyh3zs][{Webinar: Part 1 of 3} Introduction to C/C++ Package Management with Conan]]
 * [[https://www.youtube.com/watch?v=JsijdbjVlXw&feature=youtu.be][{Webinar: Part 2 of 3} Advanced package management for C/C++ with Conan]]
 * [[https://www.youtube.com/watch?v=ExpkMy6DJ6o&feature=youtu.be][{Webinar: Part 3 of 3} Modern DevOps for Modern C/C++ with Conan]] 

CppCon: 
 + [[https://www.youtube.com/watch?v=xA9yRX4Mdz0][CppCon 2017: D. Rodriguez-Losada Gonzalez “Faster Delivery of Large C/C++ Projects with...]]

** Install Conan 

Conang Github Repositories: 
 + https://github.com/conan-community

Documentation:
 + https://docs.conan.io/

Installing Conan requires a Python installation with pip.

#+BEGIN_SRC sh 
  $ pip instal conan 
#+END_SRC

The easiest way to get Python for any platform, including Windows is
through Miniconda distribution which is a lightweight version of
Python Anaconda distribution: 

 + https://docs.conda.io/en/latest/miniconda.html

Conan Extension (Addon) for Visual Studio 
 + https://docs.conan.io/en/latest/integrations/ide/visual_studio.html

Conan Plugin for JetBrains' CLION IDE: 
 + https://plugins.jetbrains.com/plugin/11956-conan

** Conan Package Repositories 

Search Conan Packages at Conan Center repository: 

Repository Lists:
 + https://docs.conan.io/en/latest/uploading_packages/remotes.html

Some Conan Repositories:

 + Main Repository: https://bintray.com/conan/conan-center
 + Others:
   + [[https://bintray.com/conan/conan-transit][Conan-Transit]]
   + [[https://bintray.com/conan-community/conan][Conan-Community]]
   + [[https://bintray.com/bincrafters/public-conan][Bincrafters]] - https://bincrafters.github.io/

** Some libraries in Conan Center

 + [[https://bintray.com/conan-community/conan/boost%253Aconan][Boost]]
 + [[https://bintray.com/pocoproject/conan/Poco%253Apocoproject][Poco libraries]]
 + [[https://bintray.com/conan-community/conan/pybind11%253Aconan][Pybind 11]]
 + [[https://bintray.com/conan-community/conan/opencv%253Aconan][OpenCV]]
 + [[https://bintray.com/bincrafters/public-conan/libcurl%253Abincrafters][LibCurl]]
 + [[https://bintray.com/bincrafters/public-conan/gtest%253Abincrafters][GoogleTest]]
 + [[https://bintray.com/conan-community/conan/lapack%253Aconan][Conan Lapack]]
 + [[https://bintray.com/conan-community/conan/zlib%253Aconan][Zlib]]
 + [[https://bintray.com/conan-community/conan/cereal%253Aconan][Cereal]]
** Command Summary 
*** Search Conan Packages 

Search for Poco libraries in Conan Center repository: 

#+BEGIN_SRC sh 
  $ conan search Poco* -r=conan-center
  Existing package recipes:

  Poco/1.7.8p3@pocoproject/stable
  Poco/1.7.9@pocoproject/stable
  Poco/1.7.9p1@pocoproject/stable
  Poco/1.7.9p2@pocoproject/stable
  Poco/1.8.0.1@pocoproject/stable
  Poco/1.8.0@pocoproject/stable
  Poco/1.8.1@pocoproject/stable
  Poco/1.9.0@pocoproject/stable
#+END_SRC

Search for Google Test in Conan Center repository: 

#+BEGIN_SRC sh 
  $ conan search gtest/* -r=conan-center
  Existing package recipes:

  gtest/1.7.0@bincrafters/stable
  gtest/1.8.0@bincrafters/stable
  gtest/1.8.1@bincrafters/stable
#+END_SRC

Search for libcurl package on BinCrafters repository:

#+BEGIN_SRC sh 
  λ conan search libcurl/* -r=bincrafters
  Existing package recipes:

  libcurl/7.50.3@bincrafters/stable
  libcurl/7.52.1@bincrafters/stable
  libcurl/7.56.1@bincrafters/stable
  libcurl/7.60.0@bincrafters/stable
  libcurl/7.61.1@bincrafters/stable
#+END_SRC

Search for pybind11 on all conan repositories:

#+BEGIN_SRC sh 
  $ conan search pybind* -r=all
  Existing package recipes:

  Remote 'conan-center':
  pybind11/2.2.2@conan/stable
  pybind11/2.2.3@conan/stable
  pybind11/2.2.4@conan/stable
  Remote 'conan-transit':
  pybind11/0.1.0@jason2506/testing
  pybind11/1.4@memsharded/stable
  pybind11/any@memsharded/stable

#+END_SRC

*** List libraries in local cache / local repository

This command lists packages in local cache or local repository.

#+BEGIN_SRC sh 
   $ conan search
   Existing package recipes:

   OpenSSL/1.0.2o@conan/stable
   Poco/1.9.0@pocoproject/stable
   gtest/1.8.1@bincrafters/stable
   zlib/1.2.11@conan/stable
#+END_SRC

List Conan storage directory ~/.conan on Unix-like (Linux, BSD, OSX ...)

#+BEGIN_SRC sh 
  $ tree -L 2  ~/.conan/
  /home/archbox/.conan/
  ├── artifacts.properties
  ├── cacert.pem
  ├── conan.conf
  ├── conan.conf.back
  ├── data
  │   ├── gtest
  │   ├── OpenSSL
  │   ├── Poco
  │   └── zlib
  ├── hooks
  │   └── attribute_checker.py
  ├── profiles
  │   └── default
  ├── registry.json
  ├── registry.json.lock
  ├── settings.yml
  └── version.txt

  7 directories, 10 files

#+END_SRC

List directory ~/.conan/data 

#+BEGIN_SRC sh 
  $ tree -L 3  ~/.conan/data
  /home/archbox/.conan/data
  ├── gtest
  │   └── 1.8.1
  │       └── bincrafters
  ├── OpenSSL
  │   └── 1.0.2o
  │       └── conan
  ├── Poco
  │   └── 1.9.0
  │       └── pocoproject
  └── zlib
      └── 1.2.11
          └── conan

  12 directories, 0 files
#+END_SRC

*** List Remote Repositories: 

#+BEGIN_SRC sh 
  $ conan remote list

  conan-center: https://conan.bintray.com [Verify SSL: True]
  conan-transit: https://conan-transit.bintray.com [Verify SSL: True]
#+END_SRC

*** Add more remote repositories 


Add Repositories: 

 + Add Conan Center (Repository installed by default)

#+BEGIN_SRC sh 
  $ conan remote add conan-center https://conan.bintray.com
#+END_SRC

 + Add Conan Community:

#+BEGIN_SRC sh 
  $ conan remote add conan-community https://api.bintray.com/conan/conan-community/conan
#+END_SRC

 + Add bincrafters

#+BEGIN_SRC sh 
  $ conan remote add bincrafters https://api.bintray.com/conan/bincrafters/public-conan
#+END_SRC

*** Install library in local cache 

Example install package libcurl version 7.61.1 from repository BinCrafters:

 + Installation on Windows 64 bits for 64 bits target. The build type
   is Release, however the installation lacks the debug building.
 + Linux, OS or Nix users don't need to be concerned about
   Debug/Release build type.

#+BEGIN_SRC sh 
  λ conan install libcurl/7.61.1@bincrafters/stable

  Configuration:
  [settings]
  arch=x86_64
  arch_build=x86_64
  build_type=Release
  compiler=Visual Studio
  compiler.runtime=MD
  compiler.version=15
  os=Windows
  os_build=Windows
  [options]
  [build_requires]
  [env]

  libcurl/7.61.1@bincrafters/stable: Not found in local cache, looking in remotes...
  libcurl/7.61.1@bincrafters/stable: Trying with 'conan-center'...
  Downloading conanmanifest.txt
  [==================================================] 234B/234B
  Downloading conanfile.py
  [==================================================] 19.4KB/19.4KB
  Downloading conan_export.tgz
  [==================================================] 764B/764B
  Decompressing conan_export.tgz: 100%|██████████| 764/764 [00:00<00:00, 46.3kB/s]
  OpenSSL/1.0.2n@conan/stable: Not found in local cache, looking in remotes...
  OpenSSL/1.0.2n@conan/stable: Trying with 'conan-center'...
  Downloading conanmanifest.txt
  [==================================================] 58B/58B
  Downloading conanfile.py
  [==================================================] 20.1KB/20.1KB
  libcurl/7.61.1@bincrafters/stable: Installing package
  Requirements
      OpenSSL/1.0.2n@conan/stable from 'conan-center' - Downloaded
      libcurl/7.61.1@bincrafters/stable from 'conan-center' - Downloaded
      zlib/1.2.11@conan/stable from 'conan-center' - Cache
  Packages
      OpenSSL/1.0.2n@conan/stable:606fdb601e335c2001bdf31d478826b644747077 - Download
      libcurl/7.61.1@bincrafters/stable:ae6191bc1194317ff7cdbc84d4d302ab49975618 - Download
      zlib/1.2.11@conan/stable:6cc50b139b9c3d27b3e9042d5f5372d327b3a9f7 - Cache

  zlib/1.2.11@conan/stable: Already installed!
  OpenSSL/1.0.2n@conan/stable: Retrieving package 606fdb601e335c2001bdf31d478826b644747077 from remote 'conan-center'
  Downloading conanmanifest.txt
  [==================================================] 4.6KB/4.6KB
  Downloading conaninfo.txt
  [==================================================] 1.2KB/1.2KB
  Downloading conan_package.tgz
  [==================================================] 5.6MB/5.6MB
  Decompressing conan_package.tgz: 100%|██████████| 5.32M/5.32M [00:00<00:00, 24.0MB/s]
  OpenSSL/1.0.2n@conan/stable: Package installed 606fdb601e335c2001bdf31d478826b644747077
  libcurl/7.61.1@bincrafters/stable: Retrieving package ae6191bc1194317ff7cdbc84d4d302ab49975618 from remote 'conan-center'
  Downloading conanmanifest.txt
  [==================================================] 1.0KB/1.0KB
  Downloading conaninfo.txt
  [==================================================] 1.8KB/1.8KB
  Downloading conan_package.tgz
  [==================================================] 704.7KB/704.7KB
  Decompressing conan_package.tgz: 100%|██████████| 688k/688k [00:00<00:00, 14.9MB/s]
  libcurl/7.61.1@bincrafters/stable: Package installed ae6191bc1194317ff7cdbc84d4d302ab49975618
#+END_SRC

Install debug build of libcurl package:

#+BEGIN_SRC sh 
  λ conan install libcurl/7.61.1@bincrafters/stable -s build_type=Debug
  Configuration:
  [settings]
  arch=x86_64
  arch_build=x86_64
  build_type=Debug
  compiler=Visual Studio
  compiler.runtime=MDd
  compiler.version=15
  os=Windows
  os_build=Windows
  [options]
  [build_requires]
  [env]

   ...  ...  ...  ...  ... 

  Decompressing conan_package.tgz: 100%|██████████| 967k/967k [00:00<00:00, 15.0MB/s]
  libcurl/7.61.1@bincrafters/stable: Package installed 8f5289d9807917ac37fa3752916c824d2a8061ad
#+END_SRC

Install debug and release build of a library compiling it from source:

#+BEGIN_SRC sh 
  λ conan install libcurl/7.61.1@bincrafters/stable -s build_type=None 
#+END_SRC

Install  release builds of libcurl for x86 target (32 bits):

#+BEGIN_SRC sh 
  λ conan install libcurl/7.61.1@bincrafters/stable -s build_type=Release -s arch=x86
  Configuration:
  [settings]
  arch=x86
  arch_build=x86_64
  build_type=Release
  compiler=Visual Studio
  compiler.runtime=MD
  compiler.version=15
  os=Windows
  os_build=Windows
  [options]
  [build_requires]
  [env]
#+END_SRC

List installed library in local cache:

#+BEGIN_SRC sh 
  λ conan search
  Existing package recipes:

  OpenSSL/1.0.2n@conan/stable
  OpenSSL/1.0.2o@conan/stable
  Poco/1.9.0@pocoproject/stable
  gtest/1.8.1@bincrafters/stable
  libcurl/7.61.1@bincrafters/stable
  zlib/1.2.11@conan/stable
#+END_SRC

*** Show pacakge information

#+BEGIN_SRC sh 
   λ conan info libcurl/7.61.1@bincrafters/stable

   OpenSSL/1.0.2n@conan/stable
       ID: 606fdb601e335c2001bdf31d478826b644747077
       BuildID: None
       Remote: conan-center=https://conan.bintray.com
       URL: http://github.com/lasote/conan-openssl
       License: The current OpenSSL licence is an 'Apache style' license: https://www.openssl.org/source/license.html
       Recipe: Cache
       Binary: Cache
       Binary remote: conan-center
       Creation date: 2018-05-10 07:47:33
       Required by:
           libcurl/7.61.1@bincrafters/stable
       Requires:
           zlib/1.2.11@conan/stable
   libcurl/7.61.1@bincrafters/stable
       ID: ae6191bc1194317ff7cdbc84d4d302ab49975618
       BuildID: None
       Remote: conan-center=https://conan.bintray.com
       URL: http://github.com/bincrafters/conan-libcurl
       Homepage: http://curl.haxx.se
       License: MIT
       Author: Bincrafters <bincrafters@gmail.com>
       Recipe: Cache
       Binary: Cache
       Binary remote: conan-center
       Creation date: 2018-11-16 03:42:43
       Required by:
           PROJECT
       Requires:
           OpenSSL/1.0.2n@conan/stable
           zlib/1.2.11@conan/stable
   zlib/1.2.11@conan/stable
       ID: 6cc50b139b9c3d27b3e9042d5f5372d327b3a9f7
       BuildID: None
       Remote: conan-center=https://conan.bintray.com
       URL: http://github.com/conan-community/conan-zlib
       Homepage: https://zlib.net
       License: Zlib
       Author: Conan Community
       Recipe: Cache
       Binary: Cache
       Binary remote: conan-center
       Creation date: 2018-12-21 02:01:48
       Required by:
           OpenSSL/1.0.2n@conan/stable
           libcurl/7.61.1@bincrafters/stable
#+END_SRC

** Example CMake/Conan project  
**** Project Files

Gist: https://gist.github.com/caiorss/5067e2981488aff1b5765b02adbfdffc 

File: *conanfile.txt* 
 + Conan project file.
 + Poco:shared=False => Static link the library.

#+BEGIN_SRC conf 
  [requires]
  Poco/1.9.0@pocoproject/stable
  gtest/1.8.1@bincrafters/stable

  [generators]
  cmake

  [options]
  Poco:shared=False
#+END_SRC

File: *CMakeLists.txt*

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.9)

   #========== Global Configurations =============#
   #----------------------------------------------#
   project(ConanTesting CXX)
   set(CMAKE_CXX_STANDARD 17)     
   set(CMAKE_VERBOSE_MAKEFILE ON)

   # ===>> Conan bootstrap  ===============

   # Automatically install conan packages if they are not installed.
   # Assumptions:
   #  + The file conanfile.txt is in this directory
   #  + This CMakeLists.txt file is in the project ROOT directory.
   #  + The conan application is the project $PATH environment variable
   #    and accessible from command line.
   #-------------------------------------------------
   if(NOT EXISTS "${CMAKE_BINARY_DIR}/conanbuildinfo.cmake")
     execute_process(
       COMMAND           conan install . --install-folder "${CMAKE_BINARY_DIR}"
       WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}
    )
   endif()

   include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)
   conan_basic_setup()

   #========== Targets Configurations ============#

   message(" [INFO] =>> CONAN_LIBS = ${CONAN_LIBS} " )

   # ==> Target for testing POCO Libraries 
   add_executable(poco demo-poco.cpp)
   target_link_libraries(poco PRIVATE ${CONAN_LIBS})

   # ==> Target for testing GogleTest 
   add_executable(agtest demo-gtest.cpp)
   target_link_libraries(agtest PRIVATE ${CONAN_LIBS})

   # Add target to run executable 
   add_custom_target(run-poco
     COMMAND poco 
     DEPENDS poco 
     WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
     )

   add_custom_target(run-gtest
     COMMAND agtest 
     DEPENDS agtest 
     WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
     )

   install(TARGETS poco agtest  DESTINATION ./bin)
#+END_SRC

File: *demo-gtest.cpp*

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <Poco/Process.h>
  #include <gtest/gtest.h>

  auto FunctionObject = [](int n){ return 5 * n + 4; };

  TEST(testA, FunctionObject)
  {
      EXPECT_EQ(19, FunctionObject(3));
  }

  TEST(testC, FunctionObject)
  {
      EXPECT_EQ(123, FunctionObject(5));
  }

  TEST(testB, FunctionObject)
  {
      EXPECT_EQ(24, FunctionObject(4));
  }
#+END_SRC

File: *demo-poco.cpp*

#+BEGIN_SRC cpp
   #include <iostream>
   #include <Poco/Process.h>

   int main()
   {
       std::cout << "Running POCO Libraries Launch." << std::endl;
       std::cout << "Poco Libraries are AWESOME!" << std::endl;

       #if !defined(_WIN32)
         std::cerr << " [INFO] I am running on some Unix-like Operating System." << std::endl;
         Poco::Process::launch("cat", {"/etc/protocols"});
      #else
         std::cerr << " [INFO] I am running on Windows." << std::endl;
         Poco::Process::launch("notepad.exe", {});
      #endif
      return 0;
   }
#+END_SRC
**** Building on Windows 

Install Conan packages in the current project at directory ./build/ -
the packages are download from the default remote repository and
stored at the Conan cache. Once they were downloaded, further usages
of those packages will use them from the cache.

#+BEGIN_SRC sh 
  $  conan install . --install-folder build 

  Configuration:
  [settings]
  arch=x86_64
  arch_build=x86_64
  build_type=Release
  compiler=Visual Studio
  compiler.runtime=MD
  compiler.version=15
  os=Windows
  os_build=Windows
  [options]
  [build_requires]
  [env]

  gtest/1.8.1@bincrafters/stable: WARN: Package is corrupted, removing folder: C:\Users\archbox\.conan\data\gtest\1.8.1\bincrafters\stable\package\3f7b6d42d6c995a23d193db1f844ed23ae943226
  PROJECT: Installing C:\Users\archbox\conan-test\conanfile.txt
  Requirements
      OpenSSL/1.0.2o@conan/stable from 'conan-center' - Cache
      Poco/1.9.0@pocoproject/stable from 'conan-center' - Cache
      gtest/1.8.1@bincrafters/stable from 'conan-center' - Cache
      zlib/1.2.11@conan/stable from 'conan-center' - Cache
  Packages
      OpenSSL/1.0.2o@conan/stable:606fdb601e335c2001bdf31d478826b644747077 - Download
      Poco/1.9.0@pocoproject/stable:09378ed7f51185386e9f04b212b79fe2d12d005c - Download
      gtest/1.8.1@bincrafters/stable:3f7b6d42d6c995a23d193db1f844ed23ae943226 - Download
      zlib/1.2.11@conan/stable:6cc50b139b9c3d27b3e9042d5f5372d327b3a9f7 - Download

   ... ....    ... ....    ... ....    ... ....    ... ....    ... ....    ... .... 

  Poco/1.9.0@pocoproject/stable: Package installed 09378ed7f51185386e9f04b212b79fe2d12d005c
  PROJECT: Generator cmake created conanbuildinfo.cmake
  PROJECT: Generator txt created conanbuildinfo.txt
  PROJECT: Generated conaninfo.txt
  PROJECT: Generated graphinfo
#+END_SRC

List ./build directory: 

#+BEGIN_SRC sh 
  λ ls build\
  conanbuildinfo.cmake  conanbuildinfo.txt  conaninfo.txt  graph_info.json
#+END_SRC

Check project packages:

#+BEGIN_SRC sh 
   $ conan info .

   PROJECT
       ID: 78e985959974aade35877b722f1e41355f5575f4
       BuildID: None
       Requires:
           Poco/1.9.0@pocoproject/stable
   OpenSSL/1.0.2o@conan/stable
       ID: 35ea421ef4c1d32898da44c28e3cc900bc6459dc
       BuildID: None
       Remote: conan-center=https://conan.bintray.com
       URL: http://github.com/lasote/conan-openssl
       License: The current OpenSSL licence is an 'Apache style' license: https://www.openssl.org/source/license.html
       Recipe: Cache
       Binary: Cache
       Binary remote: conan-center
       Creation date: 2018-08-27 04:12:47
       Required by:
           Poco/1.9.0@pocoproject/stable
       Requires:
           zlib/1.2.11@conan/stable
   Poco/1.9.0@pocoproject/stable
       ID: 67516f54281f3227d74b2b66f92537d98ff1103d
       BuildID: None
       Remote: conan-center=https://conan.bintray.com
       URL: http://github.com/pocoproject/conan-poco
       License: The Boost Software License 1.0
       Recipe: Cache
       Binary: Cache
       Binary remote: conan-center
       Creation date: 2018-08-30 08:28:08
       Required by:
           PROJECT
       Requires:
           OpenSSL/1.0.2o@conan/stable
   zlib/1.2.11@conan/stable
       ID: 1d877a3df840030e6a8abb74c5ffb9088d08b47a
       BuildID: None
       Remote: conan-center=https://conan.bintray.com
       URL: http://github.com/conan-community/conan-zlib
       Homepage: https://zlib.net
       License: Zlib
       Author: Conan Community
       Recipe: Cache
       Binary: Cache
       Binary remote: conan-center
       Creation date: 2018-12-21 07:01:48
       Required by:
           OpenSSL/1.0.2o@conan/stable
#+END_SRC

Configure CMake on Windows for 64 bits target:

#+BEGIN_SRC sh
  λ cmake -H. -Bbuild -G "Visual Studio 15 2017 Win64" -DCMAKE_INSTALL_PREFIX=.
#+END_SRC

Compile with release build and install at ./bin:

#+BEGIN_SRC sh 
  λ cmake --build build --target install --config Release

    ...  ...  ...  ...  ...  ...  ...  ...  ... 
  PostBuildEvent:
    setlocal
    "C:\Program Files\CMake\bin\cmake.exe" -DBUILD_TYPE=Release -P cmake_install.cmake
    if %errorlevel% neq 0 goto :cmEnd
    :cmEnd
    endlocal & call :cmErrorLevel %errorlevel% & goto :cmDone
    :cmErrorLevel
    exit /b %1
    :cmDone
    if %errorlevel% neq 0 goto :VCEnd
    :VCEnd
    -- Install configuration: "Release"
    -- Installing: C:/Users/archbox/conan-test/./bin/poco.exe
    -- Installing: C:/Users/archbox/conan-test/./bin/agtest.exe
  FinalizeBuildStatus:
    Deleting file "x64\Release\INSTALL\INSTALL.tlog\unsuccessfulbuild".
    Touching "x64\Release\INSTALL\INSTALL.tlog\INSTALL.lastbuildstate".
  Done Building Project "C:\Users\archbox\conan-test\build\install.vcxproj" (default targets).


  Build succeeded.
      0 Warning(s)
      0 Error(s)

  Time Elapsed 00:00:11.72
#+END_SRC

List directory ./bin 

#+BEGIN_SRC sh 
  λ where ls
  C:\Program Files\Git\usr\bin\ls.exe

  λ ls bin
  agtest.exe*  poco.exe*
#+END_SRC

Run application bin/agtest.exe:

#+BEGIN_SRC sh 
   λ bin\agtest.exe
   Running main() from gmock_main.cc
   [==========] Running 3 tests from 3 test cases.
   [----------] Global test environment set-up.
   [----------] 1 test from testA
   [ RUN      ] testA.FunctionObject
   [       OK ] testA.FunctionObject (0 ms)
   [----------] 1 test from testA (0 ms total)

   [----------] 1 test from testC
   [ RUN      ] testC.FunctionObject
   C:\Users\archbox\conan-test\demo-gtest.cpp(14): error: Expected equality of these values:
     123
     FunctionObject(5)
       Which is: 29
   [  FAILED  ] testC.FunctionObject (0 ms)
   [----------] 1 test from testC (0 ms total)

   [----------] 1 test from testB
   [ RUN      ] testB.FunctionObject
   [       OK ] testB.FunctionObject (0 ms)
   [----------] 1 test from testB (0 ms total)

   [----------] Global test environment tear-down
   [==========] 3 tests from 3 test cases ran. (4 ms total)
   [  PASSED  ] 2 tests.
   [  FAILED  ] 1 test, listed below:
   [  FAILED  ] testC.FunctionObject

    1 FAILED TEST

#+END_SRC

Note: Due to the following code in CMakeLists.txt, it is not needed to
run the command conan-install before cmake to install the packages as
this block will automatically run the conan-install command if the
packages are not installed in the project ./build directory. It allows
to configure CMake in a single step with $ cmake -Bbuild ... or open the
project in an IDE which supports CMake without running conan directly.

 + Summary: with this piece of code, it is not necessary to run conan,
   Cmake will run it automatically as a subprocess.

#+BEGIN_SRC cmake
   if(NOT EXISTS "${CMAKE_BINARY_DIR}/conanbuildinfo.cmake")
     execute_process(
       COMMAND           conan install . --install-folder "${CMAKE_BINARY_DIR}"
       WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}
    )
   endif()
#+END_SRC
**** Building on Linux 

Clone gist:

#+BEGIN_SRC sh
  $ git clone https://gist.github.com/caiorss/5067e2981488aff1b5765b02adbfdffc conan-test2
  Cloning into 'conan-test2'...
  remote: Enumerating objects: 8, done.
  remote: Counting objects: 100% (8/8), done.
  remote: Compressing objects: 100% (7/7), done.
  remote: Total 8 (delta 1), reused 3 (delta 1), pack-reused 0
  Unpacking objects: 100% (8/8), done.

#+END_SRC

List directory:

#+BEGIN_SRC sh
  $ ls
  CMakeLists.txt  conanfile.txt  demo-gtest.cpp  demo-poco.cpp
#+END_SRC

CMake configuration step:
 + Note: The CMakeLists.txt file is set to automatically run Conan in the
   build directory. 
 + Note: The packages weren't download because they are already
   cached.

#+BEGIN_SRC sh
  $ cmake -H. -Bbuild -G Ninja -DCMAKE_INSTALL_PREFIX=.
  -- Current conanbuildinfo.cmake directory: /home/archbox/root-scripts/conan-test2/build
  -- Conan: Compiler GCC>=5, checking major version 8
  -- Conan: Checking correct version: 8
  -- Conan: Using cmake global configuration
  -- Conan: Adjusting default RPATHs Conan policies
  -- Conan: Adjusting language standard
   [INFO] =>> CONAN_LIBS = PocoMongoDB;PocoNet;PocoNetSSL;PocoCrypto;PocoData;PocoDataSQLite;PocoZip;PocoUtil;PocoXML;PocoJSON;PocoFoundation;rt;gmock_main;gmock;gtest;pthread;ssl;crypto;dl;z 
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/conan-test2/build


  $ ls build/
  bin/         CMakeCache.txt        conanbuildinfo.txt  rules.ninja
  CMakeFiles/  cmake_install.cmake   conaninfo.txt
  build.ninja  conanbuildinfo.cmake  graph_info.json
#+END_SRC

Run all targets: (build all executables and libraries)

#+BEGIN_SRC sh 
  $ cmake --build build --target
  [4/4] Linking CXX executable bin/agtest
#+END_SRC

Install: 

#+BEGIN_SRC sh 
  $ cmake --build build --target install
  [0/1] Install the project...
  -- Install configuration: ""
  -- Installing: /home/archbox/root-scripts/conan-test2/./bin/poco
  -- Set runtime path of "/home/archbox/root-scripts/conan-test2/./bin/poco" to ""
  -- Installing: /home/archbox/root-scripts/conan-test2/./bin/agtest
  -- Set runtime path of "/home/archbox/root-scripts/conan-test2/./bin/agtest" to ""

  $ ls bin/
  agtest*  poco*
#+END_SRC

Run the executable bin/agtest.

#+BEGIN_SRC sh 
  $ bin/agtest --gtest_list_tests
  Running main() from gmock_main.cc
  testA.
    FunctionObject
  testC.
    FunctionObject
  testB.
    FunctionObject


  $ bin/agtest 
  Running main() from gmock_main.cc
  [==========] Running 3 tests from 3 test cases.
  [----------] Global test environment set-up.
  [----------] 1 test from testA
  [ RUN      ] testA.FunctionObject
  [       OK ] testA.FunctionObject (0 ms)
  [----------] 1 test from testA (0 ms total)

  ... ... .... 

   1 FAILED TEST
#+END_SRC

Run the executable bin/poco

#+BEGIN_SRC 
   $ # /etc/protocols:
   # $Id: protocols,v 1.12 2016/07/08 12:27 ovasik Exp $
   #
   # Internet (IP) protocols
   #
   #	from: @(#)protocols	5.1 (Berkeley) 4/17/89
   #
   # Updated for NetBSD based on RFC 1340, Assigned Numbers (July 1992).
   # Last IANA update included dated 2011-05-03
   #
   # See also http://www.iana.org/assignments/protocol-numbers

   ip	0	IP		# internet protocol, pseudo protocol number
   hopopt	0	HOPOPT		# hop-by-hop options for ipv6

   ... .... ... ... .... ... ... .... ... ... .... ... ... .... ... 
#+END_SRC
** Example CMake/Conan project with conan-cmake module 
**** Project Files 

This sample project uses the CMake wrapper [[https://github.com/conan-io/cmake-conan][cmake-conan]] for integrating
Conan and CMake without the file conanfile.txt or running conan from
command line before using CMake. 

CMake Module cmake-conan: 
 + https://github.com/conan-io/cmake-conan

Project Gist: 
 + https://gist.github.com/caiorss/7b0732f5de5ebc40981521e63a122d8e

Packages used in this sample project: (Conan reference)
 + [[https://bintray.com/bincrafters/public-conan/gtest%253Abincrafters/1.8.1%253Astable][gtest/1.8.1@bincrafters/stable]]
 + [[https://bintray.com/pocoproject/conan/Poco%253Apocoproject/1.9.0%253Astable][Poco/1.9.0@pocoproject/stable]]


This project can be downloaded with: 

#+BEGIN_SRC sh 
  # Clone repository 
  $ git clone https://gist.github.com/caiorss/7b0732f5de5ebc40981521e63a122d8e gist 
  $ cd gist 
 
  # Open in QTCreator IDE 
  $ qtcrator CMakeLists.txt 
#+END_SRC

 *File: CMakeLists.txt* 

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)

  #========== Global Configurations =============#
  #----------------------------------------------#
  project(ConanTesting CXX)
  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  # ============= Conan Bootstrap =============================#

  # Download automatically, you can also just copy the conan.cmake file
  if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
     message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
     file(DOWNLOAD "https://github.com/conan-io/cmake-conan/raw/v0.13/conan.cmake"
                   "${CMAKE_BINARY_DIR}/conan.cmake")
  endif()

  include(${CMAKE_BINARY_DIR}/conan.cmake)

  conan_cmake_run(REQUIRES

                  # Libraries to be installed locally
                  Poco/1.9.0@pocoproject/stable
                  gtest/1.8.1@bincrafters/stable

                  BASIC_SETUP
                  BUILD missing
                  )

  #========== Find Packages =====================#

  find_package(GTest REQUIRED)

  # find_package(Poco  REQUIRED Foundation)

  #========== Targets Configurations ============#


  # ==> Target for testing POCO Libraries 
  add_executable(poco demo-poco.cpp)
  target_link_libraries(poco PRIVATE ${CONAN_LIBS})

  # ==> Target for testing GogleTest 
  add_executable(agtest demo-gtest.cpp)
  target_link_libraries(agtest PRIVATE GTest::GTest GTest::Main)
  add_test(MyGoogleTest agtest)

  install(TARGETS poco agtest  DESTINATION ./bin)
#+END_SRC

 *File: demog-gtest.cpp* 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <Poco/Process.h>
  #include <gtest/gtest.h>

  auto FunctionObject = [](int n){ return 5 * n + 4; };

  TEST(testA, FunctionObject)
  {
          EXPECT_EQ(19, FunctionObject(3));
  }

  TEST(testC, FunctionObject)
  {
          EXPECT_EQ(123, FunctionObject(5));
  }

  TEST(testB, FunctionObject)
  {
          EXPECT_EQ(24, FunctionObject(4));
  }
#+END_SRC

 *File: poco-test.cpp* 

#+BEGIN_SRC cpp 
  #include <iostream>
  #include <Poco/Process.h>

  int main()
  {
      std::cout << "Running POCO Libraries Launch." << std::endl;
      std::cout << "Poco Libraries are AWESOME!" << std::endl;

      #if !defined(_WIN32)
        std::cerr << " [INFO] I am running on some Unix-like Operating System." << std::endl;
        Poco::Process::launch("cat", {"/etc/protocols"});
     #else
        std::cerr << " [INFO] I am running on Windows." << std::endl;
        Poco::Process::launch("notepad.exe", {});
      #endif

     return 0;
  }
#+END_SRC

**** Building on Linux/Unix 

Clone repository: 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/caiorss/7b0732f5de5ebc40981521e63a122d8e gist 
  Cloning into 'gist'...
  remote: Enumerating objects: 8, done.
  remote: Counting objects: 100% (8/8), done.
  remote: Compressing objects: 100% (8/8), done.
  remote: Total 8 (delta 1), reused 0 (delta 0), pack-reused 0
  Unpacking objects: 100% (8/8), done.
#+END_SRC

Show project files: 

#+BEGIN_SRC sh 
  $ ls gist/
  CMakeLists.txt  demo-gtest.cpp  demo-poco.cpp
#+END_SRC

CMake - configuration => Generate project files. 

 + $ cmake -Hgist -Bcache -GNinja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=.
   * -Hgist
     * => Set source code location to directory ./gist
   * -Bcache
     * => Set binary output directory to ./cache
   * -GNinja
     + => Use Ninja build instead of Makefile
   * -DCMAKE_BUILD_TYPE=Debug
     + => Enable debug build which generates debugging symbols and disable optimization.
   * -DCMAKE_INSTALL_PREFIX=.
     + => Set install directory to current directory (PWD)

#+BEGIN_SRC sh 
  $ cmake -Hgist -Bcache -GNinja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=. 

  -- The CXX compiler identification is GNU 8.3.1
  -- Check for working CXX compiler: /usr/lib64/ccache/c++
  -- Check for working CXX compiler: /usr/lib64/ccache/c++ -- works
  -- Detecting CXX compiler ABI info
  -- Detecting CXX compiler ABI info - done
  -- Detecting CXX compile features
  -- Detecting CXX compile features - done
  -- Downloading conan.cmake from https://github.com/conan-io/cmake-conan
  -- Conan: Automatic detection of conan settings from cmake
  -- Conan: Settings= -s;build_type=Debug;-s;compiler=gcc;-s;compiler.version=8;-s;compiler.libcxx=libstdc++11
  -- Conan executing: conan install . -s build_type=Debug -s compiler=gcc -s compiler.version=8 -s compiler.libcxx=libstdc++11 -g=cmake --build=missing
  -- Configuration:
  [settings]
  arch=x86_64
  arch_build=x86_64
  build_type=Debug
  compiler=gcc
  compiler.libcxx=libstdc++11
  compiler.version=8
  os=Linux
  os_build=Linux
  [options]
  [build_requires]
  [env]

  conanfile.txt: Installing package
  Requirements
      OpenSSL/1.0.2o@conan/stable from 'conan-center' - Cache
      Poco/1.9.0@pocoproject/stable from 'conan-center' - Cache
      gtest/1.8.1@bincrafters/stable from 'conan-center' - Cache
      zlib/1.2.11@conan/stable from 'conan-center' - Cache
  Packages
      OpenSSL/1.0.2o@conan/stable:9c111a8074926a7147291383e3d366f41bac77b3 - Cache
      Poco/1.9.0@pocoproject/stable:5d73f6d80f86b797938bd4121e0ee66b325e7063 - Cache
      gtest/1.8.1@bincrafters/stable:884a98ecd973519f5d71b74c29f9e7ddcbd902d4 - Cache
      zlib/1.2.11@conan/stable:761432f3453a17c960259b5b2605153e3bcffd7d - Cache

  gtest/1.8.1@bincrafters/stable: Already installed!
  zlib/1.2.11@conan/stable: Already installed!
  OpenSSL/1.0.2o@conan/stable: Already installed!
  Poco/1.9.0@pocoproject/stable: Already installed!
  conanfile.txt: Generator cmake created conanbuildinfo.cmake
  conanfile.txt: Generator txt created conanbuildinfo.txt
  conanfile.txt: Generated conaninfo.txt
  conanfile.txt: Generated graphinfo

  -- Conan: Loading conanbuildinfo.cmake
  -- Conan: Adjusting output directories
  -- Conan: Using cmake global configuration
  -- Conan: Adjusting default RPATHs Conan policies
  -- Conan: Adjusting language standard
  -- Current conanbuildinfo.cmake directory: /home/archbox/projects/cache
  -- Conan: Compiler GCC>=5, checking major version 8
  -- Conan: Checking correct version: 8
  -- Found GTest: /home/archbox/.conan/data/gtest/1.8.1/bincrafters/stable/package/884a98ecd973519f5d71b74c29f9e7ddcbd902d4/lib/libgtestd.a  
  -- Looking for C++ include pthread.h
  -- Looking for C++ include pthread.h - found
  -- Looking for pthread_create
  -- Looking for pthread_create - not found
  -- Looking for pthread_create in pthreads
  -- Looking for pthread_create in pthreads - not found
  -- Looking for pthread_create in pthread
  -- Looking for pthread_create in pthread - found
  -- Found Threads: TRUE  
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/archbox/projects/cache

#+END_SRC

Show cache directory: 

#+BEGIN_SRC sh 
  $ tree -L 2 cache
  cache
  ├── bin
  │   ├── agtest
  │   └── poco
  ├── build.ninja
  ├── CMakeCache.txt
  ├── CMakeFiles
  │   ├── 3.14.3
  │   ├── agtest.dir
  │   ├── CheckLibraryExists
  │   ├── cmake.check_cache
  │   ├── CMakeError.log
  │   ├── CMakeOutput.log
  │   ├── CMakeTmp
  │   ├── feature_tests.bin
  │   ├── feature_tests.cxx
  │   ├── poco.dir
  │   └── TargetDirectories.txt
  ├── cmake_install.cmake
  ├── conanbuildinfo.cmake
  ├── conanbuildinfo.txt
  ├── conan.cmake
  ├── conanfile.txt
  ├── conaninfo.txt
  ├── graph_info.json
  └── rules.ninja

  7 directories, 18 files
#+END_SRC

Build all targets: 

#+BEGIN_SRC sh 
  $ cmake --build cache --target 
  [4/4] Linking CXX executable bin/agtest
#+END_SRC

Run executable agtest (GoogleTest)

#+BEGIN_SRC sh 
 $ cache/bin/agtest  
#+END_SRC

Run executable poco

#+BEGIN_SRC sh 
  $ cache/bin/poco 
#+END_SRC

Install: 

#+BEGIN_SRC sh 
  $ cmake --build cache --target install
  [0/1] Install the project...
  -- Install configuration: "Debug"
  -- Installing: /home/archbox/projects/./bin/poco
  -- Set runtime path of "/home/archbox/projects/./bin/poco" to ""
  -- Installing: /home/archbox/projects/./bin/agtest
  -- Set runtime path of "/home/archbox/projects/./bin/agtest" to ""

 $ ls bin/
 agtest*  poco*

 # Run app ./agtest 
 $ bin/agtest 
  
 # Run app poco 
 $ bin/poco 
#+END_SRC
* Vcpkg package manager 
** Documentation 

 + VCPKG Faq: [[https://github.com/Microsoft/vcpkg/blob/master/docs/about/faq.md][Frequently Asked Questions]]

** Windows Vcpkg Intallation 

Assumption: Visual studio development tools are already installed.

1 Download and install VCPKG 
 + Note: Assumes that vcpkg will be installed at ~C:\vcpkg~

#+BEGIN_SRC sh 
  $ cd C:\
  $ git clone https://github.com/Microsoft/vcpkg
  $ cd vcpkg/
  $ bootstrap-vcpkg.bat
#+END_SRC

2 Run the command Windows Key + R or execute from the terminal the
   following command. It opens the environment variables Window.

#+BEGIN_SRC sh 
  $ rundll32.exe sysdm.cpl,EditEnvironmentVariables
#+END_SRC

3 Set the following environment variables.

 + Set PATH to ~%PATH%;C:\vcpkg~
 + Add new variable VCPKG_ROOT and set it to: ~C:\vcpkg~


4 Test installation. Open a new terminal and enter:

#+BEGIN_SRC sh
  # Show where is the vcpkg.exe executable 
  C:\Users\archbox> where vcpkg
  C:\vcpkg\vcpkg.exe

  # Check whether environment variable VCPKG_ROOT is set:
  C:\Users\archbox> echo %VCPKG_ROOT%
  C:\vcpkg

  # List installed package 
  C:\Users\archbox>vcpkg list
  freeglut:x64-windows                               3.0.0-5          Open source implementation of GLUT with source a...
  freeglut:x86-windows                               3.0.0-5          Open source implementation of GLUT with source a...
  libjpeg-turbo:x86-windows                          1.5.3-1          libjpeg-turbo is a JPEG image codec that uses SI...
  libpng:x86-windows                                 1.6.35-1         libpng is a library implementing an interface fo...
  opengl:x86-windows                                 0.0-5            Open Graphics Library (OpenGL)[3][4][5] is a cro...
  pybind11:x64-windows                               2.2.3-1          pybind11 is a lightweight header-only library th...
  python3:x64-windows                                3.6.4-2          The Python programming language as an embeddable...
  zlib:x86-windows                                   1.2.11-3         A compression library
#+END_SRC

** Linux Vcpkg Installation

1 Create install directory 
  + In this instruction: VCPKG will be installed at directory
    $HOME/opt/vcpkg or ~/home/<<MY-USER>/opt/vcpkg/~

#+BEGIN_SRC sh 
  $ mkdir -p ~/opt && cd ~/opt
#+END_SRC

2 Download and compile VCPKG 

#+BEGIN_SRC sh 
  $ git clone https://github.com/Microsoft/vcpkg
  $ cd vcpkg/
  $ sh bootstrap-vcpkg.sh 
#+END_SRC

#+RESULTS:

3 Run VCPKG:

#+BEGIN_SRC sh 
  $ ./vcpkg
  Commands:
    vcpkg search [pat]              Search for packages available to be built
    vcpkg install <pkg>...          Install a package
    vcpkg remove <pkg>...           Uninstall a package
    vcpkg remove --outdated         Uninstall all out-of-date packages
    vcpkg list                      List installed packages
    vcpkg update                    Display list of packages for updating

    ... ... ... ... ... ....   ... . .. ... . .. ... .. .... 

  For more help (including examples) see the accompanying README.md.
#+END_SRC

4 Add VCPKG to search $PATH variable in order to be able to call it
from any directory.

 + Edit: ~/.bashrc or ~/.bash_profile and add the following code and
   restart the REPL.

#+BEGIN_SRC sh 
  # Directory where installed VCPKG
  export VCPKG_ROOT=$HOME/opt/vcpkg/

  # Make vcpkg tool callable from anywhere 
  export PATH=$PATH:$VCPKG_ROOT
 #+END_SRC
** Show all available packages

 + $ vcpkg search 

#+BEGIN_SRC sh 
  $ vcpkg search 

  3fd                  2.6.2            C++ Framework For Fast Development
  abseil               2018-11-08-1     an open-source collection designed to augment the C++ standard library. Abseil...
  ace                  6.5.3            The ADAPTIVE Communication Environment
  aixlog               1.2.1            Header-only C++ logging library 
  alac                 2017-11-03-c3... The Apple Lossless Audio Codec (ALAC) is a lossless audio codec developed by A...
  alac-decoder         0.2              ALAC C implementation of a decoder, written from reverse engineering the file ...
  alembic              1.7.10           Alembic is an open framework for storing and sharing scene data that includes ...
  allegro5             5.2.4.0          Allegro is a cross-platform library mainly aimed at video game and multimedia ...

   ... ...  ... ...  ... ...  ... ...  ... ...  ... ...  ... ... 

  aws-sdk-cpp[waf]                      C++ SDK for the AWS waf service
  aws-sdk-cpp[waf-regional]             C++ SDK for the AWS waf-regional service
  aws-sdk-cpp[workdocs]                 C++ SDK for the AWS workdocs service
  aws-sdk-cpp[workmail]                 C++ SDK for the AWS workmail service
  aws-sdk-cpp[workspaces]               C++ SDK for the AWS workspaces service
  aws-sdk-cpp[xray]                     C++ SDK for the AWS xray service

   ... ...  ... ...  ... ...  ... ...  ... ...  ... ...  ... ... 

  boost-polygon        1.68.0           Boost polygon module
  boost-pool           1.68.0           Boost pool module
  boost-predef         1.68.0           Boost predef module
  boost-preprocessor   1.68.0           Boost preprocessor module
  boost-process        1.68.0           Boost process module
  boost-program-opt... 1.68.0           Boost program_options module
  boost-property-map   1.68.0           Boost property_map module
  boost-property-tree  1.68.0           Boost property_tree module
  boost-proto          1.68.0           Boost proto module
  boost-ptr-container  1.68.0           Boost ptr_container module
  boost-python         1.68.0-2         Boost python module
  boost-qvm            1.68.0           Boost qvm module
  boost-random         1.68.0           Boost random module
  boost-range          1.68.0           Boost range module

   ... ...  ... ...  ... ...  ... ...  ... ...  ... ...  ... ... 

#+END_SRC
** Removing package 

#+BEGIN_SRC sh 
  $ vcpkg.exe remove libjpeg-turbo:x86-windows
  Your feedback is important to improve Vcpkg! Please take 3 minutes to complete our survey by running: vcpkg contact --survey
  The following packages will be removed:
      libjpeg-turbo:x86-windows
  Removing package libjpeg-turbo:x86-windows...
  Removing package libjpeg-turbo:x86-windows... done
  Purging package libjpeg-turbo:x86-windows...
  Purging package libjpeg-turbo:x86-windows... done
#+END_SRC
** Example: Project with spdlog and Boost Ublas 

File: *CMakeLists.txt*

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)

  if(DEFINED ENV{VCPKG_ROOT} AND NOT DEFINED CMAKE_TOOLCHAIN_FILE)
    set(CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"
      CACHE STRING "")
    message(" [INFO] VCPKG CMAKE_TOOLCHAIN_FILE = ${CMAKE_TOOLCHAIN_FILE}")
  endif()

  #========== Global Configurations =============#
  #----------------------------------------------#
  project(SpdLogVCPKGTest)
  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  #========== Targets Configurations ============#

  # Build an executable (Unix-like OSes generates ./AppDemo1, on
  # Windows ./opengDemo1.exe)
  # ..........................................
  find_package(spdlog CONFIG REQUIRED)
  add_executable(AppDemo1 demo.cpp)
  target_link_libraries(AppDemo1 PRIVATE spdlog::spdlog)

  # Add target to run executable 
  add_custom_target(run-app
    COMMAND AppDemo1 
    DEPENDS AppDemo1 
    WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
    )

  install(TARGETS AppDemo1 DESTINATION ./bin)
  if(WIN32)
    # Install DLL depedency.
    # The only way to know the required dependencies is to
    # take a look at the build tree directory <<BUILD-TREE>>\Debug
    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/Debug/fmtd.dll
      DESTINATION "bin")
  endif()
#+END_SRC

File: *demo.cpp*

#+BEGIN_SRC cpp
  #include <iostream>
  #include <spdlog/spdlog.h>
  #include <spdlog/sinks/stdout_sinks.h>

  // Headers for vectors 
  #include <boost/numeric/ublas/vector.hpp>
  #include <boost/numeric/ublas/io.hpp>

  namespace ub = boost::numeric::ublas;

  int main(){
      auto console = spdlog::stdout_logger_mt("stdout-console");
      console->info("Testing logging information to command line");

      console->info("Welcome to spdlog version {}.{}.{} !", SPDLOG_VER_MAJOR, SPDLOG_VER_MINOR, SPDLOG_VER_PATCH);
      console->warn("Easy padding in numbers like {:08d}", 12);
      console->critical("Support for int: {0:d};  hex: {0:x};  oct: {0:o}; bin: {0:b}", 42);
      console->info("Support for floats {:03.2f}", 1.23456);
      console->info("Positional args are {1} {0}..", "too", "supported");
      console->info("{:>8} aligned, {:<8} aligned", "right", "left");

      ub::vector<double> vec1(3, 2.2) ; vec1[2] = -5.1;
      ub::vector<double> vec2(3, -1.2); vec2[2] = 1.1;

      std::cout << "Vec1 = " << vec1 << std::endl;
      std::cout << "3.0 * Vec1 = " << 3.0 * vec1 << std::endl;
      std::cout << "Norm1(Vec1) = " << ub::norm_1(vec1) << std::endl;
      std::cout << "Vec2 - Vec1 = " << vec2 - vec1 << std::endl;

      std::cout << "\n Enter RETURN to exit" << std::endl;
      std::cin.get();
      return 0;
  }
#+END_SRC

Install Vcpkg libraries Boost Ublas and spdlog: 

#+BEGIN_SRC sh 
  # Windows installation 
  $ vcpkg install spdlog:x64-windows
  $ vcpkg install boost-ublas:x64-windows

  # Installation on Linux, OSX, or any other Unix-like OS. 
  $ vcpkg install spdlog
  $ vcpkg install boost-ublas
#+END_SRC

 *Visual Studio*

 + The project can be compiled, modified, debugged and managed by
   opening it with Visual Studio as a directory or by invoking Visual
   Studio form command developer command prompt with the following
   command.

#+BEGIN_SRC sh 
  # devenv <PATH-TO-PROJECT DIRECTORY>

  # Assumes that the current directory is the project top directory
  $ devenv .
#+END_SRC

All CMake Targets can be viewed from the VS Solution Explorer.

#+CAPTION: Visual Studio Solution Explorer - CMake Targets 
[[file:images/solution-explorer-visual-spdlog.png][file:images/solution-explorer-visual-spdlog.png]]

#+CAPTION: Running CMake project from Visual Studio.
[[file:images/cmake-project-vs-spdlog.png][file:images/cmake-project-vs-spdlog.png]]

 *Manual Compilation - CMake Configuration Step*

CMake Configuration on Windows with Visual Studio building tools as backed:

 + In the project directory run: 

#+BEGIN_SRC sh 
  $ cmake -H. -Bbuild -G "Visual Studio 15 2017 Win64" -DCMAKE_INSTALL_PREFIX=.
#+END_SRC

CMake Configuration on Linux using Makefiles: 

#+BEGIN_SRC sh 
  # Configuration using Makefiles 
  $ cmake -H. -Bbuild -DCMAKE_INSTALL_PREFIX=.

  # Configuration using Ninja building system 
  $ cmake -H. -Bbuild -G Ninja -DCMAKE_INSTALL_PREFIX=.
#+END_SRC

 *Manual Compilation - CMake Building Step*

Building all CMake targets (compilation targets to build executables
and libraries):

#+BEGIN_SRC sh 
  $ cmake --build build --target 
#+END_SRC

Run install target on Windows:

#+BEGIN_SRC sh 
  $ cmake --build build --target install 

    ... ... ... ... .... 
  PrepareForBuild:
    Creating directory "x64\Debug\INSTALL\".
    Creating directory "x64\Debug\INSTALL\INSTALL.tlog\".
  InitializeBuildStatus:
    Creating "x64\Debug\INSTALL\INSTALL.tlog\unsuccessfulbuild" because "AlwaysCreate" was specified.
  PostBuildEvent:
    setlocal
    "C:\Program Files\CMake\bin\cmake.exe" -DBUILD_TYPE=Debug -P cmake_install.cmake
    if %errorlevel% neq 0 goto :cmEnd
    :cmEnd
    endlocal & call :cmErrorLevel %errorlevel% & goto :cmDone
    :cmErrorLevel
    exit /b %1
    :cmDone
    if %errorlevel% neq 0 goto :VCEnd
    :VCEnd
    -- Install configuration: "Debug"
    -- Installing: C:/Users/archbox/Desktop/spdlogtest/./bin/AppDemo1.exe
    -- Up-to-date: C:/Users/archbox/Desktop/spdlogtest/bin/fmtd.dll
  FinalizeBuildStatus:
    Deleting file "x64\Debug\INSTALL\INSTALL.tlog\unsuccessfulbuild".
    Touching "x64\Debug\INSTALL\INSTALL.tlog\INSTALL.lastbuildstate".
  Done Building Project "C:\Users\archbox\Desktop\spdlogtest\build\install.vcxproj" (default targets).
  Build succeeded.
   .... ... .... ... .... ... .... ...
#+END_SRC

Run install target on Linux:

#+BEGIN_SRC sh 
  $ cmake --build build --target install
  [2/3] Install the project...
  -- Install configuration: ""
  -- Installing: /home/archbox/root-scripts/spdlog/./bin/AppDemo1
#+END_SRC

Check install output on Windows:

#+BEGIN_SRC sh 
  $ ls bin
  AppDemo1.exe*  fmtd.dll*
#+END_SRC

Check install output on Linux:

#+BEGIN_SRC sh 
  $ ls bin/
  AppDemo1*
#+END_SRC

Run program: 

#+BEGIN_SRC sh 
   # Run on Windows
   bin\AppDemo1.exe 

   [2019-01-09 16:17:13.360] [stdout-console] [info] Testing logging information to command line
   [2019-01-09 16:17:13.361] [stdout-console] [info] Welcome to spdlog version 1.2.0 !
   [2019-01-09 16:17:13.361] [stdout-console] [warning] Easy padding in numbers like 00000012
   [2019-01-09 16:17:13.361] [stdout-console] [critical] Support for int: 42;  hex: 2a;  oct: 52; bin: 101010
   [2019-01-09 16:17:13.361] [stdout-console] [info] Support for floats 1.23
   [2019-01-09 16:17:13.362] [stdout-console] [info] Positional args are supported too..
   [2019-01-09 16:17:13.362] [stdout-console] [info]    right aligned, left     aligned
   Vec1 = [3](2.2,2.2,-5.1)
   3.0 * Vec1 = [3](6.6,6.6,-15.3)
   Norm1(Vec1) = 9.5
   Vec2 - Vec1 = [3](-3.4,-3.4,6.2)

    Enter RETURN to exit
#+END_SRC

** Example: Project with OpenGL + FreeGLUT 

GIST: [[https://gist.github.com/caiorss/4e36d7423cfd456f39c26ba476873a3c][Cmake C++ project with VCPKG package manager and OpengGL/FreeGlut]]

File: *CMakeLists.txt*

#+BEGIN_SRC cmake 
  cmake_minimum_required(VERSION 3.9)

  if(DEFINED ENV{VCPKG_ROOT} AND NOT DEFINED CMAKE_TOOLCHAIN_FILE)
    set(CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"
      CACHE STRING "")
      message(" [INFO] VCPKG CMAKE_TOOLCHAIN_FILE = ${CMAKE_TOOLCHAIN_FILE}")
  endif()

  #========== Global Configurations =============#
  #----------------------------------------------#
  project(OpengGL_Widnows)
  set(CMAKE_CXX_STANDARD 17)     
  set(CMAKE_VERBOSE_MAKEFILE ON)

  find_package(OpenGL REQUIRED)
  find_package(GLUT REQUIRED)
  find_package(GLU  REQUIRED)

  #========== Targets Configurations ============#

  # Build an executable (Unix-like OSes generates ./openglDemo1, on
  # Windows ./opengDemo1.exe)
  # ..........................................
  add_executable(openglDemo1 opengl1.cpp)
  target_link_libraries(openglDemo1 PRIVATE GLUT::GLUT)

  if(UNIX)
    target_link_libraries(openglDemo1 PRIVATE GL)
  endif()

  # Add extension .bin to executable name to make it easier
  # to identify that the binary file is an executable.
  # So, it turns  openglDemo1 becomes openglDemo1.bin 
  if(UNIX)
    set_target_properties(openglDemo1 PROPERTIES SUFFIX ".bin")
  endif()

  # Add target to run executable 
  add_custom_target(run-ex1
      COMMAND openglDemo1 
      DEPENDS openglDemo1 
      WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
  )

  # It installs (copies) the target files to a path relative to CMAKE_INSTALL_PREFIX
  # So, it will copy the built files to ${CMAKE_INSTALL_PREFIX}/out
  message(" Freeglut DLL = ${GLUT_RUNTIME_LIBRARY} ${FREEGLUT_DYNAMIC}
  ") install(TARGETS openglDemo1 DESTINATION out) install(FILES
  "${CMAKE_CURRENT_BINARY_DIR}/freeglut.dll" DESTINATION out)
#+END_SRC

File: *opengl1.cpp*

#+BEGIN_SRC cpp 
  #include <iostream>
  #if defined(_WIN32)
    #include <windows.h>
  #endif 
  #include <GL/gl.h>
  #include <GL/glu.h>
  #include <GL/glut.h>

  void renderFunction();

  int main(int argc, char ** argv){

      std::cerr << "[INFO] Starting OpenGL main loop." << std::endl;
	
      glutInit(&argc, argv);  
      glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
      glutInitWindowSize(500, 500);
      glutCreateWindow("Window 1");
      // Display Callback Function 
      glutDisplayFunc(&renderFunction);
      // Start main loop 
      glutMainLoop();
      std::cerr << "[INFO] Exit OpenGL main loop." << std::endl;
      return 0;
  }

  void renderFunction(){
          std::cerr << "[INFO] Running loop." << std::endl;
      // Clear the current output buffer
      glClear(GL_COLOR_BUFFER_BIT);   

      // Rotate 10 degrees counterclockwise around z axis
      glRotated(10, 0, 0, 1);

      // Set the current color (RGB) drawing to blue
      glColor3f(0.0, 0.0, 1.0);

      // Start polygon 
      glBegin(GL_POLYGON);
      glVertex3f(-0.5, -0.5, 0);
      glVertex3f( 0.5, -0.5, 0);
      glVertex3f( 0.5,  0.5, 0);
      glVertex3f(-0.5,  0.5, 0);
      // End polygon 
      glEnd();

      glFlush();
  }

#+END_SRC

Install FreeGlut library: 

Search FreeGlut library: 

#+BEGIN_SRC sh 
   $ vcpkg search freeglut

   freeglut             3.0.0-5          Open source implementation of GLUT with source and binary backwards compatibil...

   If your library is not listed, please open an issue at and/or consider making a pull request:
       https://github.com/Microsoft/vcpkg/issues
#+END_SRC

Install FreeGlut Library:

 + $ vcpkg install freeglut:x64-Windows
   + Install library compiled for 64 bits target. 

 + $ vcpkg install freeglut:x86-Windows
   + Install library compiled for x86 bits target. 

#+BEGIN_SRC sh 
  $ vcpkg install freeglut:x64-Windows

  The following packages will be built and installed:
      freeglut[core]:x64-windows
  Starting package 1/1: freeglut:x64-windows
  Building package freeglut[core]:x64-windows...
  A suitable version of git was not found (required v2.20.0). Downloading portable git v2.20.0...
  Downloading git...
    https://github.com/git-for-windows/git/releases/download/v2.20.0.windows.1/PortableGit-2.20.0-32-bit.7z.exe -> C:\vcpkg\downloads\PortableGit-2.20.0-32-bit.7z.exe
  Extracting git...
  A suitable version of 7zip was not found (required v18.1.0). Downloading portable 7zip v18.1.0...
  Downloading 7zip...
    https://www.nuget.org/api/v2/package/7-Zip.CommandLine/18.1.0 -> C:\vcpkg\downloads\7-zip.commandline.18.1.0.nupkg
  Extracting 7zip...
  A suitable version of nuget was not found (required v4.6.2). Downloading portable nuget v4.6.2...
  Downloading nuget...
    https://dist.nuget.org/win-x86-commandline/v4.6.2/nuget.exe -> C:\vcpkg\downloads\nuget.exe
  -- Downloading http://downloads.sourceforge.net/project/freeglut/freeglut/3.0.0/freeglut-3.0.0.tar.gz...
  -- Extracting source C:/vcpkg/downloads/freeglut-3.0.0.tar.gz
  -- Configuring x64-windows
  -- Building x64-windows-dbg
  -- Building x64-windows-rel
  -- Performing post-build validation
  -- Performing post-build validation done
  Building package freeglut[core]:x64-windows... done
  Installing package freeglut[core]:x64-windows...
  Installing package freeglut[core]:x64-windows... done
  Elapsed time for package freeglut:x64-windows: 2.215 min

  Total elapsed time: 2.215 min

  The package freeglut is compatible with built-in CMake targets:

      find_package(GLUT REQUIRED)
      target_link_libraries(main PRIVATE GLUT::GLUT)
#+END_SRC

Clone the GIST for avoiding crating the sources manually: 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/caiorss/4e36d7423cfd456f39c26ba476873a3c opengl-cmake-demo
  Cloning into 'opengl-cmake-demo'...
  remote: Enumerating objects: 4, done.
  remote: Counting objects: 100% (4/4), done.
  remote: Compressing objects: 100% (4/4), done.
  Unpacking objects: 100% (4/4), done.
  remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0

  $ cd opengl-cmake-demo\

  $ dir
   Volume in drive C has no label.
   Volume Serial Number is 

   Directory of C:\Users\archbox\Desktop\opengl-cmake-demo

  01/08/2019  05:57 PM    <DIR>          .
  01/08/2019  05:57 PM    <DIR>          ..
  01/08/2019  05:57 PM             1,630 CMakeLists.txt
  01/08/2019  05:57 PM             1,188 opengl1.cpp
                 2 File(s)          2,818 bytes
                 2 Dir(s)   1,157,586,944 bytes free

#+END_SRC

Perform CMake configuration step generating building scripts:

#+BEGIN_SRC sh 
    $ cmake -H. -Bbuild -G "Visual Studio 15 2017 Win64" -DCMAKE_INSTALL_PREFIX=.
     [INFO] VCPKG CMAKE_TOOLCHAIN_FILE = C:\vcpkg/scripts/buildsystems/vcpkg.cmake
    -- The C compiler identification is MSVC 19.16.27025.1
    -- The CXX compiler identification is MSVC 19.16.27025.1
     ... ...  ... ...  ... ...  ... ...  ... ...  ... ...  ... ... 
    -- Detecting CXX compiler ABI info - done
    -- Detecting CXX compile features
    -- Detecting CXX compile features - done
    -- Found OpenGL: opengl32
    -- Found GLUT: C:/vcpkg/installed/x64-windows/debug/lib/freeglut.lib
    -- WARNING: you are using the obsolete 'GLU' package, please use 'OpenGL' instead
     Freeglut DLL =
    -- Configuring done
    -- Generating done
    -- Build files have been written to: C:/Users/archbox/Desktop/opengl-cmake-demo/build
#+END_SRC

Build all targets: 

 + $ cmake --build build --config debug
 + $ cmake --build build --config release 
 
#+BEGIN_SRC sh 
  $ cmake --build build --config debug

  Microsoft (R) Build Engine version 15.9.21+g9802d43bc3 for .NET Framework
  Copyright (C) Microsoft Corporation. All rights reserved.

  Build started 1/8/2019 6:02:01 PM.
  Project "C:\Users\archbox\Desktop\opengl-cmake-demo\build\ALL_BUILD.vcxproj" on node 1 (default targets).
  Project "C:\Users\archbox\Desktop\opengl-cmake-demo\build\ALL_BUILD.vcxproj" (1) is building "C:\Users\archbox\Desktop\opengl-cmake-demo\buil d\ZERO_CHECK.vcxproj" (2) on node 1 (default targets).

   .. .. .   ... .. .   ... .. .   ... .. .   ... .. .   ... .. .   ... .. .   ... .. .   ... .. . 

  ClCompile:
    C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\VC\Tools\MSVC\14.16.27023\bin\HostX86\x64\CL.exe /c /I"C:\vcpkg\installed\x6
    4-windows\include" /Zi /W3 /WX- /diagnostics:classic /Od /Ob0 /D WIN32 /D _WINDOWS /D "CMAKE_INTDIR=\"Debug\"" /D _MBCS /Gm- /EHsc /RTC1 /M
    Dd /GS /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /GR /std:c++17 /Fo"openglDemo1.dir\Debug\\" /Fd"openglDemo1.dir\Debug\vc141.pdb" /Gd
     /TP /errorReport:queue "C:\Users\archbox\Desktop\opengl-cmake-demo\opengl1.cpp"
    Microsoft (R) C/C++ Optimizing Compiler Version 19.16.27025.1 for x64
    opengl1.cpp
    Copyright (C) Microsoft Corporation.  All rights reserved.

    cl /c /I"C:\vcpkg\installed\x64-windows\include" /Zi /W3 /WX- /diagnostics:classic /Od /Ob0 /D WIN32 /D _WINDOWS /D "CMAKE_INTDIR=\"Debug\"
    " /D _MBCS /Gm- /EHsc /RTC1 /MDd /GS /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /GR /std:c++17 /Fo"openglDemo1.dir\Debug\\" /Fd"opengl
    Demo1.dir\Debug\vc141.pdb" /Gd /TP /errorReport:queue "C:\Users\archbox\Desktop\opengl-cmake-demo\opengl1.cpp"

  Link:
    C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\VC\Tools\MSVC\14.16.27023\bin\HostX86\x64\link.exe /ERRORREPORT:QUEUE /OUT:"
    C:\Users\archbox\Desktop\opengl-cmake-demo\build\Debug\openglDemo1.exe" /INCREMENTAL /NOLOGO "C:\vcpkg\installed\x64-windows\debug\lib\free
    glut.lib" kernel32.lib user32.lib gdi32.lib winspool.lib shell32.lib ole32.lib oleaut32.lib uuid.lib comdlg32.lib advapi32.lib /MANIFEST /M
    ANIFESTUAC:"level='asInvoker' uiAccess='false'" /manifest:embed /DEBUG /PDB:"C:/Users/archbox/Desktop/opengl-cmake-demo/build/Debug/openglD
    emo1.pdb" /SUBSYSTEM:CONSOLE /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"C:/Users/archbox/Desktop/opengl-cmake-demo/build/Debug/openglDemo1.li
    b" /MACHINE:X64  /machine:x64 openglDemo1.dir\Debug\opengl1.obj

  ....   ....   ....   ....   ....   ....   ....   ....   ....   ....   ....   ....   ....   ....   ....   ....   ....   .... 

  Done Building Project "C:\Users\archbox\Desktop\opengl-cmake-demo\build\ALL_BUILD.vcxproj" (default targets).


  Build succeeded.
      0 Warning(s)
      0 Error(s)

  Time Elapsed 00:00:06.76
#+END_SRC

Run executable (target run-ex1):

 + This is conveniced target was added for making easier to run the
   executable from the terminal. It is not needed for IDEs like Visual
   Studio, JetBrains - Clion and so on. 

#+BEGIN_SRC sh 
  $ cmake --build build --target run-ex1
#+END_SRC


Compile and run on Linux: 

#+BEGIN_SRC sh 
  $ vcpkg install freeglut   
  $ git clone https://gist.github.com/caiorss/4e36d7423cfd456f39c26ba476873a3c opengl
  $ cd opengl 
  $ cmake -H. -Bbuild 
  $ cmake --build build --target run-ex1 
#+END_SRC

** Example: Project with Nana GUI Library 

GIST: [[https://gist.github.com/caiorss/724942d43cd11c6ee5b3461ac067c846][Nana GUI + VCPKG + CMake project]]

File: *CMakeLists.txt*

#+BEGIN_SRC cmake 
   cmake_minimum_required(VERSION 3.9)

   if(DEFINED ENV{VCPKG_ROOT} AND NOT DEFINED CMAKE_TOOLCHAIN_FILE)
     set(CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"
       CACHE STRING "")
       message(" [INFO] VCPKG CMAKE_TOOLCHAIN_FILE = ${CMAKE_TOOLCHAIN_FILE}")
   endif()

   #======= Global Project Configuration =========#

   project(DummyProject)
   set(CMAKE_CXX_STANDARD 17)     

   #========== Targets Configurations ============#

   ## ==> Target: gui1 - Executable: gui1

   find_package(unofficial-nana CONFIG REQUIRED)
   add_executable(gui1 gui1.cpp)
   target_link_libraries(gui1 PRIVATE
     unofficial::nana::nana fontconfig stdc++fs)

   # Add target to run executable gui1 (similar to $ make run)
   add_custom_target(run-gui1
       COMMAND gui1
       DEPENDS gui1
       WORKING_DIRECTORY ${CMAKE_PROJECT_DIR}
   )

   # Install directory relative to ${CMAKE_PREFIX_PATH}
   install(TARGETS gui1 DESTINATION ./bin)
#+END_SRC

File: *gui1.cpp*

 + Note: Demo code taken from - http://nanapro.org/en-us/

#+BEGIN_SRC cpp 
  #include <nana/gui.hpp>
  #include <nana/gui/widgets/label.hpp>
  #include <nana/gui/widgets/button.hpp>

  int main()
  {
      using namespace nana;

      //Define a form.
      form fm;
      //Define a label and display a text.
      label lab{fm, "Hello, <bold blue size=16>Nana C++ Library</>"};
      lab.format(true);
      //Define a button and answer the click event.
      button btn{fm, "Quit"};
      btn.events().click([&fm]{
          fm.close();
      });
      //Layout management
      fm.div("vert <><<><weight=80% text><>><><weight=24<><button><>><>");
      fm["text"]<<lab;
      fm["button"] << btn;
      fm.collocate();
      //Show the form
      fm.show();
      //Start to event loop process, it blocks until the form is closed.
      exec();
  }
#+END_SRC

Project directory: 

#+BEGIN_SRC sh 
  $ tree -L 1
  .
  ├── build
  ├── CMakeLists.txt
  └── gui1.cpp

  1 directory, 2 files
#+END_SRC

Install Linux dependency libraries (Tested on Linux Fedora): 

 + Note: Sometimes VCPKG cannot install system libraries. In this
   case, it is necessary to use the current distribution package
   manager. 

#+BEGIN_SRC sh 
  $ sudo dnf install libX11-devel.x86_x64
  $ sudo dnf install libXft-devel.x86_64
#+END_SRC

Clone gist containing the project: 

#+BEGIN_SRC sh 
  $ git clone https://gist.github.com/caiorss/724942d43cd11c6ee5b3461ac067c846 sample-vcpkg-proj
  $ cd sample-vcpkg-proj
#+END_SRC

#+RESULTS:

 *Install package Nana with vcpkg:*

#+BEGIN_SRC sh 
  $ vcpkg install nana

   ...  ...  ...  ... 
  -- Using cached /home/archbox/opt/vcpkg/downloads/cnjinhao-nana-v1.6.2.tar.gz
  -- Using source at /home/archbox/opt/vcpkg/buildtrees/nana/src/v1.6.2-51b575c248
  -- Configuring x64-linux-dbg
  -- Configuring x64-linux-rel
  -- Building x64-linux-dbg
  -- Building x64-linux-rel
  -- Performing post-build validation
  -- Performing post-build validation done
  Building package nana[core]:x64-linux... done
  Installing package nana[core]:x64-linux... 
  Installing package nana[core]:x64-linux... done
  Elapsed time for package nana:x64-linux: 1.825 min

  Total elapsed time: 1.825 min

  The package nana:x64-linux provides CMake targets:

      find_package(unofficial-nana CONFIG REQUIRED)
      target_link_libraries(main PRIVATE unofficial::nana::nana)
#+END_SRC

List installed packages: 

#+BEGIN_SRC sh 
   $ vcpkg list
   boost-accumulators:x64-linux                       1.68.0           Boost accumulators module
   boost-algorithm:x64-linux                          1.68.0           Boost algorithm module
   boost-any:x64-linux                                1.68.0           Boost any module
   boost-array:x64-linux                              1.68.0           Boost array module

   ... ... ...   ... ... ...   ... ... ...   ... ... ...   ... ... ...   ... ... ...   ... ... ...
  
   gsl:x64-linux                                      2.4-3            The GNU Scientific Library is a numerical librar...
   gtest:x64-linux                                    1.8.1-1          GoogleTest and GoogleMock testing frameworks.
   libiconv:x64-linux                                 1.15-5           GNU Unicode text conversion
   libjpeg-turbo:x64-linux                            1.5.3-1          libjpeg-turbo is a JPEG image codec that uses SI...
   liblzma:x64-linux                                  5.2.4            Compression library with an API similar to that ...
   libpng:x64-linux                                   1.6.35-1         libpng is a library implementing an interface fo...
   nana:x64-linux                                     1.6.2            Cross-platform library for GUI programming in mo...
   pybind11:x64-linux                                 2.2.3-1          pybind11 is a lightweight header-only library th...
   spdlog:x64-linux                                   1.2.1            Very fast, header only, C++ logging library
   zlib:x64-linux                                     1.2.11-3         A compression librar
#+END_SRC

Filter nana package: 

#+BEGIN_SRC sh 
   $ vcpkg list | grep nana
   nana:x64-linux                                     1.6.2            Cross-platform library for GUI programming in mo...
#+END_SRC

 *Building with CMake Ninja or Makefile*

Cmake configuration step

 + Default system building system
   + $ cmake -H. -Bbuild 

 + Ninja building System:
   + $ cmake -H. -Bbuild -G Ninja

#+BEGIN_SRC sh 
  # Install executable at (.) curret directory
  $ cmake -H. -Bbuild -G Ninja  -DCMAKE_PREFIX_PATH=.

   [INFO] VCPKG CMAKE_TOOLCHAIN_FILE = /home/archbox/opt/vcpkg/scripts/buildsystems/vcpkg.cmake
  -- The C compiler identification is GNU 8.2.1
  -- The CXX compiler identification is GNU 8.2.1
  -- Check for working C compiler: /usr/lib64/ccache/cc

   ... ... ... ... ... ... 

  -- Found Freetype: /home/archbox/build/vcpkg/installed/x64-linux/lib/libfreetype.a (found version "2.8.1") 
  -- Found ZLIB: /home/archbox/build/vcpkg/installed/x64-linux/debug/lib/libz.a (found version "1.2.11") 
  -- Found PNG: /home/archbox/build/vcpkg/installed/x64-linux/share/png/../../lib/libpng16.a (found version "1.6.35") 
  -- Found BZip2: /home/archbox/build/vcpkg/installed/x64-linux/lib/libbz2.a (found version "1.0.6") 
  -- Looking for BZ2_bzCompressInit
  -- Looking for BZ2_bzCompressInit - found
  -- Looking for XOpenDisplay in /usr/lib64/libX11.so;/usr/lib64/libXext.so
  -- Looking for XOpenDisplay in /usr/lib64/libX11.so;/usr/lib64/libXext.so - found

   ... ... ... ... ... ... 

  -- Looking for shmat - found
  -- Found X11: /usr/lib64/libX11.so
  -- Found JPEG: /home/archbox/build/vcpkg/installed/x64-linux/debug/lib/libjpeg.a  
  -- Configuring done
  -- Generating done
  -- Build files have been written to: /home/archbox/root-scripts/vcpkg2/build
#+END_SRC

Build all targets: 

#+BEGIN_SRC sh 
 $ cmake --build build --target 
#+END_SRC

Build and run executable target gui1 (target: run-gui1)

#+BEGIN_SRC sh 
  $ cmake --build build --target run-gui1
  [3/3] cd /home/archbox/root-scripts/vcpkg2/build && /home/archbox/root-scripts/vcpkg2/build/gui1
#+END_SRC

Install executable: 

#+BEGIN_SRC sh 
  $ cmake --build build --target install
  [2/3] Install the project...
  -- Install configuration: ""
  -- Installing: /home/archbox/root-scripts/vcpkg2/./bin/gui1
#+END_SRC

Run installed executable at ./bin 

#+BEGIN_SRC sh 
  $ bin/gui1 
#+END_SRC

Directory after compilation: 

#+BEGIN_SRC sh 
  $ tree . -L 2
  .
  ├── bin
  │   └── gui1
  ├── build
  │   ├── build.ninja
  │   ├── CMakeCache.txt
  │   ├── CMakeFiles
  │   ├── cmake_install.cmake
  │   ├── gui1
  │   ├── install_manifest.txt
  │   └── rules.ninja
  ├── CMakeLists.txt
  └── gui1.cpp

  3 directories, 9 files
#+END_SRC

 *Analyse executable:*

Check binary format 

#+BEGIN_SRC sh 
  $ file bin/gui1 

  bin/gui1: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux),
  dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for
  GNU/Linux 3.2.0,
  BuildID[sha1]=b2273c2b397213af8c8b8e8808da1ebc195d3b4d, with
  debug_info, not stripped
#+END_SRC

Check file size 

#+BEGIN_SRC sh
  # File size 
  $ du -h bin/gui1
  19M	bin/gui1
  19M	total
#+END_SRC

Remove debugging symbols 

#+BEGIN_SRC sh 
  $ strip bin/gui1 
#+END_SRC

Check file size again: 

#+BEGIN_SRC sh 
  $ du -h bin/gui1
  3.3M	bin/gui1
  3.3M	total
#+END_SRC

Check shared libraries dependencies:

#+BEGIN_SRC sh 
   $ ldd bin/gui1
           linux-vdso.so.1 (0x00007fff18930000)
           libfontconfig.so.1 => /lib64/libfontconfig.so.1 (0x00007f5f73116000)
           libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f5f72ef7000)
           libX11.so.6 => /lib64/libX11.so.6 (0x00007f5f72bb6000)
           libXext.so.6 => /lib64/libXext.so.6 (0x00007f5f729a4000)
           libXft.so.2 => /lib64/libXft.so.2 (0x00007f5f7278d000)
           libstdc++.so.6 => /lib64/libstdc++.so.6 (0x00007f5f723fa000)
           libm.so.6 => /lib64/libm.so.6 (0x00007f5f72066000)
           libgcc_s.so.1 => /lib64/libgcc_s.so.1 (0x00007f5f71e4e000)
           libc.so.6 => /lib64/libc.so.6 (0x00007f5f71a8f000)
           libfreetype.so.6 => /lib64/libfreetype.so.6 (0x00007f5f717d8000)
           libexpat.so.1 => /lib64/libexpat.so.1 (0x00007f5f7159d000)
           libuuid.so.1 => /lib64/libuuid.so.1 (0x00007f5f71396000)
           /lib64/ld-linux-x86-64.so.2 (0x00007f5f7335a000)
           libxcb.so.1 => /lib64/libxcb.so.1 (0x00007f5f7116d000)
           libdl.so.2 => /lib64/libdl.so.2 (0x00007f5f70f69000)
           libXrender.so.1 => /lib64/libXrender.so.1 (0x00007f5f70d5e000)
           libbz2.so.1 => /lib64/libbz2.so.1 (0x00007f5f70b4d000)
           libpng16.so.16 => /lib64/libpng16.so.16 (0x00007f5f70919000)
           libz.so.1 => /lib64/libz.so.1 (0x00007f5f70702000)
           libXau.so.6 => /lib64/libXau.so.6 (0x00007f5f704fe000)
#+END_SRC



